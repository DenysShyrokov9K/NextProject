webpackJsonp([0],[
/* 0 */
/***/ (function(module, exports) {

module.exports = window.React;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;

  var isValidElement = function isValidElement(object) {
    return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(80)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(83)();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.KEYCODE = exports.guid = exports.focus = exports.support = exports.str = exports.obj = exports.log = exports.func = exports.events = exports.env = exports.dom = undefined;

var _dom2 = __webpack_require__(40);

var _dom = _interopRequireWildcard(_dom2);

var _env2 = __webpack_require__(42);

var _env = _interopRequireWildcard(_env2);

var _events2 = __webpack_require__(86);

var _events = _interopRequireWildcard(_events2);

var _func2 = __webpack_require__(87);

var _func = _interopRequireWildcard(_func2);

var _log2 = __webpack_require__(88);

var _log = _interopRequireWildcard(_log2);

var _object2 = __webpack_require__(13);

var _object = _interopRequireWildcard(_object2);

var _string2 = __webpack_require__(41);

var _string = _interopRequireWildcard(_string2);

var _support2 = __webpack_require__(89);

var _support = _interopRequireWildcard(_support2);

var _focus2 = __webpack_require__(90);

var _focus = _interopRequireWildcard(_focus2);

var _guid2 = __webpack_require__(91);

var _guid3 = _interopRequireDefault(_guid2);

var _keycode = __webpack_require__(43);

var _keycode2 = _interopRequireDefault(_keycode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var dom = exports.dom = _dom;
var env = exports.env = _env;
var events = exports.events = _events;
var func = exports.func = _func;
var log = exports.log = _log;
var obj = exports.obj = _object;
var str = exports.str = _string;
var support = exports.support = _support;
var focus = exports.focus = _focus;
var guid = exports.guid = _guid3.default;
var KEYCODE = exports.KEYCODE = _keycode2.default;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg === 'undefined' ? 'undefined' : _typeof(arg);

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if ("function" === 'function' && _typeof(__webpack_require__(73)) === 'object' && __webpack_require__(73)) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
})();

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = window.ReactDOM;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _getContextProps = __webpack_require__(39);

var _getContextProps2 = _interopRequireDefault(_getContextProps);

var _config = __webpack_require__(84);

var _consumer = __webpack_require__(92);

var _consumer2 = _interopRequireDefault(_consumer);

var _cache = __webpack_require__(93);

var _cache2 = _interopRequireDefault(_cache);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var childContextCache = new _cache2.default();

/**
 * ConfigProvider
 * @propsExtends false
 */
var ConfigProvider = (_temp = _class = function (_Component) {
    _inherits(ConfigProvider, _Component);

    /**
     * 传入组件的 props 和 displayName，得到和 childContext 计算过的包含有 preifx/locale/pure 的对象，一般用于通过静态方法生成脱离组件树的组件
     * @param {Object} props 组件的 props
     * @param {String} displayName 组件的 displayName
     * @returns {Object} 新的 context props
     */
    function ConfigProvider() {
        _classCallCheck(this, ConfigProvider);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args)));

        childContextCache.add(_this, _extends({}, childContextCache.get(_this, {}), _this.getChildContext()));
        return _this;
    }

    /**
     * 传入组件，生成受 ConfigProvider 控制的 HOC 组件
     * @param {Component} Component 组件类
     * @param {Object} options 可选项
     * @returns {Component} HOC
     */


    ConfigProvider.prototype.getChildContext = function getChildContext() {
        var _props = this.props,
            prefix = _props.prefix,
            locale = _props.locale,
            pure = _props.pure,
            warning = _props.warning,
            rtl = _props.rtl;


        return {
            nextPrefix: prefix,
            nextLocale: locale,
            nextPure: pure,
            nextRtl: rtl,
            nextWarning: warning
        };
    };

    ConfigProvider.prototype.componentWillMount = function componentWillMount() {
        this.setMomentLocale(this.props.locale);
    };

    ConfigProvider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (this.props.locale !== nextProps.locale) {
            this.setMomentLocale(nextProps.locale);
        }
    };

    ConfigProvider.prototype.componentDidUpdate = function componentDidUpdate() {
        childContextCache.add(this, _extends({}, childContextCache.get(this, {}), this.getChildContext()));
    };

    ConfigProvider.prototype.componentWillUnmount = function componentWillUnmount() {
        childContextCache.remove(this);
    };

    ConfigProvider.prototype.setMomentLocale = function setMomentLocale(locale) {
        var moment = void 0;
        try {
            moment = __webpack_require__(94);
        } catch (e) {
            // ignore
        }

        if (moment && locale) {
            moment.locale(locale.momentLocale);
        }
    };

    ConfigProvider.prototype.render = function render() {
        return _react.Children.only(this.props.children);
    };

    return ConfigProvider;
}(_react.Component), _class.propTypes = {
    /**
     * 样式类名的品牌前缀
     */
    prefix: _propTypes2.default.string,
    /**
     * 国际化文案对象，属性为组件的 displayName
     */
    locale: _propTypes2.default.object,
    /**
     * 是否开启 Pure Render 模式，会提高性能，但是也会带来副作用
     */
    pure: _propTypes2.default.bool,
    /**
     * 是否在开发模式下显示组件属性被废弃的 warning 提示
     */
    warning: _propTypes2.default.bool,
    /**
     * 是否开启 rtl 模式
     */
    rtl: _propTypes2.default.bool,
    /**
     * 组件树
     */
    children: _propTypes2.default.element
}, _class.defaultProps = {
    warning: true
}, _class.childContextTypes = {
    nextPrefix: _propTypes2.default.string,
    nextLocale: _propTypes2.default.object,
    nextPure: _propTypes2.default.bool,
    nextRtl: _propTypes2.default.bool,
    nextWarning: _propTypes2.default.bool
}, _class.config = function (Component, options) {
    return (0, _config.config)(Component, options);
}, _class.getContextProps = function (props, displayName) {
    return (0, _getContextProps2.default)(props, childContextCache.root() || {}, displayName);
}, _class.initLocales = _config.initLocales, _class.setLanguage = _config.setLanguage, _class.setLocale = _config.setLocale, _class.setDirection = _config.setDirection, _class.getLanguage = _config.getLanguage, _class.getLocale = _config.getLocale, _class.getDirection = _config.getDirection, _class.Consumer = _consumer2.default, _class.getContext = function () {
    var _ref = childContextCache.root() || {},
        nextPrefix = _ref.nextPrefix,
        nextLocale = _ref.nextLocale,
        nextPure = _ref.nextPure,
        nextRtl = _ref.nextRtl,
        nextWarning = _ref.nextWarning;

    return {
        prefix: nextPrefix,
        locale: nextLocale,
        pure: nextPure,
        rtl: nextRtl,
        warning: nextWarning
    };
}, _temp);
ConfigProvider.displayName = 'ConfigProvider';
exports.default = ConfigProvider;
module.exports = exports['default'];

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			memo[selector] = fn.call(this, selector);
		}

		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(143);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var blackList = ['defaultProps', 'propTypes', 'contextTypes', 'childContextTypes', 'displayName'];

var statics = exports.statics = function statics(Target, Component) {
    Object.keys(Component).forEach(function (property) {
        if (blackList.indexOf(property) === -1) {
            Target[property] = Component[property];
        }
    });
};

var fetchDataByPath = exports.fetchDataByPath = function fetchDataByPath(object, path) {
    if (!object || !path) {
        return false;
    }
    path = path.toString();
    var field = path.split('.');
    var val = void 0,
        key = void 0;
    if (field.length) {
        key = field[0];
        // lists[1].name
        if (key.indexOf('[') >= 0) {
            key = key.match(/(.*)\[(.*)\]/);
            if (key) {
                val = object[key[1]][key[2]];
            }
        } else {
            val = object[field[0]];
        }
        if (val) {
            for (var colIndex = 1; colIndex < field.length; colIndex++) {
                val = val[field[colIndex]];
                if (typeof val === 'undefined') {
                    break;
                }
            }
        }
    }
    return val;
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Icon
 */
var Icon = (_temp = _class = function (_Component) {
    _inherits(Icon, _Component);

    function Icon() {
        _classCallCheck(this, Icon);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    Icon.prototype.render = function render() {
        var _cx;

        /* eslint-disable no-unused-vars*/
        var _props = this.props,
            prefix = _props.prefix,
            type = _props.type,
            size = _props.size,
            className = _props.className,
            rtl = _props.rtl,
            other = _objectWithoutProperties(_props, ['prefix', 'type', 'size', 'className', 'rtl']);

        var classes = (0, _classnames2.default)((_cx = {}, _cx[prefix + 'icon'] = true, _cx[prefix + 'icon-' + type] = !!type, _cx['' + prefix + size] = !!size, _cx[className] = !!className, _cx));

        if (rtl && ['arrow-left', 'arrow-right', 'arrow-double-left', 'arrow-double-right', 'switch', 'sorting', 'descending', 'ascending'].indexOf(type) !== -1) {
            other.dir = 'rtl';
        }

        return _react2.default.createElement('i', _extends({}, other, { className: classes }));
    };

    return Icon;
}(_react.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    rtl: _propTypes2.default.bool,
    /**
     * 指定显示哪种图标
     */
    type: _propTypes2.default.string,
    /**
     * 指定图标大小
     */
    size: _propTypes2.default.oneOf(['xxs', 'xs', 'small', 'medium', 'large', 'xl', 'xxl', 'xxxl']),
    className: _propTypes2.default.string
}, _class.defaultProps = {
    prefix: 'next-',
    size: 'medium'
}, _class._typeMark = 'icon', _temp);
Icon.displayName = 'Icon';
exports.default = _configProvider2.default.config(Icon);
module.exports = exports['default'];

/***/ }),
/* 10 */,
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(142);

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(144);

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.typeOf = typeOf;
exports.isArrayLike = isArrayLike;
exports.isPromise = isPromise;
exports.isPlainObject = isPlainObject;
exports.shallowEqual = shallowEqual;
exports.each = each;
exports.pickOthers = pickOthers;
exports.pickAttrsWith = pickAttrsWith;
/**
 * 获取对象的类型
 * @param  {*} obj
 * @return {String}
 *
 * @example
 * typeOf([]) === 'Array'
 * typeOf() === 'Undefined'
 * typeOf(1) === 'Number'
 */
function typeOf(obj) {
    return Object.prototype.toString.call(obj).replace(/\[object\s|]/g, '');
}

/**
 * 判断是否是数组或类数组对象
 * @param  {*}  obj
 * @return {Boolean}
 *
 * @example
 * isArrayLike([]) === true
 * isArrayLike(arguments) === true
 * isArrayLike(this.props.children) === true
 */
function isArrayLike(obj) {
    var length = !!obj && 'length' in obj && obj.length;
    var type = typeOf(obj);

    return type === 'Array' || length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj;
}

/**
 * 判断对象是否是一个promise，即是否可以用.then
 * @param  {*}  obj
 * @return {Boolean}
 */
function isPromise(obj) {
    return !!obj && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}

/**
 * 是否是一个纯净的对象
 * @param  {*}  obj
 * @return {Boolean}
 * @reference https://github.com/jonschlinkert/is-plain-object
 */
function isPlainObject(obj) {
    if (typeOf(obj) !== 'Object') {
        return false;
    }

    var ctor = obj.constructor;

    if (typeof ctor !== 'function') {
        return false;
    }

    var prot = ctor.prototype;

    if (typeOf(prot) !== 'Object') {
        return false;
    }

    if (!prot.hasOwnProperty('isPrototypeOf')) {
        return false;
    }

    return true;
}

/**
 * 对象浅比较
 * @param  {Object} objA
 * @param  {Object} objB
 * @param  {Function}  [compare] 手动调用方法比较
 * @return {Boolean}      对象浅比较是否相等
 *
 * @example
 * object.shallowEqual({a: 100}, {a: 100}); // true
 */
function shallowEqual(objA, objB, compare) {
    if (objA === objB) {
        return true;
    }

    // 其中一个不是object，则不相等
    if (!objA || !objB || (typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) + (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'objectobject') {
        return false;
    }

    var keyA = Object.keys(objA);
    var keyB = Object.keys(objB);
    var len = keyA.length;

    // key 数量不一致则不相等
    if (len !== keyB.length) {
        return false;
    }

    var hasCallback = typeof compare === 'function';

    for (var i = 0; i < len; i++) {
        var key = keyA[i];

        if (!Object.prototype.hasOwnProperty.call(objB, key)) {
            return false;
        }

        var valA = objA[key];
        var valB = objB[key];

        var ret = hasCallback ? compare(valA, valB, key) : void 0;

        if (ret === false || ret === void 0 && valA !== valB) {
            return false;
        }
    }

    return true;
}

/**
 * 遍历对象或数组，或者类数组，例如React中的children对象、arguments等
 * @param  {Object|Array}   obj
 * @param  {Function} callback fn(n, i) or fn(val, key)
 * @param  {Number}   [direction = 1] 是否倒序遍历，只对数组有效
 * @return {Object|Array}
 *
 * @example
 * // 遍历数组
 * object.each([100, 200, 300], (n, i) => console.log(n, i));
 * // 遍历json对象
 * object.each({a: 100, b: 200}, (value, key) => console.log(key, value));
 * // 遍历React子节点
 * object.each(this.props.children, (child, index) => console.log(child));
 * // 遍历arguments
 * object.each(arguments, (arg, i) => console.log(arg));
 */
function each(obj, callback, direction) {
    var reversed = direction === -1;
    var length = obj.length;
    var value = void 0,
        i = reversed ? length - 1 : 0;

    if (isArrayLike(obj)) {
        for (; i < length && i >= 0; reversed ? i-- : i++) {
            value = callback.call(obj[i], obj[i], i);

            if (value === false) {
                break;
            }
        }
    } else {
        for (i in obj) {
            /* istanbul ignore else */
            if (obj.hasOwnProperty(i)) {
                value = callback.call(obj[i], obj[i], i);

                if (value === false) {
                    break;
                }
            }
        }
    }

    return obj;
}

// @private 判断key是否在数组或对象中
var _isInObj = function _isInObj(key, obj, isArray) {
    return isArray ? obj.indexOf(key) > -1 : key in obj;
};

/**
 * 过滤出其它属性
 * @param  {Object|Array} holdProps 过滤的参照对象，最终的结果只保留不在参照对象中的key
 * @param  {Object} props     被过滤的对象
 * @return {Object}           others
 *
 * @example
 * object.pickOthers(FooComponent.propTypes, this.props);
 * object.pickOthers(['className', 'onChange'], this.props);
 */
function pickOthers(holdProps, props) {
    var others = {};
    var isArray = typeOf(holdProps) === 'Array';

    for (var key in props) {
        if (!_isInObj(key, holdProps, isArray)) {
            others[key] = props[key];
        }
    }

    return others;
}

/**
 * 过滤出带prefix的属性
 * @param  {Object} holdProps 过滤的参照对象，最终的结果只保留不在参照对象中的key
 * @param  {string} prefix    包含的字符串
 * @return {Object}           others
 *
 * @example
 * object.pickAttrsWith(FooComponent.propTypes, 'data-');
 */
function pickAttrsWith(holdProps, prefix) {
    var others = {};

    for (var key in holdProps) {
        if (key.match(prefix)) {
            others[key] = holdProps[key];
        }
    }

    return others;
}

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var bindCtx = _util.func.bindCtx;
var pickOthers = _util.obj.pickOthers;
var Item = (_temp = _class = function (_Component) {
    _inherits(Item, _Component);

    function Item(props) {
        _classCallCheck(this, Item);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        bindCtx(_this, ['handleClick', 'handleKeyDown']);
        return _this;
    }

    Item.prototype.componentDidMount = function componentDidMount() {
        this.itemNode = (0, _reactDom.findDOMNode)(this);

        var _props = this.props,
            parentMode = _props.parentMode,
            root = _props.root;

        if (parentMode === 'popup') {
            this.menuNode = this.itemNode.parentNode;
        } else {
            this.menuNode = (0, _reactDom.findDOMNode)(root);
            var _root$props = root.props,
                prefix = _root$props.prefix,
                header = _root$props.header,
                footer = _root$props.footer;

            if (header || footer) {
                this.menuNode = this.menuNode.querySelector('.' + prefix + 'menu-content');
            }
        }

        this.setFocus();
    };

    Item.prototype.componentDidUpdate = function componentDidUpdate() {
        this.setFocus();
    };

    Item.prototype.focusable = function focusable() {
        var _props2 = this.props,
            root = _props2.root,
            type = _props2.type,
            disabled = _props2.disabled;
        var focusable = root.props.focusable;

        return focusable && (type === 'submenu' || !disabled);
    };

    Item.prototype.getFocused = function getFocused() {
        var _props3 = this.props,
            _key = _props3._key,
            root = _props3.root;
        var focusedKey = root.state.focusedKey;

        return focusedKey === _key;
    };

    Item.prototype.setFocus = function setFocus() {
        var focused = this.getFocused();
        if (focused) {
            if (this.focusable()) {
                this.itemNode.focus({ preventScroll: true });
            }
            if (this.menuNode && this.menuNode.scrollHeight > this.menuNode.clientHeight) {
                var scrollBottom = this.menuNode.clientHeight + this.menuNode.scrollTop;
                var itemBottom = this.itemNode.offsetTop + this.itemNode.offsetHeight;
                if (itemBottom > scrollBottom) {
                    this.menuNode.scrollTop = itemBottom - this.menuNode.clientHeight;
                } else if (this.itemNode.offsetTop < this.menuNode.scrollTop) {
                    this.menuNode.scrollTop = this.itemNode.offsetTop;
                }
            }
        }
    };

    Item.prototype.handleClick = function handleClick(e) {
        e.stopPropagation();

        var _props4 = this.props,
            _key = _props4._key,
            root = _props4.root,
            disabled = _props4.disabled;


        if (!disabled) {
            root.handleItemClick(_key, this, e);

            this.props.onClick && this.props.onClick(e);
        } else {
            e.preventDefault();
        }
    };

    Item.prototype.handleKeyDown = function handleKeyDown(e) {
        var _props5 = this.props,
            _key = _props5._key,
            root = _props5.root,
            type = _props5.type;

        if (this.focusable()) {
            root.handleItemKeyDown(_key, type, this, e);
        }

        this.props.onKeyDown && this.props.onKeyDown(e);
    };

    Item.prototype.getTitle = function getTitle(children) {
        var labelString = '';

        var loop = function loop(children) {
            _react.Children.forEach(children, function (child) {
                if ((0, _react.isValidElement)(child) && child.props.children) {
                    loop(child.props.children);
                } else if (typeof child === 'string') {
                    labelString += child;
                }
            });
        };

        loop(children);

        return labelString;
    };

    Item.prototype.render = function render() {
        var _cx;

        var _props6 = this.props,
            level = _props6.level,
            root = _props6.root,
            replaceClassName = _props6.replaceClassName,
            groupIndent = _props6.groupIndent,
            component = _props6.component,
            disabled = _props6.disabled,
            className = _props6.className,
            children = _props6.children,
            needIndent = _props6.needIndent,
            parentMode = _props6.parentMode,
            _key = _props6._key;

        var others = pickOthers(Object.keys(Item.propTypes), this.props);

        var _root$props2 = root.props,
            prefix = _root$props2.prefix,
            focusable = _root$props2.focusable,
            inlineIndent = _root$props2.inlineIndent,
            itemClassName = _root$props2.itemClassName,
            rtl = _root$props2.rtl;

        var focused = this.getFocused();

        var newClassName = replaceClassName ? className : (0, _classnames2.default)((_cx = {}, _cx[prefix + 'menu-item'] = true, _cx[prefix + 'disabled'] = disabled, _cx[prefix + 'focused'] = !focusable && focused, _cx[itemClassName] = !!itemClassName, _cx[className] = !!className, _cx));
        if (disabled) {
            others['aria-disabled'] = true;
        }

        others.tabIndex = root.tabbableKey === _key ? '0' : '-1';

        if (parentMode === 'inline' && level > 1 && inlineIndent > 0 && needIndent) {
            var _extends2;

            others.style = _extends({}, others.style || {}, (_extends2 = {}, _extends2[rtl ? 'paddingRight' : 'paddingLeft'] = level * inlineIndent - (groupIndent || 0) * 0.4 * inlineIndent + 'px', _extends2));
        }
        var TagName = component;

        return _react2.default.createElement(
            TagName,
            _extends({ role: 'menuitem',
                title: this.getTitle(children)
            }, others, {
                className: newClassName,
                onClick: this.handleClick,
                onKeyDown: this.handleKeyDown }),
            _react2.default.createElement(
                'div',
                { className: prefix + 'menu-item-inner' },
                children
            )
        );
    };

    return Item;
}(_react.Component), _class.propTypes = {
    _key: _propTypes2.default.string,
    level: _propTypes2.default.number,
    groupIndent: _propTypes2.default.number,
    root: _propTypes2.default.object,
    parent: _propTypes2.default.object,
    parentMode: _propTypes2.default.oneOf(['inline', 'popup']),
    type: _propTypes2.default.oneOf(['submenu', 'item']),
    component: _propTypes2.default.string,
    disabled: _propTypes2.default.bool,
    className: _propTypes2.default.string,
    onClick: _propTypes2.default.func,
    onKeyDown: _propTypes2.default.func,
    needIndent: _propTypes2.default.bool,
    replaceClassName: _propTypes2.default.bool
}, _class.defaultProps = {
    component: 'li',
    groupIndent: 0,
    replaceClassName: false,
    needIndent: true
}, _temp);
Item.displayName = 'Item';
exports.default = Item;
module.exports = exports['default'];

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _overlay = __webpack_require__(45);

var _overlay2 = _interopRequireDefault(_overlay);

var _gateway = __webpack_require__(46);

var _gateway2 = _interopRequireDefault(_gateway);

var _position = __webpack_require__(47);

var _position2 = _interopRequireDefault(_position);

var _popup = __webpack_require__(99);

var _popup2 = _interopRequireDefault(_popup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_overlay2.default.Gateway = _gateway2.default;
_overlay2.default.Position = _position2.default;
_overlay2.default.Popup = _configProvider2.default.config(_popup2.default, {
    exportNames: ['overlay']
});

exports.default = _configProvider2.default.config(_overlay2.default, {
    exportNames: ['getContent', 'getContentNode']
});
module.exports = exports['default'];

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _row = __webpack_require__(17);

var _row2 = _interopRequireDefault(_row);

var _cell = __webpack_require__(18);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};

var Body = (_temp2 = _class = function (_React$Component) {
    _inherits(Body, _React$Component);

    function Body() {
        var _temp, _this, _ret;

        _classCallCheck(this, Body);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.getRowRef = function (i, row) {
            _this.props.rowRef(i, row);
        }, _this.onRowClick = function (record, index, e) {
            _this.props.onRowClick(record, index, e);
        }, _this.onRowMouseEnter = function (record, index, e) {
            _this.props.onRowMouseEnter(record, index, e);
        }, _this.onRowMouseLeave = function (record, index, e) {
            _this.props.onRowMouseLeave(record, index, e);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Body.prototype.render = function render() {
        var _this2 = this;

        /*eslint-disable no-unused-vars */
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            children = _props.children,
            Tag = _props.component,
            colGroup = _props.colGroup,
            loading = _props.loading,
            emptyContent = _props.emptyContent,
            components = _props.components,
            getCellProps = _props.getCellProps,
            primaryKey = _props.primaryKey,
            getRowProps = _props.getRowProps,
            dataSource = _props.dataSource,
            cellRef = _props.cellRef,
            columns = _props.columns,
            rowRef = _props.rowRef,
            onRowClick = _props.onRowClick,
            onRowMouseEnter = _props.onRowMouseEnter,
            onRowMouseLeave = _props.onRowMouseLeave,
            locale = _props.locale,
            pure = _props.pure,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'children', 'component', 'colGroup', 'loading', 'emptyContent', 'components', 'getCellProps', 'primaryKey', 'getRowProps', 'dataSource', 'cellRef', 'columns', 'rowRef', 'onRowClick', 'onRowMouseEnter', 'onRowMouseLeave', 'locale', 'pure']);

        var _components$Row = components.Row,
            Row = _components$Row === undefined ? _row2.default : _components$Row,
            _components$Cell = components.Cell,
            Cell = _components$Cell === undefined ? _cell2.default : _components$Cell;

        var empty = loading ? _react2.default.createElement(
            'span',
            null,
            '\xA0'
        ) : emptyContent || locale.empty;
        var rows = _react2.default.createElement(
            'tr',
            null,
            _react2.default.createElement(
                'td',
                { colSpan: columns.length },
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'table-empty' },
                    empty
                )
            )
        );
        if (Tag === 'div') {
            rows = _react2.default.createElement(
                'table',
                { role: 'table' },
                _react2.default.createElement(
                    'tbody',
                    null,
                    rows
                )
            );
        }
        if (dataSource.length) {
            rows = dataSource.map(function (record, index) {
                var _classnames;

                var rowProps = getRowProps(record, index) || {};
                var rowClass = rowProps.className;
                var className = (0, _classnames3.default)((_classnames = {
                    first: index === 0,
                    last: index === dataSource.length - 1
                }, _classnames[rowClass] = rowClass, _classnames));
                var expanded = record.__expanded ? 'expanded' : '';
                return _react2.default.createElement(Row, _extends({ key: '' + (record[primaryKey] || index) + expanded
                }, rowProps, {
                    ref: _this2.getRowRef.bind(_this2, index),
                    colGroup: colGroup,
                    columns: columns,
                    primaryKey: primaryKey,
                    record: record,
                    rowIndex: index,
                    prefix: prefix,
                    pure: pure,
                    cellRef: cellRef,
                    getCellProps: getCellProps,
                    className: className,
                    Cell: Cell,
                    onClick: _this2.onRowClick,
                    locale: locale,
                    onMouseEnter: _this2.onRowMouseEnter,
                    onMouseLeave: _this2.onRowMouseLeave
                }));
            });
        }
        return _react2.default.createElement(
            Tag,
            _extends({ className: className }, others),
            rows,
            children
        );
    };

    return Body;
}(_react2.default.Component), _class.propTypes = {
    loading: _propTypes2.default.bool,
    emptyContent: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    components: _propTypes2.default.object,
    getCellProps: _propTypes2.default.func,
    cellRef: _propTypes2.default.func,
    primaryKey: _propTypes2.default.string,
    getRowProps: _propTypes2.default.func,
    rowRef: _propTypes2.default.func,
    dataSource: _propTypes2.default.array,
    children: _propTypes2.default.any,
    className: _propTypes2.default.string,
    component: _propTypes2.default.string,
    colGroup: _propTypes2.default.object,
    columns: _propTypes2.default.array,
    onRowClick: _propTypes2.default.func,
    onRowMouseEnter: _propTypes2.default.func,
    onRowMouseLeave: _propTypes2.default.func,
    locale: _propTypes2.default.object
}, _class.defaultProps = {
    loading: false,
    prefix: 'next-',
    components: {},
    getCellProps: noop,
    cellRef: noop,
    primaryKey: 'id',
    getRowProps: noop,
    rowRef: noop,
    dataSource: [],
    component: 'tbody',
    columns: []
}, _temp2);
Body.displayName = 'Body';
exports.default = Body;
module.exports = exports['default'];

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames3 = __webpack_require__(3);

var _classnames4 = _interopRequireDefault(_classnames3);

var _util = __webpack_require__(2);

var _util2 = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};

var Row = (_temp2 = _class = function (_React$Component) {
    _inherits(Row, _React$Component);

    function Row() {
        var _temp, _this, _ret;

        _classCallCheck(this, Row);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onClick = function (e) {
            var _this$props = _this.props,
                record = _this$props.record,
                rowIndex = _this$props.rowIndex;

            _this.props.onClick(record, rowIndex, e);
        }, _this.onMouseEnter = function (e) {
            var _this$props2 = _this.props,
                record = _this$props2.record,
                rowIndex = _this$props2.rowIndex;

            _this.onRowHover(record, rowIndex, true, e);
        }, _this.onMouseLeave = function (e) {
            var _this$props3 = _this.props,
                record = _this$props3.record,
                rowIndex = _this$props3.rowIndex;

            _this.onRowHover(record, rowIndex, false, e);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Row.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
        if (nextProps.pure) {
            var isEqual = _util.obj.shallowEqual(this.props, nextProps);
            return !isEqual;
        }

        return true;
    };

    Row.prototype.onRowHover = function onRowHover(record, index, isEnter, e) {
        var _props = this.props,
            onMouseEnter = _props.onMouseEnter,
            onMouseLeave = _props.onMouseLeave,
            currentRow = (0, _reactDom.findDOMNode)(this);

        if (isEnter) {
            onMouseEnter(record, index, e);
            currentRow && _util.dom.addClass(currentRow, 'hovered');
        } else {
            onMouseLeave(record, index, e);
            currentRow && _util.dom.removeClass(currentRow, 'hovered');
        }
    };

    Row.prototype.renderCells = function renderCells(record) {
        var _this2 = this;

        var _props2 = this.props,
            Cell = _props2.Cell,
            columns = _props2.columns,
            getCellProps = _props2.getCellProps,
            cellRef = _props2.cellRef,
            prefix = _props2.prefix,
            rowIndex = _props2.rowIndex,
            primaryKey = _props2.primaryKey,
            pure = _props2.pure,
            locale = _props2.locale;
        var lockType = this.context.lockType;

        return columns.map(function (child, colIndex) {
            var _classnames;

            var dataIndex = child.dataIndex,
                align = child.align,
                width = child.width,
                others = _objectWithoutProperties(child, ['dataIndex', 'align', 'width']);

            var value = (0, _util2.fetchDataByPath)(record, dataIndex);
            var attrs = getCellProps(rowIndex, colIndex, dataIndex, record) || {};

            if (_this2.context.notRenderCellIndex) {
                var matchCellIndex = _this2.context.notRenderCellIndex.map(function (cellIndex) {
                    return cellIndex.toString();
                }).indexOf([rowIndex, colIndex].toString());
                if (matchCellIndex > -1) {
                    _this2.context.notRenderCellIndex.splice(matchCellIndex, 1);
                    return null;
                }
            }
            if (attrs.colSpan && attrs.colSpan > 1 || attrs.rowSpan && attrs.rowSpan > 1) {
                _this2._getNotRenderCellIndex(colIndex, rowIndex, attrs.colSpan || 1, attrs.rowSpan || 1);
            }

            var className = (0, _classnames4.default)((_classnames = {
                first: lockType !== 'right' && colIndex === 0,
                last: lockType !== 'left' && (colIndex === columns.length - 1 || colIndex + attrs.colSpan === columns.length) }, _classnames[child.className] = child.className, _classnames));

            return _react2.default.createElement(Cell, _extends({ key: colIndex
            }, others, attrs, {
                ref: function ref(cell) {
                    return cellRef(rowIndex, colIndex, cell);
                },
                prefix: prefix,
                pure: pure,
                primaryKey: primaryKey,
                record: record,
                className: className,
                value: value,
                colIndex: colIndex,
                rowIndex: rowIndex,
                align: align,
                locale: locale,
                width: width
            }));
        });
    };

    Row.prototype._getNotRenderCellIndex = function _getNotRenderCellIndex(colIndex, rowIndex, colSpan, rowSpan) {
        var maxColIndex = colSpan;
        var maxRowIndex = rowSpan;
        var notRenderCellIndex = [];
        for (var i = 0; i < maxColIndex; i++) {
            for (var j = 0; j < maxRowIndex; j++) {
                notRenderCellIndex.push([rowIndex + j, colIndex + i]);
            }
        }
        [].push.apply(this.context.notRenderCellIndex, notRenderCellIndex);
    };

    Row.prototype.render = function render() {
        var _classnames2;

        /* eslint-disable no-unused-vars*/
        var _props3 = this.props,
            prefix = _props3.prefix,
            className = _props3.className,
            onClick = _props3.onClick,
            onMouseEnter = _props3.onMouseEnter,
            onMouseLeave = _props3.onMouseLeave,
            columns = _props3.columns,
            Cell = _props3.Cell,
            getCellProps = _props3.getCellProps,
            rowIndex = _props3.rowIndex,
            record = _props3.record,
            children = _props3.children,
            primaryKey = _props3.primaryKey,
            cellRef = _props3.cellRef,
            colGroup = _props3.colGroup,
            pure = _props3.pure,
            others = _objectWithoutProperties(_props3, ['prefix', 'className', 'onClick', 'onMouseEnter', 'onMouseLeave', 'columns', 'Cell', 'getCellProps', 'rowIndex', 'record', 'children', 'primaryKey', 'cellRef', 'colGroup', 'pure']);

        var cls = (0, _classnames4.default)((_classnames2 = {}, _classnames2[prefix + 'table-row'] = true, _classnames2[className] = className, _classnames2));
        return _react2.default.createElement(
            'tr',
            _extends({ className: cls, role: 'row' }, others, {
                onClick: this.onClick, onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave }),
            this.renderCells(record),
            children
        );
    };

    return Row;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    primaryKey: _propTypes2.default.string,
    className: _propTypes2.default.string,
    columns: _propTypes2.default.array,
    record: _propTypes2.default.any,
    Cell: _propTypes2.default.func,
    rowIndex: _propTypes2.default.number,
    getCellProps: _propTypes2.default.func,
    onClick: _propTypes2.default.func,
    onMouseEnter: _propTypes2.default.func,
    onMouseLeave: _propTypes2.default.func,
    children: _propTypes2.default.any,
    cellRef: _propTypes2.default.func,
    colGroup: _propTypes2.default.object,
    locale: _propTypes2.default.object
}, _class.defaultProps = {
    prefix: 'next-',
    primaryKey: 'id',
    columns: [],
    record: {},
    getCellProps: noop,
    onClick: noop,
    onMouseEnter: noop,
    onMouseLeave: noop,
    cellRef: noop,
    colGroup: {}
}, _class.contextTypes = {
    notRenderCellIndex: _propTypes2.default.array,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}, _temp2);
Row.displayName = 'Row';
exports.default = Row;
module.exports = exports['default'];

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var Cell = (_temp = _class = function (_React$Component) {
    _inherits(Cell, _React$Component);

    function Cell() {
        _classCallCheck(this, Cell);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    Cell.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
        if (nextProps.pure) {
            var isEqual = _util.obj.shallowEqual(this.props, nextProps);
            return !isEqual;
        }
        return true;
    };

    Cell.prototype.render = function render() {
        var _classnames;

        /* eslint-disable no-unused-vars */
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            cell = _props.cell,
            value = _props.value,
            resizable = _props.resizable,
            colIndex = _props.colIndex,
            rowIndex = _props.rowIndex,
            record = _props.record,
            context = _props.context,
            align = _props.align,
            _props$style = _props.style,
            style = _props$style === undefined ? {} : _props$style,
            Tag = _props.component,
            children = _props.children,
            title = _props.title,
            width = _props.width,
            innerStyle = _props.innerStyle,
            primaryKey = _props.primaryKey,
            __normalized = _props.__normalized,
            filterMode = _props.filterMode,
            filters = _props.filters,
            sortable = _props.sortable,
            lock = _props.lock,
            pure = _props.pure,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'cell', 'value', 'resizable', 'colIndex', 'rowIndex', 'record', 'context', 'align', 'style', 'component', 'children', 'title', 'width', 'innerStyle', 'primaryKey', '__normalized', 'filterMode', 'filters', 'sortable', 'lock', 'pure']);

        var tagStyle = _extends({}, style);
        var cellProps = { value: value, index: rowIndex, record: record, context: context };
        var content = cell;
        if (_react2.default.isValidElement(content)) {
            content = _react2.default.cloneElement(content, cellProps);
        } else if (typeof content === 'function') {
            content = content(value, rowIndex, record, context);
        }
        if (align) {
            tagStyle.textAlign = align;
        }
        var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-cell'] = true, _classnames[className] = className, _classnames));

        return _react2.default.createElement(
            Tag,
            _extends({}, others, { className: cls, style: tagStyle, role: 'gridcell' }),
            _react2.default.createElement(
                'div',
                { className: prefix + 'table-cell-wrapper', style: innerStyle },
                content,
                children
            )
        );
    };

    return Cell;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    primaryKey: _propTypes2.default.string,
    className: _propTypes2.default.string,
    record: _propTypes2.default.any,
    value: _propTypes2.default.any,
    colIndex: _propTypes2.default.number,
    rowIndex: _propTypes2.default.number,
    title: _propTypes2.default.any,
    width: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    context: _propTypes2.default.any,
    cell: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.node, _propTypes2.default.func]),
    align: _propTypes2.default.oneOf(['left', 'center', 'right']),
    component: _propTypes2.default.oneOf(['td', 'th', 'div']),
    children: _propTypes2.default.any,
    style: _propTypes2.default.object,
    innerStyle: _propTypes2.default.object,
    filterMode: _propTypes2.default.oneOf(['single', 'multiple']),
    filters: _propTypes2.default.array,
    sortable: _propTypes2.default.bool,
    lock: _propTypes2.default.any,
    type: _propTypes2.default.oneOf(['header', 'body']),
    resizable: _propTypes2.default.bool,
    __normalized: _propTypes2.default.bool
}, _class.defaultProps = {
    component: 'td',
    type: 'body',
    cell: function cell(value) {
        return value;
    },
    prefix: 'next-'
}, _temp);
Cell.displayName = 'Cell';
exports.default = Cell;
module.exports = exports['default'];

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _header = __webpack_require__(48);

var _header2 = _interopRequireDefault(_header);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var FixedHeader = (_temp = _class = function (_React$Component) {
    _inherits(FixedHeader, _React$Component);

    function FixedHeader() {
        _classCallCheck(this, FixedHeader);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    FixedHeader.prototype.componentDidMount = function componentDidMount() {
        this.context.getNode('header', (0, _reactDom.findDOMNode)(this));
    };

    FixedHeader.prototype.render = function render() {
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            colGroup = _props.colGroup,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'colGroup']);

        return _react2.default.createElement(
            'div',
            { className: className },
            _react2.default.createElement(
                'div',
                { className: prefix + 'table-header-inner' },
                _react2.default.createElement(
                    'table',
                    null,
                    colGroup,
                    _react2.default.createElement(_header2.default, _extends({}, others, { prefix: prefix }))
                )
            )
        );
    };

    return FixedHeader;
}(_react2.default.Component), _class.propTypes = {
    children: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    className: _propTypes2.default.string,
    colGroup: _propTypes2.default.any
}, _class.contextTypes = {
    getNode: _propTypes2.default.func,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}, _temp);
FixedHeader.displayName = 'FixedHeader';
exports.default = FixedHeader;
module.exports = exports['default'];

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = findNode;

var _reactDom = __webpack_require__(4);

function findNode(target, param) {
    if (!target) {
        return null;
    }

    if (typeof target === 'string') {
        return document.getElementById(target);
    }

    if (typeof target === 'function') {
        target = target(param);
    }

    if (!target) {
        return null;
    }

    try {
        return (0, _reactDom.findDOMNode)(target);
    } catch (err) {
        return target;
    }
}
module.exports = exports['default'];

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

var _item = __webpack_require__(14);

var _item2 = _interopRequireDefault(_item);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var bindCtx = _util.func.bindCtx;
var pickOthers = _util.obj.pickOthers;

/**
 * Menu.Item
 * @order 0
 */

var SelectableItem = (_temp = _class = function (_Component) {
    _inherits(SelectableItem, _Component);

    function SelectableItem(props) {
        _classCallCheck(this, SelectableItem);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        bindCtx(_this, ['handleKeyDown', 'handleClick']);
        return _this;
    }

    SelectableItem.prototype.getSelected = function getSelected() {
        var _props = this.props,
            _key = _props._key,
            root = _props.root,
            selected = _props.selected;
        var selectMode = root.props.selectMode;
        var selectedKeys = root.state.selectedKeys;

        return selected || !!selectMode && selectedKeys.indexOf(_key) > -1;
    };

    SelectableItem.prototype.handleSelect = function handleSelect(e) {
        var _props2 = this.props,
            _key = _props2._key,
            root = _props2.root,
            onSelect = _props2.onSelect;

        if (onSelect) {
            onSelect(!this.getSelected(), this, e);
        } else {
            root.handleSelect(_key, !this.getSelected(), this);
        }
    };

    SelectableItem.prototype.handleKeyDown = function handleKeyDown(e) {
        if (e.keyCode === _util.KEYCODE.SPACE) {
            this.handleSelect(e);
        }

        this.props.onKeyDown && this.props.onKeyDown(e);
    };

    SelectableItem.prototype.handleClick = function handleClick(e) {
        this.handleSelect(e);

        this.props.onClick && this.props.onClick(e);
    };

    SelectableItem.prototype.renderSelectedIcon = function renderSelectedIcon(selected) {
        var _props3 = this.props,
            root = _props3.root,
            inlineIndent = _props3.inlineIndent,
            needIndent = _props3.needIndent,
            hasSelectedIcon = _props3.hasSelectedIcon;
        var _root$props = root.props,
            prefix = _root$props.prefix,
            rootSelectedIcon = _root$props.hasSelectedIcon;


        return ('hasSelectedIcon' in this.props ? hasSelectedIcon : rootSelectedIcon) && selected ? _react2.default.createElement(_icon2.default, { style: needIndent && inlineIndent > 0 ? { left: inlineIndent + 'px' } : null, className: prefix + 'menu-icon-selected', type: 'select' }) : null;
    };

    SelectableItem.prototype.render = function render() {
        var _cx;

        var _props4 = this.props,
            _key = _props4._key,
            root = _props4.root,
            className = _props4.className,
            disabled = _props4.disabled,
            helper = _props4.helper,
            children = _props4.children,
            needIndent = _props4.needIndent;
        var prefix = root.props.prefix;

        var others = pickOthers(Object.keys(SelectableItem.propTypes), this.props);
        var selected = this.getSelected();

        var newProps = _extends({
            _key: _key,
            root: root,
            disabled: disabled,
            type: 'item',
            className: (0, _classnames2.default)((_cx = {}, _cx[prefix + 'selected'] = selected, _cx[className] = !!className, _cx)),
            onKeyDown: this.handleKeyDown,
            onClick: !disabled ? this.handleClick : this.props.onClick,
            needIndent: needIndent,
            'aria-selected': selected
        }, others);

        return _react2.default.createElement(
            _item2.default,
            newProps,
            this.renderSelectedIcon(selected),
            _react2.default.createElement(
                'span',
                { className: prefix + 'menu-item-text' },
                children
            ),
            helper ? _react2.default.createElement(
                'div',
                { className: prefix + 'menu-item-helper' },
                helper
            ) : null
        );
    };

    return SelectableItem;
}(_react.Component), _class.menuChildType = 'item', _class.propTypes = {
    _key: _propTypes2.default.string,
    root: _propTypes2.default.object,
    selected: _propTypes2.default.bool,
    onSelect: _propTypes2.default.func,
    inlineIndent: _propTypes2.default.number,
    /**
     * 是否禁用
     */
    disabled: _propTypes2.default.bool,
    /**
     * 帮助文本
     */
    helper: _propTypes2.default.node,
    /**
     * 菜单项标签内容
     */
    children: _propTypes2.default.node,
    className: _propTypes2.default.string,
    onKeyDown: _propTypes2.default.func,
    onClick: _propTypes2.default.func,
    needIndent: _propTypes2.default.bool,
    hasSelectedIcon: _propTypes2.default.bool
}, _class.defaultProps = {
    disabled: false,
    needIndent: true
}, _temp);
SelectableItem.displayName = 'SelectableItem';
exports.default = SelectableItem;
module.exports = exports['default'];

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Table.Column
 * @order 0
 **/
var Column = (_temp = _class = function (_React$Component) {
  _inherits(Column, _React$Component);

  function Column() {
    _classCallCheck(this, Column);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Column.prototype.render = function render() {
    return null;
  };

  return Column;
}(_react2.default.Component), _class.propTypes = {
  /**
   * 指定列对应的字段，支持`a.b`形式的快速取值
   */
  dataIndex: _propTypes2.default.string,
  /**
   * 行渲染的逻辑
   * value, rowIndex, record, context四个属性只可读不可被更改
   * Function(value, index, record) => Element
   */
  cell: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.node, _propTypes2.default.func]),
  /**
   * 表头显示的内容
   * value, rowIndex, record, context四个属性只可读不可被更改
   */
  title: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.node, _propTypes2.default.func]),
  /**
   * 是否支持排序
   */
  sortable: _propTypes2.default.bool,
  /**
   * 列宽，注意在锁列的情况下一定需要配置宽度
   */
  width: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
  /**
   * 单元格的对齐方式
   */
  align: _propTypes2.default.oneOf(['left', 'center', 'right']),
  /**
   * 生成标题过滤的菜单, 格式为`[{label:'xxx', value:'xxx'}]`
   */
  filters: _propTypes2.default.arrayOf(_propTypes2.default.shape({
    label: _propTypes2.default.string,
    value: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.string])
  })),
  /**
   * 过滤的模式是单选还是多选
   */
  filterMode: _propTypes2.default.oneOf(['single', 'multiple']),
  /**
   * 是否支持锁列,可选值为`left`,`right`, `true`
   */
  lock: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.string]),
  /**
   * 是否支持列宽调整, 当该值设为true，table的布局方式会修改为fixed.
   */
  resizable: _propTypes2.default.bool
}, _class.contextTypes = {
  parent: _propTypes2.default.any
}, _class.defaultProps = {
  cell: function cell(value) {
    return value;
  },
  filterMode: 'multiple',
  resizable: false
}, _class._typeMark = 'column', _temp);
Column.displayName = 'Column';
exports.default = Column;
module.exports = exports['default'];

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var FixedWrapper = (_temp = _class = function (_React$Component) {
    _inherits(FixedWrapper, _React$Component);

    function FixedWrapper() {
        _classCallCheck(this, FixedWrapper);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    FixedWrapper.prototype.render = function render() {
        var _props = this.props,
            children = _props.children,
            wrapperContent = _props.wrapperContent,
            prefix = _props.prefix;

        return _react2.default.createElement(
            'div',
            { className: prefix + 'table-inner' },
            children,
            wrapperContent
        );
    };

    return FixedWrapper;
}(_react2.default.Component), _class.propTypes = {
    children: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    colGroup: _propTypes2.default.any,
    wrapperContent: _propTypes2.default.any
}, _temp);
FixedWrapper.displayName = 'FixedWrapper';
exports.default = FixedWrapper;
module.exports = exports['default'];

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n.next-icon[dir=\"rtl\"]::before {\n  -webkit-transform: rotateY(180deg);\n          transform: rotateY(180deg); }\n\n@font-face {\n  font-family: NextIcon;\n  src: url(\"//at.alicdn.com/t/font_515771_emcns5054x3whfr.eot\");\n  src: url(\"//at.alicdn.com/t/font_515771_emcns5054x3whfr.eot?#iefix\") format(\"embedded-opentype\"), url(\"//at.alicdn.com/t/font_515771_emcns5054x3whfr.woff\") format(\"woff\"), url(\"//at.alicdn.com/t/font_515771_emcns5054x3whfr.ttf\") format(\"truetype\"), url(\"//at.alicdn.com/t/font_515771_emcns5054x3whfr.svg#NextIcon\") format(\"svg\"); }\n\n.next-icon {\n  display: inline-block;\n  font-family: NextIcon;\n  font-style: normal;\n  font-weight: normal;\n  text-transform: none;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale; }\n  .next-icon:before {\n    display: inline-block;\n    vertical-align: middle;\n    text-align: center; }\n  .next-icon-smile:before {\n    content: \"\\E65F\"; }\n  .next-icon-cry:before {\n    content: \"\\E65D\"; }\n  .next-icon-success:before {\n    content: \"\\E60A\"; }\n  .next-icon-warning:before {\n    content: \"\\E60B\"; }\n  .next-icon-prompt:before {\n    content: \"\\E60C\"; }\n  .next-icon-error:before {\n    content: \"\\E60D\"; }\n  .next-icon-help:before {\n    content: \"\\E673\"; }\n  .next-icon-clock:before {\n    content: \"\\E621\"; }\n  .next-icon-success-filling:before {\n    content: \"\\E63A\"; }\n  .next-icon-delete-filling:before {\n    content: \"\\E623\"; }\n  .next-icon-favorites-filling:before {\n    content: \"\\E60E\"; }\n  .next-icon-add:before {\n    content: \"\\E655\"; }\n  .next-icon-minus:before {\n    content: \"\\E601\"; }\n  .next-icon-arrow-up:before {\n    content: \"\\E625\"; }\n  .next-icon-arrow-down:before {\n    content: \"\\E63D\"; }\n  .next-icon-arrow-left:before {\n    content: \"\\E61D\"; }\n  .next-icon-arrow-right:before {\n    content: \"\\E619\"; }\n  .next-icon-arrow-double-left:before {\n    content: \"\\E659\"; }\n  .next-icon-arrow-double-right:before {\n    content: \"\\E65E\"; }\n  .next-icon-switch:before {\n    content: \"\\E6B3\"; }\n  .next-icon-sorting:before {\n    content: \"\\E634\"; }\n  .next-icon-descending:before {\n    content: \"\\E61F\"; }\n  .next-icon-ascending:before {\n    content: \"\\E61E\"; }\n  .next-icon-select:before {\n    content: \"\\E632\"; }\n  .next-icon-semi-select:before {\n    content: \"\\E633\"; }\n  .next-icon-search:before {\n    content: \"\\E656\"; }\n  .next-icon-close:before {\n    content: \"\\E626\"; }\n  .next-icon-ellipsis:before {\n    content: \"\\E654\"; }\n  .next-icon-picture:before {\n    content: \"\\E631\"; }\n  .next-icon-calendar:before {\n    content: \"\\E607\"; }\n  .next-icon-ashbin:before {\n    content: \"\\E639\"; }\n  .next-icon-upload:before {\n    content: \"\\E7EE\"; }\n  .next-icon-download:before {\n    content: \"\\E628\"; }\n  .next-icon-set:before {\n    content: \"\\E683\"; }\n  .next-icon-edit:before {\n    content: \"\\E63B\"; }\n  .next-icon-refresh:before {\n    content: \"\\E677\"; }\n  .next-icon-filter:before {\n    content: \"\\E627\"; }\n  .next-icon-attachment:before {\n    content: \"\\E665\"; }\n  .next-icon-account:before {\n    content: \"\\E608\"; }\n  .next-icon-email:before {\n    content: \"\\E605\"; }\n  .next-icon-atm:before {\n    content: \"\\E606\"; }\n  .next-icon-loading:before {\n    content: \"\\E646\";\n    -webkit-animation: loadingCircle 1s infinite linear;\n            animation: loadingCircle 1s infinite linear; }\n\n@-webkit-keyframes loadingCircle {\n  0% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n\n@keyframes loadingCircle {\n  0% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n\n.next-icon.next-xxs:before {\n  width: 8px;\n  font-size: 8px;\n  line-height: inherit; }\n\n@media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n  .next-icon.next-xxs {\n    -webkit-transform: scale(0.5);\n        -ms-transform: scale(0.5);\n            transform: scale(0.5);\n    margin-left: -4px;\n    margin-right: -4px; }\n    .next-icon.next-xxs:before {\n      width: 16px;\n      font-size: 16px; } }\n\n.next-icon.next-xs:before {\n  width: 12px;\n  font-size: 12px;\n  line-height: inherit; }\n\n.next-icon.next-small:before {\n  width: 16px;\n  font-size: 16px;\n  line-height: inherit; }\n\n.next-icon.next-medium:before {\n  width: 20px;\n  font-size: 20px;\n  line-height: inherit; }\n\n.next-icon.next-large:before {\n  width: 24px;\n  font-size: 24px;\n  line-height: inherit; }\n\n.next-icon.next-xl:before {\n  width: 32px;\n  font-size: 32px;\n  line-height: inherit; }\n\n.next-icon.next-xxl:before {\n  width: 48px;\n  font-size: 48px;\n  line-height: inherit; }\n\n.next-icon.next-xxxl:before {\n  width: 64px;\n  font-size: 64px;\n  line-height: inherit; }\n", ""]);

// exports


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@-webkit-keyframes fadeIn {\n  0% {\n    opacity: 0; }\n  100% {\n    opacity: 1; } }\n\n@keyframes fadeIn {\n  0% {\n    opacity: 0; }\n  100% {\n    opacity: 1; } }\n\n@-webkit-keyframes fadeInDown {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateY(-100px);\n    -ms-transform: translateY(-100px);\n    transform: translateY(-100px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); } }\n\n@keyframes fadeInDown {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateY(-100px);\n    -ms-transform: translateY(-100px);\n    transform: translateY(-100px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); } }\n\n@-webkit-keyframes fadeInLeft {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateX(-20px);\n    -ms-transform: translateX(-20px);\n    transform: translateX(-20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); } }\n\n@keyframes fadeInLeft {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateX(-20px);\n    -ms-transform: translateX(-20px);\n    transform: translateX(-20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); } }\n\n@-webkit-keyframes fadeInRight {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateX(20px);\n    -ms-transform: translateX(20px);\n    transform: translateX(20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); } }\n\n@keyframes fadeInRight {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateX(20px);\n    -ms-transform: translateX(20px);\n    transform: translateX(20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); } }\n\n@-webkit-keyframes fadeInUp {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateY(20px);\n    -ms-transform: translateY(20px);\n    transform: translateY(20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); } }\n\n@keyframes fadeInUp {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateY(20px);\n    -ms-transform: translateY(20px);\n    transform: translateY(20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); } }\n\n@-webkit-keyframes fadeOut {\n  0% {\n    opacity: 1; }\n  100% {\n    opacity: 0; } }\n\n@keyframes fadeOut {\n  0% {\n    opacity: 1; }\n  100% {\n    opacity: 0; } }\n\n@-webkit-keyframes fadeOutDown {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateY(20px);\n    -ms-transform: translateY(20px);\n    transform: translateY(20px); } }\n\n@keyframes fadeOutDown {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateY(20px);\n    -ms-transform: translateY(20px);\n    transform: translateY(20px); } }\n\n@-webkit-keyframes fadeOutLeft {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateX(-20px);\n    -ms-transform: translateX(-20px);\n    transform: translateX(-20px); } }\n\n@keyframes fadeOutLeft {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateX(-20px);\n    -ms-transform: translateX(-20px);\n    transform: translateX(-20px); } }\n\n@-webkit-keyframes fadeOutRight {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateX(20px);\n    -ms-transform: translateX(20px);\n    transform: translateX(20px); } }\n\n@keyframes fadeOutRight {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateX(20px);\n    -ms-transform: translateX(20px);\n    transform: translateX(20px); } }\n\n@-webkit-keyframes fadeOutUp {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateY(-100px);\n    -ms-transform: translateY(-100px);\n    transform: translateY(-100px); } }\n\n@keyframes fadeOutUp {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateY(-100px);\n    -ms-transform: translateY(-100px);\n    transform: translateY(-100px); } }\n\n@-webkit-keyframes zoomIn {\n  0% {\n    opacity: 0;\n    -webkit-transform: scale3d(0.3, 0.3, 0.3);\n    -ms-transform: scale3d(0.3, 0.3, 0.3);\n    transform: scale3d(0.3, 0.3, 0.3); }\n  50% {\n    opacity: 1; } }\n\n@keyframes zoomIn {\n  0% {\n    opacity: 0;\n    -webkit-transform: scale3d(0.3, 0.3, 0.3);\n    -ms-transform: scale3d(0.3, 0.3, 0.3);\n    transform: scale3d(0.3, 0.3, 0.3); }\n  50% {\n    opacity: 1; } }\n\n@-webkit-keyframes zoomOut {\n  0% {\n    opacity: 1; }\n  50% {\n    opacity: 0;\n    -webkit-transform: scale3d(0.3, 0.3, 0.3);\n    -ms-transform: scale3d(0.3, 0.3, 0.3);\n    transform: scale3d(0.3, 0.3, 0.3); }\n  100% {\n    opacity: 0; } }\n\n@keyframes zoomOut {\n  0% {\n    opacity: 1; }\n  50% {\n    opacity: 0;\n    -webkit-transform: scale3d(0.3, 0.3, 0.3);\n    -ms-transform: scale3d(0.3, 0.3, 0.3);\n    transform: scale3d(0.3, 0.3, 0.3); }\n  100% {\n    opacity: 0; } }\n\n@-webkit-keyframes expandInDown {\n  0% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; }\n  100% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; } }\n\n@keyframes expandInDown {\n  0% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; }\n  100% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; } }\n\n@-webkit-keyframes expandInUp {\n  0% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; }\n  100% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; } }\n\n@keyframes expandInUp {\n  0% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; }\n  100% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; } }\n\n@-webkit-keyframes expandInWithFade {\n  0% {\n    opacity: 0; }\n  40% {\n    opacity: .1; }\n  50% {\n    opacity: .9; }\n  100% {\n    opacity: 1; } }\n\n@keyframes expandInWithFade {\n  0% {\n    opacity: 0; }\n  40% {\n    opacity: .1; }\n  50% {\n    opacity: .9; }\n  100% {\n    opacity: 1; } }\n\n@-webkit-keyframes expandOutUp {\n  0% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; }\n  100% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; } }\n\n@keyframes expandOutUp {\n  0% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; }\n  100% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; } }\n\n@-webkit-keyframes expandOutDown {\n  0% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; }\n  100% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; } }\n\n@keyframes expandOutDown {\n  0% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; }\n  100% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; } }\n\n@-webkit-keyframes expandOutWithFade {\n  0% {\n    opacity: 1; }\n  70% {\n    opacity: 0; }\n  100% {\n    opacity: 0; } }\n\n@keyframes expandOutWithFade {\n  0% {\n    opacity: 1; }\n  70% {\n    opacity: 0; }\n  100% {\n    opacity: 0; } }\n\n@-webkit-keyframes pulse {\n  from {\n    -webkit-transform: scale(1);\n    -ms-transform: scale(1);\n    transform: scale(1); }\n  20% {\n    -webkit-transform: scale(1.2);\n    -ms-transform: scale(1.2);\n    transform: scale(1.2); }\n  to {\n    -webkit-transform: scale(1);\n    -ms-transform: scale(1);\n    transform: scale(1); } }\n\n@keyframes pulse {\n  from {\n    -webkit-transform: scale(1);\n    -ms-transform: scale(1);\n    transform: scale(1); }\n  20% {\n    -webkit-transform: scale(1.2);\n    -ms-transform: scale(1.2);\n    transform: scale(1.2); }\n  to {\n    -webkit-transform: scale(1);\n    -ms-transform: scale(1);\n    transform: scale(1); } }\n\n.fadeIn {\n  -webkit-animation-name: fadeIn;\n  animation-name: fadeIn;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeInDown {\n  -webkit-animation-name: fadeInDown;\n  animation-name: fadeInDown;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeInLeft {\n  -webkit-animation-name: fadeInLeft;\n  animation-name: fadeInLeft;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeInRight {\n  -webkit-animation-name: fadeInRight;\n  animation-name: fadeInRight;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeInUp {\n  -webkit-animation-name: fadeInUp;\n  animation-name: fadeInUp;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeOut {\n  -webkit-animation-name: fadeOut;\n  animation-name: fadeOut;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeOutDown {\n  -webkit-animation-name: fadeOutDown;\n  animation-name: fadeOutDown;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeOutLeft {\n  -webkit-animation-name: fadeOutLeft;\n  animation-name: fadeOutLeft;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeOutRight {\n  -webkit-animation-name: fadeOutRight;\n  animation-name: fadeOutRight;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeOutUp {\n  -webkit-animation-name: fadeOutUp;\n  animation-name: fadeOutUp;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.2s;\n  animation-duration: 0.2s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.zoomIn {\n  -webkit-animation-name: zoomIn;\n  animation-name: zoomIn;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.zoomOut {\n  -webkit-animation-name: zoomOut;\n  animation-name: zoomOut;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.expandInDown {\n  -webkit-animation-name: expandInDown;\n  animation-name: expandInDown;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.expandOutUp {\n  -webkit-animation-name: expandOutUp;\n  animation-name: expandOutUp;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.15s;\n  animation-duration: 0.15s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.expandInUp {\n  -webkit-animation-name: expandInUp;\n  animation-name: expandInUp;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.expandOutDown {\n  -webkit-animation-name: expandOutDown;\n  animation-name: expandOutDown;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.15s;\n  animation-duration: 0.15s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.pulse {\n  -webkit-animation-name: pulse;\n  animation-name: pulse;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.expand-enter {\n  overflow: hidden; }\n\n.expand-enter-active {\n  -webkit-transition: all .3s ease-out;\n  transition: all .3s ease-out; }\n  .expand-enter-active > * {\n    -webkit-animation-name: expandInWithFade;\n    animation-name: expandInWithFade;\n    -webkit-animation-iteration-count: 1;\n    animation-iteration-count: 1;\n    -webkit-animation-duration: 0.2s;\n    animation-duration: 0.2s;\n    -webkit-animation-delay: 0s;\n    animation-delay: 0s;\n    -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n    animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n    -webkit-animation-fill-mode: \"forwards\";\n    animation-fill-mode: \"forwards\";\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden; }\n\n.expand-leave {\n  overflow: hidden; }\n\n.expand-leave-active {\n  -webkit-transition: all .2s ease-out;\n  transition: all .2s ease-out; }\n  .expand-leave-active > * {\n    -webkit-animation-name: expandOutWithFade;\n    animation-name: expandOutWithFade;\n    -webkit-animation-iteration-count: 1;\n    animation-iteration-count: 1;\n    -webkit-animation-duration: 0.2s;\n    animation-duration: 0.2s;\n    -webkit-animation-delay: 0s;\n    animation-delay: 0s;\n    -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n    animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n    -webkit-animation-fill-mode: \"forwards\";\n    animation-fill-mode: \"forwards\";\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden; }\n", ""]);

// exports


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n/* stylelint-disable max-nesting-depth */\n.next-checkbox-wrapper {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box; }\n  .next-checkbox-wrapper *,\n  .next-checkbox-wrapper *:before,\n  .next-checkbox-wrapper *:after {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box; }\n  .next-checkbox-wrapper .next-checkbox {\n    display: inline-block;\n    position: relative;\n    line-height: 1;\n    vertical-align: middle; }\n  .next-checkbox-wrapper input[type=\"checkbox\"] {\n    opacity: 0;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 16px;\n    height: 16px;\n    margin: 0; }\n  .next-checkbox-wrapper .next-checkbox-inner {\n    display: block;\n    width: 16px;\n    height: 16px;\n    background: #FFFFFF;\n    border-radius: 3px;\n    border: 1px solid #C4C6CF;\n    -webkit-transition: ease all .3s 0s;\n    transition: ease all .3s 0s;\n    text-align: left;\n    /* 防止继承父级 */\n    -webkit-box-shadow: none;\n            box-shadow: none;\n    /* box-sizing: content-box; */ }\n    .next-checkbox-wrapper .next-checkbox-inner > .next-icon {\n      -webkit-transform: scale(0);\n          -ms-transform: scale(0);\n              transform: scale(0);\n      position: absolute;\n      top: 0;\n      opacity: 0;\n      line-height: 16px;\n      -webkit-transition: all 0.3s cubic-bezier(0.78, 0.14, 0.15, 0.86);\n      transition: all 0.3s cubic-bezier(0.78, 0.14, 0.15, 0.86);\n      color: #FFFFFF;\n      left: 4px;\n      margin-left: 0; }\n      .next-checkbox-wrapper .next-checkbox-inner > .next-icon:before {\n        width: 8px;\n        font-size: 8px;\n        line-height: inherit; }\n      @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n        .next-checkbox-wrapper .next-checkbox-inner > .next-icon {\n          -webkit-transform: scale(0.5);\n              -ms-transform: scale(0.5);\n                  transform: scale(0.5);\n          margin-left: -4px;\n          margin-right: -4px; }\n          .next-checkbox-wrapper .next-checkbox-inner > .next-icon:before {\n            width: 16px;\n            font-size: 16px; } }\n    .next-checkbox-wrapper .next-checkbox-inner > .next-icon::before {\n      vertical-align: top;\n      margin-top: 0; }\n  .next-checkbox-wrapper.checked .next-checkbox-inner {\n    border-color: transparent;\n    background-color: #5584FF; }\n    .next-checkbox-wrapper.checked .next-checkbox-inner:hover, .next-checkbox-wrapper.checked .next-checkbox-inner.hovered {\n      border-color: transparent; }\n    .next-checkbox-wrapper.checked .next-checkbox-inner > .next-icon {\n      opacity: 1;\n      -webkit-transform: scale(1);\n          -ms-transform: scale(1);\n              transform: scale(1);\n      margin-left: 0;\n      /* font-size < 12px的时候进行覆盖。 */ }\n      .next-checkbox-wrapper.checked .next-checkbox-inner > .next-icon:before {\n        width: 8px;\n        font-size: 8px;\n        line-height: inherit; }\n      @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n        .next-checkbox-wrapper.checked .next-checkbox-inner > .next-icon {\n          -webkit-transform: scale(0.5);\n              -ms-transform: scale(0.5);\n                  transform: scale(0.5);\n          margin-left: -4px;\n          margin-right: -4px; }\n          .next-checkbox-wrapper.checked .next-checkbox-inner > .next-icon:before {\n            width: 16px;\n            font-size: 16px; } }\n  .next-checkbox-wrapper.indeterminate .next-checkbox-inner {\n    border-color: transparent;\n    background-color: #5584FF; }\n    .next-checkbox-wrapper.indeterminate .next-checkbox-inner:hover, .next-checkbox-wrapper.indeterminate .next-checkbox-inner.hovered {\n      border-color: transparent; }\n    .next-checkbox-wrapper.indeterminate .next-checkbox-inner > .next-icon {\n      opacity: 1;\n      -webkit-transform: scale3d(1, 1, 1);\n              transform: scale3d(1, 1, 1);\n      margin-left: 0;\n      /* font-size < 12px的时候进行覆盖。 */ }\n      .next-checkbox-wrapper.indeterminate .next-checkbox-inner > .next-icon:before {\n        width: 8px;\n        font-size: 8px;\n        line-height: inherit; }\n      @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n        .next-checkbox-wrapper.indeterminate .next-checkbox-inner > .next-icon {\n          -webkit-transform: scale(0.5);\n              -ms-transform: scale(0.5);\n                  transform: scale(0.5);\n          margin-left: -4px;\n          margin-right: -4px; }\n          .next-checkbox-wrapper.indeterminate .next-checkbox-inner > .next-icon:before {\n            width: 16px;\n            font-size: 16px; } }\n  .next-checkbox-wrapper.disabled input[type=\"checkbox\"] {\n    cursor: not-allowed; }\n  .next-checkbox-wrapper.disabled .next-checkbox-inner {\n    border-color: #E6E7EB;\n    background: #F7F8FA; }\n  .next-checkbox-wrapper.disabled.checked .next-checkbox-inner:hover, .next-checkbox-wrapper.disabled.checked .next-checkbox-inner.hovered, .next-checkbox-wrapper.disabled.indeterminate .next-checkbox-inner:hover, .next-checkbox-wrapper.disabled.indeterminate .next-checkbox-inner.hovered {\n    border-color: #E6E7EB; }\n  .next-checkbox-wrapper.disabled.checked .next-checkbox-inner > .next-icon, .next-checkbox-wrapper.disabled.indeterminate .next-checkbox-inner > .next-icon {\n    color: #CCCCCC;\n    opacity: 1; }\n  .next-checkbox-wrapper:not(.disabled):hover .next-checkbox-inner, .next-checkbox-wrapper.hovered .next-checkbox-inner, .next-checkbox-wrapper.focused .next-checkbox-inner {\n    border-color: #5584FF;\n    background-color: #DEE8FF; }\n  .next-checkbox-wrapper.indeterminate:not(.disabled):hover .next-checkbox-inner, .next-checkbox-wrapper.indeterminate:not(.disabled).hovered .next-checkbox-inner, .next-checkbox-wrapper.indeterminate.focused .next-checkbox-inner, .next-checkbox-wrapper.checked:not(.disabled):hover .next-checkbox-inner, .next-checkbox-wrapper.checked:not(.disabled).hovered .next-checkbox-inner, .next-checkbox-wrapper.checked.focused .next-checkbox-inner {\n    border-color: transparent;\n    background-color: #3E71F7; }\n    .next-checkbox-wrapper.indeterminate:not(.disabled):hover .next-checkbox-inner > .next-icon, .next-checkbox-wrapper.indeterminate:not(.disabled).hovered .next-checkbox-inner > .next-icon, .next-checkbox-wrapper.indeterminate.focused .next-checkbox-inner > .next-icon, .next-checkbox-wrapper.checked:not(.disabled):hover .next-checkbox-inner > .next-icon, .next-checkbox-wrapper.checked:not(.disabled).hovered .next-checkbox-inner > .next-icon, .next-checkbox-wrapper.checked.focused .next-checkbox-inner > .next-icon {\n      color: #FFFFFF;\n      opacity: 1; }\n\n.next-checkbox-group .next-checkbox-wrapper {\n  margin-left: 8px; }\n  .next-checkbox-group .next-checkbox-wrapper:first-child {\n    margin-left: 0; }\n\n.next-checkbox-group-ver .next-checkbox-wrapper {\n  display: block;\n  margin-left: 0;\n  margin-bottom: 8px; }\n\n.next-checkbox-label {\n  font-size: 12px;\n  vertical-align: middle;\n  margin: 0;\n  margin-left: 4px;\n  line-height: 1; }\n", ""]);

// exports


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n.next-radio-button-large[dir='rtl'] > label:first-child {\n  margin-left: -1px;\n  border-top-right-radius: 3px;\n  border-bottom-right-radius: 3px;\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0; }\n\n.next-radio-button-large[dir='rtl'] > label:last-child {\n  margin-left: 0;\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  border-top-left-radius: 3px;\n  border-bottom-left-radius: 3px; }\n\n.next-radio-button-large[dir='rtl'] .next-radio-label {\n  height: 38px;\n  line-height: 38px;\n  font-size: 16px; }\n\n.next-radio-button-medium[dir='rtl'] > label:first-child {\n  margin-left: -1px;\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  border-top-right-radius: 3px;\n  border-bottom-right-radius: 3px; }\n\n.next-radio-button-medium[dir='rtl'] > label:last-child {\n  margin-left: 0;\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  border-top-left-radius: 3px;\n  border-bottom-left-radius: 3px; }\n\n.next-radio-button-small[dir='rtl'] > label:first-child {\n  margin-left: -1px;\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  border-top-right-radius: 3px;\n  border-bottom-right-radius: 3px; }\n\n.next-radio-button-small[dir='rtl'] > label:last-child {\n  margin-left: 0;\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  border-top-left-radius: 3px;\n  border-bottom-left-radius: 3px; }\n\n.next-radio-wrapper[dir='rtl'] .next-radio-label {\n  margin-left: 0;\n  margin-right: 4px; }\n\n.next-radio-group[dir='rtl'] .next-radio-label {\n  margin-right: 4px;\n  margin-left: 16px; }\n\n.next-radio-button[dir='rtl'] > label .next-radio-label {\n  margin: 0; }\n\n.next-radio-wrapper {\n  outline: 0; }\n  .next-radio-wrapper .next-radio {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box;\n    display: inline-block;\n    vertical-align: middle;\n    position: relative;\n    line-height: 1; }\n    .next-radio-wrapper .next-radio *,\n    .next-radio-wrapper .next-radio *:before,\n    .next-radio-wrapper .next-radio *:after {\n      -webkit-box-sizing: border-box;\n              box-sizing: border-box; }\n    .next-radio-wrapper .next-radio input[type=\"radio\"] {\n      opacity: 0;\n      position: absolute;\n      vertical-align: middle;\n      top: 0;\n      left: 0;\n      width: 16px;\n      height: 16px;\n      margin: 0; }\n  .next-radio-wrapper .next-radio-inner {\n    /* 动画待定 */\n    /* &.mouseDown { */\n    /*     transform: scale3d(.7, .7, .7); */\n    /*     transition: transform .2s linear; */\n    /* } */\n    /* &.mouseUp { */\n    /*     transform: scale3d(1, 1, 1); */\n    /*     transition: transform .2s linear; */\n    /* } */\n    display: block;\n    width: 16px;\n    height: 16px;\n    background: #FFFFFF;\n    border-radius: 50%;\n    border: 1px solid #C4C6CF;\n    -webkit-transition: ease all .36s 0s;\n    transition: ease all .36s 0s;\n    -webkit-box-shadow: none;\n            box-shadow: none; }\n    .next-radio-wrapper .next-radio-inner:after {\n      -webkit-transform: scale(0);\n          -ms-transform: scale(0);\n              transform: scale(0);\n      position: absolute;\n      border-radius: 50%;\n      top: 50%;\n      margin-top: -2px;\n      left: 50%;\n      margin-left: -2px;\n      background: #FFFFFF;\n      content: ' ';\n      -webkit-transition: all 0.3s cubic-bezier(0.78, 0.14, 0.15, 0.86);\n      transition: all 0.3s cubic-bezier(0.78, 0.14, 0.15, 0.86); }\n  .next-radio-wrapper.checked .next-radio-inner {\n    border-color: #5584FF;\n    background: #5584FF; }\n    .next-radio-wrapper.checked .next-radio-inner:after {\n      width: 4px;\n      height: 4px;\n      font-weight: bold;\n      background: #FFFFFF;\n      -webkit-transform: scale(1);\n          -ms-transform: scale(1);\n              transform: scale(1); }\n  .next-radio-wrapper.checked:hover .next-radio-inner, .next-radio-wrapper.checked.hovered .next-radio-inner {\n    border-color: transparent; }\n  .next-radio-wrapper.disabled input[type=\"radio\"] {\n    cursor: not-allowed; }\n  .next-radio-wrapper.disabled .next-radio-inner {\n    border-color: #E6E7EB;\n    background: #F7F8FA; }\n    .next-radio-wrapper.disabled .next-radio-inner:hover, .next-radio-wrapper.disabled .next-radio-inner.hovered {\n      border-color: #E6E7EB; }\n  .next-radio-wrapper.disabled.checked .next-radio-inner:after {\n    background: #CCCCCC; }\n  .next-radio-wrapper:not(.disabled):hover .next-radio-inner, .next-radio-wrapper:not(.disabled).hovered .next-radio-inner, .next-radio-wrapper:not(.disabled):focus .next-radio-inner, .next-radio-wrapper:not(.disabled).focused .next-radio-inner {\n    border-color: #5584FF;\n    background-color: #DEE8FF; }\n  .next-radio-wrapper.checked:not(.disabled):hover .next-radio-inner, .next-radio-wrapper.checked:not(.disabled).hovered .next-radio-inner, .next-radio-wrapper.checked:not(.disabled):focus .next-radio-inner, .next-radio-wrapper.checked.focused .next-radio-inner {\n    border-color: transparent;\n    background: #3E71F7; }\n    .next-radio-wrapper.checked:not(.disabled):hover .next-radio-inner:after, .next-radio-wrapper.checked:not(.disabled).hovered .next-radio-inner:after, .next-radio-wrapper.checked:not(.disabled):focus .next-radio-inner:after, .next-radio-wrapper.checked.focused .next-radio-inner:after {\n      background: #FFFFFF; }\n\n.next-radio-button .next-radio {\n  width: 0;\n  height: 0; }\n\n.next-radio-button input[type=\"radio\"] {\n  width: 0;\n  height: 0; }\n\n.next-radio-button > label {\n  display: inline-block;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  position: relative;\n  z-index: 1;\n  margin: 0 0 0 -1px;\n  border: 1px solid #C4C6CF;\n  background-color: #FFFFFF;\n  -webkit-transition: ease all .3s 0s;\n  transition: ease all .3s 0s; }\n  .next-radio-button > label .next-radio-label {\n    display: block;\n    color: #333333;\n    margin: 0;\n    -webkit-transition: ease all .3s 0s;\n    transition: ease all .3s 0s; }\n  .next-radio-button > label:hover, .next-radio-button > label:focus, .next-radio-button > label.hovered {\n    z-index: 10;\n    border-color: #A0A2AD;\n    background-color: #F2F3F7; }\n    .next-radio-button > label:hover .next-radio-label, .next-radio-button > label:focus .next-radio-label, .next-radio-button > label.hovered .next-radio-label {\n      color: #333333; }\n  .next-radio-button > label.checked {\n    z-index: 10;\n    border-color: #5584FF;\n    background-color: #FFFFFF; }\n    .next-radio-button > label.checked .next-radio-label {\n      color: #5584FF; }\n  .next-radio-button > label.disabled {\n    z-index: 0;\n    cursor: not-allowed;\n    border-color: #E6E7EB;\n    background-color: #F7F8FA; }\n    .next-radio-button > label.disabled .next-radio-label {\n      color: #CCCCCC; }\n  .next-radio-button > label.checked.disabled {\n    z-index: 0;\n    border-color: #E6E7EB;\n    background-color: #F2F3F7; }\n    .next-radio-button > label.checked.disabled .next-radio-label {\n      color: #CCCCCC; }\n\n.next-radio-button-large > label {\n  padding: 0 8px;\n  height: 40px;\n  line-height: 40px; }\n  .next-radio-button-large > label:first-child {\n    margin-left: 0;\n    border-top-left-radius: 3px;\n    border-bottom-left-radius: 3px; }\n  .next-radio-button-large > label:last-child {\n    border-top-right-radius: 3px;\n    border-bottom-right-radius: 3px; }\n\n.next-radio-button-large .next-radio-label {\n  height: 38px;\n  line-height: 38px;\n  font-size: 16px; }\n\n.next-radio-button-medium > label {\n  padding: 0 8px;\n  height: 28px;\n  line-height: 28px; }\n  .next-radio-button-medium > label:first-child {\n    margin-left: 0;\n    border-top-left-radius: 3px;\n    border-bottom-left-radius: 3px; }\n  .next-radio-button-medium > label:last-child {\n    border-top-right-radius: 3px;\n    border-bottom-right-radius: 3px; }\n\n.next-radio-button-medium .next-radio-label {\n  height: 26px;\n  line-height: 26px;\n  font-size: 12px; }\n\n.next-radio-button-small > label {\n  padding: 0 8px;\n  height: 20px;\n  line-height: 20px; }\n  .next-radio-button-small > label:first-child {\n    margin-left: 0;\n    border-top-left-radius: 3px;\n    border-bottom-left-radius: 3px; }\n  .next-radio-button-small > label:last-child {\n    border-top-right-radius: 3px;\n    border-bottom-right-radius: 3px; }\n\n.next-radio-button-small .next-radio-label {\n  height: 18px;\n  line-height: 18px;\n  font-size: 12px; }\n\n.next-radio-single-input input[type=\"radio\"] {\n  opacity: 0;\n  position: absolute;\n  top: 0;\n  left: 0;\n  margin: 0; }\n\n.next-radio-group {\n  display: inline-block; }\n  .next-radio-group .next-radio-label {\n    color: #333333;\n    margin-right: 16px; }\n  .next-radio-group.disabled .next-radio-label {\n    color: #CCCCCC; }\n\n.next-radio-group-ver .next-radio-wrapper {\n  display: block;\n  margin-bottom: 8px; }\n\n.next-radio-label {\n  margin: 0;\n  margin-left: 4px;\n  font-size: 12px;\n  vertical-align: middle;\n  line-height: 1; }\n\n@-moz-document url-prefix() {\n  .next-radio {\n    margin-top: -1px; }\n  @supports ((-webkit-animation: calc(0s)) or (animation: calc(0s))) {\n    /* firefox 57+ */\n    .next-radio {\n      margin-top: -3px; } } }\n", ""]);

// exports


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n.next-menu[dir=\"rtl\"] .next-menu-item-helper {\n  float: left; }\n\n.next-menu[dir=\"rtl\"] .next-menu-item .next-checkbox,\n.next-menu[dir=\"rtl\"] .next-menu-item .next-radio {\n  margin-left: 4px;\n  margin-right: 0; }\n\n.next-menu[dir=\"rtl\"] .next-menu-hoz-right {\n  float: right; }\n\n.next-menu[dir=\"rtl\"] .next-menu-icon-arrow.next-icon {\n  left: 10px;\n  right: auto; }\n\n.next-menu[dir=\"rtl\"] .next-menu-hoz-icon-arrow.next-icon {\n  left: 6px;\n  right: auto; }\n\n.next-menu[dir=\"rtl\"] .next-menu-icon-selected.next-icon {\n  margin-left: 0;\n  margin-right: -16px; }\n  .next-menu[dir=\"rtl\"] .next-menu-icon-selected.next-icon:before {\n    width: 12px;\n    font-size: 12px;\n    line-height: inherit; }\n\n.next-menu[dir=\"rtl\"] .next-menu-icon-arrow.next-icon {\n  left: 10px;\n  right: auto; }\n\n.next-menu {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  position: relative;\n  min-width: 100px;\n  padding: 8px 0;\n  margin: 0;\n  list-style: none;\n  border: 1px solid #DCDEE3;\n  border-radius: 3px;\n  -webkit-box-shadow: none;\n          box-shadow: none;\n  background: #FFFFFF;\n  line-height: 32px;\n  font-size: 12px;\n  /* &-popup-content.next-hide { */\n  /*     display: none; */\n  /* } */ }\n  .next-menu *,\n  .next-menu *:before,\n  .next-menu *:after {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box; }\n  .next-menu:focus,\n  .next-menu *:focus {\n    outline: 0; }\n  .next-menu-content {\n    position: relative;\n    padding: 0;\n    margin: 0;\n    list-style: none; }\n  .next-menu-sub-menu {\n    padding: 0;\n    margin: 0;\n    list-style: none; }\n    .next-menu-sub-menu.next-expand-enter {\n      overflow: hidden; }\n    .next-menu-sub-menu.next-expand-enter-active {\n      -webkit-transition: height .3s ease-out;\n      transition: height .3s ease-out; }\n    .next-menu-sub-menu.next-expand-leave {\n      overflow: hidden; }\n    .next-menu-sub-menu.next-expand-leave-active {\n      -webkit-transition: height .3s ease-out;\n      transition: height .3s ease-out; }\n  .next-menu-item {\n    position: relative;\n    padding: 0 20px;\n    -webkit-transition: background .2s ease;\n    transition: background .2s ease;\n    color: #333333;\n    cursor: pointer; }\n    .next-menu-item-helper {\n      float: right;\n      color: #999999;\n      font-style: normal;\n      font-size: 12px; }\n    .next-menu-item .next-checkbox,\n    .next-menu-item .next-radio {\n      margin-right: 4px; }\n    .next-menu-item.next-selected {\n      color: #333333;\n      background-color: #FFFFFF; }\n      .next-menu-item.next-selected .next-menu-icon-arrow {\n        color: #666666; }\n      .next-menu-item.next-selected .next-menu-icon-selected {\n        color: #5584FF; }\n    .next-menu-item.next-disabled,\n    .next-menu-item.next-disabled .next-menu-item-text > a {\n      color: #CCCCCC;\n      background-color: #FFFFFF;\n      cursor: not-allowed; }\n      .next-menu-item.next-disabled .next-menu-icon-arrow,\n      .next-menu-item.next-disabled .next-menu-item-text > a .next-menu-icon-arrow {\n        color: #CCCCCC; }\n      .next-menu-item.next-disabled .next-menu-icon-selected,\n      .next-menu-item.next-disabled .next-menu-item-text > a .next-menu-icon-selected {\n        color: #CCCCCC; }\n    .next-menu-item:not(.next-disabled):hover, .next-menu-item:not(.next-disabled).next-selected:hover, .next-menu-item:not(.next-disabled).next-selected.next-focused:hover, .next-menu-item:not(.next-disabled).next-selected:focus:hover, .next-menu-item:not(.next-disabled).next-focused, .next-menu-item:not(.next-disabled):focus, .next-menu-item:not(.next-disabled).next-selected.next-focused, .next-menu-item:not(.next-disabled).next-selected:focus {\n      color: #333333;\n      background-color: #F2F3F7; }\n      .next-menu-item:not(.next-disabled):hover .next-menu-icon-arrow, .next-menu-item:not(.next-disabled).next-selected:hover .next-menu-icon-arrow, .next-menu-item:not(.next-disabled).next-selected.next-focused:hover .next-menu-icon-arrow, .next-menu-item:not(.next-disabled).next-selected:focus:hover .next-menu-icon-arrow, .next-menu-item:not(.next-disabled).next-focused .next-menu-icon-arrow, .next-menu-item:not(.next-disabled):focus .next-menu-icon-arrow, .next-menu-item:not(.next-disabled).next-selected.next-focused .next-menu-icon-arrow, .next-menu-item:not(.next-disabled).next-selected:focus .next-menu-icon-arrow {\n        color: #333333; }\n      .next-menu-item:not(.next-disabled):hover .next-menu-icon-selected, .next-menu-item:not(.next-disabled).next-selected:hover .next-menu-icon-selected, .next-menu-item:not(.next-disabled).next-selected.next-focused:hover .next-menu-icon-selected, .next-menu-item:not(.next-disabled).next-selected:focus:hover .next-menu-icon-selected, .next-menu-item:not(.next-disabled).next-focused .next-menu-icon-selected, .next-menu-item:not(.next-disabled):focus .next-menu-icon-selected, .next-menu-item:not(.next-disabled).next-selected.next-focused .next-menu-icon-selected, .next-menu-item:not(.next-disabled).next-selected:focus .next-menu-icon-selected {\n        color: #5584FF; }\n  .next-menu-item-inner {\n    height: 32px;\n    font-size: 12px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    word-wrap: normal; }\n  .next-menu-item-text {\n    vertical-align: middle; }\n    .next-menu-item-text > a {\n      display: inline-block;\n      text-decoration: none;\n      color: #333333; }\n      .next-menu-item-text > a::before {\n        position: absolute;\n        background-color: transparent;\n        top: 0;\n        left: 0;\n        bottom: 0;\n        right: 0;\n        content: ''; }\n  .next-menu.next-hoz {\n    padding: 0; }\n    .next-menu.next-hoz > .next-menu-item,\n    .next-menu.next-hoz .next-menu-content > .next-menu-item {\n      display: inline-block;\n      vertical-align: top; }\n    .next-menu.next-hoz .next-menu-header,\n    .next-menu.next-hoz .next-menu-content,\n    .next-menu.next-hoz .next-menu-footer {\n      display: inline-block; }\n  .next-menu-hoz-right {\n    float: right; }\n  .next-menu-group-label {\n    padding: 0 12px;\n    color: #999999; }\n  .next-menu-divider {\n    margin: 8px 12px;\n    border-bottom: 1px solid #E6E7EB; }\n  .next-menu .next-menu-icon-selected.next-icon {\n    position: absolute;\n    top: 0;\n    margin-left: -16px; }\n    .next-menu .next-menu-icon-selected.next-icon:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-menu .next-menu-icon-arrow.next-icon {\n    position: absolute;\n    top: 0;\n    right: 10px;\n    color: #666666;\n    -webkit-transition: all ease .3s;\n    transition: all ease .3s; }\n    .next-menu .next-menu-icon-arrow.next-icon:before {\n      width: 8px;\n      font-size: 8px;\n      line-height: inherit; }\n    @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n      .next-menu .next-menu-icon-arrow.next-icon {\n        -webkit-transform: scale(0.5);\n            -ms-transform: scale(0.5);\n                transform: scale(0.5);\n        margin-left: -4px;\n        margin-right: -4px; }\n        .next-menu .next-menu-icon-arrow.next-icon:before {\n          width: 16px;\n          font-size: 16px; } }\n  .next-menu .next-menu-icon-arrow-down.next-open {\n    -webkit-transform: rotate(180deg);\n        -ms-transform: rotate(180deg);\n            transform: rotate(180deg); }\n    .next-menu .next-menu-icon-arrow-down.next-open:before {\n      width: 8px;\n      font-size: 8px;\n      line-height: inherit; }\n    @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n      .next-menu .next-menu-icon-arrow-down.next-open {\n        -webkit-transform: scale(0.5) rotate(180deg);\n            -ms-transform: scale(0.5) rotate(180deg);\n                transform: scale(0.5) rotate(180deg);\n        margin-left: -4px;\n        margin-right: -4px; }\n        .next-menu .next-menu-icon-arrow-down.next-open:before {\n          width: 16px;\n          font-size: 16px; } }\n  .next-menu .next-menu-icon-arrow-right.next-open {\n    -webkit-transform: rotate(-90deg);\n        -ms-transform: rotate(-90deg);\n            transform: rotate(-90deg); }\n    .next-menu .next-menu-icon-arrow-right.next-open:before {\n      width: 8px;\n      font-size: 8px;\n      line-height: inherit; }\n    @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n      .next-menu .next-menu-icon-arrow-right.next-open {\n        -webkit-transform: scale(0.5) rotate(-90deg);\n            -ms-transform: scale(0.5) rotate(-90deg);\n                transform: scale(0.5) rotate(-90deg);\n        margin-left: -4px;\n        margin-right: -4px; }\n        .next-menu .next-menu-icon-arrow-right.next-open:before {\n          width: 16px;\n          font-size: 16px; } }\n  .next-menu .next-menu-hoz-icon-arrow.next-icon {\n    position: absolute;\n    top: 0;\n    right: 6px;\n    color: #666666;\n    -webkit-transition: all ease .3s;\n    transition: all ease .3s; }\n    .next-menu .next-menu-hoz-icon-arrow.next-icon:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-menu .next-menu-hoz-icon-arrow.next-open {\n    -webkit-transform: rotate(180deg);\n        -ms-transform: rotate(180deg);\n            transform: rotate(180deg); }\n    .next-menu .next-menu-hoz-icon-arrow.next-open:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-menu.next-context {\n    line-height: 24px; }\n    .next-menu.next-context .next-menu-item-inner {\n      height: 24px; }\n", ""]);

// exports


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n.next-btn {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box; }\n  .next-btn *,\n  .next-btn *:before,\n  .next-btn *:after {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box; }\n  .next-btn::-moz-focus-inner {\n    border: 0;\n    padding: 0; }\n  .next-btn, .next-btn:active, .next-btn:focus, .next-btn:hover {\n    outline: 0; }\n\n@-webkit-keyframes loadingCircle {\n  0% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n\n@keyframes loadingCircle {\n  0% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n\n.next-btn {\n  /* 尺寸维度 */\n  /* ---------------------------------------- */\n  /* 普通按钮 */\n  /* 普通态禁用样式 */\n  /* 警告按钮 */\n  /* 文本按钮 */\n  /* loading */\n  /* ---------------------------------------- */\n  /* 幽灵按钮 */\n  /* 组合 */\n  /* ---------------------------------------- */ }\n  .next-btn {\n    position: relative;\n    display: inline-block;\n    -webkit-box-shadow: none;\n            box-shadow: none;\n    text-decoration: none;\n    text-align: center;\n    text-transform: none;\n    white-space: nowrap;\n    vertical-align: middle;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n    -webkit-transition: all .3s ease-out;\n    transition: all .3s ease-out;\n    cursor: pointer; }\n    .next-btn:after {\n      text-align: center;\n      position: absolute;\n      opacity: 0;\n      visibility: hidden;\n      -webkit-transition: opacity .5s ease;\n      transition: opacity .5s ease; }\n    .next-btn .next-icon.next-xs:before {\n      vertical-align: baseline; }\n    .next-btn.hover, .next-btn:hover {\n      -webkit-box-shadow: none;\n              box-shadow: none; }\n  .next-btn.next-small {\n    border-radius: 3px;\n    padding: 0 8px;\n    height: 20px;\n    line-height: 18px;\n    font-size: 12px;\n    border-width: 1px; }\n    .next-btn.next-small > .next-btn-icon.next-icon-first {\n      margin-left: 0;\n      margin-right: 4px; }\n      .next-btn.next-small > .next-btn-icon.next-icon-first:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n    .next-btn.next-small > .next-btn-icon.next-icon-last {\n      margin-left: 4px;\n      margin-right: 0; }\n      .next-btn.next-small > .next-btn-icon.next-icon-last:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n    .next-btn.next-small > .next-btn-icon.next-icon-alone:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n    .next-btn.next-small.next-btn-loading {\n      padding-left: 24px; }\n      .next-btn.next-small.next-btn-loading:after {\n        width: 12px;\n        height: 12px;\n        font-size: 12px;\n        line-height: 12px;\n        left: 8px;\n        top: 50%;\n        text-align: center;\n        margin-top: -6px;\n        margin-right: 4px; }\n      .next-btn.next-small.next-btn-loading > .next-icon {\n        display: none; }\n  .next-btn.next-medium {\n    border-radius: 3px;\n    padding: 0 12px;\n    height: 28px;\n    line-height: 26px;\n    font-size: 12px;\n    border-width: 1px; }\n    .next-btn.next-medium > .next-btn-icon.next-icon-first {\n      margin-left: 0;\n      margin-right: 4px; }\n      .next-btn.next-medium > .next-btn-icon.next-icon-first:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n    .next-btn.next-medium > .next-btn-icon.next-icon-last {\n      margin-left: 4px;\n      margin-right: 0; }\n      .next-btn.next-medium > .next-btn-icon.next-icon-last:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n    .next-btn.next-medium > .next-btn-icon.next-icon-alone:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n    .next-btn.next-medium.next-btn-loading {\n      padding-left: 28px; }\n      .next-btn.next-medium.next-btn-loading:after {\n        width: 12px;\n        height: 12px;\n        font-size: 12px;\n        line-height: 12px;\n        left: 12px;\n        top: 50%;\n        text-align: center;\n        margin-top: -6px;\n        margin-right: 4px; }\n      .next-btn.next-medium.next-btn-loading > .next-icon {\n        display: none; }\n  .next-btn.next-large {\n    border-radius: 3px;\n    padding: 0 16px;\n    height: 40px;\n    line-height: 38px;\n    font-size: 16px;\n    border-width: 1px; }\n    .next-btn.next-large > .next-btn-icon.next-icon-first {\n      margin-left: 0;\n      margin-right: 4px; }\n      .next-btn.next-large > .next-btn-icon.next-icon-first:before {\n        width: 16px;\n        font-size: 16px;\n        line-height: inherit; }\n    .next-btn.next-large > .next-btn-icon.next-icon-last {\n      margin-left: 4px;\n      margin-right: 0; }\n      .next-btn.next-large > .next-btn-icon.next-icon-last:before {\n        width: 16px;\n        font-size: 16px;\n        line-height: inherit; }\n    .next-btn.next-large > .next-btn-icon.next-icon-alone:before {\n      width: 16px;\n      font-size: 16px;\n      line-height: inherit; }\n    .next-btn.next-large.next-btn-loading {\n      padding-left: 36px; }\n      .next-btn.next-large.next-btn-loading:after {\n        width: 16px;\n        height: 16px;\n        font-size: 16px;\n        line-height: 16px;\n        left: 16px;\n        top: 50%;\n        text-align: center;\n        margin-top: -8px;\n        margin-right: 4px; }\n      .next-btn.next-large.next-btn-loading > .next-icon {\n        display: none; }\n  .next-btn.next-btn-normal {\n    border-style: solid;\n    background-color: #FFFFFF;\n    border-color: #C4C6CF; }\n    .next-btn.next-btn-normal, .next-btn.next-btn-normal:link, .next-btn.next-btn-normal:visited, .next-btn.next-btn-normal.visited {\n      color: #333333; }\n    .next-btn.next-btn-normal:focus, .next-btn.next-btn-normal:hover, .next-btn.next-btn-normal.hover, .next-btn.next-btn-normal:active, .next-btn.next-btn-normal.active {\n      color: #333333;\n      background-color: #F2F3F7;\n      border-color: #A0A2AD;\n      text-decoration: none; }\n  .next-btn.next-btn-primary {\n    border-style: solid;\n    background-color: #5584FF;\n    border-color: transparent; }\n    .next-btn.next-btn-primary, .next-btn.next-btn-primary:link, .next-btn.next-btn-primary:visited, .next-btn.next-btn-primary.visited {\n      color: #FFFFFF; }\n    .next-btn.next-btn-primary:focus, .next-btn.next-btn-primary:hover, .next-btn.next-btn-primary.hover, .next-btn.next-btn-primary:active, .next-btn.next-btn-primary.active {\n      color: #FFFFFF;\n      background-color: #3E71F7;\n      border-color: transparent;\n      text-decoration: none; }\n  .next-btn.next-btn-secondary {\n    border-style: solid;\n    background-color: #FFFFFF;\n    border-color: #5584FF; }\n    .next-btn.next-btn-secondary, .next-btn.next-btn-secondary:link, .next-btn.next-btn-secondary:visited, .next-btn.next-btn-secondary.visited {\n      color: #5584FF; }\n    .next-btn.next-btn-secondary:focus, .next-btn.next-btn-secondary:hover, .next-btn.next-btn-secondary.hover, .next-btn.next-btn-secondary:active, .next-btn.next-btn-secondary.active {\n      color: #FFFFFF;\n      background-color: #3E71F7;\n      border-color: #3E71F7;\n      text-decoration: none; }\n  .next-btn.disabled, .next-btn[disabled] {\n    cursor: not-allowed;\n    background-color: #F7F8FA;\n    border-color: #E6E7EB; }\n    .next-btn.disabled, .next-btn.disabled:link, .next-btn.disabled:visited, .next-btn.disabled.visited, .next-btn[disabled], .next-btn[disabled]:link, .next-btn[disabled]:visited, .next-btn[disabled].visited {\n      color: #CCCCCC; }\n    .next-btn.disabled:focus, .next-btn.disabled:hover, .next-btn.disabled.hover, .next-btn.disabled:active, .next-btn.disabled.active, .next-btn[disabled]:focus, .next-btn[disabled]:hover, .next-btn[disabled].hover, .next-btn[disabled]:active, .next-btn[disabled].active {\n      color: #CCCCCC;\n      background-color: #F7F8FA;\n      border-color: #E6E7EB;\n      text-decoration: none; }\n  .next-btn-warning {\n    border-style: solid; }\n    .next-btn-warning.next-btn-primary {\n      background-color: #FF3000;\n      border-color: #FF3000; }\n      .next-btn-warning.next-btn-primary, .next-btn-warning.next-btn-primary:link, .next-btn-warning.next-btn-primary:visited, .next-btn-warning.next-btn-primary.visited {\n        color: #FFFFFF; }\n      .next-btn-warning.next-btn-primary:focus, .next-btn-warning.next-btn-primary:hover, .next-btn-warning.next-btn-primary.hover, .next-btn-warning.next-btn-primary:active, .next-btn-warning.next-btn-primary.active {\n        color: #FFFFFF;\n        background-color: #E72B00;\n        border-color: #E72B00;\n        text-decoration: none; }\n      .next-btn-warning.next-btn-primary.disabled, .next-btn-warning.next-btn-primary[disabled] {\n        background-color: #F7F8FA;\n        border-color: #DCDEE3; }\n        .next-btn-warning.next-btn-primary.disabled, .next-btn-warning.next-btn-primary.disabled:link, .next-btn-warning.next-btn-primary.disabled:visited, .next-btn-warning.next-btn-primary.disabled.visited, .next-btn-warning.next-btn-primary[disabled], .next-btn-warning.next-btn-primary[disabled]:link, .next-btn-warning.next-btn-primary[disabled]:visited, .next-btn-warning.next-btn-primary[disabled].visited {\n          color: #CCCCCC; }\n        .next-btn-warning.next-btn-primary.disabled:focus, .next-btn-warning.next-btn-primary.disabled:hover, .next-btn-warning.next-btn-primary.disabled.hover, .next-btn-warning.next-btn-primary.disabled:active, .next-btn-warning.next-btn-primary.disabled.active, .next-btn-warning.next-btn-primary[disabled]:focus, .next-btn-warning.next-btn-primary[disabled]:hover, .next-btn-warning.next-btn-primary[disabled].hover, .next-btn-warning.next-btn-primary[disabled]:active, .next-btn-warning.next-btn-primary[disabled].active {\n          color: #CCCCCC;\n          background-color: #F7F8FA;\n          border-color: #DCDEE3;\n          text-decoration: none; }\n    .next-btn-warning.next-btn-normal {\n      background-color: #FFFFFF;\n      border-color: #FF3000; }\n      .next-btn-warning.next-btn-normal, .next-btn-warning.next-btn-normal:link, .next-btn-warning.next-btn-normal:visited, .next-btn-warning.next-btn-normal.visited {\n        color: #FF3000; }\n      .next-btn-warning.next-btn-normal:focus, .next-btn-warning.next-btn-normal:hover, .next-btn-warning.next-btn-normal.hover, .next-btn-warning.next-btn-normal:active, .next-btn-warning.next-btn-normal.active {\n        color: #FFFFFF;\n        background-color: #E72B00;\n        border-color: #E72B00;\n        text-decoration: none; }\n      .next-btn-warning.next-btn-normal.disabled, .next-btn-warning.next-btn-normal[disabled] {\n        background-color: #F7F8FA;\n        border-color: #E6E7EB; }\n        .next-btn-warning.next-btn-normal.disabled, .next-btn-warning.next-btn-normal.disabled:link, .next-btn-warning.next-btn-normal.disabled:visited, .next-btn-warning.next-btn-normal.disabled.visited, .next-btn-warning.next-btn-normal[disabled], .next-btn-warning.next-btn-normal[disabled]:link, .next-btn-warning.next-btn-normal[disabled]:visited, .next-btn-warning.next-btn-normal[disabled].visited {\n          color: #CCCCCC; }\n        .next-btn-warning.next-btn-normal.disabled:focus, .next-btn-warning.next-btn-normal.disabled:hover, .next-btn-warning.next-btn-normal.disabled.hover, .next-btn-warning.next-btn-normal.disabled:active, .next-btn-warning.next-btn-normal.disabled.active, .next-btn-warning.next-btn-normal[disabled]:focus, .next-btn-warning.next-btn-normal[disabled]:hover, .next-btn-warning.next-btn-normal[disabled].hover, .next-btn-warning.next-btn-normal[disabled]:active, .next-btn-warning.next-btn-normal[disabled].active {\n          color: #CCCCCC;\n          background-color: #F7F8FA;\n          border-color: #E6E7EB;\n          text-decoration: none; }\n  .next-btn-text {\n    -webkit-box-shadow: none;\n            box-shadow: none;\n    border-radius: 0; }\n    .next-btn-text.hover, .next-btn-text:hover {\n      -webkit-box-shadow: none;\n              box-shadow: none; }\n    .next-btn-text.next-btn-primary {\n      background-color: transparent;\n      border-color: transparent; }\n      .next-btn-text.next-btn-primary, .next-btn-text.next-btn-primary:link, .next-btn-text.next-btn-primary:visited, .next-btn-text.next-btn-primary.visited {\n        color: #5584FF; }\n      .next-btn-text.next-btn-primary:focus, .next-btn-text.next-btn-primary:hover, .next-btn-text.next-btn-primary.hover, .next-btn-text.next-btn-primary:active, .next-btn-text.next-btn-primary.active {\n        color: #3E71F7;\n        background-color: transparent;\n        border-color: transparent;\n        text-decoration: none; }\n    .next-btn-text.next-btn-secondary {\n      background-color: transparent;\n      border-color: transparent; }\n      .next-btn-text.next-btn-secondary, .next-btn-text.next-btn-secondary:link, .next-btn-text.next-btn-secondary:visited, .next-btn-text.next-btn-secondary.visited {\n        color: #666666; }\n      .next-btn-text.next-btn-secondary:focus, .next-btn-text.next-btn-secondary:hover, .next-btn-text.next-btn-secondary.hover, .next-btn-text.next-btn-secondary:active, .next-btn-text.next-btn-secondary.active {\n        color: #5584FF;\n        background-color: transparent;\n        border-color: transparent;\n        text-decoration: none; }\n    .next-btn-text.next-btn-normal {\n      background-color: transparent;\n      border-color: transparent; }\n      .next-btn-text.next-btn-normal, .next-btn-text.next-btn-normal:link, .next-btn-text.next-btn-normal:visited, .next-btn-text.next-btn-normal.visited {\n        color: #333333; }\n      .next-btn-text.next-btn-normal:focus, .next-btn-text.next-btn-normal:hover, .next-btn-text.next-btn-normal.hover, .next-btn-text.next-btn-normal:active, .next-btn-text.next-btn-normal.active {\n        color: #5584FF;\n        background-color: transparent;\n        border-color: transparent;\n        text-decoration: none; }\n    .next-btn-text.next-large {\n      border-radius: 0;\n      padding: 0 0;\n      height: 24px;\n      line-height: 24px;\n      font-size: 14px;\n      border-width: 0; }\n      .next-btn-text.next-large > .next-btn-icon.next-icon-first {\n        margin-left: 0;\n        margin-right: 4px; }\n        .next-btn-text.next-large > .next-btn-icon.next-icon-first:before {\n          width: 16px;\n          font-size: 16px;\n          line-height: inherit; }\n      .next-btn-text.next-large > .next-btn-icon.next-icon-last {\n        margin-left: 4px;\n        margin-right: 0; }\n        .next-btn-text.next-large > .next-btn-icon.next-icon-last:before {\n          width: 16px;\n          font-size: 16px;\n          line-height: inherit; }\n      .next-btn-text.next-large > .next-btn-icon.next-icon-alone:before {\n        width: 16px;\n        font-size: 16px;\n        line-height: inherit; }\n      .next-btn-text.next-large.next-btn-loading {\n        padding-left: 20px; }\n        .next-btn-text.next-large.next-btn-loading:after {\n          width: 16px;\n          height: 16px;\n          font-size: 16px;\n          line-height: 16px;\n          left: 0;\n          top: 50%;\n          text-align: center;\n          margin-top: -8px;\n          margin-right: 4px; }\n        .next-btn-text.next-large.next-btn-loading > .next-icon {\n          display: none; }\n    .next-btn-text.next-medium {\n      border-radius: 0;\n      padding: 0 0;\n      height: 20px;\n      line-height: 20px;\n      font-size: 12px;\n      border-width: 0; }\n      .next-btn-text.next-medium > .next-btn-icon.next-icon-first {\n        margin-left: 0;\n        margin-right: 4px; }\n        .next-btn-text.next-medium > .next-btn-icon.next-icon-first:before {\n          width: 12px;\n          font-size: 12px;\n          line-height: inherit; }\n      .next-btn-text.next-medium > .next-btn-icon.next-icon-last {\n        margin-left: 4px;\n        margin-right: 0; }\n        .next-btn-text.next-medium > .next-btn-icon.next-icon-last:before {\n          width: 12px;\n          font-size: 12px;\n          line-height: inherit; }\n      .next-btn-text.next-medium > .next-btn-icon.next-icon-alone:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n      .next-btn-text.next-medium.next-btn-loading {\n        padding-left: 16px; }\n        .next-btn-text.next-medium.next-btn-loading:after {\n          width: 12px;\n          height: 12px;\n          font-size: 12px;\n          line-height: 12px;\n          left: 0;\n          top: 50%;\n          text-align: center;\n          margin-top: -6px;\n          margin-right: 4px; }\n        .next-btn-text.next-medium.next-btn-loading > .next-icon {\n          display: none; }\n    .next-btn-text.next-small {\n      border-radius: 0;\n      padding: 0 0;\n      height: 16px;\n      line-height: 16px;\n      font-size: 12px;\n      border-width: 0; }\n      .next-btn-text.next-small > .next-btn-icon.next-icon-first {\n        margin-left: 0;\n        margin-right: 4px; }\n        .next-btn-text.next-small > .next-btn-icon.next-icon-first:before {\n          width: 12px;\n          font-size: 12px;\n          line-height: inherit; }\n      .next-btn-text.next-small > .next-btn-icon.next-icon-last {\n        margin-left: 4px;\n        margin-right: 0; }\n        .next-btn-text.next-small > .next-btn-icon.next-icon-last:before {\n          width: 12px;\n          font-size: 12px;\n          line-height: inherit; }\n      .next-btn-text.next-small > .next-btn-icon.next-icon-alone:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n      .next-btn-text.next-small.next-btn-loading {\n        padding-left: 16px; }\n        .next-btn-text.next-small.next-btn-loading:after {\n          width: 12px;\n          height: 12px;\n          font-size: 12px;\n          line-height: 12px;\n          left: 0;\n          top: 50%;\n          text-align: center;\n          margin-top: -6px;\n          margin-right: 4px; }\n        .next-btn-text.next-small.next-btn-loading > .next-icon {\n          display: none; }\n    .next-btn-text.disabled, .next-btn-text[disabled] {\n      background-color: transparent;\n      border-color: transparent; }\n      .next-btn-text.disabled, .next-btn-text.disabled:link, .next-btn-text.disabled:visited, .next-btn-text.disabled.visited, .next-btn-text[disabled], .next-btn-text[disabled]:link, .next-btn-text[disabled]:visited, .next-btn-text[disabled].visited {\n        color: #CCCCCC; }\n      .next-btn-text.disabled:focus, .next-btn-text.disabled:hover, .next-btn-text.disabled.hover, .next-btn-text.disabled:active, .next-btn-text.disabled.active, .next-btn-text[disabled]:focus, .next-btn-text[disabled]:hover, .next-btn-text[disabled].hover, .next-btn-text[disabled]:active, .next-btn-text[disabled].active {\n        color: #CCCCCC;\n        background-color: transparent;\n        border-color: transparent;\n        text-decoration: none; }\n    .next-btn-text.next-btn-loading {\n      background-color: transparent;\n      border-color: transparent; }\n      .next-btn-text.next-btn-loading, .next-btn-text.next-btn-loading:link, .next-btn-text.next-btn-loading:visited, .next-btn-text.next-btn-loading.visited {\n        color: #333333; }\n      .next-btn-text.next-btn-loading:focus, .next-btn-text.next-btn-loading:hover, .next-btn-text.next-btn-loading.hover, .next-btn-text.next-btn-loading:active, .next-btn-text.next-btn-loading.active {\n        color: #333333;\n        background-color: transparent;\n        border-color: transparent;\n        text-decoration: none; }\n  .next-btn-loading {\n    pointer-events: none; }\n    .next-btn-loading:after {\n      font-family: NextIcon;\n      content: \"\\E646\";\n      opacity: 1;\n      visibility: visible;\n      -webkit-animation: loadingCircle 2s infinite linear;\n              animation: loadingCircle 2s infinite linear; }\n  .next-btn-ghost {\n    -webkit-box-shadow: none;\n            box-shadow: none;\n    border-style: solid; }\n    .next-btn-ghost.next-btn-dark {\n      background-color: transparent;\n      border-color: #FFFFFF; }\n      .next-btn-ghost.next-btn-dark, .next-btn-ghost.next-btn-dark:link, .next-btn-ghost.next-btn-dark:visited, .next-btn-ghost.next-btn-dark.visited {\n        color: #FFFFFF; }\n      .next-btn-ghost.next-btn-dark:focus, .next-btn-ghost.next-btn-dark:hover, .next-btn-ghost.next-btn-dark.hover, .next-btn-ghost.next-btn-dark:active, .next-btn-ghost.next-btn-dark.active {\n        color: #FFFFFF;\n        background-color: rgba(255, 255, 255, 0.8);\n        border-color: #FFFFFF;\n        text-decoration: none; }\n      .next-btn-ghost.next-btn-dark.disabled, .next-btn-ghost.next-btn-dark[disabled] {\n        background-color: transparent;\n        border-color: rgba(255, 255, 255, 0.4); }\n        .next-btn-ghost.next-btn-dark.disabled, .next-btn-ghost.next-btn-dark.disabled:link, .next-btn-ghost.next-btn-dark.disabled:visited, .next-btn-ghost.next-btn-dark.disabled.visited, .next-btn-ghost.next-btn-dark[disabled], .next-btn-ghost.next-btn-dark[disabled]:link, .next-btn-ghost.next-btn-dark[disabled]:visited, .next-btn-ghost.next-btn-dark[disabled].visited {\n          color: rgba(255, 255, 255, 0.4); }\n        .next-btn-ghost.next-btn-dark.disabled:focus, .next-btn-ghost.next-btn-dark.disabled:hover, .next-btn-ghost.next-btn-dark.disabled.hover, .next-btn-ghost.next-btn-dark.disabled:active, .next-btn-ghost.next-btn-dark.disabled.active, .next-btn-ghost.next-btn-dark[disabled]:focus, .next-btn-ghost.next-btn-dark[disabled]:hover, .next-btn-ghost.next-btn-dark[disabled].hover, .next-btn-ghost.next-btn-dark[disabled]:active, .next-btn-ghost.next-btn-dark[disabled].active {\n          color: rgba(255, 255, 255, 0.4);\n          background-color: transparent;\n          border-color: rgba(255, 255, 255, 0.4);\n          text-decoration: none; }\n    .next-btn-ghost.next-btn-light {\n      background-color: transparent;\n      border-color: #333333; }\n      .next-btn-ghost.next-btn-light, .next-btn-ghost.next-btn-light:link, .next-btn-ghost.next-btn-light:visited, .next-btn-ghost.next-btn-light.visited {\n        color: #333333; }\n      .next-btn-ghost.next-btn-light:focus, .next-btn-ghost.next-btn-light:hover, .next-btn-ghost.next-btn-light.hover, .next-btn-ghost.next-btn-light:active, .next-btn-ghost.next-btn-light.active {\n        color: #999999;\n        background-color: rgba(0, 0, 0, 0.92);\n        border-color: #333333;\n        text-decoration: none; }\n      .next-btn-ghost.next-btn-light.disabled, .next-btn-ghost.next-btn-light[disabled] {\n        background-color: transparent;\n        border-color: rgba(0, 0, 0, 0.1); }\n        .next-btn-ghost.next-btn-light.disabled, .next-btn-ghost.next-btn-light.disabled:link, .next-btn-ghost.next-btn-light.disabled:visited, .next-btn-ghost.next-btn-light.disabled.visited, .next-btn-ghost.next-btn-light[disabled], .next-btn-ghost.next-btn-light[disabled]:link, .next-btn-ghost.next-btn-light[disabled]:visited, .next-btn-ghost.next-btn-light[disabled].visited {\n          color: rgba(0, 0, 0, 0.1); }\n        .next-btn-ghost.next-btn-light.disabled:focus, .next-btn-ghost.next-btn-light.disabled:hover, .next-btn-ghost.next-btn-light.disabled.hover, .next-btn-ghost.next-btn-light.disabled:active, .next-btn-ghost.next-btn-light.disabled.active, .next-btn-ghost.next-btn-light[disabled]:focus, .next-btn-ghost.next-btn-light[disabled]:hover, .next-btn-ghost.next-btn-light[disabled].hover, .next-btn-ghost.next-btn-light[disabled]:active, .next-btn-ghost.next-btn-light[disabled].active {\n          color: rgba(0, 0, 0, 0.1);\n          background-color: transparent;\n          border-color: rgba(0, 0, 0, 0.1);\n          text-decoration: none; }\n  .next-btn-group {\n    position: relative;\n    display: inline-block;\n    vertical-align: middle; }\n    .next-btn-group > .next-btn {\n      position: relative;\n      float: left;\n      -webkit-box-shadow: none;\n              box-shadow: none; }\n      .next-btn-group > .next-btn:hover, .next-btn-group > .next-btn:focus, .next-btn-group > .next-btn:active, .next-btn-group > .next-btn.active {\n        z-index: 1; }\n      .next-btn-group > .next-btn.disabled, .next-btn-group > .next-btn[disabled] {\n        z-index: 0; }\n    .next-btn-group .next-btn.next-btn {\n      margin: 0 0 0 -1px; }\n    .next-btn-group .next-btn:not(:first-child):not(:last-child) {\n      border-radius: 0; }\n    .next-btn-group > .next-btn:first-child {\n      margin: 0; }\n    .next-btn-group > .next-btn:first-child:not(:last-child) {\n      border-bottom-right-radius: 0;\n      border-top-right-radius: 0; }\n    .next-btn-group > .next-btn:last-child:not(:first-child) {\n      border-bottom-left-radius: 0;\n      border-top-left-radius: 0; }\n    .next-btn-group > .next-btn-primary:not(:first-child) {\n      border-left-color: rgba(255, 255, 255, 0.2); }\n      .next-btn-group > .next-btn-primary:not(:first-child):hover {\n        border-left-color: transparent; }\n      .next-btn-group > .next-btn-primary:not(:first-child).disabled, .next-btn-group > .next-btn-primary:not(:first-child)[disabled] {\n        border-left-color: #E6E7EB; }\n\n/* 组合 */\n/* ---------------------------------------- */\n.next-btn-group[dir=\"rtl\"] > .next-btn {\n  float: right; }\n\n.next-btn-group[dir=\"rtl\"] .next-btn.next-btn {\n  margin: 0 -1px 0 0; }\n\n.next-btn-group[dir=\"rtl\"] > .next-btn:first-child:not(:last-child) {\n  border-bottom-left-radius: 0;\n  border-top-left-radius: 0; }\n\n.next-btn-group[dir=\"rtl\"] > .next-btn:last-child:not(:first-child) {\n  border-bottom-right-radius: 0;\n  border-top-right-radius: 0; }\n\n.next-btn-group[dir=\"rtl\"] > .next-btn-primary:not(:first-child) {\n  border-right-color: rgba(255, 255, 255, 0.2); }\n  .next-btn-group[dir=\"rtl\"] > .next-btn-primary:not(:first-child):hover {\n    border-right-color: transparent; }\n  .next-btn-group[dir=\"rtl\"] > .next-btn-primary:not(:first-child).disabled, .next-btn-group[dir=\"rtl\"] > .next-btn-primary:not(:first-child)[disabled] {\n    border-right-color: #E6E7EB; }\n\n/* 尺寸维度 */\n/* ---------------------------------------- */\n.next-btn.next-small[dir=\"rtl\"] {\n  border-radius: 3px; }\n  .next-btn.next-small[dir=\"rtl\"] > .next-btn-icon.next-icon-first {\n    margin-left: 4px;\n    margin-right: 0; }\n    .next-btn.next-small[dir=\"rtl\"] > .next-btn-icon.next-icon-first:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn.next-small[dir=\"rtl\"] > .next-btn-icon.next-icon-last {\n    margin-left: 0;\n    margin-right: 4px; }\n    .next-btn.next-small[dir=\"rtl\"] > .next-btn-icon.next-icon-last:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn.next-small[dir=\"rtl\"].next-btn-loading {\n    padding-left: 8px;\n    padding-right: 24px; }\n    .next-btn.next-small[dir=\"rtl\"].next-btn-loading:after {\n      right: 8px;\n      top: 50%;\n      margin-right: 0;\n      margin-left: 4px; }\n\n.next-btn.next-medium[dir=\"rtl\"] {\n  border-radius: 3px; }\n  .next-btn.next-medium[dir=\"rtl\"] > .next-btn-icon.next-icon-first {\n    margin-left: 4px;\n    margin-right: 0; }\n    .next-btn.next-medium[dir=\"rtl\"] > .next-btn-icon.next-icon-first:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn.next-medium[dir=\"rtl\"] > .next-btn-icon.next-icon-last {\n    margin-left: 0;\n    margin-right: 4px; }\n    .next-btn.next-medium[dir=\"rtl\"] > .next-btn-icon.next-icon-last:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn.next-medium[dir=\"rtl\"].next-btn-loading {\n    padding-left: 12px;\n    padding-right: 28px; }\n    .next-btn.next-medium[dir=\"rtl\"].next-btn-loading:after {\n      right: 12px;\n      top: 50%;\n      margin-right: 0;\n      margin-left: 4px; }\n\n.next-btn.next-large[dir=\"rtl\"] {\n  border-radius: 3px; }\n  .next-btn.next-large[dir=\"rtl\"] > .next-btn-icon.next-icon-first {\n    margin-left: 4px;\n    margin-right: 0; }\n    .next-btn.next-large[dir=\"rtl\"] > .next-btn-icon.next-icon-first:before {\n      width: 16px;\n      font-size: 16px;\n      line-height: inherit; }\n  .next-btn.next-large[dir=\"rtl\"] > .next-btn-icon.next-icon-last {\n    margin-left: 0;\n    margin-right: 4px; }\n    .next-btn.next-large[dir=\"rtl\"] > .next-btn-icon.next-icon-last:before {\n      width: 16px;\n      font-size: 16px;\n      line-height: inherit; }\n  .next-btn.next-large[dir=\"rtl\"].next-btn-loading {\n    padding-left: 16px;\n    padding-right: 36px; }\n    .next-btn.next-large[dir=\"rtl\"].next-btn-loading:after {\n      right: 16px;\n      top: 50%;\n      margin-right: 0;\n      margin-left: 4px; }\n\n/* 文本按钮 */\n.next-btn-text[dir=\"rtl\"].next-large {\n  border-radius: 0; }\n  .next-btn-text[dir=\"rtl\"].next-large > .next-btn-icon.next-icon-first {\n    margin-left: 4px;\n    margin-right: 0; }\n    .next-btn-text[dir=\"rtl\"].next-large > .next-btn-icon.next-icon-first:before {\n      width: 16px;\n      font-size: 16px;\n      line-height: inherit; }\n  .next-btn-text[dir=\"rtl\"].next-large > .next-btn-icon.next-icon-last {\n    margin-left: 0;\n    margin-right: 4px; }\n    .next-btn-text[dir=\"rtl\"].next-large > .next-btn-icon.next-icon-last:before {\n      width: 16px;\n      font-size: 16px;\n      line-height: inherit; }\n  .next-btn-text[dir=\"rtl\"].next-large.next-btn-loading {\n    padding-left: 0;\n    padding-right: 20px; }\n    .next-btn-text[dir=\"rtl\"].next-large.next-btn-loading:after {\n      right: 0;\n      top: 50%;\n      margin-right: 0;\n      margin-left: 4px; }\n\n.next-btn-text[dir=\"rtl\"].next-medium {\n  border-radius: 0; }\n  .next-btn-text[dir=\"rtl\"].next-medium > .next-btn-icon.next-icon-first {\n    margin-left: 4px;\n    margin-right: 0; }\n    .next-btn-text[dir=\"rtl\"].next-medium > .next-btn-icon.next-icon-first:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn-text[dir=\"rtl\"].next-medium > .next-btn-icon.next-icon-last {\n    margin-left: 0;\n    margin-right: 4px; }\n    .next-btn-text[dir=\"rtl\"].next-medium > .next-btn-icon.next-icon-last:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn-text[dir=\"rtl\"].next-medium.next-btn-loading {\n    padding-left: 0;\n    padding-right: 16px; }\n    .next-btn-text[dir=\"rtl\"].next-medium.next-btn-loading:after {\n      right: 0;\n      top: 50%;\n      margin-right: 0;\n      margin-left: 4px; }\n\n.next-btn-text[dir=\"rtl\"].next-small {\n  border-radius: 0; }\n  .next-btn-text[dir=\"rtl\"].next-small > .next-btn-icon.next-icon-first {\n    margin-left: 4px;\n    margin-right: 0; }\n    .next-btn-text[dir=\"rtl\"].next-small > .next-btn-icon.next-icon-first:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn-text[dir=\"rtl\"].next-small > .next-btn-icon.next-icon-last {\n    margin-left: 0;\n    margin-right: 4px; }\n    .next-btn-text[dir=\"rtl\"].next-small > .next-btn-icon.next-icon-last:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn-text[dir=\"rtl\"].next-small.next-btn-loading {\n    padding-left: 0;\n    padding-right: 16px; }\n    .next-btn-text[dir=\"rtl\"].next-small.next-btn-loading:after {\n      right: 0;\n      top: 50%;\n      margin-right: 0;\n      margin-left: 4px; }\n", ""]);

// exports


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n.next-overlay-wrapper .next-overlay-inner {\n  z-index: 1001; }\n\n.next-overlay-wrapper .next-overlay-backdrop {\n  position: fixed;\n  z-index: 1001;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: #000000;\n  -webkit-transition: opacity .3s;\n  transition: opacity .3s;\n  opacity: 0; }\n\n.next-overlay-wrapper.opened .next-overlay-backdrop {\n  opacity: 0.2; }\n", ""]);

// exports


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "", ""]);

// exports


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n/* put your code here */\n.next-loading {\n  position: relative;\n  display: inline-block;\n  /* 遮罩层 */\n  /* for IE9,10 */\n  /* text on the right side of */\n  /* 动效 */ }\n  .next-loading.next-open {\n    pointer-events: none; }\n  .next-loading .next-loading-component {\n    opacity: .7;\n    -webkit-filter: blur(1px);\n    filter: blur(1px);\n    -webkit-filter: \"progid:DXImageTransform.Microsoft.Blur(PixelRadius=1, MakeShadow=false)\";\n            filter: \"progid:DXImageTransform.Microsoft.Blur(PixelRadius=1, MakeShadow=false)\";\n    /* IE6~IE9 */\n    position: relative;\n    pointer-events: none; }\n  .next-loading-masker {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    z-index: 99;\n    opacity: .2;\n    background: #FFF; }\n  .next-loading-tip {\n    display: block;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    z-index: 4;\n    -webkit-transform: translate(-50%, -50%);\n        -ms-transform: translate(-50%, -50%);\n            transform: translate(-50%, -50%);\n    text-align: center; }\n  .next-loading-tip-placeholder {\n    display: none; }\n  .next-loading-right-tip .next-loading-indicator {\n    display: inline-block; }\n  .next-loading-right-tip .next-loading-tip-content {\n    position: absolute;\n    display: block;\n    top: 50%;\n    right: 0;\n    -webkit-transform: translate(0, -50%);\n        -ms-transform: translate(0, -50%);\n            transform: translate(0, -50%); }\n  .next-loading-right-tip .next-loading-tip-placeholder {\n    display: inline-block;\n    visibility: hidden;\n    margin-left: 1em; }\n  .next-loading-fusion-reactor {\n    display: inline-block;\n    width: 48px;\n    height: 48px;\n    position: relative;\n    margin: 0;\n    -webkit-animation-duration: 5.6s;\n    animation-duration: 5.6s;\n    -webkit-animation-iteration-count: infinite;\n    animation-iteration-count: infinite;\n    -webkit-animation-timing-function: linear;\n    animation-timing-function: linear;\n    -webkit-animation-name: nextVectorRoute;\n    animation-name: nextVectorRoute; }\n    .next-loading-fusion-reactor .next-loading-dot {\n      position: absolute;\n      margin: auto;\n      width: 12px;\n      height: 12px;\n      border-radius: 50%;\n      background: #5584FF;\n      -webkit-animation-timing-function: ease-in-out;\n      animation-timing-function: ease-in-out;\n      -webkit-animation-iteration-count: infinite;\n      animation-iteration-count: infinite;\n      -webkit-animation-duration: 1.4s;\n      animation-duration: 1.4s; }\n      .next-loading-fusion-reactor .next-loading-dot:nth-child(1) {\n        top: 0;\n        bottom: 0;\n        left: 0;\n        -webkit-animation-name: nextVectorDotsX;\n        animation-name: nextVectorDotsX; }\n      .next-loading-fusion-reactor .next-loading-dot:nth-child(2) {\n        left: 0;\n        right: 0;\n        top: 0;\n        opacity: .8;\n        -webkit-animation-name: nextVectorDotsY;\n        animation-name: nextVectorDotsY; }\n      .next-loading-fusion-reactor .next-loading-dot:nth-child(3) {\n        top: 0;\n        bottom: 0;\n        right: 0;\n        opacity: .6;\n        -webkit-animation-name: nextVectorDotsXR;\n        animation-name: nextVectorDotsXR; }\n      .next-loading-fusion-reactor .next-loading-dot:nth-child(4) {\n        left: 0;\n        right: 0;\n        bottom: 0;\n        opacity: .2;\n        -webkit-animation-name: nextVectorDotsYR;\n        animation-name: nextVectorDotsYR; }\n  .next-loading-medium-fusion-reactor {\n    width: 32px;\n    height: 32px; }\n    .next-loading-medium-fusion-reactor .next-loading-dot {\n      width: 8px;\n      height: 8px; }\n      .next-loading-medium-fusion-reactor .next-loading-dot:nth-child(1) {\n        -webkit-animation-name: nextVectorDotsX-medium;\n        animation-name: nextVectorDotsX-medium; }\n      .next-loading-medium-fusion-reactor .next-loading-dot:nth-child(2) {\n        -webkit-animation-name: nextVectorDotsY-medium;\n        animation-name: nextVectorDotsY-medium; }\n      .next-loading-medium-fusion-reactor .next-loading-dot:nth-child(3) {\n        -webkit-animation-name: nextVectorDotsXR-medium;\n        animation-name: nextVectorDotsXR-medium; }\n      .next-loading-medium-fusion-reactor .next-loading-dot:nth-child(4) {\n        -webkit-animation-name: nextVectorDotsYR-medium;\n        animation-name: nextVectorDotsYR-medium; }\n\n@-webkit-keyframes nextVectorRoute {\n  0% {\n    -webkit-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    transform: rotate(0deg); }\n  5% {\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    transform: rotate(90deg); }\n  25% {\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    transform: rotate(90deg); }\n  30% {\n    -webkit-transform: rotate(180deg);\n    -ms-transform: rotate(180deg);\n    transform: rotate(180deg); }\n  50% {\n    -webkit-transform: rotate(180deg);\n    -ms-transform: rotate(180deg);\n    transform: rotate(180deg); }\n  55% {\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    transform: rotate(270deg); }\n  75% {\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    transform: rotate(270deg); }\n  80% {\n    -webkit-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    transform: rotate(360deg); }\n  100% {\n    -webkit-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    transform: rotate(360deg); } }\n\n@keyframes nextVectorRoute {\n  0% {\n    -webkit-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    transform: rotate(0deg); }\n  5% {\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    transform: rotate(90deg); }\n  25% {\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    transform: rotate(90deg); }\n  30% {\n    -webkit-transform: rotate(180deg);\n    -ms-transform: rotate(180deg);\n    transform: rotate(180deg); }\n  50% {\n    -webkit-transform: rotate(180deg);\n    -ms-transform: rotate(180deg);\n    transform: rotate(180deg); }\n  55% {\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    transform: rotate(270deg); }\n  75% {\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    transform: rotate(270deg); }\n  80% {\n    -webkit-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    transform: rotate(360deg); }\n  100% {\n    -webkit-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    transform: rotate(360deg); } }\n\n/* 20% 的时间在旋转 */\n@-webkit-keyframes nextVectorDotsYR {\n  25% {\n    bottom: 0; }\n  45%,\n  50% {\n    bottom: 16.8px;\n    height: 14.4px;\n    width: 14.4px; }\n  90% {\n    bottom: 0;\n    height: 12px;\n    width: 12px; } }\n\n@keyframes nextVectorDotsYR {\n  25% {\n    bottom: 0; }\n  45%,\n  50% {\n    bottom: 16.8px;\n    height: 14.4px;\n    width: 14.4px; }\n  90% {\n    bottom: 0;\n    height: 12px;\n    width: 12px; } }\n\n@-webkit-keyframes nextVectorDotsY {\n  25% {\n    top: 0; }\n  45%,\n  50% {\n    top: 16.8px;\n    height: 14.4px;\n    width: 14.4px; }\n  90% {\n    top: 0;\n    height: 12px;\n    width: 12px; } }\n\n@keyframes nextVectorDotsY {\n  25% {\n    top: 0; }\n  45%,\n  50% {\n    top: 16.8px;\n    height: 14.4px;\n    width: 14.4px; }\n  90% {\n    top: 0;\n    height: 12px;\n    width: 12px; } }\n\n@-webkit-keyframes nextVectorDotsX {\n  25% {\n    left: 0; }\n  45%,\n  50% {\n    left: 16.8px;\n    width: 14.4px;\n    height: 14.4px; }\n  90% {\n    left: 0;\n    height: 12px;\n    width: 12px; } }\n\n@keyframes nextVectorDotsX {\n  25% {\n    left: 0; }\n  45%,\n  50% {\n    left: 16.8px;\n    width: 14.4px;\n    height: 14.4px; }\n  90% {\n    left: 0;\n    height: 12px;\n    width: 12px; } }\n\n@-webkit-keyframes nextVectorDotsXR {\n  25% {\n    right: 0; }\n  45%,\n  50% {\n    right: 16.8px;\n    width: 14.4px;\n    height: 14.4px; }\n  90% {\n    right: 0;\n    height: 12px;\n    width: 12px; } }\n\n@keyframes nextVectorDotsXR {\n  25% {\n    right: 0; }\n  45%,\n  50% {\n    right: 16.8px;\n    width: 14.4px;\n    height: 14.4px; }\n  90% {\n    right: 0;\n    height: 12px;\n    width: 12px; } }\n\n@-webkit-keyframes nextVectorDotsYR-medium {\n  25% {\n    bottom: 0; }\n  45%,\n  50% {\n    bottom: 11.2px;\n    height: 9.6px;\n    width: 9.6px; }\n  90% {\n    bottom: 0;\n    height: 8px;\n    width: 8px; } }\n\n@keyframes nextVectorDotsYR-medium {\n  25% {\n    bottom: 0; }\n  45%,\n  50% {\n    bottom: 11.2px;\n    height: 9.6px;\n    width: 9.6px; }\n  90% {\n    bottom: 0;\n    height: 8px;\n    width: 8px; } }\n\n@-webkit-keyframes nextVectorDotsY-medium {\n  25% {\n    top: 0; }\n  45%,\n  50% {\n    top: 11.2px;\n    height: 9.6px;\n    width: 9.6px; }\n  90% {\n    top: 0;\n    height: 8px;\n    width: 8px; } }\n\n@keyframes nextVectorDotsY-medium {\n  25% {\n    top: 0; }\n  45%,\n  50% {\n    top: 11.2px;\n    height: 9.6px;\n    width: 9.6px; }\n  90% {\n    top: 0;\n    height: 8px;\n    width: 8px; } }\n\n@-webkit-keyframes nextVectorDotsX-medium {\n  25% {\n    left: 0; }\n  45%,\n  50% {\n    left: 11.2px;\n    width: 9.6px;\n    height: 9.6px; }\n  90% {\n    left: 0;\n    height: 8px;\n    width: 8px; } }\n\n@keyframes nextVectorDotsX-medium {\n  25% {\n    left: 0; }\n  45%,\n  50% {\n    left: 11.2px;\n    width: 9.6px;\n    height: 9.6px; }\n  90% {\n    left: 0;\n    height: 8px;\n    width: 8px; } }\n\n@-webkit-keyframes nextVectorDotsXR-medium {\n  25% {\n    right: 0; }\n  45%,\n  50% {\n    right: 11.2px;\n    width: 9.6px;\n    height: 9.6px; }\n  90% {\n    right: 0;\n    height: 8px;\n    width: 8px; } }\n\n@keyframes nextVectorDotsXR-medium {\n  25% {\n    right: 0; }\n  45%,\n  50% {\n    right: 11.2px;\n    width: 9.6px;\n    height: 9.6px; }\n  90% {\n    right: 0;\n    height: 8px;\n    width: 8px; } }\n", ""]);

// exports


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n/* put your code here */\n.next-table {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  position: relative; }\n  .next-table *,\n  .next-table *:before,\n  .next-table *:after {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box; }\n  .next-table table {\n    border-collapse: collapse;\n    border-spacing: 0;\n    width: 100%;\n    background: #FFFFFF; }\n    .next-table table tr:first-child td {\n      border-top-width: 0; }\n  .next-table th {\n    padding: 0;\n    background: #EBECF0;\n    color: #333333;\n    text-align: left;\n    font-weight: normal;\n    border: 1px solid #DCDEE3; }\n    .next-table th .next-table-cell-wrapper {\n      padding: 12px 16px;\n      overflow: hidden;\n      text-overflow: ellipsis;\n      word-break: break-all; }\n  .next-table-affix {\n    z-index: 1; }\n  .next-table-header-resizable {\n    position: relative; }\n    .next-table-header-resizable .next-table-resize-handler {\n      position: absolute;\n      right: 0;\n      top: 0;\n      bottom: 0;\n      width: 3px;\n      background: transparent;\n      cursor: ew-resize; }\n  .next-table td {\n    padding: 0;\n    border: 1px solid #DCDEE3; }\n    .next-table td .next-table-cell-wrapper {\n      padding: 12px 16px;\n      overflow: hidden;\n      text-overflow: ellipsis;\n      word-break: break-all; }\n      .next-table td .next-table-cell-wrapper .next-icon-arrow-down.next-table-tree-arrow,\n      .next-table td .next-table-cell-wrapper .next-icon-arrow-right.next-table-tree-arrow,\n      .next-table td .next-table-cell-wrapper .next-table-tree-placeholder {\n        margin-right: 3px;\n        float: left; }\n      .next-table td .next-table-cell-wrapper .next-icon-arrow-down.next-table-tree-arrow:before,\n      .next-table td .next-table-cell-wrapper .next-icon-arrow-right.next-table-tree-arrow:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n  .next-table .next-table-expanded .next-table-cell-wrapper,\n  .next-table .next-table-selection .next-table-cell-wrapper {\n    overflow: visible; }\n  .next-table.no-header table tr:first-child td {\n    border-top-width: 1px; }\n  .next-table.only-bottom-border {\n    border-width: 0; }\n    .next-table.only-bottom-border th {\n      border-width: 0 0 1px 0; }\n    .next-table.only-bottom-border td {\n      border-width: 0 0 1px 0; }\n    .next-table.only-bottom-border .next-table-expanded-row th {\n      border-width: 0 0 1px 0; }\n    .next-table.only-bottom-border .next-table-expanded-row td {\n      border-width: 0 0 1px 0; }\n  .next-table-loading {\n    display: block; }\n  .next-table.zebra tr:nth-child(odd) td {\n    background: #FFFFFF; }\n  .next-table.zebra tr:nth-child(even) td {\n    background: #F7F8FA; }\n  .next-table.zebra .next-table-row.hovered td {\n    background: #F2F3F7;\n    color: #333333; }\n  .next-table.zebra .next-table-row.selected td {\n    background: #F2F3F7;\n    color: #333333; }\n  .next-table-empty {\n    color: #A0A2AD;\n    padding: 32px 0;\n    text-align: center; }\n  .next-table-expanded-row td {\n    border-width: 0; }\n    .next-table-expanded-row td:first-child {\n      border-left-width: 1px; }\n    .next-table-expanded-row td:last-child {\n      border-right-width: 1px; }\n  .next-table-expanded-row:last-child td {\n    border-bottom-width: 1px; }\n  .next-table-expanded-row .next-table .last td {\n    border-bottom-width: 0; }\n  .next-table-filter-footer {\n    margin: 10px 10px 0; }\n    .next-table-filter-footer button {\n      margin-right: 5px; }\n  .next-table-row {\n    -webkit-transition: all ease .3s;\n    transition: all ease .3s;\n    background: #FFFFFF;\n    color: #333333; }\n    .next-table-row.hidden {\n      display: none; }\n    .next-table-row.hovered {\n      background: #F2F3F7;\n      color: #333333; }\n    .next-table-row.selected {\n      background: #F2F3F7;\n      color: #333333; }\n  .next-table-tree-placeholder {\n    display: inline-block;\n    width: 12px; }\n\n.last .next-table-expanded-row td {\n  border-bottom-width: 1px; }\n\n.next-table-body,\n.next-table-header {\n  overflow: auto;\n  font-size: 12px; }\n\n.next-table-body {\n  font-size: 12px; }\n\n.next-table-fixed {\n  border: 1px solid #DCDEE3; }\n  .next-table-fixed table {\n    table-layout: fixed; }\n  .next-table-fixed .next-table-header {\n    background: #EBECF0; }\n  .next-table-fixed table tr td:first-child,\n  .next-table-fixed table tr th:first-child {\n    border-left-width: 0; }\n  .next-table-fixed .next-table-header th {\n    border-top-width: 0; }\n  .next-table-fixed .next-table-header tr th:last-child {\n    border-right-width: 0; }\n  .next-table-fixed .next-table-body td {\n    border-top-width: 0; }\n  .next-table-fixed .next-table-body tr:last-child td {\n    border-bottom-width: 0; }\n  .next-table-fixed .next-table-body tr td:last-child {\n    border-right-width: 0; }\n  .next-table-fixed.next-table-group table tr td:first-child,\n  .next-table-fixed.next-table-group table tr th:first-child {\n    border-left-width: 1px; }\n  .next-table-fixed.next-table-group .next-table-header th {\n    border-top-width: 1px; }\n  .next-table-fixed.next-table-group .next-table-header tr th:last-child {\n    border-right-width: 1px; }\n  .next-table-fixed.next-table-group .next-table-body td {\n    border-top-width: 1px; }\n  .next-table-fixed.next-table-group .next-table-body tr:last-child td {\n    border-bottom-width: 1px; }\n  .next-table-fixed.next-table-group .next-table-body tr td:last-child {\n    border-right-width: 1px; }\n\n.next-table-lock .next-table-body {\n  overflow-x: auto;\n  overflow-y: visible; }\n\n.next-table-group {\n  border-width: 0; }\n  .next-table-group .next-table-body {\n    margin-top: 8px; }\n    .next-table-group .next-table-body table {\n      margin-bottom: 8px; }\n      .next-table-group .next-table-body table tr:first-child td {\n        border-top-width: 1px; }\n  .next-table-group .next-table-group-header td {\n    background: #EBECF0;\n    color: #333333; }\n  .next-table-group .next-table-group-footer td {\n    background: #EBECF0;\n    color: #333333; }\n  .next-table-group .next-table-row.hovered,\n  .next-table-group .next-table-row.selected {\n    background: #FFFFFF;\n    color: #333333; }\n\n.next-table-lock {\n  position: relative; }\n  .next-table-lock table {\n    table-layout: fixed; }\n\n.next-table-header-inner {\n  overflow: hidden; }\n\n.next-table-lock-left,\n.next-table-lock-right {\n  position: absolute;\n  left: 0;\n  top: 0;\n  z-index: 1;\n  border: 0; }\n  .next-table-lock-left table,\n  .next-table-lock-right table {\n    width: auto; }\n  .next-table-lock-left .next-table-body,\n  .next-table-lock-right .next-table-body {\n    overflow: hidden; }\n\n.next-table-lock-right {\n  right: 0;\n  left: auto; }\n  .next-table-lock-right table tr td:first-child,\n  .next-table-lock-right table tr th:first-child {\n    border-left-width: 1px; }\n  .next-table-lock-right.shadow {\n    -webkit-box-shadow: -2px 0 3px rgba(0, 0, 0, 0.12);\n            box-shadow: -2px 0 3px rgba(0, 0, 0, 0.12); }\n\n.next-table-lock-left.shadow {\n  -webkit-box-shadow: 2px 0 3px rgba(0, 0, 0, 0.12);\n          box-shadow: 2px 0 3px rgba(0, 0, 0, 0.12); }\n\n.next-table-filter {\n  line-height: 1; }\n\n.next-table-sort {\n  position: relative;\n  width: 16px;\n  height: 15px;\n  display: inline-block;\n  vertical-align: middle;\n  line-height: 1; }\n  .next-table-sort .next-icon {\n    position: absolute;\n    left: 0;\n    color: #333333; }\n    .next-table-sort .next-icon:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-table-sort .current .next-icon {\n    color: #5584FF; }\n  .next-table-sort .next-icon-ascending {\n    left: 4px; }\n\n.next-table-filter {\n  margin-left: 5px;\n  cursor: pointer;\n  width: 20px;\n  display: inline-block; }\n  .next-table-filter .next-icon {\n    color: #333333; }\n    .next-table-filter .next-icon:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n\n.next-table-expanded-ctrl.disabled {\n  color: #999999; }\n\n.next-table-expanded-ctrl .next-icon:before {\n  width: 12px;\n  font-size: 12px;\n  line-height: inherit; }\n", ""]);

// exports


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = {
    momentLocale: 'zh-cn',
    Timeline: {
        expand: '展开',
        fold: '收起'
    },
    Card: {
        expand: '展开',
        fold: '收起'
    },
    Calendar: {
        today: '今天',
        now: '此刻',
        ok: '确定',
        clear: '清除',
        month: '月',
        year: '年',
        prevYear: '上一年',
        nextYear: '下一年',
        prevMonth: '上个月',
        nextMonth: '下个月',
        prevDecade: '上十年',
        nextDecade: '后十年'
    },
    DatePicker: {
        placeholder: '请选择日期',
        datetimePlaceholder: '请选择日期和时间',
        monthPlaceholder: '请选择月',
        yearPlaceholder: '请选择年',
        now: '此刻',
        selectTime: '选择时间',
        selectDate: '选择日期',
        ok: '确定',
        clear: '清除',
        startPlaceholder: '起始日期',
        endPlaceholder: '结束日期',
        hour: '时',
        minute: '分',
        second: '秒'
    },
    Dialog: {
        ok: '确认',
        cancel: '取消'
    },
    Pagination: {
        prev: '上一页',
        next: '下一页',
        goTo: '到第',
        page: '页',
        go: '确定',
        pageSize: '每页显示：'
    },
    Input: {
        clear: '清除'
    },
    Select: {
        selectPlaceholder: '请选择',
        autoCompletePlaceholder: '请输入',
        notFoundContent: '无选项'
    },
    Table: {
        empty: '没有数据',
        ok: '确认',
        reset: '重置',
        asc: '升序',
        desc: '降序',
        expanded: '已展开',
        folded: '已折叠',
        filter: '筛选',
        selectAll: '全选'
    },
    TimePicker: {
        placeholder: '请选择时间',
        clear: '清除',
        hour: '时',
        minute: '分',
        second: '秒'
    },
    Transfer: {
        items: '项',
        item: '项',
        moveAll: '移动全部',
        searchPlaceholder: '请输入'
    },
    Upload: {
        card: {
            cancel: '取消',
            addPhoto: '上传图片'
        },
        drag: {
            text: '点击或者拖动文件到虚线框内上传',
            hint: '支持 docx, xls, PDF, rar, zip, PNG, JPG 等类型的文件'
        }
    },
    Search: {
        buttonText: '搜索'
    }
};
module.exports = exports['default'];

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(12);

__webpack_require__(150);

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _checkbox = __webpack_require__(59);

var _checkbox2 = _interopRequireDefault(_checkbox);

var _checkboxGroup = __webpack_require__(112);

var _checkboxGroup2 = _interopRequireDefault(_checkboxGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_checkbox2.default.Group = _checkboxGroup2.default;

exports.default = _checkbox2.default;
module.exports = exports['default'];

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(11);

__webpack_require__(12);

__webpack_require__(145);

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = getContextProps;
function getContextProps(props, context, displayName) {
    var prefix = props.prefix,
        locale = props.locale,
        pure = props.pure,
        rtl = props.rtl;
    var nextPrefix = context.nextPrefix,
        nextLocale = context.nextLocale,
        nextPure = context.nextPure,
        nextWarning = context.nextWarning,
        nextRtl = context.nextRtl;


    var newPrefix = prefix || nextPrefix;

    var localeFromContext = void 0;
    if (nextLocale) {
        localeFromContext = nextLocale[displayName];
        if (localeFromContext) {
            localeFromContext.momentLocale = nextLocale.momentLocale;
        }
    }
    var newLocale = void 0;
    if (locale) {
        newLocale = _extends({}, localeFromContext || {}, locale);
    } else if (localeFromContext) {
        newLocale = localeFromContext;
    }

    var newPure = typeof pure === 'boolean' ? pure : nextPure;
    var newRtl = typeof rtl === 'boolean' ? rtl : nextRtl;

    return {
        prefix: newPrefix,
        locale: newLocale,
        pure: newPure,
        rtl: newRtl,
        warning: nextWarning
    };
}
module.exports = exports['default'];

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.matches = exports.hasDOM = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.hasClass = hasClass;
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.toggleClass = toggleClass;
exports.getStyle = getStyle;
exports.setStyle = setStyle;
exports.scrollbar = scrollbar;
exports.getOffset = getOffset;

var _string = __webpack_require__(41);

var _object = __webpack_require__(13);

/**
 * 是否能使用 DOM 方法
 * @type {Boolean}
 */
var hasDOM = exports.hasDOM = typeof window !== 'undefined' && !!window.document && !!document.createElement;

/**
 * 节点是否包含指定 className
 * @param  {Element}  node
 * @param  {String}  className
 * @return {Boolean}
 *
 * @example
 * dom.hasClass(document.body, 'foo');
 */
function hasClass(node, className) {
    /* istanbul ignore if */
    if (!hasDOM || !node) {
        return false;
    }

    if (node.classList) {
        return node.classList.contains(className);
    } else {
        return node.className.indexOf(className) > -1;
    }
}

/**
 * 添加 className
 * @param {Element} node
 * @param {String} className
 *
 * @example
 * dom.addClass(document.body, 'foo');
 */
function addClass(node, className, _force) {
    /* istanbul ignore if */
    if (!hasDOM || !node) {
        return;
    }

    if (node.classList) {
        node.classList.add(className);
    } else if (_force === true || !hasClass(node, className)) {
        node.className += ' ' + className;
    }
}

/**
 * 移除 className
 * @param  {Element} node
 * @param  {String} className
 *
 * @example
 * dom.removeClass(document.body, 'foo');
 */
function removeClass(node, className, _force) {
    /* istanbul ignore if */
    if (!hasDOM || !node) {
        return;
    }

    if (node.classList) {
        node.classList.remove(className);
    } else if (_force === true || hasClass(node, className)) {
        node.className = node.className.replace(className, '').replace(/\s+/g, ' ').trim();
    }
}

/**
 * 切换 className
 * @param  {Element} node
 * @param  {String} className
 * @return {Boolean}           执行后节点上是否还有此 className
 *
 * @example
 * dom.toggleClass(document.body, 'foo');
 */
function toggleClass(node, className) {
    /* istanbul ignore if */
    if (!hasDOM || !node) {
        return false;
    }

    if (node.classList) {
        return node.classList.toggle(className);
    } else {
        var flag = hasClass(node, className);
        flag ? removeClass(node, className, true) : addClass(node, className, true);

        return !flag;
    }
}

/**
 * 元素是否匹配 CSS 选择器
 * @param  {Element} node       DOM 节点
 * @param  {String}  selector   CSS 选择器
 * @return {Boolean}
 *
 * @example
 * dom.matches(mountNode, '.container'); // boolean
 */
var matches = exports.matches = function () {
    var matchesFn = null;
    /* istanbul ignore else */
    if (hasDOM) {
        var _body = document.body || document.head;
        matchesFn = _body.matches ? 'matches' : _body.webkitMatchesSelector ? 'webkitMatchesSelector' : _body.msMatchesSelector ? 'msMatchesSelector' : _body.mozMatchesSelector ? 'mozMatchesSelector' : null;
    }

    return function (node, selector) {
        if (!hasDOM || !node) {
            return false;
        }

        return matchesFn ? node[matchesFn](selector) : false;
    };
}();

/**
 * 获取元素计算后的样式
 * @private
 * @param  {Element} node
 * @return {Object}
 */
function _getComputedStyle(node) {
    return node && node.nodeType === 1 ? window.getComputedStyle(node, null) : {};
}

var PIXEL_PATTERN = /margin|padding|width|height|max|min|offset|size/i;
var removePixel = { left: 1, top: 1, right: 1, bottom: 1 };

/**
 * 校验并修正元素的样式属性值
 * @private
 * @param  {Element} node
 * @param  {String} type
 * @param  {Number} value
 */
function _getStyleValue(node, type, value) {
    type = type.toLowerCase();

    if (value === 'auto') {
        if (type === 'height') {
            return node.offsetHeight || 0;
        }
        if (type === 'width') {
            return node.offsetWidth || 0;
        }
    }

    if (!(type in removePixel)) {
        // 属性值是否需要去掉 px 单位，这里假定此类的属性值都是 px 为单位的
        removePixel[type] = PIXEL_PATTERN.test(type);
    }

    return removePixel[type] ? parseFloat(value) || 0 : value;
}

var floatMap = { cssFloat: 1, styleFloat: 1, float: 1 };

/**
 * 获取元素计算后的样式
 * @param  {Element} node DOM 节点
 * @param  {String} name 属性名
 * @return {Number|Object}
 */
function getStyle(node, name) {
    /* istanbul ignore if */
    if (!hasDOM || !node) {
        return null;
    }

    var style = _getComputedStyle(node);

    // 如果不指定属性名，则返回全部值
    if (arguments.length === 1) {
        return style;
    }

    name = floatMap[name] ? 'cssFloat' in node.style ? 'cssFloat' : 'styleFloat' : name;

    return _getStyleValue(node, name, style.getPropertyValue((0, _string.hyphenate)(name)) || node.style[(0, _string.camelcase)(name)]);
}

/**
 * 设置元素的样式
 * @param {Element} node  DOM 节点
 * @param {Object|String} name  属性名，或者是一个对象，包含多个属性
 * @param {Number|String} value 属性值
 *
 * @example
 * // 设置单个属性值
 * dom.setStyle(mountNode, 'width', 100);
 * // 设置多条属性值
 * dom.setStyle(mountNode, {
 *     width: 100,
 *     height: 200
 * });
 */
function setStyle(node, name, value) {
    /* istanbul ignore if */
    if (!hasDOM || !node) {
        return false;
    }

    // 批量设置多个值
    if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object' && arguments.length === 2) {
        (0, _object.each)(name, function (val, key) {
            return setStyle(node, key, val);
        });
    } else {
        name = floatMap[name] ? 'cssFloat' in node.style ? 'cssFloat' : 'styleFloat' : name;
        if (typeof value === 'number' && PIXEL_PATTERN.test(name)) {
            value = value + 'px';
        }
        node.style[(0, _string.camelcase)(name)] = value; // IE8 support
    }
}

/**
 * 获取默认的滚动条大小
 * @return {Object} width, height
 */
function scrollbar() {
    var scrollDiv = document.createElement('div');

    setStyle(scrollDiv, {
        position: 'absolute',
        width: '100px',
        height: '100px',
        overflow: 'scroll',
        top: '-9999px'
    });
    document.body.appendChild(scrollDiv);
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    var scrollbarHeight = scrollDiv.offsetHeight - scrollDiv.clientHeight;
    document.body.removeChild(scrollDiv);

    return {
        width: scrollbarWidth,
        height: scrollbarHeight
    };
}

/**
 * 获取元素距离视口顶部和左边的偏移距离
 * @return {Object} top, left
 */
function getOffset(node) {
    var rect = node.getBoundingClientRect();
    var win = node.ownerDocument.defaultView;
    return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
    };
}

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.camelcase = camelcase;
exports.hyphenate = hyphenate;
/**
 * 将字符串转化为驼峰式写法
 * @param  {String} str 例：-webkit-transition
 * @return {String}     例：WebkitTransition
 */
function camelcase(str) {
    if (!/-/.test(str)) {
        return str || '';
    }
    return str.toLowerCase().replace(/-([a-z])/g, function ($0, $1) {
        return $1.toUpperCase();
    });
}

/**
 * 将驼峰式字符串转化为连字符写法
 * @param  {String} str 例：WebkitTransition
 * @return {String}     例：-webkit-transition
 */
function hyphenate(str) {
    return str.replace(/([A-Z])/g, function ($0) {
        return '-' + $0.toLowerCase();
    });
}

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

exports.__esModule = true;
/**
 * IE浏览器的渲染引擎版本号
 * 注意：此属性与浏览器版本号不同，IE的渲染引擎版本号是可以通过HTML header或手动设置去更改的
 * @type {Number} 6 ~ 10
 */
var ieVersion = exports.ieVersion = typeof document !== 'undefined' ? document.documentMode : undefined;

/**
 * 判断是否是生产环境
 * @type {Boolean}
 */
var isProduction = exports.isProduction = function isProduction() {
    var PRODUCTION_ENV = 'production';
    var result = false;
    try {
        if (process.env.NODE_ENV === PRODUCTION_ENV) {
            result = true;
        }
    } catch (err) {
        //
    }

    if (!result) {
        try {
            if (window.process.env.NODE_ENV === PRODUCTION_ENV) {
                result = true;
            }
        } catch (err) {
            //
        }
    }

    return result;
};

exports.default = {
    ieVersion: ieVersion,
    isProduction: isProduction
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    ESC: 27,
    SPACE: 32,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,

    // version 0.x
    ESCAPE: 27,
    LEFT_ARROW: 37,
    UP_ARROW: 38,
    RIGHT_ARROW: 39,
    DOWN_ARROW: 40,

    // MacOS
    CONTROL: 17,
    OPTION: 18,
    CMD: 91,
    COMMAND: 91,
    DELETE: 8
};
module.exports = exports["default"];

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var styleEqual = __webpack_require__(96);
var hasOwnProperty = Object.prototype.hasOwnProperty;

function type(a) {
  return Array.isArray(a) ? 'array' : typeof a === 'undefined' ? 'undefined' : _typeof(a);
}

function elementEquals(a, b) {
  var typeOfA = type(a);
  var typeOfB = type(b);

  if (typeOfA !== typeOfB) return false;

  switch (typeOfA) {
    case 'array':
      if (a.length !== b.length) return false;
      for (var i = 0; i < a.length; i++) {
        if (!elementEquals(a[i], b[i])) return false;
      }
      return true;
    case 'object':
      if (!a || !b) return a === b;
      if (a.type !== b.type) return false;
      if (a.key !== b.key) return false;
      if (a.ref !== b.ref) return false;
      return shallowElementEquals(a.props, b.props);
      break;
    default:
      return a === b;
  }
}

function shallowElementEquals(a, b) {
  var aCount = 0;
  var bCount = 0;

  for (var key in a) {
    if (hasOwnProperty.call(a, key)) {
      if (key === 'style') {
        // NOTE(lmr): kind of risky, but i'm assuming that a `style` prop is a React Native style,
        // and using the `styleEqual` algorithm here.
        if (!styleEqual(a[key], b[key])) return false;
      } else if (key === 'children') {
        // will compare children later
      } else {
        if (a[key] !== b[key]) return false;
      }
      aCount++;
    }
  }

  for (var key in b) {
    if (hasOwnProperty.call(b, key)) {
      bCount++;
    }
  }

  if (aCount !== bCount) return false;

  // compare children last...
  return elementEquals(a.children, b.children);
}

module.exports = shallowElementEquals;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _util = __webpack_require__(2);

var _manager = __webpack_require__(97);

var _manager2 = _interopRequireDefault(_manager);

var _gateway = __webpack_require__(46);

var _gateway2 = _interopRequireDefault(_gateway);

var _position = __webpack_require__(47);

var _position2 = _interopRequireDefault(_position);

var _findNode = __webpack_require__(21);

var _findNode2 = _interopRequireDefault(_findNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var saveLastFocusNode = _util.focus.saveLastFocusNode,
    getFocusNodeList = _util.focus.getFocusNodeList,
    backLastFocusNode = _util.focus.backLastFocusNode;
var makeChain = _util.func.makeChain,
    noop = _util.func.noop,
    bindCtx = _util.func.bindCtx;


var isScrollDisplay = function isScrollDisplay(element) {
    try {
        var scrollbarStyle = window.getComputedStyle(element, '::-webkit-scrollbar');
        return !scrollbarStyle || scrollbarStyle.getPropertyValue('display') !== 'none';
    } catch (e) {
        // ignore error for firefox
    }

    return true;
};
var hasScroll = function hasScroll() {
    var doc = document.documentElement;
    return doc.scrollHeight > doc.clientHeight && _util.dom.scrollbar().width > 0 && isScrollDisplay(document.documentElement) && isScrollDisplay(document.body);
};
var prefixes = ['-webkit-', '-moz-', '-o-', 'ms-', ''];
var getStyleProperty = function getStyleProperty(node, name) {
    var style = window.getComputedStyle(node);
    var ret = '';
    for (var i = 0; i < prefixes.length; i++) {
        ret = style.getPropertyValue(prefixes[i] + name);
        if (ret) {
            break;
        }
    }
    return ret;
};

var modals = [];
var bodyOverflowY = void 0,
    bodyPaddingRight = void 0;

/**
 * Overlay
 * */
var Overlay = (_temp = _class = function (_Component) {
    _inherits(Overlay, _Component);

    function Overlay(props) {
        _classCallCheck(this, Overlay);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        _this.saveContentRef = function (ref) {
            _this.contentRef = ref;
        };

        _this.saveGatewayRef = function (ref) {
            _this.gatewayRef = ref;
        };

        _this.state = {
            visible: props.visible,
            status: 'none',
            animation: _this.getAnimation(props)
        };

        _this.lastAlign = props.align;

        bindCtx(_this, ['handlePosition', 'handleAnimateEnd', 'handleDocumentKeyDown', 'handleDocumentClick', 'handleMaskClick', 'beforeOpen', 'beforeClose']);

        _this.timeoutMap = {};
        return _this;
    }

    Overlay.prototype.componentWillMount = function componentWillMount() {
        if (this.props.visible) {
            this.beforeOpen();
            this.props.beforeOpen();

            if (this.state.animation && _util.support.animation) {
                this.enter();
            }
        }
    };

    Overlay.prototype.componentDidMount = function componentDidMount() {
        this.componentDidUpdate({ visible: false });
        this.addDocumentEvents();

        _manager2.default.addOverlay(this);

        if (this.state.visible) {
            this._isMounted = true;
        }
    };

    Overlay.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (!this._isMounted && nextProps.visible) {
            this._isMounted = true;
        }

        var willOpen = !this.props.visible && nextProps.visible;
        var willClose = this.props.visible && !nextProps.visible;
        if (willOpen) {
            this.beforeOpen();
            nextProps.beforeOpen();
        } else if (willClose) {
            this.beforeClose();
            nextProps.beforeClose();
        }

        if (nextProps.animation || nextProps.animation === false) {
            this.setState({
                animation: nextProps.animation
            });
        }

        if (nextProps.animation !== false && _util.support.animation) {
            if (willOpen) {
                this.enter();
            } else if (willClose) {
                this.leave();
            }
        } else {
            this.setState({
                visible: nextProps.visible
            });
        }
    };

    Overlay.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
        var _this2 = this;

        var open = !prevProps.visible && this.props.visible;
        var close = prevProps.visible && !this.props.visible;
        if (this.state.animation && _util.support.animation) {
            if (open || close) {
                this.addAnimationEvents();
            }
        } else {
            var wrapperNode = this.getWrapperNode();
            if (open) {
                setTimeout(function () {
                    _this2.props.onOpen();
                    _this2.props.afterOpen();
                    _util.dom.addClass(wrapperNode, 'opened');
                    _manager2.default.addOverlay(_this2);
                });
            } else if (close) {
                this.props.onClose();
                this.props.afterClose();
                _util.dom.removeClass(wrapperNode, 'opened');
                _manager2.default.removeOverlay(this);
            }
            this.setFocusNode();
        }
    };

    Overlay.prototype.componentWillUnmount = function componentWillUnmount() {
        this._isDestroyed = true;
        this._isMounted = false;
        _manager2.default.removeOverlay(this);
        this.removeDocumentEvents();
        if (this.focusTimeout) {
            clearTimeout(this.focusTimeout);
        }
        if (this._animation) {
            this._animation.off();
            this._animation = null;
        }
        this.beforeClose();
    };

    Overlay.prototype.getAnimation = function getAnimation(props) {
        if (props.animation === false) {
            return false;
        }

        if (props.animation) {
            return props.animation;
        }

        return this.getAnimationByAlign(props.align);
    };

    Overlay.prototype.getAnimationByAlign = function getAnimationByAlign(align) {
        switch (align[0]) {
            case 't':
                return {
                    in: 'expandInDown',
                    out: 'expandOutUp'
                };
            case 'b':
                return {
                    in: 'expandInUp',
                    out: 'expandOutDown'
                };
            default:
                return {
                    in: 'expandInDown',
                    out: 'expandOutUp'
                };
        }
    };

    Overlay.prototype.addAnimationEvents = function addAnimationEvents() {
        var _this3 = this;

        setTimeout(function () {
            var node = _this3.getContentNode();
            if (node) {
                var id = (0, _util.guid)();

                _this3._animation = _util.events.on(node, _util.support.animation.end, _this3.handleAnimateEnd.bind(_this3, id));

                var animationDelay = parseFloat(getStyleProperty(node, 'animation-delay')) || 0;
                var animationDuration = parseFloat(getStyleProperty(node, 'animation-duration')) || 0;
                var time = animationDelay + animationDuration;
                if (time) {
                    _this3.timeoutMap[id] = setTimeout(function () {
                        _this3.handleAnimateEnd(id);
                    }, time * 1000 + 200);
                }
            }
        });
    };

    Overlay.prototype.handlePosition = function handlePosition(config) {
        var align = config.align.join(' ');

        if (!('animation' in this.props) && this.props.needAdjust && this.lastAlign !== align) {
            this.setState({
                animation: this.getAnimationByAlign(align)
            });
        }

        this.lastAlign = align;
    };

    Overlay.prototype.handleAnimateEnd = function handleAnimateEnd(id) {
        if (this.timeoutMap[id]) {
            clearTimeout(this.timeoutMap[id]);
        }
        delete this.timeoutMap[id];

        if (this._animation) {
            this._animation.off();
            this._animation = null;
        }

        if (!this._isMounted) {
            return;
        }

        if (this.state.status === 'leaving') {
            this.setState({
                visible: false,
                status: 'none'
            });

            this.onLeaved();
        } else if (this.state.status === 'entering') {
            this.setState({
                status: 'none'
            });

            this.onEntered();
        }
    };

    Overlay.prototype.enter = function enter() {
        var _this4 = this;

        this.setState({
            visible: true,
            status: 'entering'
        }, function () {
            // NOTE: setState callback (second argument) now fires immediately after componentDidMount / componentDidUpdate instead of after all components have rendered.
            setTimeout(function () {
                if (!_this4._isDestroyed) {
                    _this4.onEntering();
                }
            });
        });
    };

    Overlay.prototype.leave = function leave() {
        this.setState({
            status: 'leaving'
        });

        this.onLeaving();
    };

    Overlay.prototype.onEntering = function onEntering() {
        var wrapperNode = this.getWrapperNode();
        _util.dom.addClass(wrapperNode, 'opened');
        this.props.onOpen();
    };

    Overlay.prototype.onLeaving = function onLeaving() {
        var wrapperNode = this.getWrapperNode();
        _util.dom.removeClass(wrapperNode, 'opened');
        this.props.onClose();
    };

    Overlay.prototype.onEntered = function onEntered() {
        _manager2.default.addOverlay(this);
        this.setFocusNode();
        this.props.afterOpen();
    };

    Overlay.prototype.onLeaved = function onLeaved() {
        _manager2.default.removeOverlay(this);
        this.setFocusNode();
        this.props.afterClose();
    };

    Overlay.prototype.beforeOpen = function beforeOpen() {
        if (this.props.disableScroll) {
            if (modals.length === 0) {
                var style = {
                    overflowY: 'hidden'
                };
                var body = document.body;
                bodyOverflowY = body.style.overflowY;
                if (hasScroll()) {
                    bodyPaddingRight = body.style.paddingRight;
                    style.paddingRight = _util.dom.getStyle(body, 'paddingRight') + _util.dom.scrollbar().width + 'px';
                }

                _util.dom.setStyle(body, style);
            }
            modals.push(this);
        }
    };

    Overlay.prototype.beforeClose = function beforeClose() {
        if (this.props.disableScroll) {
            var index = modals.indexOf(this);
            if (index > -1) {
                if (modals.length === 1) {
                    var style = {
                        overflowY: bodyOverflowY
                    };
                    if (hasScroll()) {
                        style.paddingRight = bodyPaddingRight;
                    }

                    _util.dom.setStyle(document.body, style);

                    bodyOverflowY = undefined;
                    bodyPaddingRight = undefined;
                }

                modals.splice(index, 1);
            }
        }
    };

    Overlay.prototype.setFocusNode = function setFocusNode() {
        var _this5 = this;

        if (!this.props.autoFocus) {
            return;
        }

        if (this.state.visible && !this._hasFocused) {
            saveLastFocusNode();
            // 这个时候很可能上一个弹层的关闭事件还未触发，导致焦点已经回到触发的元素
            // 这里延时处理一下，延时的时间为 document.click 捕获触发的延时时间
            this.focusTimeout = setTimeout(function () {
                var node = _this5.getContentNode();
                if (node) {
                    var focusNodeList = getFocusNodeList(node);
                    if (focusNodeList.length) {
                        focusNodeList[0].focus();
                    }
                    _this5._hasFocused = true;
                }
            }, 100);
        } else if (!this.state.visible && this._hasFocused) {
            backLastFocusNode();
            this._hasFocused = false;
        }
    };

    Overlay.prototype.getContent = function getContent() {
        return this.contentRef;
    };

    Overlay.prototype.getContentNode = function getContentNode() {
        return (0, _reactDom.findDOMNode)(this.contentRef);
    };

    Overlay.prototype.getWrapperNode = function getWrapperNode() {
        return this.gatewayRef ? this.gatewayRef.getChildNode() : null;
    };

    Overlay.prototype.addDocumentEvents = function addDocumentEvents() {
        if (this.props.canCloseByEsc) {
            this._keydownEvents = _util.events.on(document, 'keydown', this.handleDocumentKeyDown);
        }
        if (this.props.canCloseByOutSideClick) {
            this._clickEvents = _util.events.on(document, 'click', this.handleDocumentClick);
        }
    };

    Overlay.prototype.removeDocumentEvents = function removeDocumentEvents() {
        if (this._keydownEvents) {
            this._keydownEvents.off();
            this._keydownEvents = null;
        }
        if (this._clickEvents) {
            this._clickEvents.off();
            this._clickEvents = null;
        }
    };

    Overlay.prototype.handleDocumentKeyDown = function handleDocumentKeyDown(e) {
        if (this.state.visible && e.keyCode === _util.KEYCODE.ESC && _manager2.default.isCurrentOverlay(this)) {
            this.props.onRequestClose('keyboard', e);
        }
    };

    Overlay.prototype.handleDocumentClick = function handleDocumentClick(e) {
        var _this6 = this;

        if (this.state.visible) {
            var safeNode = this.props.safeNode;

            var safeNodes = Array.isArray(safeNode) ? [].concat(safeNode) : [safeNode];
            safeNodes.unshift(function () {
                return _this6.getWrapperNode();
            });

            for (var i = 0; i < safeNodes.length; i++) {
                var node = (0, _findNode2.default)(safeNodes[i], this.props);
                // HACK: 如果触发点击的节点是弹层内部的节点，并且在被点击后立即销毁，那么此时无法使用 node.contains(e.target)
                // 来判断此时点击的节点是否是弹层内部的节点，额外判断
                if (node && (node === e.target || node.contains(e.target) || e.target !== document && !document.documentElement.contains(e.target))) {
                    return;
                }
            }

            this.props.onRequestClose('docClick', e);
        }
    };

    Overlay.prototype.handleMaskClick = function handleMaskClick(e) {
        if (this.props.canCloseByMask) {
            this.props.onRequestClose('maskClick', e);
        }
    };

    // 兼容过去的用法: this.popupRef.getInstance().overlay.getInstance().getContentNode()
    Overlay.prototype.getInstance = function getInstance() {
        return this;
    };

    Overlay.prototype.render = function render() {
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            style = _props.style,
            propChildren = _props.children,
            target = _props.target,
            align = _props.align,
            offset = _props.offset,
            container = _props.container,
            hasMask = _props.hasMask,
            needAdjust = _props.needAdjust,
            beforePosition = _props.beforePosition,
            onPosition = _props.onPosition,
            wrapperStyle = _props.wrapperStyle,
            rtl = _props.rtl,
            propShouldUpdatePosition = _props.shouldUpdatePosition,
            cache = _props.cache,
            wrapperClassName = _props.wrapperClassName,
            onMaskMouseEnter = _props.onMaskMouseEnter,
            onMaskMouseLeave = _props.onMaskMouseLeave;
        var _state = this.state,
            stateVisible = _state.visible,
            status = _state.status,
            animation = _state.animation;


        var children = stateVisible || cache && this._isMounted ? propChildren : null;
        if (children) {
            var _classnames;

            var child = _react.Children.only(children);
            var childClazz = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'overlay-inner'] = true, _classnames[animation.in] = status === 'entering', _classnames[animation.out] = status === 'leaving', _classnames[child.props.className] = !!child.props.className, _classnames[className] = !!className, _classnames));
            if (typeof child.ref === 'string') {
                throw new Error('Can not set ref by string in Overlay, use function instead.');
            }

            children = _react2.default.cloneElement(child, {
                className: childClazz,
                style: _extends({}, child.props.style, style),
                ref: makeChain(this.saveContentRef, child.ref),
                'aria-hidden': !stateVisible && cache && this._isMounted
            });

            if (align) {
                var shouldUpdatePosition = status === 'leaving' ? false : propShouldUpdatePosition;
                children = _react2.default.createElement(_position2.default, {
                    children: children, target: target, align: align, offset: offset, needAdjust: needAdjust,
                    beforePosition: beforePosition,
                    onPosition: makeChain(this.handlePosition, onPosition),
                    shouldUpdatePosition: shouldUpdatePosition, rtl: rtl
                });
            }

            var wrapperClazz = (0, _classnames3.default)([prefix + 'overlay-wrapper', wrapperClassName]);
            var newWrapperStyle = _extends({}, {
                display: stateVisible ? '' : 'none'
            }, wrapperStyle);

            children = _react2.default.createElement(
                'div',
                { className: wrapperClazz, style: newWrapperStyle, dir: rtl ? 'rtl' : undefined },
                hasMask ? _react2.default.createElement('div', { className: prefix + 'overlay-backdrop',
                    onClick: this.handleMaskClick,
                    onMouseEnter: onMaskMouseEnter,
                    onMouseLeave: onMaskMouseLeave,
                    dir: rtl ? 'rtl' : undefined }) : null,
                children
            );
        }

        return _react2.default.createElement(_gateway2.default, _extends({ container: container, target: target, children: children }, { ref: this.saveGatewayRef }));
    };

    return Overlay;
}(_react.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    rtl: _propTypes2.default.bool,
    className: _propTypes2.default.string,
    style: _propTypes2.default.object,
    /**
     * 弹层内容
     */
    children: _propTypes2.default.any,
    /**
     * 是否显示弹层
     */
    visible: _propTypes2.default.bool,
    /**
     * 弹层请求关闭时触发事件的回调函数
     * @param {String} type 弹层关闭的来源
     * @param {Object} e DOM 事件
     */
    onRequestClose: _propTypes2.default.func,
    /**
     * 弹层定位的参照元素
     */
    target: _propTypes2.default.any,
    /**
     * 弹层相对于参照元素的定位, 详见开发指南的[定位部分](#定位)
     */
    align: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.bool]),
    /**
     * 弹层相对于参照元素定位的微调
     */
    offset: _propTypes2.default.array,
    /**
     * 渲染组件的容器，如果是函数需要返回 ref，如果是字符串则是该 DOM 的 id，也可以直接传入 DOM 节点
     */
    container: _propTypes2.default.any,
    /**
     * 是否显示遮罩
     */
    hasMask: _propTypes2.default.bool,
    /**
     * 是否支持 esc 按键关闭弹层
     */
    canCloseByEsc: _propTypes2.default.bool,
    /**
     * 点击弹层外的区域是否关闭弹层，不显示遮罩时生效
     */
    canCloseByOutSideClick: _propTypes2.default.bool,
    /**
     * 点击遮罩区域是否关闭弹层，显示遮罩时生效
     */
    canCloseByMask: _propTypes2.default.bool,
    /**
     * 弹层打开前触发事件的回调函数
     */
    beforeOpen: _propTypes2.default.func,
    /**
     * 弹层打开时触发事件的回调函数
     */
    onOpen: _propTypes2.default.func,
    /**
     * 弹层打开后触发事件的回调函数, 如果有动画，则在动画结束后触发
     */
    afterOpen: _propTypes2.default.func,
    /**
     * 弹层关闭前触发事件的回调函数
     */
    beforeClose: _propTypes2.default.func,
    /**
     * 弹层关闭时触发事件的回调函数
     */
    onClose: _propTypes2.default.func,
    /**
     * 弹层关闭后触发事件的回调函数, 如果有动画，则在动画结束后触发
     */
    afterClose: _propTypes2.default.func,
    /**
     * 弹层定位完成前触发的事件
     */
    beforePosition: _propTypes2.default.func,
    /**
     * 弹层定位完成时触发的事件
     * @param {Object} config 定位的参数
     * @param {Array} config.align 对齐方式，如 ['cc', 'cc']（如果开启 needAdjust，可能和预先设置的 align 不同）
     * @param {Number} config.top 距离视口顶部距离
     * @param {Number} config.left 距离视口左侧距离
     * @param {Object} node 定位参照的容器节点
     */
    onPosition: _propTypes2.default.func,
    /**
     * 是否在每次弹层重新渲染后强制更新定位信息，一般用于弹层内容区域大小发生变化时，仍需保持原来的定位方式
     */
    shouldUpdatePosition: _propTypes2.default.bool,
    /**
     * 弹层打开时是否让其中的元素自动获取焦点
     */
    autoFocus: _propTypes2.default.bool,
    /**
     * 当弹层由于页面滚动等情况不在可视区域时，是否自动调整定位以出现在可视区域
     */
    needAdjust: _propTypes2.default.bool,
    /**
     * 是否禁用页面滚动
     */
    disableScroll: _propTypes2.default.bool,
    /**
     * 隐藏时是否保留子节点
     */
    cache: _propTypes2.default.bool,
    /**
     * 安全节点，当点击 document 的时候，如果包含该节点则不会关闭弹层，如果是函数需要返回 ref，如果是字符串则是该 DOM 的 id，也可以直接传入 DOM 节点，或者以上值组成的数组
     */
    safeNode: _propTypes2.default.any,
    /**
     * 弹层的根节点的样式类
     */
    wrapperClassName: _propTypes2.default.string,
    /**
     * 弹层的根节点的内联样式
     */
    wrapperStyle: _propTypes2.default.object,
    /**
     * 配置动画的播放方式，支持 { in: 'enter-class', out: 'leave-class' } 的对象参数，如果设置为 false，则不播放动画
     * @default { in: 'expandInDown', out: 'expandOutUp' }
     */
    animation: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.bool]),
    onMaskMouseEnter: _propTypes2.default.func,
    onMaskMouseLeave: _propTypes2.default.func
}, _class.defaultProps = {
    prefix: 'next-',
    pure: false,
    visible: false,
    onRequestClose: noop,
    target: _position2.default.VIEWPORT,
    align: 'tl bl',
    offset: [0, 0],
    hasMask: false,
    canCloseByEsc: true,
    canCloseByOutSideClick: true,
    canCloseByMask: true,
    beforeOpen: noop,
    onOpen: noop,
    afterOpen: noop,
    beforeClose: noop,
    onClose: noop,
    afterClose: noop,
    beforePosition: noop,
    onPosition: noop,
    onMaskMouseEnter: noop,
    onMaskMouseLeave: noop,
    shouldUpdatePosition: false,
    autoFocus: false,
    needAdjust: true,
    disableScroll: false,
    cache: false
}, _temp);
Overlay.displayName = 'Overlay';
exports.default = Overlay;
module.exports = exports['default'];

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

var _findNode = __webpack_require__(21);

var _findNode2 = _interopRequireDefault(_findNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var makeChain = _util.func.makeChain;
var Gateway = (_temp2 = _class = function (_Component) {
    _inherits(Gateway, _Component);

    function Gateway() {
        var _temp, _this, _ret;

        _classCallCheck(this, Gateway);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.saveChildRef = function (ref) {
            _this.child = ref;
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Gateway.prototype.componentDidMount = function componentDidMount() {
        this.containerNode = this.getContainerNode(this.props);
        this.forceUpdate();
    };

    Gateway.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        this.containerNode = this.getContainerNode(nextProps);
    };

    Gateway.prototype.getContainerNode = function getContainerNode(props) {
        var targetNode = (0, _findNode2.default)(props.target);
        return (0, _findNode2.default)(props.container, targetNode);
    };

    Gateway.prototype.getChildNode = function getChildNode() {
        return (0, _reactDom.findDOMNode)(this.child);
    };

    Gateway.prototype.render = function render() {
        if (!this.containerNode) {
            return null;
        }

        var children = this.props.children;

        var child = children ? _react.Children.only(children) : null;
        if (!child) {
            return null;
        }

        if (typeof child.ref === 'string') {
            throw new Error('Can not set ref by string in Gateway, use function instead.');
        }
        child = _react2.default.cloneElement(child, {
            ref: makeChain(this.saveChildRef, child.ref)
        });

        return (0, _reactDom.createPortal)(child, this.containerNode);
    };

    return Gateway;
}(_react.Component), _class.propTypes = {
    children: _propTypes2.default.node,
    container: _propTypes2.default.any,
    target: _propTypes2.default.any
}, _class.defaultProps = {
    container: function container() {
        return document.body;
    }
}, _temp2);
Gateway.displayName = 'Gateway';
exports.default = Gateway;
module.exports = exports['default'];

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

var _position = __webpack_require__(98);

var _position2 = _interopRequireDefault(_position);

var _findNode = __webpack_require__(21);

var _findNode2 = _interopRequireDefault(_findNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = _util.func.noop,
    bindCtx = _util.func.bindCtx;
var getStyle = _util.dom.getStyle;

var place = _position2.default.place;

var Position = (_temp = _class = function (_Component) {
    _inherits(Position, _Component);

    function Position(props) {
        _classCallCheck(this, Position);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        bindCtx(_this, ['handleResize']);
        return _this;
    }

    Position.prototype.componentDidMount = function componentDidMount() {
        this.setPosition();

        if (this.props.needListenResize) {
            _util.events.on(window, 'resize', this.handleResize);
        }
    };

    Position.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if ('align' in nextProps && nextProps.align !== this.props.align || nextProps.shouldUpdatePosition) {
            this.shouldUpdatePosition = true;
        }
    };

    Position.prototype.componentDidUpdate = function componentDidUpdate() {
        if (this.shouldUpdatePosition) {
            this.setPosition();
            this.shouldUpdatePosition = false;
        }
    };

    Position.prototype.componentWillUnmount = function componentWillUnmount() {
        if (this.props.needListenResize) {
            _util.events.off(window, 'resize', this.handleResize);
        }

        clearTimeout(this.resizeTimeout);
    };

    Position.prototype.setPosition = function setPosition() {
        var _props = this.props,
            align = _props.align,
            offset = _props.offset,
            beforePosition = _props.beforePosition,
            onPosition = _props.onPosition,
            needAdjust = _props.needAdjust,
            rtl = _props.rtl;


        beforePosition();

        var contentNode = this.getContentNode();
        var targetNode = this.getTargetNode();
        if (contentNode && targetNode) {
            var resultAlign = place({
                pinElement: contentNode,
                baseElement: targetNode,
                align: align,
                offset: offset,
                needAdjust: needAdjust,
                isRtl: rtl
            });
            var top = getStyle(contentNode, 'top');
            var left = getStyle(contentNode, 'left');

            onPosition({
                align: resultAlign.split(' '),
                top: top,
                left: left
            }, contentNode);
        }
    };

    Position.prototype.getContentNode = function getContentNode() {
        return (0, _reactDom.findDOMNode)(this);
    };

    Position.prototype.getTargetNode = function getTargetNode() {
        var target = this.props.target;


        return target === _position2.default.VIEWPORT ? _position2.default.VIEWPORT : (0, _findNode2.default)(target, this.props);
    };

    Position.prototype.handleResize = function handleResize() {
        var _this2 = this;

        clearTimeout(this.resizeTimeout);

        this.resizeTimeout = setTimeout(function () {
            _this2.setPosition();
        }, 200);
    };

    Position.prototype.render = function render() {
        return _react.Children.only(this.props.children);
    };

    return Position;
}(_react.Component), _class.VIEWPORT = _position2.default.VIEWPORT, _class.propTypes = {
    children: _propTypes2.default.node,
    target: _propTypes2.default.any,
    align: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.bool]),
    offset: _propTypes2.default.array,
    beforePosition: _propTypes2.default.func,
    onPosition: _propTypes2.default.func,
    needAdjust: _propTypes2.default.bool,
    needListenResize: _propTypes2.default.bool,
    shouldUpdatePosition: _propTypes2.default.bool,
    rtl: _propTypes2.default.bool
}, _class.defaultProps = {
    align: 'tl bl',
    offset: [0, 0],
    beforePosition: noop,
    onPosition: noop,
    needAdjust: true,
    needListenResize: true,
    shouldUpdatePosition: false,
    rtl: false
}, _temp);
Position.displayName = 'Position';
exports.default = Position;
module.exports = exports['default'];

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _filter = __webpack_require__(49);

var _filter2 = _interopRequireDefault(_filter);

var _sort = __webpack_require__(63);

var _sort2 = _interopRequireDefault(_sort);

var _cell = __webpack_require__(18);

var _cell2 = _interopRequireDefault(_cell);

var _resize = __webpack_require__(120);

var _resize2 = _interopRequireDefault(_resize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};
var Header = (_temp2 = _class = function (_React$Component) {
    _inherits(Header, _React$Component);

    function Header() {
        var _temp, _this, _ret;

        _classCallCheck(this, Header);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.getCellRef = function (i, j, cell) {
            _this.props.headerCellRef(i, j, cell);
        }, _this.onSort = function (dataIndex, order, sort) {
            _this.props.onSort(dataIndex, order, sort);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Header.prototype.render = function render() {
        var _this2 = this;

        /*eslint-disable no-unused-vars */
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            children = _props.children,
            Tag = _props.component,
            colGroup = _props.colGroup,
            columns = _props.columns,
            locale = _props.locale,
            filterParams = _props.filterParams,
            onFilter = _props.onFilter,
            components = _props.components,
            affixRef = _props.affixRef,
            headerCellRef = _props.headerCellRef,
            onSort = _props.onSort,
            sort = _props.sort,
            onResizeChange = _props.onResizeChange,
            pure = _props.pure,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'children', 'component', 'colGroup', 'columns', 'locale', 'filterParams', 'onFilter', 'components', 'affixRef', 'headerCellRef', 'onSort', 'sort', 'onResizeChange', 'pure']);

        var _components$Cell = components.Cell,
            Cell = _components$Cell === undefined ? _cell2.default : _components$Cell,
            _components$Filter = components.Filter,
            Filter = _components$Filter === undefined ? _filter2.default : _components$Filter,
            _components$Sort = components.Sort,
            Sort = _components$Sort === undefined ? _sort2.default : _components$Sort,
            _components$Resize = components.Resize,
            Resize = _components$Resize === undefined ? _resize2.default : _components$Resize;

        var rowSpan = columns.length;

        var header = columns.map(function (cols, index) {
            var col = cols.map(function (col, j) {
                var _classnames;

                /* eslint-disable no-unused-vars, prefer-const */
                var title = col.title,
                    colSpan = col.colSpan,
                    sortable = col.sortable,
                    resizable = col.resizable,
                    dataIndex = col.dataIndex,
                    filters = col.filters,
                    filterMode = col.filterMode,
                    width = col.width,
                    align = col.align,
                    className = col.className,
                    __normalized = col.__normalized,
                    lock = col.lock,
                    others = _objectWithoutProperties(col, ['title', 'colSpan', 'sortable', 'resizable', 'dataIndex', 'filters', 'filterMode', 'width', 'align', 'className', '__normalized', 'lock']);

                className = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-header-node'] = true, _classnames[prefix + 'table-header-resizable'] = resizable, _classnames[className] = className, _classnames));
                var attrs = {},
                    sortElement = void 0,
                    filterElement = void 0,
                    resizeElement = void 0;
                if (col.children && col.children.length) {
                    attrs.colSpan = colSpan;
                } else {
                    if (sortable) {
                        sortElement = _react2.default.createElement(Sort, { prefix: prefix,
                            dataIndex: dataIndex,
                            onSort: _this2.onSort,
                            sort: sort,
                            locale: locale });
                    }
                    if (resizable) {
                        resizeElement = _react2.default.createElement(Resize, { prefix: prefix, dataIndex: dataIndex, onChange: onResizeChange });
                    }

                    if (filters) {
                        filterElement = filters.length ? _react2.default.createElement(Filter, { dataIndex: dataIndex,
                            filters: filters,
                            prefix: prefix,
                            locale: locale,
                            filterParams: filterParams,
                            filterMode: filterMode,
                            onFilter: onFilter }) : null;
                    }
                    attrs.rowSpan = rowSpan - index;
                }
                return _react2.default.createElement(
                    Cell,
                    _extends({}, others, attrs, {
                        key: j,
                        prefix: prefix,
                        pure: pure,
                        cell: title,
                        component: 'th',
                        align: align,
                        className: className,
                        ref: _this2.getCellRef.bind(_this2, index, j),
                        type: 'header' }),
                    sortElement,
                    filterElement,
                    resizeElement
                );
            });
            return _react2.default.createElement(
                'tr',
                { key: index },
                col
            );
        });

        return _react2.default.createElement(
            Tag,
            _extends({ className: className }, others),
            header,
            children
        );
    };

    return Header;
}(_react2.default.Component), _class.propTypes = {
    children: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    className: _propTypes2.default.string,
    component: _propTypes2.default.string,
    columns: _propTypes2.default.array,
    colGroup: _propTypes2.default.object,
    headerCellRef: _propTypes2.default.func,
    locale: _propTypes2.default.object,
    filterParams: _propTypes2.default.object,
    onFilter: _propTypes2.default.func,
    components: _propTypes2.default.object,
    sort: _propTypes2.default.object,
    onSort: _propTypes2.default.func,
    onResizeChange: _propTypes2.default.func
}, _class.defaultProps = {
    component: 'thead',
    columns: [],
    headerCellRef: noop,
    onFilter: noop,
    components: {},
    onSort: noop,
    onResizeChange: noop
}, _temp2);
Header.displayName = 'Header';
exports.default = Header;
module.exports = exports['default'];

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp, _initialiseProps;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _dropdown = __webpack_require__(100);

var _dropdown2 = _interopRequireDefault(_dropdown);

var _menu = __webpack_require__(76);

var _menu2 = _interopRequireDefault(_menu);

var _button = __webpack_require__(71);

var _button2 = _interopRequireDefault(_button);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

// 共享状态的组件需要变成非受控组件
var Filter = (_temp = _class = function (_React$Component) {
    _inherits(Filter, _React$Component);

    function Filter(props) {
        _classCallCheck(this, Filter);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

        _initialiseProps.call(_this);

        var filterParams = props.filterParams || {};
        var filterConfig = filterParams[props.dataIndex] || {};
        _this.state = {
            visible: filterConfig.visible || false,
            selectedKeys: filterConfig.selectedKeys || []
        };
        _this._selectedKeys = [].concat(_this.state.selectedKeys);
        return _this;
    }

    Filter.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (nextProps.hasOwnProperty('filterParams') && typeof nextProps.filterParams !== 'undefined') {
            var dataIndex = nextProps.dataIndex || this.props.dataIndex;
            var filterParams = nextProps.filterParams || {};
            var filterConfig = filterParams[dataIndex] || {};
            var selectedKeys = filterConfig.selectedKeys || [];
            this.setState({
                selectedKeys: selectedKeys
            });
            this._selectedKeys = [].concat(selectedKeys);
        }
    };

    Filter.prototype.render = function render() {
        var _props = this.props,
            filters = _props.filters,
            prefix = _props.prefix,
            locale = _props.locale,
            filterMode = _props.filterMode;
        var _state = this.state,
            visible = _state.visible,
            selectedKeys = _state.selectedKeys;


        function renderMenuItem(item) {
            return _react2.default.createElement(
                _menu2.default.Item,
                { key: item.value },
                item.label
            );
        }

        function renderSubMenu(parent, children) {
            return _react2.default.createElement(
                _menu2.default.SubMenu,
                { label: parent.label, key: parent.value, selectable: false },
                renderMenuContent(children)
            );
        }

        function renderMenuContent(list) {
            return list.map(function (item) {
                if (item.children) {
                    return renderSubMenu(item, item.children);
                } else {
                    return renderMenuItem(item);
                }
            });
        }

        var content = renderMenuContent(filters),
            footer = _react2.default.createElement(
            'div',
            { className: prefix + 'table-filter-footer' },
            _react2.default.createElement(
                _button2.default,
                { type: 'primary', onClick: this.onFilterConfirm },
                locale.ok
            ),
            _react2.default.createElement(
                _button2.default,
                { onClick: this.onFilterClear },
                locale.reset
            )
        );

        return _react2.default.createElement(
            _dropdown2.default,
            { trigger: _react2.default.createElement(
                    'span',
                    { role: 'button',
                        'aria-label': locale.filter,
                        onKeyDown: this.filterKeydown,
                        tabIndex: '0',
                        className: prefix + 'table-filter' },
                    _react2.default.createElement(_icon2.default, { type: 'filter', size: 'small' })
                ),
                triggerType: 'click',
                visible: visible,
                autoFocus: true,
                container: function container(node) {
                    return node.parentNode;
                },
                onVisibleChange: this.onFilterVisible },
            _react2.default.createElement(
                _menu2.default,
                { footer: footer,
                    selectedKeys: selectedKeys,
                    selectMode: filterMode,
                    onSelect: this.onFilterSelect },
                content
            )
        );
    };

    return Filter;
}(_react2.default.Component), _class.propTypes = {
    dataIndex: _propTypes2.default.string,
    filters: _propTypes2.default.array,
    filterMode: _propTypes2.default.string,
    filterParams: _propTypes2.default.object,
    locale: _propTypes2.default.object,
    onFilter: _propTypes2.default.func,
    prefix: _propTypes2.default.string
}, _class.defaultProps = {
    onFilter: function onFilter() {}
}, _initialiseProps = function _initialiseProps() {
    var _this2 = this;

    this.filterKeydown = function (e) {
        e.preventDefault();
        e.stopPropagation();

        if (e.keyCode === _util.KEYCODE.ENTER) {
            _this2.setState({
                visible: !_this2.state.visible
            });
        }
    };

    this.onFilterVisible = function (visible) {
        _this2.setState({
            visible: visible
        });

        if (!visible) {
            var selectedKeys = [].concat(_this2._selectedKeys);

            _this2.setState({
                selectedKeys: selectedKeys
            });
        }
    };

    this.onFilterSelect = function (selectedKeys) {
        _this2.setState({
            visible: true,
            selectedKeys: selectedKeys
        });
    };

    this.onFilterConfirm = function () {
        var selectedKeys = _this2.state.selectedKeys;
        var filterParams = {},
            dataIndex = _this2.props.dataIndex;

        filterParams[dataIndex] = {
            visible: false,
            selectedKeys: selectedKeys
        };
        _this2._selectedKeys = [].concat(selectedKeys);
        _this2.setState({
            visible: false
        });
        // 兼容之前的格式
        _this2.props.onFilter(filterParams);
    };

    this.onFilterClear = function () {
        var filterParams = {},
            dataIndex = _this2.props.dataIndex;

        filterParams[dataIndex] = {
            visible: false,
            selectedKeys: []
        };
        _this2._selectedKeys = [];
        _this2.setState({
            selectedKeys: [],
            visible: false
        });
        // 兼容之前的格式
        _this2.props.onFilter(filterParams);
    };
}, _temp);
Filter.displayName = 'Filter';
exports.default = Filter;
module.exports = exports['default'];

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var bindCtx = _util.func.bindCtx;
var pickOthers = _util.obj.pickOthers;

var noop = function noop() {};

/**
 * Menu
 */
var Menu = (_temp = _class = function (_Component) {
    _inherits(Menu, _Component);

    function Menu(props) {
        _classCallCheck(this, Menu);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        var _this$props = _this.props,
            children = _this$props.children,
            selectedKeys = _this$props.selectedKeys,
            defaultSelectedKeys = _this$props.defaultSelectedKeys,
            focusedKey = _this$props.focusedKey,
            focusable = _this$props.focusable,
            autoFocus = _this$props.autoFocus;


        _this.newChildren = _this.getNewChildren(children);

        if (focusable) {
            _this.tabbableKey = _this.getFirstAvaliablelChildKey('0');
        }
        _this.state = {
            openKeys: _this.getInitOpenKeys(props),
            selectedKeys: _this.normalizeToArray(selectedKeys || defaultSelectedKeys),
            focusedKey: 'focusedKey' in _this.props ? focusedKey : focusable && autoFocus ? _this.tabbableKey : null
        };

        bindCtx(_this, ['handleOpen', 'handleSelect', 'handleItemClick', 'handleItemKeyDown', 'onBlur']);

        _this.popupNodes = [];
        return _this;
    }

    Menu.prototype.componentDidMount = function componentDidMount() {
        this.menuNode = (0, _reactDom.findDOMNode)(this);
    };

    Menu.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var state = {};

        if ('openKeys' in nextProps) {
            state.openKeys = this.normalizeToArray(nextProps.openKeys);
        }
        if ('selectedKeys' in nextProps) {
            state.selectedKeys = this.normalizeToArray(nextProps.selectedKeys);
        }
        if ('focusedKey' in nextProps) {
            state.focusedKey = nextProps.focusedKey;
        }

        if (Object.keys(state).length) {
            this.setState(state);
        }
    };

    Menu.prototype.componentWillUpdate = function componentWillUpdate(nextProps) {
        this.newChildren = this.getNewChildren(nextProps.children);
        if (this.props.focusable) {
            if (this.tabbableKey in this.k2n) {
                if (this.state.focusedKey) {
                    this.tabbableKey = this.state.focusedKey;
                }
            } else {
                this.tabbableKey = this.getFirstAvaliablelChildKey('0');
            }
        }
    };

    Menu.prototype.onBlur = function onBlur(e) {
        this.setState({
            focusedKey: ''
        });

        this.props.onBlur && this.props.onBlur(e);
    };

    Menu.prototype.getInitOpenKeys = function getInitOpenKeys(props) {
        var _this2 = this;

        var initOpenKeys = void 0;

        var openKeys = props.openKeys,
            defaultOpenKeys = props.defaultOpenKeys,
            defaultOpenAll = props.defaultOpenAll,
            mode = props.mode,
            openMode = props.openMode;

        if (openKeys) {
            initOpenKeys = openKeys;
        } else if (defaultOpenAll && mode === 'inline' && openMode === 'multiple') {
            initOpenKeys = Object.keys(this.k2n).filter(function (key) {
                return _this2.k2n[key].type === 'submenu';
            });
        } else {
            initOpenKeys = defaultOpenKeys;
        }

        return this.normalizeToArray(initOpenKeys);
    };

    Menu.prototype.getNewChildren = function getNewChildren(children) {
        var _this3 = this;

        this.k2n = {};
        this.p2n = {};
        var loop = function loop(children, posPrefix) {
            var indexWrapper = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { index: 0 };

            return _react.Children.map(children, function (child) {
                if (child && typeof child.type === 'function' && 'menuChildType' in child.type) {
                    var newChild = void 0;

                    var pos = void 0;
                    var props = { root: _this3 };

                    if (['item', 'submenu', 'group'].indexOf(child.type.menuChildType) > -1) {
                        pos = posPrefix + '-' + indexWrapper.index++;
                        var key = typeof child.key === 'string' ? child.key : pos;
                        var level = pos.split('-').length - 1;
                        _this3.k2n[key] = _this3.p2n[pos] = {
                            key: key,
                            pos: pos,
                            type: child.type.menuChildType,
                            disabled: child.props.disabled,
                            label: child.props.label || child.props.children
                        };

                        props._key = key;
                        props.level = level;
                        props.groupIndent = child.type.menuChildType === 'group' ? 1 : 0;
                    }

                    switch (child.type.menuChildType) {
                        case 'submenu':
                            newChild = (0, _react.cloneElement)(child, props, loop(child.props.children, pos));
                            break;
                        case 'group':
                            newChild = (0, _react.cloneElement)(child, props, loop(child.props.children, posPrefix, indexWrapper));
                            break;
                        case 'item':
                        case 'divider':
                            newChild = (0, _react.cloneElement)(child, props);
                            break;
                        default:
                            newChild = child;
                            break;
                    }

                    return newChild;
                }

                return child;
            });
        };

        return loop(children, '0');
    };

    Menu.prototype.normalizeToArray = function normalizeToArray(items) {
        if (items) {
            if (Array.isArray(items)) {
                return items;
            }
            return [items];
        }

        return [];
    };

    Menu.prototype.isSibling = function isSibling(currentPos, targetPos) {
        var currentNums = currentPos.split('-').slice(0, -1);
        var targetNums = targetPos.split('-').slice(0, -1);

        return currentNums.length === targetNums.length && currentNums.every(function (num, index) {
            return num === targetNums[index];
        });
    };

    Menu.prototype.isAncestor = function isAncestor(currentPos, targetPos) {
        var currentNums = currentPos.split('-');
        var targetNums = targetPos.split('-');

        return currentNums.length > targetNums.length && targetNums.every(function (num, index) {
            return num === currentNums[index];
        });
    };

    Menu.prototype.handleOpen = function handleOpen(key, open, triggerType, e) {
        var _this4 = this;

        var newOpenKeys = void 0;

        var _props = this.props,
            mode = _props.mode,
            openMode = _props.openMode;
        var openKeys = this.state.openKeys;

        var index = openKeys.indexOf(key);
        if (open && index === -1) {
            if (mode === 'inline') {
                if (openMode === 'single') {
                    newOpenKeys = openKeys.filter(function (k) {
                        return !_this4.isSibling(_this4.k2n[key].pos, _this4.k2n[k].pos);
                    });
                    newOpenKeys.push(key);
                } else {
                    newOpenKeys = openKeys.concat(key);
                }
            } else {
                newOpenKeys = openKeys.filter(function (k) {
                    return _this4.isAncestor(_this4.k2n[key].pos, _this4.k2n[k].pos);
                });
                newOpenKeys.push(key);
            }
        } else if (!open && index > -1) {
            if (mode === 'inline') {
                newOpenKeys = [].concat(openKeys.slice(0, index), openKeys.slice(index + 1));
            } else if (triggerType === 'docClick') {
                if (!this.popupNodes.concat(this.menuNode).some(function (node) {
                    return node.contains(e.target);
                })) {
                    newOpenKeys = [];
                }
            } else {
                newOpenKeys = openKeys.filter(function (k) {
                    return k !== key && !_this4.isAncestor(_this4.k2n[k].pos, _this4.k2n[key].pos);
                });
            }
        }

        if (newOpenKeys) {
            if (!('openKeys' in this.props)) {
                this.setState({
                    openKeys: newOpenKeys
                });
            }

            this.props.onOpen(newOpenKeys, {
                key: key,
                open: open
            });
        }
    };

    Menu.prototype.getPath = function getPath(key) {
        var keyPath = [];
        var labelPath = [];

        var pos = this.k2n[key].pos;
        var nums = pos.split('-');
        for (var i = 1; i < nums.length - 1; i++) {
            var parentNums = nums.slice(0, i + 1);
            var parentPos = parentNums.join('-');
            var parent = this.p2n[parentPos];
            keyPath.push(parent.key);
            labelPath.push(parent.label);
        }

        return {
            keyPath: keyPath,
            labelPath: labelPath
        };
    };

    Menu.prototype.handleSelect = function handleSelect(key, select, menuItem) {
        var pos = this.k2n[key].pos;
        var level = pos.split('-').length - 1;
        if (this.props.shallowSelect && level > 1) {
            return;
        }

        var newSelectedKeys = void 0;

        var selectMode = this.props.selectMode;
        var selectedKeys = this.state.selectedKeys;

        var index = selectedKeys.indexOf(key);
        if (select && index === -1) {
            if (selectMode === 'single') {
                newSelectedKeys = [key];
            } else if (selectMode === 'multiple') {
                newSelectedKeys = selectedKeys.concat(key);
            }
        } else if (!select && index > -1 && selectMode === 'multiple') {
            newSelectedKeys = [].concat(selectedKeys.slice(0, index), selectedKeys.slice(index + 1));
        }

        if (newSelectedKeys) {
            if (!('selectedKeys' in this.props)) {
                this.setState({
                    selectedKeys: newSelectedKeys
                });
            }

            this.props.onSelect(newSelectedKeys, menuItem, _extends({
                key: key,
                select: select,
                label: this.k2n[key].label
            }, this.getPath(key)));
        }
    };

    Menu.prototype.handleItemClick = function handleItemClick(key, item, e) {
        var _this5 = this;

        if (this.props.focusable) {
            if (!('focusedKey' in this.props)) {
                this.setState({
                    focusedKey: key
                });
            }

            this.props.onItemFocus(key, item, e);
        }

        if (item.props.type === 'item') {
            if (item.props.parentMode === 'popup' && this.state.openKeys.length) {
                if (!('openKeys' in this.props)) {
                    this.setState({
                        openKeys: []
                    });
                }

                this.props.onOpen([], {
                    key: this.state.openKeys.sort(function (prevKey, nextKey) {
                        return _this5.k2n[nextKey].pos.split('-').length - _this5.k2n[prevKey].pos.split('-').length;
                    })[0],
                    open: false
                });
            }

            this.props.onItemClick(key, item, e);
        }
    };

    Menu.prototype.isAvailablePos = function isAvailablePos(refPos, targetPos) {
        var _p2n$targetPos = this.p2n[targetPos],
            type = _p2n$targetPos.type,
            disabled = _p2n$targetPos.disabled;


        return this.isSibling(refPos, targetPos) && (type === 'item' && !disabled || type === 'submenu');
    };

    Menu.prototype.getAvailableKey = function getAvailableKey(pos, prev) {
        var _this6 = this;

        var ps = Object.keys(this.p2n).filter(function (p) {
            return _this6.isAvailablePos(pos, p);
        });
        if (ps.length > 1) {
            var index = ps.indexOf(pos);
            var targetIndex = void 0;
            if (prev) {
                targetIndex = index === 0 ? ps.length - 1 : index - 1;
            } else {
                targetIndex = index === ps.length - 1 ? 0 : index + 1;
            }

            return this.p2n[ps[targetIndex]].key;
        }

        return null;
    };

    Menu.prototype.getFirstAvaliablelChildKey = function getFirstAvaliablelChildKey(parentPos) {
        var _this7 = this;

        var pos = Object.keys(this.p2n).find(function (p) {
            return _this7.isAvailablePos(parentPos + '-0', p);
        });
        return pos ? this.p2n[pos].key : null;
    };

    Menu.prototype.getParentKey = function getParentKey(pos) {
        return this.p2n[pos.slice(0, pos.length - 2)].key;
    };

    Menu.prototype.handleItemKeyDown = function handleItemKeyDown(key, type, item, e) {
        if ([_util.KEYCODE.UP, _util.KEYCODE.DOWN, _util.KEYCODE.RIGHT, _util.KEYCODE.LEFT, _util.KEYCODE.ENTER, _util.KEYCODE.ESC, _util.KEYCODE.SPACE].indexOf(e.keyCode) > -1) {
            e.preventDefault();
            e.stopPropagation();
        }

        var focusedKey = this.state.focusedKey;

        var direction = this.props.direction;

        var pos = this.k2n[key].pos;
        var level = pos.split('-').length - 1;
        switch (e.keyCode) {
            case _util.KEYCODE.UP:
                {
                    var avaliableKey = this.getAvailableKey(pos, true);
                    if (avaliableKey) {
                        focusedKey = avaliableKey;
                    }
                    break;
                }
            case _util.KEYCODE.DOWN:
                {
                    var _avaliableKey = void 0;
                    if (direction === 'hoz' && level === 1 && type === 'submenu') {
                        this.handleOpen(key, true);
                        _avaliableKey = this.getFirstAvaliablelChildKey(pos);
                    } else {
                        _avaliableKey = this.getAvailableKey(pos, false);
                    }
                    if (_avaliableKey) {
                        focusedKey = _avaliableKey;
                    }
                    break;
                }
            case _util.KEYCODE.RIGHT:
                {
                    var _avaliableKey2 = void 0;
                    if (direction === 'hoz' && level === 1) {
                        _avaliableKey2 = this.getAvailableKey(pos, false);
                    } else if (type === 'submenu') {
                        this.handleOpen(key, true);
                        _avaliableKey2 = this.getFirstAvaliablelChildKey(pos);
                    }
                    if (_avaliableKey2) {
                        focusedKey = _avaliableKey2;
                    }
                    break;
                }
            case _util.KEYCODE.ENTER:
                {
                    if (type === 'submenu') {
                        this.handleOpen(key, true);
                        var _avaliableKey3 = this.getFirstAvaliablelChildKey(pos);
                        if (_avaliableKey3) {
                            focusedKey = _avaliableKey3;
                        }
                    }
                    break;
                }
            case _util.KEYCODE.LEFT:
                {
                    if (direction === 'hoz' && level === 1) {
                        var _avaliableKey4 = this.getAvailableKey(pos, true);
                        if (_avaliableKey4) {
                            focusedKey = _avaliableKey4;
                        }
                    } else if (level > 1) {
                        var parentKey = this.getParentKey(pos);
                        this.handleOpen(parentKey, false);
                        focusedKey = parentKey;
                    }
                    break;
                }
            case _util.KEYCODE.ESC:
                if (level > 1) {
                    var _parentKey = this.getParentKey(pos);
                    this.handleOpen(_parentKey, false);
                    focusedKey = _parentKey;
                }
                break;

            case _util.KEYCODE.TAB:
                focusedKey = null;
                break;
            default:
                break;
        }

        if (focusedKey !== this.state.focusedKey) {
            if (!('focusedKey' in this.props)) {
                this.setState({
                    focusedKey: focusedKey
                });
            }

            this.props.onItemKeyDown(focusedKey, item, e);
            this.props.onItemFocus(focusedKey, e);
        }
    };

    Menu.prototype.render = function render() {
        var _cx;

        var _props2 = this.props,
            prefix = _props2.prefix,
            className = _props2.className,
            direction = _props2.direction,
            hozAlign = _props2.hozAlign,
            header = _props2.header,
            footer = _props2.footer,
            selectMode = _props2.selectMode,
            rtl = _props2.rtl;

        var others = pickOthers(Object.keys(Menu.propTypes), this.props);

        var newClassName = (0, _classnames2.default)((_cx = {}, _cx[prefix + 'menu'] = true, _cx[prefix + 'ver'] = direction === 'ver', _cx[prefix + 'hoz'] = direction === 'hoz', _cx[className] = !!className, _cx));

        var role = direction === 'hoz' ? 'menubar' : 'menu';
        var headerElement = header ? _react2.default.createElement(
            'li',
            { className: prefix + 'menu-header' },
            header
        ) : null;
        var itemsElement = header || footer ? _react2.default.createElement(
            'ul',
            { className: prefix + 'menu-content' },
            this.newChildren
        ) : this.newChildren;
        var footerElement = footer ? _react2.default.createElement(
            'li',
            { className: prefix + 'menu-footer' },
            footer
        ) : null;
        var shouldWrapItemsAndFooter = hozAlign === 'right' && !!header;

        if (rtl) {
            others.dir = 'rtl';
        }

        return _react2.default.createElement(
            'ul',
            _extends({ role: role, onBlur: this.onBlur, className: newClassName, onKeyDown: this.handleEnter, 'aria-multiselectable': selectMode === 'multiple' }, others),
            headerElement,
            shouldWrapItemsAndFooter ? _react2.default.createElement(
                'div',
                { className: prefix + 'menu-hoz-right' },
                itemsElement,
                footerElement
            ) : null,
            !shouldWrapItemsAndFooter ? itemsElement : null,
            !shouldWrapItemsAndFooter ? footerElement : null
        );
    };

    return Menu;
}(_react.Component), _class.isNextMenu = true, _class.propTypes = {
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    rtl: _propTypes2.default.bool,
    className: _propTypes2.default.string,
    /**
     * 菜单项和子菜单
     */
    children: _propTypes2.default.node,
    /**
     * 点击菜单项触发的回调函数
     * @param {String} key 点击的菜单项的 key 值
     * @param {Object} item 点击的菜单项对象
     * @param {Object} event 点击的事件对象
     */
    onItemClick: _propTypes2.default.func,
    /**
     * 当前打开的子菜单的 key 值
     */
    openKeys: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),
    /**
     * 初始打开的子菜单的 key 值
     */
    defaultOpenKeys: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),
    /**
     * 初始展开所有的子菜单，只在 mode 设置为 'inline' 以及 openMode 设置为 'multiple' 下生效，优先级高于 defaultOpenKeys
     */
    defaultOpenAll: _propTypes2.default.bool,
    /**
     * 打开或关闭子菜单触发的回调函数
     * @param {String} key 打开的所有子菜单的 key 值
     * @param {Object} extra 额外参数
     * @param {String} extra.key 当前操作子菜单的 key 值
     * @param {Boolean} extra.open 是否是打开
     */
    onOpen: _propTypes2.default.func,
    /**
     * 子菜单打开的模式
     */
    mode: _propTypes2.default.oneOf(['inline', 'popup']),
    /**
     * 子菜单打开的触发行为
     */
    triggerType: _propTypes2.default.oneOf(['click', 'hover']),
    /**
     * 展开内连子菜单的模式，同时可以展开一个子菜单还是多个子菜单，该属性仅在 mode 为 inline 时生效
     */
    openMode: _propTypes2.default.oneOf(['single', 'multiple']),
    /**
     * 内连子菜单缩进距离
     */
    inlineIndent: _propTypes2.default.number,
    inlineArrowDirection: _propTypes2.default.oneOf(['down', 'right']),
    /**
     * 是否自动让弹层的宽度和菜单项保持一致，如果弹层的宽度比菜单项小则和菜单项保持一致，如果宽度大于菜单项则不做处理
     */
    popupAutoWidth: _propTypes2.default.bool,
    /**
     * 弹层的对齐方式
     */
    popupAlign: _propTypes2.default.oneOf(['follow', 'outside']),
    /**
     * 弹层自定义 props
     */
    popupProps: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    /**
     * 弹出子菜单自定义 className
     */
    popupClassName: _propTypes2.default.string,
    /**
     * 弹出子菜单自定义 style
     */
    popupStyle: _propTypes2.default.object,
    /**
     * 当前选中菜单项的 key 值
     */
    selectedKeys: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),
    /**
     * 初始选中菜单项的 key 值
     */
    defaultSelectedKeys: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),
    /**
     * 选中或取消选中菜单项触发的回调函数
     * @param {Array} selectedKeys 选中的所有菜单项的值
     * @param {Object} item 选中或取消选中的菜单项
     * @param {Object} extra 额外参数
     * @param {Boolean} extra.select 是否是选中
     * @param {Array} extra.key 菜单项的 key
     * @param {Object} extra.label 菜单项的文本
     * @param {Array} extra.keyPath 菜单项 key 的路径
     */
    onSelect: _propTypes2.default.func,
    /**
     * 选中模式，单选还是多选，默认无值，不可选
     */
    selectMode: _propTypes2.default.oneOf(['single', 'multiple']),
    /**
     * 是否只能选择第一层菜单项（不能选择子菜单中的菜单项）
     */
    shallowSelect: _propTypes2.default.bool,
    /**
     * 是否显示选中图标，如果设置为 false 需配合配置平台设置选中时的背景色以示区分
     */
    hasSelectedIcon: _propTypes2.default.bool,
    labelToggleChecked: _propTypes2.default.bool,
    /**
     * 菜单第一层展示方向
     */
    direction: _propTypes2.default.oneOf(['ver', 'hoz']),
    /**
     * 横向菜单条 item 和 footer 的对齐方向，在 direction 设置为 'hoz' 并且 header 存在时生效
     */
    hozAlign: _propTypes2.default.oneOf(['left', 'right']),
    /**
     * 自定义菜单头部
     */
    header: _propTypes2.default.node,
    /**
     * 自定义菜单尾部
     */
    footer: _propTypes2.default.node,
    /**
     * 是否自动获得焦点
     */
    autoFocus: _propTypes2.default.bool,
    /**
     * 当前获得焦点的子菜单或菜单项 key 值
     */
    focusedKey: _propTypes2.default.string,
    focusable: _propTypes2.default.bool,
    onItemFocus: _propTypes2.default.func,
    onBlur: _propTypes2.default.func,
    onItemKeyDown: _propTypes2.default.func,
    expandAnimation: _propTypes2.default.bool,
    itemClassName: _propTypes2.default.string
}, _class.defaultProps = {
    prefix: 'next-',
    pure: false,
    defaultOpenKeys: [],
    defaultOpenAll: false,
    onOpen: noop,
    mode: 'inline',
    triggerType: 'click',
    openMode: 'multiple',
    inlineIndent: 20,
    inlineArrowDirection: 'down',
    popupAutoWidth: false,
    popupAlign: 'follow',
    popupProps: {},
    defaultSelectedKeys: [],
    onSelect: noop,
    shallowSelect: false,
    hasSelectedIcon: true,
    labelToggleChecked: true,
    direction: 'ver',
    hozAlign: 'left',
    autoFocus: false,
    focusable: true,
    onItemFocus: noop,
    onItemKeyDown: noop,
    onItemClick: noop,
    expandAnimation: true
}, _temp);
Menu.displayName = 'Menu';
exports.default = Menu;
module.exports = exports['default'];

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactTransitionGroup = __webpack_require__(52);

var _child = __webpack_require__(109);

var _child2 = _interopRequireDefault(_child);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};
var FirstChild = function FirstChild(props) {
    var childrenArray = _react2.default.Children.toArray(props.children);
    return childrenArray[0] || null;
};

/**
 * Animate
 */
var Animate = (_temp = _class = function (_Component) {
    _inherits(Animate, _Component);

    function Animate() {
        _classCallCheck(this, Animate);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    Animate.prototype.normalizeNames = function normalizeNames(names) {
        if (typeof names === 'string') {
            return {
                appear: names + '-appear',
                appearActive: names + '-appear-active',
                enter: names + '-enter',
                enterActive: names + '-enter-active',
                leave: names + '-leave',
                leaveActive: names + '-leave-active'
            };
        }
        if ((typeof names === 'undefined' ? 'undefined' : _typeof(names)) === 'object') {
            return {
                appear: names.appear,
                appearActive: names.appear + '-active',
                enter: '' + names.enter,
                enterActive: names.enter + '-active',
                leave: '' + names.leave,
                leaveActive: names.leave + '-active'
            };
        }
    };

    Animate.prototype.render = function render() {
        var _this2 = this;

        /* eslint-disable no-unused-vars */
        var _props = this.props,
            animation = _props.animation,
            children = _props.children,
            animationAppear = _props.animationAppear,
            singleMode = _props.singleMode,
            component = _props.component,
            beforeAppear = _props.beforeAppear,
            onAppear = _props.onAppear,
            afterAppear = _props.afterAppear,
            beforeEnter = _props.beforeEnter,
            onEnter = _props.onEnter,
            afterEnter = _props.afterEnter,
            beforeLeave = _props.beforeLeave,
            onLeave = _props.onLeave,
            afterLeave = _props.afterLeave,
            others = _objectWithoutProperties(_props, ['animation', 'children', 'animationAppear', 'singleMode', 'component', 'beforeAppear', 'onAppear', 'afterAppear', 'beforeEnter', 'onEnter', 'afterEnter', 'beforeLeave', 'onLeave', 'afterLeave']);
        /* eslint-enable no-unused-vars */

        var animateChildren = _react.Children.map(children, function (child) {
            return _react2.default.createElement(
                _child2.default,
                { key: child.key,
                    names: _this2.normalizeNames(animation),
                    onAppear: beforeAppear,
                    onAppearing: onAppear,
                    onAppeared: afterAppear,
                    onEnter: beforeEnter,
                    onEntering: onEnter,
                    onEntered: afterEnter,
                    onExit: beforeLeave,
                    onExiting: onLeave,
                    onExited: afterLeave },
                child
            );
        });

        return _react2.default.createElement(
            _reactTransitionGroup.TransitionGroup,
            _extends({ appear: animationAppear, component: singleMode ? FirstChild : component }, others),
            animateChildren
        );
    };

    return Animate;
}(_react.Component), _class.propTypes = {
    /**
     * 动画 className
     */
    animation: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),
    /**
     * 子元素第一次挂载时是否执行动画
     */
    animationAppear: _propTypes2.default.bool,
    /**
     * 包裹子元素的标签
     */
    component: _propTypes2.default.any,
    /**
     * 是否只有单个子元素，如果有多个子元素，请设置为 false
     */
    singleMode: _propTypes2.default.bool,
    /**
     * 子元素
     */
    children: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.arrayOf(_propTypes2.default.element)]),
    /**
     * 执行第一次挂载动画前触发的回调函数
     */
    beforeAppear: _propTypes2.default.func,
    /**
     * 执行第一次挂载动画，添加 xxx-appear-active 类名后触发的回调函数
     *  @param {HTMLElement} node 执行动画的 dom 元素
     */
    onAppear: _propTypes2.default.func,
    /**
     * 执行完第一次挂载动画后触发的函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    afterAppear: _propTypes2.default.func,
    /**
     * 执行进场动画前触发的回调函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    beforeEnter: _propTypes2.default.func,
    /**
     * 执行进场动画，添加 xxx-enter-active 类名后触发的回调函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    onEnter: _propTypes2.default.func,
    /**
     * 执行完进场动画后触发的回调函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    afterEnter: _propTypes2.default.func,
    /**
     * 执行离场动画前触发的回调函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    beforeLeave: _propTypes2.default.func,
    /**
     * 执行离场动画，添加 xxx-leave-active 类名后触发的回调函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    onLeave: _propTypes2.default.func,
    /**
     * 执行完离场动画后触发的回调函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    afterLeave: _propTypes2.default.func
}, _class.defaultProps = {
    animationAppear: true,
    component: 'div',
    singleMode: true,
    beforeAppear: noop,
    onAppear: noop,
    afterAppear: noop,
    beforeEnter: noop,
    onEnter: noop,
    afterEnter: noop,
    beforeLeave: noop,
    onLeave: noop,
    afterLeave: noop
}, _temp);
Animate.displayName = 'Animate';
exports.default = Animate;
module.exports = exports['default'];

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _CSSTransition = _interopRequireDefault(__webpack_require__(102));

var _ReplaceTransition = _interopRequireDefault(__webpack_require__(107));

var _TransitionGroup = _interopRequireDefault(__webpack_require__(56));

var _Transition = _interopRequireDefault(__webpack_require__(53));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

module.exports = {
  Transition: _Transition.default,
  TransitionGroup: _TransitionGroup.default,
  ReplaceTransition: _ReplaceTransition.default,
  CSSTransition: _CSSTransition.default
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

exports.__esModule = true;
exports.default = exports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = void 0;

var PropTypes = _interopRequireWildcard(__webpack_require__(1));

var _react = _interopRequireDefault(__webpack_require__(0));

var _reactDom = _interopRequireDefault(__webpack_require__(4));

var _reactLifecyclesCompat = __webpack_require__(54);

var _PropTypes = __webpack_require__(55);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }newObj.default = obj;return newObj;
  }
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];
  }return target;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;
  _defaults(subClass, superClass);
}

var UNMOUNTED = 'unmounted';
exports.UNMOUNTED = UNMOUNTED;
var EXITED = 'exited';
exports.EXITED = EXITED;
var ENTERING = 'entering';
exports.ENTERING = ENTERING;
var ENTERED = 'entered';
exports.ENTERED = ENTERED;
var EXITING = 'exiting';
/**
 * The Transition component lets you describe a transition from one component
 * state to another _over time_ with a simple declarative API. Most commonly
 * it's used to animate the mounting and unmounting of a component, but can also
 * be used to describe in-place transition states as well.
 *
 * By default the `Transition` component does not alter the behavior of the
 * component it renders, it only tracks "enter" and "exit" states for the components.
 * It's up to you to give meaning and effect to those states. For example we can
 * add styles to a component when it enters or exits:
 *
 * ```jsx
 * import Transition from 'react-transition-group/Transition';
 *
 * const duration = 300;
 *
 * const defaultStyle = {
 *   transition: `opacity ${duration}ms ease-in-out`,
 *   opacity: 0,
 * }
 *
 * const transitionStyles = {
 *   entering: { opacity: 0 },
 *   entered:  { opacity: 1 },
 * };
 *
 * const Fade = ({ in: inProp }) => (
 *   <Transition in={inProp} timeout={duration}>
 *     {(state) => (
 *       <div style={{
 *         ...defaultStyle,
 *         ...transitionStyles[state]
 *       }}>
 *         I'm a fade Transition!
 *       </div>
 *     )}
 *   </Transition>
 * );
 * ```
 *
 * As noted the `Transition` component doesn't _do_ anything by itself to its child component.
 * What it does do is track transition states over time so you can update the
 * component (such as by adding styles or classes) when it changes states.
 *
 * There are 4 main states a Transition can be in:
 *  - `'entering'`
 *  - `'entered'`
 *  - `'exiting'`
 *  - `'exited'`
 *
 * Transition state is toggled via the `in` prop. When `true` the component begins the
 * "Enter" stage. During this stage, the component will shift from its current transition state,
 * to `'entering'` for the duration of the transition and then to the `'entered'` stage once
 * it's complete. Let's take the following example:
 *
 * ```jsx
 * state = { in: false };
 *
 * toggleEnterState = () => {
 *   this.setState({ in: true });
 * }
 *
 * render() {
 *   return (
 *     <div>
 *       <Transition in={this.state.in} timeout={500} />
 *       <button onClick={this.toggleEnterState}>Click to Enter</button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the button is clicked the component will shift to the `'entering'` state and
 * stay there for 500ms (the value of `timeout`) before it finally switches to `'entered'`.
 *
 * When `in` is `false` the same thing happens except the state moves from `'exiting'` to `'exited'`.
 *
 * ## Timing
 *
 * Timing is often the trickiest part of animation, mistakes can result in slight delays
 * that are hard to pin down. A common example is when you want to add an exit transition,
 * you should set the desired final styles when the state is `'exiting'`. That's when the
 * transition to those styles will start and, if you matched the `timeout` prop with the
 * CSS Transition duration, it will end exactly when the state changes to `'exited'`.
 *
 * > **Note**: For simpler transitions the `Transition` component might be enough, but
 * > take into account that it's platform-agnostic, while the `CSSTransition` component
 * > [forces reflows](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
 * > in order to make more complex transitions more predictable. For example, even though
 * > classes `example-enter` and `example-enter-active` are applied immediately one after
 * > another, you can still transition from one to the other because of the forced reflow
 * > (read [this issue](https://github.com/reactjs/react-transition-group/issues/159#issuecomment-322761171)
 * > for more info). Take this into account when choosing between `Transition` and
 * > `CSSTransition`.
 */

exports.EXITING = EXITING;

var Transition =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Transition, _React$Component);

  function Transition(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context.transitionGroup; // In the context of a TransitionGroup all enters are really appears

    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;

    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }

    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }

  var _proto = Transition.prototype;

  _proto.getChildContext = function getChildContext() {
    return {
      transitionGroup: null // allows for nested Transitions

    };
  };

  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;

    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }

    return null;
  }; // getSnapshotBeforeUpdate(prevProps) {
  //   let nextStatus = null
  //   if (prevProps !== this.props) {
  //     const { status } = this.state
  //     if (this.props.in) {
  //       if (status !== ENTERING && status !== ENTERED) {
  //         nextStatus = ENTERING
  //       }
  //     } else {
  //       if (status === ENTERING || status === ENTERED) {
  //         nextStatus = EXITING
  //       }
  //     }
  //   }
  //   return { nextStatus }
  // }


  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;

    if (prevProps !== this.props) {
      var status = this.state.status;

      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }

    this.updateStatus(false, nextStatus);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };

  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;

    if (timeout != null && typeof timeout !== 'number') {
      exit = timeout.exit;
      enter = timeout.enter;
      appear = timeout.appear;
    }

    return {
      exit: exit,
      enter: enter,
      appear: appear
    };
  };

  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }

    if (nextStatus !== null) {
      // nextStatus will always be ENTERING or EXITING.
      this.cancelNextCallback();

      var node = _reactDom.default.findDOMNode(this);

      if (nextStatus === ENTERING) {
        this.performEnter(node, mounting);
      } else {
        this.performExit(node);
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };

  _proto.performEnter = function performEnter(node, mounting) {
    var _this2 = this;

    var enter = this.props.enter;
    var appearing = this.context.transitionGroup ? this.context.transitionGroup.isMounting : mounting;
    var timeouts = this.getTimeouts(); // no enter animation skip right to ENTERED
    // if we are mounting and running this it means appear _must_ be set

    if (!mounting && !enter) {
      this.safeSetState({
        status: ENTERED
      }, function () {
        _this2.props.onEntered(node);
      });
      return;
    }

    this.props.onEnter(node, appearing);
    this.safeSetState({
      status: ENTERING
    }, function () {
      _this2.props.onEntering(node, appearing); // FIXME: appear timeout?


      _this2.onTransitionEnd(node, timeouts.enter, function () {
        _this2.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(node, appearing);
        });
      });
    });
  };

  _proto.performExit = function performExit(node) {
    var _this3 = this;

    var exit = this.props.exit;
    var timeouts = this.getTimeouts(); // no exit animation skip right to EXITED

    if (!exit) {
      this.safeSetState({
        status: EXITED
      }, function () {
        _this3.props.onExited(node);
      });
      return;
    }

    this.props.onExit(node);
    this.safeSetState({
      status: EXITING
    }, function () {
      _this3.props.onExiting(node);

      _this3.onTransitionEnd(node, timeouts.exit, function () {
        _this3.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(node);
        });
      });
    });
  };

  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };

  _proto.safeSetState = function safeSetState(nextState, callback) {
    // This shouldn't be necessary, but there are weird race conditions with
    // setState callbacks and unmounting in testing, so always make sure that
    // we can cancel any pending setState callbacks after we unmount.
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };

  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;

    var active = true;

    this.nextCallback = function (event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };

    this.nextCallback.cancel = function () {
      active = false;
    };

    return this.nextCallback;
  };

  _proto.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {
    this.setNextCallback(handler);

    if (node) {
      if (this.props.addEndListener) {
        this.props.addEndListener(node, this.nextCallback);
      }

      if (timeout != null) {
        setTimeout(this.nextCallback, timeout);
      }
    } else {
      setTimeout(this.nextCallback, 0);
    }
  };

  _proto.render = function render() {
    var status = this.state.status;

    if (status === UNMOUNTED) {
      return null;
    }

    var _this$props = this.props,
        children = _this$props.children,
        childProps = _objectWithoutPropertiesLoose(_this$props, ["children"]); // filter props for Transtition


    delete childProps.in;
    delete childProps.mountOnEnter;
    delete childProps.unmountOnExit;
    delete childProps.appear;
    delete childProps.enter;
    delete childProps.exit;
    delete childProps.timeout;
    delete childProps.addEndListener;
    delete childProps.onEnter;
    delete childProps.onEntering;
    delete childProps.onEntered;
    delete childProps.onExit;
    delete childProps.onExiting;
    delete childProps.onExited;

    if (typeof children === 'function') {
      return children(status, childProps);
    }

    var child = _react.default.Children.only(children);

    return _react.default.cloneElement(child, childProps);
  };

  return Transition;
}(_react.default.Component);

Transition.contextTypes = {
  transitionGroup: PropTypes.object
};
Transition.childContextTypes = {
  transitionGroup: function transitionGroup() {}
};
Transition.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * A `function` child can be used instead of a React element.
   * This function is called with the current transition status
   * ('entering', 'entered', 'exiting', 'exited', 'unmounted'), which can be used
   * to apply context specific props to a component.
   *
   * ```jsx
   * <Transition timeout={150}>
   *   {(status) => (
   *     <MyComponent className={`fade fade-${status}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,

  /**
   * Show the component; triggers the enter or exit states
   */
  in: PropTypes.bool,

  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: PropTypes.bool,

  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: PropTypes.bool,

  /**
   * Normally a component is not transitioned if it is shown when the `<Transition>` component mounts.
   * If you want to transition on the first mount set `appear` to `true`, and the
   * component will transition in as soon as the `<Transition>` mounts.
   *
   * > Note: there are no specific "appear" states. `appear` only adds an additional `enter` transition.
   */
  appear: PropTypes.bool,

  /**
   * Enable or disable enter transitions.
   */
  enter: PropTypes.bool,

  /**
   * Enable or disable exit transitions.
   */
  exit: PropTypes.bool,

  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided
   *
   * You may specify a single timeout for all transitions like: `timeout={500}`,
   * or individually like:
   *
   * ```jsx
   * timeout={{
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * @type {number | { enter?: number, exit?: number }}
   */
  timeout: function timeout(props) {
    var pt = process.env.NODE_ENV !== "production" ? _PropTypes.timeoutsShape : {};;
    if (!props.addEndListener) pt = pt.isRequired;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return pt.apply(void 0, [props].concat(args));
  },

  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. **Note:** Timeouts are still used as a fallback if provided.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: PropTypes.func,

  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: PropTypes.func,

  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,

  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: PropTypes.func,

  /**
   * Callback fired before the "exiting" status is applied.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: PropTypes.func,

  /**
   * Callback fired after the "exiting" status is applied.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: PropTypes.func,

  /**
   * Callback fired after the "exited" status is applied.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: PropTypes.func // Name the function so it is clearer in the documentation

} : {};

function noop() {}

Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = 0;
Transition.EXITED = 1;
Transition.ENTERING = 2;
Transition.ENTERED = 3;
Transition.EXITING = 4;

var _default = (0, _reactLifecyclesCompat.polyfill)(Transition);

exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function componentWillMount() {
  // Call this.constructor.gDSFP to support sub-classes.
  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
  if (state !== null && state !== undefined) {
    this.setState(state);
  }
}

function componentWillReceiveProps(nextProps) {
  // Call this.constructor.gDSFP to support sub-classes.
  // Use the setState() updater to ensure state isn't stale in certain edge cases.
  function updater(prevState) {
    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
    return state !== null && state !== undefined ? state : null;
  }
  // Binding "this" is important for shallow renderer support.
  this.setState(updater.bind(this));
}

function componentWillUpdate(nextProps, nextState) {
  try {
    var prevProps = this.props;
    var prevState = this.state;
    this.props = nextProps;
    this.state = nextState;
    this.__reactInternalSnapshotFlag = true;
    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(prevProps, prevState);
  } finally {
    this.props = prevProps;
    this.state = prevState;
  }
}

// React may warn about cWM/cWRP/cWU methods being deprecated.
// Add a flag to suppress these warnings for this special case.
componentWillMount.__suppressDeprecationWarning = true;
componentWillReceiveProps.__suppressDeprecationWarning = true;
componentWillUpdate.__suppressDeprecationWarning = true;

function polyfill(Component) {
  var prototype = Component.prototype;

  if (!prototype || !prototype.isReactComponent) {
    throw new Error('Can only polyfill class components');
  }

  if (typeof Component.getDerivedStateFromProps !== 'function' && typeof prototype.getSnapshotBeforeUpdate !== 'function') {
    return Component;
  }

  // If new component APIs are defined, "unsafe" lifecycles won't be called.
  // Error if any of these lifecycles are present,
  // Because they would work differently between older and newer (16.3+) versions of React.
  var foundWillMountName = null;
  var foundWillReceivePropsName = null;
  var foundWillUpdateName = null;
  if (typeof prototype.componentWillMount === 'function') {
    foundWillMountName = 'componentWillMount';
  } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {
    foundWillMountName = 'UNSAFE_componentWillMount';
  }
  if (typeof prototype.componentWillReceiveProps === 'function') {
    foundWillReceivePropsName = 'componentWillReceiveProps';
  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {
    foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
  }
  if (typeof prototype.componentWillUpdate === 'function') {
    foundWillUpdateName = 'componentWillUpdate';
  } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {
    foundWillUpdateName = 'UNSAFE_componentWillUpdate';
  }
  if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
    var componentName = Component.displayName || Component.name;
    var newApiName = typeof Component.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';

    throw Error('Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' + componentName + ' uses ' + newApiName + ' but also contains the following legacy lifecycles:' + (foundWillMountName !== null ? '\n  ' + foundWillMountName : '') + (foundWillReceivePropsName !== null ? '\n  ' + foundWillReceivePropsName : '') + (foundWillUpdateName !== null ? '\n  ' + foundWillUpdateName : '') + '\n\nThe above lifecycles should be removed. Learn more about this warning here:\n' + 'https://fb.me/react-async-component-lifecycle-hooks');
  }

  // React <= 16.2 does not support static getDerivedStateFromProps.
  // As a workaround, use cWM and cWRP to invoke the new static lifecycle.
  // Newer versions of React will ignore these lifecycles if gDSFP exists.
  if (typeof Component.getDerivedStateFromProps === 'function') {
    prototype.componentWillMount = componentWillMount;
    prototype.componentWillReceiveProps = componentWillReceiveProps;
  }

  // React <= 16.2 does not support getSnapshotBeforeUpdate.
  // As a workaround, use cWU to invoke the new lifecycle.
  // Newer versions of React will ignore that lifecycle if gSBU exists.
  if (typeof prototype.getSnapshotBeforeUpdate === 'function') {
    if (typeof prototype.componentDidUpdate !== 'function') {
      throw new Error('Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype');
    }

    prototype.componentWillUpdate = componentWillUpdate;

    var componentDidUpdate = prototype.componentDidUpdate;

    prototype.componentDidUpdate = function componentDidUpdatePolyfill(prevProps, prevState, maybeSnapshot) {
      // 16.3+ will not execute our will-update method;
      // It will pass a snapshot value to did-update though.
      // Older versions will require our polyfilled will-update value.
      // We need to handle both cases, but can't just check for the presence of "maybeSnapshot",
      // Because for <= 15.x versions this might be a "prevContext" object.
      // We also can't just check "__reactInternalSnapshot",
      // Because get-snapshot might return a falsy value.
      // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.
      var snapshot = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : maybeSnapshot;

      componentDidUpdate.call(this, prevProps, prevState, snapshot);
    };
  }

  return Component;
}

exports.polyfill = polyfill;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.transitionTimeout = transitionTimeout;
exports.classNamesShape = exports.timeoutsShape = void 0;

var _propTypes = _interopRequireDefault(__webpack_require__(1));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function transitionTimeout(transitionType) {
  var timeoutPropName = 'transition' + transitionType + 'Timeout';
  var enabledPropName = 'transition' + transitionType;
  return function (props) {
    // If the transition is enabled
    if (props[enabledPropName]) {
      // If no timeout duration is provided
      if (props[timeoutPropName] == null) {
        return new Error(timeoutPropName + ' wasn\'t supplied to CSSTransitionGroup: ' + 'this can cause unreliable animations and won\'t be supported in ' + 'a future version of React. See ' + 'https://fb.me/react-animation-transition-group-timeout for more ' + 'information.'); // If the duration isn't a number
      } else if (typeof props[timeoutPropName] !== 'number') {
        return new Error(timeoutPropName + ' must be a number (in milliseconds)');
      }
    }

    return null;
  };
}

var timeoutsShape = _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.shape({
  enter: _propTypes.default.number,
  exit: _propTypes.default.number
}).isRequired]);

exports.timeoutsShape = timeoutsShape;

var classNamesShape = _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.shape({
  enter: _propTypes.default.string,
  exit: _propTypes.default.string,
  active: _propTypes.default.string
}), _propTypes.default.shape({
  enter: _propTypes.default.string,
  enterDone: _propTypes.default.string,
  enterActive: _propTypes.default.string,
  exit: _propTypes.default.string,
  exitDone: _propTypes.default.string,
  exitActive: _propTypes.default.string
})]);

exports.classNamesShape = classNamesShape;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

exports.__esModule = true;
exports.default = void 0;

var _propTypes = _interopRequireDefault(__webpack_require__(1));

var _react = _interopRequireDefault(__webpack_require__(0));

var _reactLifecyclesCompat = __webpack_require__(54);

var _ChildMapping = __webpack_require__(108);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];
  }return target;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;
  _defaults(subClass, superClass);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return self;
}

var values = Object.values || function (obj) {
  return Object.keys(obj).map(function (k) {
    return obj[k];
  });
};

var propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: _propTypes.default.any,

  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   */
  children: _propTypes.default.node,

  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: _propTypes.default.bool,

  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: _propTypes.default.bool,

  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: _propTypes.default.bool,

  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: _propTypes.default.func
} : {};;
var defaultProps = {
  component: 'div',
  childFactory: function childFactory(child) {
    return child;
  }
  /**
   * The `<TransitionGroup>` component manages a set of transition components
   * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
   * components, `<TransitionGroup>` is a state machine for managing the mounting
   * and unmounting of components over time.
   *
   * Consider the example below. As items are removed or added to the TodoList the
   * `in` prop is toggled automatically by the `<TransitionGroup>`.
   *
   * Note that `<TransitionGroup>`  does not define any animation behavior!
   * Exactly _how_ a list item animates is up to the individual transition
   * component. This means you can mix and match animations across different list
   * items.
   */

};

var TransitionGroup =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(TransitionGroup, _React$Component);

  function TransitionGroup(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;

    var handleExited = _this.handleExited.bind(_assertThisInitialized(_assertThisInitialized(_this))); // Initial children should all be entering, dependent on appear


    _this.state = {
      handleExited: handleExited,
      firstRender: true
    };
    return _this;
  }

  var _proto = TransitionGroup.prototype;

  _proto.getChildContext = function getChildContext() {
    return {
      transitionGroup: {
        isMounting: !this.appeared
      }
    };
  };

  _proto.componentDidMount = function componentDidMount() {
    this.appeared = true;
    this.mounted = true;
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };

  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children,
        handleExited = _ref.handleExited,
        firstRender = _ref.firstRender;
    return {
      children: firstRender ? (0, _ChildMapping.getInitialChildMapping)(nextProps, handleExited) : (0, _ChildMapping.getNextChildMapping)(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };

  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = (0, _ChildMapping.getChildMapping)(this.props.children);
    if (child.key in currentChildMapping) return;

    if (child.props.onExited) {
      child.props.onExited(node);
    }

    if (this.mounted) {
      this.setState(function (state) {
        var children = _extends({}, state.children);

        delete children[child.key];
        return {
          children: children
        };
      });
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        Component = _this$props.component,
        childFactory = _this$props.childFactory,
        props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);

    var children = values(this.state.children).map(childFactory);
    delete props.appear;
    delete props.enter;
    delete props.exit;

    if (Component === null) {
      return children;
    }

    return _react.default.createElement(Component, props, children);
  };

  return TransitionGroup;
}(_react.default.Component);

TransitionGroup.childContextTypes = {
  transitionGroup: _propTypes.default.object.isRequired
};
TransitionGroup.propTypes = process.env.NODE_ENV !== "production" ? propTypes : {};
TransitionGroup.defaultProps = defaultProps;

var _default = (0, _reactLifecyclesCompat.polyfill)(TransitionGroup);

exports.default = _default;
module.exports = exports["default"];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _overlay = __webpack_require__(15);

var _overlay2 = _interopRequireDefault(_overlay);

var _util = __webpack_require__(2);

var _item = __webpack_require__(14);

var _item2 = _interopRequireDefault(_item);

var _selectableItem = __webpack_require__(22);

var _selectableItem2 = _interopRequireDefault(_selectableItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var bindCtx = _util.func.bindCtx;
var setStyle = _util.dom.setStyle;

var Popup = _overlay2.default.Popup;

/**
 * Menu.PopupItem
 * @order 2
 */
var PopupItem = (_temp = _class = function (_Component) {
    _inherits(PopupItem, _Component);

    function PopupItem(props) {
        _classCallCheck(this, PopupItem);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        bindCtx(_this, ['handleOpen', 'handlePopupOpen', 'handlePopupClose', 'getPopup']);
        return _this;
    }

    PopupItem.prototype.getPopup = function getPopup(ref) {
        this.popup = ref;
    };

    PopupItem.prototype.getOpen = function getOpen() {
        var _props = this.props,
            _key = _props._key,
            root = _props.root;
        var openKeys = root.state.openKeys;


        return openKeys.indexOf(_key) > -1;
    };

    PopupItem.prototype.getPopupProps = function getPopupProps() {
        var popupProps = this.props.root.props.popupProps;

        if (typeof popupProps === 'function') {
            popupProps = popupProps(this.props);
        }
        return popupProps;
    };

    PopupItem.prototype.handleOpen = function handleOpen(open, triggerType, e) {
        var _props2 = this.props,
            _key = _props2._key,
            root = _props2.root;

        root.handleOpen(_key, open, triggerType, e);

        var popupProps = this.popupProps;
        popupProps.onVisibleChange && popupProps.onVisibleChange(open, triggerType, e);
    };

    PopupItem.prototype.handlePopupOpen = function handlePopupOpen() {
        var _props3 = this.props,
            root = _props3.root,
            level = _props3.level,
            align = _props3.align,
            autoWidth = _props3.autoWidth;
        var _root$props = root.props,
            rootPopupAutoWidth = _root$props.popupAutoWidth,
            rootPopupAlign = _root$props.popupAlign,
            direction = _root$props.direction;

        var popupAlign = align || rootPopupAlign;
        var popupAutoWidth = 'autoWidth' in this.props ? autoWidth : rootPopupAutoWidth;
        var itemNode = (0, _reactDom.findDOMNode)(this);
        var menuNode = itemNode.parentNode;
        this.popupNode = this.popup.getInstance().overlay.getInstance().getContentNode();
        root.popupNodes.push(this.popupNode);

        if (popupAutoWidth) {
            var targetNode = direction === 'hoz' && level === 1 ? itemNode : menuNode;

            if (targetNode.offsetWidth > this.popupNode.offsetWidth) {
                setStyle(this.popupNode, 'width', targetNode.offsetWidth + 'px');
            }
        }
        if (popupAlign === 'outside' && !(direction === 'hoz' && level === 1)) {
            setStyle(this.popupNode, 'height', menuNode.offsetHeight + 'px');
            setStyle(this.popupNode, 'overflow-y', 'scroll');
        }
        // removeClass(this.popupNode, `${prefix}hide`);

        var popupProps = this.popupProps;
        popupProps.onOpen && popupProps.onOpen();
    };

    PopupItem.prototype.handlePopupClose = function handlePopupClose() {
        var root = this.props.root;

        var popupNodes = root.popupNodes;
        var index = popupNodes.indexOf(this.popupNode);
        index > -1 && popupNodes.splice(index, 1);

        var popupProps = this.popupProps;
        popupProps.onClose && popupProps.onClose();
    };

    PopupItem.prototype.renderItem = function renderItem(selectable, children, others) {
        var _props4 = this.props,
            _key = _props4._key,
            root = _props4.root,
            level = _props4.level,
            label = _props4.label,
            className = _props4.className;
        var prefix = root.props.prefix;

        var NewItem = selectable ? _selectableItem2.default : _item2.default;
        var open = this.getOpen();

        var itemProps = {
            'aria-haspopup': true,
            'aria-expanded': open,
            _key: _key,
            root: root,
            level: level,
            type: 'submenu'
        };
        if (open) {
            var _cx;

            itemProps.className = (0, _classnames2.default)((_cx = {}, _cx[prefix + 'opened'] = true, _cx[className] = !!className, _cx));
        } else {
            itemProps.className = className;
        }

        return _react2.default.createElement(
            NewItem,
            _extends({}, itemProps, others),
            _react2.default.createElement(
                'span',
                { className: prefix + 'menu-item-text' },
                label
            ),
            children
        );
    };

    PopupItem.prototype.renderPopup = function renderPopup(trigger, triggerType, positionProps, children) {
        var _this2 = this;

        var _props5 = this.props,
            root = _props5.root,
            level = _props5.level,
            selectable = _props5.selectable;
        var direction = root.props.direction;

        this.popupProps = this.getPopupProps();
        var open = this.getOpen();

        if (direction === 'hoz' && level === 1 && selectable) {
            positionProps.target = function () {
                return (0, _reactDom.findDOMNode)(_this2);
            };
        }

        return _react2.default.createElement(
            Popup,
            _extends({ ref: this.getPopup
            }, positionProps, this.popupProps, {
                canCloseByEsc: false,
                trigger: trigger,
                triggerType: triggerType,
                visible: open,
                onVisibleChange: this.handleOpen,
                onOpen: this.handlePopupOpen,
                onClose: this.handlePopupClose }),
            children
        );
    };

    PopupItem.prototype.render = function render() {
        var _this3 = this;

        var _props6 = this.props,
            root = _props6.root,
            level = _props6.level,
            hasSubMenu = _props6.hasSubMenu,
            selectableFromProps = _props6.selectable,
            children = _props6.children,
            triggerType = _props6.triggerType,
            align = _props6.align,
            rtl = _props6.rtl;

        var others = _util.obj.pickOthers(Object.keys(PopupItem.propTypes), this.props);
        var _root$props2 = root.props,
            prefix = _root$props2.prefix,
            selectMode = _root$props2.selectMode,
            direction = _root$props2.direction,
            rootPopupAlign = _root$props2.popupAlign,
            rootTriggerType = _root$props2.triggerType;

        var popupAlign = align || rootPopupAlign;
        var newTriggerType = triggerType || (hasSubMenu ? rootTriggerType : 'hover');
        var newChildren = Array.isArray(children) ? children[0] : children;
        // let newChildren = Array.isArray(children) ? children[0] : children;
        // newChildren = cloneElement(newChildren, {
        //     className: cx({
        //         [`${prefix}menu-popup-content`]: true,
        //         [newChildren.props.className]: !!newChildren.props.className,
        //         [`${prefix}hide`]: popupAutoWidth || popupAlign === 'outside'
        //     })
        // });
        var selectable = selectMode && selectableFromProps;
        var triggerIsIcon = selectable && newTriggerType === 'click';
        var open = this.getOpen();

        var positionProps = {};
        var arrowProps = void 0;

        if (direction === 'hoz' && level === 1) {
            var _cx2;

            positionProps.align = 'tl bl';
            positionProps.offset = [0, 0];

            arrowProps = {
                type: 'arrow-down',
                className: (0, _classnames2.default)((_cx2 = {}, _cx2[prefix + 'menu-hoz-icon-arrow'] = true, _cx2[prefix + 'open'] = open, _cx2))
            };
        } else {
            if (popupAlign === 'outside') {
                positionProps.target = function () {
                    return (0, _reactDom.findDOMNode)(root);
                };
                positionProps.align = 'tl tr';

                rtl ? positionProps.offset = [-2, 0] : positionProps.offset = [2, 0];
            } else {
                if (triggerIsIcon) {
                    positionProps.target = function () {
                        return (0, _reactDom.findDOMNode)(_this3);
                    };
                }
                positionProps.align = 'tl tr';

                rtl ? positionProps.offset = [2, -8] : positionProps.offset = [-2, -8];
            }

            arrowProps = {
                type: 'arrow-right',
                className: prefix + 'menu-icon-arrow'
            };
        }

        var arrow = _react2.default.createElement(_icon2.default, arrowProps);
        var trigger = triggerIsIcon ? arrow : this.renderItem(selectable, arrow, others);
        var popup = this.renderPopup(trigger, newTriggerType, positionProps, newChildren);
        return triggerIsIcon ? this.renderItem(selectable, popup, others) : popup;
    };

    return PopupItem;
}(_react.Component), _class.menuChildType = 'submenu', _class.propTypes = {
    _key: _propTypes2.default.string,
    root: _propTypes2.default.object,
    level: _propTypes2.default.number,
    hasSubMenu: _propTypes2.default.bool,
    rtl: _propTypes2.default.bool,
    selectable: _propTypes2.default.bool,
    /**
     * 标签内容
     */
    label: _propTypes2.default.node,
    /**
     * 自定义弹层内容
     */
    children: _propTypes2.default.node,
    className: _propTypes2.default.string,
    triggerType: _propTypes2.default.oneOf(['click', 'hover']),
    align: _propTypes2.default.oneOf(['outside', 'follow']),
    autoWidth: _propTypes2.default.bool
}, _class.defaultProps = {
    selectable: false
}, _temp);
PopupItem.displayName = 'PopupItem';
exports.default = PopupItem;
module.exports = exports['default'];

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _checkbox = __webpack_require__(37);

var _checkbox2 = _interopRequireDefault(_checkbox);

var _radio = __webpack_require__(61);

var _radio2 = _interopRequireDefault(_radio);

var _util = __webpack_require__(2);

var _item = __webpack_require__(14);

var _item2 = _interopRequireDefault(_item);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = {};
var bindCtx = _util.func.bindCtx;
var pickOthers = _util.obj.pickOthers;
var CheckableItem = (_temp = _class = function (_Component) {
    _inherits(CheckableItem, _Component);

    function CheckableItem(props) {
        _classCallCheck(this, CheckableItem);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        bindCtx(_this, ['stopPropagation', 'handleKeyDown', 'handleClick']);
        return _this;
    }

    CheckableItem.prototype.stopPropagation = function stopPropagation(e) {
        e.stopPropagation();
    };

    CheckableItem.prototype.handleCheck = function handleCheck(e) {
        var _props = this.props,
            checkType = _props.checkType,
            checked = _props.checked,
            onChange = _props.onChange;

        if (!(checkType === 'radio' && checked)) {
            onChange(!checked, e);
        }
    };

    CheckableItem.prototype.handleKeyDown = function handleKeyDown(e) {
        if (e.keyCode === _util.KEYCODE.SPACE && !this.props.checkDisabled) {
            this.handleCheck(e);
        }

        this.props.onKeyDown && this.props.onKeyDown(e);
    };

    CheckableItem.prototype.handleClick = function handleClick(e) {
        this.handleCheck(e);

        this.props.onClick && this.props.onClick(e);
    };

    CheckableItem.prototype.renderCheck = function renderCheck() {
        var _props2 = this.props,
            root = _props2.root,
            checked = _props2.checked,
            indeterminate = _props2.indeterminate,
            disabled = _props2.disabled,
            checkType = _props2.checkType,
            checkDisabled = _props2.checkDisabled,
            onChange = _props2.onChange;
        var labelToggleChecked = root.props.labelToggleChecked;

        var Check = checkType === 'radio' ? _radio2.default : _checkbox2.default;

        var checkProps = {
            tabIndex: '-1',
            checked: checked,
            disabled: disabled || checkDisabled
        };
        if (checkType === 'checkbox') {
            checkProps.indeterminate = indeterminate;
        }
        if (!labelToggleChecked) {
            checkProps.onChange = onChange;
            checkProps.onClick = this.stopPropagation;
        }

        return _react2.default.createElement(Check, checkProps);
    };

    CheckableItem.prototype.render = function render() {
        var _props3 = this.props,
            _key = _props3._key,
            root = _props3.root,
            checked = _props3.checked,
            disabled = _props3.disabled,
            onClick = _props3.onClick,
            helper = _props3.helper,
            children = _props3.children;
        var _root$props = root.props,
            prefix = _root$props.prefix,
            labelToggleChecked = _root$props.labelToggleChecked;

        var others = pickOthers(Object.keys(CheckableItem.propTypes), this.props);

        var newProps = _extends({
            _key: _key,
            root: root,
            disabled: disabled,
            type: 'item',
            onClick: onClick,
            onKeyDown: this.handleKeyDown
        }, others);
        if (labelToggleChecked && !disabled) {
            newProps.onClick = this.handleClick;
        }

        return _react2.default.createElement(
            _item2.default,
            _extends({ 'aria-checked': checked }, newProps),
            this.renderCheck(),
            _react2.default.createElement(
                'span',
                { className: prefix + 'menu-item-text' },
                children
            ),
            helper ? _react2.default.createElement(
                'div',
                { className: prefix + 'menu-item-helper' },
                helper
            ) : null
        );
    };

    return CheckableItem;
}(_react.Component), _class.propTypes = {
    _key: _propTypes2.default.string,
    root: _propTypes2.default.object,
    disabled: _propTypes2.default.bool,
    inlineIndent: _propTypes2.default.number,
    checked: _propTypes2.default.bool,
    indeterminate: _propTypes2.default.bool,
    onChange: _propTypes2.default.func,
    checkType: _propTypes2.default.oneOf(['checkbox', 'radio']),
    checkDisabled: _propTypes2.default.bool,
    helper: _propTypes2.default.node,
    children: _propTypes2.default.node,
    onKeyDown: _propTypes2.default.func,
    onClick: _propTypes2.default.func
}, _class.defaultProps = {
    disabled: false,
    checked: false,
    indeterminate: false,
    checkType: 'checkbox',
    checkDisabled: false,
    onChange: noop
}, _temp);
CheckableItem.displayName = 'CheckableItem';
exports.default = CheckableItem;
module.exports = exports['default'];

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _mixinUiState = __webpack_require__(60);

var _mixinUiState2 = _interopRequireDefault(_mixinUiState);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = _util.func.noop;
function isChecked(selectedValue, value) {
    return selectedValue.indexOf(value) > -1;
}
/**
 * Checkbox
 * @order 1
 */
var Checkbox = (_temp = _class = function (_UIState) {
    _inherits(Checkbox, _UIState);

    function Checkbox(props, context) {
        _classCallCheck(this, Checkbox);

        var _this = _possibleConstructorReturn(this, _UIState.call(this, props));

        var checked = void 0,
            indeterminate = void 0;
        if (context.__group__) {
            indeterminate = false;
            checked = isChecked(context.selectedValue, props.value);
        } else {
            if ('checked' in props) {
                checked = props.checked;
            } else {
                checked = props.defaultChecked;
            }

            if ('indeterminate' in props) {
                indeterminate = props.indeterminate;
            } else {
                indeterminate = props.defaultIndeterminate;
            }
        }

        _this.state = {
            checked: checked,
            indeterminate: indeterminate
        };

        _this.disabled = props.disabled || context.__group__ && 'disabled' in context && context.disabled;
        _this.onChange = _this.onChange.bind(_this);
        return _this;
    }

    Checkbox.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
        if (nextContext.__group__) {
            if ('selectedValue' in nextContext) {
                this.setState({
                    checked: isChecked(nextContext.selectedValue, nextProps.value)
                });
            }
            this.disabled = nextProps.disabled || 'disabled' in nextContext && nextContext.disabled;
        } else {
            if ('checked' in nextProps) {
                this.setState({
                    checked: nextProps.checked
                });
            }
            if ('indeterminate' in nextProps) {
                this.setState({
                    indeterminate: nextProps.indeterminate
                });
            }
            this.disabled = nextProps.disabled;
        }
    };

    Checkbox.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState, nextContext) {
        var shallowEqual = _util.obj.shallowEqual;

        return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState) || !shallowEqual(this.context, nextContext);
    };

    Checkbox.prototype.onChange = function onChange(e) {
        var checked = e.target.checked;
        var value = this.props.value;
        if (this.disabled) {
            return;
        }
        if (this.context.__group__) {
            this.context.onChange(value, e);
        } else {
            if (!('checked' in this.props)) {
                this.setState({
                    checked: checked
                });
            }

            if (!('indeterminate' in this.props)) {
                this.setState({
                    indeterminate: false
                });
            }
            this.props.onChange(checked, e);
        }
    };

    Checkbox.prototype.render = function render() {
        var _classnames;

        /* eslint-disable no-unused-vars */
        var _props = this.props,
            id = _props.id,
            className = _props.className,
            children = _props.children,
            style = _props.style,
            label = _props.label,
            onMouseEnter = _props.onMouseEnter,
            onMouseLeave = _props.onMouseLeave,
            rtl = _props.rtl,
            otherProps = _objectWithoutProperties(_props, ['id', 'className', 'children', 'style', 'label', 'onMouseEnter', 'onMouseLeave', 'rtl']);

        var checked = !!this.state.checked;
        var disabled = this.disabled;
        var indeterminate = !!this.state.indeterminate;
        var prefix = this.context.prefix || this.props.prefix;

        var others = _util.obj.pickOthers(Checkbox.propTypes, otherProps);
        var othersData = _util.obj.pickAttrsWith(others, 'data-');

        var childInput = _react2.default.createElement('input', _extends({}, _util.obj.pickOthers(Checkbox.propTypes, otherProps), {
            id: id,
            disabled: disabled,
            checked: checked,
            type: 'checkbox',
            onChange: this.onChange,
            'aria-checked': indeterminate ? 'mixed' : checked,
            className: prefix + 'checkbox-input'
        }));

        // disable 无状态操作
        if (!disabled) {
            childInput = this.getStateElement(childInput);
        }
        var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'checkbox-wrapper'] = true, _classnames[className] = !!className, _classnames.checked = checked, _classnames.disabled = disabled, _classnames.indeterminate = indeterminate, _classnames[this.getStateClassName()] = true, _classnames));
        var labelCls = prefix + 'checkbox-label';
        var type = indeterminate ? 'semi-select' : 'select';

        return _react2.default.createElement(
            'label',
            _extends({}, othersData, {
                className: cls,
                style: style,
                onMouseEnter: onMouseEnter,
                onMouseLeave: onMouseLeave
            }),
            _react2.default.createElement(
                'span',
                { className: prefix + 'checkbox' },
                _react2.default.createElement(
                    'span',
                    { className: prefix + 'checkbox-inner' },
                    _react2.default.createElement(_icon2.default, { type: type, size: 'xs', className: indeterminate ? 'zoomIn' : '' })
                ),
                childInput
            ),
            [label, children].map(function (item, i) {
                return item ? _react2.default.createElement(
                    'span',
                    { key: i, className: labelCls },
                    item
                ) : null;
            })
        );
    };

    return Checkbox;
}(_mixinUiState2.default), _class.displayName = 'Checkbox', _class.propTypes = {
    prefix: _propTypes2.default.string,
    rtl: _propTypes2.default.bool,
    /**
     * 自定义类名
     */
    className: _propTypes2.default.string,
    /**
     * checkbox id, 挂载在input上
     */
    id: _propTypes2.default.string,
    /**
     * 自定义内敛样式
     */
    style: _propTypes2.default.object,
    /**
     * 选中状态
     */
    checked: _propTypes2.default.bool,
    /**
     * 默认选中状态
     */
    defaultChecked: _propTypes2.default.bool,
    /**
     * 禁用
     */
    disabled: _propTypes2.default.bool,
    /**
     * 通过属性配置label，
     */
    label: _propTypes2.default.node,
    /**
     * Checkbox 的中间状态，只会影响到 Checkbox 的样式，并不影响其 checked 属性
     */
    indeterminate: _propTypes2.default.bool,
    /**
     *  Checkbox 的默认中间态，只会影响到 Checkbox 的样式，并不影响其 checked 属性
     */
    defaultIndeterminate: _propTypes2.default.bool,
    /**
     * 状态变化时触发的事件
     * @param {Boolean} checked 是否选中
     * @param {Event} e Dom 事件对象
     */
    onChange: _propTypes2.default.func,
    /**
     * 鼠标进入enter事件
     * @param {Event} e Dom 事件对象
     */
    onMouseEnter: _propTypes2.default.func,
    /**
     * 鼠标离开Leave事件
     * @param {Event} e Dom 事件对象
     */
    onMouseLeave: _propTypes2.default.func
}, _class.defaultProps = {
    defaultChecked: false,
    defaultIndeterminate: false,
    onChange: noop,
    onMouseEnter: noop,
    onMouseLeave: noop,
    prefix: 'next-'
}, _class.contextTypes = {
    onChange: _propTypes2.default.func,
    __group__: _propTypes2.default.bool,
    selectedValue: _propTypes2.default.array,
    disabled: _propTypes2.default.bool,
    prefix: _propTypes2.default.string
}, _temp);
exports.default = _configProvider2.default.config(Checkbox);
module.exports = exports['default'];

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var makeChain = _util.func.makeChain;
// UIState 为一些特殊元素的状态响应提供了标准的方式，
// 尤其适合CSS无法完全定制的控件，比如checkbox，radio等。
// 若组件 disable 则自行判断是否需要绑定状态管理。
// 注意：disable 不会触发事件，请使用resetUIState还原状态
/* eslint-disable react/prop-types */

var UIState = function (_Component) {
    _inherits(UIState, _Component);

    function UIState(props) {
        _classCallCheck(this, UIState);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        _this.state = {};
        ['_onUIFocus', '_onUIBlur'].forEach(function (item) {
            _this[item] = _this[item].bind(_this);
        });
        return _this;
    }
    // base 事件绑定的元素


    UIState.prototype.getStateElement = function getStateElement(base) {
        var _props = this.props,
            onFocus = _props.onFocus,
            onBlur = _props.onBlur;

        return _react2.default.cloneElement(base, {
            onFocus: makeChain(this._onUIFocus, onFocus),
            onBlur: makeChain(this._onUIBlur, onBlur)
        });
    };
    // 获取状态classname


    UIState.prototype.getStateClassName = function getStateClassName() {
        var focused = this.state.focused;

        return (0, _classnames2.default)({
            focused: focused
        });
    };
    // 复原状态


    UIState.prototype.resetUIState = function resetUIState() {
        this.setState({
            focused: false
        });
    };

    UIState.prototype._onUIFocus = function _onUIFocus() {
        this.setState({
            focused: true
        });
    };

    UIState.prototype._onUIBlur = function _onUIBlur() {
        this.setState({
            focused: false
        });
    };

    return UIState;
}(_react.Component);

UIState.displayName = 'UIState';
exports.default = UIState;
module.exports = exports['default'];

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _radio = __webpack_require__(62);

var _radio2 = _interopRequireDefault(_radio);

var _radioGroup = __webpack_require__(113);

var _radioGroup2 = _interopRequireDefault(_radioGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_radio2.default.Group = _radioGroup2.default;

exports.default = _radio2.default;
module.exports = exports['default'];

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames4 = __webpack_require__(3);

var _classnames5 = _interopRequireDefault(_classnames4);

var _mixinUiState = __webpack_require__(60);

var _mixinUiState2 = _interopRequireDefault(_mixinUiState);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var makeChain = _util.func.makeChain,
    noop = _util.func.noop;
/**
 * Radio
 * @order 1
 */

var Radio = (_temp = _class = function (_UIState) {
    _inherits(Radio, _UIState);

    function Radio(props, context) {
        _classCallCheck(this, Radio);

        var _this = _possibleConstructorReturn(this, _UIState.call(this, props));

        var checked = void 0;
        if (context.__group__) {
            checked = context.selectedValue === props.value;
        } else if ('checked' in props) {
            checked = props.checked;
        } else {
            checked = props.defaultChecked;
        }

        _this.state = { checked: checked };

        _this.onChange = _this.onChange.bind(_this);
        _this.disabled = props.disabled || context.__group__ && 'disabled' in context && context.disabled;

        return _this;
    }

    Radio.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
        if (nextContext.__group__) {
            var selectedValue = nextContext.selectedValue;

            if ('selectedValue' in nextContext) {
                this.setState({
                    checked: selectedValue === nextProps.value
                });
            }
        } else if ('checked' in nextProps) {
            this.setState({
                checked: nextProps.checked
            });
        }

        this.disabled = nextProps.disabled || nextContext.__group__ && 'disabled' in nextContext && nextContext.disabled;

        // when disabled, reset UIState
        if (this.disabled) {
            // only class has an impact, no effect on visual
            this.resetUIState();
        }
    };

    Radio.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState, nextContext) {
        var shallowEqual = _util.obj.shallowEqual;

        return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState) || !shallowEqual(this.nextContext, nextContext);
    };

    Radio.prototype.onChange = function onChange(e) {
        var checked = e.target.checked;
        var value = this.props.value;

        if (this.context.__group__) {
            this.context.onChange(value, e);
        } else if (this.state.checked !== checked) {
            if (!('checked' in this.props)) {
                this.setState({
                    checked: checked
                });
            }
            this.props.onChange(checked, e);
        }
    };

    Radio.prototype.render = function render() {
        var _classnames, _classnames2, _classnames3;

        /* eslint-disable no-unused-vars */
        var _props = this.props,
            id = _props.id,
            className = _props.className,
            children = _props.children,
            style = _props.style,
            label = _props.label,
            onMouseEnter = _props.onMouseEnter,
            onMouseLeave = _props.onMouseLeave,
            tabIndex = _props.tabIndex,
            rtl = _props.rtl,
            otherProps = _objectWithoutProperties(_props, ['id', 'className', 'children', 'style', 'label', 'onMouseEnter', 'onMouseLeave', 'tabIndex', 'rtl']);

        var checked = !!this.state.checked;
        var disabled = this.disabled;
        var isButton = this.context.isButton;
        var prefix = this.context.prefix || this.props.prefix;

        var others = _util.obj.pickOthers(Radio.propTypes, otherProps);
        var othersData = _util.obj.pickAttrsWith(others, 'data-');

        var input = _react2.default.createElement('input', _extends({}, _util.obj.pickOthers(othersData, others), {
            id: id,
            disabled: disabled,
            checked: checked,
            type: 'radio',
            onChange: this.onChange,
            'aria-checked': checked,
            className: prefix + 'radio-input'
        }));

        // disabled do not hove focus state
        if (!disabled) {
            input = this.getStateElement(input);
        }

        var cls = (0, _classnames5.default)((_classnames = {}, _classnames[prefix + 'radio'] = true, _classnames.checked = checked, _classnames.disabled = disabled, _classnames[this.getStateClassName()] = true, _classnames));
        var clsInner = (0, _classnames5.default)((_classnames2 = {}, _classnames2[prefix + 'radio-inner'] = true, _classnames2.press = checked, _classnames2.unpress = !checked, _classnames2));
        var clsWrapper = (0, _classnames5.default)((_classnames3 = {}, _classnames3[prefix + 'radio-wrapper'] = true, _classnames3[className] = !!className, _classnames3.checked = checked, _classnames3.disabled = disabled, _classnames3[this.getStateClassName()] = true, _classnames3));
        var childrenCls = prefix + 'radio-label';

        var radioComp = !isButton ? _react2.default.createElement(
            'span',
            { className: cls },
            _react2.default.createElement('span', { className: clsInner }),
            input
        ) : _react2.default.createElement(
            'span',
            { className: prefix + 'radio-single-input' },
            input
        );

        return _react2.default.createElement(
            'label',
            _extends({}, othersData, {
                role: 'radio',
                dir: rtl ? 'rtl' : 'ltr',
                style: style,
                tabIndex: tabIndex,
                'aria-checked': checked,
                'aria-disabled': disabled,
                className: clsWrapper,
                onMouseEnter: disabled ? onMouseEnter : makeChain(this._onUIMouseEnter, onMouseEnter),
                onMouseLeave: disabled ? onMouseLeave : makeChain(this._onUIMouseLeave, onMouseLeave)
            }),
            radioComp,
            [children, label].map(function (d, i) {
                return d !== undefined ? _react2.default.createElement(
                    'span',
                    { key: i, className: childrenCls },
                    d
                ) : null;
            })
        );
    };

    return Radio;
}(_mixinUiState2.default), _class.displayName = 'Radio', _class.propTypes = {
    prefix: _propTypes2.default.string,
    rtl: _propTypes2.default.bool,
    /**
     * 自定义类名
     */
    className: _propTypes2.default.string,
    /**
     * 组件input的id
     */
    id: _propTypes2.default.string,
    /**
     * 自定义内敛样式
     */
    style: _propTypes2.default.object,
    /**
     * 设置radio是否选中
     */
    checked: _propTypes2.default.bool,
    /**
     * 设置radio是否默认选中
     */
    defaultChecked: _propTypes2.default.bool,
    /**
     * 通过属性配置label
     */
    label: _propTypes2.default.node,
    /**
     * 状态变化时触发的事件
     * @param {Boolean} checked 是否选中
     * @param {Event} e Dom 事件对象
     */
    onChange: _propTypes2.default.func,
    /**
     * 鼠标进入enter事件
     * @param {Event} e Dom 事件对象
     */
    onMouseEnter: _propTypes2.default.func,
    /**
     * 鼠标离开事件
     * @param {Event} e Dom 事件对象
     */
    onMouseLeave: _propTypes2.default.func,
    /**
     * radio是否被禁用
     */
    disabled: _propTypes2.default.bool,
    /**
     * radio 的value
     */
    value: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number, _propTypes2.default.bool]),
    /**
     * name
     */
    name: _propTypes2.default.string
}, _class.defaultProps = {
    onChange: noop,
    onMouseLeave: noop,
    onMouseEnter: noop,
    tabIndex: 0,
    prefix: 'next-'
}, _class.contextTypes = {
    onChange: _propTypes2.default.func,
    __group__: _propTypes2.default.bool,
    isButton: _propTypes2.default.bool,
    selectedValue: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number, _propTypes2.default.bool]),
    disabled: _propTypes2.default.bool
}, _temp);
exports.default = _configProvider2.default.config(Radio);
module.exports = exports['default'];

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var Sort = (_temp2 = _class = function (_React$Component) {
    _inherits(Sort, _React$Component);

    function Sort() {
        var _temp, _this, _ret;

        _classCallCheck(this, Sort);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function () {
            var _this$props = _this.props,
                sort = _this$props.sort,
                dataIndex = _this$props.dataIndex;

            _this.onSort(dataIndex, sort[dataIndex] === 'desc' ? 'asc' : 'desc');
        }, _this.keydownHandler = function (e) {
            e.preventDefault();
            e.stopPropagation();

            if (e.keyCode === _util.KEYCODE.ENTER) {
                _this.handleClick();
            }
        }, _this.onSort = function (dataIndex, order) {
            var sort = {};
            sort[dataIndex] = order;

            _this.props.onSort(dataIndex, order, sort);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    // 渲染排序
    Sort.prototype.renderSort = function renderSort() {
        var _props = this.props,
            prefix = _props.prefix,
            sort = _props.sort,
            dataIndex = _props.dataIndex,
            locale = _props.locale,
            sortStatus = sort[dataIndex],
            map = {
            desc: 'descending',
            asc: 'ascending'
        };


        var icons = ['asc', 'desc'].map(function (sortOrder) {
            return _react2.default.createElement(
                'a',
                { href: 'javascript:;',
                    key: sortOrder,
                    className: sortStatus === sortOrder ? 'current' : '' },
                _react2.default.createElement(_icon2.default, { type: map[sortOrder], size: 'small' })
            );
        });

        return _react2.default.createElement(
            'span',
            { role: 'button',
                tabIndex: '0',
                'aria-label': locale[sortStatus],
                className: prefix + 'table-sort',
                onClick: this.handleClick.bind(this),
                onKeyDown: this.keydownHandler },
            icons
        );
    };

    Sort.prototype.render = function render() {
        return this.renderSort();
    };

    return Sort;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    className: _propTypes2.default.string,
    sort: _propTypes2.default.object,
    onSort: _propTypes2.default.func,
    dataIndex: _propTypes2.default.string,
    locale: _propTypes2.default.object
}, _class.defaultProps = {
    sort: {} }, _temp2);
Sort.displayName = 'Sort';
exports.default = Sort;
module.exports = exports['default'];

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _row = __webpack_require__(65);

var _row2 = _interopRequireDefault(_row);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var SelectionRow = (_temp = _class = function (_React$Component) {
    _inherits(SelectionRow, _React$Component);

    function SelectionRow() {
        _classCallCheck(this, SelectionRow);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    SelectionRow.prototype.render = function render() {
        var _classnames;

        /* eslint-disable no-unused-vars*/
        var _props = this.props,
            className = _props.className,
            record = _props.record,
            primaryKey = _props.primaryKey;
        var selectedRowKeys = this.context.selectedRowKeys;

        var cls = (0, _classnames3.default)((_classnames = {
            selected: selectedRowKeys.indexOf(record[primaryKey]) > -1
        }, _classnames[className] = className, _classnames));
        return _react2.default.createElement(_row2.default, _extends({}, this.props, { className: cls }));
    };

    return SelectionRow;
}(_react2.default.Component), _class.propTypes = _extends({}, _row2.default.propTypes), _class.defaultProps = _extends({}, _row2.default.defaultProps), _class.contextTypes = {
    selectedRowKeys: _propTypes2.default.array
}, _temp);
SelectionRow.displayName = 'SelectionRow';
exports.default = SelectionRow;
module.exports = exports['default'];

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

var _row = __webpack_require__(66);

var _row2 = _interopRequireDefault(_row);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var ExpandedRow = (_temp = _class = function (_React$Component) {
    _inherits(ExpandedRow, _React$Component);

    function ExpandedRow() {
        _classCallCheck(this, ExpandedRow);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    ExpandedRow.prototype.renderExpandedRow = function renderExpandedRow(record, index, colSpan) {
        var _context = this.context,
            expandedRowRender = _context.expandedRowRender,
            expandedRowIndent = _context.expandedRowIndent,
            openRowKeys = _context.openRowKeys,
            lockType = _context.lockType;
        var _props = this.props,
            columns = _props.columns,
            cellRef = _props.cellRef;

        if (expandedRowRender) {
            var _props2 = this.props,
                primaryKey = _props2.primaryKey,
                prefix = _props2.prefix,
                leftIndent = expandedRowIndent[0],
                rightIndent = expandedRowIndent[1],
                totalIndent = leftIndent + rightIndent,
                renderCols = function renderCols(number) {
                var ret = [];

                var _loop = function _loop(i) {
                    ret.push(_react2.default.createElement(
                        'td',
                        { key: i, ref: function ref(cell) {
                                return cellRef(index, i, cell);
                            } },
                        '\xA0'
                    ));
                };

                for (var i = 0; i < number; i++) {
                    _loop(i);
                }
                return ret;
            };

            var content = void 0;

            if (totalIndent > colSpan && !lockType) {
                _util.log.warning('It\'s not allowed expandedRowIndent is more than the number of columns.');
            }
            if (leftIndent < columns.length && lockType === 'left') {
                _util.log.warning('expandedRowIndent left is less than the number of left lock columns.');
            }
            if (rightIndent < columns.length && lockType === 'right') {
                _util.log.warning('expandedRowIndent right is less than the number of right lock columns.');
            }
            if (lockType) {
                return openRowKeys.indexOf(record[primaryKey]) > -1 ? _react2.default.createElement(
                    'tr',
                    { className: prefix + 'table-expanded-row', key: 'expanded-' + index },
                    _react2.default.createElement(
                        'td',
                        { colSpan: colSpan, ref: function ref(cell) {
                                return cellRef(index, 0, cell);
                            } },
                        '\xA0'
                    )
                ) : null;
            }
            content = expandedRowRender(record, index);
            if (!_react2.default.isValidElement(content)) {
                content = _react2.default.createElement(
                    'div',
                    { className: prefix + 'table-cell-wrapper' },
                    content
                );
            }
            return openRowKeys.indexOf(record[primaryKey]) > -1 ? _react2.default.createElement(
                'tr',
                { className: prefix + 'table-expanded-row', key: 'expanded-' + (record[primaryKey] || index) },
                renderCols(leftIndent),
                _react2.default.createElement(
                    'td',
                    { colSpan: colSpan - totalIndent },
                    content
                ),
                renderCols(rightIndent)
            ) : null;
        } else {
            return null;
        }
    };

    ExpandedRow.prototype.render = function render() {
        /* eslint-disable no-unused-vars*/
        var _props3 = this.props,
            record = _props3.record,
            rowIndex = _props3.rowIndex,
            columns = _props3.columns;

        if (record.__expanded) {
            return this.renderExpandedRow(record, rowIndex, columns.length);
        }
        return _react2.default.createElement(_row2.default, this.props);
    };

    return ExpandedRow;
}(_react2.default.Component), _class.propTypes = _extends({}, _row2.default.propTypes), _class.defaultProps = _extends({}, _row2.default.defaultProps), _class.contextTypes = {
    openRowKeys: _propTypes2.default.array,
    expandedRowRender: _propTypes2.default.func,
    expandedRowIndent: _propTypes2.default.array,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}, _temp);
ExpandedRow.displayName = 'ExpandedRow';
exports.default = ExpandedRow;
module.exports = exports['default'];

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _row = __webpack_require__(17);

var _row2 = _interopRequireDefault(_row);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var LockRow = (_temp2 = _class = function (_React$Component) {
    _inherits(LockRow, _React$Component);

    function LockRow() {
        var _temp, _this, _ret;

        _classCallCheck(this, LockRow);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onMouseEnter = function (record, index, e) {
            var onRowMouseEnter = _this.context.onRowMouseEnter;
            var onMouseEnter = _this.props.onMouseEnter;

            onRowMouseEnter && onRowMouseEnter(record, index, e);
            onMouseEnter(record, index, e);
        }, _this.onMouseLeave = function (record, index, e) {
            var onRowMouseLeave = _this.context.onRowMouseLeave;
            var onMouseLeave = _this.props.onMouseLeave;

            onRowMouseLeave && onRowMouseLeave(record, index, e);
            onMouseLeave(record, index, e);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    LockRow.prototype.render = function render() {
        /* eslint-disable no-unused-vars*/
        return _react2.default.createElement(_row2.default, _extends({}, this.props, { onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave }));
    };

    return LockRow;
}(_react2.default.Component), _class.propTypes = _extends({}, _row2.default.propTypes), _class.contextTypes = {
    onRowMouseEnter: _propTypes2.default.func,
    onRowMouseLeave: _propTypes2.default.func
}, _class.defaultProps = _extends({}, _row2.default.defaultProps), _temp2);
LockRow.displayName = 'LockRow';
exports.default = LockRow;
module.exports = exports['default'];

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _body = __webpack_require__(16);

var _body2 = _interopRequireDefault(_body);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var FixedBody = (_temp2 = _class = function (_React$Component) {
    _inherits(FixedBody, _React$Component);

    function FixedBody() {
        var _temp, _this, _ret;

        _classCallCheck(this, FixedBody);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onBodyScroll = function () {
            var onBodyScroll = _this.context.onBodyScroll;

            onBodyScroll && onBodyScroll();
            _this.props.onScroll();
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    FixedBody.prototype.componentDidMount = function componentDidMount() {
        var getNode = this.context.getNode;

        getNode && getNode('body', (0, _reactDom.findDOMNode)(this));
    };

    FixedBody.prototype.render = function render() {
        var _props = this.props,
            className = _props.className,
            colGroup = _props.colGroup,
            others = _objectWithoutProperties(_props, ['className', 'colGroup']);

        var _context = this.context,
            maxBodyHeight = _context.maxBodyHeight,
            fixedHeader = _context.fixedHeader;

        var style = {};
        if (fixedHeader) {
            style.maxHeight = maxBodyHeight;
        }
        return _react2.default.createElement(
            'div',
            { style: style, className: className, onScroll: this.onBodyScroll },
            _react2.default.createElement(
                'table',
                null,
                colGroup,
                _react2.default.createElement(_body2.default, _extends({}, others, { colGroup: colGroup }))
            )
        );
    };

    return FixedBody;
}(_react2.default.Component), _class.propTypes = {
    children: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    className: _propTypes2.default.string,
    colGroup: _propTypes2.default.any,
    onScroll: _propTypes2.default.func
}, _class.defaultProps = {
    onScroll: function onScroll() {}
}, _class.contextTypes = {
    fixedHeader: _propTypes2.default.bool,
    maxBodyHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    onBodyScroll: _propTypes2.default.func,
    getNode: _propTypes2.default.func
}, _temp2);
FixedBody.displayName = 'FixedBody';
exports.default = FixedBody;
module.exports = exports['default'];

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Table.GroupHeader
 * @order 2
 **/
var ListHeader = (_temp = _class = function (_React$Component) {
  _inherits(ListHeader, _React$Component);

  function ListHeader() {
    _classCallCheck(this, ListHeader);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  ListHeader.prototype.render = function render() {
    return null;
  };

  return ListHeader;
}(_react2.default.Component), _class.propTypes = {
  /**
   * 行渲染的逻辑
   */
  cell: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.node, _propTypes2.default.func]),
  /**
   * 是否在Children上面渲染selection
   */
  hasChildrenSelection: _propTypes2.default.bool,
  /**
   * 是否在GroupHeader上面渲染selection
   */
  hasSelection: _propTypes2.default.bool
}, _class.defaultProps = {
  cell: function cell() {
    return '';
  },
  hasSelection: true,
  hasChildrenSelection: false
}, _class._typeMark = 'listHeader', _temp);
ListHeader.displayName = 'ListHeader';
exports.default = ListHeader;
module.exports = exports['default'];

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Table.GroupFooter
 * @order 3
 **/
var ListFooter = (_temp = _class = function (_React$Component) {
    _inherits(ListFooter, _React$Component);

    function ListFooter() {
        _classCallCheck(this, ListFooter);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    ListFooter.prototype.render = function render() {
        return null;
    };

    return ListFooter;
}(_react2.default.Component), _class.propTypes = {
    /**
     * 行渲染的逻辑
     */
    cell: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.node, _propTypes2.default.func])
}, _class.defaultProps = {
    cell: function cell() {
        return '';
    }
}, _class._typeMark = 'listFooter', _temp);
ListFooter.displayName = 'ListFooter';
exports.default = ListFooter;
module.exports = exports['default'];

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(12);

__webpack_require__(146);

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _button = __webpack_require__(118);

var _button2 = _interopRequireDefault(_button);

var _group = __webpack_require__(119);

var _group2 = _interopRequireDefault(_group);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

_button2.default.Group = _group2.default;

exports.default = _configProvider2.default.config(_button2.default, {
    transform: function transform(props, deprecated) {
        if ('shape' in props) {
            deprecated('shape', 'text | warning | ghost', 'Button');

            var _props = props,
                shape = _props.shape,
                type = _props.type,
                others = _objectWithoutProperties(_props, ['shape', 'type']);

            var newType = type;
            if (type === 'light' || type === 'dark' || type === 'secondary' && shape === 'warning') {
                newType = 'normal';
            }

            var ghost = void 0;
            if (shape === 'ghost') {
                ghost = {
                    primary: 'dark',
                    secondary: 'dark',
                    normal: 'light',
                    dark: 'dark',
                    light: 'light'
                }[type || _button2.default.defaultProps.type];
            }

            var text = shape === 'text';
            var warning = shape === 'warning';

            props = _extends({ type: newType, ghost: ghost, text: text, warning: warning }, others);
        }

        return props;
    }
});
module.exports = exports['default'];

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(11);

__webpack_require__(148);

/***/ }),
/* 73 */,
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _animate = __webpack_require__(51);

var _animate2 = _interopRequireDefault(_animate);

var _expand = __webpack_require__(110);

var _expand2 = _interopRequireDefault(_expand);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_animate2.default.Expand = _expand2.default;

exports.default = _animate2.default;
module.exports = exports['default'];

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _overlay = __webpack_require__(15);

var _overlay2 = _interopRequireDefault(_overlay);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/** Loading */
var Loading = (_temp = _class = function (_React$Component) {
    _inherits(Loading, _React$Component);

    function Loading() {
        _classCallCheck(this, Loading);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    Loading.prototype.render = function render() {
        var _classNames2, _classNames3, _classNames4;

        var _props = this.props,
            tip = _props.tip,
            visible = _props.visible,
            children = _props.children,
            className = _props.className,
            style = _props.style,
            indicator = _props.indicator,
            color = _props.color,
            prefix = _props.prefix,
            fullScreen = _props.fullScreen,
            onVisibleChange = _props.onVisibleChange,
            tipAlign = _props.tipAlign,
            size = _props.size;


        var indicatorDom = null;
        var dotCls = prefix + 'loading-dot';

        if (indicator) {
            indicatorDom = indicator;
        } else {
            var _classNames;

            var backgroundColor = color;
            var fusionReactorCls = (0, _classnames2.default)((_classNames = {}, _classNames[prefix + 'loading-fusion-reactor'] = true, _classNames[prefix + 'loading-medium-fusion-reactor'] = size === 'medium', _classNames));
            indicatorDom = _react2.default.createElement(
                'div',
                { className: fusionReactorCls },
                _react2.default.createElement('span', { className: dotCls, style: { backgroundColor: backgroundColor } }),
                _react2.default.createElement('span', { className: dotCls, style: { backgroundColor: backgroundColor } }),
                _react2.default.createElement('span', { className: dotCls, style: { backgroundColor: backgroundColor } }),
                _react2.default.createElement('span', { className: dotCls, style: { backgroundColor: backgroundColor } })
            );
        }

        var loadingCls = (0, _classnames2.default)((_classNames2 = {}, _classNames2[prefix + 'loading'] = true, _classNames2[prefix + 'open'] = visible, _classNames2[className] = className, _classNames2));

        var tipCls = (0, _classnames2.default)((_classNames3 = {}, _classNames3[prefix + 'loading-tip'] = true, _classNames3[prefix + 'loading-right-tip'] = tipAlign === 'right', _classNames3));

        var others = _util.obj.pickOthers(Loading.propTypes, this.props);

        var contentCls = (0, _classnames2.default)((_classNames4 = {}, _classNames4[prefix + 'loading-component'] = visible, _classNames4[prefix + 'loading-wrap'] = true, _classNames4));

        return fullScreen ? [children, _react2.default.createElement(
            _overlay2.default,
            _extends({ key: 'overlay', hasMask: true, align: 'cc cc' }, others, {
                className: className,
                style: style,
                visible: visible,
                onRequestClose: onVisibleChange }),
            _react2.default.createElement(
                'div',
                { className: tipCls },
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'loading-indicator' },
                    indicatorDom
                ),
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'loading-tip-content' },
                    tip
                ),
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'loading-tip-placeholder' },
                    tip
                )
            )
        )] : _react2.default.createElement(
            'div',
            _extends({ className: loadingCls, style: style }, others),
            visible ? _react2.default.createElement(
                'div',
                { className: tipCls },
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'loading-indicator' },
                    indicatorDom
                ),
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'loading-tip-content' },
                    tip
                ),
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'loading-tip-placeholder' },
                    tip
                )
            ) : null,
            _react2.default.createElement(
                'div',
                { className: contentCls },
                visible ? _react2.default.createElement('div', { className: prefix + 'loading-masker' }) : null,
                children
            )
        );
    };

    return Loading;
}(_react2.default.Component), _class.propTypes = {
    /**
     * 样式前缀
     */
    prefix: _propTypes2.default.string,
    /**
     * 自定义内容
     */
    tip: _propTypes2.default.any,
    /**
     * 自定义内容位置
     * @enumdesc 出现在动画右边, 出现在动画下面
     */
    tipAlign: _propTypes2.default.oneOf(['right', 'bottom']),
    /**
     * loading 状态, 默认 true
     */
    visible: _propTypes2.default.bool,
    onVisibleChange: _propTypes2.default.func,
    /**
     * 自定义class
     */
    className: _propTypes2.default.string,
    /**
     * 自定义内联样式
     */
    style: _propTypes2.default.object,
    /**
     * 设置动画尺寸
     * @description 仅仅对默认动画效果起作用
     * @enumdesc 大号, 中号
     */
    size: _propTypes2.default.oneOf(['large', 'medium']),
    /**
     * 自定义动画
     */
    indicator: _propTypes2.default.any,
    /**
     * 动画颜色
     */
    color: _propTypes2.default.string,
    /**
     * 全屏展示
     */
    fullScreen: _propTypes2.default.bool,
    /**
     * 子元素
     */
    children: _propTypes2.default.any
}, _class.defaultProps = {
    prefix: 'next-',
    visible: true,
    onVisibleChange: _util.func.noop,
    animate: null,
    tipAlign: 'bottom',
    size: 'large'
}, _temp);
Loading.displayName = 'Loading';
exports.default = _configProvider2.default.config(Loading);
module.exports = exports['default'];

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _menu = __webpack_require__(50);

var _menu2 = _interopRequireDefault(_menu);

var _subMenu = __webpack_require__(101);

var _subMenu2 = _interopRequireDefault(_subMenu);

var _selectableItem = __webpack_require__(22);

var _selectableItem2 = _interopRequireDefault(_selectableItem);

var _checkboxItem = __webpack_require__(111);

var _checkboxItem2 = _interopRequireDefault(_checkboxItem);

var _radioItem = __webpack_require__(114);

var _radioItem2 = _interopRequireDefault(_radioItem);

var _popupItem = __webpack_require__(57);

var _popupItem2 = _interopRequireDefault(_popupItem);

var _group = __webpack_require__(115);

var _group2 = _interopRequireDefault(_group);

var _divider = __webpack_require__(116);

var _divider2 = _interopRequireDefault(_divider);

var _create = __webpack_require__(117);

var _create2 = _interopRequireDefault(_create);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

_menu2.default.SubMenu = _subMenu2.default;
_menu2.default.Item = _selectableItem2.default;
_menu2.default.CheckboxItem = _checkboxItem2.default;
_menu2.default.RadioItem = _radioItem2.default;
_menu2.default.PopupItem = _popupItem2.default;
_menu2.default.Group = _group2.default;
_menu2.default.Divider = _divider2.default;
_menu2.default.create = _create2.default;

/* istanbul ignore next */
var transform = function transform(props, deprecated) {
    if ('indentSize' in props) {
        deprecated('indentSize', 'inlineIndent', 'Menu');

        var _props = props,
            indentSize = _props.indentSize,
            others = _objectWithoutProperties(_props, ['indentSize']);

        props = _extends({ inlineIndent: indentSize }, others);
    }

    if ('onDeselect' in props) {
        deprecated('onDeselect', 'onSelect', 'Menu');
        if (props.onDeselect) {
            var _props2 = props,
                onDeselect = _props2.onDeselect,
                onSelect = _props2.onSelect,
                _others = _objectWithoutProperties(_props2, ['onDeselect', 'onSelect']);

            var newOnSelect = function newOnSelect(selectedKeys, item, extra) {
                if (!extra.select) {
                    onDeselect(extra.key);
                }
                if (onSelect) {
                    onSelect(selectedKeys, item, extra);
                }
            };

            props = _extends({ onSelect: newOnSelect }, _others);
        }
    }

    return props;
};

exports.default = _configProvider2.default.config(_menu2.default, {
    transform: transform
});
module.exports = exports['default'];

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(11);

__webpack_require__(12);

__webpack_require__(70);

__webpack_require__(38);

__webpack_require__(147);

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(11);

__webpack_require__(12);

__webpack_require__(36);

__webpack_require__(152);

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _base = __webpack_require__(95);

var _base2 = _interopRequireDefault(_base);

var _tree = __webpack_require__(123);

var _tree2 = _interopRequireDefault(_tree);

var _fixed = __webpack_require__(126);

var _fixed2 = _interopRequireDefault(_fixed);

var _selection = __webpack_require__(127);

var _selection2 = _interopRequireDefault(_selection);

var _expanded = __webpack_require__(128);

var _expanded2 = _interopRequireDefault(_expanded);

var _virtual = __webpack_require__(129);

var _virtual2 = _interopRequireDefault(_virtual);

var _lock = __webpack_require__(131);

var _lock2 = _interopRequireDefault(_lock);

var _list = __webpack_require__(134);

var _list2 = _interopRequireDefault(_list);

var _sticky = __webpack_require__(137);

var _sticky2 = _interopRequireDefault(_sticky);

var _listHeader = __webpack_require__(68);

var _listHeader2 = _interopRequireDefault(_listHeader);

var _listFooter = __webpack_require__(69);

var _listFooter2 = _interopRequireDefault(_listFooter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var ORDER_LIST = [_fixed2.default, _lock2.default, _selection2.default, _expanded2.default, _tree2.default, _virtual2.default, _list2.default, _sticky2.default];
var Table = ORDER_LIST.reduce(function (ret, current) {
    ret = current(ret);
    return ret;
}, _base2.default);
Table.Base = _base2.default;
Table.fixed = _fixed2.default;
Table.lock = _lock2.default;
Table.selection = _selection2.default;
Table.expanded = _expanded2.default;
Table.tree = _tree2.default;
Table.virtual = _virtual2.default;
Table.list = _list2.default;
Table.sticky = _sticky2.default;

Table.GroupHeader = _listHeader2.default;
Table.GroupFooter = _listFooter2.default;

exports.default = _configProvider2.default.config(Table, {
    componentName: 'Table',
    transform: function transform(props, deprecated) {
        if ('expandedRowKeys' in props) {
            deprecated('expandedRowKeys', 'openRowKeys', 'Table');

            var _props = props,
                expandedRowKeys = _props.expandedRowKeys,
                others = _objectWithoutProperties(_props, ['expandedRowKeys']);

            props = _extends({ openRowKeys: expandedRowKeys }, others);
        }
        if ('onExpandedChange' in props) {
            deprecated('onExpandedChange', 'onRowOpen', 'Table');

            var _props2 = props,
                onExpandedChange = _props2.onExpandedChange,
                _others = _objectWithoutProperties(_props2, ['onExpandedChange']);

            props = _extends({ onRowOpen: onExpandedChange }, _others);
        }
        if ('isLoading' in props) {
            deprecated('isLoading', 'loading', 'Table');

            var _props3 = props,
                isLoading = _props3.isLoading,
                _others2 = _objectWithoutProperties(_props3, ['isLoading']);

            props = _extends({ loading: isLoading }, _others2);
        }
        if ('indentSize' in props) {
            deprecated('indentSize', 'indent', 'Table');

            var _props4 = props,
                indentSize = _props4.indentSize,
                _others3 = _objectWithoutProperties(_props4, ['indentSize']);

            props = _extends({ indent: indentSize }, _others3);
        }
        if ('optimization' in props) {
            deprecated('optimization', 'pure', 'Table');

            var _props5 = props,
                optimization = _props5.optimization,
                _others4 = _objectWithoutProperties(_props5, ['optimization']);

            props = _extends({ pure: optimization }, _others4);
        }
        if ('getRowClassName' in props) {
            deprecated('getRowClassName', 'getRowProps', 'Table');

            var _props6 = props,
                getRowClassName = _props6.getRowClassName,
                getRowProps = _props6.getRowProps,
                _others5 = _objectWithoutProperties(_props6, ['getRowClassName', 'getRowProps']);

            if (getRowClassName) {
                var newGetRowProps = function newGetRowProps() {
                    return _extends({
                        className: getRowClassName.apply(undefined, arguments)
                    }, getRowProps ? getRowProps.apply(undefined, arguments) : {});
                };

                props = _extends({ getRowProps: newGetRowProps }, _others5);
            } else {
                props = _extends({ getRowProps: getRowProps }, _others5);
            }
        }

        return props;
    }
});
module.exports = exports['default'];

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var assign = __webpack_require__(81);

var ReactPropTypesSecret = __webpack_require__(20);
var checkPropTypes = __webpack_require__(82);

var printWarning = function printWarning() {};

if (process.env.NODE_ENV !== 'production') {
  printWarning = function printWarning(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function (isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
          err.name = 'Invariant Violation';
          throw err;
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (!manualPropTypeCallCache[cacheKey] &&
          // Avoid spamming the console because they are often not actionable except for lib authors
          manualPropTypeWarningCount < 3) {
            printWarning('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(_extends({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var printWarning = function printWarning() {};

if (process.env.NODE_ENV !== 'production') {
  var ReactPropTypesSecret = __webpack_require__(20);
  var loggedTypeFailures = {};

  printWarning = function printWarning(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + _typeof(typeSpecs[typeSpecName]) + '`.');
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + (typeof error === 'undefined' ? 'undefined' : _typeof(error)) + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
        }
      }
    }
  }
}

module.exports = checkPropTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__(20);

function emptyFunction() {}

module.exports = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.initLocales = initLocales;
exports.setLanguage = setLanguage;
exports.setLocale = setLocale;
exports.setDirection = setDirection;
exports.getLocale = getLocale;
exports.getLanguage = getLanguage;
exports.getDirection = getDirection;
exports.config = config;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _hoistNonReactStatics = __webpack_require__(85);

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _util = __webpack_require__(2);

var _getContextProps = __webpack_require__(39);

var _getContextProps2 = _interopRequireDefault(_getContextProps);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var shallowEqual = _util.obj.shallowEqual;


function getDisplayName(Component) {
    return Component.displayName || Component.name || 'Component';
}

var globalLocales = void 0;
var currentGlobalLanguage = 'zh-cn';
var currentGlobalLocale = {};
var currentGlobalRtl = false;

function initLocales(locales) {
    globalLocales = locales;
    currentGlobalLocale = locales[currentGlobalLanguage];
}

function setLanguage(language) {
    if (globalLocales) {
        currentGlobalLanguage = language;
        currentGlobalLocale = globalLocales[language];
    }
}

function setLocale(locale) {
    currentGlobalLocale = _extends({}, globalLocales ? globalLocales[currentGlobalLanguage] : {}, locale);
}

function setDirection(dir) {
    currentGlobalRtl = dir === 'rtl';
}

function getLocale() {
    return currentGlobalLocale;
}

function getLanguage() {
    return currentGlobalLanguage;
}

function getDirection() {
    return currentGlobalRtl;
}

function config(Component) {
    var _class, _temp;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (Component.prototype.shouldComponentUpdate === undefined) {
        Component.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
            if (this.props.pure) {
                return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);
            }

            return true;
        };
    }

    var ConfigedComponent = (_temp = _class = function (_React$Component) {
        _inherits(ConfigedComponent, _React$Component);

        function ConfigedComponent(props, context) {
            _classCallCheck(this, ConfigedComponent);

            var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

            _this._getInstance = _this._getInstance.bind(_this);
            _this._deprecated = _this._deprecated.bind(_this);
            return _this;
        }

        ConfigedComponent.prototype._getInstance = function _getInstance(ref) {
            var _this2 = this;

            this._instance = ref;

            if (this._instance && options.exportNames) {
                options.exportNames.forEach(function (name) {
                    var field = _this2._instance[name];
                    if (typeof field === 'function') {
                        _this2[name] = field.bind(_this2._instance);
                    } else {
                        _this2[name] = field;
                    }
                });
            }
        };

        ConfigedComponent.prototype._deprecated = function _deprecated() {
            if (this.context.nextWarning !== false) {
                _util.log.deprecated.apply(_util.log, arguments);
            }
        };

        ConfigedComponent.prototype.getInstance = function getInstance() {
            return this._instance;
        };

        ConfigedComponent.prototype.render = function render() {
            var _props = this.props,
                prefix = _props.prefix,
                locale = _props.locale,
                pure = _props.pure,
                rtl = _props.rtl,
                others = _objectWithoutProperties(_props, ['prefix', 'locale', 'pure', 'rtl']);

            var _context = this.context,
                nextPrefix = _context.nextPrefix,
                _context$nextLocale = _context.nextLocale,
                nextLocale = _context$nextLocale === undefined ? {} : _context$nextLocale,
                nextPure = _context.nextPure,
                nextRtl = _context.nextRtl;


            var displayName = options.componentName || getDisplayName(Component);
            var contextProps = (0, _getContextProps2.default)({ prefix: prefix, locale: locale, pure: pure, rtl: rtl }, {
                nextPrefix: nextPrefix,
                nextLocale: _extends({}, currentGlobalLocale, nextLocale),
                nextPure: nextPure,
                nextRtl: typeof nextRtl === 'boolean' ? nextRtl : currentGlobalRtl === true ? true : undefined
            }, displayName);

            var newContextProps = ['prefix', 'locale', 'pure', 'rtl'].reduce(function (ret, name) {
                if (typeof contextProps[name] !== 'undefined') {
                    ret[name] = contextProps[name];
                }
                return ret;
            }, {});

            var newOthers = options.transform ? options.transform(others, this._deprecated) : others;

            return _react2.default.createElement(Component, _extends({}, newOthers, newContextProps, {
                ref: this._getInstance
            }));
        };

        return ConfigedComponent;
    }(_react2.default.Component), _class.propTypes = _extends({}, Component.propTypes || {}, {
        prefix: _propTypes2.default.string,
        locale: _propTypes2.default.object,
        pure: _propTypes2.default.bool,
        rtl: _propTypes2.default.bool
    }), _class.contextTypes = _extends({}, Component.contextTypes || {}, {
        nextPrefix: _propTypes2.default.string,
        nextLocale: _propTypes2.default.object,
        nextPure: _propTypes2.default.bool,
        nextRtl: _propTypes2.default.bool,
        nextWarning: _propTypes2.default.bool
    }), _temp);
    ConfigedComponent.displayName = 'ConfigedComponent';


    ConfigedComponent.displayName = 'Config(' + getDisplayName(Component) + ')';

    (0, _hoistNonReactStatics2.default)(ConfigedComponent, Component);

    return ConfigedComponent;
}

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
        // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
}

module.exports = hoistNonReactStatics;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.on = on;
exports.once = once;
/**
 * 取消事件绑定
 * @param  {*}   node       DOM节点或任何可以绑定事件的对象
 * @param  {String}   eventName  事件名
 * @param  {Function} callback   回调方法
 * @param  {Boolean}   [useCapture=false] 是否开启事件捕获优先
 */
function _off(node, eventName, callback, useCapture) {
    /* istanbul ignore else */
    if (node.removeEventListener) {
        node.removeEventListener(eventName, callback, useCapture || false);
    }
}

/**
 * 绑定事件
 * @param  {*}   node       DOM节点或任何可以绑定事件的对象
 * @param  {String}   eventName  事件名
 * @param  {Function} callback   回调方法
 * @param  {Boolean}   useCapture 是否开启事件捕获优先
 * @return {Object}               返回的object中包含一个off方法，用于取消事件监听
 *
 * @example
 * const handler = events.on(document.body, 'click', e => {
 *     // handle click ...
 * });
 * // 取消事件绑定
 * handler.off();
 */
exports.off = _off;
function on(node, eventName, callback, useCapture) {
    /* istanbul ignore else */
    if (node.addEventListener) {
        node.addEventListener(eventName, callback, useCapture || false);
    }

    return {
        off: function off() {
            return _off(node, eventName, callback, useCapture);
        }
    };
}

/**
 * 绑定事件，只执行一次后销毁
 * @param  {*}   node       DOM节点或任何可以绑定事件的对象
 * @param  {String}   eventName  事件名
 * @param  {Function} callback   回调方法
 * @param  {Boolean}   useCapture 是否开启事件捕获优先
 * @return {Function}             返回的object中包含一个off方法，用于取消事件监听
 */
function once(node, eventName, callback, useCapture) {
    return on(node, eventName, function __fn() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        callback.apply(this, args);

        // 由于addEventListener中的参数options只在Chrome 55、Firefox(Gecko)以上版本支持，故还是用传统的方法实现once
        _off(node, eventName, __fn, useCapture);
    }, useCapture);
}

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.noop = undefined;
exports.makeChain = makeChain;
exports.bindCtx = bindCtx;
exports.promiseCall = promiseCall;

var _object = __webpack_require__(13);

/**
 * 一个空方法，返回入参本身或空对象
 */
var noop = exports.noop = function noop() {};

/**
 * 将N个方法合并为一个链式调用的方法
 * @return {Function}     合并后的方法
 * 参考 https://github.com/react-component/util/
 *
 * @example
 * func.makeChain(this.handleChange, this.props.onChange);
 */
function makeChain() {
    for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
        fns[_key] = arguments[_key];
    }

    if (fns.length === 1) {
        return fns[0];
    }

    return function chainedFunction() {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
        }

        for (var i = 0, j = fns.length; i < j; i++) {
            if (fns[i] && fns[i].apply) {
                fns[i].apply(this, args);
            }
        }
    };
}

/**
 * 批量改变方法的上下文
 * 此方法在react组件中很有用，在constructor中批量将组件上的方法执行上下文绑定到组件本身
 * 注意：用bind改变函数运行的上下文只会生效一次
 * @param  {Object} ctx 方法挂载的对象以及执行的上下文
 * @param  {Array<String>} fns 方法名列表
 *
 * @example
 * func.bindCtx(this, ['handleClick', 'handleChange']);
 */
function bindCtx(ctx, fns, ns) {
    if (typeof fns === 'string') {
        fns = [fns];
    }

    // 方法的挂载空间，如果不传，默认与ctx相同
    ns = ns || ctx;

    fns.forEach(function (fnName) {
        // 这里不要添加空方法判断，由调用者保证正确性，否则出了问题无法排查
        ns[fnName] = ns[fnName].bind(ctx);
    });
}

/**
 * 用于执行回调方法后的逻辑
 * @param  {*} ret            回调方法执行结果
 * @param  {Function} success 执行结果返回非false的回调
 * @param  {Function} [failure=noop] 执行结果返回false的回调
 */
function promiseCall(ret, success) {
    var failure = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

    if ((0, _object.isPromise)(ret)) {
        return ret.then(function (result) {
            success(result);
            return result;
        }).catch(function (e) {
            failure(e);
            // throw e;
        });
    }

    return ret !== false ? success(ret) : failure(ret);
}

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.deprecated = deprecated;
exports.warning = warning;

var _env = __webpack_require__(42);

/* eslint no-console: 0 */

/**
 * 反对使用某一方法或属性的警告
 * @param  {String} props     过时的属性或方法名
 * @param  {String} instead   替代的属性或方法名
 * @param  {String} component 组件名
 *
 * @example
 * log.deprecated('onBeforeClose', 'beforeClose', 'Dialog');
 * // Warning: onBeforeClose is deprecated at [ Dialog ], use [ beforeClose ] instead of it.
 */
function deprecated(props, instead, component) {
    /* istanbul ignore else */
    if (!(0, _env.isProduction)() && typeof console !== 'undefined' && console.error) {
        return console.error('Warning: [ ' + props + ' ] is deprecated at [ ' + component + ' ], ' + ('use [ ' + instead + ' ] instead of it.'));
    }
}

/**
 * 控制台警告日志
 * @param  {String} msg
 */
function warning(msg) {
    /* istanbul ignore else */
    if (typeof console !== 'undefined' && console.error) {
        return console.error('Warning: ' + msg);
    }
}

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.flex = exports.transition = exports.animation = undefined;

var _dom = __webpack_require__(40);

var _object = __webpack_require__(13);

var animationEndEventNames = {
    WebkitAnimation: 'webkitAnimationEnd',
    OAnimation: 'oAnimationEnd',
    animation: 'animationend'
};

var transitionEventNames = {
    WebkitTransition: 'webkitTransitionEnd',
    OTransition: 'oTransitionEnd',
    transition: 'transitionend'
};

/**
 * 是否支持某些动效事件，如果支持，返回相应的end事件名
 * @private
 * @param  {Object<String>} names
 * @return {Object|false}
 */
function _supportEnd(names) {
    /* istanbul ignore if */
    if (!_dom.hasDOM) {
        return false;
    }

    var el = document.createElement('div');
    var ret = false;

    (0, _object.each)(names, function (val, key) {
        /* istanbul ignore else */
        if (el.style[key] !== undefined) {
            ret = { end: val };
            return false;
        }
    });

    return ret;
}

/**
 * 是否支持某些CSS属性
 * @private
 * @param  {Object<Array<String>>} names
 * @return {Boolean}       is support
 */
function _supportCSS(names) {
    /* istanbul ignore if */
    if (!_dom.hasDOM) {
        return false;
    }

    var el = document.createElement('div');
    var ret = false;

    (0, _object.each)(names, function (val, key) {
        (0, _object.each)(val, function (item) {
            try {
                el.style[key] = item;
                ret = ret || el.style[key] === item;
            } catch (e) {
                // It will be throw error when set unknown property under IE8
            }
            return !ret; // 如果有一个支持就返回false，后面不需要再判断
        });

        return !ret;
    });

    return ret;
}

/**
 * 是否支持animation以及动画结束事件名
 * @type {Object|false}
 * @property {String} end 动画结束事件名
 */
var animation = exports.animation = _supportEnd(animationEndEventNames);

/**
 * 是否支持transition以及过滤效果结束事件名
 * @type {Object|false}
 * @property {String} end 过渡效果结束事件名
 */
var transition = exports.transition = _supportEnd(transitionEventNames);

/**
 * 是否支持flex属性
 * @type {Boolean}
 */
var flex = exports.flex = _supportCSS({
    display: ['flex', '-webkit-flex', '-moz-flex', '-ms-flexbox']
});

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getFocusNodeList = getFocusNodeList;
exports.saveLastFocusNode = saveLastFocusNode;
exports.clearLastFocusNode = clearLastFocusNode;
exports.backLastFocusNode = backLastFocusNode;
exports.limitTabRange = limitTabRange;

var _keycode = __webpack_require__(43);

var _keycode2 = _interopRequireDefault(_keycode);

var _object = __webpack_require__(13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 用于切换页面元素的焦点
 */

/**
 * 元素是否可见
 * @private
 * @param   {Element}  node
 * @return  {Boolean}
 */
function _isVisible(node) {
    while (node) {
        if (node === document.body || node === document.documentElement) {
            break;
        }
        if (node.style.display === 'none' || node.style.visibility === 'hidden') {
            return false;
        }
        node = node.parentNode;
    }
    return true;
}

/**
 * 元素是否可以获取焦点
 * @private
 * @param   {Element}  node
 * @return  {Boolean}
 */
function _isFocusable(node) {
    var nodeName = node.nodeName.toLowerCase();
    var tabIndex = parseInt(node.getAttribute('tabindex'), 10);
    var hasTabIndex = !isNaN(tabIndex) && tabIndex > -1;

    if (_isVisible(node)) {
        if (nodeName === 'input') {
            return !node.disabled && node.type !== 'hidden';
        } else if (['select', 'textarea', 'button'].indexOf(nodeName) > -1) {
            return !node.disabled;
        } else if (nodeName === 'a') {
            return node.getAttribute('href') || hasTabIndex;
        } else {
            return hasTabIndex;
        }
    }
    return false;
}

/**
 * 列出能获取焦点的子节点
 * @param  {Element} node 容器节点
 * @return {Array<Element>}
 */
function getFocusNodeList(node) {
    var res = [];
    var nodeList = node.querySelectorAll('*');

    (0, _object.each)(nodeList, function (item) {
        if (_isFocusable(item)) {
            var method = item.getAttribute('data-auto-focus') ? 'unshift' : 'push';
            res[method](item);
        }
    });

    if (_isFocusable(node)) {
        res.unshift(node);
    }

    return res;
}

// 用于记录上一次获得焦点的无素
var lastFocusElement = null;

/**
 * 保存最近一次获得焦点的无素
 */
function saveLastFocusNode() {
    lastFocusElement = document.activeElement;
}

/**
 * 清除焦点记录
 */
function clearLastFocusNode() {
    lastFocusElement = null;
}

/**
 * 尝试将焦点切换到上一个元素
 */
function backLastFocusNode() {
    if (lastFocusElement) {
        try {
            // 元素可能已经被移动了
            lastFocusElement.focus();
        } catch (e) {
            // ignore ...
        }
    }
}

/**
 * 在限制的范围内切换焦点
 * @param  {Element} node 容器节点
 * @param  {Event} e      键盘事件
 */
function limitTabRange(node, e) {
    if (e.keyCode === _keycode2.default.TAB) {
        var tabNodeList = getFocusNodeList(node);
        var maxIndex = tabNodeList.length - 1;
        var index = tabNodeList.indexOf(document.activeElement);

        if (index > -1) {
            var targetIndex = index + (e.shiftKey ? -1 : 1);
            targetIndex < 0 && (targetIndex = maxIndex);
            targetIndex > maxIndex && (targetIndex = 0);
            tabNodeList[targetIndex].focus();
            e.preventDefault();
        }
    }
}

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (prefix) {
  prefix = prefix || '';

  return prefix + (timestamp++).toString(36);
};

var timestamp = Date.now();

/**
 * 生成全局唯一的id
 * @param  {String} [prefix=''] 前缀字符串
 * @return {String}
 *
 * @example
 * guid(); // j7jv509c
 * guid('prefix-'); // prefix-j7jv509d
 */
module.exports = exports['default'];

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates an object with the same values as object and keys
 * generated by running each own enumerable string keyed property
 * of object thru iteratee.
 * @param {Object} obj
 * @param {Function} fn
 * @return {Object}
 */
var mapKeys = function mapKeys(obj, fn) {
    var result = {};
    for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var value = obj[key];
            var newKey = fn(key, value);
            result[newKey] = value;
        }
    }

    return result;
};

/**
 * Replace specific key with prefix `next`
 * and lowercase first character of the result.
 * @param {String} key
 * @return {String}
 */
var replaceKey = function replaceKey(key) {
    return key.replace(/^(next)([A-Z])/, function (match, p1, p2) {
        return p2.toLowerCase();
    });
};

/**
 * @param {Object} source
 * @return {Object}
 */
var transformContext = function transformContext(source) {
    return mapKeys(source, replaceKey);
};

/**
 * Consumer
 * @param {Object} prop
 * @param {Object} context
 */
var Consumer = function Consumer(_ref, context) {
    var children = _ref.children;
    return typeof children === 'function' ? children(transformContext(context)) : null;
};

/**
 * PropTypes
 * @type {Object}
 * @static
 */
Consumer.propTypes = {
    // Render context as function
    // Function(context: object): ReactElement
    children: _propTypes2.default.func
};

/**
 * ContextTypes (legacy context)
 * @type {Object}
 * @static
 */
Consumer.contextTypes = {
    nextPrefix: _propTypes2.default.string,
    nextLocale: _propTypes2.default.object,
    nextPure: _propTypes2.default.bool,
    newRtl: _propTypes2.default.bool,
    nextWarning: _propTypes2.default.bool
};

exports.default = Consumer;
module.exports = exports['default'];

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Cache = function () {
    function Cache() {
        _classCallCheck(this, Cache);

        this._root = null;
        this._store = new Map();
    }

    Cache.prototype.empty = function empty() {
        return this._store.size === 0;
    };

    Cache.prototype.has = function has(key) {
        return this._store.has(key);
    };

    Cache.prototype.get = function get(key, defaultValue) {
        var res = this.has(key) ? this._store.get(key) : this.root();
        return typeof res === 'undefined' || res === null ? defaultValue : res;
    };

    Cache.prototype.add = function add(key, value) {
        if (this.empty()) {
            this._root = key;
        }
        this._store.set(key, value);
    };

    Cache.prototype.update = function update(key, value) {
        if (this.has(key)) {
            this._store.set(key, value);
        }
    };

    Cache.prototype.remove = function remove(key) {
        this._store.delete(key);
    };

    Cache.prototype.root = function root() {
        return this._store.get(this._root);
    };

    return Cache;
}();

exports.default = Cache;
module.exports = exports['default'];

/***/ }),
/* 94 */
/***/ (function(module, exports) {

if(typeof window.moment === 'undefined') {var e = new Error("Cannot find module \"window.moment\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
module.exports = window.moment;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _shallowElementEquals = __webpack_require__(44);

var _shallowElementEquals2 = _interopRequireDefault(_shallowElementEquals);

var _loading = __webpack_require__(75);

var _loading2 = _interopRequireDefault(_loading);

var _zhCn = __webpack_require__(35);

var _zhCn2 = _interopRequireDefault(_zhCn);

var _util = __webpack_require__(2);

var _body = __webpack_require__(16);

var _body2 = _interopRequireDefault(_body);

var _header = __webpack_require__(48);

var _header2 = _interopRequireDefault(_header);

var _wrapper = __webpack_require__(121);

var _wrapper2 = _interopRequireDefault(_wrapper);

var _row = __webpack_require__(17);

var _row2 = _interopRequireDefault(_row);

var _cell = __webpack_require__(18);

var _cell2 = _interopRequireDefault(_cell);

var _filter = __webpack_require__(49);

var _filter2 = _interopRequireDefault(_filter);

var _sort = __webpack_require__(63);

var _sort2 = _interopRequireDefault(_sort);

var _column = __webpack_require__(23);

var _column2 = _interopRequireDefault(_column);

var _columnGroup = __webpack_require__(122);

var _columnGroup2 = _interopRequireDefault(_columnGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var Children = _react2.default.Children,
    noop = function noop() {};

//<Table>
//    <Table.Column/>
//    <Table.ColumnGroup>
//      <Table.Column/>
//      <Table.Column/>
//    </Table.ColumnGroup>
//</Table>

/** Table */
var Table = (_temp = _class = function (_React$Component) {
    _inherits(Table, _React$Component);

    function Table(props, context) {
        _classCallCheck(this, Table);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

        _this.state = {
            sort: _this.props.sort || {}
        };

        _this.onSort = function (dataIndex, order, sort) {
            if (typeof _this.props.sort === 'undefined') {
                _this.setState({
                    sort: sort
                }, function () {
                    _this.props.onSort(dataIndex, order, sort);
                });
            } else {
                _this.props.onSort(dataIndex, order, sort);
            }
        };

        _this.onFilter = function (filterParams) {
            _this.props.onFilter(filterParams);
        };

        _this.onResizeChange = function (dataIndex, value) {
            _this.props.onResizeChange(dataIndex, value);
        };

        _this.getWrapperRef = function (wrapper) {
            if (!wrapper) {
                return _this.wrapper;
            }
            _this.wrapper = wrapper;
        };

        _this.getAffixRef = function (affixRef) {
            if (!affixRef) {
                return _this.affixRef;
            }
            _this.affixRef = affixRef;
        };

        _this.getHeaderCellRef = function (i, j, cell) {
            var cellRef = 'header_cell_' + i + '_' + j;
            if (!cell) {
                return _this[cellRef];
            }
            _this[cellRef] = cell;
        };

        _this.getRowRef = function (i, row) {
            var rowRef = 'row_' + i;
            if (!row) {
                return _this[rowRef];
            }
            _this[rowRef] = row;
        };

        _this.getCellRef = function (i, j, cell) {
            var cellRef = 'cell_' + i + '_' + j;
            if (!cell) {
                return _this[cellRef];
            }
            _this[cellRef] = cell;
        };

        var _this$context = _this.context,
            getTableInstance = _this$context.getTableInstance,
            getTableInstanceForVirtual = _this$context.getTableInstanceForVirtual;

        getTableInstance && getTableInstance(props.lockType, _this);
        getTableInstanceForVirtual && getTableInstanceForVirtual(props.lockType, _this);
        _this.notRenderCellIndex = [];
        return _this;
    }

    Table.prototype.getChildContext = function getChildContext() {
        return {
            notRenderCellIndex: this.notRenderCellIndex,
            lockType: this.props.lockType
        };
    };

    Table.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (typeof this.props.sort !== 'undefined') {
            this.setState({
                sort: nextProps.sort
            });
        }
    };

    Table.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState, nextContext) {
        if (nextProps.pure) {
            var isEqual = (0, _shallowElementEquals2.default)(nextProps, this.props) && _util.obj.shallowEqual(nextState, this.state) && _util.obj.shallowEqual(nextContext, this.context);
            return !isEqual;
        }

        return true;
    };

    Table.prototype.componentWillUpdate = function componentWillUpdate() {
        this.notRenderCellIndex = [];
    };

    Table.prototype.normalizeChildrenState = function normalizeChildrenState(props) {
        var columns = props.columns;
        if (props.children) {
            columns = this.normalizeChildren(props);
        }
        return this.fetchInfoFromBinaryChildren(columns);
    };

    // 将React结构化数据提取props转换成数组


    Table.prototype.normalizeChildren = function normalizeChildren(props) {
        var columns = props.columns;

        var getChildren = function getChildren(children) {
            var ret = [];
            Children.forEach(children, function (child) {
                if (child) {
                    var _props = _extends({}, child.props);

                    if (!(child && typeof child.type === 'function' && (child.type._typeMark === 'column' || child.type._typeMark === 'columnGroup'))) {
                        _util.log.warning('Use <Table.Column/>, <Table.ColumnGroup/> as child.');
                    }
                    ret.push(_props);
                    if (child.props.children) {
                        _props.children = getChildren(child.props.children);
                    }
                }
            });
            return ret;
        };
        if (props.children) {
            columns = getChildren(props.children);
        }
        return columns;
    };

    Table.prototype.fetchInfoFromBinaryChildren = function fetchInfoFromBinaryChildren(children) {
        var hasGroupHeader = false;
        var flatChildren = [],
            groupChildren = [],
            getChildren = function getChildren(propsChildren, level) {
            groupChildren[level] = groupChildren[level] || [];
            propsChildren.forEach(function (child) {
                if (child.children) {
                    hasGroupHeader = true;
                    getChildren(child.children, level + 1);
                } else {
                    flatChildren.push(child);
                }
                groupChildren[level].push(child);
            });
        },
            getColSpan = function getColSpan(children, colSpan) {
            colSpan = colSpan || 0;
            children.forEach(function (child) {
                if (child.children) {
                    colSpan = getColSpan(child.children, colSpan);
                } else {
                    colSpan += 1;
                }
            });
            return colSpan;
        };

        getChildren(children, 0);

        groupChildren.forEach(function (groupChild, i) {
            groupChild.forEach(function (child, j) {
                var colSpan = void 0;
                var children = child.children;

                if (children) {
                    colSpan = getColSpan(children);
                    child.colSpan = colSpan;
                    groupChildren[i][j] = child;
                }
            });
        });

        return {
            flatChildren: flatChildren,
            groupChildren: groupChildren,
            hasGroupHeader: hasGroupHeader
        };
    };

    Table.prototype.renderColGroup = function renderColGroup(flatChildren) {
        var cols = flatChildren.map(function (col, index) {
            var width = col.width;
            var style = {};
            if (width) {
                style = {
                    width: width
                };
            }

            return _react2.default.createElement('col', { style: style, key: index });
        });
        return _react2.default.createElement(
            'colgroup',
            { key: 'table-colgroup' },
            cols
        );
    };

    // 通过头部和扁平的结构渲染表格
    Table.prototype.renderTable = function renderTable(groupChildren, flatChildren) {
        if (flatChildren.length || !flatChildren.length && !this.props.lockType) {
            var _props2 = this.props,
                hasHeader = _props2.hasHeader,
                components = _props2.components,
                prefix = _props2.prefix,
                wrapperContent = _props2.wrapperContent,
                filterParams = _props2.filterParams,
                locale = _props2.locale,
                dataSource = _props2.dataSource,
                emptyContent = _props2.emptyContent,
                loading = _props2.loading,
                getCellProps = _props2.getCellProps,
                primaryKey = _props2.primaryKey,
                getRowProps = _props2.getRowProps,
                onRowClick = _props2.onRowClick,
                onRowMouseEnter = _props2.onRowMouseEnter,
                onRowMouseLeave = _props2.onRowMouseLeave,
                pure = _props2.pure;
            var sort = this.state.sort;
            var _components$Header = components.Header,
                Header = _components$Header === undefined ? _header2.default : _components$Header,
                _components$Wrapper = components.Wrapper,
                Wrapper = _components$Wrapper === undefined ? _wrapper2.default : _components$Wrapper,
                _components$Body = components.Body,
                Body = _components$Body === undefined ? _body2.default : _components$Body;

            var colGroup = this.renderColGroup(flatChildren);

            return _react2.default.createElement(
                Wrapper,
                {
                    colGroup: colGroup,
                    ref: this.getWrapperRef,
                    prefix: prefix
                },
                hasHeader ? _react2.default.createElement(Header, {
                    prefix: prefix,
                    pure: pure,
                    affixRef: this.getAffixRef,
                    colGroup: colGroup,
                    className: prefix + 'table-header',
                    filterParams: filterParams,
                    columns: groupChildren,
                    locale: locale,
                    headerCellRef: this.getHeaderCellRef,
                    components: components,
                    onFilter: this.onFilter,
                    sort: sort,
                    onResizeChange: this.onResizeChange,
                    onSort: this.onSort
                }) : null,
                _react2.default.createElement(Body, {
                    prefix: prefix,
                    pure: pure,
                    colGroup: colGroup,
                    className: prefix + 'table-body',
                    components: components,
                    loading: loading,
                    emptyContent: emptyContent,
                    getCellProps: getCellProps,
                    primaryKey: primaryKey,
                    getRowProps: getRowProps,
                    columns: flatChildren,
                    rowRef: this.getRowRef,
                    cellRef: this.getCellRef,
                    onRowClick: onRowClick,
                    onRowMouseEnter: onRowMouseEnter,
                    onRowMouseLeave: onRowMouseLeave,
                    dataSource: dataSource,
                    locale: locale
                }),
                wrapperContent
            );
        } else {
            return null;
        }
    };

    Table.prototype.render = function render() {
        var _classnames;

        var ret = this.normalizeChildrenState(this.props);
        this.groupChildren = ret.groupChildren;
        this.flatChildren = ret.flatChildren;
        /* eslint-disable no-unused-vars, prefer-const */
        var table = this.renderTable(ret.groupChildren, ret.flatChildren),
            _props3 = this.props,
            className = _props3.className,
            hasBorder = _props3.hasBorder,
            isZebra = _props3.isZebra,
            loading = _props3.loading,
            hasHeader = _props3.hasHeader,
            prefix = _props3.prefix,
            dataSource = _props3.dataSource,
            entireDataSource = _props3.entireDataSource,
            onSort = _props3.onSort,
            onResizeChange = _props3.onResizeChange,
            onRowClick = _props3.onRowClick,
            onRowMouseEnter = _props3.onRowMouseEnter,
            onRowMouseLeave = _props3.onRowMouseLeave,
            onFilter = _props3.onFilter,
            getRowProps = _props3.getRowProps,
            getCellProps = _props3.getCellProps,
            primaryKey = _props3.primaryKey,
            components = _props3.components,
            wrapperContent = _props3.wrapperContent,
            lockType = _props3.lockType,
            locale = _props3.locale,
            refs = _props3.refs,
            pure = _props3.pure,
            rtl = _props3.rtl,
            emptyContent = _props3.emptyContent,
            filterParams = _props3.filterParams,
            _props3$loadingCompon = _props3.loadingComponent,
            LoadingComponent = _props3$loadingCompon === undefined ? _loading2.default : _props3$loadingCompon,
            others = _objectWithoutProperties(_props3, ['className', 'hasBorder', 'isZebra', 'loading', 'hasHeader', 'prefix', 'dataSource', 'entireDataSource', 'onSort', 'onResizeChange', 'onRowClick', 'onRowMouseEnter', 'onRowMouseLeave', 'onFilter', 'getRowProps', 'getCellProps', 'primaryKey', 'components', 'wrapperContent', 'lockType', 'locale', 'refs', 'pure', 'rtl', 'emptyContent', 'filterParams', 'loadingComponent']),
            cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table'] = true, _classnames['only-bottom-border'] = !hasBorder, _classnames['no-header'] = !hasHeader, _classnames.zebra = isZebra, _classnames[className] = className, _classnames));


        if (rtl) {
            others.dir = 'rtl';
        }
        var content = _react2.default.createElement(
            'div',
            _extends({ className: cls }, others),
            table
        );
        if (loading) {
            var loadingClassName = prefix + 'table-loading';
            return _react2.default.createElement(
                LoadingComponent,
                { className: loadingClassName },
                content
            );
        }
        return content;
    };

    return Table;
}(_react2.default.Component), _class.Column = _column2.default, _class.ColumnGroup = _columnGroup2.default, _class.Header = _header2.default, _class.Body = _body2.default, _class.Wrapper = _wrapper2.default, _class.Row = _row2.default, _class.Cell = _cell2.default, _class.Filter = _filter2.default, _class.Sort = _sort2.default, _class.propTypes = {
    /**
     * 样式类名的品牌前缀
     */
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    rtl: _propTypes2.default.bool,
    /**
     * 自定义类名
     */
    className: _propTypes2.default.string,
    /**
     * 自定义内联样式
     */
    style: _propTypes2.default.object,
    /**
     * 表格展示的数据源
     */
    dataSource: _propTypes2.default.array,
    entireDataSource: _propTypes2.default.array,
    /**
     * 点击表格每一行触发的事件
     * @param {Object} record 该行所对应的数据
     * @param {Number} index 该行所对应的序列
     * @param {Event} e DOM事件对象
     */
    onRowClick: _propTypes2.default.func,
    /**
     * 悬浮在表格每一行的时候触发的事件
     * @param {Object} record 该行所对应的数据
     * @param {Number} index 该行所对应的序列
     * @param {Event} e DOM事件对象
     */
    onRowMouseEnter: _propTypes2.default.func,
    /**
     * 离开表格每一行的时候触发的事件
     * @param {Object} record 该行所对应的数据
     * @param {Number} index 该行所对应的序列
     * @param {Event} e DOM事件对象
     */
    onRowMouseLeave: _propTypes2.default.func,
    /**
     * 点击列排序触发的事件
     * @param {String} dataIndex 指定的排序的字段
     * @param {String} order 排序对应的顺序, 有`desc`和`asc`两种
     */
    onSort: _propTypes2.default.func,
    /**
     * 点击过滤确认按钮触发的事件
     * @param {Object} filterParams 过滤的字段信息
     */
    onFilter: _propTypes2.default.func,
    /**
     * 重设列尺寸的时候触发的事件
     * @param {String} dataIndex 指定重设的字段
     * @param {Number} value 列宽变动的数值
     */
    onResizeChange: _propTypes2.default.func,
    /**
     * 设置每一行的属性，如果返回值和其他针对行操作的属性冲突则无效。
     * @param {Object} record 该行所对应的数据
     * @param {Number} index 该行所对应的序列
     * @returns {Object} 需要设置的行属性
     */
    getRowProps: _propTypes2.default.func,
    /**
     * 设置单元格的属性，通过该属性可以进行合并单元格
     * @param {Number} rowIndex 该行所对应的序列
     * @param {Number} colIndex 该列所对应的序列
     * @param {String} dataIndex 该列所对应的字段名称
     * @param {Object} record 该行对应的记录
     * @returns {Object} 返回td元素的所支持的属性对象
     */
    getCellProps: _propTypes2.default.func,
    /**
     * 表格是否具有边框
     */
    hasBorder: _propTypes2.default.bool,
    /**
     * 表格是否具有头部
     */
    hasHeader: _propTypes2.default.bool,
    /**
     * 表格是否是斑马线
     */
    isZebra: _propTypes2.default.bool,
    /**
     * 表格是否在加载中
     */
    loading: _propTypes2.default.bool,
    /**
     * 自定义 Loading 组件
     * @type {Function}
     */
    loadingComponent: _propTypes2.default.func,
    /**
     * 当前过滤的的keys,使用此属性可以控制表格的头部的过滤选项中哪个菜单被选中,格式为 {dataIndex: {selectedKeys:[]}}
     * 示例:
     * 假设要控制dataIndex为id的列的过滤菜单中key为one的菜单项选中
     * `<Table filterParams={{id: {selectedKeys: ['one']}}}/>`
     */
    filterParams: _propTypes2.default.object,
    /**
     * 当前排序的字段,使用此属性可以控制表格的字段的排序,格式为{dataIndex: 'asc'}
     */
    sort: _propTypes2.default.object,
    /**
     * 自定义国际化文案对象
     * @property {String} ok 过滤器中确认按钮文案
     * @property {String} reset 过滤器中重置按钮文案
     * @property {String} empty 没有数据情况下 table内的文案
     * @property {String} asc 排序升序状态下的文案
     * @property {String} desc 排序将序状态下的文案
     * @property {String} expanded 可折叠行，展开状态下的文案
     * @property {String} folded 可折叠行，折叠状态下的文案
     * @property {String} filter 过滤器文案
     * @property {String} selectAll header里全选的按钮文案
     */
    locale: _propTypes2.default.object,
    components: _propTypes2.default.object,
    columns: _propTypes2.default.array,
    /**
     * 设置数据为空的时候的表格内容展现
     */
    emptyContent: _propTypes2.default.node,
    /**
     * dataSource当中数据的主键，如果给定的数据源中的属性不包含该主键，会造成选择状态全部选中
     */
    primaryKey: _propTypes2.default.string,
    lockType: _propTypes2.default.oneOf(['left', 'right']),
    wrapperContent: _propTypes2.default.any,
    refs: _propTypes2.default.object,
    /**
     * 额外渲染行的渲染函数
     * @param {Object} record 该行所对应的数据
     * @param {Number} index 该行所对应的序列
     * @returns {Element} 渲染内容
     */
    expandedRowRender: _propTypes2.default.func,
    /**
     * 额外渲染行的缩进
     */
    expandedRowIndent: _propTypes2.default.array,
    /**
     * 默认情况下展开的渲染行或者Tree, 传入此属性为受控状态
     */
    openRowKeys: _propTypes2.default.array,
    /**
     * 是否显示点击展开额外渲染行的+号按钮
     */
    hasExpandedRowCtrl: _propTypes2.default.bool,
    /**
     * 设置额外渲染行的属性
     */
    getExpandedColProps: _propTypes2.default.func,
    /**
     * 在额外渲染行或者Tree展开或者收起的时候触发的事件
     * @param {Array} openRowKeys 展开的渲染行的key
     * @param {String} currentRowKey 当前点击的渲染行的key
     * @param {Boolean} expanded 当前点击是展开还是收起
     * @param {Object} currentRecord 当前点击额外渲染行的记录
     */
    onRowOpen: _propTypes2.default.func,
    /**
     * 点击额外渲染行触发的事件
     * @param {Object} record 该行所对应的数据
     * @param {Number} index 该行所对应的序列
     * @param {Event} e DOM事件对象
     */
    onExpandedRowClick: _propTypes2.default.func,
    /**
     * 表头是否固定，该属性配合maxBodyHeight使用，当内容区域的高度超过maxBodyHeight的时候，在内容区域会出现滚动条
     */
    fixedHeader: _propTypes2.default.bool,
    /**
     * 最大内容区域的高度,在`fixedHeader`为`true`的时候,超过这个高度会出现滚动条
     */
    maxBodyHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    /**
     * 是否启用选择模式
     * @property {Function} getProps `Function(record, index)=>Object` 获取selection的默认属性
     * @property {Function} onChange `Function(selectedRowKeys:Array, records:Array)` 选择改变的时候触发的事件，**注意:** 其中records只会包含当前dataSource的数据，很可能会小于selectedRowKeys的长度。
     * @property {Function} onSelect `Function(selected:Boolean, record:Object, records:Array)` 用户手动选择/取消选择某行的回调
     * @property {Function} onSelectAll `Function(selected:Boolean, records:Array)` 用户手动选择/取消选择所有行的回调
     * @property {Array} selectedRowKeys 设置了此属性,将rowSelection变为受控状态,接收值为该行数据的primaryKey的值
     * @property {String} mode 选择selection的模式, 可选值为`single`, `multiple`，默认为`multiple`
     */
    rowSelection: _propTypes2.default.object,
    /**
     * 表头是否是sticky
     */
    stickyHeader: _propTypes2.default.bool,
    /**
     * 距离窗口顶部达到指定偏移量后触发
     */
    offsetTop: _propTypes2.default.number,
    /**
     * affix组件的的属性
     */
    affixProps: _propTypes2.default.object,
    /**
     * 在tree模式下的缩进尺寸， 仅在isTree为true时候有效
     */
    indent: _propTypes2.default.number,
    /**
     * 开启Table的tree模式, 接收的数据格式中包含children则渲染成tree table
     */
    isTree: _propTypes2.default.bool,
    /**
     * 是否开启虚拟滚动
     */
    useVirtual: _propTypes2.default.bool,
    /**
     * 设置行高
     */
    rowHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.func]),
    /**
     * 在内容区域滚动的时候触发的函数
     */
    onBodyScroll: _propTypes2.default.func
}, _class.defaultProps = {
    dataSource: [],
    onRowClick: noop,
    onRowMouseEnter: noop,
    onRowMouseLeave: noop,
    onSort: noop,
    onFilter: noop,
    onResizeChange: noop,
    getRowProps: noop,
    getCellProps: noop,
    prefix: 'next-',
    hasBorder: true,
    hasHeader: true,
    isZebra: false,
    loading: false,
    primaryKey: 'id',
    components: {},
    locale: _zhCn2.default.Table
}, _class.childContextTypes = {
    notRenderCellIndex: _propTypes2.default.array,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}, _class.contextTypes = {
    getTableInstance: _propTypes2.default.func,
    getTableInstanceForVirtual: _propTypes2.default.func
}, _temp);
Table.displayName = 'Table';
exports.default = Table;
module.exports = exports['default'];

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var hasOwnProperty = Object.prototype.hasOwnProperty;

function transformEntryEqual(a, b) {
  for (var k in a) {
    if (hasOwnProperty.call(a, k)) {
      return a[k] === b[k];
    }
  }
  return false;
}

function transformEqual(a, b) {
  if (!a && !b || a === b) {
    return true;
  }
  if (!a !== !b) {
    return false;
  }
  if (a.length !== b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!transformEntryEqual(a[i], b[i])) {
      return false;
    }
  }
  return true;
}

function shallowObjectEquals(a, b) {
  var k;
  var i = 0;
  var j = 0;
  for (k in a) {
    if (hasOwnProperty.call(a, k)) {
      switch (k) {
        case 'transform':
          if (!transformEqual(a[k], b[k])) {
            return false;
          }
          break;
        case 'shadowOffset':
          if (!shallowObjectEquals(a[k], b[k])) {
            return false;
          }
          break;
        default:
          if (a[k] !== b[k]) {
            return false;
          }
          break;
      }
      i++;
    }
  }
  for (k in b) {
    if (hasOwnProperty.call(b, k)) {
      j++;
    }
  }
  return i === j;
}

function styleEqual(a, b) {
  if (!a && !b || a === b) {
    return true;
  }
  if (!a !== !b) {
    return false;
  }
  switch (typeof a === 'undefined' ? 'undefined' : _typeof(a)) {
    case 'object':
      if (a instanceof Array) {
        for (var i = 0; i < a.length; i++) {
          if (!styleEqual(a[i], b[i])) {
            return false;
          }
        }
        return a.length === b.length;
      } else {
        return shallowObjectEquals(a, b);
      }
      break;
    case 'number':
    default:
      return a === b;
  }
}

module.exports = styleEqual;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var overlayManager = {
    allOverlays: [],

    addOverlay: function addOverlay(overlay) {
        this.removeOverlay(overlay);
        this.allOverlays.unshift(overlay);
    },
    isCurrentOverlay: function isCurrentOverlay(overlay) {
        return overlay && this.allOverlays[0] === overlay;
    },
    removeOverlay: function removeOverlay(overlay) {
        var i = this.allOverlays.indexOf(overlay);
        if (i > -1) {
            this.allOverlays.splice(i, 1);
        }
    }
};

exports.default = overlayManager;
module.exports = exports["default"];

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _util = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var VIEWPORT = 'viewport';

// IE8 not support pageXOffset
var getPageX = function getPageX() {
    return window.pageXOffset || document.documentElement.scrollLeft;
};
var getPageY = function getPageY() {
    return window.pageYOffset || document.documentElement.scrollTop;
};

/**
 * @private get element rect
 * @param       {Element} elem
 * @return      {Object}
 */
function _getElementRect(elem) {
    var offsetTop = 0,
        offsetLeft = 0;

    var offsetHeight = elem.offsetHeight;
    var offsetWidth = elem.offsetWidth;

    do {
        if (!isNaN(elem.offsetTop)) {
            offsetTop += elem.offsetTop;
        }
        if (!isNaN(elem.offsetLeft)) {
            offsetLeft += elem.offsetLeft;
        }
    } while ((elem = elem.offsetParent) !== null);

    return {
        top: offsetTop - (document.documentElement.scrollTop || document.body.scrollTop),
        left: offsetLeft - (document.documentElement.scrollLeft || document.body.scrollLeft),
        height: offsetHeight,
        width: offsetWidth
    };
}

/**
 * @private get viewport size
 * @return {Object}
 */
function _getViewportSize() {
    return {
        width: document.documentElement.clientWidth,
        height: document.documentElement.clientHeight
    };
}
var Position = (_temp = _class = function () {
    function Position(props) {
        _classCallCheck(this, Position);

        this.pinElement = props.pinElement;
        this.baseElement = props.baseElement;
        this.align = props.align || 'tl tl';
        this.offset = props.offset || [0, 0];
        this.needAdjust = props.needAdjust || false;
        this.isRtl = props.isRtl || false;
    }

    /**
     * @public static place method
     * @param  {Object}       props
     *     @param  {DOM}      props.pinElement
     *     @param  {DOM}      props.baseElement
     *     @param  {String}   props.align
     *     @param  {Number}   props.offset
     *     @param  {Boolean}  props.needAdjust
     *     @param  {Boolean}  props.isRtl
     * @return {Position}
     */


    Position.prototype.setPosition = function setPosition() {
        var pinElement = this.pinElement;
        var baseElement = this.baseElement;
        var expectedAlign = this._getExpectedAlign();
        var isPinFixed = void 0,
            isBaseFixed = void 0,
            firstPositionResult = void 0;
        if (pinElement === VIEWPORT) {
            return;
        }
        if (_util.dom.getStyle(pinElement, 'position') !== 'fixed') {
            _util.dom.setStyle(pinElement, 'position', 'absolute');
            isPinFixed = false;
        } else {
            isPinFixed = true;
        }
        if (baseElement === VIEWPORT || _util.dom.getStyle(baseElement, 'position') !== 'fixed') {
            isBaseFixed = false;
        } else {
            isBaseFixed = true;
        }
        // 根据期望的定位
        for (var i = 0; i < expectedAlign.length; i++) {
            var align = expectedAlign[i];
            var pinElementPoints = this._normalizePosition(pinElement, align.split(' ')[0], isPinFixed);
            var baseElementPoints = this._normalizePosition(baseElement, align.split(' ')[1], isPinFixed);
            var pinElementParentOffset = this._getParentOffset(pinElement);
            var baseElementOffset = isPinFixed && isBaseFixed ? this._getLeftTop(baseElement) : baseElementPoints.offset();
            var top = baseElementOffset.top + baseElementPoints.y - pinElementParentOffset.top - pinElementPoints.y;
            var left = baseElementOffset.left + baseElementPoints.x - pinElementParentOffset.left - pinElementPoints.x;
            this._setPinElementPostion(pinElement, { left: left, top: top }, this.offset);

            if (!firstPositionResult) {
                firstPositionResult = { left: left, top: top };
            }
            if (this._isInViewport(pinElement)) {
                return align;
            }
        }

        var inViewportLeft = this._makeElementInViewport(pinElement, firstPositionResult.left, 'Left', isPinFixed);
        var inViewportTop = this._makeElementInViewport(pinElement, firstPositionResult.top, 'Top', isPinFixed);

        this._setPinElementPostion(pinElement, { left: inViewportLeft, top: inViewportTop });
        return expectedAlign[0];
    };

    Position.prototype._getParentOffset = function _getParentOffset(element) {
        var parent = element.offsetParent || document.documentElement;
        var offset = void 0;
        if (parent === document.body && _util.dom.getStyle(parent, 'position') === 'static') {
            offset = {
                top: 0,
                left: 0
            };
        } else {
            offset = this._getElementOffset(parent);
        }

        offset.top += parseFloat(_util.dom.getStyle(parent, 'border-top-width'), 10);
        offset.left += parseFloat(_util.dom.getStyle(parent, 'border-left-width'), 10);
        offset.offsetParent = parent;
        return offset;
    };

    Position.prototype._makeElementInViewport = function _makeElementInViewport(pinElement, number, type, isPinFixed) {
        var result = number;
        var docElement = document.documentElement;
        var offsetParent = pinElement.offsetParent || document.documentElement;

        if (result < 0) {
            if (isPinFixed) {
                result = 0;
            } else if (offsetParent === document.body && _util.dom.getStyle(offsetParent, 'position') === 'static') {
                // Only when div's offsetParent is document.body, we set new position result.
                result = Math.max(docElement['scroll' + type], document.body['scroll' + type]);
            }
        }

        return result;
    };

    Position.prototype._normalizePosition = function _normalizePosition(element, align, isPinFixed) {
        var points = this._normalizeElement(element, isPinFixed);
        this._normalizeXY(points, align);

        return points;
    };

    Position.prototype._normalizeXY = function _normalizeXY(points, align) {
        var x = align.split('')[1];
        var y = align.split('')[0];

        points.x = this._xyConverter(x, points, 'width');
        points.y = this._xyConverter(y, points, 'height');

        return points;
    };

    Position.prototype._xyConverter = function _xyConverter(align, points, type) {
        var res = align.replace(/t|l/gi, '0%').replace(/c/gi, '50%').replace(/b|r/gi, '100%').replace(/(\d+)%/gi, function (m, d) {
            return points.size()[type] * (d / 100);
        });

        return parseFloat(res, 10) || 0;
    };

    Position.prototype._getLeftTop = function _getLeftTop(element) {
        return {
            left: parseFloat(_util.dom.getStyle(element, 'left')) || 0,
            top: parseFloat(_util.dom.getStyle(element, 'top')) || 0
        };
    };

    Position.prototype._normalizeElement = function _normalizeElement(element, isPinFixed) {
        var _this = this;

        var result = {
            element: element,
            x: 0,
            y: 0
        },
            isViewport = element === VIEWPORT,
            docElement = document.documentElement;

        result.offset = function () {
            if (isPinFixed) {
                return {
                    left: 0,
                    top: 0
                };
            } else if (isViewport) {
                return {
                    left: getPageX(),
                    top: getPageY()
                };
            } else {
                return _this._getElementOffset(element);
            }
        };

        result.size = function () {
            if (isViewport) {
                return {
                    width: docElement.clientWidth,
                    height: docElement.clientHeight
                };
            } else {
                return {
                    width: element.offsetWidth,
                    height: element.offsetHeight
                };
            }
        };

        return result;
    };

    Position.prototype._getElementOffset = function _getElementOffset(element) {
        var rect = element.getBoundingClientRect();
        var docElement = document.documentElement;
        var body = document.body;
        var docClientLeft = docElement.clientLeft || body.clientLeft || 0;
        var docClientTop = docElement.clientTop || body.clientTop || 0;

        return {
            left: rect.left + (getPageX() - docClientLeft),
            top: rect.top + (getPageY() - docClientTop)
        };
    };

    // According to the location of the overflow to calculate the desired positioning


    Position.prototype._getExpectedAlign = function _getExpectedAlign() {
        var align = this.isRtl ? this._replaceAlignDir(this.align, /l|r/g, { l: 'r', r: 'l' }) : this.align;
        var expectedAlign = [align];

        if (this.needAdjust) {
            if (/t|b/g.test(align)) {
                expectedAlign.push(this._replaceAlignDir(align, /t|b/g, { t: 'b', b: 't' }));
            }
            if (/l|r/g.test(align)) {
                expectedAlign.push(this._replaceAlignDir(align, /l|r/g, { l: 'r', r: 'l' }));
            }
            if (/c/g.test(align)) {
                expectedAlign.push(this._replaceAlignDir(align, /c(?= |$)/g, { c: 'l' }));
                expectedAlign.push(this._replaceAlignDir(align, /c(?= |$)/g, { c: 'r' }));
            }
            expectedAlign.push(this._replaceAlignDir(align, /l|r|t|b/g, { l: 'r', r: 'l', t: 'b', b: 't' }));
        }
        return expectedAlign;
    };

    // Transform align order.


    Position.prototype._replaceAlignDir = function _replaceAlignDir(align, regExp, map) {
        return align.replace(regExp, function (res) {
            return map[res];
        });
    };

    // Detecting element is in the window， we want to adjust position later.


    Position.prototype._isInViewport = function _isInViewport(element) {
        var viewportSize = _getViewportSize();
        // Avoid animate problem that use offsetWidth instead of getBoundingClientRect.
        var elementRect = _getElementRect(element);
        return elementRect.left >= 0 && elementRect.left + element.offsetWidth <= viewportSize.width && elementRect.top >= 0 && elementRect.top + element.offsetHeight <= viewportSize.height;
    };
    // 在这里做RTL判断 top-left 定位转化为等效的 top-right定位


    Position.prototype._setPinElementPostion = function _setPinElementPostion(pinElement, postion) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];
        var top = postion.top,
            left = postion.left;

        if (!this.isRtl) {
            _util.dom.setStyle(pinElement, {
                left: left + offset[0] + 'px',
                top: top + offset[1] + 'px'
            });
            return;
        }

        // transfer {left,top} equaly to {right,top}
        var pinElementParentOffset = this._getParentOffset(pinElement);

        var _getElementRect2 = _getElementRect(pinElementParentOffset.offsetParent),
            offsetParentWidth = _getElementRect2.width;

        var _getElementRect3 = _getElementRect(pinElement),
            width = _getElementRect3.width;

        var right = offsetParentWidth - (left + width);
        _util.dom.setStyle(pinElement, {
            left: 'auto',
            right: right + offset[0] + 'px',
            top: top + offset[1] + 'px'
        });
    };

    return Position;
}(), _class.VIEWPORT = VIEWPORT, _class.place = function (props) {
    return new Position(props).setPosition();
}, _temp);
exports.default = Position;
module.exports = exports['default'];

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

var _overlay = __webpack_require__(45);

var _overlay2 = _interopRequireDefault(_overlay);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = _util.func.noop,
    makeChain = _util.func.makeChain,
    bindCtx = _util.func.bindCtx;

/**
 * Overlay.Popup
 * @description 继承 Overlay 的 API，除非特别说明
 * */

var Popup = (_temp = _class = function (_Component) {
    _inherits(Popup, _Component);

    function Popup(props) {
        _classCallCheck(this, Popup);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        _this.state = {
            visible: typeof props.visible === 'undefined' ? props.defaultVisible : props.visible
        };

        bindCtx(_this, ['handleTriggerClick', 'handleTriggerKeyDown', 'handleTriggerMouseEnter', 'handleTriggerMouseLeave', 'handleTriggerFocus', 'handleTriggerBlur', 'handleContentMouseEnter', 'handleContentMouseLeave', 'handleContentMouseDown', 'handleRequestClose', 'handleMaskMouseEnter', 'handleMaskMouseLeave']);
        return _this;
    }

    Popup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if ('visible' in nextProps) {
            this.setState({
                visible: nextProps.visible
            });
        }
    };

    Popup.prototype.componentWillUnmount = function componentWillUnmount() {
        var _this2 = this;

        ['_timer', '_hideTimer', '_showTimer'].forEach(function (time) {
            _this2[time] && clearTimeout(_this2[time]);
        });
    };

    Popup.prototype.handleVisibleChange = function handleVisibleChange(visible, type, e) {
        if (!('visible' in this.props)) {
            this.setState({
                visible: visible
            });
        }

        this.props.onVisibleChange(visible, type, e);
    };

    Popup.prototype.handleTriggerClick = function handleTriggerClick(e) {
        if (this.state.visible && !this.props.canCloseByTrigger) {
            return;
        }

        this.handleVisibleChange(!this.state.visible, 'fromTrigger', e);
    };

    Popup.prototype.handleTriggerKeyDown = function handleTriggerKeyDown(e) {
        if (e.keyCode === _util.KEYCODE.SPACE || e.keyCode === _util.KEYCODE.ENTER) {
            e.preventDefault();
            this.handleTriggerClick(e);
        }
    };

    Popup.prototype.handleTriggerMouseEnter = function handleTriggerMouseEnter(e) {
        var _this3 = this;

        this._mouseNotFirstOnMask = false;

        if (this._hideTimer) {
            clearTimeout(this._hideTimer);
            this._hideTimer = null;
        }
        if (this._showTimer) {
            clearTimeout(this._showTimer);
            this._showTimer = null;
        }
        if (!this.state.visible) {
            this._showTimer = setTimeout(function () {
                _this3.handleVisibleChange(true, 'fromTrigger', e);
            }, this.props.delay);
        }
    };

    Popup.prototype.handleTriggerMouseLeave = function handleTriggerMouseLeave(e, type) {
        var _this4 = this;

        if (this._showTimer) {
            clearTimeout(this._showTimer);
            this._showTimer = null;
        }
        if (this.state.visible) {
            this._hideTimer = setTimeout(function () {
                _this4.handleVisibleChange(false, type || 'fromTrigger', e);
            }, this.props.delay);
        }
    };

    Popup.prototype.handleTriggerFocus = function handleTriggerFocus(e) {
        this.handleVisibleChange(true, 'fromTrigger', e);
    };

    Popup.prototype.handleTriggerBlur = function handleTriggerBlur(e) {
        if (!this._isForwardContent) {
            this.handleVisibleChange(false, 'fromTrigger', e);
        }
        this._isForwardContent = false;
    };

    Popup.prototype.handleContentMouseDown = function handleContentMouseDown() {
        this._isForwardContent = true;
    };

    Popup.prototype.handleContentMouseEnter = function handleContentMouseEnter() {
        clearTimeout(this._hideTimer);
    };

    Popup.prototype.handleContentMouseLeave = function handleContentMouseLeave(e) {
        this.handleTriggerMouseLeave(e, 'fromContent');
    };

    Popup.prototype.handleMaskMouseEnter = function handleMaskMouseEnter() {
        if (!this._mouseNotFirstOnMask) {
            clearTimeout(this._hideTimer);
            this._hideTimer = null;
            this._mouseNotFirstOnMask = false;
        }
    };

    Popup.prototype.handleMaskMouseLeave = function handleMaskMouseLeave() {
        this._mouseNotFirstOnMask = true;
    };

    Popup.prototype.handleRequestClose = function handleRequestClose(type, e) {
        this.handleVisibleChange(false, type, e);
    };

    Popup.prototype.renderTrigger = function renderTrigger() {
        var _this5 = this;

        var _props = this.props,
            trigger = _props.trigger,
            disabled = _props.disabled;

        var props = {
            key: 'trigger',
            'aria-haspopup': true,
            'aria-expanded': this.state.visible
        };

        if (!disabled) {
            var triggerType = this.props.triggerType;

            var triggerTypes = Array.isArray(triggerType) ? triggerType : [triggerType];
            var _trigger$props = trigger.props,
                onClick = _trigger$props.onClick,
                onKeyDown = _trigger$props.onKeyDown,
                onMouseEnter = _trigger$props.onMouseEnter,
                onMouseLeave = _trigger$props.onMouseLeave,
                onFocus = _trigger$props.onFocus,
                onBlur = _trigger$props.onBlur;

            triggerTypes.forEach(function (triggerType) {
                switch (triggerType) {
                    case 'click':
                        props.onClick = makeChain(_this5.handleTriggerClick, onClick);
                        props.onKeyDown = makeChain(_this5.handleTriggerKeyDown, onKeyDown);
                        break;
                    case 'hover':
                        props.onMouseEnter = makeChain(_this5.handleTriggerMouseEnter, onMouseEnter);
                        props.onMouseLeave = makeChain(_this5.handleTriggerMouseLeave, onMouseLeave);
                        break;
                    case 'focus':
                        props.onFocus = makeChain(_this5.handleTriggerFocus, onFocus);
                        props.onBlur = makeChain(_this5.handleTriggerBlur, onBlur);
                        break;
                    default:
                        break;
                }
            });
        }

        return _react2.default.cloneElement(trigger, props);
    };

    Popup.prototype.renderContent = function renderContent() {
        var _this6 = this;

        var _props2 = this.props,
            children = _props2.children,
            triggerType = _props2.triggerType;

        var triggerTypes = Array.isArray(triggerType) ? triggerType : [triggerType];
        var content = _react.Children.only(children);
        var _content$props = content.props,
            onMouseDown = _content$props.onMouseDown,
            onMouseEnter = _content$props.onMouseEnter,
            onMouseLeave = _content$props.onMouseLeave;

        var props = {
            key: 'portal'
        };

        triggerTypes.forEach(function (triggerType) {
            switch (triggerType) {
                case 'focus':
                    props.onMouseDown = makeChain(_this6.handleContentMouseDown, onMouseDown);
                    break;
                case 'hover':
                    props.onMouseEnter = makeChain(_this6.handleContentMouseEnter, onMouseEnter);
                    props.onMouseLeave = makeChain(_this6.handleContentMouseLeave, onMouseLeave);
                    break;
                default:
                    break;
            }
        });

        return _react2.default.cloneElement(content, props);
    };

    Popup.prototype.renderPortal = function renderPortal() {
        var _this7 = this;

        var _props3 = this.props,
            target = _props3.target,
            safeNode = _props3.safeNode,
            followTrigger = _props3.followTrigger,
            triggerType = _props3.triggerType,
            hasMask = _props3.hasMask,
            wrapperStyle = _props3.wrapperStyle,
            others = _objectWithoutProperties(_props3, ['target', 'safeNode', 'followTrigger', 'triggerType', 'hasMask', 'wrapperStyle']);

        var container = this.props.container;

        var findTriggerNode = function findTriggerNode() {
            return (0, _reactDom.findDOMNode)(_this7) || {};
        };
        var safeNodes = Array.isArray(safeNode) ? [].concat(safeNode) : [safeNode];
        safeNodes.unshift(findTriggerNode);

        var newWrapperStyle = wrapperStyle || {};

        if (followTrigger) {
            container = function container(trigger) {
                return trigger.parentNode;
            };
            newWrapperStyle.position = 'relative';
        }

        if (triggerType === 'hover' && hasMask) {
            others.onMaskMouseEnter = this.handleMaskMouseEnter;
            others.onMaskMouseLeave = this.handleMaskMouseLeave;
        }

        return _react2.default.createElement(
            _overlay2.default,
            _extends({}, others, {
                key: 'overlay',
                ref: function ref(overlay) {
                    return _this7.overlay = overlay;
                },
                visible: this.state.visible,
                target: target || findTriggerNode,
                container: container,
                safeNode: safeNodes,
                wrapperStyle: newWrapperStyle,
                triggerType: triggerType,
                hasMask: hasMask,
                onRequestClose: this.handleRequestClose }),
            this.renderContent()
        );
    };

    Popup.prototype.render = function render() {
        return [this.renderTrigger(), this.renderPortal()];
    };

    return Popup;
}(_react.Component), _class.propTypes = {
    /**
     * 弹层内容
     */
    children: _propTypes2.default.node,
    /**
     * 触发弹层显示或隐藏的元素
     */
    trigger: _propTypes2.default.element,
    /**
     * 触发弹层显示或隐藏的操作类型，可以是 'click'，'hover'，'focus'，或者它们组成的数组，如 ['hover', 'focus']
     */
    triggerType: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),
    /**
     * 弹层当前是否显示
     */
    visible: _propTypes2.default.bool,
    /**
     * 弹层默认是否显示
     */
    defaultVisible: _propTypes2.default.bool,
    /**
     * 弹层显示或隐藏时触发的回调函数
     * @param {Boolean} visible 弹层是否显示
     * @param {String} type 触发弹层显示或隐藏的来源
     * @param {Object} e DOM事件
     */
    onVisibleChange: _propTypes2.default.func,
    /**
     * 设置此属性，弹层无法显示或隐藏
     */
    disabled: _propTypes2.default.bool,
    /**
     * 弹层显示或隐藏的延时时间（以毫秒为单位），在 triggerType 被设置为 hover 时生效
     */
    delay: _propTypes2.default.number,
    /**
     * 触发元素是否可以关闭弹层
     */
    canCloseByTrigger: _propTypes2.default.bool,
    /**
     * 弹层定位的参照元素
     * @default target 属性，即触发元素
     */
    target: _propTypes2.default.any,
    safeNode: _propTypes2.default.any,
    /**
     * 是否跟随trigger滚动
     */
    followTrigger: _propTypes2.default.bool,
    container: _propTypes2.default.any,
    hasMask: _propTypes2.default.bool,
    wrapperStyle: _propTypes2.default.object,
    rtl: _propTypes2.default.bool
}, _class.defaultProps = {
    triggerType: 'hover',
    defaultVisible: false,
    onVisibleChange: noop,
    disabled: false,
    delay: 200,
    canCloseByTrigger: true,
    followTrigger: false,
    container: function container() {
        return document.body;
    },
    rtl: false
}, _temp);
Popup.displayName = 'Popup';
exports.default = Popup;
module.exports = exports['default'];

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _overlay = __webpack_require__(15);

var _overlay2 = _interopRequireDefault(_overlay);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = _util.func.noop,
    makeChain = _util.func.makeChain,
    bindCtx = _util.func.bindCtx;

var Popup = _overlay2.default.Popup;

/**
 * Dropdown
 * @description 继承 Popup 的 API，除非特别说明
 */
var Dropdown = (_temp = _class = function (_Component) {
  _inherits(Dropdown, _Component);

  function Dropdown(props) {
    _classCallCheck(this, Dropdown);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.state = {
      visible: 'visible' in props ? props.visible : props.defaultVisible || false
    };

    bindCtx(_this, ['onMenuClick', 'onVisibleChange']);
    return _this;
  }

  Dropdown.prototype.getVisible = function getVisible() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;

    return 'visible' in props ? props.visible : this.state.visible;
  };

  Dropdown.prototype.onMenuClick = function onMenuClick() {
    this.onVisibleChange(false, 'fromContent');
  };

  Dropdown.prototype.onVisibleChange = function onVisibleChange(visible, from) {
    this.setState({ visible: visible });

    this.props.onVisibleChange(visible, from);
  };

  Dropdown.prototype.render = function render() {
    var child = _react.Children.only(this.props.children);
    if (typeof child.type === 'function' && child.type.isNextMenu) {
      child = _react2.default.cloneElement(child, {
        onItemClick: makeChain(this.onMenuClick, child.props.onItemClick)
      });
    }

    return _react2.default.createElement(
      Popup,
      _extends({}, this.props, {
        visible: this.getVisible(),
        onVisibleChange: this.onVisibleChange,
        canCloseByOutSideClick: true }),
      child
    );
  };

  return Dropdown;
}(_react.Component), _class.propTypes = {
  prefix: _propTypes2.default.string,
  pure: _propTypes2.default.bool,
  className: _propTypes2.default.string,
  /**
   * 弹层内容
   */
  children: _propTypes2.default.node,
  /**
   * 弹层当前是否显示
   */
  visible: _propTypes2.default.bool,
  /**
   * 弹层默认是否显示
   */
  defaultVisible: _propTypes2.default.bool,
  /**
   * 弹层显示或隐藏时触发的回调函数
   * @param {Boolean} visible 弹层是否显示
   * @param {String} type 触发弹层显示或隐藏的来源
   * @param {Object} e DOM事件
   */
  onVisibleChange: _propTypes2.default.func,
  /**
   * 触发弹层显示或者隐藏的元素
   */
  trigger: _propTypes2.default.node,
  /**
   * 触发弹层显示或隐藏的操作类型
   */
  triggerType: _propTypes2.default.oneOf(['hover', 'click', 'focus']),
  /**
   * 设置此属性，弹层无法显示或隐藏
   */
  disabled: _propTypes2.default.bool,
  /**
   * 弹层相对于触发元素的定位, 详见 Overlay 的定位部分
   */
  align: _propTypes2.default.string,
  /**
   * 弹层相对于触发元素定位的微调
   */
  offset: _propTypes2.default.array,
  /**
   * 弹层显示或隐藏的延时时间（以毫秒为单位），在 triggerType 被设置为 hover 时生效
   */
  delay: _propTypes2.default.number,
  /**
   * 弹层打开时是否让其中的元素自动获取焦点
   */
  autoFocus: _propTypes2.default.bool,
  /**
   * 是否显示遮罩
   */
  hasMask: _propTypes2.default.bool,
  /**
   * 隐藏时是否保留子节点
   */
  cache: _propTypes2.default.bool,
  /**
   * 配置动画的播放方式，支持 { in: 'enter-class', out: 'leave-class' } 的对象参数，如果设置为 false，则不播放动画
   * @default { in: 'expandInDown', out: 'expandOutUp' }
   */
  animation: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.bool])
}, _class.defaultProps = {
  prefix: 'next-',
  pure: false,
  defaultVisible: false,
  onVisibleChange: noop,
  triggerType: 'hover',
  disabled: false,
  align: 'tl bl',
  offset: [0, 0],
  delay: 200,
  autoFocus: true,
  hasMask: false,
  cache: false,
  onPosition: noop
}, _temp);
Dropdown.displayName = 'Dropdown';
exports.default = _configProvider2.default.config(Dropdown);
module.exports = exports['default'];

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _animate = __webpack_require__(74);

var _animate2 = _interopRequireDefault(_animate);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

var _item = __webpack_require__(14);

var _item2 = _interopRequireDefault(_item);

var _selectableItem = __webpack_require__(22);

var _selectableItem2 = _interopRequireDefault(_selectableItem);

var _popupItem = __webpack_require__(57);

var _popupItem2 = _interopRequireDefault(_popupItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var Expand = _animate2.default.Expand;
var bindCtx = _util.func.bindCtx;

/**
 * Menu.SubMenu
 * @order 1
 */

var SubMenu = (_temp = _class = function (_Component) {
    _inherits(SubMenu, _Component);

    function SubMenu(props) {
        _classCallCheck(this, SubMenu);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        bindCtx(_this, ['handleMouseEnter', 'handleMouseLeave', 'handleClick', 'handleOpen', 'afterLeave']);
        return _this;
    }

    SubMenu.prototype.componentDidMount = function componentDidMount() {
        this.itemNode = (0, _reactDom.findDOMNode)(this);
    };

    SubMenu.prototype.afterLeave = function afterLeave() {
        var _props = this.props,
            focused = _props.focused,
            root = _props.root;
        var focusable = root.props.focusable;

        if (focusable && focused) {
            this.itemNode.focus();
        }
    };

    SubMenu.prototype.getOpen = function getOpen() {
        var _props2 = this.props,
            _key = _props2._key,
            root = _props2.root;
        var openKeys = root.state.openKeys;


        return openKeys.indexOf(_key) > -1;
    };

    SubMenu.prototype.handleMouseEnter = function handleMouseEnter(e) {
        this.handleOpen(true);

        this.props.onMouseEnter && this.props.onMouseEnter(e);
    };

    SubMenu.prototype.handleMouseLeave = function handleMouseLeave(e) {
        this.handleOpen(false);

        this.props.onMouseLeave && this.props.onMouseLeave(e);
    };

    SubMenu.prototype.handleClick = function handleClick(e) {
        var _props3 = this.props,
            root = _props3.root,
            selectable = _props3.selectable;
        var selectMode = root.props.selectMode;

        if (selectMode && selectable) {
            e.stopPropagation();
        }

        var open = this.getOpen();
        this.handleOpen(!open);
    };

    SubMenu.prototype.handleOpen = function handleOpen(open, triggerType, e) {
        var _props4 = this.props,
            _key = _props4._key,
            root = _props4.root;

        root.handleOpen(_key, open, triggerType, e);
    };

    SubMenu.prototype.passParentToChildren = function passParentToChildren(children) {
        var _this2 = this;

        var _props5 = this.props,
            mode = _props5.mode,
            root = _props5.root;


        return _react.Children.map(children, function (child) {
            return (0, _react.cloneElement)(child, {
                parent: _this2,
                parentMode: mode || root.props.mode
            });
        });
    };

    SubMenu.prototype.renderInline = function renderInline() {
        var _cx, _cx2, _cx3;

        var _props6 = this.props,
            _key = _props6._key,
            level = _props6.level,
            root = _props6.root,
            className = _props6.className,
            selectableFromProps = _props6.selectable,
            label = _props6.label,
            children = _props6.children,
            subMenuContentClassName = _props6.subMenuContentClassName,
            propsTriggerType = _props6.triggerType,
            parentMode = _props6.parentMode;
        var _root$props = root.props,
            prefix = _root$props.prefix,
            selectMode = _root$props.selectMode,
            rootTriggerType = _root$props.triggerType,
            inlineArrowDirection = _root$props.inlineArrowDirection,
            expandAnimation = _root$props.expandAnimation,
            rtl = _root$props.rtl;

        var triggerType = propsTriggerType || rootTriggerType;
        var open = this.getOpen();
        var others = _util.obj.pickOthers(Object.keys(SubMenu.propTypes), this.props);

        var liProps = {
            className: (0, _classnames2.default)((_cx = {}, _cx[prefix + 'menu-sub-menu-wrapper'] = true, _cx[className] = !!className, _cx))
        };
        var itemProps = {
            'aria-expanded': open,
            _key: _key,
            level: level,
            root: root,
            type: 'submenu',
            component: 'div',
            parentMode: parentMode
        };
        var arrorProps = {
            type: inlineArrowDirection === 'right' ? 'arrow-right' : 'arrow-down',
            className: (0, _classnames2.default)((_cx2 = {}, _cx2[prefix + 'menu-icon-arrow'] = true, _cx2[prefix + 'menu-icon-arrow-down'] = inlineArrowDirection === 'down', _cx2[prefix + 'menu-icon-arrow-right'] = inlineArrowDirection === 'right', _cx2[prefix + 'open'] = open, _cx2))
        };

        var selectable = !!selectMode && selectableFromProps;
        var NewItem = selectable ? _selectableItem2.default : _item2.default;

        if (triggerType === 'hover') {
            liProps.onMouseEnter = this.handleMouseEnter;
            liProps.onMouseLeave = this.handleMouseLeave;
        } else if (selectable) {
            arrorProps.onClick = this.handleClick;
        } else {
            itemProps.onClick = this.handleClick;
        }
        if (open) {
            itemProps.className = prefix + 'opened';
        }

        var newSubMenuContentClassName = (0, _classnames2.default)((_cx3 = {}, _cx3[prefix + 'menu-sub-menu'] = true, _cx3[subMenuContentClassName] = !!subMenuContentClassName, _cx3));

        var subMenu = open ? _react2.default.createElement(
            'ul',
            { role: 'menu', dir: rtl ? 'rtl' : undefined, ref: 'subMenu', className: newSubMenuContentClassName },
            this.passParentToChildren(children)
        ) : null;

        return _react2.default.createElement(
            'li',
            _extends({}, others, liProps),
            _react2.default.createElement(
                NewItem,
                itemProps,
                _react2.default.createElement(
                    'span',
                    { className: prefix + 'menu-item-text' },
                    label
                ),
                _react2.default.createElement(_icon2.default, arrorProps)
            ),
            expandAnimation ? _react2.default.createElement(
                Expand,
                { animationAppear: false, afterLeave: this.afterLeave },
                subMenu
            ) : subMenu
        );
    };

    SubMenu.prototype.renderPopup = function renderPopup() {
        var _cx4;

        var _props7 = this.props,
            children = _props7.children,
            subMenuContentClassName = _props7.subMenuContentClassName,
            others = _objectWithoutProperties(_props7, ['children', 'subMenuContentClassName']);

        var root = this.props.root;
        var _root$props2 = root.props,
            prefix = _root$props2.prefix,
            popupClassName = _root$props2.popupClassName,
            popupStyle = _root$props2.popupStyle,
            rtl = _root$props2.rtl;


        var newClassName = (0, _classnames2.default)((_cx4 = {}, _cx4[prefix + 'menu'] = true, _cx4[prefix + 'ver'] = true, _cx4[popupClassName] = !!popupClassName, _cx4[subMenuContentClassName] = !!subMenuContentClassName, _cx4));

        others.rtl = rtl;

        return _react2.default.createElement(
            _popupItem2.default,
            _extends({}, others, { hasSubMenu: true }),
            _react2.default.createElement(
                'ul',
                { role: 'menu', dir: rtl ? 'rtl' : undefined, className: newClassName, style: popupStyle },
                this.passParentToChildren(children)
            )
        );
    };

    SubMenu.prototype.render = function render() {
        var _props8 = this.props,
            mode = _props8.mode,
            root = _props8.root;

        var newMode = mode || root.props.mode;

        return newMode === 'popup' ? this.renderPopup() : this.renderInline();
    };

    return SubMenu;
}(_react.Component), _class.menuChildType = 'submenu', _class.propTypes = {
    _key: _propTypes2.default.string,
    root: _propTypes2.default.object,
    level: _propTypes2.default.number,
    groupIndent: _propTypes2.default.number,
    /**
     * 标签内容
     */
    label: _propTypes2.default.node,
    /**
     * 是否可选，该属性仅在设置 Menu 组件 selectMode 属性后生效
     */
    selectable: _propTypes2.default.bool,
    /**
     * 子菜单打开方式，如果设置会覆盖 Menu 上的同名属性
     * @default Menu 的 mode 属性值
     */
    mode: _propTypes2.default.oneOf(['inline', 'popup']),
    /**
     * 菜单项或下一级子菜单
     */
    children: _propTypes2.default.node,
    onMouseEnter: _propTypes2.default.func,
    onMouseLeave: _propTypes2.default.func,
    subMenuContentClassName: _propTypes2.default.string,
    triggerType: _propTypes2.default.oneOf(['click', 'hover']),
    align: _propTypes2.default.oneOf(['outside', 'follow']),
    parentMode: _propTypes2.default.oneOf(['inline', 'popup'])
}, _class.defaultProps = {
    groupIndent: 0,
    selectable: false
}, _temp);
SubMenu.displayName = 'SubMenu';
exports.default = SubMenu;
module.exports = exports['default'];

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

exports.__esModule = true;
exports.default = void 0;

var PropTypes = _interopRequireWildcard(__webpack_require__(1));

var _addClass = _interopRequireDefault(__webpack_require__(103));

var _removeClass = _interopRequireDefault(__webpack_require__(106));

var _react = _interopRequireDefault(__webpack_require__(0));

var _Transition = _interopRequireDefault(__webpack_require__(53));

var _PropTypes = __webpack_require__(55);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }newObj.default = obj;return newObj;
  }
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;
  _defaults(subClass, superClass);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var addClass = function addClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return (0, _addClass.default)(node, c);
  });
};

var removeClass = function removeClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return (0, _removeClass.default)(node, c);
  });
};

var propTypes = process.env.NODE_ENV !== "production" ? _extends({}, _Transition.default.propTypes, {
  /**
   * The animation classNames applied to the component as it enters, exits or has finished the transition.
   * A single name can be provided and it will be suffixed for each stage: e.g.
   *
   * `classNames="fade"` applies `fade-enter`, `fade-enter-active`, `fade-enter-done`,
   * `fade-exit`, `fade-exit-active`, `fade-exit-done`, `fade-appear`, and `fade-appear-active`.
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply spread
   * them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */
  classNames: _PropTypes.classNamesShape,

  /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEnter: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntered: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * @type Function(node: HtmlElement)
   */
  onExit: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * @type Function(node: HtmlElement)
   */
  onExiting: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * @type Function(node: HtmlElement)
   */
  onExited: PropTypes.func
}) : {};;
/**
 * A `Transition` component using CSS transitions and animations.
 * It's inspired by the excellent [ng-animate](http://www.nganimate.org/) library.
 *
 * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
 * and `exit` stages of the transition. The first class is applied and then a
 * second "active" class in order to activate the css animation. After the animation,
 * matching `done` class names are applied to persist the animation state.
 *
 * When the `in` prop is toggled to `true` the Component will get
 * the `example-enter` CSS class and the `example-enter-active` CSS class
 * added in the next tick. This is a convention based on the `classNames` prop.
 */

var CSSTransition =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(CSSTransition, _React$Component);

  function CSSTransition() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

    _this.onEnter = function (node, appearing) {
      var _this$getClassNames = _this.getClassNames(appearing ? 'appear' : 'enter'),
          className = _this$getClassNames.className;

      _this.removeClasses(node, 'exit');

      addClass(node, className);

      if (_this.props.onEnter) {
        _this.props.onEnter(node, appearing);
      }
    };

    _this.onEntering = function (node, appearing) {
      var _this$getClassNames2 = _this.getClassNames(appearing ? 'appear' : 'enter'),
          activeClassName = _this$getClassNames2.activeClassName;

      _this.reflowAndAddClass(node, activeClassName);

      if (_this.props.onEntering) {
        _this.props.onEntering(node, appearing);
      }
    };

    _this.onEntered = function (node, appearing) {
      var _this$getClassNames3 = _this.getClassNames('enter'),
          doneClassName = _this$getClassNames3.doneClassName;

      _this.removeClasses(node, appearing ? 'appear' : 'enter');

      addClass(node, doneClassName);

      if (_this.props.onEntered) {
        _this.props.onEntered(node, appearing);
      }
    };

    _this.onExit = function (node) {
      var _this$getClassNames4 = _this.getClassNames('exit'),
          className = _this$getClassNames4.className;

      _this.removeClasses(node, 'appear');

      _this.removeClasses(node, 'enter');

      addClass(node, className);

      if (_this.props.onExit) {
        _this.props.onExit(node);
      }
    };

    _this.onExiting = function (node) {
      var _this$getClassNames5 = _this.getClassNames('exit'),
          activeClassName = _this$getClassNames5.activeClassName;

      _this.reflowAndAddClass(node, activeClassName);

      if (_this.props.onExiting) {
        _this.props.onExiting(node);
      }
    };

    _this.onExited = function (node) {
      var _this$getClassNames6 = _this.getClassNames('exit'),
          doneClassName = _this$getClassNames6.doneClassName;

      _this.removeClasses(node, 'exit');

      addClass(node, doneClassName);

      if (_this.props.onExited) {
        _this.props.onExited(node);
      }
    };

    _this.getClassNames = function (type) {
      var classNames = _this.props.classNames;
      var className = typeof classNames !== 'string' ? classNames[type] : classNames + '-' + type;
      var activeClassName = typeof classNames !== 'string' ? classNames[type + 'Active'] : className + '-active';
      var doneClassName = typeof classNames !== 'string' ? classNames[type + 'Done'] : className + '-done';
      return {
        className: className,
        activeClassName: activeClassName,
        doneClassName: doneClassName
      };
    };

    return _this;
  }

  var _proto = CSSTransition.prototype;

  _proto.removeClasses = function removeClasses(node, type) {
    var _this$getClassNames7 = this.getClassNames(type),
        className = _this$getClassNames7.className,
        activeClassName = _this$getClassNames7.activeClassName,
        doneClassName = _this$getClassNames7.doneClassName;

    className && removeClass(node, className);
    activeClassName && removeClass(node, activeClassName);
    doneClassName && removeClass(node, doneClassName);
  };

  _proto.reflowAndAddClass = function reflowAndAddClass(node, className) {
    // This is for to force a repaint,
    // which is necessary in order to transition styles when adding a class name.
    if (className) {
      /* eslint-disable no-unused-expressions */
      node && node.scrollTop;
      /* eslint-enable no-unused-expressions */

      addClass(node, className);
    }
  };

  _proto.render = function render() {
    var props = _extends({}, this.props);

    delete props.classNames;
    return _react.default.createElement(_Transition.default, _extends({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };

  return CSSTransition;
}(_react.default.Component);

CSSTransition.propTypes = process.env.NODE_ENV !== "production" ? propTypes : {};
var _default = CSSTransition;
exports.default = _default;
module.exports = exports["default"];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(104);

exports.__esModule = true;
exports.default = addClass;

var _hasClass = _interopRequireDefault(__webpack_require__(105));

function addClass(element, className) {
  if (element.classList) element.classList.add(className);else if (!(0, _hasClass.default)(element, className)) if (typeof element.className === 'string') element.className = element.className + ' ' + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + ' ' + className);
}

module.exports = exports["default"];

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = hasClass;

function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);else return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}

module.exports = exports["default"];

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp('(^|\\s)' + classToRemove + '(?:\\s|$)', 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
}

module.exports = function removeClass(element, className) {
  if (element.classList) element.classList.remove(className);else if (typeof element.className === 'string') element.className = replaceClassName(element.className, className);else element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

exports.__esModule = true;
exports.default = void 0;

var _propTypes = _interopRequireDefault(__webpack_require__(1));

var _react = _interopRequireDefault(__webpack_require__(0));

var _reactDom = __webpack_require__(4);

var _TransitionGroup = _interopRequireDefault(__webpack_require__(56));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];
  }return target;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;
  _defaults(subClass, superClass);
}

var propTypes = process.env.NODE_ENV !== "production" ? {
  in: _propTypes.default.bool.isRequired,
  children: function children(props, propName) {
    if (_react.default.Children.count(props[propName]) !== 2) return new Error("\"" + propName + "\" must be exactly two transition components.");
    return null;
  }
} : {};;
/**
 * The `<ReplaceTransition>` component is a specialized `Transition` component
 * that animates between two children.
 *
 * ```jsx
 * <ReplaceTransition in>
 *   <Fade><div>I appear first</div></Fade>
 *   <Fade><div>I replace the above</div></Fade>
 * </ReplaceTransition>
 * ```
 */

var ReplaceTransition =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(ReplaceTransition, _React$Component);

  function ReplaceTransition() {
    var _this;

    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;

    _this.handleEnter = function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return _this.handleLifecycle('onEnter', 0, args);
    };

    _this.handleEntering = function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return _this.handleLifecycle('onEntering', 0, args);
    };

    _this.handleEntered = function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return _this.handleLifecycle('onEntered', 0, args);
    };

    _this.handleExit = function () {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      return _this.handleLifecycle('onExit', 1, args);
    };

    _this.handleExiting = function () {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      return _this.handleLifecycle('onExiting', 1, args);
    };

    _this.handleExited = function () {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      return _this.handleLifecycle('onExited', 1, args);
    };

    return _this;
  }

  var _proto = ReplaceTransition.prototype;

  _proto.handleLifecycle = function handleLifecycle(handler, idx, originalArgs) {
    var _child$props;

    var children = this.props.children;

    var child = _react.default.Children.toArray(children)[idx];

    if (child.props[handler]) (_child$props = child.props)[handler].apply(_child$props, originalArgs);
    if (this.props[handler]) this.props[handler]((0, _reactDom.findDOMNode)(this));
  };

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        inProp = _this$props.in,
        props = _objectWithoutPropertiesLoose(_this$props, ["children", "in"]);

    var _React$Children$toArr = _react.default.Children.toArray(children),
        first = _React$Children$toArr[0],
        second = _React$Children$toArr[1];

    delete props.onEnter;
    delete props.onEntering;
    delete props.onEntered;
    delete props.onExit;
    delete props.onExiting;
    delete props.onExited;
    return _react.default.createElement(_TransitionGroup.default, props, inProp ? _react.default.cloneElement(first, {
      key: 'first',
      onEnter: this.handleEnter,
      onEntering: this.handleEntering,
      onEntered: this.handleEntered
    }) : _react.default.cloneElement(second, {
      key: 'second',
      onEnter: this.handleExit,
      onEntering: this.handleExiting,
      onEntered: this.handleExited
    }));
  };

  return ReplaceTransition;
}(_react.default.Component);

ReplaceTransition.propTypes = process.env.NODE_ENV !== "production" ? propTypes : {};
var _default = ReplaceTransition;
exports.default = _default;
module.exports = exports["default"];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getChildMapping = getChildMapping;
exports.mergeChildMappings = mergeChildMappings;
exports.getInitialChildMapping = getInitialChildMapping;
exports.getNextChildMapping = getNextChildMapping;

var _react = __webpack_require__(0);

/**
 * Given `this.props.children`, return an object mapping key to child.
 *
 * @param {*} children `this.props.children`
 * @return {object} Mapping of key to child
 */
function getChildMapping(children, mapFn) {
  var mapper = function mapper(child) {
    return mapFn && (0, _react.isValidElement)(child) ? mapFn(child) : child;
  };

  var result = Object.create(null);
  if (children) _react.Children.map(children, function (c) {
    return c;
  }).forEach(function (child) {
    // run the map function here instead so that the key is the computed one
    result[child.key] = mapper(child);
  });
  return result;
}
/**
 * When you're adding or removing children some may be added or removed in the
 * same render pass. We want to show *both* since we want to simultaneously
 * animate elements in and out. This function takes a previous set of keys
 * and a new set of keys and merges them with its best guess of the correct
 * ordering. In the future we may expose some of the utilities in
 * ReactMultiChild to make this easy, but for now React itself does not
 * directly have this concept of the union of prevChildren and nextChildren
 * so we implement it here.
 *
 * @param {object} prev prev children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @param {object} next next children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @return {object} a key set that contains all keys in `prev` and all keys
 * in `next` in a reasonable order.
 */

function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};

  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  } // For each key of `next`, the list of keys to insert before that key in
  // the combined list


  var nextKeysPending = Object.create(null);
  var pendingKeys = [];

  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }

  var i;
  var childMapping = {};

  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }

    childMapping[nextKey] = getValueForKey(nextKey);
  } // Finally, add the keys which didn't appear before any key in `next`


  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }

  return childMapping;
}

function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}

function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function (child) {
    return (0, _react.cloneElement)(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, 'appear', props),
      enter: getProp(child, 'enter', props),
      exit: getProp(child, 'exit', props)
    });
  });
}

function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function (key) {
    var child = children[key];
    if (!(0, _react.isValidElement)(child)) return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = (0, _react.isValidElement)(prevChild) && !prevChild.props.in; // item is new (entering)

    if (hasNext && (!hasPrev || isLeaving)) {
      // console.log('entering', key)
      children[key] = (0, _react.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      // item is old (exiting)
      // console.log('leaving', key)
      children[key] = (0, _react.cloneElement)(child, {
        in: false
      });
    } else if (hasNext && hasPrev && (0, _react.isValidElement)(prevChild)) {
      // item hasn't changed transition states
      // copy over the last transition props;
      // console.log('unchanged', key)
      children[key] = (0, _react.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    }
  });
  return children;
}

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactTransitionGroup = __webpack_require__(52);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};
var on = _util.events.on,
    off = _util.events.off;
var addClass = _util.dom.addClass,
    removeClass = _util.dom.removeClass;

var prefixes = ['-webkit-', '-moz-', '-o-', 'ms-', ''];

function getStyleProperty(node, name) {
    var style = window.getComputedStyle(node);
    var ret = '';
    for (var i = 0; i < prefixes.length; i++) {
        ret = style.getPropertyValue(prefixes[i] + name);
        if (ret) {
            break;
        }
    }
    return ret;
}

var AnimateChild = (_temp = _class = function (_Component) {
    _inherits(AnimateChild, _Component);

    function AnimateChild(props) {
        _classCallCheck(this, AnimateChild);

        var _this2 = _possibleConstructorReturn(this, _Component.call(this, props));

        _util.func.bindCtx(_this2, ['handleEnter', 'handleEntering', 'handleEntered', 'handleExit', 'handleExiting', 'handleExited', 'addEndListener']);
        _this2.endListeners = {
            transitionend: [],
            animationend: []
        };
        _this2.timeoutMap = {};
        return _this2;
    }

    AnimateChild.prototype.componentWillUnmount = function componentWillUnmount() {
        var _this3 = this;

        Object.keys(this.endListeners).forEach(function (eventName) {
            _this3.endListeners[eventName].forEach(function (listener) {
                off(_this3.node, eventName, listener);
            });
        });
        this.endListeners = {
            transitionend: [],
            animationend: []
        };
    };

    AnimateChild.prototype.generateEndListener = function generateEndListener(node, done, eventName, id) {
        var _this = this;
        return function endListener(e) {

            if (e && e.target === node) {
                if (_this.timeoutMap[id]) {
                    clearTimeout(_this.timeoutMap[id]);
                    delete _this.timeoutMap[id];
                }

                done();
                off(node, eventName, endListener);
                var listeners = _this.endListeners[eventName];
                var index = listeners.indexOf(endListener);
                index > -1 && listeners.splice(index, 1);
            }
        };
    };

    AnimateChild.prototype.addEndListener = function addEndListener(node, done) {
        var _this4 = this;

        if (_util.support.transition || _util.support.animation) {
            var id = (0, _util.guid)();

            this.node = node;
            if (_util.support.transition) {
                var transitionEndListener = this.generateEndListener(node, done, 'transitionend', id);
                on(node, 'transitionend', transitionEndListener);
                this.endListeners.transitionend.push(transitionEndListener);
            }
            if (_util.support.animation) {
                var animationEndListener = this.generateEndListener(node, done, 'animationend', id);
                on(node, 'animationend', animationEndListener);
                this.endListeners.animationend.push(animationEndListener);
            }

            setTimeout(function () {
                var transitionDelay = parseFloat(getStyleProperty(node, 'transition-delay')) || 0;
                var transitionDuration = parseFloat(getStyleProperty(node, 'transition-duration')) || 0;
                var animationDelay = parseFloat(getStyleProperty(node, 'animation-delay')) || 0;
                var animationDuration = parseFloat(getStyleProperty(node, 'animation-duration')) || 0;
                var time = Math.max(transitionDuration + transitionDelay, animationDuration + animationDelay);
                if (time) {
                    _this4.timeoutMap[id] = setTimeout(function () {
                        done();
                    }, time * 1000 + 200);
                }
            }, 15);
        } else {
            done();
        }
    };

    AnimateChild.prototype.removeEndtListener = function removeEndtListener() {
        this.transitionOff && this.transitionOff();
        this.animationOff && this.animationOff();
    };

    AnimateChild.prototype.removeClassNames = function removeClassNames(node, names) {
        Object.keys(names).forEach(function (key) {
            removeClass(node, names[key]);
        });
    };

    AnimateChild.prototype.handleEnter = function handleEnter(node, isAppearing) {
        var names = this.props.names;

        if (names) {
            this.removeClassNames(node, names);
            var className = isAppearing ? 'appear' : 'enter';
            addClass(node, names[className]);
        }

        var hook = isAppearing ? this.props.onAppear : this.props.onEnter;
        hook(node);
    };

    AnimateChild.prototype.handleEntering = function handleEntering(node, isAppearing) {
        var _this5 = this;

        setTimeout(function () {
            var names = _this5.props.names;

            if (names) {
                var className = isAppearing ? 'appearActive' : 'enterActive';
                addClass(node, names[className]);
            }

            var hook = isAppearing ? _this5.props.onAppearing : _this5.props.onEntering;
            hook(node);
        }, 10);
    };

    AnimateChild.prototype.handleEntered = function handleEntered(node, isAppearing) {
        var names = this.props.names;

        if (names) {
            var classNames = isAppearing ? [names.appear, names.appearActive] : [names.enter, names.enterActive];
            classNames.forEach(function (className) {
                removeClass(node, className);
            });
        }

        var hook = isAppearing ? this.props.onAppeared : this.props.onEntered;
        hook(node);
    };

    AnimateChild.prototype.handleExit = function handleExit(node) {
        var names = this.props.names;

        if (names) {
            this.removeClassNames(node, names);
            addClass(node, names.leave);
        }

        this.props.onExit(node);
    };

    AnimateChild.prototype.handleExiting = function handleExiting(node) {
        var _this6 = this;

        setTimeout(function () {
            var names = _this6.props.names;

            if (names) {
                addClass(node, names.leaveActive);
            }
            _this6.props.onExiting(node);
        }, 10);
    };

    AnimateChild.prototype.handleExited = function handleExited(node) {
        var names = this.props.names;

        if (names) {
            [names.leave, names.leaveActive].forEach(function (className) {
                removeClass(node, className);
            });
        }

        this.props.onExited(node);
    };

    AnimateChild.prototype.render = function render() {
        /* eslint-disable no-unused-vars */
        var _props = this.props,
            names = _props.names,
            onAppear = _props.onAppear,
            onAppeared = _props.onAppeared,
            onAppearing = _props.onAppearing,
            onEnter = _props.onEnter,
            onEntering = _props.onEntering,
            onEntered = _props.onEntered,
            onExit = _props.onExit,
            onExiting = _props.onExiting,
            onExited = _props.onExited,
            others = _objectWithoutProperties(_props, ['names', 'onAppear', 'onAppeared', 'onAppearing', 'onEnter', 'onEntering', 'onEntered', 'onExit', 'onExiting', 'onExited']);
        /* eslint-enable no-unused-vars */

        return _react2.default.createElement(_reactTransitionGroup.Transition, _extends({}, others, {
            onEnter: this.handleEnter,
            onEntering: this.handleEntering,
            onEntered: this.handleEntered,
            onExit: this.handleExit,
            onExiting: this.handleExiting,
            onExited: this.handleExited,
            addEndListener: this.addEndListener }));
    };

    return AnimateChild;
}(_react.Component), _class.propTypes = {
    names: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),
    onAppear: _propTypes2.default.func,
    onAppearing: _propTypes2.default.func,
    onAppeared: _propTypes2.default.func,
    onEnter: _propTypes2.default.func,
    onEntering: _propTypes2.default.func,
    onEntered: _propTypes2.default.func,
    onExit: _propTypes2.default.func,
    onExiting: _propTypes2.default.func,
    onExited: _propTypes2.default.func
}, _class.defaultProps = {
    onAppear: noop,
    onAppearing: noop,
    onAppeared: noop,
    onEnter: noop,
    onEntering: noop,
    onEntered: noop,
    onExit: noop,
    onExiting: noop,
    onExited: noop
}, _temp);
AnimateChild.displayName = 'AnimateChild';
exports.default = AnimateChild;
module.exports = exports['default'];

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

var _animate = __webpack_require__(51);

var _animate2 = _interopRequireDefault(_animate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};
var getStyle = _util.dom.getStyle;
var Expand = (_temp = _class = function (_Component) {
    _inherits(Expand, _Component);

    function Expand(props) {
        _classCallCheck(this, Expand);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        _util.func.bindCtx(_this, ['beforeEnter', 'onEnter', 'afterEnter', 'beforeLeave', 'onLeave', 'afterLeave']);
        return _this;
    }

    Expand.prototype.beforeEnter = function beforeEnter(node) {
        if (this.leaving) {
            this.afterLeave(node);
        }

        this.cacheCurrentStyle(node);
        this.cacheComputedStyle(node);
        this.setCurrentStyleToZero(node);

        this.props.beforeEnter(node);
    };

    Expand.prototype.onEnter = function onEnter(node) {
        this.setCurrentStyleToComputedStyle(node);

        this.props.onEnter(node);
    };

    Expand.prototype.afterEnter = function afterEnter(node) {
        this.restoreCurrentStyle(node);

        this.props.afterEnter(node);
    };

    Expand.prototype.beforeLeave = function beforeLeave(node) {
        this.leaving = true;

        this.cacheCurrentStyle(node);
        this.cacheComputedStyle(node);
        this.setCurrentStyleToComputedStyle(node);

        this.props.beforeLeave(node);
    };

    Expand.prototype.onLeave = function onLeave(node) {
        this.setCurrentStyleToZero(node);

        this.props.onLeave(node);
    };

    Expand.prototype.afterLeave = function afterLeave(node) {
        this.leaving = false;

        this.restoreCurrentStyle(node);

        this.props.afterLeave(node);
    };

    Expand.prototype.cacheCurrentStyle = function cacheCurrentStyle(node) {
        this.styleBorderTopWidth = node.style.borderTopWidth;
        this.stylePaddingTop = node.style.paddingTop;
        this.styleHeight = node.style.height;
        this.stylePaddingBottom = node.style.paddingBottom;
        this.styleBorderBottomWidth = node.style.borderBottomWidth;
    };

    Expand.prototype.cacheComputedStyle = function cacheComputedStyle(node) {
        this.borderTopWidth = getStyle(node, 'borderTopWidth');
        this.paddingTop = getStyle(node, 'paddingTop');
        this.height = node.offsetHeight;
        this.paddingBottom = getStyle(node, 'paddingBottom');
        this.borderBottomWidth = getStyle(node, 'borderBottomWidth');
    };

    Expand.prototype.setCurrentStyleToZero = function setCurrentStyleToZero(node) {
        node.style.borderTopWidth = '0px';
        node.style.paddingTop = '0px';
        node.style.height = '0px';
        node.style.paddingBottom = '0px';
        node.style.borderBottomWidth = '0px';
    };

    Expand.prototype.setCurrentStyleToComputedStyle = function setCurrentStyleToComputedStyle(node) {
        node.style.borderTopWidth = this.borderTopWidth + 'px';
        node.style.paddingTop = this.paddingTop + 'px';
        node.style.height = this.height + 'px';
        node.style.paddingBottom = this.paddingBottom + 'px';
        node.style.borderBottomWidth = this.borderBottomWidth + 'px';
    };

    Expand.prototype.restoreCurrentStyle = function restoreCurrentStyle(node) {
        node.style.borderTopWidth = this.styleBorderTopWidth;
        node.style.paddingTop = this.stylePaddingTop;
        node.style.height = this.styleHeight;
        node.style.paddingBottom = this.stylePaddingBottom;
        node.style.borderBottomWidth = this.styleBorderBottomWidth;
    };

    Expand.prototype.render = function render() {
        var _props = this.props,
            animation = _props.animation,
            others = _objectWithoutProperties(_props, ['animation']);

        var newAnimation = animation || 'expand';

        return _react2.default.createElement(_animate2.default, _extends({}, others, {
            animation: newAnimation,
            beforeEnter: this.beforeEnter,
            onEnter: this.onEnter,
            afterEnter: this.afterEnter,
            beforeLeave: this.beforeLeave,
            onLeave: this.onLeave,
            afterLeave: this.afterLeave }));
    };

    return Expand;
}(_react.Component), _class.propTypes = {
    animation: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),
    beforeEnter: _propTypes2.default.func,
    onEnter: _propTypes2.default.func,
    afterEnter: _propTypes2.default.func,
    beforeLeave: _propTypes2.default.func,
    onLeave: _propTypes2.default.func,
    afterLeave: _propTypes2.default.func
}, _class.defaultProps = {
    beforeEnter: noop,
    onEnter: noop,
    afterEnter: noop,
    beforeLeave: noop,
    onLeave: noop,
    afterLeave: noop
}, _temp);
Expand.displayName = 'Expand';
exports.default = Expand;
module.exports = exports['default'];

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _checkableItem = __webpack_require__(58);

var _checkableItem2 = _interopRequireDefault(_checkableItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Menu.CheckboxItem
 * @order 3
 * @description 该子组件选中情况不受 defaultSelectedKeys/selectedKeys 控制，请自行控制选中逻辑
 */
var CheckboxItem = (_temp = _class = function (_Component) {
  _inherits(CheckboxItem, _Component);

  function CheckboxItem() {
    _classCallCheck(this, CheckboxItem);

    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  CheckboxItem.prototype.render = function render() {
    var _props = this.props,
        checkboxDisabled = _props.checkboxDisabled,
        others = _objectWithoutProperties(_props, ['checkboxDisabled']);

    return _react2.default.createElement(_checkableItem2.default, _extends({ role: 'menuitemcheckbox', checkType: 'checkbox', checkDisabled: checkboxDisabled }, others));
  };

  return CheckboxItem;
}(_react.Component), _class.menuChildType = 'item', _class.propTypes = {
  /**
   * 是否选中
   */
  checked: _propTypes2.default.bool,
  /**
   * 是否半选中
   */
  indeterminate: _propTypes2.default.bool,
  /**
   * 是否禁用
   */
  disabled: _propTypes2.default.bool,
  /**
   * 选中或取消选中触发的回调函数
   * @param {Boolean} checked 是否选中
   * @param {Object} event 选中事件对象
   */
  onChange: _propTypes2.default.func,
  /**
   * 帮助文本
   */
  helper: _propTypes2.default.node,
  /**
   * 标签内容
   */
  children: _propTypes2.default.node,
  checkboxDisabled: _propTypes2.default.bool
}, _class.defaultProps = {
  checked: false,
  indeterminate: false,
  disabled: false,
  onChange: function onChange() {},
  checkboxDisabled: false
}, _temp);
CheckboxItem.displayName = 'CheckboxItem';
exports.default = CheckboxItem;
module.exports = exports['default'];

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _util = __webpack_require__(2);

var _checkbox = __webpack_require__(59);

var _checkbox2 = _interopRequireDefault(_checkbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var pickOthers = _util.obj.pickOthers;

/** Checkbox.Group */

var CheckboxGroup = (_temp = _class = function (_Component) {
    _inherits(CheckboxGroup, _Component);

    function CheckboxGroup(props) {
        _classCallCheck(this, CheckboxGroup);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        var value = [];
        if ('value' in props) {
            value = props.value;
        } else if ('defaultValue' in props) {
            value = props.defaultValue;
        }
        if (!Array.isArray(value)) {
            if (value === null || value === undefined) {
                value = [];
            } else {
                value = [value];
            }
        }
        _this.state = {
            value: [].concat(value)
        };

        _this.onChange = _this.onChange.bind(_this);
        return _this;
    }

    CheckboxGroup.prototype.getChildContext = function getChildContext() {
        return {
            __group__: true,
            onChange: this.onChange,
            selectedValue: this.state.value,
            disabled: this.props.disabled
        };
    };

    CheckboxGroup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if ('value' in nextProps) {
            var value = nextProps.value;

            if (!Array.isArray(value)) {
                if (value === null || value === undefined) {
                    value = [];
                } else {
                    value = [value];
                }
            }
            this.setState({
                value: value
            });
        }
    };

    CheckboxGroup.prototype.onChange = function onChange(currentValue, e) {
        var value = this.state.value;

        var index = value.indexOf(currentValue);
        var valTemp = [].concat(value);

        if (index === -1) {
            valTemp.push(currentValue);
        } else {
            valTemp.splice(index, 1);
        }

        if (!('value' in this.props)) {
            this.setState({ value: valTemp });
        }
        this.props.onChange(valTemp, e);
    };

    CheckboxGroup.prototype.render = function render() {
        var _this2 = this,
            _classnames;

        var _props = this.props,
            className = _props.className,
            style = _props.style,
            prefix = _props.prefix,
            disabled = _props.disabled,
            itemDirection = _props.itemDirection;

        var others = pickOthers(CheckboxGroup.propTypes, this.props);

        // 如果内嵌标签跟dataSource同时存在，以内嵌标签为主
        var children = void 0;
        if (this.props.children) {
            children = this.props.children;
        } else {
            children = this.props.dataSource.map(function (item, index) {
                var option = item;
                if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) !== 'object') {
                    option = {
                        label: item,
                        value: item,
                        disabled: disabled
                    };
                }
                var checked = _this2.state.value && _this2.state.value.indexOf(option.value) > -1;

                return _react2.default.createElement(_checkbox2.default, { key: index,
                    value: option.value,
                    checked: checked,
                    disabled: disabled || option.disabled,
                    label: option.label
                });
            });
        }

        var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'checkbox-group'] = true, _classnames[prefix + 'checkbox-group-' + itemDirection] = true, _classnames[className] = !!className, _classnames.disabled = disabled, _classnames));

        return _react2.default.createElement(
            'span',
            _extends({}, others, { className: cls, style: style }),
            children
        );
    };

    return CheckboxGroup;
}(_react.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    rtl: _propTypes2.default.bool,
    /**
     * 自定义类名
     */
    className: _propTypes2.default.string,
    /**
     * 自定义内敛样式
     */
    style: _propTypes2.default.object,
    /**
     * 整体禁用
     */
    disabled: _propTypes2.default.bool,
    /**
     * 可选项列表, 数据项可为 String 或者 Object, 如 `['apple', 'pear', 'orange']` 或者 `[{value: 'apple', label: '苹果',}, {value: 'pear', label: '梨'}, {value: 'orange', label: '橙子'}]`
     */
    dataSource: _propTypes2.default.arrayOf(_propTypes2.default.any),
    /**
     * 被选中的值列表
     */
    value: _propTypes2.default.oneOfType([_propTypes2.default.array, _propTypes2.default.string, _propTypes2.default.number]),
    /**
     * 默认被选中的值列表
     */
    defaultValue: _propTypes2.default.oneOfType([_propTypes2.default.array, _propTypes2.default.string, _propTypes2.default.number]),
    /**
     * 通过子元素方式设置内部 checkbox
     */
    children: _propTypes2.default.arrayOf(_propTypes2.default.element),
    /**
     * 选中值改变时的事件
     * @param {Array} value 选中项列表
     * @param {Event} e Dom 事件对象
     */
    onChange: _propTypes2.default.func,

    /**
     * 子项目的排列方式
     * - hoz: 水平排列 (default)
     * - ver: 垂直排列
     */
    itemDirection: _propTypes2.default.oneOf(['hoz', 'ver'])
}, _class.defaultProps = {
    dataSource: [],
    onChange: function onChange() {},
    prefix: 'next-',
    itemDirection: 'hoz'
}, _class.childContextTypes = {
    onChange: _propTypes2.default.func,
    __group__: _propTypes2.default.bool,
    selectedValue: _propTypes2.default.array,
    disabled: _propTypes2.default.bool
}, _temp);
CheckboxGroup.displayName = 'CheckboxGroup';
exports.default = _configProvider2.default.config(CheckboxGroup);
module.exports = exports['default'];

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _util = __webpack_require__(2);

var _radio = __webpack_require__(62);

var _radio2 = _interopRequireDefault(_radio);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var pickOthers = _util.obj.pickOthers;

/**
 * Radio.Group
 * @order 2
 */

var RadioGroup = (_temp = _class = function (_Component) {
    _inherits(RadioGroup, _Component);

    function RadioGroup(props) {
        _classCallCheck(this, RadioGroup);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        var value = '';
        if ('value' in props) {
            value = props.value;
        } else if ('defaultValue' in props) {
            value = props.defaultValue;
        }
        _this.state = { value: value };
        _this.onChange = _this.onChange.bind(_this);
        return _this;
    }

    RadioGroup.prototype.getChildContext = function getChildContext() {
        return {
            __group__: true,
            isButton: this.props.shape === 'button',
            onChange: this.onChange,
            selectedValue: this.state.value,
            disabled: this.props.disabled
        };
    };

    RadioGroup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var value = nextProps.value;

        if ('value' in nextProps) {
            if (value === undefined) {
                value = '';
            }
            this.setState({
                value: value
            });
        }
    };

    RadioGroup.prototype.onChange = function onChange(currentValue, e) {
        if (!('value' in this.props)) {
            this.setState({ value: currentValue });
        }
        if (currentValue !== this.state.value) {
            this.props.onChange(currentValue, e);
        }
    };

    RadioGroup.prototype.render = function render() {
        var _this2 = this,
            _classnames;

        var _props = this.props,
            rtl = _props.rtl,
            className = _props.className,
            shape = _props.shape,
            size = _props.size,
            style = _props.style,
            prefix = _props.prefix,
            itemDirection = _props.itemDirection;

        var others = pickOthers(Object.keys(RadioGroup.propTypes), this.props);
        var disabled = this.props.disabled;

        if (rtl) {
            others.dir = 'rtl';
        }

        var children = void 0;
        if (this.props.children) {
            children = this.props.children;
        } else {
            children = this.props.dataSource.map(function (item, index) {
                var option = item;
                if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) !== 'object') {
                    option = {
                        label: item,
                        value: item,
                        disabled: disabled
                    };
                }
                var checked = _this2.state.value === option.value;
                return _react2.default.createElement(_radio2.default, {
                    key: index,
                    tabIndex: index === 0 && !_this2.state.value || checked ? 0 : -1,
                    value: option.value,
                    checked: checked,
                    label: option.label,
                    disabled: disabled || option.disabled
                });
            });
        }

        var isButtonShape = shape === 'button';

        var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'radio-group'] = true, _classnames[prefix + 'radio-group-' + itemDirection] = !isButtonShape, _classnames[prefix + 'radio-button'] = isButtonShape, _classnames[prefix + 'radio-button-' + size] = isButtonShape, _classnames[className] = !!className, _classnames.disabled = disabled, _classnames));

        return _react2.default.createElement(
            'div',
            _extends({}, others, { 'aria-disabled': disabled, role: 'radiogroup', className: cls, style: style }),
            children
        );
    };

    return RadioGroup;
}(_react.Component), _class.propTypes = {
    /**
     * 样式类名的品牌前缀
     */
    prefix: _propTypes2.default.string,
    rtl: _propTypes2.default.bool,
    /**
     * 自定义类名
     */
    className: _propTypes2.default.string,
    /**
     * 自定义内敛样式
     */
    style: _propTypes2.default.object,
    /**
     * name
     */
    name: _propTypes2.default.string,
    /**
     * radio group的选中项的值
     */
    value: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number, _propTypes2.default.bool]),
    /**
     * radio group的默认值
     */
    defaultValue: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number, _propTypes2.default.bool]),
    /**
     * 选中值改变时的事件
     * @param {String/Number} value 选中项的值
     * @param {Event} e Dom 事件对象
     */
    onChange: _propTypes2.default.func,
    /**
     * 表示radio被禁用
     */
    disabled: _propTypes2.default.bool,
    /**
     * 可以设置成 button 展示形状
     * @enumdesc 按钮状
     */
    shape: _propTypes2.default.oneOf(['button']),
    /**
     * 与 `shape` 属性配套使用，shape设为button时有效
     * @enumdesc 大, 中, 小
     */
    size: _propTypes2.default.oneOf(['large', 'medium', 'small']),
    /**
     * 可选项列表, 数据项可为 String 或者 Object, 如 `['apple', 'pear', 'orange']`
     */
    dataSource: _propTypes2.default.arrayOf(_propTypes2.default.any),
    /**
     * 通过子元素方式设置内部radio
     */
    children: _propTypes2.default.oneOfType([_propTypes2.default.arrayOf(_propTypes2.default.element), _propTypes2.default.element]),

    /**
     * 子项目的排列方式
     * - hoz: 水平排列 (default)
     * - ver: 垂直排列
     */
    itemDirection: _propTypes2.default.oneOf(['hoz', 'ver'])
}, _class.defaultProps = {
    dataSource: [],
    size: 'medium',
    onChange: function onChange() {},
    prefix: 'next-',
    itemDirection: 'hoz'
}, _class.childContextTypes = {
    onChange: _propTypes2.default.func,
    __group__: _propTypes2.default.bool,
    isButton: _propTypes2.default.bool,
    selectedValue: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number, _propTypes2.default.bool]),
    disabled: _propTypes2.default.bool
}, _temp);
RadioGroup.displayName = 'RadioGroup';
exports.default = _configProvider2.default.config(RadioGroup);
module.exports = exports['default'];

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _checkableItem = __webpack_require__(58);

var _checkableItem2 = _interopRequireDefault(_checkableItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Menu.RadioItem
 * @order 4
 * @description 该子组件选中情况不受 defaultSelectedKeys/selectedKeys 控制，请自行控制选中逻辑
 */
var RadioItem = (_temp = _class = function (_Component) {
  _inherits(RadioItem, _Component);

  function RadioItem() {
    _classCallCheck(this, RadioItem);

    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  RadioItem.prototype.render = function render() {
    return _react2.default.createElement(_checkableItem2.default, _extends({ role: 'menuitemradio', checkType: 'radio' }, this.props));
  };

  return RadioItem;
}(_react.Component), _class.menuChildType = 'item', _class.propTypes = {
  /**
   * 是否选中
   */
  checked: _propTypes2.default.bool,
  /**
   * 是否禁用
   */
  disabled: _propTypes2.default.bool,
  /**
   * 选中或取消选中触发的回调函数
   * @param {Boolean} checked 是否选中
   * @param {Object} event 选中事件对象
   */
  onChange: _propTypes2.default.func,
  /**
   * 帮助文本
   */
  helper: _propTypes2.default.node,
  /**
   * 标签内容
   */
  children: _propTypes2.default.node
}, _class.defaultProps = {
  checked: false,
  disabled: false,
  onChange: function onChange() {}
}, _temp);
RadioItem.displayName = 'RadioItem';
exports.default = RadioItem;
module.exports = exports['default'];

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _item = __webpack_require__(14);

var _item2 = _interopRequireDefault(_item);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Menu.Group
 * @order 5
 */
var Group = (_temp = _class = function (_Component) {
    _inherits(Group, _Component);

    function Group() {
        _classCallCheck(this, Group);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    Group.prototype.render = function render() {
        var _cx;

        var _props = this.props,
            root = _props.root,
            className = _props.className,
            label = _props.label,
            children = _props.children,
            parentMode = _props.parentMode,
            others = _objectWithoutProperties(_props, ['root', 'className', 'label', 'children', 'parentMode']);

        var prefix = root.props.prefix;


        var newClassName = (0, _classnames2.default)((_cx = {}, _cx[prefix + 'menu-group-label'] = true, _cx[className] = !!className, _cx));

        var newChildren = children.map(function (child) {
            var _cx2;

            var className = child.props.className;

            var newChildClassName = (0, _classnames2.default)((_cx2 = {}, _cx2[prefix + 'menu-group-item'] = true, _cx2[className] = !!className, _cx2));

            return (0, _react.cloneElement)(child, {
                parentMode: parentMode,
                className: newChildClassName
            });
        });

        return [_react2.default.createElement(
            _item2.default,
            _extends({
                key: 'menu-group-label',
                className: newClassName,
                replaceClassName: true,
                root: root,
                parentMode: parentMode
            }, others),
            label
        )].concat(newChildren);
    };

    return Group;
}(_react.Component), _class.menuChildType = 'group', _class.propTypes = {
    root: _propTypes2.default.object,
    className: _propTypes2.default.string,
    /**
     * 标签内容
     */
    label: _propTypes2.default.node,
    /**
     * 菜单项
     */
    children: _propTypes2.default.node,
    parentMode: _propTypes2.default.oneOf(['inline', 'popup'])
}, _temp);
Group.displayName = 'Group';
exports.default = Group;
module.exports = exports['default'];

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Menu.Divider
 * @order 6
 */
var Divider = (_temp = _class = function (_Component) {
    _inherits(Divider, _Component);

    function Divider() {
        _classCallCheck(this, Divider);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    Divider.prototype.render = function render() {
        var _cx;

        var _props = this.props,
            root = _props.root,
            className = _props.className,
            others = _objectWithoutProperties(_props, ['root', 'className']);

        var prefix = root.props.prefix;


        var newClassName = (0, _classnames2.default)((_cx = {}, _cx[prefix + 'menu-divider'] = true, _cx[className] = !!className, _cx));

        return _react2.default.createElement('li', _extends({ role: 'separator', className: newClassName }, others));
    };

    return Divider;
}(_react.Component), _class.menuChildType = 'divider', _class.propTypes = {
    root: _propTypes2.default.object,
    className: _propTypes2.default.string
}, _temp);
Divider.displayName = 'Divider';
exports.default = Divider;
module.exports = exports['default'];

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

exports.default = create;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _overlay = __webpack_require__(15);

var _overlay2 = _interopRequireDefault(_overlay);

var _util = __webpack_require__(2);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _menu = __webpack_require__(50);

var _menu2 = _interopRequireDefault(_menu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var bindCtx = _util.func.bindCtx;
var getContextProps = _configProvider2.default.getContextProps;

var Menu = _configProvider2.default.config(_menu2.default);

var menuInstance = void 0;

var ContextMenu = (_temp = _class = function (_Component) {
    _inherits(ContextMenu, _Component);

    function ContextMenu(props) {
        _classCallCheck(this, ContextMenu);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        _this.state = {
            visible: true
        };

        bindCtx(_this, ['handleOverlayClose', 'handleOverlayOpen', 'handleItemClick', 'getOverlay']);
        return _this;
    }

    ContextMenu.prototype.getOverlay = function getOverlay(ref) {
        this.overlay = ref;
    };

    ContextMenu.prototype.close = function close() {
        this.setState({
            visible: false
        });
        menuInstance = null;
    };

    ContextMenu.prototype.handleOverlayClose = function handleOverlayClose(triggerType, e) {
        var clickedPopupMenu = triggerType === 'docClick' && this.popupNodes.some(function (node) {
            return node.contains(e.target);
        });
        if (!clickedPopupMenu) {
            this.close();
            var overlayProps = this.props.overlayProps;

            if (overlayProps && overlayProps.onRequestClose) {
                for (var _len = arguments.length, others = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                    others[_key - 2] = arguments[_key];
                }

                overlayProps.onRequestClose.apply(overlayProps, [triggerType, e].concat(others));
            }
        }
    };

    ContextMenu.prototype.handleOverlayOpen = function handleOverlayOpen() {
        this.popupNodes = this.overlay.getInstance().getContent().getInstance().popupNodes;
        var overlayProps = this.props.overlayProps;

        if (overlayProps && overlayProps.onOpen) {
            overlayProps.onOpen();
        }
    };

    ContextMenu.prototype.handleItemClick = function handleItemClick() {
        var _props;

        this.close();

        this.props.onItemClick && (_props = this.props).onItemClick.apply(_props, arguments);
    };

    ContextMenu.prototype.render = function render() {
        var _cx, _cx2;

        var _props2 = this.props,
            className = _props2.className,
            popupClassName = _props2.popupClassName,
            target = _props2.target,
            align = _props2.align,
            offset = _props2.offset,
            afterClose = _props2.afterClose,
            _props2$overlayProps = _props2.overlayProps,
            overlayProps = _props2$overlayProps === undefined ? {} : _props2$overlayProps,
            others = _objectWithoutProperties(_props2, ['className', 'popupClassName', 'target', 'align', 'offset', 'afterClose', 'overlayProps']);

        var contextProps = getContextProps(this.props);
        var prefix = contextProps.prefix;
        var visible = this.state.visible;


        var newOverlayProps = _extends({}, contextProps, overlayProps, {
            target: target, align: align, offset: offset, afterClose: afterClose, visible: visible,
            onRequestClose: this.handleOverlayClose,
            onOpen: this.handleOverlayOpen,
            ref: this.getOverlay
        });
        var menuProps = _extends({}, contextProps, {
            triggerType: 'hover'
        }, others, {
            className: (0, _classnames2.default)((_cx = {}, _cx[prefix + 'context'] = true, _cx[className] = !!className, _cx)),
            popupClassName: (0, _classnames2.default)((_cx2 = {}, _cx2[prefix + 'context'] = true, _cx2[popupClassName] = !!popupClassName, _cx2)),
            onItemClick: this.handleItemClick
        });

        newOverlayProps.rtl = false;

        return _react2.default.createElement(
            _overlay2.default,
            newOverlayProps,
            _react2.default.createElement(Menu, menuProps)
        );
    };

    return ContextMenu;
}(_react.Component), _class.propTypes = {
    className: _propTypes2.default.string,
    popupClassName: _propTypes2.default.string,
    target: _propTypes2.default.any,
    align: _propTypes2.default.string,
    offset: _propTypes2.default.array,
    overlayProps: _propTypes2.default.object,
    afterClose: _propTypes2.default.func,
    mode: _propTypes2.default.oneOf(['inline', 'popup']),
    onOpen: _propTypes2.default.func,
    onItemClick: _propTypes2.default.func
}, _class.defaultProps = {
    prefix: 'next-',
    align: 'tl tl',
    mode: 'popup'
}, _temp);

/**
 * 创建上下文菜单
 * @exportName create
 * @param {Object} props 属性对象
 */

ContextMenu.displayName = 'ContextMenu';
function create(props) {
    if (menuInstance) {
        menuInstance.destroy();
    }

    /* eslint-disable no-unused-vars */

    var afterClose = props.afterClose,
        others = _objectWithoutProperties(props, ['afterClose']);
    /* eslint-enable no-unused-vars */

    var div = document.createElement('div');
    document.body.appendChild(div);

    var closeChain = function closeChain() {
        (0, _reactDom.unmountComponentAtNode)(div);
        document.body.removeChild(div);

        afterClose && afterClose();
    };

    var newContext = _configProvider2.default.getContext();

    var menu = void 0;
    (0, _reactDom.render)(_react2.default.createElement(
        _configProvider2.default,
        newContext,
        _react2.default.createElement(ContextMenu, _extends({ ref: function ref(_ref) {
                menu = _ref;
            }, afterClose: closeChain }, others))
    ), div);

    menuInstance = {
        destroy: function destroy() {
            if (menu) {
                menu.close();
            }
        }
    };

    return menuInstance;
}
module.exports = exports['default'];

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function mapIconSize(size) {
    return {
        large: 'small',
        medium: 'xs',
        small: 'xs'
    }[size];
}

/** Button */
var Button = (_temp2 = _class = function (_Component) {
    _inherits(Button, _Component);

    function Button() {
        var _temp, _this, _ret;

        _classCallCheck(this, Button);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.onMouseUp = function (e) {
            _this.button.blur();

            if (_this.props.onMouseUp) {
                _this.props.onMouseUp(e);
            }
        }, _this.buttonRefHandler = function (button) {
            _this.button = button;
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Button.prototype.render = function render() {
        var _classNames;

        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            type = _props.type,
            size = _props.size,
            htmlType = _props.htmlType,
            loading = _props.loading,
            text = _props.text,
            warning = _props.warning,
            ghost = _props.ghost,
            component = _props.component,
            iconSize = _props.iconSize,
            children = _props.children,
            rtl = _props.rtl,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'type', 'size', 'htmlType', 'loading', 'text', 'warning', 'ghost', 'component', 'iconSize', 'children', 'rtl']);

        var ghostType = ['light', 'dark'].indexOf(ghost) >= 0 ? ghost : 'dark';

        var btnCls = (0, _classnames2.default)((_classNames = {}, _classNames[prefix + 'btn'] = true, _classNames['' + prefix + size] = size, _classNames[prefix + 'btn-' + type] = type && !ghost, _classNames[prefix + 'btn-text'] = text, _classNames[prefix + 'btn-warning'] = warning, _classNames[prefix + 'btn-loading'] = loading, _classNames[prefix + 'btn-ghost'] = ghost, _classNames[prefix + 'btn-' + ghostType] = ghost, _classNames[className] = className, _classNames));

        var count = _react.Children.count(children);
        var clonedChildren = _react.Children.map(children, function (child, index) {
            if (child && typeof child.type === 'function' && child.type._typeMark === 'icon') {
                var _classNames2;

                var iconCls = (0, _classnames2.default)((_classNames2 = {}, _classNames2[prefix + 'btn-icon'] = !iconSize, _classNames2[prefix + 'icon-first'] = count > 1 && index === 0, _classNames2[prefix + 'icon-last'] = count > 1 && index === count - 1, _classNames2[prefix + 'icon-alone'] = count === 1, _classNames2[child.props.className] = !!child.props.className, _classNames2));
                return _react2.default.cloneElement(child, {
                    className: iconCls,
                    size: iconSize || mapIconSize(size)
                });
            }

            return child;
        });

        var TagName = component;
        var tagAttrs = _extends({}, others, {
            type: htmlType,
            className: btnCls
        });

        if (TagName === 'a') {
            delete tagAttrs.type;

            if (tagAttrs.disabled) {
                delete tagAttrs.onClick; // a 标签的 onClick 浏览器默认不会禁用
                tagAttrs.href && delete tagAttrs.href; // a 标签在禁用状态下无跳转
            }
        }

        return _react2.default.createElement(
            TagName,
            _extends({}, tagAttrs, { dir: rtl ? 'rtl' : undefined, onMouseUp: this.onMouseUp, ref: this.buttonRefHandler, role: 'button' }),
            clonedChildren
        );
    };

    return Button;
}(_react.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    rtl: _propTypes2.default.bool,
    /**
     * 按钮的类型
     */
    type: _propTypes2.default.oneOf(['primary', 'secondary', 'normal']),
    /**
     * 按钮的尺寸
     */
    size: _propTypes2.default.oneOf(['small', 'medium', 'large']),
    /**
     * 按钮中 Icon 的尺寸，用于替代 Icon 的默认大小
     */
    iconSize: _propTypes2.default.oneOf(['xxs', 'xs', 'small', 'medium', 'large', 'xl', 'xxl', 'xxxl']),
    /**
     * 当 component = 'button' 时，设置 button 标签的 type 值
     */
    htmlType: _propTypes2.default.oneOf(['submit', 'reset', 'button']),
    /**
     * 设置标签类型
     */
    component: _propTypes2.default.oneOf(['button', 'a']),
    /**
     * 设置按钮的载入状态
     */
    loading: _propTypes2.default.bool,
    /**
     * 是否为幽灵按钮
     */
    ghost: _propTypes2.default.oneOf([true, false, 'light', 'dark']),
    /**
     * 是否为文本按钮
     */
    text: _propTypes2.default.bool,
    /**
     * 是否为警告按钮
     */
    warning: _propTypes2.default.bool,
    /**
     * 是否禁用
     */
    disabled: _propTypes2.default.bool,
    /**
     * 点击按钮的回调
     * @param {Object} e Event Object
     */
    onClick: _propTypes2.default.func,
    className: _propTypes2.default.string,
    onMouseUp: _propTypes2.default.func,
    children: _propTypes2.default.node
}, _class.defaultProps = {
    prefix: 'next-',
    type: 'normal',
    size: 'medium',
    htmlType: 'button',
    component: 'button',
    loading: false,
    ghost: false,
    text: false,
    warning: false,
    disabled: false,
    onClick: function onClick() {}
}, _temp2);
Button.displayName = 'Button';
exports.default = Button;
module.exports = exports['default'];

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Button.Group
 */
var ButtonGroup = (_temp = _class = function (_Component) {
    _inherits(ButtonGroup, _Component);

    function ButtonGroup() {
        _classCallCheck(this, ButtonGroup);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    ButtonGroup.prototype.render = function render() {
        var _classNames;

        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            size = _props.size,
            children = _props.children,
            rtl = _props.rtl,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'size', 'children', 'rtl']);

        var groupCls = (0, _classnames2.default)((_classNames = {}, _classNames[prefix + 'btn-group'] = true, _classNames[className] = className, _classNames));

        var cloneChildren = _react.Children.map(children, function (child) {
            if (child) {
                return _react2.default.cloneElement(child, {
                    size: size
                });
            }
        });

        if (rtl) {
            others.dir = 'rtl';
        }

        return _react2.default.createElement(
            'div',
            _extends({}, others, { className: groupCls }),
            cloneChildren
        );
    };

    return ButtonGroup;
}(_react.Component), _class.propTypes = {
    rtl: _propTypes2.default.bool,
    prefix: _propTypes2.default.string,
    /**
     * 统一设置 Button 组件的按钮大小
     */
    size: _propTypes2.default.string,
    className: _propTypes2.default.string,
    children: _propTypes2.default.node
}, _class.defaultProps = {
    prefix: 'next-',
    size: 'medium'
}, _temp);
ButtonGroup.displayName = 'ButtonGroup';
exports.default = _configProvider2.default.config(ButtonGroup);
module.exports = exports['default'];

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var Resize = (_temp2 = _class = function (_React$Component) {
    _inherits(Resize, _React$Component);

    function Resize() {
        var _temp, _this, _ret;

        _classCallCheck(this, Resize);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onMouseDown = function (e) {
            _this.lastPageX = e.pageX;
            _util.events.on(document, 'mousemove', _this.onMouseMove);
            _util.events.on(document, 'mouseup', _this.onMouseUp);
            _this.unSelect();
        }, _this.onMouseMove = function (e) {
            var pageX = e.pageX;
            var changedPageX = pageX - _this.lastPageX;
            _this.props.onChange(_this.props.dataIndex, changedPageX);
            _this.lastPageX = pageX;
        }, _this.onMouseUp = function () {
            _this.destory();
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Resize.prototype.componentWillUnmount = function componentWillUnmount() {
        this.destory();
    };

    Resize.prototype.destory = function destory() {
        _util.events.off(document, 'mousemove', this.onMouseMove);
        _util.events.off(document, 'mouseup', this.onMouseMove);
        this.select();
    };

    Resize.prototype.unSelect = function unSelect() {
        _util.dom.setStyle(document.body, {
            userSelect: 'none',
            cursor: 'ew-resize'
        });
        document.body.setAttribute('unselectable', 'on');
    };

    Resize.prototype.select = function select() {
        _util.dom.setStyle(document.body, {
            userSelect: '',
            cursor: ''
        });
        document.body.removeAttribute('unselectable');
    };

    Resize.prototype.render = function render() {
        var prefix = this.props.prefix;

        return _react2.default.createElement('a', { className: prefix + 'table-resize-handler', onMouseDown: this.onMouseDown });
    };

    return Resize;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    onChange: _propTypes2.default.func,
    dataIndex: _propTypes2.default.string
}, _class.defaultProps = {
    onChange: function onChange() {}
}, _temp2);
Resize.displayName = 'Resize';
exports.default = Resize;
module.exports = exports['default'];

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var Wrapper = function (_Component) {
    _inherits(Wrapper, _Component);

    function Wrapper() {
        _classCallCheck(this, Wrapper);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    Wrapper.prototype.render = function render() {
        var _props = this.props,
            colGroup = _props.colGroup,
            children = _props.children,
            Tag = _props.component;

        return _react2.default.createElement(
            Tag,
            { role: 'table' },
            colGroup,
            children
        );
    };

    return Wrapper;
}(_react.Component);

Wrapper.displayName = 'Wrapper';
exports.default = Wrapper;


Wrapper.defaultProps = {
    component: 'table'
};

Wrapper.propTypes = {
    children: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    colGroup: _propTypes2.default.any,
    component: _propTypes2.default.string
};
module.exports = exports['default'];

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Table.ColumnGroup
 * @order 1
 **/
var ColumnGroup = (_temp = _class = function (_React$Component) {
    _inherits(ColumnGroup, _React$Component);

    function ColumnGroup() {
        _classCallCheck(this, ColumnGroup);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    ColumnGroup.prototype.getChildContext = function getChildContext() {
        return {
            parent: this
        };
    };

    ColumnGroup.prototype.render = function render() {
        return null;
    };

    return ColumnGroup;
}(_react2.default.Component), _class.propTypes = {
    /**
     * 表头显示的内容
     */
    title: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.node, _propTypes2.default.func])
}, _class.childContextTypes = {
    parent: _propTypes2.default.any
}, _class.defaultProps = {
    title: 'column-group'
}, _class._typeMark = 'columnGroup', _temp);
ColumnGroup.displayName = 'ColumnGroup';
exports.default = ColumnGroup;
module.exports = exports['default'];

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = tree;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _row = __webpack_require__(124);

var _row2 = _interopRequireDefault(_row);

var _cell = __webpack_require__(125);

var _cell2 = _interopRequireDefault(_cell);

var _util = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};

function tree(BaseComponent) {
    var _class, _temp;

    var TreeTable = (_temp = _class = function (_React$Component) {
        _inherits(TreeTable, _React$Component);

        function TreeTable(props, context) {
            _classCallCheck(this, TreeTable);

            var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

            _this.onTreeNodeClick = function (record) {
                var primaryKey = _this.props.primaryKey,
                    id = record[primaryKey],
                    dataSource = _this.ds,
                    openRowKeys = [].concat(_this.state.openRowKeys),
                    index = openRowKeys.indexOf(id),
                    getChildrenKeyById = function getChildrenKeyById(id) {
                    var ret = [id];
                    var loop = function loop(data) {
                        data.forEach(function (item) {
                            ret.push(item[primaryKey]);
                            if (item.children) {
                                loop(item.children);
                            }
                        });
                    };
                    dataSource.forEach(function (item) {
                        if (item[primaryKey] === id) {
                            if (item.children) {
                                loop(item.children);
                            }
                        }
                    });
                    return ret;
                };


                if (index > -1) {
                    // 不仅要删除当前的openRowKey，还需要删除关联子节点的openRowKey
                    var ids = getChildrenKeyById(id);
                    ids.forEach(function (id) {
                        var i = openRowKeys.indexOf(id);
                        if (i > -1) {
                            openRowKeys.splice(i, 1);
                        }
                    });
                } else {
                    openRowKeys.push(id);
                }

                if (!('openRowKeys' in _this.props)) {
                    _this.setState({
                        openRowKeys: openRowKeys
                    });
                }
                _this.props.onRowOpen(openRowKeys, id, index === -1, record);
            };

            _this.state = {
                openRowKeys: props.openRowKeys || []
            };
            return _this;
        }

        TreeTable.prototype.getChildContext = function getChildContext() {
            return {
                openTreeRowKeys: this.state.openRowKeys,
                indent: this.props.indent,
                treeStatus: this.getTreeNodeStatus(this.ds),
                onTreeNodeClick: this.onTreeNodeClick,
                isTree: this.props.isTree
            };
        };

        TreeTable.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
            if ('openRowKeys' in nextProps) {
                var openRowKeys = nextProps.openRowKeys;

                this.setState({
                    openRowKeys: openRowKeys
                });
            }
        };

        TreeTable.prototype.normalizeDataSource = function normalizeDataSource(dataSource) {
            var ret = [],
                loop = function loop(dataSource, level) {
                dataSource.forEach(function (item) {
                    item.__level = level;
                    ret.push(item);
                    if (item.children) {
                        loop(item.children, level + 1);
                    }
                });
            };
            loop(dataSource, 0);
            this.ds = ret;
            return ret;
        };

        TreeTable.prototype.getTreeNodeStatus = function getTreeNodeStatus() {
            var dataSource = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            var openRowKeys = this.state.openRowKeys,
                primaryKey = this.props.primaryKey,
                ret = [];


            openRowKeys.forEach(function (openKey) {
                dataSource.forEach(function (item) {
                    if (item[primaryKey] === openKey) {
                        if (item.children) {
                            item.children.forEach(function (child) {
                                ret.push(child[primaryKey]);
                            });
                        }
                    }
                });
            });
            return ret;
        };

        TreeTable.prototype.render = function render() {
            /* eslint-disable no-unused-vars, prefer-const */
            var _props = this.props,
                components = _props.components,
                isTree = _props.isTree,
                dataSource = _props.dataSource,
                indent = _props.indent,
                others = _objectWithoutProperties(_props, ['components', 'isTree', 'dataSource', 'indent']);

            if (isTree) {
                components = _extends({}, components);
                if (!components.Row) {
                    components.Row = _row2.default;
                }
                if (!components.Cell) {
                    components.Cell = _cell2.default;
                }

                dataSource = this.normalizeDataSource(dataSource);
            }
            return _react2.default.createElement(BaseComponent, _extends({}, others, { dataSource: dataSource, components: components }));
        };

        return TreeTable;
    }(_react2.default.Component), _class.TreeRow = _row2.default, _class.TreeCell = _cell2.default, _class.propTypes = _extends({
        /**
         * 默认情况下展开的树形表格，传入了此属性代表tree的展开为受控操作
         */
        openRowKeys: _propTypes2.default.array,
        /**
         * 点击tree展开或者关闭的时候触发的事件
         * @param {Array} openRowKeys tree模式下展开的key
         * @param {String} currentRowKey 当前点击行的key
         * @param {Boolean} opened 当前点击是展开还是收起
         * @param {Object} currentRecord 当前点击行的记录
         */
        onRowOpen: _propTypes2.default.func,
        /**
         * dataSource当中数据的主键，如果给定的数据源中的属性不包含该主键，会造成选择状态全部选中
         */
        primaryKey: _propTypes2.default.string,
        /**
         * 在tree模式下的缩进尺寸， 仅在isTree为true时候有效
         */
        indent: _propTypes2.default.number,
        /**
         * 开启Table的tree模式, 接收的数据格式中包含children则渲染成tree table
         */
        isTree: _propTypes2.default.bool,
        locale: _propTypes2.default.object
    }, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps, {
        primaryKey: 'id',
        onRowOpen: noop,
        components: {},
        indent: 12
    }), _class.childContextTypes = {
        openTreeRowKeys: _propTypes2.default.array,
        indent: _propTypes2.default.number,
        treeStatus: _propTypes2.default.array,
        onTreeNodeClick: _propTypes2.default.func,
        isTree: _propTypes2.default.bool
    }, _temp);
    TreeTable.displayName = 'TreeTable';

    (0, _util.statics)(TreeTable, BaseComponent);
    return TreeTable;
}
module.exports = exports['default'];

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _row = __webpack_require__(64);

var _row2 = _interopRequireDefault(_row);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var TreeRow = (_temp = _class = function (_React$Component) {
    _inherits(TreeRow, _React$Component);

    function TreeRow() {
        _classCallCheck(this, TreeRow);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    TreeRow.prototype.render = function render() {
        var _classnames;

        /* eslint-disable no-unused-vars*/
        var _props = this.props,
            className = _props.className,
            record = _props.record,
            primaryKey = _props.primaryKey,
            prefix = _props.prefix,
            others = _objectWithoutProperties(_props, ['className', 'record', 'primaryKey', 'prefix']);

        var _context = this.context,
            treeStatus = _context.treeStatus,
            openRowKeys = _context.openRowKeys;

        var cls = (0, _classnames3.default)((_classnames = {
            hidden: !(treeStatus.indexOf(record[primaryKey]) > -1) && record.__level !== 0
        }, _classnames[prefix + 'table-row-level-' + record.__level] = true, _classnames.opened = openRowKeys.indexOf(record[primaryKey]) > -1, _classnames));
        return _react2.default.createElement(_row2.default, _extends({}, others, { record: record, className: cls, primaryKey: primaryKey, prefix: prefix }));
    };

    return TreeRow;
}(_react2.default.Component), _class.propTypes = _extends({}, _row2.default.propTypes), _class.defaultProps = _extends({}, _row2.default.defaultProps), _class.contextTypes = {
    treeStatus: _propTypes2.default.array,
    openRowKeys: _propTypes2.default.array
}, _temp);
TreeRow.displayName = 'TreeRow';
exports.default = TreeRow;
module.exports = exports['default'];

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

var _cell = __webpack_require__(18);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var TreeCell = (_temp2 = _class = function (_React$Component) {
    _inherits(TreeCell, _React$Component);

    function TreeCell() {
        var _temp, _this, _ret;

        _classCallCheck(this, TreeCell);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onTreeNodeClick = function (record, e) {
            e.stopPropagation();
            _this.context.onTreeNodeClick(record);
        }, _this.expandedKeydown = function (record, e) {
            e.preventDefault();
            e.stopPropagation();

            if (e.keyCode === _util.KEYCODE.ENTER) {
                _this.onTreeNodeClick(record, e);
            }
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    TreeCell.prototype.render = function render() {
        var _this2 = this;

        var _props = this.props,
            colIndex = _props.colIndex,
            record = _props.record,
            prefix = _props.prefix,
            primaryKey = _props.primaryKey,
            locale = _props.locale;
        var _context = this.context,
            openRowKeys = _context.openTreeRowKeys,
            indent = _context.indent,
            isTree = _context.isTree,
            rowSelection = _context.rowSelection;

        var treeArrowNodeIndex = rowSelection ? 1 : 0;
        var firstCellStyle = void 0,
            treeArrowNode = void 0;
        if (colIndex === treeArrowNodeIndex) {
            var treeArrowType = void 0;
            if (isTree) {
                firstCellStyle = {
                    paddingLeft: indent * (record.__level + 1)
                };
                treeArrowNode = _react2.default.createElement(_icon2.default, { size: 'xs', className: prefix + 'table-tree-placeholder' });
                if (record.children && record.children.length) {
                    var hasExpanded = openRowKeys.indexOf(record[primaryKey]) > -1;

                    treeArrowType = hasExpanded ? 'arrow-down' : 'arrow-right';

                    treeArrowNode = _react2.default.createElement(_icon2.default, {
                        className: prefix + 'table-tree-arrow',
                        type: treeArrowType,
                        size: 'xs',
                        onClick: function onClick(e) {
                            return _this2.onTreeNodeClick(record, e);
                        },
                        onKeyDown: function onKeyDown(e) {
                            return _this2.expandedKeydown(record, e);
                        },
                        role: 'button',
                        tabIndex: '0',
                        'aria-expanded': hasExpanded,
                        'aria-label': hasExpanded ? locale.expanded : locale.folded });
                }
            }
        }
        return _react2.default.createElement(
            _cell2.default,
            _extends({}, this.props, { innerStyle: firstCellStyle }),
            treeArrowNode
        );
    };

    return TreeCell;
}(_react2.default.Component), _class.propTypes = _extends({
    indent: _propTypes2.default.number,
    locale: _propTypes2.default.object
}, _cell2.default.propTypes), _class.defaultProps = _extends({}, _cell2.default.defaultProps, {
    component: 'td',
    indent: 20
}), _class.contextTypes = {
    openTreeRowKeys: _propTypes2.default.array,
    indent: _propTypes2.default.number,
    onTreeNodeClick: _propTypes2.default.func,
    isTree: _propTypes2.default.bool,
    rowSelection: _propTypes2.default.object
}, _temp2);
TreeCell.displayName = 'TreeCell';
exports.default = TreeCell;
module.exports = exports['default'];

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = fixed;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _util = __webpack_require__(2);

var _header = __webpack_require__(19);

var _header2 = _interopRequireDefault(_header);

var _body = __webpack_require__(67);

var _body2 = _interopRequireDefault(_body);

var _wrapper = __webpack_require__(24);

var _wrapper2 = _interopRequireDefault(_wrapper);

var _util2 = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function fixed(BaseComponent) {
    var _class, _temp2;

    /** Table */
    var FixedTable = (_temp2 = _class = function (_React$Component) {
        _inherits(FixedTable, _React$Component);

        function FixedTable() {
            var _temp, _this, _ret;

            _classCallCheck(this, FixedTable);

            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.getNode = function (type, node, lockType) {
                lockType = lockType ? lockType.charAt(0).toUpperCase() + lockType.substr(1) : '';
                _this['' + type + lockType + 'Node'] = node;
                if (type === 'header' && !lockType) {
                    _this.innerHeaderNode = _this.headerNode.querySelector('div');
                }
            }, _this.onBodyScroll = function () {
                _this.scrollTo(_this.bodyNode.scrollLeft, _this.bodyNode.scrollTop);
            }, _temp), _possibleConstructorReturn(_this, _ret);
        }

        FixedTable.prototype.getChildContext = function getChildContext() {
            return {
                fixedHeader: this.props.fixedHeader,
                maxBodyHeight: this.props.maxBodyHeight,
                onBodyScroll: this.onBodyScroll,
                getNode: this.getNode
            };
        };

        FixedTable.prototype.componentDidMount = function componentDidMount() {
            this.adjustFixedHeaderSize();
        };

        FixedTable.prototype.componentDidUpdate = function componentDidUpdate() {
            this.adjustFixedHeaderSize();
        };

        FixedTable.prototype.adjustFixedHeaderSize = function adjustFixedHeaderSize() {
            var _props = this.props,
                hasHeader = _props.hasHeader,
                fixedHeader = _props.fixedHeader,
                maxBodyHeight = _props.maxBodyHeight;

            if (hasHeader && fixedHeader && !this.props.lockType) {
                if (this.bodyNode.scrollHeight <= maxBodyHeight) {
                    _util.dom.setStyle(this.headerNode, 'paddingRight', 0);
                } else {
                    _util.dom.setStyle(this.headerNode, 'paddingRight', _util.dom.scrollbar().width);
                }
            }
        };

        FixedTable.prototype.scrollTo = function scrollTo(x) {
            if (this.innerHeaderNode) {
                this.innerHeaderNode.scrollLeft = x;
            }
        };

        FixedTable.prototype.render = function render() {
            /* eslint-disable no-unused-vars, prefer-const */
            var _props2 = this.props,
                components = _props2.components,
                className = _props2.className,
                prefix = _props2.prefix,
                fixedHeader = _props2.fixedHeader,
                maxBodyHeight = _props2.maxBodyHeight,
                others = _objectWithoutProperties(_props2, ['components', 'className', 'prefix', 'fixedHeader', 'maxBodyHeight']);

            if (fixedHeader) {
                var _classnames;

                components = _extends({}, components);
                if (!components.Header) {
                    components.Header = _header2.default;
                }
                if (!components.Body) {
                    components.Body = _body2.default;
                }
                if (!components.Wrapper) {
                    components.Wrapper = _wrapper2.default;
                }
                className = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-fixed'] = true, _classnames[className] = className, _classnames));
            }
            return _react2.default.createElement(BaseComponent, _extends({}, others, { components: components, className: className, prefix: prefix }));
        };

        return FixedTable;
    }(_react2.default.Component), _class.FixedHeader = _header2.default, _class.FixedBody = _body2.default, _class.FixedWrapper = _wrapper2.default, _class.propTypes = _extends({
        /**
          * 是否具有表头
          */
        hasHeader: _propTypes2.default.bool,
        /**
          * 表头是否固定，该属性配合maxBodyHeight使用，当内容区域的高度超过maxBodyHeight的时候，在内容区域会出现滚动条
          */
        fixedHeader: _propTypes2.default.bool,
        /**
         * 最大内容区域的高度,在`fixedHeader`为`true`的时候,超过这个高度会出现滚动条
         */
        maxBodyHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string])
    }, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps, {
        hasHeader: true,
        fixedHeader: false,
        maxBodyHeight: 200,
        components: {},
        refs: {},
        prefix: 'next-'
    }), _class.childContextTypes = {
        fixedHeader: _propTypes2.default.bool,
        maxBodyHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
        onBodyScroll: _propTypes2.default.func,
        getNode: _propTypes2.default.func
    }, _temp2);
    FixedTable.displayName = 'FixedTable';

    (0, _util2.statics)(FixedTable, BaseComponent);
    return FixedTable;
}
module.exports = exports['default'];

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = selection;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _checkbox = __webpack_require__(37);

var _checkbox2 = _interopRequireDefault(_checkbox);

var _radio = __webpack_require__(61);

var _radio2 = _interopRequireDefault(_radio);

var _util = __webpack_require__(2);

var _zhCn = __webpack_require__(35);

var _zhCn2 = _interopRequireDefault(_zhCn);

var _row = __webpack_require__(64);

var _row2 = _interopRequireDefault(_row);

var _column = __webpack_require__(23);

var _column2 = _interopRequireDefault(_column);

var _util2 = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var makeChain = _util.func.makeChain;


var unique = function unique(arr) {
    var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'this';

    var temp = {},
        ret = [];
    arr.forEach(function (item) {
        var value = void 0;
        if (key === 'this') {
            value = item;
        } else {
            value = item[key];
        }
        if (!temp[value]) {
            ret.push(item);
            temp[value] = true;
        }
    });
    return ret;
};

function selection(BaseComponent) {
    var _class, _temp;

    /** Table */
    var SelectionTable = (_temp = _class = function (_React$Component) {
        _inherits(SelectionTable, _React$Component);

        function SelectionTable(props, context) {
            _classCallCheck(this, SelectionTable);

            var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

            _this.renderSelectionHeader = function () {
                var onChange = _this.selectAllRow,
                    attrs = {},
                    _this$props = _this.props,
                    rowSelection = _this$props.rowSelection,
                    primaryKey = _this$props.primaryKey,
                    dataSource = _this$props.dataSource,
                    locale = _this$props.locale,
                    selectedRowKeys = _this.state.selectedRowKeys,
                    mode = rowSelection.mode ? rowSelection.mode : 'multiple';

                var checked = !!selectedRowKeys.length;
                var indeterminate = false;
                _this.flatDataSource(dataSource).filter(function (record, index) {
                    if (!rowSelection.getProps) {
                        return true;
                    } else {
                        return !(rowSelection.getProps(record, index) || {}).disabled;
                    }
                }).map(function (record) {
                    return record[primaryKey];
                }).forEach(function (id) {
                    if (selectedRowKeys.indexOf(id) === -1) {
                        checked = false;
                    } else {
                        indeterminate = true;
                    }
                });
                attrs.onClick = makeChain(function (e) {
                    e.stopPropagation();
                }, attrs.onClick);

                if (checked) {
                    indeterminate = false;
                }
                return mode === 'multiple' ? _react2.default.createElement(_checkbox2.default, _extends({ indeterminate: indeterminate, 'aria-label': locale.selectAll, checked: checked, onChange: onChange }, attrs)) : null;
            };

            _this.renderSelectionBody = function (value, index, record) {
                var _this$props2 = _this.props,
                    rowSelection = _this$props2.rowSelection,
                    primaryKey = _this$props2.primaryKey;
                var selectedRowKeys = _this.state.selectedRowKeys;

                var mode = rowSelection.mode ? rowSelection.mode : 'multiple';
                var checked = selectedRowKeys.indexOf(record[primaryKey]) > -1;
                var onChange = _this.selectOneRow.bind(_this, index, record);
                var attrs = rowSelection.getProps ? rowSelection.getProps(record, index) || {} : {};

                attrs.onClick = makeChain(function (e) {
                    e.stopPropagation();
                }, attrs.onClick);
                return mode === 'multiple' ? _react2.default.createElement(_checkbox2.default, _extends({ checked: checked, onChange: onChange }, attrs)) : _react2.default.createElement(_radio2.default, _extends({ checked: checked, onChange: onChange }, attrs));
            };

            _this.selectAllRow = function (checked, e) {
                var ret = [].concat(_this.state.selectedRowKeys),
                    _this$props3 = _this.props,
                    rowSelection = _this$props3.rowSelection,
                    primaryKey = _this$props3.primaryKey,
                    dataSource = _this$props3.dataSource,
                    entireDataSource = _this$props3.entireDataSource,
                    selectedRowKeys = _this.state.selectedRowKeys,
                    getProps = rowSelection.getProps;

                var attrs = {},
                    records = [];

                var source = entireDataSource ? entireDataSource : dataSource;

                _this.flatDataSource(source).forEach(function (record, index) {
                    var id = record[primaryKey];
                    if (getProps) {
                        attrs = getProps(record, index) || {};
                    }
                    // 反选和全选的时候不要丢弃禁用项的选中状态
                    if (checked && (!attrs.disabled || selectedRowKeys.indexOf(id) > -1)) {
                        ret.push(id);
                        records.push(record);
                    } else if (attrs.disabled && selectedRowKeys.indexOf(id) > -1) {
                        ret.push(id);
                        records.push(record);
                    } else {
                        var i = ret.indexOf(id);
                        i > -1 && ret.splice(i, 1);
                    }
                });

                records = unique(records, primaryKey);
                if (typeof rowSelection.onSelectAll === 'function') {
                    rowSelection.onSelectAll(checked, records);
                }
                _this.triggerSelection(rowSelection, unique(ret), records);
                e.stopPropagation();
            };

            _this.state = {
                selectedRowKeys: props.rowSelection && 'selectedRowKeys' in props.rowSelection ? props.rowSelection.selectedRowKeys || [] : []
            };
            return _this;
        }

        SelectionTable.prototype.getChildContext = function getChildContext() {
            return {
                rowSelection: this.props.rowSelection,
                selectedRowKeys: this.state.selectedRowKeys
            };
        };

        SelectionTable.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
            if (nextProps.rowSelection && 'selectedRowKeys' in nextProps.rowSelection) {
                var selectedRowKeys = nextProps.rowSelection.selectedRowKeys || [];
                this.setState({
                    selectedRowKeys: selectedRowKeys
                });
            }
        };

        SelectionTable.prototype.normalizeChildren = function normalizeChildren(children) {
            var _props = this.props,
                prefix = _props.prefix,
                rowSelection = _props.rowSelection;

            if (rowSelection) {
                children = _react.Children.map(children, function (child, index) {
                    return _react2.default.cloneElement(child, {
                        key: index
                    });
                });
                children.unshift(_react2.default.createElement(_column2.default, { key: 'selection', title: this.renderSelectionHeader.bind(this),
                    cell: this.renderSelectionBody.bind(this),
                    width: 50,
                    className: prefix + 'table-selection', __normalized: true }));
                return children;
            }
            return children;
        };

        SelectionTable.prototype.selectOneRow = function selectOneRow(index, record, checked, e) {
            var selectedRowKeys = [].concat(this.state.selectedRowKeys),
                i = void 0;
            var _props2 = this.props,
                primaryKey = _props2.primaryKey,
                rowSelection = _props2.rowSelection,
                dataSource = _props2.dataSource,
                mode = rowSelection.mode ? rowSelection.mode : 'multiple',
                id = record[primaryKey];

            if (!id) {
                _util.log.warning('Can\'t get value from record using given ' + primaryKey + ' as primaryKey.');
            }
            if (mode === 'multiple') {
                if (checked) {
                    selectedRowKeys.push(id);
                } else {
                    i = selectedRowKeys.indexOf(id);
                    selectedRowKeys.splice(i, 1);
                }
            } else if (checked) {
                selectedRowKeys = [id];
            }
            var records = unique(dataSource.filter(function (item) {
                return selectedRowKeys.indexOf(item[primaryKey]) > -1;
            }), primaryKey);
            if (typeof rowSelection.onSelect === 'function') {
                rowSelection.onSelect(checked, record, records);
            }

            this.triggerSelection(rowSelection, selectedRowKeys, records);

            e.stopPropagation();
        };

        SelectionTable.prototype.triggerSelection = function triggerSelection(rowSelection, selectedRowKeys, records) {
            if (!('selectedRowKeys' in rowSelection)) {
                this.setState({
                    selectedRowKeys: selectedRowKeys
                });
            }
            if (typeof rowSelection.onChange === 'function') {
                rowSelection.onChange(selectedRowKeys, records);
            }
        };

        SelectionTable.prototype.flatDataSource = function flatDataSource(dataSource) {
            var ret = dataSource;
            var listHeader = this.context.listHeader;


            if (listHeader) {
                ret = [];
                var hasChildrenSelection = listHeader.hasChildrenSelection,
                    hasSelection = listHeader.hasSelection;

                dataSource.forEach(function (item) {
                    var children = item.children;
                    // 如果需要渲染selection才将这条记录插入到dataSource
                    // 或者没有孩子节点
                    if (hasSelection) {
                        ret.push(item);
                    }
                    if (children && hasChildrenSelection) {
                        ret = ret.concat(children);
                    }
                });
            }
            return ret;
        };

        SelectionTable.prototype.render = function render() {
            /* eslint-disable prefer-const */
            var _props3 = this.props,
                rowSelection = _props3.rowSelection,
                components = _props3.components,
                children = _props3.children,
                others = _objectWithoutProperties(_props3, ['rowSelection', 'components', 'children']);

            if (rowSelection) {
                children = this.normalizeChildren(children);
                components = _extends({}, components);
                components.Row = components.Row || _row2.default;
            }
            return _react2.default.createElement(
                BaseComponent,
                _extends({}, others, { components: components }),
                children
            );
        };

        return SelectionTable;
    }(_react2.default.Component), _class.SelectionRow = _row2.default, _class.propTypes = _extends({
        /**
        * 是否启用选择模式
        * @property {Function} getProps `Function(record, index)=>Object` 获取selection的默认属性
        * @property {Function} onChange `Function(selectedRowKeys:Array, records:Array)` 选择改变的时候触发的事件，**注意:** 其中records只会包含当前dataSource的数据，很可能会小于selectedRowKeys的长度。
        * @property {Function} onSelect `Function(selected:Boolean, record:Object, records:Array)` 用户手动选择/取消选择某行的回调
        * @property {Function} onSelectAll `Function(selected:Boolean, records:Array)` 用户手动选择/取消选择所有行的回调
        * @property {Array} selectedRowKeys 设置了此属性,将rowSelection变为受控状态,接收值为该行数据的primaryKey的值
        * @property {String} mode 选择selection的模式, 可选值为`single`, `multiple`，默认为`multiple`
        */
        rowSelection: _propTypes2.default.object,
        primaryKey: _propTypes2.default.string,
        dataSource: _propTypes2.default.array,
        entireDataSource: _propTypes2.default.array
    }, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps, {
        locale: _zhCn2.default.Table,
        primaryKey: 'id',
        prefix: 'next-'
    }), _class.contextTypes = {
        listHeader: _propTypes2.default.any
    }, _class.childContextTypes = {
        rowSelection: _propTypes2.default.object,
        selectedRowKeys: _propTypes2.default.array
    }, _temp);
    SelectionTable.displayName = 'SelectionTable';

    (0, _util2.statics)(SelectionTable, BaseComponent);
    return SelectionTable;
}
module.exports = exports['default'];

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = expanded;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

var _row = __webpack_require__(65);

var _row2 = _interopRequireDefault(_row);

var _column = __webpack_require__(23);

var _column2 = _interopRequireDefault(_column);

var _util2 = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};

function expanded(BaseComponent) {
    var _class, _temp2;

    /** Table */
    var ExpandedTable = (_temp2 = _class = function (_React$Component) {
        _inherits(ExpandedTable, _React$Component);

        function ExpandedTable() {
            var _temp, _this, _ret;

            _classCallCheck(this, ExpandedTable);

            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
                openRowKeys: _this.props.openRowKeys || []
            }, _this.expandedKeydown = function (value, record, index, e) {
                e.preventDefault();
                e.stopPropagation();

                if (e.keyCode === _util.KEYCODE.ENTER) {
                    _this.onExpandedClick(value, record, index, e);
                }
            }, _this.renderExpandedCell = function (value, index, record) {
                var _classnames;

                var _this$props = _this.props,
                    getExpandedColProps = _this$props.getExpandedColProps,
                    prefix = _this$props.prefix,
                    locale = _this$props.locale;
                var openRowKeys = _this.state.openRowKeys,
                    primaryKey = _this.props.primaryKey,
                    hasExpanded = openRowKeys.indexOf(record[primaryKey]) > -1,
                    switchNode = hasExpanded ? _react2.default.createElement(_icon2.default, { type: 'minus', size: 'xs' }) : _react2.default.createElement(_icon2.default, { type: 'add', size: 'xs' }),
                    attrs = getExpandedColProps(record, index) || {};

                var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-expanded-ctrl'] = true, _classnames.disabled = attrs.disabled, _classnames[attrs.className] = attrs.className, _classnames));

                if (!attrs.disabled) {
                    attrs.onClick = _this.onExpandedClick.bind(_this, value, record, index);
                }
                return _react2.default.createElement(
                    'span',
                    _extends({}, attrs, {
                        role: 'button',
                        tabIndex: '0',
                        onKeyDown: _this.expandedKeydown.bind(_this, value, record, index),
                        'aria-label': hasExpanded ? locale.expanded : locale.folded,
                        'aria-expanded': hasExpanded,
                        className: cls }),
                    switchNode
                );
            }, _temp), _possibleConstructorReturn(_this, _ret);
        }

        ExpandedTable.prototype.getChildContext = function getChildContext() {
            return {
                openRowKeys: this.state.openRowKeys,
                expandedRowRender: this.props.expandedRowRender,
                expandedRowIndent: this.props.expandedRowIndent
            };
        };

        ExpandedTable.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
            if ('openRowKeys' in nextProps) {
                var openRowKeys = nextProps.openRowKeys;

                this.setState({
                    openRowKeys: openRowKeys
                });
            }
        };

        ExpandedTable.prototype.onExpandedClick = function onExpandedClick(value, record, i, e) {
            var openRowKeys = [].concat(this.state.openRowKeys),
                primaryKey = this.props.primaryKey,
                id = record[primaryKey],
                index = openRowKeys.indexOf(id);

            if (index > -1) {
                openRowKeys.splice(index, 1);
            } else {
                openRowKeys.push(id);
            }
            if (!('openRowKeys' in this.props)) {
                this.setState({
                    openRowKeys: openRowKeys
                });
            }
            this.props.onRowOpen(openRowKeys, id, index === -1, record);
            e.stopPropagation();
        };

        ExpandedTable.prototype.normalizeChildren = function normalizeChildren(children) {
            var toArrayChildren = _react.Children.map(children, function (child, index) {
                return _react2.default.cloneElement(child, {
                    key: index
                });
            });
            var prefix = this.props.prefix;

            toArrayChildren.unshift(_react2.default.createElement(_column2.default, { title: '', key: 'expanded', cell: this.renderExpandedCell.bind(this), width: 50, className: prefix + 'table-expanded', __normalized: true }));
            return toArrayChildren;
        };

        ExpandedTable.prototype.normalizeDataSource = function normalizeDataSource(ds) {
            var ret = [];
            ds.forEach(function (item) {
                var itemCopy = _extends({}, item);
                itemCopy.__expanded = true;
                ret.push(item, itemCopy);
            });
            return ret;
        };

        ExpandedTable.prototype.render = function render() {
            /* eslint-disable no-unused-vars, prefer-const */
            var _props = this.props,
                components = _props.components,
                openRowKeys = _props.openRowKeys,
                expandedRowRender = _props.expandedRowRender,
                hasExpandedRowCtrl = _props.hasExpandedRowCtrl,
                children = _props.children,
                dataSource = _props.dataSource,
                getExpandedColProps = _props.getExpandedColProps,
                expandedRowIndent = _props.expandedRowIndent,
                onRowOpen = _props.onRowOpen,
                onExpandedRowClick = _props.onExpandedRowClick,
                others = _objectWithoutProperties(_props, ['components', 'openRowKeys', 'expandedRowRender', 'hasExpandedRowCtrl', 'children', 'dataSource', 'getExpandedColProps', 'expandedRowIndent', 'onRowOpen', 'onExpandedRowClick']);

            if (expandedRowRender && !components.Row) {
                components = _extends({}, components);
                components.Row = _row2.default;
                dataSource = this.normalizeDataSource(dataSource);
            }
            if (expandedRowRender && hasExpandedRowCtrl) {
                children = this.normalizeChildren(children);
            }

            return _react2.default.createElement(
                BaseComponent,
                _extends({}, others, { dataSource: dataSource, components: components }),
                children
            );
        };

        return ExpandedTable;
    }(_react2.default.Component), _class.ExpandedRow = _row2.default, _class.propTypes = _extends({
        /**
         * 额外渲染行的渲染函数
         * @param {Object} record 该行所对应的数据
         * @param {Number} index 该行所对应的序列
         * @returns {Element}
         */
        expandedRowRender: _propTypes2.default.func,
        /**
         * 额外渲染行的缩进
         */
        expandedRowIndent: _propTypes2.default.array,
        /**
         * 默认情况下展开的渲染行或者Tree, 传入此属性为受控状态
         */
        openRowKeys: _propTypes2.default.array,
        /**
         * 是否显示点击展开额外渲染行的+号按钮
         */
        hasExpandedRowCtrl: _propTypes2.default.bool,
        /**
         * 设置额外渲染行的属性
         */
        getExpandedColProps: _propTypes2.default.func,
        /**
         * 在额外渲染行或者Tree展开或者收起的时候触发的事件
         * @param {Array} openRowKeys 展开的渲染行的key
         * @param {String} currentRowKey 当前点击的渲染行的key
         * @param {Boolean} expanded 当前点击是展开还是收起
         * @param {Object} currentRecord 当前点击额外渲染行的记录
         */
        onRowOpen: _propTypes2.default.func,
        /**
         * 点击额外渲染行触发的事件
         * @param {Object} record 该行所对应的数据
         * @param {Number} index 该行所对应的序列
         * @param {Event} e DOM事件对象
         */
        onExpandedRowClick: _propTypes2.default.func,
        locale: _propTypes2.default.object
    }, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps, {
        getExpandedColProps: noop,
        onRowOpen: noop,
        hasExpandedRowCtrl: true,
        components: {},
        expandedRowIndent: [1, 0],
        prefix: 'next-'
    }), _class.childContextTypes = {
        openRowKeys: _propTypes2.default.array,
        expandedRowRender: _propTypes2.default.func,
        expandedRowIndent: _propTypes2.default.array
    }, _temp2);
    ExpandedTable.displayName = 'ExpandedTable';

    (0, _util2.statics)(ExpandedTable, BaseComponent);
    return ExpandedTable;
}
module.exports = exports['default'];

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = virtual;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

var _body = __webpack_require__(130);

var _body2 = _interopRequireDefault(_body);

var _util2 = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};
function virtual(BaseComponent) {
    var _class, _temp2;

    var VirtualTable = (_temp2 = _class = function (_React$Component) {
        _inherits(VirtualTable, _React$Component);

        function VirtualTable() {
            var _temp, _this, _ret;

            _classCallCheck(this, VirtualTable);

            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
                rowHeight: _this.props.rowHeight,
                scrollToRow: _this.props.scrollToRow,
                height: _this.props.maxBodyHeight
            }, _this.onScroll = function () {
                // 避免横向滚动带来的性能问题
                var scrollTop = _this.bodyNode.scrollTop;
                if (scrollTop === _this.lastScrollTop) {
                    return;
                }
                var start = _this.computeScrollToRow(scrollTop);
                if (!('scrollToRow' in _this.props)) {
                    _this.setState({
                        scrollToRow: start
                    });
                }
                _this.props.onBodyScroll(start);
                _this.lastScrollTop = scrollTop;
            }, _this.getBodyNode = function (node, lockType) {
                lockType = lockType ? lockType.charAt(0).toUpperCase() + lockType.substr(1) : '';
                _this['body' + lockType + 'Node'] = node;
            }, _this.getTableInstance = function (type, instance) {
                type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';
                _this['table' + type + 'Inc'] = instance;
            }, _temp), _possibleConstructorReturn(_this, _ret);
        }

        VirtualTable.prototype.getChildContext = function getChildContext() {
            return {
                onVirtualScroll: this.onScroll,
                bodyHeight: this.computeBodyHeight(),
                innerTop: this.computeInnerTop(),
                getBodyNode: this.getBodyNode,
                getTableInstanceForVirtual: this.getTableInstance,
                rowSelection: this.rowSelection
            };
        };

        VirtualTable.prototype.componentWillMount = function componentWillMount() {
            var _props = this.props,
                useVirtual = _props.useVirtual,
                dataSource = _props.dataSource;


            this.hasVirtualData = useVirtual && dataSource && dataSource.length > 0;
        };

        VirtualTable.prototype.componentDidMount = function componentDidMount() {

            if (this.hasVirtualData) {
                this.lastScrollTop = this.bodyNode.scrollTop;
            }

            this.adjustScrollTop();
            this.adjustSize();
            this.reComputeSize();
        };

        VirtualTable.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
            var useVirtual = nextProps.useVirtual,
                dataSource = nextProps.dataSource;


            this.hasVirtualData = useVirtual && dataSource && dataSource.length > 0;

            if ('maxBodyHeight' in nextProps) {
                if (this.state.height !== nextProps.maxBodyHeight) {
                    this.setState({
                        height: nextProps.maxBodyHeight
                    });
                }
            }

            if ('scrollToRow' in nextProps) {
                this.setState({
                    scrollToRow: nextProps.scrollToRow
                });
            }

            if (this.state.rowHeight && 'rowHeight' in nextProps) {
                var row = this.getRowNode();
                var rowClientHeight = row && row.clientHeight;
                if (rowClientHeight && rowClientHeight !== this.state.rowHeight) {
                    this.setState({
                        rowHeight: rowClientHeight
                    });
                }
            }
        };

        VirtualTable.prototype.componentDidUpdate = function componentDidUpdate() {
            this.adjustScrollTop();
            this.adjustSize();
            this.reComputeSize();
        };

        VirtualTable.prototype.reComputeSize = function reComputeSize() {
            var rowHeight = this.state.rowHeight;

            if (typeof rowHeight === 'function' && this.hasVirtualData) {
                var row = this.getRowNode();
                var rowClientHeight = row && row.clientHeight;
                if (rowClientHeight !== this.state.rowHeight) {
                    this.setState({
                        rowHeight: rowClientHeight
                    });
                }
            }
        };

        VirtualTable.prototype.computeBodyHeight = function computeBodyHeight() {
            var rowHeight = this.state.rowHeight;
            var dataSource = this.props.dataSource;

            if (typeof rowHeight === 'function') {
                return 0;
            }
            return dataSource.length * rowHeight;
        };

        VirtualTable.prototype.computeInnerTop = function computeInnerTop() {
            var rowHeight = this.state.rowHeight;

            if (typeof rowHeight === 'function') {
                return 0;
            }
            return this.start * rowHeight;
        };

        VirtualTable.prototype.getVisibleRange = function getVisibleRange(ExpectStart) {
            var _state = this.state,
                height = _state.height,
                rowHeight = _state.rowHeight;

            var len = this.props.dataSource.length;

            var end = void 0,
                visibleCount = 0;
            var start = 0;
            if (typeof rowHeight === 'function') {
                // try get cell height;
                end = 1;
            } else {
                visibleCount = parseInt(height / rowHeight, 10);

                if ('number' === typeof ExpectStart) {
                    start = ExpectStart < len ? ExpectStart : 0;
                }

                end = Math.min(+start + 1 + visibleCount + 10, len);
            }
            this.end = end;
            this.visibleCount = visibleCount;
            return {
                start: start,
                end: end
            };
        };

        VirtualTable.prototype.adjustScrollTop = function adjustScrollTop() {
            if (this.hasVirtualData) {
                this.bodyNode.scrollTop = this.lastScrollTop % this.state.rowHeight + this.state.rowHeight * this.state.scrollToRow;
            }
        };

        VirtualTable.prototype.adjustSize = function adjustSize() {
            if (this.hasVirtualData) {
                var body = this.bodyNode;
                var virtualScrollNode = body.querySelector('div');
                var clientHeight = body.clientHeight,
                    clientWidth = body.clientWidth;


                var tableInc = this.tableInc;
                var tableNode = (0, _reactDom.findDOMNode)(tableInc);
                var prefix = this.props.prefix;

                var headerNode = tableNode.querySelector('.' + prefix + 'table-header table');
                var headerClientWidth = headerNode && headerNode.clientWidth;

                if (clientWidth < headerClientWidth) {
                    _util.dom.setStyle(virtualScrollNode, 'min-width', headerClientWidth);
                    var leftNode = this.bodyLeftNode;
                    var rightNode = this.bodyRightNode;
                    leftNode && _util.dom.setStyle(leftNode, 'max-height', clientHeight);
                    rightNode && _util.dom.setStyle(rightNode, 'max-height', clientHeight);
                    this.hasScrollbar = true;
                } else {
                    this.hasScrollbar = false;
                }
            }
        };

        VirtualTable.prototype.computeScrollToRow = function computeScrollToRow(offset) {
            var rowHeight = this.state.rowHeight;

            var start = parseInt(offset / rowHeight);
            this.start = start;
            return start;
        };

        VirtualTable.prototype.getRowNode = function getRowNode() {
            try {
                // in case of finding an unmounted component due to cached data
                // need to clear refs of this.tableInc when dataSource Changed
                // use try catch for temporary
                return (0, _reactDom.findDOMNode)(this.tableInc.getRowRef(0));
            } catch (error) {
                return null;
            }
        };

        VirtualTable.prototype.render = function render() {
            /* eslint-disable no-unused-vars, prefer-const */
            var _props2 = this.props,
                useVirtual = _props2.useVirtual,
                components = _props2.components,
                dataSource = _props2.dataSource,
                fixedHeader = _props2.fixedHeader,
                rowHeight = _props2.rowHeight,
                scrollToRow = _props2.scrollToRow,
                onBodyScroll = _props2.onBodyScroll,
                others = _objectWithoutProperties(_props2, ['useVirtual', 'components', 'dataSource', 'fixedHeader', 'rowHeight', 'scrollToRow', 'onBodyScroll']);

            var entireDataSource = dataSource;

            this.rowSelection = this.props.rowSelection;
            if (this.hasVirtualData) {
                components = _extends({}, components);

                var _getVisibleRange = this.getVisibleRange(this.state.scrollToRow),
                    start = _getVisibleRange.start,
                    end = _getVisibleRange.end;

                dataSource = dataSource.slice(start, end);

                if (!components.Body) {
                    components.Body = _body2.default;
                }
                fixedHeader = true;
            }

            return _react2.default.createElement(BaseComponent, _extends({}, others, { dataSource: dataSource, entireDataSource: entireDataSource, components: components, fixedHeader: fixedHeader }));
        };

        return VirtualTable;
    }(_react2.default.Component), _class.VirtualBody = _body2.default, _class.propTypes = _extends({
        /**
         * 是否开启虚拟滚动
         */
        useVirtual: _propTypes2.default.bool,
        /**
         * 设置行高
         */
        rowHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.func]),
        maxBodyHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
        primaryKey: _propTypes2.default.string,
        dataSource: _propTypes2.default.array,
        /**
         * 在内容区域滚动的时候触发的函数
         */
        onBodyScroll: _propTypes2.default.func
    }, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps, {
        primaryKey: 'id',
        rowHeight: noop,
        maxBodyHeight: 200,
        components: {},
        prefix: 'next-',
        onBodyScroll: noop
    }), _class.childContextTypes = {
        onVirtualScroll: _propTypes2.default.func,
        bodyHeight: _propTypes2.default.number,
        innerTop: _propTypes2.default.number,
        getBodyNode: _propTypes2.default.func,
        getTableInstanceForVirtual: _propTypes2.default.func,
        rowSelection: _propTypes2.default.object
    }, _temp2);
    VirtualTable.displayName = 'VirtualTable';

    (0, _util2.statics)(VirtualTable, BaseComponent);
    return VirtualTable;
}
module.exports = exports['default'];

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _body = __webpack_require__(16);

var _body2 = _interopRequireDefault(_body);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var VirtualBody = (_temp2 = _class = function (_React$Component) {
    _inherits(VirtualBody, _React$Component);

    function VirtualBody() {
        var _temp, _this, _ret;

        _classCallCheck(this, VirtualBody);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.tableRef = function (table) {
            _this.tableNode = table;
        }, _this.virtualScrollRef = function (virtualScroll) {
            _this.virtualScrollNode = virtualScroll;
        }, _this.onScroll = function () {
            // for fixed
            _this.context.onBodyScroll();
            // for lock
            _this.context.onLockBodyScroll();
            // for virtual
            _this.context.onVirtualScroll();
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    VirtualBody.prototype.componentDidMount = function componentDidMount() {
        var bodyNode = (0, _reactDom.findDOMNode)(this);
        // // for fixed
        this.context.getNode('body', bodyNode);
        // for virtual
        this.context.getBodyNode(bodyNode, this.context.lockType);
        // for lock
        this.context.getLockNode('body', bodyNode, this.context.lockType);
    };

    VirtualBody.prototype.render = function render() {
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            colGroup = _props.colGroup,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'colGroup']);

        var _context = this.context,
            maxBodyHeight = _context.maxBodyHeight,
            bodyHeight = _context.bodyHeight,
            innerTop = _context.innerTop;

        return _react2.default.createElement(
            'div',
            { style: { maxHeight: maxBodyHeight }, className: className, onScroll: this.onScroll },
            _react2.default.createElement(
                'div',
                { style: { height: bodyHeight, overflow: 'hidden', position: 'relative' }, ref: this.virtualScrollRef },
                _react2.default.createElement(
                    'div',
                    { style: { height: '100%', position: 'relative', transform: 'translateY(' + innerTop + 'px)' } },
                    _react2.default.createElement(
                        'table',
                        { ref: this.tableRef },
                        colGroup,
                        _react2.default.createElement(_body2.default, _extends({}, others, { prefix: prefix }))
                    )
                )
            )
        );
    };

    return VirtualBody;
}(_react2.default.Component), _class.propTypes = {
    children: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    className: _propTypes2.default.string,
    colGroup: _propTypes2.default.any
}, _class.contextTypes = {
    maxBodyHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    onBodyScroll: _propTypes2.default.func,
    onVirtualScroll: _propTypes2.default.func,
    onLockBodyScroll: _propTypes2.default.func,
    bodyHeight: _propTypes2.default.number,
    innerTop: _propTypes2.default.number,
    getNode: _propTypes2.default.func,
    getBodyNode: _propTypes2.default.func,
    getLockNode: _propTypes2.default.func,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}, _temp2);
VirtualBody.displayName = 'VirtualBody';
exports.default = VirtualBody;
module.exports = exports['default'];

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = lock;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _shallowElementEquals = __webpack_require__(44);

var _shallowElementEquals2 = _interopRequireDefault(_shallowElementEquals);

var _util = __webpack_require__(2);

var _row = __webpack_require__(66);

var _row2 = _interopRequireDefault(_row);

var _body = __webpack_require__(132);

var _body2 = _interopRequireDefault(_body);

var _header = __webpack_require__(133);

var _header2 = _interopRequireDefault(_header);

var _wrapper = __webpack_require__(24);

var _wrapper2 = _interopRequireDefault(_wrapper);

var _util2 = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function lock(BaseComponent) {
    var _class, _temp;

    /** Table */
    var LockTable = (_temp = _class = function (_React$Component) {
        _inherits(LockTable, _React$Component);

        function LockTable(props, context) {
            _classCallCheck(this, LockTable);

            var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

            _this.getTableInstance = function (type, instance) {
                type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';
                _this['table' + type + 'Inc'] = instance;
            };

            _this.getNode = function (type, node, lockType) {
                lockType = lockType ? lockType.charAt(0).toUpperCase() + lockType.substr(1) : '';
                _this['' + type + lockType + 'Node'] = node;
                if (type === 'header' && !_this.innerHeaderNode && !lockType) {
                    _this.innerHeaderNode = _this.headerNode.querySelector('div');
                }
            };

            _this.onRowMouseEnter = function (record, index) {
                if (_this.isLock()) {
                    var row = _this.getRowNode(index);
                    var leftRow = _this.getRowNode(index, 'left');
                    var rightRow = _this.getRowNode(index, 'right');
                    [row, leftRow, rightRow].forEach(function (row) {
                        row && _util.dom.addClass(row, 'hovered');
                    });
                }
            };

            _this.onRowMouseLeave = function (record, index) {
                if (_this.isLock()) {
                    var row = _this.getRowNode(index);
                    var leftRow = _this.getRowNode(index, 'left');
                    var rightRow = _this.getRowNode(index, 'right');
                    [row, leftRow, rightRow].forEach(function (row) {
                        row && _util.dom.removeClass(row, 'hovered');
                    });
                }
            };

            _this.onLockBodyWheel = function (e) {
                var y = e.deltaY;
                if (_this.isLock()) {
                    var lockRightBody = _this.bodyRightNode,
                        lockLeftBody = _this.bodyLeftNode,
                        scrollNode = _this.bodyNode,
                        scrollTop = scrollNode.scrollTop,
                        clientHeight = scrollNode.clientHeight,
                        scrollHeight = scrollNode.scrollHeight;


                    if (lockLeftBody) {
                        lockLeftBody.scrollTop = y;
                    }
                    if (lockRightBody) {
                        lockRightBody.scrollTop = y;
                    }
                    scrollNode.scrollTop = scrollTop + y;
                    var newScrollTop = scrollNode.scrollTop;

                    if (newScrollTop + clientHeight < scrollHeight && newScrollTop) {
                        e.preventDefault();
                    }
                }
            };

            _this.onLockBodyScroll = function () {
                if (_this.isLock()) {
                    var lockRightBody = _this.bodyRightNode,
                        lockLeftBody = _this.bodyLeftNode,
                        lockRightTable = _this.getWrapperNode('right'),
                        lockLeftTable = _this.getWrapperNode('left'),
                        shadowClassName = 'shadow';

                    var x = _this.bodyNode.scrollLeft,
                        y = _this.bodyNode.scrollTop;

                    if (lockLeftBody) {
                        lockLeftBody.scrollTop = y;
                    }
                    if (lockRightBody) {
                        lockRightBody.scrollTop = y;
                    }
                    if (x === 0) {
                        lockLeftTable && _util.dom.removeClass(lockLeftTable, shadowClassName);
                        lockRightTable && _util.dom.addClass(lockRightTable, shadowClassName);
                    } else if (x === _this.bodyNode.scrollWidth - _this.bodyNode.clientWidth) {
                        lockLeftTable && _util.dom.addClass(lockLeftTable, shadowClassName);
                        lockRightTable && _util.dom.removeClass(lockRightTable, shadowClassName);
                    } else {
                        lockLeftTable && _util.dom.addClass(lockLeftTable, shadowClassName);
                        lockRightTable && _util.dom.addClass(lockRightTable, shadowClassName);
                    }
                }
            };

            _this.lockLeftChildren = [];
            _this.lockRightChildren = [];
            return _this;
        }

        LockTable.prototype.getChildContext = function getChildContext() {
            return {
                getTableInstance: this.getTableInstance,
                getLockNode: this.getNode,
                onLockBodyWheel: this.onLockBodyWheel,
                onLockBodyScroll: this.onLockBodyScroll,
                onRowMouseEnter: this.onRowMouseEnter,
                onRowMouseLeave: this.onRowMouseLeave
            };
        };

        LockTable.prototype.componentDidMount = function componentDidMount() {
            this.adjustSize = this.adjustSize.bind(this);

            this.adjustSize();
            this.scroll();

            _util.events.on(window, 'resize', this.adjustSize);
        };

        LockTable.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState, nextContext) {
            if (nextProps.pure) {
                var isEqual = (0, _shallowElementEquals2.default)(nextProps, this.props);
                return !(isEqual && _util.obj.shallowEqual(nextContext, this.context));
            }

            return true;
        };

        LockTable.prototype.componentWillUpdate = function componentWillUpdate() {
            this._isLock = false;
        };

        LockTable.prototype.componentDidUpdate = function componentDidUpdate() {
            this.adjustSize();
        };

        LockTable.prototype.componentWillUnmount = function componentWillUnmount() {
            _util.events.off(window, 'resize', this.adjustSize);
        };

        LockTable.prototype.normalizeChildrenState = function normalizeChildrenState(props) {
            var children = props.children;

            children = this.normalizeChildren(children);
            var splitChildren = this.splitFromNormalizeChildren(children);
            var lockLeftChildren = splitChildren.lockLeftChildren,
                lockRightChildren = splitChildren.lockRightChildren;

            return {
                lockLeftChildren: lockLeftChildren,
                lockRightChildren: lockRightChildren,
                children: this.mergeFromSplitLockChildren(splitChildren)
            };
        };

        // 将React结构化数据提取props转换成数组


        LockTable.prototype.normalizeChildren = function normalizeChildren(children) {
            var isLock = false;
            var getChildren = function getChildren(children) {
                var ret = [];
                _react.Children.forEach(children, function (child) {
                    if (child) {
                        var props = _extends({}, child.props);
                        if ([true, 'left', 'right'].indexOf(props.lock) > -1) {
                            isLock = true;
                            if (!('width' in props)) {
                                _util.log.warning('Should config width for lock column named [ ' + props.dataIndex + ' ].');
                            }
                        }
                        ret.push(props);
                        if (child.props.children) {
                            props.children = getChildren(child.props.children);
                        }
                    }
                });
                return ret;
            };
            var ret = getChildren(children);
            ret.forEach(function (child) {
                // 为自定义的列特殊处理
                if (child.__normalized && isLock) {
                    child.lock = 'left';
                    delete child.__normalized;
                }
            });
            this._isLock = isLock;
            return ret;
        };

        //从数组中分离出lock的列和正常的列


        LockTable.prototype.splitFromNormalizeChildren = function splitFromNormalizeChildren(children) {
            var originChildren = deepCopy(children);
            var lockLeftChildren = deepCopy(children);
            var lockRightChildren = deepCopy(children);
            var loop = function loop(lockChildren, condition) {
                var ret = [];
                lockChildren.forEach(function (child) {
                    if (child.children) {
                        var res = loop(child.children, condition);
                        if (!res.length) {
                            ret.push(child);
                        }
                    } else {
                        var order = condition(child);
                        if (!order) {
                            ret.push(child);
                        }
                    }
                });
                ret.forEach(function (res) {
                    var index = lockChildren.indexOf(res);
                    lockChildren.splice(index, 1);
                });
                return lockChildren;
            };
            loop(lockLeftChildren, function (child) {
                if (child.lock === true || child.lock === 'left') {
                    return 'left';
                }
            });
            loop(lockRightChildren, function (child) {
                if (child.lock === 'right') {
                    return 'right';
                }
            });
            loop(originChildren, function (child) {
                return child.lock !== true && child.lock !== 'left' && child.lock !== 'right';
            });
            return {
                lockLeftChildren: lockLeftChildren,
                lockRightChildren: lockRightChildren,
                originChildren: originChildren
            };
        };

        //将左侧的锁列树和中间的普通树及右侧的锁列树进行合并


        LockTable.prototype.mergeFromSplitLockChildren = function mergeFromSplitLockChildren(splitChildren) {
            var lockLeftChildren = splitChildren.lockLeftChildren,
                lockRightChildren = splitChildren.lockRightChildren;
            var originChildren = splitChildren.originChildren;

            Array.prototype.unshift.apply(originChildren, lockLeftChildren);
            originChildren = originChildren.concat(lockRightChildren);
            return originChildren;
        };

        LockTable.prototype.scroll = function scroll() {
            var _props = this.props,
                _props$scrollToCol = _props.scrollToCol,
                scrollToCol = _props$scrollToCol === undefined ? 0 : _props$scrollToCol,
                _props$scrollToRow = _props.scrollToRow,
                scrollToRow = _props$scrollToRow === undefined ? 0 : _props$scrollToRow;

            if (!scrollToCol && !scrollToRow) {
                return;
            }
            var colCellNode = this.getCellNode(0, scrollToCol);
            var rowCellNode = this.getCellNode(scrollToRow, 0);
            var bodyNodeOffset = this.bodyNode.getBoundingClientRect();
            if (colCellNode) {
                var cellNodeoffset = colCellNode.getBoundingClientRect();
                var scrollLeft = cellNodeoffset.left - bodyNodeOffset.left;
                this.bodyNode.scrollLeft = scrollLeft;
            }
            if (rowCellNode) {
                var _cellNodeoffset = rowCellNode.getBoundingClientRect();
                var scrollTop = _cellNodeoffset.top - bodyNodeOffset.top;
                this.bodyNode.scrollTop = scrollTop;
            }
        };

        // Table处理过后真实的lock状态
        LockTable.prototype.isLock = function isLock() {
            return this.lockLeftChildren.length || this.lockRightChildren.length;
        };

        // 用户设置的lock状态


        LockTable.prototype.isOriginLock = function isOriginLock() {
            return this._isLock;
        };

        LockTable.prototype.adjustSize = function adjustSize() {
            if (!this.adjustIfTableNotNeedLock()) {
                this.adjustHeaderSize();
                this.adjustBodySize();
                this.adjustCellSize();
                this.onLockBodyScroll();
            }
        };

        LockTable.prototype.adjustIfTableNotNeedLock = function adjustIfTableNotNeedLock() {
            var _this2 = this;

            if (this.isOriginLock() && this.tableInc.props.dataSource.length) {
                var configWidths = this.tableInc.flatChildren.map(function (item, index) {
                    var row = _this2.getCellNode(0, index);
                    return row && row.clientWidth || 0;
                }).reduce(function (a, b) {
                    return a + b;
                }, 0);

                var node = (0, _reactDom.findDOMNode)(this);
                var width = node.clientWidth;
                var lockLeftLen = this.lockLeftChildren.length;
                var lockRightLen = this.lockRightChildren.length;

                if (configWidths <= width && configWidths > 0) {
                    if (lockLeftLen) {
                        this._notNeedAdjustLockLeft = true;
                    }
                    if (lockRightLen) {
                        this._notNeedAdjustLockRight = true;
                    }
                    if (lockRightLen || lockLeftLen) {
                        this.forceUpdate();
                        return true;
                    }
                } else if (this._notNeedAdjustLockLeft || this._notNeedAdjustLockRight) {
                    this._notNeedAdjustLockLeft = this._notNeedAdjustLockRight = false;
                    this.forceUpdate();
                } else {
                    this._notNeedAdjustLockLeft = this._notNeedAdjustLockRight = false;
                    return false;
                }
            }

            return false;
        };

        LockTable.prototype.adjustBodySize = function adjustBodySize() {
            if (this.isLock()) {
                var body = this.bodyNode,
                    lockLeftBody = this.bodyLeftNode,
                    lockRightBody = this.bodyRightNode,
                    lockRightBodyWrapper = this.getWrapperNode('right'),
                    scrollbar = _util.dom.scrollbar(),
                    bodyHeight = body.offsetHeight,
                    hasHozScroll = body.scrollWidth > body.clientWidth,
                    hasVerScroll = body.scrollHeight > body.clientHeight,
                    width = hasVerScroll ? scrollbar.width : 0,
                    lockBodyHeight = bodyHeight - (hasHozScroll ? scrollbar.height : 0);

                lockLeftBody && _util.dom.setStyle(lockLeftBody, 'max-height', lockBodyHeight);
                lockRightBody && _util.dom.setStyle(lockRightBody, 'max-height', lockBodyHeight);
                lockRightBodyWrapper && _util.dom.setStyle(lockRightBodyWrapper, 'right', width);
            }
        };

        LockTable.prototype.adjustHeaderSize = function adjustHeaderSize() {
            var _this3 = this;

            if (this.isLock()) {
                this.tableInc.groupChildren.forEach(function (child, index) {
                    var lastIndex = _this3.tableInc.groupChildren[index].length - 1;
                    var headerRightRow = _this3.getHeaderCellNode(index, lastIndex),
                        headerLeftRow = _this3.getHeaderCellNode(index, 0),
                        headerRightLockRow = _this3.getHeaderCellNode(index, 0, 'right'),
                        headerLeftLockRow = _this3.getHeaderCellNode(index, 0, 'left');

                    if (headerRightRow && headerRightLockRow) {
                        var maxRightRowHeight = headerRightRow.offsetHeight;

                        _util.dom.setStyle(headerRightLockRow, 'height', maxRightRowHeight);

                        setTimeout(function () {
                            _this3.tableRightInc.affixRef && _this3.tableRightInc.affixRef.getInstance().updatePosition();
                        });
                    }

                    if (headerLeftRow && headerLeftLockRow) {
                        var maxLeftRowHeight = headerLeftRow.offsetHeight;

                        _util.dom.setStyle(headerLeftLockRow, 'height', maxLeftRowHeight);

                        setTimeout(function () {
                            _this3.tableLeftInc.affixRef && _this3.tableLeftInc.affixRef.getInstance().updatePosition();
                        });
                    }
                });
            }
        };

        LockTable.prototype.adjustCellSize = function adjustCellSize() {
            var _this4 = this;

            if (this.isLock()) {
                this.tableInc.props.dataSource.forEach(function (item, index) {
                    var lockLeftRow = _this4.getCellNode(index, 0, 'left'),
                        lockRightRow = _this4.getCellNode(index, 0, 'right'),
                        row = _this4.getFirstNormalCellNode(index),
                        rowHeight = row && parseFloat(getComputedStyle(row).height) || 0;
                    var lockLeftHeight = 0,
                        lockRightHeight = 0;

                    if (lockLeftRow) {
                        lockLeftHeight = lockLeftRow.offsetHeight;
                    }
                    if (lockRightRow) {
                        lockRightHeight = lockRightRow.offsetHeight;
                    }
                    if (lockLeftRow && rowHeight !== lockLeftHeight) {
                        _util.dom.setStyle(lockLeftRow, 'height', rowHeight);
                    }
                    if (lockRightRow && rowHeight !== lockRightHeight) {
                        _util.dom.setStyle(lockRightRow, 'height', rowHeight);
                    }
                });
            }
        };

        LockTable.prototype.getWrapperNode = function getWrapperNode(type) {
            type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';
            try {
                // in case of finding an unmounted component due to cached data
                // need to clear refs of table when dataSource Changed
                // use try catch for temporary
                return (0, _reactDom.findDOMNode)(this.refs['lock' + type]);
            } catch (error) {
                return null;
            }
        };

        LockTable.prototype.getFirstNormalCellNode = function getFirstNormalCellNode(index) {
            var i = 0;
            var row = void 0;
            do {
                row = this.getCellNode(index, i);
                i++;
            } while ((!row || row && row.rowSpan && row.rowSpan > 1) && this.tableInc.flatChildren.length > i);

            return row;
        };

        LockTable.prototype.getRowNode = function getRowNode(index, type) {
            type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';
            var table = this['table' + type + 'Inc'];

            try {
                // in case of finding an unmounted component due to cached data
                // need to clear refs of table when dataSource Changed
                // use try catch for temporary
                return (0, _reactDom.findDOMNode)(table.getRowRef(index));
            } catch (error) {
                return null;
            }
        };

        LockTable.prototype.getHeaderCellNode = function getHeaderCellNode(index, i, type) {
            type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';
            var table = this['table' + type + 'Inc'];

            try {
                // in case of finding an unmounted component due to cached data
                // need to clear refs of table when dataSource Changed
                // use try catch for temporary
                return (0, _reactDom.findDOMNode)(table.getHeaderCellRef(index, i));
            } catch (error) {
                return null;
            }
        };

        LockTable.prototype.getCellNode = function getCellNode(index, i, type) {
            type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';
            var table = this['table' + type + 'Inc'];

            try {
                // in case of finding an unmounted component due to cached data
                // need to clear refs of table when dataSource Changed
                // use try catch for temporary
                return (0, _reactDom.findDOMNode)(table.getCellRef(index, i));
            } catch (error) {
                return null;
            }
        };

        LockTable.prototype.render = function render() {
            /* eslint-disable no-unused-vars, prefer-const */
            var _props2 = this.props,
                children = _props2.children,
                prefix = _props2.prefix,
                components = _props2.components,
                className = _props2.className,
                others = _objectWithoutProperties(_props2, ['children', 'prefix', 'components', 'className']);

            var _normalizeChildrenSta = this.normalizeChildrenState(this.props),
                lockLeftChildren = _normalizeChildrenSta.lockLeftChildren,
                lockRightChildren = _normalizeChildrenSta.lockRightChildren,
                normalizedChildren = _normalizeChildrenSta.children;

            if (this._notNeedAdjustLockLeft) {
                lockLeftChildren = [];
            }
            if (this._notNeedAdjustLockRight) {
                lockRightChildren = [];
            }
            this.lockLeftChildren = lockLeftChildren;
            this.lockRightChildren = lockRightChildren;

            if (this.isOriginLock()) {
                var _classnames;

                components = _extends({}, components);
                components.Body = components.Body || _body2.default;
                components.Header = components.Header || _header2.default;
                components.Wrapper = components.Wrapper || _wrapper2.default;
                components.Row = components.Row || _row2.default;
                className = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-lock'] = true, _classnames[className] = className, _classnames));
                var content = [_react2.default.createElement(BaseComponent, _extends({}, others, { key: 'lock-left', columns: lockLeftChildren, className: prefix + 'table-lock-left', prefix: prefix, lockType: 'left', components: components, ref: 'lockLeft', loading: false })), _react2.default.createElement(BaseComponent, _extends({}, others, { key: 'lock-right', columns: lockRightChildren, className: prefix + 'table-lock-right', prefix: prefix, lockType: 'right', components: components, ref: 'lockRight', loading: false }))];
                return _react2.default.createElement(BaseComponent, _extends({}, others, { columns: normalizedChildren, prefix: prefix, wrapperContent: content, components: components, className: className }));
            }
            return _react2.default.createElement(BaseComponent, this.props);
        };

        return LockTable;
    }(_react2.default.Component), _class.LockRow = _row2.default, _class.LockBody = _body2.default, _class.LockHeader = _header2.default, _class.propTypes = _extends({
        scrollToCol: _propTypes2.default.number,
        /**
         * 指定滚动到某一行，仅在`useVirtual`的时候生效
         */
        scrollToRow: _propTypes2.default.number
    }, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps), _class.childContextTypes = {
        getTableInstance: _propTypes2.default.func,
        getLockNode: _propTypes2.default.func,
        onLockBodyScroll: _propTypes2.default.func,
        onLockBodyWheel: _propTypes2.default.func,
        onRowMouseEnter: _propTypes2.default.func,
        onRowMouseLeave: _propTypes2.default.func
    }, _temp);
    LockTable.displayName = 'LockTable';

    (0, _util2.statics)(LockTable, BaseComponent);
    return LockTable;
}

function deepCopy(arr) {
    var copy = function copy(arr) {
        return arr.map(function (item) {
            var newItem = _extends({}, item);
            if (item.children) {
                item.children = copy(item.children);
            }
            return newItem;
        });
    };
    return copy(arr);
}
module.exports = exports['default'];

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _body = __webpack_require__(67);

var _body2 = _interopRequireDefault(_body);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var LockBody = (_temp2 = _class = function (_React$Component) {
    _inherits(LockBody, _React$Component);

    function LockBody() {
        var _temp, _this, _ret;

        _classCallCheck(this, LockBody);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onBodyScroll = function () {
            _this.context.onLockBodyScroll();
        }, _this.onBodyWheel = function (e) {
            _this.context.onLockBodyWheel(e);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    LockBody.prototype.componentDidMount = function componentDidMount() {
        this.context.getLockNode('body', (0, _reactDom.findDOMNode)(this), this.context.lockType);
    };

    LockBody.prototype.render = function render() {
        return _react2.default.createElement(_body2.default, _extends({}, this.props, { onScroll: this.onBodyScroll, onWheel: this.onBodyWheel }));
    };

    return LockBody;
}(_react2.default.Component), _class.propTypes = _extends({}, _body2.default.propTypes), _class.contextTypes = _extends({}, _body2.default.contextTypes, {
    getLockNode: _propTypes2.default.func,
    onLockBodyScroll: _propTypes2.default.func,
    onLockBodyWheel: _propTypes2.default.func,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}), _temp2);
LockBody.displayName = 'LockBody';
exports.default = LockBody;
module.exports = exports['default'];

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _header = __webpack_require__(19);

var _header2 = _interopRequireDefault(_header);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var LockHeader = (_temp = _class = function (_FixedHeader) {
    _inherits(LockHeader, _FixedHeader);

    function LockHeader() {
        _classCallCheck(this, LockHeader);

        return _possibleConstructorReturn(this, _FixedHeader.apply(this, arguments));
    }

    LockHeader.prototype.componentDidMount = function componentDidMount() {
        var _context = this.context,
            getNode = _context.getNode,
            getLockNode = _context.getLockNode;

        getNode && getNode('header', (0, _reactDom.findDOMNode)(this), this.context.lockType);
        getLockNode && getLockNode('header', (0, _reactDom.findDOMNode)(this), this.context.lockType);
    };

    return LockHeader;
}(_header2.default), _class.propTypes = _extends({}, _header2.default.propTypes), _class.contextTypes = _extends({}, _header2.default.contextTypes, {
    getLockNode: _propTypes2.default.func,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}), _temp);
exports.default = LockHeader;
module.exports = exports['default'];

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = list;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _listHeader = __webpack_require__(68);

var _listHeader2 = _interopRequireDefault(_listHeader);

var _listFooter = __webpack_require__(69);

var _listFooter2 = _interopRequireDefault(_listFooter);

var _row = __webpack_require__(135);

var _row2 = _interopRequireDefault(_row);

var _body = __webpack_require__(136);

var _body2 = _interopRequireDefault(_body);

var _header = __webpack_require__(19);

var _header2 = _interopRequireDefault(_header);

var _wrapper = __webpack_require__(24);

var _wrapper2 = _interopRequireDefault(_wrapper);

var _util = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function list(BaseComponent) {
    var _class, _temp;

    var ListTable = (_temp = _class = function (_React$Component) {
        _inherits(ListTable, _React$Component);

        function ListTable() {
            _classCallCheck(this, ListTable);

            return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
        }

        ListTable.prototype.getChildContext = function getChildContext() {
            return {
                listHeader: this.listHeader,
                listFooter: this.listFooter,
                rowSelection: this.rowSelection
            };
        };

        ListTable.prototype.normalizeDataSource = function normalizeDataSource(dataSource) {
            var ret = [];
            var loop = function loop(dataSource, level) {
                dataSource.forEach(function (item) {
                    item.__level = level;
                    ret.push(item);
                    if (item.children) {
                        loop(item.children, level + 1);
                    }
                });
            };
            loop(dataSource, 0);
            this.ds = ret;
            return ret;
        };

        ListTable.prototype.render = function render() {
            var _this2 = this;

            /* eslint-disable prefer-const */
            var _props = this.props,
                components = _props.components,
                children = _props.children,
                className = _props.className,
                prefix = _props.prefix,
                others = _objectWithoutProperties(_props, ['components', 'children', 'className', 'prefix']);

            var isList = false,
                ret = [];
            _react.Children.forEach(children, function (child) {
                if (child) {
                    if (typeof child.type === 'function') {
                        if (child.type._typeMark === 'listHeader') {
                            _this2.listHeader = child.props;
                            isList = true;
                        } else if (child.type._typeMark === 'listFooter') {
                            _this2.listFooter = child.props;
                        } else {
                            ret.push(child);
                        }
                    } else {
                        ret.push(child);
                    }
                }
            });
            this.rowSelection = this.props.rowSelection;
            if (isList) {
                var _classnames;

                components = _extends({}, components);
                components.Row = components.Row || _row2.default;
                components.Body = components.Body || _body2.default;
                components.Header = components.Header || _header2.default;
                components.Wrapper = components.Wrapper || _wrapper2.default;
                className = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-group'] = true, _classnames[className] = className, _classnames));
            }
            return _react2.default.createElement(BaseComponent, _extends({}, others, { components: components, children: ret, className: className, prefix: prefix }));
        };

        return ListTable;
    }(_react2.default.Component), _class.ListHeader = _listHeader2.default, _class.ListFooter = _listFooter2.default, _class.ListRow = _row2.default, _class.ListBody = _body2.default, _class.propTypes = _extends({}, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps), _class.childContextTypes = {
        listHeader: _propTypes2.default.any,
        listFooter: _propTypes2.default.any,
        rowSelection: _propTypes2.default.object
    }, _temp);
    ListTable.displayName = 'ListTable';

    (0, _util.statics)(ListTable, BaseComponent);
    return ListTable;
}
module.exports = exports['default'];

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _util = __webpack_require__(2);

var _row = __webpack_require__(17);

var _row2 = _interopRequireDefault(_row);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var GroupListRow = (_temp = _class = function (_Row) {
    _inherits(GroupListRow, _Row);

    function GroupListRow() {
        _classCallCheck(this, GroupListRow);

        return _possibleConstructorReturn(this, _Row.apply(this, arguments));
    }

    GroupListRow.prototype.render = function render() {
        var _classnames;

        /* eslint-disable no-unused-vars*/
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            onClick = _props.onClick,
            onMouseEnter = _props.onMouseEnter,
            onMouseLeave = _props.onMouseLeave,
            columns = _props.columns,
            Cell = _props.Cell,
            rowIndex = _props.rowIndex,
            record = _props.record,
            children = _props.children,
            primaryKey = _props.primaryKey,
            colGroup = _props.colGroup,
            cellRef = _props.cellRef,
            getCellProps = _props.getCellProps,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'onClick', 'onMouseEnter', 'onMouseLeave', 'columns', 'Cell', 'rowIndex', 'record', 'children', 'primaryKey', 'colGroup', 'cellRef', 'getCellProps']);

        var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-row'] = true, _classnames[className] = className, _classnames));
        return _react2.default.createElement(
            'table',
            _extends({ className: cls, role: 'row' }, others, {
                onClick: this.onClick, onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave }),
            colGroup,
            _react2.default.createElement(
                'tbody',
                null,
                this.renderContent('header'),
                this.renderChildren(),
                this.renderContent('footer')
            )
        );
    };

    GroupListRow.prototype.isChildrenSelection = function isChildrenSelection() {
        return this.context.listHeader && this.context.listHeader.hasChildrenSelection;
    };

    GroupListRow.prototype.isSelection = function isSelection() {
        return this.context.listHeader && this.context.listHeader.hasSelection;
    };

    GroupListRow.prototype.renderChildren = function renderChildren() {
        var _this2 = this;

        var _props2 = this.props,
            record = _props2.record,
            primaryKey = _props2.primaryKey;
        var children = record.children;

        if (children) {
            return children.map(function (child, index) {
                var cells = _this2.renderCells(child);
                if (_this2.isChildrenSelection()) {
                    if (!child[primaryKey]) {
                        _util.log.warning('record.children should contains primaryKey when childrenSelection is true.');
                    }
                    return _react2.default.createElement(
                        'tr',
                        { key: child[primaryKey] },
                        cells
                    );
                }
                if (_this2.context.rowSelection) {
                    cells.shift();
                    cells[0] = _react2.default.cloneElement(cells[0], _extends({
                        colSpan: 2
                    }, cells[0].props));
                }
                return _react2.default.createElement(
                    'tr',
                    { key: index },
                    cells
                );
            });
        }
        return null;
    };

    GroupListRow.prototype.renderContent = function renderContent(type) {
        var _props3 = this.props,
            columns = _props3.columns,
            prefix = _props3.prefix,
            record = _props3.record,
            rowIndex = _props3.rowIndex;

        var cameType = type.charAt(0).toUpperCase() + type.substr(1);
        var list = this.context['list' + cameType];
        var listNode = void 0;
        if (list) {
            if (_react2.default.isValidElement(list.cell)) {
                listNode = _react2.default.cloneElement(list.cell, { record: record, index: rowIndex });
            } else if (typeof list.cell === 'function') {
                listNode = list.cell(record, rowIndex);
            }
            if (listNode) {
                var cells = this.renderCells(record);
                if (type === 'header' && this.context.rowSelection && this.isSelection()) {
                    cells = cells.slice(0, 1);
                    cells.push(_react2.default.createElement(
                        'td',
                        { colSpan: columns.length - 1, key: 'listNode' },
                        _react2.default.createElement(
                            'div',
                            { className: prefix + 'table-cell-wrapper' },
                            listNode
                        )
                    ));
                    listNode = _react2.default.createElement(
                        'tr',
                        { className: prefix + 'table-group-' + type },
                        cells
                    );
                } else {
                    listNode = _react2.default.createElement(
                        'tr',
                        { className: prefix + 'table-group-' + type },
                        _react2.default.createElement(
                            'td',
                            { colSpan: columns.length },
                            _react2.default.createElement(
                                'div',
                                { className: prefix + 'table-cell-wrapper' },
                                listNode
                            )
                        )
                    );
                }
            }
        }
        return listNode;
    };

    return GroupListRow;
}(_row2.default), _class.contextTypes = {
    listHeader: _propTypes2.default.any,
    listFooter: _propTypes2.default.any,
    rowSelection: _propTypes2.default.object,
    notRenderCellIndex: _propTypes2.default.array,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}, _temp);
exports.default = GroupListRow;
module.exports = exports['default'];

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = ListBody;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _body = __webpack_require__(16);

var _body2 = _interopRequireDefault(_body);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ListBody(props) {
    return _react2.default.createElement(_body2.default, _extends({ component: 'div' }, props));
}
module.exports = exports['default'];

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = sticky;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _header = __webpack_require__(19);

var _header2 = _interopRequireDefault(_header);

var _header3 = __webpack_require__(138);

var _header4 = _interopRequireDefault(_header3);

var _util = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function sticky(BaseComponent) {
    var _class, _temp;

    /** Table */
    var StickyTable = (_temp = _class = function (_React$Component) {
        _inherits(StickyTable, _React$Component);

        function StickyTable() {
            _classCallCheck(this, StickyTable);

            return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
        }

        StickyTable.prototype.getChildContext = function getChildContext() {
            return {
                Header: this.props.components.Header || _header2.default,
                offsetTop: this.props.offsetTop,
                affixProps: this.props.affixProps
            };
        };

        StickyTable.prototype.render = function render() {
            /* eslint-disable no-unused-vars */
            var _props = this.props,
                stickyHeader = _props.stickyHeader,
                offsetTop = _props.offsetTop,
                affixProps = _props.affixProps,
                others = _objectWithoutProperties(_props, ['stickyHeader', 'offsetTop', 'affixProps']);

            var _props2 = this.props,
                components = _props2.components,
                maxBodyHeight = _props2.maxBodyHeight,
                fixedHeader = _props2.fixedHeader;

            if (stickyHeader) {
                components = _extends({}, components);
                components.Header = _header4.default;
                fixedHeader = true;
                maxBodyHeight = Math.max(maxBodyHeight, 10000);
            }
            return _react2.default.createElement(BaseComponent, _extends({}, others, { components: components, fixedHeader: fixedHeader, maxBodyHeight: maxBodyHeight }));
        };

        return StickyTable;
    }(_react2.default.Component), _class.StickyHeader = _header4.default, _class.propTypes = _extends({
        /**
         * 表头是否是sticky
         */
        stickyHeader: _propTypes2.default.bool,
        /**
         * 距离窗口顶部达到指定偏移量后触发
         */
        offsetTop: _propTypes2.default.number,
        /**
         * affix组件的的属性
         */
        affixProps: _propTypes2.default.object,
        components: _propTypes2.default.object
    }, BaseComponent.propTypes), _class.defaultProps = _extends({
        components: {}
    }, BaseComponent.defaultProps), _class.childContextTypes = {
        Header: _propTypes2.default.any,
        offsetTop: _propTypes2.default.number,
        affixProps: _propTypes2.default.object
    }, _temp);
    StickyTable.displayName = 'StickyTable';

    (0, _util.statics)(StickyTable, BaseComponent);
    return StickyTable;
}
module.exports = exports['default'];

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _affix = __webpack_require__(139);

var _affix2 = _interopRequireDefault(_affix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function*/
var StickHeader = (_temp2 = _class = function (_React$Component) {
    _inherits(StickHeader, _React$Component);

    function StickHeader() {
        var _temp, _this, _ret;

        _classCallCheck(this, StickHeader);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.getAffixRef = function (ref) {
            _this.props.affixRef && _this.props.affixRef(ref);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    StickHeader.prototype.render = function render() {
        var _classnames;

        var prefix = this.props.prefix;
        var _context = this.context,
            Header = _context.Header,
            offsetTop = _context.offsetTop,
            affixProps = _context.affixProps;


        var newAffixProps = affixProps || {};

        var className = newAffixProps.className,
            others = _objectWithoutProperties(newAffixProps, ['className']);

        var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-affix'] = true, _classnames.className = className, _classnames));

        return _react2.default.createElement(
            _affix2.default,
            _extends({ ref: this.getAffixRef }, others, { className: cls, offsetTop: offsetTop }),
            _react2.default.createElement(Header, this.props)
        );
    };

    return StickHeader;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string
}, _class.contextTypes = {
    Header: _propTypes2.default.any,
    offsetTop: _propTypes2.default.number,
    affixProps: _propTypes2.default.object
}, _temp2);
StickHeader.displayName = 'StickHeader';
exports.default = StickHeader;
module.exports = exports['default'];

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__(4);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _util = __webpack_require__(2);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _util2 = __webpack_require__(140);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/** Affix */
var Affix = (_temp = _class = function (_React$Component) {
    _inherits(Affix, _React$Component);

    function Affix(props, context) {
        _classCallCheck(this, Affix);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

        _this.updatePosition = function () {
            _this._updateNodePosition();
        };

        _this._updateNodePosition = function () {
            var _this$props = _this.props,
                container = _this$props.container,
                useAbsolute = _this$props.useAbsolute;

            var affixContainer = container();

            if (!affixContainer) {
                return false;
            }
            var containerScrollTop = (0, _util2.getScroll)(affixContainer, true); // 容器在垂直位置上的滚动 offset
            var affixOffset = _this._getOffset(_this.affixNode, affixContainer); // 目标节点当前相对于容器的 offset
            var containerHeight = (0, _util2.getNodeHeight)(affixContainer); // 容器的高度
            var affixHeight = _this.affixNode.offsetHeight;
            var containerRect = (0, _util2.getRect)(affixContainer);

            var affixChildHeight = _this.affixChildNode.offsetHeight;

            var affixMode = _this.affixMode;
            var affixStyle = {
                width: affixOffset.width
            };
            var containerStyle = {
                width: affixOffset.width,
                height: affixChildHeight
            };

            if (affixMode.top && containerScrollTop > affixOffset.top - affixMode.offset) {
                // affix top
                if (useAbsolute) {
                    affixStyle.position = 'absolute';
                    affixStyle.top = containerScrollTop - (affixOffset.top - affixMode.offset);
                    containerStyle.position = 'relative';
                } else {
                    affixStyle.position = 'fixed';
                    affixStyle.top = affixMode.offset + containerRect.top;
                }
                _this._setAffixStyle(affixStyle, true);
                _this._setContainerStyle(containerStyle);
            } else if (affixMode.bottom && containerScrollTop < affixOffset.top + affixHeight + affixMode.offset - containerHeight) {
                // affix bottom
                affixStyle.height = affixHeight;
                if (useAbsolute) {
                    affixStyle.position = 'absolute';
                    affixStyle.top = containerScrollTop - (affixOffset.top + affixHeight + affixMode.offset - containerHeight);
                    containerStyle.position = 'relative';
                } else {
                    affixStyle.position = 'fixed';
                    affixStyle.bottom = affixMode.offset;
                }
                _this._setAffixStyle(affixStyle, true);
                _this._setContainerStyle(containerStyle);
            } else {
                _this._setAffixStyle(null);
                _this._setContainerStyle(null);
            }
        };

        _this._affixNodeRefHandler = function (ref) {
            _this.affixNode = (0, _reactDom.findDOMNode)(ref);
        };

        _this._affixChildNodeRefHandler = function (ref) {
            _this.affixChildNode = (0, _reactDom.findDOMNode)(ref);
        };

        _this.state = {
            style: null,
            containerStyle: null
        };
        _this.affixMode = _this._getAffixMode(props);
        return _this;
    }

    Affix.prototype.componentDidMount = function componentDidMount() {
        var _this2 = this;

        var container = this.props.container;

        this._updateNodePosition();
        // wait for parent rendered
        this.timeout = setTimeout(function () {
            _this2._setEventHandlerForContainer(container);
        });
    };

    Affix.prototype.componentWillUnmount = function componentWillUnmount() {
        if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
        var container = this.props.container;

        this._removeEventHandlerForContainer(container);
    };

    Affix.prototype._setEventHandlerForContainer = function _setEventHandlerForContainer(getContainer) {
        var container = getContainer();
        if (!container) {
            return;
        }
        _util.events.on(container, 'scroll', this._updateNodePosition, false);
        _util.events.on(container, 'resize', this._updateNodePosition, false);
    };

    Affix.prototype._removeEventHandlerForContainer = function _removeEventHandlerForContainer(getContainer) {
        var container = getContainer();
        if (container) {
            _util.events.off(container, 'scroll', this._updateNodePosition);
            _util.events.off(container, 'resize', this._updateNodePosition);
        }
    };

    Affix.prototype._getAffixMode = function _getAffixMode() {
        var _props = this.props,
            offsetTop = _props.offsetTop,
            offsetBottom = _props.offsetBottom;

        var affixMode = {
            top: false,
            bottom: false,
            offset: 0
        };

        if (typeof offsetTop !== 'number' && typeof offsetBottom !== 'number') {
            // set default
            affixMode.top = true;
        } else if (typeof offsetTop === 'number') {
            affixMode.top = true;
            affixMode.offset = offsetTop;
        } else if (typeof offsetBottom === 'number') {
            affixMode.bottom = true;
            affixMode.offset = offsetBottom;
        }

        return affixMode;
    };

    Affix.prototype._setAffixStyle = function _setAffixStyle(affixStyle) {
        var affixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (_util.obj.shallowEqual(affixStyle, this.state.style)) {
            return;
        }

        this.setState({
            style: affixStyle
        });

        var onAffix = this.props.onAffix;


        if (affixed) {
            onAffix(true);
        } else if (!affixStyle) {
            onAffix(false);
        }
    };

    Affix.prototype._setContainerStyle = function _setContainerStyle(containerStyle) {
        if (_util.obj.shallowEqual(containerStyle, this.state.containerStyle)) {
            return;
        }
        this.setState({ containerStyle: containerStyle });
    };

    Affix.prototype._getOffset = function _getOffset(affixNode, affixContainer) {
        var affixRect = affixNode.getBoundingClientRect(); // affix 元素 相对浏览器窗口的位置
        var containerRect = (0, _util2.getRect)(affixContainer); // affix 容器 相对浏览器窗口的位置
        var containerScrollTop = (0, _util2.getScroll)(affixContainer, true);
        var containerScrollLeft = (0, _util2.getScroll)(affixContainer, false);

        return {
            top: affixRect.top - containerRect.top + containerScrollTop,
            left: affixRect.left - containerRect.left + containerScrollLeft,
            width: affixRect.width,
            height: affixRect.height
        };
    };

    Affix.prototype.render = function render() {
        var _classnames;

        var _props2 = this.props,
            prefix = _props2.prefix,
            className = _props2.className,
            style = _props2.style,
            children = _props2.children;

        var state = this.state;
        var classNames = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'affix'] = state.style, _classnames[prefix + 'affix-top'] = !state.style && this.affixMode.top, _classnames[prefix + 'affix-bottom'] = !state.style && this.affixMode.bottom, _classnames[className] = className, _classnames));
        var combinedStyle = _extends({}, state.containerStyle, style);

        return _react2.default.createElement(
            'div',
            { ref: this._affixNodeRefHandler, style: combinedStyle },
            _react2.default.createElement(
                'div',
                { ref: this._affixChildNodeRefHandler, className: classNames, style: state.style },
                children
            )
        );
    };

    return Affix;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    /**
     * 设置 Affix 需要监听滚动事件的容器元素
     * @return {ReactElement} 目标容器元素的实例
     */
    container: _propTypes2.default.func,
    /**
     * 距离窗口顶部达到指定偏移量后触发
     */
    offsetTop: _propTypes2.default.number,
    /**
     * 距离窗口底部达到制定偏移量后触发
     */
    offsetBottom: _propTypes2.default.number,
    /**
     * 当元素的样式发生固钉样式变化时触发的回调函数
     * @param {Boolean} 元素是否被固钉
     */
    onAffix: _propTypes2.default.func,
    /**
     * 是否启用绝对布局实现 affix
     * @param {Boolean} 是否启用绝对布局
     */
    useAbsolute: _propTypes2.default.bool,
    className: _propTypes2.default.string,
    style: _propTypes2.default.object,
    children: _propTypes2.default.any
}, _class.defaultProps = {
    prefix: 'next-',
    container: function container() {
        return window;
    },
    onAffix: _util.func.noop
}, _temp);
Affix.displayName = 'Affix';
exports.default = _configProvider2.default.config(Affix);
module.exports = exports['default'];

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getScroll = getScroll;
exports.getRect = getRect;
exports.getNodeHeight = getNodeHeight;
function getScroll(node, isVertical) {
    if (typeof window === 'undefined') {
        return 0;
    }
    var windowProp = isVertical ? 'pageYOffset' : 'pageXOffset';
    var elementProp = isVertical ? 'scrollTop' : 'scrollLeft';
    return node === window ? node[windowProp] : node[elementProp];
}

function getRect(node) {
    return node !== window ? node.getBoundingClientRect() : { top: 0, left: 0, bottom: 0 };
}

function getNodeHeight(node) {
    if (!node) {
        return 0;
    }
    if (node === window) {
        return window.innerHeight;
    }
    return node.clientHeight;
}

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(11);

__webpack_require__(38);

__webpack_require__(70);

__webpack_require__(77);

__webpack_require__(72);

__webpack_require__(149);

__webpack_require__(78);

__webpack_require__(153);

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(25);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(25, function () {
			var newContent = __webpack_require__(25);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
	// get current location
	var location = typeof window !== "undefined" && window.location;

	if (!location) {
		throw new Error("fixUrls requires window.location");
	}

	// blank or null?
	if (!css || typeof css !== "string") {
		return css;
	}

	var baseUrl = location.protocol + "//" + location.host;
	var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
 This regular expression is just a way to recursively match brackets within
 a string.
 	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
    (  = Start a capturing group
      (?:  = Start a non-capturing group
          [^)(]  = Match anything that isn't a parentheses
          |  = OR
          \(  = Match a start parentheses
              (?:  = Start another non-capturing groups
                  [^)(]+  = Match anything that isn't a parentheses
                  |  = OR
                  \(  = Match a start parentheses
                      [^)(]*  = Match anything that isn't a parentheses
                  \)  = Match a end parentheses
              )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
  \)  = Match a close parens
 	 /gi  = Get all matches, not the first.  Be case insensitive.
  */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
			return $1;
		}).replace(/^'(.*)'$/, function (o, $1) {
			return $1;
		});

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
			return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
			//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(26);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(26, function () {
			var newContent = __webpack_require__(26);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(27);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(27, function () {
			var newContent = __webpack_require__(27);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(28);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(28, function () {
			var newContent = __webpack_require__(28);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(29);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(29, function () {
			var newContent = __webpack_require__(29);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(30);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(30, function () {
			var newContent = __webpack_require__(30);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(36);

__webpack_require__(151);

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(31);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(31, function () {
			var newContent = __webpack_require__(31);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(32);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(32, function () {
			var newContent = __webpack_require__(32);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(33);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(33, function () {
			var newContent = __webpack_require__(33);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(34);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(34, function () {
			var newContent = __webpack_require__(34);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _input = __webpack_require__(304);

var _input2 = _interopRequireDefault(_input);

var _textarea = __webpack_require__(305);

var _textarea2 = _interopRequireDefault(_textarea);

var _group = __webpack_require__(208);

var _group2 = _interopRequireDefault(_group);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_input2.default.TextArea = _configProvider2.default.config(_textarea2.default, { exportNames: ['getInputNode', 'focus'] });
_input2.default.Group = _group2.default;

// 用来自动生成文档的工具底层依赖的 react-docgen，无法解析生成 HOC 的方法中存在第二个参数的情况
// 所以不能在 input.jsx／textarea.jsx 中生成 HOC
exports.default = _configProvider2.default.config(_input2.default, {
    exportNames: ['getInputNode', 'focus']
});
module.exports = exports['default'];

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _animate = __webpack_require__(74);

var _animate2 = _interopRequireDefault(_animate);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = _util.func.noop,
    bindCtx = _util.func.bindCtx;

/**
 * Tag
 */

var Tag = (_temp = _class = function (_Component) {
    _inherits(Tag, _Component);

    function Tag(props) {
        _classCallCheck(this, Tag);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        _this.onKeyDown = function (e) {
            // 针对无障碍化要求 添加键盘SPACE事件
            var _this$props = _this.props,
                closable = _this$props.closable,
                closeArea = _this$props.closeArea,
                onClick = _this$props.onClick,
                disabled = _this$props.disabled;

            if (e.keyCode !== _util.KEYCODE.SPACE || disabled) {
                return;
            }

            e.preventDefault();
            e.stopPropagation();

            if (closable) {
                _this.handleClose(closeArea);
            } else {
                typeof onClick === 'function' && onClick(e);
            }
        };

        _this.state = {
            visible: true
        };

        bindCtx(_this, ['handleBodyClick', 'handleTailClick', 'handleAnimationInit', 'handleAnimationEnd', 'renderTailNode']);
        return _this;
    }

    Tag.prototype.componentWillUnmount = function componentWillUnmount() {
        this.__destroyed = true;
    };

    Tag.prototype.handleClose = function handleClose(from) {
        var _this2 = this;

        var _props = this.props,
            animation = _props.animation,
            onClose = _props.onClose;

        var hasAnimation = _util.support.animation && animation;

        // 先执行回调
        var result = onClose(from, this.tagNode);

        // 如果回调函数返回 false，则阻止关闭行为
        if (result !== false && !this.__destroyed) {
            this.setState({
                visible: false
            }, function () {
                // 如果没有动画，则直接执行 afterClose
                !hasAnimation && _this2.props.afterClose(_this2.tagNode);
            });
        }
    };

    // 标签体点击


    Tag.prototype.handleBodyClick = function handleBodyClick(e) {
        var _props2 = this.props,
            closable = _props2.closable,
            closeArea = _props2.closeArea,
            onClick = _props2.onClick;


        if (closable && closeArea === 'tag') {
            this.handleClose('tag');
        }

        if (typeof onClick === 'function') {
            return onClick(e);
        }
    };

    Tag.prototype.handleTailClick = function handleTailClick(e) {
        e && e.preventDefault();
        e && e.stopPropagation();

        this.handleClose('tail');
    };

    Tag.prototype.handleAnimationInit = function handleAnimationInit(node) {
        this.props.afterAppear(node);
    };

    Tag.prototype.handleAnimationEnd = function handleAnimationEnd(node) {
        this.props.afterClose(node);
    };

    Tag.prototype.renderAnimatedTag = function renderAnimatedTag(children, animationName) {
        return _react2.default.createElement(
            _animate2.default,
            {
                animation: animationName,
                afterAppear: this.handleAnimationInit,
                afterLeave: this.handleAnimationEnd
            },
            children
        );
    };

    Tag.prototype.renderTailNode = function renderTailNode() {
        var _props3 = this.props,
            prefix = _props3.prefix,
            closable = _props3.closable;


        if (!closable) {
            return null;
        }

        return _react2.default.createElement(
            'span',
            {
                className: prefix + 'tag-close-btn',
                onClick: this.handleTailClick
            },
            _react2.default.createElement(_icon2.default, { type: 'close' })
        );
    };

    Tag.prototype.render = function render() {
        var _classNames,
            _this3 = this;

        var _props4 = this.props,
            prefix = _props4.prefix,
            type = _props4.type,
            size = _props4.size,
            _shape = _props4._shape,
            closable = _props4.closable,
            closeArea = _props4.closeArea,
            className = _props4.className,
            children = _props4.children,
            animation = _props4.animation,
            disabled = _props4.disabled,
            rtl = _props4.rtl;
        var visible = this.state.visible;

        var others = _util.obj.pickOthers(Tag.propTypes, this.props);
        var shape = closable ? 'closable' : _shape;
        var bodyClazz = (0, _classnames2.default)([prefix + 'tag', prefix + 'tag-' + shape, prefix + 'tag-level-' + type, prefix + 'tag-' + size], (_classNames = {}, _classNames[prefix + 'tag-closable'] = closable, _classNames[prefix + 'tag-body-pointer'] = closable && closeArea === 'tag', _classNames), className);
        // close btn
        var tailNode = this.renderTailNode();
        // tag node
        var tagNode = !visible ? null : _react2.default.createElement(
            'div',
            _extends({
                className: bodyClazz,
                onClick: this.handleBodyClick,
                onKeyDown: this.onKeyDown,
                tabIndex: '0',
                role: 'button',
                'aria-disabled': disabled,
                disabled: disabled,
                dir: rtl ? 'rtl' : undefined,
                ref: function ref(n) {
                    return _this3.tagNode = n;
                }
            }, others),
            _react2.default.createElement(
                'span',
                { className: prefix + 'tag-body' },
                children
            ),
            tailNode
        );

        if (animation && _util.support.animation) {
            return this.renderAnimatedTag(tagNode, prefix + 'tag-zoom');
        }

        // 未开启或不支持动画
        return tagNode;
    };

    return Tag;
}(_react.Component), _class.propTypes = {
    /**
     * 标签类名前缀,提供给二次开发者用
     * @default next-
     */
    prefix: _propTypes2.default.string,
    /**
     * 标签的类型
     */
    type: _propTypes2.default.oneOf(['normal', 'primary']),
    /**
     * 标签的尺寸（large 尺寸为兼容表单场景 large = medium）
     */
    size: _propTypes2.default.oneOf(['small', 'medium', 'large']),

    closable: _propTypes2.default.bool,
    /**
     * 是否开启动效
     */
    animation: _propTypes2.default.bool,
    closeArea: _propTypes2.default.oneOf(['tag', 'tail']),
    onClose: _propTypes2.default.func,
    afterClose: _propTypes2.default.func,
    /**
     * 标签出现动画结束后执行的回调
     */
    afterAppear: _propTypes2.default.func,
    className: _propTypes2.default.any,
    children: _propTypes2.default.node,
    /**
     * 点击回调
     */
    onClick: _propTypes2.default.func,
    _shape: _propTypes2.default.oneOf(['default', 'closable', 'checkable']),
    disabled: _propTypes2.default.bool,
    rtl: _propTypes2.default.bool
}, _class.defaultProps = {
    prefix: 'next-',
    type: 'normal',
    size: 'medium',
    closeArea: 'tail',
    animation: false,
    onClose: noop,
    afterClose: noop,
    afterAppear: noop,
    onClick: noop,
    _shape: 'default',
    disabled: false,
    rtl: false
}, _temp);
Tag.displayName = 'Tag';
exports.default = Tag;
module.exports = exports['default'];

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.isSingle = isSingle;
exports.isNull = isNull;
exports.escapeForReg = escapeForReg;
exports.filter = filter;
exports.loopMap = loopMap;
exports.parseDataSourceFromChildren = parseDataSourceFromChildren;
exports.normalizeDataSource = normalizeDataSource;
exports.flattingDataSource = flattingDataSource;
exports.filterDataSource = filterDataSource;
exports.getValueDataSource = getValueDataSource;
exports.valueToSelectKey = valueToSelectKey;

var _react = __webpack_require__(0);

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

/**
 * util module
 */

/**
 * 是否是单选模式
 * @param {string} mode
 * @return {boolean} is single mode
 */
function isSingle(mode) {
    return !mode || mode === 'single' || mode === 'combobox';
}

/**
 * 在 Select 中，认为 null 和 undefined 都是空值
 * @param {*} n any object
 * @return {boolean}
 */
function isNull(n) {
    return n === null || n === undefined;
}

/**
 * 将字符串中的正则表达式关键字符添加转义
 * @param {string} str
 * @return {string}
 */
function escapeForReg(str) {
    return str.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
}

/**
 * filter by key
 * @param {string} key filter key
 * @param {object} item item object
 * @return {boolean} it's filtered
 */
function filter(key, item) {
    var _key = escapeForReg('' + key);
    var regExp = new RegExp('(' + _key + ')', 'ig');

    return regExp.test('' + item.value) || regExp.test('' + item.label);
}

/**
 * loop map
 * @param {Array} dataSource
 * @param {function} callback
 * @return {Array}
 * ----
 * @callback ~loopCallback
 * @param {object} option
 */
function loopMap(dataSource, callback) {
    var result = [];
    dataSource.forEach(function (option) {
        if (option.children) {
            var children = loopMap(option.children, callback);
            children.length && result.push(_extends({}, option, { children: children
            }));
        } else {
            var tmp = callback(option);
            tmp && result.push(tmp);
        }
    });

    return result;
}

/**
 * Parse dataSource from MenuItem
 * @static
 * @param {Array<Element>} children
 * @param {number} [deep=0] recursion deep level
 */
function parseDataSourceFromChildren(children) {
    var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    var source = [];

    _react.Children.forEach(children, function (child, index) {
        var type = child.type,
            childProps = child.props;

        var item2 = { deep: deep };

        var isOption = false;
        var isOptionGroup = false;

        if (typeof type === 'function' && type._typeMark === 'next_select_option' || type === 'option') {
            isOption = true;
        }
        if (typeof type === 'function' && type._typeMark === 'next_select_option_group' || type === 'optgroup') {
            isOptionGroup = true;
        }

        if (!isOption && !isOptionGroup) {
            return;
        }

        if (isOption) {
            // option
            // If children is a string, it can be used as value
            var isStrChild = typeof childProps.children === 'string';
            // value > key > string children > index
            item2.value = 'value' in childProps ? childProps.value : 'key' in childProps ? childProps.key : isStrChild ? childProps.children : '' + index;

            item2.label = childProps.label || childProps.children || '' + item2.value;
            item2.title = childProps.title;
            childProps.disabled === true && (item2.disabled = true);
            // You can put your extra data here, and use it in `itemRender` or `labelRender`
            _extends(item2, childProps['data-extra'] || {});
        } else if (isOptionGroup && deep < 1) {
            // option group
            item2.label = childProps.label || 'Group';
            // parse children nodes
            item2.children = parseDataSourceFromChildren(childProps.children, deep + 1);
        }

        source.push(item2);
    });

    return source;
}

/**
 * Normalize dataSource
 * @static
 * @param {Array} dataSource
 * @param {number} [deep=0] recursion deep level
 * ----
 * value priority: value > 'index'
 * label priority: label > 'value' > 'index'
 * disabled: disabled === true
 */
function normalizeDataSource(dataSource) {
    var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    var source = [];

    dataSource.forEach(function (item, index) {
        // enable array of basic type
        if (/string|boolean|number/.test(typeof item === 'undefined' ? 'undefined' : _typeof(item))) {
            item = { label: '' + item, value: item };
        }

        // filter off addon item
        if (item.__isAddon) {
            return;
        }

        var item2 = { deep: deep };
        // deep < 1: only 2 level allowed
        if (Array.isArray(item.children) && deep < 1) {
            // handle group
            item2.label = item.label || item.value || 'Group ' + index;
            // parse children
            item2.children = normalizeDataSource(item.children, deep + 1);
        } else {
            var _item = item,
                value = _item.value,
                label = _item.label,
                title = _item.title,
                disabled = _item.disabled,
                others = _objectWithoutProperties(_item, ['value', 'label', 'title', 'disabled']);

            item2.value = !isNull(value) ? value : '' + index;
            item2.label = label || '' + item2.value;
            item2.title = title;
            disabled === true && (item2.disabled = true);

            _extends(item2, others);
        }

        source.push(item2);
    });

    return source;
}

/**
 * Get flatten dataSource
 * @static
 * @param  {Array} dataSource structured dataSource
 * @return {Array}
 */
function flattingDataSource(dataSource) {
    var source = [];

    dataSource.forEach(function (item) {
        if (Array.isArray(item.children)) {
            source.push.apply(source, flattingDataSource(item.children));
        } else {
            source.push(item);
        }
    });

    return source;
}

function filterDataSource(dataSource, key, filter, addonKey) {
    if (!Array.isArray(dataSource)) {
        return [];
    }
    if (typeof key === 'undefined' || key === null) {
        return [].concat(dataSource);
    }

    var addKey = true;
    var menuDataSource = loopMap(dataSource, function (option) {
        if (key === '' + option.value) {
            addKey = false;
        }
        return filter(key, option) && !option.__isAddon && option;
    });

    // if key not in menuDataSource, add key to dataSource
    if (addonKey && key && addKey) {
        menuDataSource.unshift({
            value: key,
            label: key,
            title: key,
            __isAddon: true
        });
    }

    return menuDataSource;
}

function getKeyItemByValue(value, valueMap) {
    var item = void 0;

    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.hasOwnProperty('value')) {
        item = value;
    } else {
        item = valueMap['' + value] || {
            value: value,
            label: value
        };
    }

    return item;
}

/**
 * compute valueDataSource by new value
 * @param {Array/String} value 数据
 * @param {Object} mapValueDS   上个value的缓存数据 value => {value,label} 的映射关系表
 * @param {*} mapMenuDS  通过 dataSource 建立 value => {value,label} 的映射关系表
 * @returns {Object} value: [value]; valueDS: [{value,label}]; mapValueDS: {value: {value,label}}
 */
function getValueDataSource(value, mapValueDS, mapMenuDS) {
    if (isNull(value)) {
        return {};
    }

    var newValue = [];
    var newValueDS = [];
    var newMapValueDS = {};
    var _newMapDS = _extends({}, mapValueDS, mapMenuDS);

    if (Array.isArray(value)) {
        value.forEach(function (v) {
            var item = getKeyItemByValue(v, _newMapDS);

            newValueDS.push(item);
            newMapValueDS['' + item.value] = item;
            newValue.push(item.value);
        });

        return {
            value: newValue, // [value]
            valueDS: newValueDS, // [{value,label}]
            mapValueDS: newMapValueDS // {value: {value,label}}
        };
    } else {
        var _mapValueDS;

        var item = getKeyItemByValue(value, _newMapDS);

        return {
            value: item.value,
            valueDS: item,
            mapValueDS: (_mapValueDS = {}, _mapValueDS['' + item.value] = item, _mapValueDS)
        };
    }
}

/**
 * Get flatten dataSource
 * @static
 * @param  {any} value structured dataSource
 * @return {String}
 */
function valueToSelectKey(value) {
    var val = void 0;
    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.hasOwnProperty('value')) {
        val = value.value;
    } else {
        val = value;
    }
    return '' + val;
}

/**
 * UP Down 改进双向链表方法
 */
// function DoubleLinkList(element){
//     this.prev = null;
//     this.next = null;
//     this.element = element;
// }
//
// export function mapDoubleLinkList(dataSource){
//
//     const mapDS = {};
//     let doubleLink = null;
//
//     let head = null;
//     let tail = null;
//
//     function  append(element) {
//         if (!doubleLink) {
//             doubleLink = new DoubleLinkList(element);
//             head = doubleLink;
//             tail = doubleLink;
//             return doubleLink;
//         }
//
//         const node = new DoubleLinkList(element);
//         tail.next = node;
//         node.prev = tail;
//         tail = node;
//
//         return tail;
//     }
//
//     dataSource.forEach((item => {
//         if (item.disabled) {
//             return;
//         }
//         mapDS[`${item.value}`] = append(item);
//     }));
//
//     return mapDS;
// }
//

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n.next-input {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  vertical-align: middle;\n  display: inline-table;\n  border-collapse: separate;\n  font-size: 0;\n  width: 200px;\n  border-spacing: 0;\n  -webkit-transition: all .3s ease-out;\n  transition: all .3s ease-out;\n  border: 1px solid #C4C6CF;\n  background-color: #FFFFFF; }\n  .next-input *,\n  .next-input *:before,\n  .next-input *:after {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box; }\n  .next-input input {\n    height: 100%;\n    /* remove autoFill yellow background */ }\n    .next-input input[type=\"reset\"], .next-input input[type=\"submit\"] {\n      -webkit-appearance: button;\n      cursor: pointer; }\n    .next-input input::-moz-focus-inner {\n      border: 0;\n      padding: 0; }\n    .next-input input:-webkit-autofill {\n      -webkit-box-shadow: 0 0 0 1000px #FFFFFF inset; }\n  .next-input textarea {\n    resize: none; }\n  .next-input input,\n  .next-input textarea {\n    width: 100%;\n    border: none;\n    outline: none;\n    padding: 0;\n    margin: 0;\n    font-weight: normal;\n    vertical-align: middle;\n    background-color: transparent;\n    color: #333333; }\n    .next-input input::-moz-placeholder,\n    .next-input textarea::-moz-placeholder {\n      color: #999999;\n      opacity: 1; }\n    .next-input input:-ms-input-placeholder,\n    .next-input textarea:-ms-input-placeholder {\n      color: #999999; }\n    .next-input input::-webkit-input-placeholder,\n    .next-input textarea::-webkit-input-placeholder {\n      color: #999999; }\n    .next-input input::-ms-clear,\n    .next-input textarea::-ms-clear {\n      display: none; }\n  .next-input.next-input-textarea {\n    border-radius: 3px;\n    font-size: 0; }\n    .next-input.next-input-textarea textarea {\n      color: #333333;\n      padding: 4px 8px;\n      font-size: 12px;\n      border-radius: 3px; }\n    .next-input.next-input-textarea .next-input-control {\n      display: block;\n      width: auto;\n      border-radius: 3px; }\n    .next-input.next-input-textarea .next-input-len {\n      padding: 0 8px 4px;\n      display: block;\n      text-align: right;\n      width: auto; }\n  .next-input.next-small {\n    height: 20px;\n    border-radius: 3px; }\n    .next-input.next-small .next-input-label {\n      padding-left: 8px;\n      font-size: 12px; }\n    .next-input.next-small .next-input-inner {\n      font-size: 12px; }\n    .next-input.next-small .next-input-control {\n      padding-right: 4px; }\n    .next-input.next-small input {\n      height: 18px;\n      line-height: 18px \\0;\n      padding: 0 4px;\n      font-size: 12px; }\n      .next-input.next-small input::-webkit-input-placeholder {\n        font-size: 12px; }\n      .next-input.next-small input::-ms-input-placeholder {\n        font-size: 12px; }\n      .next-input.next-small input::placeholder {\n        font-size: 12px; }\n    .next-input.next-small .next-input-text-field {\n      padding: 0 4px;\n      font-size: 12px;\n      height: 18px;\n      line-height: 18px; }\n    .next-input.next-small .next-icon:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n    .next-input.next-small input {\n      border-radius: 3px; }\n    .next-input.next-small .next-input-control {\n      border-radius: 0 3px 3px 0; }\n  .next-input.next-medium {\n    height: 28px;\n    border-radius: 3px; }\n    .next-input.next-medium .next-input-label {\n      padding-left: 8px;\n      font-size: 12px; }\n    .next-input.next-medium .next-input-inner {\n      font-size: 12px; }\n    .next-input.next-medium .next-input-control {\n      padding-right: 8px; }\n    .next-input.next-medium input {\n      height: 26px;\n      line-height: 26px \\0;\n      padding: 0 8px;\n      font-size: 12px; }\n      .next-input.next-medium input::-webkit-input-placeholder {\n        font-size: 12px; }\n      .next-input.next-medium input::-ms-input-placeholder {\n        font-size: 12px; }\n      .next-input.next-medium input::placeholder {\n        font-size: 12px; }\n    .next-input.next-medium .next-input-text-field {\n      padding: 0 8px;\n      font-size: 12px;\n      height: 26px;\n      line-height: 26px; }\n    .next-input.next-medium .next-icon:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n    .next-input.next-medium input {\n      border-radius: 3px; }\n    .next-input.next-medium .next-input-control {\n      border-radius: 0 3px 3px 0; }\n  .next-input.next-large {\n    height: 40px;\n    border-radius: 3px; }\n    .next-input.next-large .next-input-label {\n      padding-left: 12px;\n      font-size: 16px; }\n    .next-input.next-large .next-input-inner {\n      font-size: 16px; }\n    .next-input.next-large .next-input-control {\n      padding-right: 8px; }\n    .next-input.next-large input {\n      height: 38px;\n      line-height: 38px \\0;\n      padding: 0 12px;\n      font-size: 16px; }\n      .next-input.next-large input::-webkit-input-placeholder {\n        font-size: 16px; }\n      .next-input.next-large input::-ms-input-placeholder {\n        font-size: 16px; }\n      .next-input.next-large input::placeholder {\n        font-size: 16px; }\n    .next-input.next-large .next-input-text-field {\n      padding: 0 12px;\n      font-size: 16px;\n      height: 38px;\n      line-height: 38px; }\n    .next-input.next-large .next-icon:before {\n      width: 16px;\n      font-size: 16px;\n      line-height: inherit; }\n    .next-input.next-large input {\n      border-radius: 3px; }\n    .next-input.next-large .next-input-control {\n      border-radius: 0 3px 3px 0; }\n  .next-input-hint-wrap {\n    color: #999999;\n    position: relative; }\n    .next-input-hint-wrap .next-input-clear {\n      opacity: 0;\n      z-index: 1;\n      position: absolute; }\n    .next-input-hint-wrap .next-input-hint {\n      opacity: 1; }\n  .next-input .next-icon-delete-filling:hover {\n    cursor: pointer;\n    color: #666666; }\n  .next-input:hover, .next-input.next-focus {\n    border-color: #A0A2AD;\n    background-color: #FFFFFF; }\n    .next-input:hover .next-input-clear, .next-input.next-focus .next-input-clear {\n      opacity: 1; }\n      .next-input:hover .next-input-clear + .next-input-hint, .next-input.next-focus .next-input-clear + .next-input-hint {\n        opacity: 0; }\n  .next-input .next-input-clear:focus {\n    opacity: 1; }\n    .next-input .next-input-clear:focus + .next-input-hint {\n      opacity: 0; }\n  .next-input.next-focus {\n    border-color: #5584FF;\n    background-color: #FFFFFF; }\n  .next-input.next-error {\n    border-color: #FF3000; }\n    .next-input.next-error.next-focus, .next-input.next-error:hover {\n      border-color: #FF3000; }\n  .next-input.next-hidden {\n    display: none; }\n  .next-input.next-noborder {\n    border: none; }\n  .next-input-control .next-input-len {\n    font-size: 12px;\n    line-height: 12px;\n    color: #999999;\n    display: table-cell;\n    width: 1px;\n    vertical-align: bottom; }\n    .next-input-control .next-input-len.next-error {\n      color: #FF3000; }\n  .next-input-control > * {\n    display: table-cell;\n    width: 1%;\n    top: 0; }\n  .next-input-control > *:not(:last-child) {\n    padding-right: 4px; }\n  .next-input-control .next-icon {\n    -webkit-transition: all .3s ease-out;\n    transition: all .3s ease-out;\n    color: #999999; }\n  .next-input-control .next-icon-success-filling {\n    color: #46BC15; }\n  .next-input-control .next-icon-loading {\n    color: #4494F9; }\n  .next-input-label {\n    color: #666666; }\n  .next-input.next-disabled {\n    color: #CCCCCC;\n    border-color: #E6E7EB;\n    background-color: #F7F8FA;\n    cursor: not-allowed;\n    background-color: #F7F8FA; }\n    .next-input.next-disabled:hover {\n      border-color: #E6E7EB;\n      background-color: #F7F8FA; }\n    .next-input.next-disabled input::-moz-placeholder, .next-input.next-disabled textarea::-moz-placeholder {\n      color: #CCCCCC;\n      opacity: 1; }\n    .next-input.next-disabled input:-ms-input-placeholder, .next-input.next-disabled textarea:-ms-input-placeholder {\n      color: #CCCCCC; }\n    .next-input.next-disabled input::-webkit-input-placeholder, .next-input.next-disabled textarea::-webkit-input-placeholder {\n      color: #CCCCCC; }\n    .next-input.next-disabled .next-input-label {\n      color: #CCCCCC; }\n    .next-input.next-disabled .next-input-len {\n      color: #CCCCCC; }\n    .next-input.next-disabled input,\n    .next-input.next-disabled textarea {\n      color: #CCCCCC;\n      border-color: #E6E7EB;\n      background-color: #F7F8FA;\n      cursor: not-allowed; }\n      .next-input.next-disabled input:hover,\n      .next-input.next-disabled textarea:hover {\n        border-color: #E6E7EB;\n        background-color: #F7F8FA; }\n    .next-input.next-disabled .next-input-hint-wrap {\n      color: #CCCCCC; }\n      .next-input.next-disabled .next-input-hint-wrap .next-input-clear {\n        opacity: 0; }\n      .next-input.next-disabled .next-input-hint-wrap .next-input-hint {\n        opacity: 1; }\n      .next-input.next-disabled .next-input-hint-wrap .next-icon-delete-filling:hover {\n        cursor: not-allowed;\n        color: #CCCCCC; }\n    .next-input.next-disabled .next-icon {\n      color: #CCCCCC; }\n  .next-input-inner, .next-input-control, .next-input-label {\n    display: table-cell;\n    width: 1px;\n    vertical-align: middle;\n    line-height: 1;\n    background-color: transparent;\n    white-space: nowrap; }\n  .next-input-group {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box;\n    display: inline-table;\n    border-collapse: separate;\n    border-spacing: 0;\n    line-height: 0;\n    width: 100%; }\n    .next-input-group *,\n    .next-input-group *:before,\n    .next-input-group *:after {\n      -webkit-box-sizing: border-box;\n              box-sizing: border-box; }\n    .next-input-group-auto-width {\n      width: 100%;\n      border-radius: 0 !important; }\n    .next-input-group > .next-input:first-child.next-small {\n      border-top-left-radius: 3px !important;\n      border-bottom-left-radius: 3px !important; }\n    .next-input-group > .next-input:first-child.next-medium {\n      border-top-left-radius: 3px !important;\n      border-bottom-left-radius: 3px !important; }\n    .next-input-group > .next-input:first-child.next-large {\n      border-top-left-radius: 3px !important;\n      border-bottom-left-radius: 3px !important; }\n    .next-input-group > .next-input:last-child.next-small {\n      border-top-right-radius: 3px !important;\n      border-bottom-right-radius: 3px !important; }\n    .next-input-group > .next-input:last-child.next-medium {\n      border-top-right-radius: 3px !important;\n      border-bottom-right-radius: 3px !important; }\n    .next-input-group > .next-input:last-child.next-large {\n      border-top-right-radius: 3px !important;\n      border-bottom-right-radius: 3px !important; }\n  .next-input-group-addon {\n    width: 1px;\n    display: table-cell;\n    vertical-align: middle;\n    white-space: nowrap;\n    /* stylelint-disable declaration-no-important */ }\n    .next-input-group-addon:first-child {\n      border-bottom-right-radius: 0 !important;\n      border-top-right-radius: 0 !important; }\n      .next-input-group-addon:first-child > * {\n        border-bottom-right-radius: 0 !important;\n        border-top-right-radius: 0 !important; }\n    .next-input-group-addon:last-child {\n      border-bottom-left-radius: 0 !important;\n      border-top-left-radius: 0 !important; }\n      .next-input-group-addon:last-child > * {\n        border-bottom-left-radius: 0 !important;\n        border-top-left-radius: 0 !important; }\n  .next-input-group-text {\n    color: #999999;\n    background-color: #F2F3F7;\n    text-align: center;\n    border: 1px solid #C4C6CF;\n    padding: 0 8px; }\n    .next-input-group-text:first-child {\n      border-right-width: 0; }\n    .next-input-group-text:last-child {\n      border-left-width: 0; }\n    .next-input-group-text.next-disabled {\n      color: #CCCCCC;\n      border-color: #E6E7EB;\n      background-color: #F7F8FA;\n      cursor: not-allowed; }\n      .next-input-group-text.next-disabled:hover {\n        border-color: #E6E7EB;\n        background-color: #F7F8FA; }\n    .next-input-group-text.next-small {\n      font-size: 12px;\n      border-radius: 3px; }\n    .next-input-group-text.next-medium {\n      font-size: 12px;\n      border-radius: 3px; }\n    .next-input-group-text.next-large {\n      font-size: 16px;\n      border-radius: 3px; }\n\n.next-input[dir=\"rtl\"].next-small .next-input-label {\n  padding-left: 0;\n  padding-right: 8px; }\n\n.next-input[dir=\"rtl\"].next-small .next-input-control {\n  padding-right: 0;\n  padding-left: 4px; }\n\n.next-input[dir=\"rtl\"].next-medium .next-input-label {\n  padding-left: 0;\n  padding-right: 8px; }\n\n.next-input[dir=\"rtl\"].next-medium .next-input-control {\n  padding-right: 0;\n  padding-left: 8px; }\n\n.next-input[dir=\"rtl\"].next-large .next-input-label {\n  padding-left: 0;\n  padding-right: 12px; }\n\n.next-input[dir=\"rtl\"].next-large .next-input-control {\n  padding-right: 0;\n  padding-left: 8px; }\n\n.next-input[dir=\"rtl\"].next-input-textarea .next-input-len {\n  text-align: left; }\n\n.next-input[dir=\"rtl\"] .next-input-control > *:not(:last-child) {\n  padding-left: 4px;\n  padding-right: 0; }\n\n.next-input-group[dir=\"rtl\"] .next-input-group-addon {\n  /* stylelint-disable declaration-no-important */ }\n  .next-input-group[dir=\"rtl\"] .next-input-group-addon:first-child {\n    border-bottom-left-radius: 0 !important;\n    border-top-left-radius: 0 !important; }\n    .next-input-group[dir=\"rtl\"] .next-input-group-addon:first-child.next-small {\n      border-bottom-right-radius: 3px !important;\n      border-top-right-radius: 3px !important; }\n    .next-input-group[dir=\"rtl\"] .next-input-group-addon:first-child.next-medium {\n      border-bottom-right-radius: 3px !important;\n      border-top-right-radius: 3px !important; }\n    .next-input-group[dir=\"rtl\"] .next-input-group-addon:first-child.next-large {\n      border-bottom-right-radius: 3px !important;\n      border-top-right-radius: 3px !important; }\n  .next-input-group[dir=\"rtl\"] .next-input-group-addon:last-child {\n    border-bottom-right-radius: 0 !important;\n    border-top-right-radius: 0 !important; }\n    .next-input-group[dir=\"rtl\"] .next-input-group-addon:last-child.next-small {\n      border-bottom-left-radius: 3px !important;\n      border-top-left-radius: 3px !important; }\n    .next-input-group[dir=\"rtl\"] .next-input-group-addon:last-child.next-medium {\n      border-bottom-left-radius: 3px !important;\n      border-top-left-radius: 3px !important; }\n    .next-input-group[dir=\"rtl\"] .next-input-group-addon:last-child.next-large {\n      border-bottom-left-radius: 3px !important;\n      border-top-left-radius: 3px !important; }\n\n.next-input-group[dir=\"rtl\"] .next-input-group-text:first-child {\n  border-right-width: 1px;\n  border-left: 0; }\n\n.next-input-group[dir=\"rtl\"] .next-input-group-text:last-child {\n  border-left-width: 1px;\n  border-right: 0; }\n", ""]);

// exports


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n@-webkit-keyframes fadeInRightForTag {\n  0% {\n    opacity: 0;\n    -webkit-transform: rotate(45deg) translateX(20px);\n            transform: rotate(45deg) translateX(20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: rotate(45deg) translateX(0);\n            transform: rotate(45deg) translateX(0); } }\n@keyframes fadeInRightForTag {\n  0% {\n    opacity: 0;\n    -webkit-transform: rotate(45deg) translateX(20px);\n            transform: rotate(45deg) translateX(20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: rotate(45deg) translateX(0);\n            transform: rotate(45deg) translateX(0); } }\n\n.next-tag > .next-tag-body {\n  overflow: hidden;\n  text-overflow: ellipsis; }\n\n.next-tag-checkable.next-tag-level-secondary {\n  color: #333333;\n  border-color: transparent;\n  background-color: transparent; }\n  .next-tag-checkable.next-tag-level-secondary:not(.disabled):not([disabled]):hover, .next-tag-checkable.next-tag-level-secondary:not(.disabled):not([disabled]).hover, .next-tag-checkable.next-tag-level-secondary:not(.disabled):not([disabled]):focus {\n    color: #5584FF; }\n\n.next-tag-default.next-tag-level-primary, .next-tag-closable.next-tag-level-primary {\n  color: #666666;\n  border-color: #EBECF0;\n  background-color: #EBECF0; }\n  .next-tag-default.next-tag-level-primary:not(.disabled):not([disabled]):hover, .next-tag-closable.next-tag-level-primary:not(.disabled):not([disabled]):hover, .next-tag-default.next-tag-level-primary:not(.disabled):not([disabled]).hover, .next-tag-closable.next-tag-level-primary:not(.disabled):not([disabled]).hover, .next-tag-default.next-tag-level-primary:not(.disabled):not([disabled]):focus, .next-tag-closable.next-tag-level-primary:not(.disabled):not([disabled]):focus {\n    color: #333333;\n    border-color: #E2E4E8;\n    background-color: #E2E4E8; }\n    .next-tag-default.next-tag-level-primary:not(.disabled):not([disabled]):hover > .next-tag-close-btn, .next-tag-closable.next-tag-level-primary:not(.disabled):not([disabled]):hover > .next-tag-close-btn, .next-tag-default.next-tag-level-primary:not(.disabled):not([disabled]).hover > .next-tag-close-btn, .next-tag-closable.next-tag-level-primary:not(.disabled):not([disabled]).hover > .next-tag-close-btn, .next-tag-default.next-tag-level-primary:not(.disabled):not([disabled]):focus > .next-tag-close-btn, .next-tag-closable.next-tag-level-primary:not(.disabled):not([disabled]):focus > .next-tag-close-btn {\n      color: #333333; }\n  [disabled].next-tag-default.next-tag-level-primary, [disabled].next-tag-closable.next-tag-level-primary, .disabled.next-tag-default.next-tag-level-primary, .disabled.next-tag-closable.next-tag-level-primary {\n    color: #CCCCCC;\n    border-color: #F7F8FA;\n    background-color: #F7F8FA; }\n    [disabled].next-tag-default.next-tag-level-primary > .next-tag-close-btn, [disabled].next-tag-closable.next-tag-level-primary > .next-tag-close-btn, .disabled.next-tag-default.next-tag-level-primary > .next-tag-close-btn, .disabled.next-tag-closable.next-tag-level-primary > .next-tag-close-btn {\n      color: #CCCCCC; }\n  .next-tag-default.next-tag-level-primary > .next-tag-close-btn, .next-tag-closable.next-tag-level-primary > .next-tag-close-btn {\n    color: #666666; }\n\n.next-tag-checkable.next-tag-level-primary {\n  color: #666666;\n  border-color: #EBECF0;\n  background-color: #EBECF0; }\n  .next-tag-checkable.next-tag-level-primary:not(.disabled):not([disabled]):hover, .next-tag-checkable.next-tag-level-primary:not(.disabled):not([disabled]).hover, .next-tag-checkable.next-tag-level-primary:not(.disabled):not([disabled]):focus {\n    color: #333333;\n    border-color: #E2E4E8;\n    background-color: #E2E4E8; }\n    .next-tag-checkable.next-tag-level-primary:not(.disabled):not([disabled]):hover > .next-tag-close-btn, .next-tag-checkable.next-tag-level-primary:not(.disabled):not([disabled]).hover > .next-tag-close-btn, .next-tag-checkable.next-tag-level-primary:not(.disabled):not([disabled]):focus > .next-tag-close-btn {\n      color: #333333; }\n  [disabled].next-tag-checkable.next-tag-level-primary, .disabled.next-tag-checkable.next-tag-level-primary {\n    color: #CCCCCC;\n    border-color: #F7F8FA;\n    background-color: #F7F8FA; }\n    [disabled].next-tag-checkable.next-tag-level-primary > .next-tag-close-btn, .disabled.next-tag-checkable.next-tag-level-primary > .next-tag-close-btn {\n      color: #CCCCCC; }\n  .next-tag-checkable.next-tag-level-primary > .next-tag-close-btn {\n    color: #666666; }\n\n.next-tag-checkable.next-tag-level-primary.checked {\n  color: #FFFFFF;\n  border-color: #5584FF;\n  background-color: #5584FF; }\n  .next-tag-checkable.next-tag-level-primary.checked:not(.disabled):not([disabled]):hover, .next-tag-checkable.next-tag-level-primary.checked:not(.disabled):not([disabled]).hover, .next-tag-checkable.next-tag-level-primary.checked:not(.disabled):not([disabled]):focus {\n    color: #FFFFFF;\n    border-color: #3E71F7;\n    background-color: #3E71F7; }\n    .next-tag-checkable.next-tag-level-primary.checked:not(.disabled):not([disabled]):hover > .next-tag-close-btn, .next-tag-checkable.next-tag-level-primary.checked:not(.disabled):not([disabled]).hover > .next-tag-close-btn, .next-tag-checkable.next-tag-level-primary.checked:not(.disabled):not([disabled]):focus > .next-tag-close-btn {\n      color: #FFFFFF; }\n  .next-tag-checkable.next-tag-level-primary.checked > .next-tag-close-btn {\n    color: #FFFFFF; }\n\n.next-tag-default.next-tag-level-normal {\n  color: #666666;\n  border-color: #C4C6CF;\n  background-color: transparent; }\n  .next-tag-default.next-tag-level-normal:not(.disabled):not([disabled]):hover, .next-tag-default.next-tag-level-normal:not(.disabled):not([disabled]).hover, .next-tag-default.next-tag-level-normal:not(.disabled):not([disabled]):focus {\n    color: #333333;\n    border-color: #A0A2AD;\n    background-color: transparent; }\n    .next-tag-default.next-tag-level-normal:not(.disabled):not([disabled]):hover > .next-tag-close-btn, .next-tag-default.next-tag-level-normal:not(.disabled):not([disabled]).hover > .next-tag-close-btn, .next-tag-default.next-tag-level-normal:not(.disabled):not([disabled]):focus > .next-tag-close-btn {\n      color: #333333; }\n  [disabled].next-tag-default.next-tag-level-normal, .disabled.next-tag-default.next-tag-level-normal {\n    color: #CCCCCC;\n    border-color: #E6E7EB;\n    background-color: #F7F8FA; }\n    [disabled].next-tag-default.next-tag-level-normal > .next-tag-close-btn, .disabled.next-tag-default.next-tag-level-normal > .next-tag-close-btn {\n      color: #CCCCCC; }\n  .next-tag-default.next-tag-level-normal > .next-tag-close-btn {\n    color: #666666; }\n\n.next-tag-closable.next-tag-level-normal {\n  color: #666666;\n  border-color: #C4C6CF;\n  background-color: transparent; }\n  .next-tag-closable.next-tag-level-normal:not(.disabled):not([disabled]):hover, .next-tag-closable.next-tag-level-normal:not(.disabled):not([disabled]).hover, .next-tag-closable.next-tag-level-normal:not(.disabled):not([disabled]):focus {\n    color: #333333;\n    border-color: #A0A2AD;\n    background-color: transparent; }\n    .next-tag-closable.next-tag-level-normal:not(.disabled):not([disabled]):hover > .next-tag-close-btn, .next-tag-closable.next-tag-level-normal:not(.disabled):not([disabled]).hover > .next-tag-close-btn, .next-tag-closable.next-tag-level-normal:not(.disabled):not([disabled]):focus > .next-tag-close-btn {\n      color: #333333; }\n  [disabled].next-tag-closable.next-tag-level-normal, .disabled.next-tag-closable.next-tag-level-normal {\n    color: #CCCCCC;\n    border-color: #E6E7EB;\n    background-color: transparent; }\n    [disabled].next-tag-closable.next-tag-level-normal > .next-tag-close-btn, .disabled.next-tag-closable.next-tag-level-normal > .next-tag-close-btn {\n      color: #CCCCCC; }\n  .next-tag-closable.next-tag-level-normal > .next-tag-close-btn {\n    color: #666666; }\n\n.next-tag-checkable.next-tag-level-normal.checked, .next-tag-checkable.next-tag-level-secondary.checked {\n  color: #5584FF;\n  border-color: #5584FF;\n  background-color: transparent; }\n  .next-tag-checkable.next-tag-level-normal.checked:not(.disabled):not([disabled]):hover, .next-tag-checkable.next-tag-level-secondary.checked:not(.disabled):not([disabled]):hover, .next-tag-checkable.next-tag-level-normal.checked:not(.disabled):not([disabled]).hover, .next-tag-checkable.next-tag-level-secondary.checked:not(.disabled):not([disabled]).hover, .next-tag-checkable.next-tag-level-normal.checked:not(.disabled):not([disabled]):focus, .next-tag-checkable.next-tag-level-secondary.checked:not(.disabled):not([disabled]):focus {\n    color: #3E71F7;\n    border-color: #3E71F7;\n    background-color: transparent; }\n\n.next-tag-checkable.next-tag-level-secondary.checked:before {\n  position: absolute;\n  content: \"\";\n  -webkit-font-smoothing: antialiased;\n  background-color: #5584FF;\n  -webkit-transform: rotate(45deg);\n      -ms-transform: rotate(45deg);\n          transform: rotate(45deg); }\n\n.next-tag-checkable.next-tag-level-secondary.checked:after {\n  position: absolute;\n  font-family: NextIcon;\n  -webkit-font-smoothing: antialiased;\n  content: \"\\E632\";\n  -webkit-transform: scale(0.6);\n      -ms-transform: scale(0.6);\n          transform: scale(0.6);\n  color: #FFFFFF; }\n\n.next-tag-checkable.next-tag-level-secondary.checked:not(.disabled):not([disabled]):hover:before, .next-tag-checkable.next-tag-level-secondary.checked:not(.disabled):not([disabled]).hover:before, .next-tag-checkable.next-tag-level-secondary.checked:not(.disabled):not([disabled]):focus:before {\n  background-color: #3E71F7; }\n\n.next-tag-checkable.next-tag-level-secondary.checked:not(.disabled):not([disabled]):hover:after, .next-tag-checkable.next-tag-level-secondary.checked:not(.disabled):not([disabled]).hover:after, .next-tag-checkable.next-tag-level-secondary.checked:not(.disabled):not([disabled]):focus:after {\n  color: #FFFFFF; }\n\n[disabled].next-tag-checkable.next-tag-level-secondary.checked:before, .next-tag-checkable.next-tag-level-secondary.checked:disabled:before {\n  background-color: #E6E7EB; }\n\n[disabled].next-tag-checkable.next-tag-level-secondary.checked:after, .next-tag-checkable.next-tag-level-secondary.checked:disabled:after {\n  color: #FFFFFF; }\n\n.next-tag-checkable.next-tag-level-normal {\n  color: #666666;\n  border-color: #C4C6CF;\n  background-color: transparent; }\n  .next-tag-checkable.next-tag-level-normal:not(.disabled):not([disabled]):hover, .next-tag-checkable.next-tag-level-normal:not(.disabled):not([disabled]).hover, .next-tag-checkable.next-tag-level-normal:not(.disabled):not([disabled]):focus {\n    color: #333333;\n    border-color: #C4C6CF;\n    background-color: transparent; }\n  [disabled].next-tag-checkable.next-tag-level-normal, .disabled.next-tag-checkable.next-tag-level-normal {\n    color: #CCCCCC;\n    border-color: #E6E7EB;\n    background-color: #F7F8FA; }\n\n.next-tag-checkable.next-tag-level-normal.checked:before {\n  position: absolute;\n  content: \"\";\n  -webkit-font-smoothing: antialiased;\n  background-color: #5584FF;\n  -webkit-transform: rotate(45deg);\n      -ms-transform: rotate(45deg);\n          transform: rotate(45deg); }\n\n.next-tag-checkable.next-tag-level-normal.checked:after {\n  position: absolute;\n  font-family: NextIcon;\n  -webkit-font-smoothing: antialiased;\n  content: \"\\E632\";\n  -webkit-transform: scale(0.6);\n      -ms-transform: scale(0.6);\n          transform: scale(0.6);\n  color: #FFFFFF; }\n\n.next-tag-checkable.next-tag-level-normal.checked:not(.disabled):not([disabled]):hover:before, .next-tag-checkable.next-tag-level-normal.checked:not(.disabled):not([disabled]).hover:before, .next-tag-checkable.next-tag-level-normal.checked:not(.disabled):not([disabled]):focus:before {\n  background-color: #3E71F7; }\n\n.next-tag-checkable.next-tag-level-normal.checked:not(.disabled):not([disabled]):hover:after, .next-tag-checkable.next-tag-level-normal.checked:not(.disabled):not([disabled]).hover:after, .next-tag-checkable.next-tag-level-normal.checked:not(.disabled):not([disabled]):focus:after {\n  color: #FFFFFF; }\n\n[disabled].next-tag-checkable.next-tag-level-normal.checked:before, .next-tag-checkable.next-tag-level-normal.checked:disabled:before {\n  background-color: #E6E7EB; }\n\n[disabled].next-tag-checkable.next-tag-level-normal.checked:after, .next-tag-checkable.next-tag-level-normal.checked:disabled:after {\n  color: #FFFFFF; }\n\n.next-tag-closable.next-tag-level-normal:before {\n  position: absolute;\n  content: \"\";\n  -webkit-font-smoothing: antialiased;\n  background-color: #C4C6CF;\n  -webkit-transform: rotate(45deg);\n      -ms-transform: rotate(45deg);\n          transform: rotate(45deg); }\n\n.next-tag-closable.next-tag-level-normal:after {\n  position: absolute;\n  font-family: NextIcon;\n  -webkit-font-smoothing: antialiased;\n  content: \"\\E626\";\n  -webkit-transform: scale(0.6);\n      -ms-transform: scale(0.6);\n          transform: scale(0.6);\n  color: #FFFFFF; }\n\n.next-tag-closable.next-tag-level-normal:not(.disabled):not([disabled]):hover:before, .next-tag-closable.next-tag-level-normal:not(.disabled):not([disabled]).hover:before, .next-tag-closable.next-tag-level-normal:not(.disabled):not([disabled]):focus:before {\n  background-color: #A0A2AD; }\n\n.next-tag-closable.next-tag-level-normal:not(.disabled):not([disabled]):hover:after, .next-tag-closable.next-tag-level-normal:not(.disabled):not([disabled]).hover:after, .next-tag-closable.next-tag-level-normal:not(.disabled):not([disabled]):focus:after {\n  color: #FFFFFF; }\n\n[disabled].next-tag-closable.next-tag-level-normal:before, .next-tag-closable.next-tag-level-normal:disabled:before {\n  background-color: #E6E7EB; }\n\n[disabled].next-tag-closable.next-tag-level-normal:after, .next-tag-closable.next-tag-level-normal:disabled:after {\n  color: #FFFFFF; }\n\n.next- {\n  /* Animation */\n  /* ----------- */ }\n  .next-tag-group .next-tag-medium,\n  .next-tag-group .next-tag-large {\n    margin-right: 8px;\n    margin-bottom: 8px; }\n  .next-tag-group .next-tag-small {\n    margin-right: 4px;\n    margin-bottom: 4px; }\n  .next-tag {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box;\n    display: inline-block;\n    max-width: 100%;\n    vertical-align: middle;\n    border-width: 1px;\n    border-radius: 3px;\n    -webkit-box-shadow: none;\n            box-shadow: none;\n    border-style: solid;\n    /* 可配置??? */\n    overflow: hidden;\n    white-space: nowrap;\n    -webkit-transition: all 0.2s cubic-bezier(0.23, 1, 0.32, 1);\n    transition: all 0.2s cubic-bezier(0.23, 1, 0.32, 1);\n    font-size: 0;\n    outline: 0; }\n    .next-tag *,\n    .next-tag *:before,\n    .next-tag *:after {\n      -webkit-box-sizing: border-box;\n              box-sizing: border-box; }\n    .next-tag > .next-tag-body {\n      position: relative;\n      display: inline-block;\n      height: 100%;\n      text-align: center;\n      vertical-align: middle;\n      max-width: 100%;\n      -webkit-user-select: none;\n         -moz-user-select: none;\n          -ms-user-select: none;\n              user-select: none;\n      /* 用户手动传的 icon 的大小也保持一致？ */ }\n      .next-tag > .next-tag-body > a {\n        text-decoration: none;\n        color: inherit; }\n        .next-tag > .next-tag-body > a:before {\n          content: \" \";\n          position: absolute;\n          display: block;\n          top: 0;\n          left: 0;\n          right: 0;\n          bottom: 0; }\n      .next-tag > .next-tag-body .next-icon {\n        line-height: 1;\n        vertical-align: middle; }\n        .next-tag > .next-tag-body .next-icon:before {\n          font-size: inherit; }\n    .next-tag.next-tag-body-pointer {\n      cursor: pointer; }\n    .next-tag[disabled], .next-tag.disabled {\n      cursor: not-allowed;\n      pointer-events: none; }\n  .next-tag-large {\n    height: 40px;\n    padding: 0;\n    line-height: 38px;\n    font-size: 0; }\n    .next-tag-large > .next-tag-body {\n      font-size: 16px;\n      padding: 0 16px; }\n    .next-tag-large.next-tag-closable > .next-tag-body {\n      padding: 0 0 0 16px; }\n    .next-tag-large[dir=rtl].next-tag-closable > .next-tag-body {\n      padding: 0 16px 0 0; }\n    .next-tag-large > .next-tag-close-btn {\n      margin-left: 9px;\n      padding-right: 16px; }\n      .next-tag-large > .next-tag-close-btn .next-icon:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n    .next-tag-large[dir=rtl] > .next-tag-close-btn {\n      margin-right: 9px;\n      margin-left: 0;\n      padding-right: 0;\n      padding-left: 16px; }\n  .next-tag-medium {\n    height: 28px;\n    padding: 0;\n    line-height: 26px;\n    font-size: 0; }\n    .next-tag-medium > .next-tag-body {\n      font-size: 14px;\n      padding: 0 12px; }\n    .next-tag-medium.next-tag-closable > .next-tag-body {\n      padding: 0 0 0 12px; }\n    .next-tag-medium[dir=rtl].next-tag-closable > .next-tag-body {\n      padding: 0 12px 0 0; }\n    .next-tag-medium > .next-tag-close-btn {\n      margin-left: 6px;\n      padding-right: 12px; }\n      .next-tag-medium > .next-tag-close-btn .next-icon:before {\n        width: 8px;\n        font-size: 8px;\n        line-height: inherit; }\n      @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n        .next-tag-medium > .next-tag-close-btn .next-icon {\n          -webkit-transform: scale(0.5);\n              -ms-transform: scale(0.5);\n                  transform: scale(0.5);\n          margin-left: -4px;\n          margin-right: -4px; }\n          .next-tag-medium > .next-tag-close-btn .next-icon:before {\n            width: 16px;\n            font-size: 16px; } }\n    .next-tag-medium[dir=rtl] > .next-tag-close-btn {\n      margin-right: 6px;\n      margin-left: 0;\n      padding-right: 0;\n      padding-left: 12px; }\n  .next-tag-small {\n    height: 20px;\n    padding: 0;\n    line-height: 18px;\n    font-size: 0; }\n    .next-tag-small > .next-tag-body {\n      font-size: 12px;\n      padding: 0 8px; }\n    .next-tag-small.next-tag-closable > .next-tag-body {\n      padding: 0 0 0 8px; }\n    .next-tag-small[dir=rtl].next-tag-closable > .next-tag-body {\n      padding: 0 8px 0 0; }\n    .next-tag-small > .next-tag-close-btn {\n      margin-left: 4px;\n      padding-right: 8px; }\n      .next-tag-small > .next-tag-close-btn .next-icon:before {\n        width: 8px;\n        font-size: 8px;\n        line-height: inherit; }\n      @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n        .next-tag-small > .next-tag-close-btn .next-icon {\n          -webkit-transform: scale(0.5);\n              -ms-transform: scale(0.5);\n                  transform: scale(0.5);\n          margin-left: -4px;\n          margin-right: -4px; }\n          .next-tag-small > .next-tag-close-btn .next-icon:before {\n            width: 16px;\n            font-size: 16px; } }\n    .next-tag-small[dir=rtl] > .next-tag-close-btn {\n      margin-right: 4px;\n      margin-left: 0;\n      padding-right: 0;\n      padding-left: 8px; }\n  .next-tag-default {\n    cursor: default; }\n  .next-tag-closable {\n    position: relative; }\n    .next-tag-closable > .next-tag-close-btn {\n      display: inline-block;\n      vertical-align: middle;\n      height: 100%;\n      text-align: center;\n      cursor: pointer; }\n    .next-tag-closable.next-tag-level-normal[disabled], .next-tag-closable.next-tag-level-normal.disabled {\n      color: #CCCCCC;\n      border-color: #E6E7EB;\n      background-color: #F7F8FA; }\n  .next-tag-checkable {\n    cursor: pointer;\n    position: relative;\n    border-radius: 3px; }\n    .next-tag-checkable.checked:before {\n      -webkit-animation: fadeInRightForTag 0.4s cubic-bezier(0.78, 0.14, 0.15, 0.86);\n              animation: fadeInRightForTag 0.4s cubic-bezier(0.78, 0.14, 0.15, 0.86); }\n    .next-tag-checkable.checked:after {\n      -webkit-animation: zoomIn 0.4s cubic-bezier(0.78, 0.14, 0.15, 0.86);\n              animation: zoomIn 0.4s cubic-bezier(0.78, 0.14, 0.15, 0.86); }\n    .next-tag-checkable.next-tag-small:not(.next-tag-level-primary):before {\n      right: -10px;\n      bottom: -10px;\n      width: 20px;\n      height: 20px; }\n    .next-tag-checkable.next-tag-small:not(.next-tag-level-primary):after {\n      font-size: 8px;\n      line-height: 8px;\n      right: 0;\n      bottom: 0; }\n    .next-tag-checkable.next-tag-medium:not(.next-tag-level-primary):before {\n      right: -14px;\n      bottom: -14px;\n      width: 28px;\n      height: 28px; }\n    .next-tag-checkable.next-tag-medium:not(.next-tag-level-primary):after {\n      font-size: 12px;\n      line-height: 12px;\n      right: 0;\n      bottom: 0; }\n    .next-tag-checkable.next-tag-large:not(.next-tag-level-primary):before {\n      right: -18px;\n      bottom: -18px;\n      width: 36px;\n      height: 36px; }\n    .next-tag-checkable.next-tag-large:not(.next-tag-level-primary):after {\n      font-size: 16px;\n      line-height: 16px;\n      right: 0;\n      bottom: 0; }\n    .next-tag-checkable.next-tag-level-primary[disabled], .next-tag-checkable.next-tag-level-primary.disabled {\n      color: #CCCCCC;\n      /* $tag-text-color-disabled; */\n      border-color: #F7F8FA;\n      background-color: #F7F8FA; }\n    .next-tag-checkable.next-tag-level-secondary[disabled], .next-tag-checkable.next-tag-level-secondary.disabled {\n      color: #CCCCCC;\n      border-color: #E6E7EB;\n      background-color: #F7F8FA; }\n  .next-tag-zoom-enter, .next-tag-zoom-appear {\n    -webkit-animation: fadeInLeft 0.4s cubic-bezier(0.78, 0.14, 0.15, 0.86);\n            animation: fadeInLeft 0.4s cubic-bezier(0.78, 0.14, 0.15, 0.86);\n    -webkit-animation-fill-mode: both;\n            animation-fill-mode: both; }\n  .next-tag-zoom-leave {\n    -webkit-animation: zoomOut .3s ease-in;\n            animation: zoomOut .3s ease-in;\n    -webkit-animation-fill-mode: both;\n            animation-fill-mode: both; }\n", ""]);

// exports


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n.next-select {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  display: inline-block;\n  font-size: 0;\n  vertical-align: middle;\n  /* Select trigger */\n  /* 弹层 */\n  /* 全选按钮 */\n  /* -------------- IE polyfill -------------- */\n  /* 根据最新的数据，在中国，PC 端的 IE9 份额为 2%， */\n  /* 所以不应该因为 IE9 而不使用 flex，而是应该做降级 polyfill */\n  /* @see http://gs.statcounter.com/ */\n  /* IE10、IE11 虽然支持 flex，但还是会有各种各样奇奇怪怪的问题 */ }\n  .next-select *,\n  .next-select *:before,\n  .next-select *:after {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box; }\n  .next-select-trigger {\n    min-width: 100px;\n    outline: 0;\n    -webkit-transition: all .3s ease;\n    transition: all .3s ease; }\n    .next-select-trigger .next-input-label {\n      -webkit-box-flex: 0;\n          -ms-flex: 0 0 auto;\n              flex: 0 0 auto;\n      width: auto; }\n    .next-select-trigger .next-select-values {\n      display: block;\n      width: 100%;\n      -webkit-box-flex: 1;\n          -ms-flex: 1 1 0px;\n              flex: 1 1 0;\n      overflow: hidden; }\n      .next-select-trigger .next-select-values > em {\n        font-style: inherit; }\n      .next-select-trigger .next-select-values input {\n        padding-left: 0;\n        padding-right: 0; }\n    .next-select-trigger .next-input-control {\n      -webkit-box-flex: 0;\n          -ms-flex: 0 0 auto;\n              flex: 0 0 auto;\n      width: auto; }\n      .next-select-trigger .next-input-control > * {\n        display: inline-block;\n        width: auto; }\n    .next-select-trigger .next-input.next-disabled em {\n      color: #CCCCCC; }\n    .next-select-trigger .next-input.next-disabled .next-select-arrow {\n      cursor: not-allowed; }\n    .next-select-trigger .next-select-clear {\n      display: none; }\n    .next-select-trigger.next-has-clear:hover .next-select-clear {\n      display: inline-block; }\n    .next-select-trigger.next-has-clear:hover .next-select-arrow {\n      display: none; }\n  .next-select .next-select-inner {\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    width: 100%;\n    min-width: 100px;\n    outline: 0;\n    color: #333333; }\n    .next-select .next-select-inner .next-tag {\n      line-height: 1;\n      margin-right: 4px;\n      margin-bottom: 3px;\n      padding-left: 4px;\n      padding-right: 4px; }\n  .next-select-trigger-search {\n    position: relative;\n    display: inline-block;\n    vertical-align: top;\n    overflow: hidden;\n    width: 100%;\n    max-width: 100%; }\n    .next-select-trigger-search > input, .next-select-trigger-search > span {\n      display: block;\n      font-size: inherit;\n      font-family: inherit;\n      letter-spacing: inherit;\n      white-space: nowrap;\n      overflow: hidden; }\n    .next-select-trigger-search input {\n      position: absolute;\n      background-color: transparent;\n      width: 100%;\n      height: 100% !important;\n      z-index: 1;\n      left: 0;\n      border: 0;\n      outline: 0;\n      margin: 0;\n      padding: 0;\n      cursor: inherit; }\n    .next-select-trigger-search > span {\n      position: relative;\n      visibility: hidden;\n      white-space: pre;\n      max-width: 100%;\n      /* 在 table 布局中，100% 并没有什么x用 */\n      z-index: -1; }\n  .next-select-single {\n    /* 搜索框激活时，展开后不显示值，只显示搜索框 */\n    /* 搜索框未激活，或者menu未展开，如果有值，则不显示搜索(placeholder) */ }\n    .next-select-single.next-no-search {\n      cursor: pointer; }\n    .next-select-single.next-has-search.next-active .next-select-values > em {\n      display: none; }\n    .next-select-single.next-no-search .next-select-values > em + .next-select-trigger-search, .next-select-single.next-inactive .next-select-values > em + .next-select-trigger-search {\n      width: 1px;\n      opacity: 0;\n      filter: alpha(opacity=0);\n      /* for IE 9 */ }\n    .next-select-single.next-no-search .next-select-trigger-search input, .next-select-single.next-inactive .next-select-trigger-search input {\n      color: transparent; }\n    .next-select-single .next-select-values {\n      display: -webkit-inline-box;\n      display: -ms-inline-flexbox;\n      display: inline-flex;\n      -webkit-box-align: center;\n          -ms-flex-align: center;\n              align-items: center; }\n      .next-select-single .next-select-values > em {\n        vertical-align: middle;\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap; }\n  .next-select-multiple, .next-select-tag {\n    /* 如果有值，则搜索框变为1px */ }\n    .next-select-multiple .next-select-values, .next-select-tag .next-select-values {\n      /* Tag 有 3px 的 margin-bottom，所以包裹 Tag 的容器要作一下处理 */\n      margin-bottom: -3px;\n      height: auto !important; }\n    .next-select-multiple .next-select-trigger-search, .next-select-tag .next-select-trigger-search {\n      margin-bottom: 3px; }\n    .next-select-multiple .next-tag + .next-select-trigger-search, .next-select-tag .next-tag + .next-select-trigger-search {\n      width: auto;\n      min-width: 1px;\n      /* 保留一个光标的宽度 */ }\n    .next-select-multiple .next-input, .next-select-tag .next-input {\n      height: auto;\n      -webkit-box-align: start;\n          -ms-flex-align: start;\n              align-items: start; }\n    .next-select-multiple.next-small .next-select-values, .next-select-tag.next-small .next-select-values {\n      min-height: 18px;\n      padding-top: 2px;\n      padding-bottom: 2px;\n      line-height: 14px; }\n    .next-select-multiple.next-small .next-tag, .next-select-tag.next-small .next-tag {\n      border: 0;\n      padding-top: 0px;\n      padding-bottom: 0px;\n      height: 14px; }\n      .next-select-multiple.next-small .next-tag .next-tag-body, .next-select-multiple.next-small .next-tag .next-tag-close-btn, .next-select-tag.next-small .next-tag .next-tag-body, .next-select-tag.next-small .next-tag .next-tag-close-btn {\n        line-height: 14px; }\n      .next-select-multiple.next-small .next-tag-body, .next-select-tag.next-small .next-tag-body {\n        line-height: 14px; }\n    .next-select-multiple.next-small .next-input-label, .next-select-multiple.next-small .next-input-control, .next-select-tag.next-small .next-input-label, .next-select-tag.next-small .next-input-control {\n      line-height: 18px; }\n    .next-select-multiple.next-medium .next-select-values, .next-select-tag.next-medium .next-select-values {\n      min-height: 26px;\n      padding-top: 3px;\n      padding-bottom: 3px;\n      line-height: 20px; }\n    .next-select-multiple.next-medium .next-tag, .next-select-tag.next-medium .next-tag {\n      padding-top: 1px;\n      padding-bottom: 1px;\n      height: 20px; }\n      .next-select-multiple.next-medium .next-tag .next-tag-body, .next-select-multiple.next-medium .next-tag .next-tag-close-btn, .next-select-tag.next-medium .next-tag .next-tag-body, .next-select-tag.next-medium .next-tag .next-tag-close-btn {\n        line-height: 18px; }\n    .next-select-multiple.next-medium .next-input-label, .next-select-multiple.next-medium .next-input-control, .next-select-tag.next-medium .next-input-label, .next-select-tag.next-medium .next-input-control {\n      line-height: 26px; }\n    .next-select-multiple.next-large .next-select-values, .next-select-tag.next-large .next-select-values {\n      min-height: 38px;\n      padding-top: 7px;\n      padding-bottom: 7px;\n      line-height: 24px; }\n    .next-select-multiple.next-large .next-tag, .next-select-tag.next-large .next-tag {\n      padding-top: 3px;\n      padding-bottom: 3px;\n      height: 24px; }\n      .next-select-multiple.next-large .next-tag .next-tag-body, .next-select-multiple.next-large .next-tag .next-tag-close-btn, .next-select-tag.next-large .next-tag .next-tag-body, .next-select-tag.next-large .next-tag .next-tag-close-btn {\n        line-height: 18px; }\n    .next-select-multiple.next-large .next-input-label, .next-select-multiple.next-large .next-input-control, .next-select-tag.next-large .next-input-label, .next-select-tag.next-large .next-input-control {\n      line-height: 38px; }\n  .next-select.next-no-search {\n    /* 在搜索框未激活时，将 input 的 color 置为透明 */\n    /* ISSUE: 在 firefox 中，readonly 的 input 仍然会显示光标 */ }\n    .next-select.next-no-search .next-select-trigger-search input {\n      color: transparent; }\n  .next-select-auto-complete {\n    width: 160px; }\n    .next-select-auto-complete .next-input {\n      width: 100%;\n      /* table-cell 下 margin 无效 */ }\n      .next-select-auto-complete .next-input .next-input-hint-wrap {\n        padding-right: 1px; }\n      .next-select-auto-complete .next-input .next-select-arrow {\n        padding-left: 0; }\n  .next-select.next-active .next-select-arrow {\n    -webkit-transform: rotate(180deg);\n        -ms-transform: rotate(180deg);\n            transform: rotate(180deg); }\n  .next-select-arrow {\n    cursor: pointer;\n    width: auto !important;\n    text-align: center;\n    -webkit-transition: all .3s ease;\n    transition: all .3s ease;\n    /* transform-origin: center 41.8%; // icon 图像中心 */ }\n  .next-select-menu-wrapper {\n    max-height: 260px;\n    overflow: auto;\n    border: 1px solid #DCDEE3;\n    border-radius: 3px;\n    -webkit-box-shadow: none;\n            box-shadow: none; }\n    .next-select-menu-wrapper .next-select-menu {\n      max-height: none;\n      border: none; }\n  .next-select-menu {\n    max-height: 260px;\n    overflow: auto;\n    /* autoComplete 没有选项时 menu 不显示 */ }\n    .next-select-menu .next-select-menu-empty-content {\n      padding-left: 8px;\n      padding-right: 8px;\n      color: #999999; }\n    .next-select-menu.next-select-auto-complete-menu.next-select-menu-empty {\n      display: none; }\n    .next-select-menu .next-menu-item-text .next-icon {\n      vertical-align: middle; }\n  .next-select-all {\n    display: block;\n    cursor: pointer;\n    line-height: 20px;\n    padding: 4px 8px;\n    margin: 0 12px 8px;\n    border-bottom: 1px solid #DCDEE3; }\n    .next-select-all:hover {\n      color: #3E71F7; }\n  .next-select-highlight {\n    color: #5584FF;\n    font-size: 12px; }\n  .next-select-in-ie.next-select-trigger .next-select-values {\n    /* 在 table 布局中，overflow: hidden 会导致负的 margin 失效 */\n    overflow: visible; }\n  .next-select-in-ie.next-select-trigger .next-input-control, .next-select-in-ie.next-select-trigger .next-input-label {\n    width: 1px; }\n  .next-select-in-ie.next-select-trigger .next-input-control > * {\n    display: table-cell;\n    width: 1%; }\n  .next-select-in-ie.next-select-trigger .next-select-arrow {\n    display: table-cell; }\n  .next-select-in-ie.next-select-trigger .next-select-clear {\n    display: none; }\n  .next-select-in-ie.next-select-trigger.next-select-multiple .next-select-inner, .next-select-in-ie.next-select-trigger.next-select-tag .next-select-inner {\n    vertical-align: top; }\n  .next-select-in-ie.next-select-trigger .next-select-inner {\n    display: inline-table; }\n  .next-select-in-ie.next-select-trigger.next-select-single .next-select-values {\n    display: inline-table; }\n  .next-select-in-ie.next-select-trigger.next-select-single .next-input.next-small .next-select-values {\n    line-height: 20px; }\n  .next-select-in-ie.next-select-trigger.next-select-single .next-input.next-medium .next-select-values {\n    line-height: 28px; }\n  .next-select-in-ie.next-select-trigger.next-select-single .next-input.next-large .next-select-values {\n    line-height: 40px; }\n  .next-select-in-ie.next-select-trigger .next-select-trigger-search > span {\n    max-width: 100px; }\n  .next-select-in-ie.next-select-trigger.next-select-single {\n    /* 搜索框未激活，或者menu未展开，如果有值，则不显示搜索(placeholder) */ }\n    .next-select-in-ie.next-select-trigger.next-select-single.next-select-in-ie-fixwidth .next-select-values {\n      position: relative; }\n      .next-select-in-ie.next-select-trigger.next-select-single.next-select-in-ie-fixwidth .next-select-values > em {\n        position: absolute;\n        display: inline-block;\n        height: 100%;\n        line-height: 1;\n        vertical-align: middle;\n        overflow: hidden;\n        left: 4px;\n        right: 0;\n        top: 30%; }\n    .next-select-in-ie.next-select-trigger.next-select-single.next-no-search .next-select-values > em + .next-select-trigger-search, .next-select-in-ie.next-select-trigger.next-select-single.next-inactive .next-select-values > em + .next-select-trigger-search {\n      filter: alpha(opacity=0);\n      /* for IE 9 */\n      font-size: 0; }\n    .next-select-in-ie.next-select-trigger.next-select-single.next-no-search .next-select-trigger-search input, .next-select-in-ie.next-select-trigger.next-select-single.next-inactive .next-select-trigger-search input {\n      color: inherit; }\n  .next-select-in-ie.next-select-trigger.next-no-search .next-select-trigger-search input {\n    color: inherit; }\n", ""]);

// exports


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n.next-pagination[dir=\"rtl\"] .next-pagination-total {\n  margin-right: 0;\n  margin-left: 16px; }\n\n.next-pagination[dir=\"rtl\"] .next-pagination-jump-go {\n  margin-left: 0;\n  margin-right: 4px; }\n\n.next-pagination[dir=\"rtl\"] .next-pagination-size-selector-title {\n  margin-right: 0;\n  margin-left: 4px; }\n\n.next-pagination[dir=\"rtl\"] .next-pagination-size-selector-btn.next-btn-text + .next-pagination-size-selector-btn {\n  border-left: none;\n  border-right: 1px solid #DCDEE3; }\n\n.next-pagination[dir=\"rtl\"] .next-pagination-pages + .next-pagination-size-selector,\n.next-pagination[dir=\"rtl\"] .next-pagination-size-selector + .next-pagination-pages {\n  margin-left: 0;\n  margin-right: 40px; }\n\n.next-pagination[dir=\"rtl\"].next-start .next-pagination-pages {\n  float: left; }\n\n.next-pagination[dir=\"rtl\"].next-start .next-pagination-size-selector {\n  float: right; }\n\n.next-pagination[dir=\"rtl\"].next-end .next-pagination-pages {\n  float: right; }\n\n.next-pagination[dir=\"rtl\"].next-end .next-pagination-size-selector {\n  float: left; }\n\n.next-pagination[dir=\"rtl\"].next-small .next-pagination-list {\n  margin: 0 4px; }\n\n.next-pagination[dir=\"rtl\"].next-small .next-pagination-total {\n  line-height: 20px;\n  vertical-align: middle; }\n\n.next-pagination[dir=\"rtl\"].next-small .next-pagination-item {\n  padding: 0 6px; }\n  .next-pagination[dir=\"rtl\"].next-small .next-pagination-item + .next-pagination-item {\n    margin: 0 4px 0 0; }\n\n.next-pagination[dir=\"rtl\"].next-small .next-pagination-ellipsis {\n  height: 20px;\n  line-height: 20px;\n  margin-left: 8px;\n  margin-right: 8px; }\n  .next-pagination[dir=\"rtl\"].next-small .next-pagination-ellipsis:before {\n    width: 12px;\n    font-size: 12px;\n    line-height: inherit; }\n\n.next-pagination[dir=\"rtl\"].next-small .next-pagination-display {\n  font-size: 12px; }\n  .next-pagination[dir=\"rtl\"].next-small .next-pagination-display em {\n    font-size: 12px; }\n\n.next-pagination[dir=\"rtl\"].next-small .next-pagination-jump-text {\n  font-size: 12px; }\n\n.next-pagination[dir=\"rtl\"].next-small .next-pagination-jump-input {\n  width: 28px; }\n\n.next-pagination[dir=\"rtl\"].next-small .next-pagination-size-selector-title {\n  height: 20px;\n  line-height: 20px;\n  font-size: 12px;\n  vertical-align: middle; }\n\n.next-pagination[dir=\"rtl\"].next-small .next-pagination-size-selector-btn {\n  padding: 0 8px; }\n\n.next-pagination[dir=\"rtl\"].next-small .next-pagination-item.next-prev:not([disabled]) i,\n.next-pagination[dir=\"rtl\"].next-small .next-pagination-item.next-next:not([disabled]) i {\n  color: #666666; }\n\n.next-pagination[dir=\"rtl\"].next-small .next-pagination-item:hover.next-prev:not([disabled]) i,\n.next-pagination[dir=\"rtl\"].next-small .next-pagination-item:hover.next-next:not([disabled]) i {\n  color: #333333; }\n\n.next-pagination[dir=\"rtl\"].next-medium .next-pagination-list {\n  margin: 0 4px; }\n\n.next-pagination[dir=\"rtl\"].next-medium .next-pagination-total {\n  line-height: 28px;\n  vertical-align: middle; }\n\n.next-pagination[dir=\"rtl\"].next-medium .next-pagination-item {\n  padding: 0 10px; }\n  .next-pagination[dir=\"rtl\"].next-medium .next-pagination-item + .next-pagination-item {\n    margin: 0 4px 0 0; }\n\n.next-pagination[dir=\"rtl\"].next-medium .next-pagination-ellipsis {\n  height: 28px;\n  line-height: 28px;\n  margin-left: 8px;\n  margin-right: 8px; }\n  .next-pagination[dir=\"rtl\"].next-medium .next-pagination-ellipsis:before {\n    width: 12px;\n    font-size: 12px;\n    line-height: inherit; }\n\n.next-pagination[dir=\"rtl\"].next-medium .next-pagination-display {\n  font-size: 12px; }\n  .next-pagination[dir=\"rtl\"].next-medium .next-pagination-display em {\n    font-size: 12px; }\n\n.next-pagination[dir=\"rtl\"].next-medium .next-pagination-jump-text {\n  font-size: 12px; }\n\n.next-pagination[dir=\"rtl\"].next-medium .next-pagination-jump-input {\n  width: 36px; }\n\n.next-pagination[dir=\"rtl\"].next-medium .next-pagination-size-selector-title {\n  height: 28px;\n  line-height: 28px;\n  font-size: 12px;\n  vertical-align: middle; }\n\n.next-pagination[dir=\"rtl\"].next-medium .next-pagination-size-selector-btn {\n  padding: 0 12px; }\n\n.next-pagination[dir=\"rtl\"].next-medium .next-pagination-item.next-prev:not([disabled]) i,\n.next-pagination[dir=\"rtl\"].next-medium .next-pagination-item.next-next:not([disabled]) i {\n  color: #666666; }\n\n.next-pagination[dir=\"rtl\"].next-medium .next-pagination-item:hover.next-prev:not([disabled]) i,\n.next-pagination[dir=\"rtl\"].next-medium .next-pagination-item:hover.next-next:not([disabled]) i {\n  color: #333333; }\n\n.next-pagination[dir=\"rtl\"].next-large .next-pagination-list {\n  margin: 0 8px; }\n\n.next-pagination[dir=\"rtl\"].next-large .next-pagination-total {\n  line-height: 40px;\n  vertical-align: middle; }\n\n.next-pagination[dir=\"rtl\"].next-large .next-pagination-item {\n  padding: 0 15px; }\n  .next-pagination[dir=\"rtl\"].next-large .next-pagination-item + .next-pagination-item {\n    margin: 0 8px 0 0; }\n\n.next-pagination[dir=\"rtl\"].next-large .next-pagination-ellipsis {\n  height: 40px;\n  line-height: 40px;\n  margin-left: 8px;\n  margin-right: 8px; }\n  .next-pagination[dir=\"rtl\"].next-large .next-pagination-ellipsis:before {\n    width: 16px;\n    font-size: 16px;\n    line-height: inherit; }\n\n.next-pagination[dir=\"rtl\"].next-large .next-pagination-display {\n  font-size: 16px; }\n  .next-pagination[dir=\"rtl\"].next-large .next-pagination-display em {\n    font-size: 16px; }\n\n.next-pagination[dir=\"rtl\"].next-large .next-pagination-jump-text {\n  font-size: 16px; }\n\n.next-pagination[dir=\"rtl\"].next-large .next-pagination-jump-input {\n  width: 48px; }\n\n.next-pagination[dir=\"rtl\"].next-large .next-pagination-size-selector-title {\n  height: 40px;\n  line-height: 40px;\n  font-size: 16px;\n  vertical-align: middle; }\n\n.next-pagination[dir=\"rtl\"].next-large .next-pagination-size-selector-btn {\n  padding: 0 16px; }\n\n.next-pagination[dir=\"rtl\"].next-large .next-pagination-item.next-prev:not([disabled]) i,\n.next-pagination[dir=\"rtl\"].next-large .next-pagination-item.next-next:not([disabled]) i {\n  color: #666666; }\n\n.next-pagination[dir=\"rtl\"].next-large .next-pagination-item:hover.next-prev:not([disabled]) i,\n.next-pagination[dir=\"rtl\"].next-large .next-pagination-item:hover.next-next:not([disabled]) i {\n  color: #333333; }\n\n.next-pagination {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  font-size: 0; }\n  .next-pagination *,\n  .next-pagination *:before,\n  .next-pagination *:after {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box; }\n  .next-pagination:after {\n    visibility: hidden;\n    display: block;\n    height: 0;\n    font-size: 0;\n    content: ' ';\n    clear: both; }\n  .next-pagination-total {\n    display: inline-block;\n    font-size: 14px;\n    margin-right: 16px; }\n  .next-pagination-pages {\n    display: inline-block; }\n  .next-pagination-list {\n    display: inline-block;\n    vertical-align: top; }\n  .next-pagination .next-pagination-item {\n    display: inline-block; }\n    .next-pagination .next-pagination-item.next-current {\n      border-color: #5584FF;\n      background: #5584FF;\n      color: #FFFFFF; }\n    .next-pagination .next-pagination-item.next-current:hover, .next-pagination .next-pagination-item.next-current:focus {\n      border-color: #5584FF;\n      background: #5584FF;\n      color: #FFFFFF; }\n  .next-pagination-ellipsis {\n    display: inline-block;\n    color: #999999;\n    vertical-align: top; }\n  .next-pagination-display {\n    display: inline-block;\n    margin: 0 16px;\n    color: #333333;\n    vertical-align: middle; }\n    .next-pagination-display em {\n      font-style: normal;\n      color: #5584FF; }\n  .next-pagination-jump-text {\n    display: inline-block;\n    vertical-align: middle;\n    color: #999999; }\n  .next-pagination-jump-input {\n    margin: 0 4px;\n    vertical-align: top; }\n  .next-pagination-jump-go {\n    margin-left: 4px;\n    vertical-align: top; }\n  .next-pagination-size-selector {\n    display: inline-block;\n    position: relative; }\n    .next-pagination-size-selector-title {\n      margin-right: 4px;\n      color: #999999; }\n    .next-pagination-size-selector-filter {\n      display: inline-block;\n      vertical-align: middle; }\n    .next-pagination-size-selector-dropdown {\n      vertical-align: top;\n      min-width: 64px; }\n    .next-pagination-size-selector-popup {\n      min-width: 64px; }\n    .next-pagination-size-selector-btn.next-btn-text {\n      height: initial;\n      line-height: initial;\n      color: #666666;\n      border-radius: 0; }\n      .next-pagination-size-selector-btn.next-btn-text.next-current {\n        color: #5584FF; }\n      .next-pagination-size-selector-btn.next-btn-text + .next-pagination-size-selector-btn {\n        border-left: 1px solid #DCDEE3; }\n  .next-pagination-pages + .next-pagination-size-selector,\n  .next-pagination-size-selector + .next-pagination-pages {\n    margin-left: 40px; }\n  .next-pagination.next-hide {\n    display: none; }\n  .next-pagination.next-start .next-pagination-pages {\n    float: right; }\n  .next-pagination.next-start .next-pagination-size-selector {\n    float: left; }\n  .next-pagination.next-end .next-pagination-pages {\n    float: left; }\n  .next-pagination.next-end .next-pagination-size-selector {\n    float: right; }\n  .next-pagination.next-small .next-pagination-list {\n    margin: 0 4px; }\n  .next-pagination.next-small .next-pagination-total {\n    line-height: 20px;\n    vertical-align: middle; }\n  .next-pagination.next-small .next-pagination-item {\n    padding: 0 6px; }\n    .next-pagination.next-small .next-pagination-item + .next-pagination-item {\n      margin: 0 0 0 4px; }\n  .next-pagination.next-small .next-pagination-ellipsis {\n    height: 20px;\n    line-height: 20px;\n    margin-left: 8px;\n    margin-right: 8px; }\n    .next-pagination.next-small .next-pagination-ellipsis:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-pagination.next-small .next-pagination-display {\n    font-size: 12px; }\n    .next-pagination.next-small .next-pagination-display em {\n      font-size: 12px; }\n  .next-pagination.next-small .next-pagination-jump-text {\n    font-size: 12px; }\n  .next-pagination.next-small .next-pagination-jump-input {\n    width: 28px; }\n  .next-pagination.next-small .next-pagination-size-selector-title {\n    height: 20px;\n    line-height: 20px;\n    font-size: 12px;\n    vertical-align: middle; }\n  .next-pagination.next-small .next-pagination-size-selector-btn {\n    padding: 0 8px; }\n  .next-pagination.next-small .next-pagination-item.next-prev:not([disabled]) i,\n  .next-pagination.next-small .next-pagination-item.next-next:not([disabled]) i {\n    color: #666666; }\n  .next-pagination.next-small .next-pagination-item:hover.next-prev:not([disabled]) i,\n  .next-pagination.next-small .next-pagination-item:hover.next-next:not([disabled]) i {\n    color: #333333; }\n  .next-pagination.next-small.next-arrow-only .next-pagination-item.next-prev, .next-pagination.next-small.next-arrow-only .next-pagination-item.next-next {\n    width: 20px;\n    padding: 0; }\n    .next-pagination.next-small.next-arrow-only .next-pagination-item.next-prev .next-icon, .next-pagination.next-small.next-arrow-only .next-pagination-item.next-next .next-icon {\n      margin: 0 auto; }\n  .next-pagination.next-small.next-arrow-prev-only .next-pagination-item.next-prev {\n    width: 20px;\n    padding: 0; }\n    .next-pagination.next-small.next-arrow-prev-only .next-pagination-item.next-prev .next-icon {\n      margin: 0 auto; }\n  .next-pagination.next-small.next-no-border .next-pagination-item.next-prev, .next-pagination.next-small.next-no-border .next-pagination-item.next-next {\n    padding: 0;\n    border: none;\n    background-color: transparent;\n    -webkit-box-shadow: none;\n            box-shadow: none; }\n    .next-pagination.next-small.next-no-border .next-pagination-item.next-prev .next-icon, .next-pagination.next-small.next-no-border .next-pagination-item.next-next .next-icon {\n      margin: 0; }\n  .next-pagination.next-small.next-no-border .next-pagination-item.next-prev:not([disabled]):hover i,\n  .next-pagination.next-small.next-no-border .next-pagination-item.next-next:not([disabled]):hover i {\n    color: #5584FF; }\n  .next-pagination.next-small.next-no-border .next-pagination-display {\n    margin: 0 8px; }\n  .next-pagination.next-small.next-mini .next-pagination-item.next-prev {\n    margin-right: 4px; }\n  .next-pagination.next-small.next-mini .next-pagination-item.next-next {\n    margin-left: 4px; }\n  .next-pagination.next-medium .next-pagination-list {\n    margin: 0 4px; }\n  .next-pagination.next-medium .next-pagination-total {\n    line-height: 28px;\n    vertical-align: middle; }\n  .next-pagination.next-medium .next-pagination-item {\n    padding: 0 10px; }\n    .next-pagination.next-medium .next-pagination-item + .next-pagination-item {\n      margin: 0 0 0 4px; }\n  .next-pagination.next-medium .next-pagination-ellipsis {\n    height: 28px;\n    line-height: 28px;\n    margin-left: 8px;\n    margin-right: 8px; }\n    .next-pagination.next-medium .next-pagination-ellipsis:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-pagination.next-medium .next-pagination-display {\n    font-size: 12px; }\n    .next-pagination.next-medium .next-pagination-display em {\n      font-size: 12px; }\n  .next-pagination.next-medium .next-pagination-jump-text {\n    font-size: 12px; }\n  .next-pagination.next-medium .next-pagination-jump-input {\n    width: 36px; }\n  .next-pagination.next-medium .next-pagination-size-selector-title {\n    height: 28px;\n    line-height: 28px;\n    font-size: 12px;\n    vertical-align: middle; }\n  .next-pagination.next-medium .next-pagination-size-selector-btn {\n    padding: 0 12px; }\n  .next-pagination.next-medium .next-pagination-item.next-prev:not([disabled]) i,\n  .next-pagination.next-medium .next-pagination-item.next-next:not([disabled]) i {\n    color: #666666; }\n  .next-pagination.next-medium .next-pagination-item:hover.next-prev:not([disabled]) i,\n  .next-pagination.next-medium .next-pagination-item:hover.next-next:not([disabled]) i {\n    color: #333333; }\n  .next-pagination.next-medium.next-arrow-only .next-pagination-item.next-prev, .next-pagination.next-medium.next-arrow-only .next-pagination-item.next-next {\n    width: 28px;\n    padding: 0; }\n    .next-pagination.next-medium.next-arrow-only .next-pagination-item.next-prev .next-icon, .next-pagination.next-medium.next-arrow-only .next-pagination-item.next-next .next-icon {\n      margin: 0 auto; }\n  .next-pagination.next-medium.next-arrow-prev-only .next-pagination-item.next-prev {\n    width: 28px;\n    padding: 0; }\n    .next-pagination.next-medium.next-arrow-prev-only .next-pagination-item.next-prev .next-icon {\n      margin: 0 auto; }\n  .next-pagination.next-medium.next-no-border .next-pagination-item.next-prev, .next-pagination.next-medium.next-no-border .next-pagination-item.next-next {\n    padding: 0;\n    border: none;\n    background-color: transparent;\n    -webkit-box-shadow: none;\n            box-shadow: none; }\n    .next-pagination.next-medium.next-no-border .next-pagination-item.next-prev .next-icon, .next-pagination.next-medium.next-no-border .next-pagination-item.next-next .next-icon {\n      margin: 0; }\n  .next-pagination.next-medium.next-no-border .next-pagination-item.next-prev:not([disabled]):hover i,\n  .next-pagination.next-medium.next-no-border .next-pagination-item.next-next:not([disabled]):hover i {\n    color: #5584FF; }\n  .next-pagination.next-medium.next-no-border .next-pagination-display {\n    margin: 0 12px; }\n  .next-pagination.next-medium.next-mini .next-pagination-item.next-prev {\n    margin-right: 4px; }\n  .next-pagination.next-medium.next-mini .next-pagination-item.next-next {\n    margin-left: 4px; }\n  .next-pagination.next-large .next-pagination-list {\n    margin: 0 8px; }\n  .next-pagination.next-large .next-pagination-total {\n    line-height: 40px;\n    vertical-align: middle; }\n  .next-pagination.next-large .next-pagination-item {\n    padding: 0 15px; }\n    .next-pagination.next-large .next-pagination-item + .next-pagination-item {\n      margin: 0 0 0 8px; }\n  .next-pagination.next-large .next-pagination-ellipsis {\n    height: 40px;\n    line-height: 40px;\n    margin-left: 8px;\n    margin-right: 8px; }\n    .next-pagination.next-large .next-pagination-ellipsis:before {\n      width: 16px;\n      font-size: 16px;\n      line-height: inherit; }\n  .next-pagination.next-large .next-pagination-display {\n    font-size: 16px; }\n    .next-pagination.next-large .next-pagination-display em {\n      font-size: 16px; }\n  .next-pagination.next-large .next-pagination-jump-text {\n    font-size: 16px; }\n  .next-pagination.next-large .next-pagination-jump-input {\n    width: 48px; }\n  .next-pagination.next-large .next-pagination-size-selector-title {\n    height: 40px;\n    line-height: 40px;\n    font-size: 16px;\n    vertical-align: middle; }\n  .next-pagination.next-large .next-pagination-size-selector-btn {\n    padding: 0 16px; }\n  .next-pagination.next-large .next-pagination-item.next-prev:not([disabled]) i,\n  .next-pagination.next-large .next-pagination-item.next-next:not([disabled]) i {\n    color: #666666; }\n  .next-pagination.next-large .next-pagination-item:hover.next-prev:not([disabled]) i,\n  .next-pagination.next-large .next-pagination-item:hover.next-next:not([disabled]) i {\n    color: #333333; }\n  .next-pagination.next-large.next-arrow-only .next-pagination-item.next-prev, .next-pagination.next-large.next-arrow-only .next-pagination-item.next-next {\n    width: 40px;\n    padding: 0; }\n    .next-pagination.next-large.next-arrow-only .next-pagination-item.next-prev .next-icon, .next-pagination.next-large.next-arrow-only .next-pagination-item.next-next .next-icon {\n      margin: 0 auto; }\n  .next-pagination.next-large.next-arrow-prev-only .next-pagination-item.next-prev {\n    width: 40px;\n    padding: 0; }\n    .next-pagination.next-large.next-arrow-prev-only .next-pagination-item.next-prev .next-icon {\n      margin: 0 auto; }\n  .next-pagination.next-large.next-no-border .next-pagination-item.next-prev, .next-pagination.next-large.next-no-border .next-pagination-item.next-next {\n    padding: 0;\n    border: none;\n    background-color: transparent;\n    -webkit-box-shadow: none;\n            box-shadow: none; }\n    .next-pagination.next-large.next-no-border .next-pagination-item.next-prev .next-icon, .next-pagination.next-large.next-no-border .next-pagination-item.next-next .next-icon {\n      margin: 0; }\n  .next-pagination.next-large.next-no-border .next-pagination-item.next-prev:not([disabled]):hover i,\n  .next-pagination.next-large.next-no-border .next-pagination-item.next-next:not([disabled]):hover i {\n    color: #5584FF; }\n  .next-pagination.next-large.next-no-border .next-pagination-display {\n    margin: 0 16px; }\n  .next-pagination.next-large.next-mini .next-pagination-item.next-prev {\n    margin-right: 8px; }\n  .next-pagination.next-large.next-mini .next-pagination-item.next-next {\n    margin-left: 8px; }\n", ""]);

// exports


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, ".page-demo {\n    margin-top:10px;\n}", ""]);

// exports


/***/ }),
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _util = __webpack_require__(2);

var _zhCn = __webpack_require__(35);

var _zhCn2 = _interopRequireDefault(_zhCn);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var Base = (_temp2 = _class = function (_React$Component) {
    _inherits(Base, _React$Component);

    function Base() {
        var _temp, _this, _ret;

        _classCallCheck(this, Base);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.saveRef = function (input) {
            _this.inputRef = input;
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Base.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if ('value' in nextProps) {
            this.setState({
                value: typeof nextProps.value === 'undefined' ? '' : nextProps.value
            });
        }
    };

    Base.prototype.ieHack = function ieHack(value) {
        return value;
    };

    Base.prototype.onChange = function onChange(e) {
        var value = e.target.value;

        if (this.props.trim) {
            value = value.trim();
        }

        value = this.ieHack(value);

        // not controlled
        if (!('value' in this.props)) {
            this.setState({
                value: value
            });
        }

        // Number('') = 0
        if (value && this.props.htmlType === 'number') {
            value = Number(value);
        }

        this.props.onChange(value, e);
    };

    Base.prototype.onKeyDown = function onKeyDown(e) {
        var value = e.target.value;
        var maxLength = this.props.maxLength;

        var len = maxLength > 0 && value ? this.getValueLength(value) : 0;
        var opts = {};

        // has enable trim and has input whitespace
        if (this.props.trim && e.keyCode === 32) {
            opts.beTrimed = true;
        }

        // has defined maxLength and has over max length and has not input backspace and delete
        if (maxLength > 0 && (len > maxLength + 1 || (len === maxLength || len === maxLength + 1) && e.keyCode !== 8 && e.keyCode !== 46)) {
            opts.overMaxLength = true;
        }

        this.props.onKeyDown(e, opts);
    };

    Base.prototype.onFocus = function onFocus(e) {
        this.setState({
            focus: true
        });
        this.props.onFocus(e);
    };

    Base.prototype.onBlur = function onBlur(e) {
        this.setState({
            focus: false
        });
        this.props.onBlur(e);
    };

    Base.prototype.renderLength = function renderLength() {
        var _classNames;

        var _props = this.props,
            maxLength = _props.maxLength,
            hasLimitHint = _props.hasLimitHint,
            prefix = _props.prefix,
            rtl = _props.rtl;

        var len = maxLength > 0 && this.state.value ? this.getValueLength(this.state.value) : 0;

        var classesLenWrap = (0, _classnames2.default)((_classNames = {}, _classNames[prefix + 'input-len'] = true, _classNames[prefix + 'error'] = len > maxLength, _classNames));

        var content = rtl ? maxLength + '/' + len : len + '/' + maxLength;

        return maxLength && hasLimitHint ? _react2.default.createElement(
            'span',
            { className: classesLenWrap },
            content
        ) : null;
    };

    Base.prototype.renderControl = function renderControl() {
        var lenWrap = this.renderLength();

        return lenWrap ? _react2.default.createElement(
            'span',
            { className: this.props.prefix + 'input-control' },
            lenWrap
        ) : null;
    };

    Base.prototype.getClass = function getClass() {
        var _classNames2;

        var _props2 = this.props,
            disabled = _props2.disabled,
            state = _props2.state,
            prefix = _props2.prefix;


        return (0, _classnames2.default)((_classNames2 = {}, _classNames2[prefix + 'input'] = true, _classNames2[prefix + 'disabled'] = !!disabled, _classNames2[prefix + 'error'] = state === 'error', _classNames2[prefix + 'focus'] = this.state.focus, _classNames2));
    };

    Base.prototype.getProps = function getProps() {
        var _props3 = this.props,
            placeholder = _props3.placeholder,
            inputStyle = _props3.inputStyle,
            disabled = _props3.disabled,
            readOnly = _props3.readOnly,
            cutString = _props3.cutString,
            maxLength = _props3.maxLength;

        var props = {
            style: inputStyle,
            placeholder: placeholder,
            disabled: disabled,
            readOnly: readOnly,
            maxLength: cutString ? maxLength : undefined,
            value: this.state.value,
            onChange: this.onChange.bind(this),
            onBlur: this.onBlur.bind(this),
            onFocus: this.onFocus.bind(this)
        };

        // fix accessibility：auto process status of aria disabled
        if (disabled) {
            props['aria-disabled'] = disabled;
        }

        return props;
    };

    Base.prototype.getInputNode = function getInputNode() {
        return this.inputRef;
    };

    Base.prototype.focus = function focus(start, end) {
        this.inputRef.focus();
        if (typeof start !== 'undefined') {
            this.inputRef.selectionStart = start;
        }
        if (typeof end !== 'undefined') {
            this.inputRef.selectionEnd = end;
        }
    };

    return Base;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    /**
     * 当前值
     */
    value: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
    /**
     * 初始化值
     */
    defaultValue: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
    /**
     * 发生改变的时候触发的回调
     * @param {String} value 数据
     * @param {Event} e DOM事件对象
     */
    onChange: _propTypes2.default.func,
    /**
     * 键盘按下的时候触发的回调
     * @param {Event} e DOM事件对象
     * @param {Object} opts 可扩展的附加信息：<br> - opts.overMaxLength: {Boolean} 已超出最大长度<br> - opts.beTrimed: {Boolean} 输入的空格被清理
     */
    onKeyDown: _propTypes2.default.func,
    /**
     * 禁用状态
     */
    disabled: _propTypes2.default.bool,
    /**
     * 最大长度
     */
    maxLength: _propTypes2.default.number,
    /**
     * 是否展现最大长度样式
     */
    hasLimitHint: _propTypes2.default.bool,
    /**
     * 当设置了maxLength时，是否截断超出字符串
     */
    cutString: _propTypes2.default.bool,
    /**
     * 只读
     */
    readOnly: _propTypes2.default.bool,
    /**
     * onChange返回会自动去除头尾空字符
     */
    trim: _propTypes2.default.bool,
    /**
     * 输入提示
     */
    placeholder: _propTypes2.default.string,
    /**
     * 获取焦点时候触发的回调
     */
    onFocus: _propTypes2.default.func,
    /**
     * 失去焦点时候触发的回调
     */
    onBlur: _propTypes2.default.func,
    /**
     * 自定义字符串计算长度方式
     * @param {String} value 数据
     * @returns {Number} 自定义长度
     */
    getValueLength: _propTypes2.default.func,
    inputStyle: _propTypes2.default.object,
    /**
     * 自定义class
     */
    className: _propTypes2.default.string,
    /**
     * 自定义内联样式
     */
    style: _propTypes2.default.object,
    /**
     * 原生type
     */
    htmlType: _propTypes2.default.string,
    /**
     * name
     */
    name: _propTypes2.default.string,
    rtl: _propTypes2.default.bool,
    state: _propTypes2.default.oneOf(['error', 'loading', 'success']),
    locale: _propTypes2.default.object
}, _class.defaultProps = {
    disabled: false,
    prefix: 'next-',
    maxLength: null,
    hasLimitHint: false,
    cutString: true,
    readOnly: false,
    trim: false,
    onFocus: _util.func.noop,
    onBlur: _util.func.noop,
    onChange: _util.func.noop,
    onKeyDown: _util.func.noop,
    getValueLength: _util.func.noop,
    locale: _zhCn2.default.Input
}, _temp2);
Base.displayName = 'Base';
exports.default = Base;
module.exports = exports['default'];

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Input.Group
 */
var Group = (_temp = _class = function (_React$Component) {
    _inherits(Group, _React$Component);

    function Group() {
        _classCallCheck(this, Group);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    Group.prototype.render = function render() {
        var _classNames, _classNames2, _classNames3;

        var _props = this.props,
            className = _props.className,
            style = _props.style,
            children = _props.children,
            prefix = _props.prefix,
            addonBefore = _props.addonBefore,
            addonAfter = _props.addonAfter,
            addonBeforeClassName = _props.addonBeforeClassName,
            addonAfterClassName = _props.addonAfterClassName,
            rtl = _props.rtl,
            others = _objectWithoutProperties(_props, ['className', 'style', 'children', 'prefix', 'addonBefore', 'addonAfter', 'addonBeforeClassName', 'addonAfterClassName', 'rtl']);

        var cls = (0, _classnames2.default)((_classNames = {}, _classNames[prefix + 'input-group'] = true, _classNames[className] = !!className, _classNames));

        var addonCls = prefix + 'input-group-addon';
        var beforeCls = (0, _classnames2.default)(addonCls, (_classNames2 = {}, _classNames2[prefix + 'before'] = true, _classNames2[addonBeforeClassName] = addonBeforeClassName, _classNames2));
        var afterCls = (0, _classnames2.default)(addonCls, (_classNames3 = {}, _classNames3[prefix + 'after'] = true, _classNames3[addonAfterClassName] = addonAfterClassName, _classNames3));

        var before = addonBefore ? _react2.default.createElement(
            'span',
            { className: beforeCls },
            addonBefore
        ) : null;

        var after = addonAfter ? _react2.default.createElement(
            'span',
            { className: afterCls },
            addonAfter
        ) : null;

        return _react2.default.createElement(
            'span',
            _extends({}, others, { dir: rtl ? 'rtl' : undefined, className: cls, style: style }),
            before,
            children,
            after
        );
    };

    return Group;
}(_react2.default.Component), _class.propTypes = {
    /**
     * 样式前缀
     */
    prefix: _propTypes2.default.string,
    className: _propTypes2.default.string,
    style: _propTypes2.default.object,
    children: _propTypes2.default.node,
    /**
     * 输入框前附加内容
     */
    addonBefore: _propTypes2.default.node,
    /**
     * 输入框前附加内容css
     */
    addonBeforeClassName: _propTypes2.default.string,
    /**
     * 输入框后附加内容
     */
    addonAfter: _propTypes2.default.node,
    /**
     * 输入框后额外css
     */
    addonAfterClassName: _propTypes2.default.string,
    /**
     * rtl
     */
    rtl: _propTypes2.default.bool
}, _class.defaultProps = {
    prefix: 'next-'
}, _temp);
Group.displayName = 'Group';
exports.default = _configProvider2.default.config(Group);
module.exports = exports['default'];

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _util = __webpack_require__(2);

var _menu = __webpack_require__(76);

var _menu2 = _interopRequireDefault(_menu);

var _overlay = __webpack_require__(15);

var _overlay2 = _interopRequireDefault(_overlay);

var _zhCn = __webpack_require__(35);

var _zhCn2 = _interopRequireDefault(_zhCn);

var _dataStore = __webpack_require__(312);

var _dataStore2 = _interopRequireDefault(_dataStore);

var _virtualList = __webpack_require__(313);

var _virtualList2 = _interopRequireDefault(_virtualList);

var _util2 = __webpack_require__(180);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var Popup = _overlay2.default.Popup;
var MenuItem = _menu2.default.Item,
    MenuGroup = _menu2.default.Group;
var noop = _util.func.noop,
    bindCtx = _util.func.bindCtx,
    makeChain = _util.func.makeChain;


function preventDefault(e) {
    e.preventDefault();
}

var Base = (_temp = _class = function (_React$Component) {
    _inherits(Base, _React$Component);

    function Base(props) {
        _classCallCheck(this, Base);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

        _this.saveSelectRef = function (ref) {
            _this.selectDOM = (0, _reactDom.findDOMNode)(ref);
        };

        _this.saveInputRef = function (ref) {
            if (ref && ref.getInstance()) {
                _this.inputRef = ref.getInstance();
            }
        };

        _this.savePopupRef = function (ref) {
            _this.popupRef = ref;
            if (_this.props.popupProps && typeof _this.props.popupProps.ref === 'function') {
                _this.props.popupProps.ref(ref);
            }
        };

        _this.dataStore = new _dataStore2.default({
            filter: props.filter,
            filterLocal: props.filterLocal
        });

        _this.state = {
            value: 'value' in props ? props.value : props.defaultValue,
            visible: 'visible' in props ? props.visible : props.defaultVisible,
            dataSource: [],
            width: 100,
            // current highlight key
            highlightKey: null
        };

        bindCtx(_this, ['handleMenuBodyClick', 'handleVisibleChange', 'focusInput', 'beforeOpen', 'beforeClose', 'afterClose', 'handleResize']);
        return _this;
    }

    Base.prototype.componentWillMount = function componentWillMount() {
        this.setState({
            dataSource: this.setDataSource(this.props)
        });
    };

    Base.prototype.componentDidMount = function componentDidMount() {
        var _this2 = this;

        // overlay 还没有完成 mount，所以需要滞后同步宽度
        setTimeout(function () {
            return _this2.syncWidth();
        }, 0);

        _util.events.on(window, 'resize', this.handleResize);
    };

    Base.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if ('value' in nextProps) {
            this.setState({
                value: nextProps.value
            });
        }

        if ('visible' in nextProps) {
            // this.state.visible = nextProps.visible;
            this.setState({
                visible: nextProps.visible
            });
        }

        this.dataStore.setOptions({
            filter: nextProps.filter,
            filterLocal: nextProps.filterLocal
        });

        if (nextProps.children !== this.props.children || nextProps.dataSource !== this.props.dataSource) {
            var dataSource = this.setDataSource(nextProps);
            this.setState({
                dataSource: dataSource
            });
        }
    };

    Base.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
        if (prevProps.label !== this.props.label || prevState.value !== this.state.value) {
            this.syncWidth();
        }
    };

    Base.prototype.componentWillUnmount = function componentWillUnmount() {
        _util.events.off(window, 'resize', this.handleResize);
        clearTimeout(this.resizeTimeout);
    };

    /**
     * Calculate and set width of popup menu
     * @protected
     */


    Base.prototype.syncWidth = function syncWidth() {
        var _this3 = this;

        var width = _util.dom.getStyle(this.selectDOM, 'width');

        if (width && this.width !== width) {
            this.width = width;

            if (this.popupRef && this.props.autoWidth) {
                // overy 的 node 节点可能没有挂载完成，所以这里需要异步
                setTimeout(function () {
                    if (_this3.popupRef && _this3.popupRef.getInstance().overlay) {
                        _util.dom.setStyle(_this3.popupRef.getInstance().overlay.getInstance().getContentNode(), 'width', _this3.width);
                    }
                }, 0);
            }
        }
    };

    Base.prototype.handleResize = function handleResize() {
        var _this4 = this;

        clearTimeout(this.resizeTimeout);
        if (this.state.visible) {
            this.resizeTimeout = setTimeout(function () {
                _this4.syncWidth();
            }, 200);
        }
    };

    /**
     * Get structured dataSource, for cache
     * @protected
     * @param  {Object} [props=this.props]
     * @return {Array}
     */


    Base.prototype.setDataSource = function setDataSource(props) {
        var dataSource = props.dataSource,
            children = props.children;

        // children is higher priority then dataSource

        if (_react.Children.count(children)) {
            return this.dataStore.updateByDS(children, true);
        } else if (Array.isArray(dataSource)) {
            return this.dataStore.updateByDS(dataSource, false);
        }
        return [];
    };

    /**
     * Set popup visible
     * @protected
     * @param {boolean} visible
     * @param {string} type trigger type
     */


    Base.prototype.setVisible = function setVisible(visible, type) {
        if (this.props.disabled || this.state.visible === visible) {
            return;
        }

        if (!('visible' in this.props)) {
            this.setState({
                visible: visible
            });
        }

        this.props.onVisibleChange(visible, type);
    };

    Base.prototype.setFirstHightLightKeyForMenu = function setFirstHightLightKeyForMenu() {
        // 设置高亮 item key
        if (this.dataStore.getMenuDS().length && this.dataStore.getEnableDS().length) {
            this.setState({
                highlightKey: '' + this.dataStore.getEnableDS()[0].value
            });
        }
    };

    Base.prototype.handleChange = function handleChange(value) {
        var _props2;

        // 非受控模式清空内部数据
        if (!('value' in this.props)) {
            this.setState({
                value: value
            });
        }

        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
        }

        (_props2 = this.props).onChange.apply(_props2, [value].concat(args));
    };

    /**
     * Handle Menu body click
     * @param {Event} e click event
     */


    Base.prototype.handleMenuBodyClick = function handleMenuBodyClick(e) {
        this.focusInput(e);
    };

    /**
     * Toggle highlight MenuItem
     * @private
     * @param {number} dir -1: up, 1: down
     */


    Base.prototype.toggleHighlightItem = function toggleHighlightItem(dir) {
        if (!this.state.visible) {
            this.setVisible(true, 'enter');
            return;
        }

        var maxCount = this.dataStore.getEnableDS().length;
        // When there is no enabled item
        if (!maxCount) {
            return false;
        }

        var highlightKey = this.state.highlightKey;

        var highlightIndex = -1;

        // find previous highlight index
        highlightKey !== null && this.dataStore.getEnableDS().some(function (item, index) {
            if ('' + item.value === highlightKey) {
                highlightIndex = index;
            }
            return highlightIndex > -1;
        });

        // toggle highlight index
        highlightIndex += dir;
        if (highlightIndex < 0) {
            highlightIndex = maxCount - 1;
        }
        if (highlightIndex >= maxCount) {
            highlightIndex = 0;
        }

        // get highlight key
        var highlightItem = this.dataStore.getEnableDS()[highlightIndex];
        highlightKey = highlightItem ? '' + highlightItem.value : null;

        this.setState({ highlightKey: highlightKey });

        this.scrollMenuIntoView();

        return highlightItem;
    };

    // scroll into focus item


    Base.prototype.scrollMenuIntoView = function scrollMenuIntoView() {
        var _this5 = this;

        var prefix = this.props.prefix;


        clearTimeout(this.highlightTimer);
        this.highlightTimer = setTimeout(function () {
            try {
                var menuNode = (0, _reactDom.findDOMNode)(_this5.menuRef);
                var itemNode = menuNode.querySelector('.' + prefix + 'select-menu-item.' + prefix + 'focused');
                itemNode && itemNode.scrollIntoViewIfNeeded();
            } catch (ex) {
                // I don't care...
            }
        });
    };

    /**
     * render popup menu header
     * @abstract
     */


    Base.prototype.renderMenuHeader = function renderMenuHeader() {
        return null;
    };

    Base.prototype.handleSelect = function handleSelect() {};

    /**
     * render popup children
     * @protected
     * @param {object} props
     */


    Base.prototype.renderMenu = function renderMenu() {
        var _classNames,
            _this6 = this;

        var _props3 = this.props,
            prefix = _props3.prefix,
            mode = _props3.mode,
            autoWidth = _props3.autoWidth,
            locale = _props3.locale,
            notFoundContent = _props3.notFoundContent,
            useVirtual = _props3.useVirtual;
        var _state = this.state,
            dataSource = _state.dataSource,
            highlightKey = _state.highlightKey;

        var value = this.state.value;
        var selectedKeys = void 0;

        if ((0, _util2.isNull)(value) || value.length === 0) {
            selectedKeys = [];
        } else if ((0, _util2.isSingle)(mode)) {
            selectedKeys = [(0, _util2.valueToSelectKey)(value)];
        } else {
            selectedKeys = [].concat(value).map(function (n) {
                return (0, _util2.valueToSelectKey)(n);
            });
        }

        var children = this.renderMenuItem(dataSource);

        var menuClassName = (0, _classnames2.default)((_classNames = {}, _classNames[prefix + 'select-menu'] = true, _classNames[prefix + 'select-menu-empty'] = !children || !children.length, _classNames));

        if (!children || !children.length) {
            children = _react2.default.createElement(
                'span',
                { className: prefix + 'select-menu-empty-content' },
                notFoundContent || locale.notFoundContent
            );
        }

        var menuProps = {
            children: children,
            style: autoWidth ? { width: this.width } : { minWidth: this.width },
            selectedKeys: selectedKeys,
            focusedKey: highlightKey,
            focusable: false,
            selectMode: (0, _util2.isSingle)(mode) ? 'single' : 'multiple',
            onSelect: this.handleMenuSelect,
            onItemClick: this.handleItemClick,
            header: this.renderMenuHeader(),
            onClick: this.handleMenuBodyClick,
            onMouseDown: preventDefault,
            className: menuClassName
        };

        return useVirtual ? _react2.default.createElement(
            'div',
            { className: prefix + 'select-menu-wrapper', style: { position: 'relative' } },
            _react2.default.createElement(
                _virtualList2.default,
                {
                    itemsRenderer: function itemsRenderer(items, _ref) {
                        return _react2.default.createElement(
                            _menu2.default,
                            _extends({ ref: function ref(c) {
                                    _ref(c);
                                    _this6.menuRef = c;
                                } }, menuProps),
                            items
                        );
                    } },
                children
            )
        ) : _react2.default.createElement(_menu2.default, menuProps);
    };

    /**
     * render menu item
     * @protected
     * @param {Array} dataSource
     */


    Base.prototype.renderMenuItem = function renderMenuItem(dataSource) {
        var _this7 = this;

        var _props4 = this.props,
            prefix = _props4.prefix,
            itemRender = _props4.itemRender;
        // If it has.

        var searchKey = void 0;
        if (this.isAutoComplete) {
            // In AutoComplete, value is the searchKey
            searchKey = this.state.value;
        } else {
            searchKey = this.state.searchValue;
        }

        return dataSource.map(function (item, index) {
            if (!item) {
                return null;
            }
            if (Array.isArray(item.children)) {
                return _react2.default.createElement(
                    MenuGroup,
                    {
                        key: index,
                        label: item.label },
                    _this7.renderMenuItem(item.children)
                );
            } else {
                var itemProps = {
                    key: item.value,
                    className: prefix + 'select-menu-item',
                    disabled: item.disabled
                };
                if (item.title) {
                    itemProps.title = item.title;
                }

                return _react2.default.createElement(
                    MenuItem,
                    itemProps,
                    itemRender(item, searchKey)
                );
            }
        });
    };

    /**
     * 点击 arrow 或 label 的时候焦点切到 input 中
     * @override
     */
    Base.prototype.focusInput = function focusInput() {
        this.inputRef.focus();
    };

    Base.prototype.beforeOpen = function beforeOpen() {
        var _state2 = this.state,
            value = _state2.value,
            highlightKey = _state2.highlightKey;

        if (this.props.mode === 'single' && !value && !highlightKey) {
            this.setFirstHightLightKeyForMenu();
        }
        this.syncWidth();
    };

    Base.prototype.beforeClose = function beforeClose() {};

    Base.prototype.afterClose = function afterClose() {};

    Base.prototype.render = function render(props) {
        var _classNames2;

        var prefix = props.prefix,
            mode = props.mode,
            popupProps = props.popupProps,
            popupContainer = props.popupContainer,
            popupClassName = props.popupClassName,
            popupStyle = props.popupStyle,
            popupContent = props.popupContent,
            autoWidth = props.autoWidth,
            canCloseByTrigger = props.canCloseByTrigger,
            cache = props.cache;


        var cls = (0, _classnames2.default)((_classNames2 = {}, _classNames2[prefix + 'select-auto-complete-menu'] = !popupContent && this.isAutoComplete, _classNames2[prefix + 'select-' + mode + '-menu'] = !popupContent && !!mode, _classNames2), popupClassName || popupProps.className);

        var _props = _extends({
            triggerType: 'click',
            autoFocus: false,
            cache: cache
        }, popupProps, {
            //beforeOpen node not mount, afterOpen too slow.
            // from display:none to block, we may need to recompute width
            beforeOpen: makeChain(this.beforeOpen, popupProps.beforeOpen),
            beforeClose: makeChain(this.beforeClose, popupProps.beforeClose),
            afterClose: makeChain(this.afterClose, popupProps.afterClose),
            canCloseByTrigger: canCloseByTrigger,
            visible: this.state.visible,
            onVisibleChange: this.handleVisibleChange,
            shouldUpdatePosition: true,
            container: popupContainer || popupProps.container,
            className: cls,
            style: popupStyle || popupProps.style
        });

        return _react2.default.createElement(
            Popup,
            _extends({}, _props, { trigger: this.renderSelect(), ref: this.savePopupRef }),
            popupContent ? _react2.default.createElement(
                'div',
                { className: prefix + 'select-popup-wrap', style: autoWidth ? { width: this.width } : {} },
                popupContent
            ) : this.renderMenu()
        );
    };

    return Base;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    /**
     * 选择器尺寸
     */
    size: _propTypes2.default.oneOf(['small', 'medium', 'large']),
    // 当前值，用于受控模式
    value: _propTypes2.default.any, // to be override
    // 初始化的默认值
    defaultValue: _propTypes2.default.any, // to be override
    /**
     * 没有值的时候的占位符
     */
    placeholder: _propTypes2.default.string,
    /**
     * 下拉菜单是否与选择器对齐
     */
    autoWidth: _propTypes2.default.bool,
    /**
     * 自定义内联 label
     */
    label: _propTypes2.default.node,
    /**
     * 是否有清除按钮
     */
    hasClear: _propTypes2.default.bool,
    /**
     * 校验状态
     */
    state: _propTypes2.default.oneOf(['error', 'loading']),
    /**
     * 是否只读，只读模式下可以展开弹层但不能选
     */
    readOnly: _propTypes2.default.bool,
    /**
     * 是否禁用选择器
     */
    disabled: _propTypes2.default.bool,
    /**
     * 当前弹层是否显示
     */
    visible: _propTypes2.default.bool,
    /**
     * 弹层初始化是否显示
     */
    defaultVisible: _propTypes2.default.bool,
    /**
     * 弹层显示或隐藏时触发的回调
     * @param {Boolean} visible 弹层是否显示
     */
    onVisibleChange: _propTypes2.default.func,
    /**
     * 弹层挂载的容器节点
     */
    popupContainer: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    /**
     * 弹层的 className
     */
    popupClassName: _propTypes2.default.any,
    /**
     * 弹层的内联样式
     */
    popupStyle: _propTypes2.default.object,
    /**
     * 添加到弹层上的属性
     */
    popupProps: _propTypes2.default.object,
    /**
     * 自定义弹层的内容
     */
    popupContent: _propTypes2.default.node,
    /**
     * 是否使用本地过滤，在数据源为远程的时候需要关闭此项
     */
    filterLocal: _propTypes2.default.bool,
    /**
     * 本地过滤方法，返回一个 Boolean 值确定是否保留
     */
    filter: _propTypes2.default.func,
    /**
     * 键盘上下键切换菜单高亮选项的回调
     */
    onToggleHighlightItem: _propTypes2.default.func,
    /**
     * 是否开启虚拟滚动模式
     */
    useVirtual: _propTypes2.default.bool,
    // 自定义类名
    className: _propTypes2.default.any,
    children: _propTypes2.default.any,
    dataSource: _propTypes2.default.array,
    itemRender: _propTypes2.default.func,
    mode: _propTypes2.default.string,
    notFoundContent: _propTypes2.default.node,
    locale: _propTypes2.default.object,
    rtl: _propTypes2.default.bool
}, _class.defaultProps = {
    prefix: 'next-',
    size: 'medium',
    autoWidth: true,
    onChange: noop,
    onVisibleChange: noop,
    onToggleHighlightItem: noop,
    popupProps: {},
    filterLocal: true,
    filter: _util2.filter,
    itemRender: function itemRender(item) {
        return item.label || item.value;
    },
    locale: _zhCn2.default.Select
}, _temp);
Base.displayName = 'Base';
exports.default = Base;
module.exports = exports['default'];

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(11);

__webpack_require__(319);

/***/ }),
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(155);
module.exports = __webpack_require__(301);


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _table = __webpack_require__(79);

var _table2 = _interopRequireDefault(_table);

__webpack_require__(141);

var _pagination = __webpack_require__(302);

var _pagination2 = _interopRequireDefault(_pagination);

__webpack_require__(318);

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);for (var i = 0; i < keys.length; i++) {
        var key = keys[i];var value = Object.getOwnPropertyDescriptor(defaults, key);if (value && value.configurable && obj[key] === undefined) {
            Object.defineProperty(obj, key, value);
        }
    }return obj;
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
}

__webpack_require__(325);

var dataSource = function dataSource(j) {
    var result = [];
    for (var i = 0; i < 5; i++) {
        result.push({
            title: { name: 'Quotation for 1PCS Nano ' + (3 + i) + '.0 controller compatible' },
            id: 100306660940 + i + j,
            time: 2000 + j
        });
    }
    return result;
},
    _render = function _render(value, index, record) {
    return React.createElement('a', { href: 'javascript:;' }, 'Remove(', record.id, ')');
};

var App = function (_React$Component) {
    _inherits(App, _React$Component);

    function App(props) {
        _classCallCheck(this, App);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

        _this.onChange = function (currentPage) {
            _this.setState({
                loading: true
            });
            setTimeout(function () {
                _this.setState({
                    dataSource: dataSource(currentPage * 5),
                    loading: false
                });
            }, 200);
        };

        _this.state = {
            dataSource: dataSource(5)
        };
        return _this;
    }

    App.prototype.render = function render() {
        return React.createElement('div', null, React.createElement(_table2.default, { dataSource: this.state.dataSource,
            loading: this.state.loading }, React.createElement(_table2.default.Column, { title: 'Id1', dataIndex: 'id', width: 140 }), React.createElement(_table2.default.Column, { title: 'Time', dataIndex: 'time', width: 500 }), React.createElement(_table2.default.Column, { cell: _render, width: 200 })), React.createElement(_pagination2.default, { onChange: this.onChange, className: 'page-demo' }));
    };

    return App;
}(React.Component);

App.displayName = 'App';

ReactDOM.render(React.createElement(App, null), mountNode);

// HOT RELOAD CODE
var componentDesc = document.querySelector('#component-desc');
componentDesc.innerHTML = '\u4E0E\u5206\u9875\u7ED3\u5408';
var componentBody = document.querySelector('#component-body');
componentBody.innerHTML = '<pre><code class="language-jsx"><div class="hljs"><span class="hljs-keyword">import</span> { Table, Pagination } <span class="hljs-keyword">from</span> <span class="hljs-string">\'@alifd/next\'</span>;\n\n<span class="hljs-keyword">const</span> dataSource = <span class="hljs-function">(<span class="hljs-params">j</span>) =&gt;</span> {\n        <span class="hljs-keyword">const</span> result = [];\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {\n            result.push({\n                <span class="hljs-attr">title</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">{backquote}Quotation for 1PCS Nano <span class="hljs-subst">{dollar}{<span class="hljs-number">3</span> + i}</span>.0 controller compatible{backquote}</span> },\n                <span class="hljs-attr">id</span>: <span class="hljs-number">100306660940</span> + i + j,\n                <span class="hljs-attr">time</span>: <span class="hljs-number">2000</span> + j\n            });\n        }\n        <span class="hljs-keyword">return</span> result;\n    },\n    render = <span class="hljs-function">(<span class="hljs-params">value, index, record</span>) =&gt;</span> {\n        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"javascript:;"</span>&gt;</span>Remove({record.id})<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>;\n    };\n\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n\n    <span class="hljs-keyword">constructor</span>(props) {\n        <span class="hljs-keyword">super</span>(props);\n        <span class="hljs-keyword">this</span>.state = {\n            <span class="hljs-attr">dataSource</span>: dataSource(<span class="hljs-number">5</span>)\n        };\n    }\n\n    onChange = <span class="hljs-function">(<span class="hljs-params">currentPage</span>) =&gt;</span> {\n        <span class="hljs-keyword">this</span>.setState({\n            <span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span>\n        });\n        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n            <span class="hljs-keyword">this</span>.setState({\n                <span class="hljs-attr">dataSource</span>: dataSource(currentPage * <span class="hljs-number">5</span>),\n                <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>\n            });\n        }, <span class="hljs-number">200</span>);\n    }\n    render() {\n        <span class="hljs-keyword">return</span> (\n            &lt;div&gt;\n                &lt;Table dataSource={this.state.dataSource}\n                    loading={this.state.loading}&gt;\n                    &lt;Table.Column title="Id1" dataIndex="id" width={140} /&gt;\n                    &lt;Table.Column title="Time" dataIndex="time" width={500} /&gt;\n                    &lt;Table.Column cell={render} width={200} /&gt;\n                &lt;/Table&gt;\n                &lt;Pagination onChange={this.onChange} className="page-demo" /&gt;\n            &lt;/div&gt;);\n    }\n}\nReactDOM.render(&lt;App /&gt;, mountNode);\n</div></code></pre>\n<pre><code class="language-css"><div class="hljs"><span class="hljs-selector-class">.page-demo</span> {\n    <span class="hljs-attribute">margin-top</span>:<span class="hljs-number">10px</span>;\n}\n</div></code></pre>\n'.replace(/{backquote}/g, '`').replace(/{dollar}/g, '$');

if (true) {
    module.hot.accept();

    var reloading = document.querySelector('#next-demo-reloading');

    if (!window.hasAddStatusHandler) {
        module.hot.addStatusHandler(function (status) {
            window.hasAddStatusHandler = true;
            if (status === 'check') {
                reloading.style.display = 'block';
            } else if (status === 'idle') {
                reloading.style.display = 'none';
            }
        });
    }
}

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _pagination = __webpack_require__(303);

var _pagination2 = _interopRequireDefault(_pagination);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _pagination2.default;
module.exports = exports['default'];

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _button = __webpack_require__(71);

var _button2 = _interopRequireDefault(_button);

var _input = __webpack_require__(178);

var _input2 = _interopRequireDefault(_input);

var _select = __webpack_require__(306);

var _select2 = _interopRequireDefault(_select);

var _util = __webpack_require__(2);

var _zhCn = __webpack_require__(35);

var _zhCn2 = _interopRequireDefault(_zhCn);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var Option = _select2.default.Option;

var noop = function noop() {};

/**
 * Pagination
 */
var Pagination = (_temp = _class = function (_Component) {
    _inherits(Pagination, _Component);

    function Pagination(props, context) {
        _classCallCheck(this, Pagination);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

        var current = props.current,
            defaultCurrent = props.defaultCurrent,
            total = props.total,
            pageSize = props.pageSize;

        _this.state = {
            current: _this.correctCurrent(current || defaultCurrent, total, pageSize),
            currentPageSize: pageSize
        };
        _this.onJump = _this.onJump.bind(_this);
        return _this;
    }

    Pagination.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var current = nextProps.current,
            total = nextProps.total,
            pageSize = nextProps.pageSize;


        var st = {};
        var newCurrent = this.correctCurrent(current || this.state.current, total, pageSize);
        if (this.state.current !== newCurrent) {
            st.current = newCurrent;
        }
        if (this.state.currentPageSize !== pageSize) {
            st.currentPageSize = pageSize;
        }

        if (Object.keys(st).length) {
            this.setState(st);
        }
    };

    Pagination.prototype.correctCurrent = function correctCurrent(currentPage, total, currentPageSize) {
        var totalPage = this.getTotalPage(total, currentPageSize);
        return currentPage > totalPage ? totalPage : currentPage;
    };

    Pagination.prototype.getTotalPage = function getTotalPage(total, currentPageSize) {
        var totalPage = Math.ceil(total / currentPageSize);
        return totalPage <= 0 ? 1 : totalPage;
    };

    Pagination.prototype.onJump = function onJump(e) {
        var total = this.props.total;
        var _state = this.state,
            current = _state.current,
            currentPageSize = _state.currentPageSize;

        var totalPage = this.getTotalPage(total, currentPageSize);
        var value = parseInt(this.inputValue, 10);
        if (typeof value === 'number' && value >= 1 && value <= totalPage && value !== current) {
            this.onPageItemClick(value, e);
        }
    };

    Pagination.prototype.onPageItemClick = function onPageItemClick(page, e) {
        var _this2 = this;

        if (!('current' in this.props)) {
            this.setState({
                current: page
            }, function () {
                _this2.props.onChange(page, e);
            });
        } else {
            this.props.onChange(page, e);
        }
    };

    Pagination.prototype.onInputChange = function onInputChange(value) {
        this.inputValue = value;
    };

    Pagination.prototype.onSelectSize = function onSelectSize(pageSize) {
        var newState = {
            currentPageSize: pageSize
        };

        var totalPage = this.getTotalPage(this.props.total, pageSize);
        if (this.state.current > totalPage) {
            newState.current = totalPage;
        }

        this.setState(newState);
        this.props.onPageSizeChange(pageSize);
    };

    Pagination.prototype.renderPageTotal = function renderPageTotal() {
        var _props = this.props,
            prefix = _props.prefix,
            total = _props.total,
            totalRender = _props.totalRender;
        var _state2 = this.state,
            currentPageSize = _state2.currentPageSize,
            current = _state2.current;

        var range = [(current - 1) * currentPageSize + 1, current * currentPageSize];

        return _react2.default.createElement(
            'div',
            { className: prefix + 'pagination-total' },
            totalRender(total, range)
        );
    };

    Pagination.prototype.renderPageItem = function renderPageItem(index) {
        var _cx;

        var _props2 = this.props,
            prefix = _props2.prefix,
            size = _props2.size,
            link = _props2.link,
            pageNumberRender = _props2.pageNumberRender;
        var current = this.state.current;


        var isCurrent = parseInt(index, 10) === current;
        var props = {
            size: size,
            className: (0, _classnames2.default)((_cx = {}, _cx[prefix + 'pagination-item'] = true, _cx[prefix + 'current'] = isCurrent, _cx)),
            onClick: isCurrent ? noop : this.onPageItemClick.bind(this, index)
        };
        if (link) {
            props.component = 'a';
            props.href = link.replace('{page}', index);
        }

        return _react2.default.createElement(
            _button2.default,
            _extends({}, props, { key: index }),
            pageNumberRender(index)
        );
    };

    Pagination.prototype.renderPageFirst = function renderPageFirst(current) {
        var _cx2;

        var _props3 = this.props,
            prefix = _props3.prefix,
            size = _props3.size,
            shape = _props3.shape,
            locale = _props3.locale;


        var isFirst = current <= 1;
        var props = {
            disabled: isFirst,
            size: size,
            className: (0, _classnames2.default)((_cx2 = {}, _cx2[prefix + 'pagination-item'] = true, _cx2[prefix + 'prev'] = true, _cx2)),
            onClick: this.onPageItemClick.bind(this, current - 1)
        };

        var icon = _react2.default.createElement(_icon2.default, { type: 'arrow-left' });

        return _react2.default.createElement(
            _button2.default,
            props,
            icon,
            shape === 'arrow-only' || shape === 'arrow-prev-only' || shape === 'no-border' ? '' : locale.prev
        );
    };

    Pagination.prototype.renderPageLast = function renderPageLast(current, totalPage) {
        var _cx3;

        var _props4 = this.props,
            prefix = _props4.prefix,
            size = _props4.size,
            shape = _props4.shape,
            locale = _props4.locale;


        var isLast = current >= totalPage;
        var props = {
            disabled: isLast,
            size: size,
            className: (0, _classnames2.default)((_cx3 = {}, _cx3[prefix + 'pagination-item'] = true, _cx3[prefix + 'next'] = true, _cx3)),
            onClick: this.onPageItemClick.bind(this, current + 1)
        };

        var icon = _react2.default.createElement(_icon2.default, { type: 'arrow-right' });

        return _react2.default.createElement(
            _button2.default,
            props,
            shape === 'arrow-only' || shape === 'no-border' ? '' : locale.next,
            icon
        );
    };

    Pagination.prototype.renderPageEllipsis = function renderPageEllipsis(idx) {
        var prefix = this.props.prefix;


        return _react2.default.createElement(_icon2.default, { className: prefix + 'pagination-ellipsis', type: 'ellipsis', key: 'ellipsis-' + idx });
    };

    Pagination.prototype.renderPageJump = function renderPageJump() {
        var _this3 = this;

        var _props5 = this.props,
            prefix = _props5.prefix,
            size = _props5.size,
            locale = _props5.locale;

        /* eslint-disable react/jsx-key */

        return [_react2.default.createElement(
            'span',
            { className: prefix + 'pagination-jump-text' },
            locale.goTo
        ), _react2.default.createElement(_input2.default, {
            className: prefix + 'pagination-jump-input',
            type: 'text',
            size: size,
            onChange: this.onInputChange.bind(this),
            onKeyDown: function onKeyDown(e) {
                if (e.keyCode === _util.KEYCODE.ENTER) {
                    _this3.onJump(e);
                }
            } }), _react2.default.createElement(
            'span',
            { className: prefix + 'pagination-jump-text' },
            locale.page
        ), _react2.default.createElement(
            _button2.default,
            { className: prefix + 'pagination-jump-go', size: size, onClick: this.onJump },
            locale.go
        )];
        /* eslint-enable react/jsx-key */
    };

    Pagination.prototype.renderPageDisplay = function renderPageDisplay(current, totalPage) {
        var _props6 = this.props,
            prefix = _props6.prefix,
            pageNumberRender = _props6.pageNumberRender;


        return _react2.default.createElement(
            'span',
            { className: prefix + 'pagination-display' },
            _react2.default.createElement(
                'em',
                null,
                pageNumberRender(current)
            ),
            '/',
            pageNumberRender(totalPage)
        );
    };

    Pagination.prototype.renderPageList = function renderPageList(current, totalPage) {
        var _props7 = this.props,
            prefix = _props7.prefix,
            pageShowCount = _props7.pageShowCount;

        var pages = [];

        if (totalPage <= pageShowCount) {
            for (var i = 1; i <= totalPage; i++) {
                pages.push(this.renderPageItem(i));
            }
        } else {
            // 除去第一页，最后一页以及当前页，剩下的页数
            var othersCount = pageShowCount - 3;
            var halfCount = parseInt(othersCount / 2, 10);
            var start = void 0,
                end = void 0;

            pages.push(this.renderPageItem(1));

            start = current - halfCount;
            end = current + halfCount;
            if (start <= 1) {
                start = 2;
                end = start + othersCount;
            }
            if (start > 2) {
                pages.push(this.renderPageEllipsis(1));
            }
            if (end >= totalPage - 1) {
                end = totalPage - 1;
                start = totalPage - 1 - othersCount;
            }
            for (var j = start; j <= end; j++) {
                pages.push(this.renderPageItem(j));
            }
            if (end < totalPage - 1) {
                pages.push(this.renderPageEllipsis(2));
            }

            pages.push(this.renderPageItem(totalPage));
        }

        return _react2.default.createElement(
            'div',
            { className: prefix + 'pagination-list' },
            pages
        );
    };

    Pagination.prototype.renderPageSizeSelector = function renderPageSizeSelector() {
        var _props8 = this.props,
            prefix = _props8.prefix,
            pageSizeSelector = _props8.pageSizeSelector,
            locale = _props8.locale;

        var pageSizeSpan = _react2.default.createElement(
            'span',
            { className: prefix + 'pagination-size-selector-title' },
            locale.pageSize
        );

        switch (pageSizeSelector) {
            case 'filter':
                return _react2.default.createElement(
                    'div',
                    { className: prefix + 'pagination-size-selector' },
                    pageSizeSpan,
                    this.renderPageSizeFilter()
                );
            case 'dropdown':
                return _react2.default.createElement(
                    'div',
                    { className: prefix + 'pagination-size-selector' },
                    pageSizeSpan,
                    this.renderPageSizeDropdown()
                );
            default:
                return null;
        }
    };

    Pagination.prototype.renderPageSizeFilter = function renderPageSizeFilter() {
        var _this4 = this;

        var _props9 = this.props,
            prefix = _props9.prefix,
            size = _props9.size,
            pageSizeList = _props9.pageSizeList;
        var currentPageSize = this.state.currentPageSize;


        return _react2.default.createElement(
            'div',
            { className: prefix + 'pagination-size-selector-filter' },
            pageSizeList.map(function (item, index) {
                var _cx4;

                var label = void 0;
                var pageSize = void 0;
                if (item.value) {
                    // {label: '', value: 5}
                    label = item.label;
                    pageSize = item.value;
                } else {
                    // number
                    label = pageSize = item;
                }
                var classes = (0, _classnames2.default)((_cx4 = {}, _cx4[prefix + 'pagination-size-selector-btn'] = true, _cx4[prefix + 'current'] = pageSize === currentPageSize, _cx4));

                return _react2.default.createElement(
                    _button2.default,
                    { key: index,
                        text: true,
                        size: size,
                        className: classes,
                        onClick: pageSize !== currentPageSize ? _this4.onSelectSize.bind(_this4, pageSize) : null },
                    label
                );
            })
        );
    };

    Pagination.prototype.renderPageSizeDropdown = function renderPageSizeDropdown() {
        var _props10 = this.props,
            prefix = _props10.prefix,
            size = _props10.size,
            pageSizeList = _props10.pageSizeList;
        var currentPageSize = this.state.currentPageSize;


        return _react2.default.createElement(
            _select2.default,
            { className: prefix + 'pagination-size-selector-dropdown',
                popupClassName: prefix + 'pagination-size-selector-popup',
                popupContainer: function popupContainer(node) {
                    return node.parentNode;
                },
                autoWidth: true,
                size: size,
                value: currentPageSize,
                onChange: this.onSelectSize.bind(this) },
            pageSizeList.map(function (item, index) {
                var label = void 0;
                var pageSize = void 0;
                if (item.value) {
                    // {label: '', value: 5}
                    label = item.label;
                    pageSize = item.value;
                } else {
                    // number
                    label = pageSize = item;
                }
                return _react2.default.createElement(
                    Option,
                    { key: index, value: pageSize },
                    label
                );
            })
        );
    };

    Pagination.prototype.render = function render() {
        var _cx5,
            _this5 = this;

        /* eslint-disable no-unused-vars */
        var _props11 = this.props,
            prefix = _props11.prefix,
            pure = _props11.pure,
            rtl = _props11.rtl,
            type = _props11.type,
            size = _props11.size,
            shape = _props11.shape,
            className = _props11.className,
            total = _props11.total,
            totalRender = _props11.totalRender,
            pageSize = _props11.pageSize,
            pageSizeSelector = _props11.pageSizeSelector,
            pageSizeList = _props11.pageSizeList,
            pageSizePosition = _props11.pageSizePosition,
            useFloatLayout = _props11.useFloatLayout,
            onPageSizeChange = _props11.onPageSizeChange,
            hideOnlyOnePage = _props11.hideOnlyOnePage,
            showJump = _props11.showJump,
            locale = _props11.locale,
            current = _props11.current,
            defaultCurrent = _props11.defaultCurrent,
            pageShowCount = _props11.pageShowCount,
            pageNumberRender = _props11.pageNumberRender,
            link = _props11.link,
            onChange = _props11.onChange,
            others = _objectWithoutProperties(_props11, ['prefix', 'pure', 'rtl', 'type', 'size', 'shape', 'className', 'total', 'totalRender', 'pageSize', 'pageSizeSelector', 'pageSizeList', 'pageSizePosition', 'useFloatLayout', 'onPageSizeChange', 'hideOnlyOnePage', 'showJump', 'locale', 'current', 'defaultCurrent', 'pageShowCount', 'pageNumberRender', 'link', 'onChange']);
        /* eslint-enable */


        var _state3 = this.state,
            currentPage = _state3.current,
            currentPageSize = _state3.currentPageSize;

        var totalPage = this.getTotalPage(total, currentPageSize);
        var pageFirst = this.renderPageFirst(currentPage);
        var pageLast = this.renderPageLast(currentPage, totalPage);
        var sizeSelector = this.renderPageSizeSelector();
        var isStart = pageSizePosition === 'start';

        var classes = (0, _classnames2.default)((_cx5 = {}, _cx5[prefix + 'pagination'] = true, _cx5['' + prefix + size] = size, _cx5['' + prefix + type] = type, _cx5['' + prefix + shape] = shape, _cx5[prefix + 'start'] = !!pageSizeSelector && isStart && useFloatLayout, _cx5[prefix + 'end'] = !!pageSizeSelector && !isStart && useFloatLayout, _cx5[prefix + 'hide'] = totalPage <= 1 && hideOnlyOnePage, _cx5[className] = !!className, _cx5));

        if (rtl) {
            others.dir = 'rtl';
        }

        var buildComponent = function buildComponent() {
            for (var _len = arguments.length, coms = Array(_len), _key = 0; _key < _len; _key++) {
                coms[_key] = arguments[_key];
            }

            return _react2.default.createElement(
                'div',
                _extends({ className: classes }, others),
                isStart && sizeSelector,
                totalRender ? _this5.renderPageTotal() : null,
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'pagination-pages' },
                    coms.map(function (com, index) {
                        return com && _react2.default.cloneElement(com, { key: index });
                    })
                ),
                !isStart && sizeSelector
            );
        };

        switch (type) {
            case 'mini':
                return buildComponent(pageFirst, pageLast);
            case 'simple':
                {
                    var pageDisplay = this.renderPageDisplay(currentPage, totalPage);
                    return buildComponent(pageFirst, pageDisplay, pageLast);
                }
            case 'normal':
                {
                    var pageList = this.renderPageList(currentPage, totalPage);
                    var _pageDisplay = showJump && total > pageSize * pageShowCount ? this.renderPageDisplay(currentPage, totalPage) : null;
                    var pageJump = showJump && total > pageSize * pageShowCount ? this.renderPageJump(currentPage, totalPage) : null;
                    return buildComponent.apply(undefined, [pageFirst, pageList, pageLast, _pageDisplay].concat(pageJump));
                }
            default:
                return null;
        }
    };

    return Pagination;
}(_react.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    rtl: _propTypes2.default.bool,
    className: _propTypes2.default.string,
    /**
     * 自定义国际化文案对象
     */
    locale: _propTypes2.default.object,
    /**
     * 分页组件类型
     */
    type: _propTypes2.default.oneOf(['normal', 'simple', 'mini']),
    /**
     * 前进后退按钮样式
     */
    shape: _propTypes2.default.oneOf(['normal', 'arrow-only', 'arrow-prev-only', 'no-border']),
    /**
     * 分页组件大小
     */
    size: _propTypes2.default.oneOf(['small', 'medium', 'large']),
    /**
     * （受控）当前页码
     */
    current: _propTypes2.default.number,
    /**
     * （非受控）初始页码
     */
    defaultCurrent: _propTypes2.default.number,
    /**
     * 页码发生改变时的回调函数
     * @param {Number} current 改变后的页码数
     * @param {Object} e 点击事件对象
     */
    onChange: _propTypes2.default.func,
    /**
     * 总记录数
     */
    total: _propTypes2.default.number,
    /**
     * 总数的渲染函数
     * @param {Number} total 总数
     * @param {Array} range 当前数据在总数中的区间
     */
    totalRender: _propTypes2.default.func,
    /**
     * 页码显示的数量，更多的使用...代替
     */
    pageShowCount: _propTypes2.default.number,
    /**
     * 一页中的记录数
     */
    pageSize: _propTypes2.default.number,
    /**
     * 每页显示选择器类型
     */
    pageSizeSelector: _propTypes2.default.oneOf([false, 'filter', 'dropdown']),
    /**
     * 每页显示选择器可选值
     */
    pageSizeList: _propTypes2.default.oneOfType([_propTypes2.default.arrayOf(_propTypes2.default.number), _propTypes2.default.arrayOf(_propTypes2.default.shape({
        label: _propTypes2.default.string,
        value: _propTypes2.default.number
    }))]),
    /**
     * 自定义页码渲染函数，函数作用于页码button以及当前页/总页数的数字渲染
     * @param {Number} index 分页的页码，从1开始
     * @return {ReactNode} 返回渲染结果
    */
    pageNumberRender: _propTypes2.default.func,
    /**
     * 每页显示选择器在组件中的位置
     */
    pageSizePosition: _propTypes2.default.oneOf(['start', 'end']),
    /**
     * 存在每页显示选择器时是否使用浮动布局
     */
    useFloatLayout: _propTypes2.default.bool,
    /**
     * 每页显示记录数量改变时的回调函数
     * @param {Number} pageSize 改变后的每页显示记录数
     */
    onPageSizeChange: _propTypes2.default.func,
    /**
     * 当分页数为1时，是否隐藏分页器
     */
    hideOnlyOnePage: _propTypes2.default.bool,
    /**
     * type 设置为 normal 时，在页码数超过5页后，会显示跳转输入框与按钮，当设置 showJump 为 false 时，不再显示该跳转区域
     */
    showJump: _propTypes2.default.bool,
    /**
     * 设置页码按钮的跳转链接，它的值为一个包含 {page} 的模版字符串，如：http://xxx.com/{page}
     */
    link: _propTypes2.default.string
}, _class.defaultProps = {
    prefix: 'next-',
    pure: false,
    rtl: false,
    locale: _zhCn2.default.Pagination,
    type: 'normal',
    shape: 'normal',
    size: 'medium',
    defaultCurrent: 1,
    onChange: noop,
    pageSize: 10,
    pageSizeSelector: false,
    pageSizeList: [5, 10, 20],
    pageSizePosition: 'start',
    onPageSizeChange: noop,
    useFloatLayout: false,
    total: 100,
    pageShowCount: 5,
    hideOnlyOnePage: false,
    showJump: true,
    pageNumberRender: function pageNumberRender(index) {
        return index;
    }
}, _temp);
Pagination.displayName = 'Pagination';
exports.default = _configProvider2.default.config(Pagination);
module.exports = exports['default'];

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

var _base = __webpack_require__(207);

var _base2 = _interopRequireDefault(_base);

var _group = __webpack_require__(208);

var _group2 = _interopRequireDefault(_group);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

// preventDefault here can stop onBlur to keep focus state
function preventDefault(e) {
    e.preventDefault();
}

/** Input */
var Input = (_temp = _class = function (_Base) {
    _inherits(Input, _Base);

    function Input(props) {
        _classCallCheck(this, Input);

        var _this = _possibleConstructorReturn(this, _Base.call(this, props));

        _this.handleKeyDown = function (e) {
            if (e.keyCode === 13) {
                _this.props.onPressEnter(e);
            }

            _this.onKeyDown(e);
        };

        _this.handleKeyDownFromClear = function (e) {
            if (e.keyCode === 13) {
                _this.onClear(e);
            }
        };

        var value = void 0;
        if ('value' in props) {
            value = props.value;
        } else {
            value = props.defaultValue;
        }

        _this.state = {
            value: typeof value === 'undefined' ? '' : value
        };
        return _this;
    }

    // `Enter` was considered to be two chars in chrome , but one char in ie.
    // so we make all `Enter` to be two chars


    Input.prototype.getValueLength = function getValueLength(value) {
        var nv = '' + value;
        var strLen = this.props.getValueLength(nv);
        if (typeof strLen !== 'number') {
            strLen = nv.length;
        }

        return strLen;
    };

    Input.prototype.renderControl = function renderControl() {
        var _props = this.props,
            hasClear = _props.hasClear,
            readOnly = _props.readOnly,
            state = _props.state,
            prefix = _props.prefix,
            hint = _props.hint,
            extra = _props.extra,
            locale = _props.locale;


        var lenWrap = this.renderLength();

        var stateWrap = null;
        if (state === 'success') {
            stateWrap = _react2.default.createElement(_icon2.default, { type: 'success-filling' });
        } else if (state === 'loading') {
            stateWrap = _react2.default.createElement(_icon2.default, { type: 'loading' });
        }

        var clearWrap = null;
        var showClear = hasClear && !readOnly && !!('' + this.state.value);

        if (hint || showClear) {
            var hintIcon = null;
            if (hint) {
                hintIcon = _react2.default.createElement(_icon2.default, { type: hint, className: prefix + 'input-hint' });
            } else {
                hintIcon = _react2.default.createElement(_icon2.default, { type: 'delete-filling', role: 'button', tabIndex: '0', className: prefix + 'input-hint', 'aria-label': locale.clear,
                    onClick: this.onClear.bind(this),
                    onMouseDown: preventDefault,
                    onKeyDown: this.handleKeyDownFromClear });
            }

            clearWrap = _react2.default.createElement(
                'span',
                { className: prefix + 'input-hint-wrap' },
                hasClear && hint ? _react2.default.createElement(_icon2.default, { type: 'delete-filling', role: 'button', tabIndex: '0', className: prefix + 'input-clear', 'aria-label': locale.clear,
                    onClick: this.onClear.bind(this),
                    onMouseDown: preventDefault,
                    onKeyDown: this.handleKeyDownFromClear }) : null,
                hintIcon
            );
        }

        if (state === 'loading') {
            clearWrap = null;
        }

        return clearWrap || lenWrap || stateWrap || extra ? _react2.default.createElement(
            'span',
            { className: prefix + 'input-control' },
            clearWrap,
            lenWrap,
            stateWrap,
            extra
        ) : null;
    };

    Input.prototype.renderLabel = function renderLabel() {
        var _props2 = this.props,
            label = _props2.label,
            prefix = _props2.prefix,
            id = _props2.id;

        return label ? _react2.default.createElement(
            'label',
            { className: prefix + 'input-label', htmlFor: id },
            label
        ) : null;
    };

    Input.prototype.renderInner = function renderInner(inner, cls) {
        return inner ? _react2.default.createElement(
            'span',
            { className: cls },
            inner
        ) : null;
    };

    Input.prototype.onClear = function onClear(e) {
        if (this.props.disabled) {
            return;
        }

        // 非受控模式清空内部数据
        if (!('value' in this.props)) {
            this.setState({
                value: ''
            });
        }
        this.props.onChange('', e, 'clear');
        this.focus();
    };

    Input.prototype.render = function render() {
        var _classNames, _classNames2, _classNames3, _classNames4, _classNames5, _classNames6;

        var _props3 = this.props,
            size = _props3.size,
            htmlType = _props3.htmlType,
            htmlSize = _props3.htmlSize,
            autoComplete = _props3.autoComplete,
            autoFocus = _props3.autoFocus,
            disabled = _props3.disabled,
            style = _props3.style,
            innerBefore = _props3.innerBefore,
            innerAfter = _props3.innerAfter,
            innerBeforeClassName = _props3.innerBeforeClassName,
            innerAfterClassName = _props3.innerAfterClassName,
            className = _props3.className,
            hasBorder = _props3.hasBorder,
            prefix = _props3.prefix,
            addonBefore = _props3.addonBefore,
            addonAfter = _props3.addonAfter,
            addonTextBefore = _props3.addonTextBefore,
            addonTextAfter = _props3.addonTextAfter,
            inputRender = _props3.inputRender,
            rtl = _props3.rtl;


        var hasAddon = addonBefore || addonAfter || addonTextBefore || addonTextAfter;
        var cls = (0, _classnames2.default)(this.getClass(), (_classNames = {}, _classNames['' + prefix + size] = true, _classNames[prefix + 'hidden'] = this.props.htmlType === 'hidden', _classNames[prefix + 'noborder'] = !hasBorder || this.props.htmlType === 'file', _classNames[prefix + 'input-group-auto-width'] = hasAddon, _classNames[className] = !!className && !hasAddon, _classNames));

        var innerCls = prefix + 'input-inner';
        var innerBeforeCls = (0, _classnames2.default)((_classNames2 = {}, _classNames2[innerCls] = true, _classNames2[prefix + 'before'] = true, _classNames2[innerBeforeClassName] = innerBeforeClassName, _classNames2));
        var innerAfterCls = (0, _classnames2.default)((_classNames3 = {}, _classNames3[innerCls] = true, _classNames3[prefix + 'after'] = true, _classNames3[innerAfterClassName] = innerAfterClassName, _classNames3));

        var props = this.getProps();
        // custom data attributes are assigned to the top parent node
        // data-类自定义数据属性分配到顶层node节点
        var dataProps = _util.obj.pickAttrsWith(this.props, 'data-');
        // Custom props are transparently transmitted to the core input node by default
        // 自定义属性默认透传到核心node节点：input
        var others = _util.obj.pickOthers(_extends({}, dataProps, Input.propTypes), this.props);

        var inputEl = _react2.default.createElement('input', _extends({}, others, props, {
            height: '100%',
            type: htmlType,
            size: htmlSize,
            autoFocus: autoFocus,
            autoComplete: autoComplete,
            onKeyDown: this.handleKeyDown,
            ref: this.saveRef
        }));

        var inputWrap = _react2.default.createElement(
            'span',
            _extends({}, dataProps, { dir: rtl ? 'rtl' : undefined, className: cls, style: hasAddon ? undefined : style }),
            this.renderInner(innerBefore, innerBeforeCls),
            this.renderLabel(),
            inputRender(inputEl),
            this.renderControl(),
            this.renderInner(innerAfter, innerAfterCls)
        );

        var groupCls = (0, _classnames2.default)((_classNames4 = {}, _classNames4[prefix + 'input-group-text'] = true, _classNames4['' + prefix + size] = !!size, _classNames4[prefix + 'disabled'] = disabled, _classNames4));

        var addonBeforeCls = (0, _classnames2.default)((_classNames5 = {}, _classNames5[groupCls] = addonTextBefore, _classNames5));
        var addonAfterCls = (0, _classnames2.default)((_classNames6 = {}, _classNames6[groupCls] = addonTextAfter, _classNames6));

        if (hasAddon) {
            return _react2.default.createElement(
                _group2.default,
                _extends({}, dataProps, {
                    className: className,
                    style: style,
                    addonBefore: addonBefore || addonTextBefore,
                    addonBeforeClassName: addonBeforeCls,
                    addonAfter: addonAfter || addonTextAfter,
                    addonAfterClassName: addonAfterCls }),
                inputWrap
            );
        }

        return inputWrap;
    };

    return Input;
}(_base2.default), _class.propTypes = _extends({}, _base2.default.propTypes, {
    /**
     * label
     */
    label: _propTypes2.default.node,
    /**
     * 是否出现clear按钮
     */
    hasClear: _propTypes2.default.bool,
    /**
     * 是否有边框
     */
    hasBorder: _propTypes2.default.bool,
    /**
     * 状态
     * @enumdesc 错误, 校验中, 成功
     */
    state: _propTypes2.default.oneOf(['error', 'loading', 'success']),
    /**
     * 尺寸
     * @enumdesc 小, 中, 大
     */
    size: _propTypes2.default.oneOf(['small', 'medium', 'large']),
    /**
     * 按下回车的回调
     */
    onPressEnter: _propTypes2.default.func,

    onClear: _propTypes2.default.func,
    /**
     * 原生type
     */
    htmlType: _propTypes2.default.string,
    htmlSize: _propTypes2.default.string,
    /**
     * 水印 (Icon的type类型，和hasClear占用一个地方)
     */
    hint: _propTypes2.default.string,
    /**
     * 文字前附加内容
     */
    innerBefore: _propTypes2.default.node,
    /**
     * 文字后附加内容
     */
    innerAfter: _propTypes2.default.node,
    /**
     * 输入框前附加内容
     */
    addonBefore: _propTypes2.default.node,
    /**
     * 输入框后附加内容
     */
    addonAfter: _propTypes2.default.node,
    /**
     * 输入框前附加文字
     */
    addonTextBefore: _propTypes2.default.node,
    /**
     * 输入框后附加文字
     */
    addonTextAfter: _propTypes2.default.node,
    /**
     * (原生input支持)
     */
    autoComplete: _propTypes2.default.string,
    /**
     * 自动聚焦(原生input支持)
     */
    autoFocus: _propTypes2.default.bool,
    inputRender: _propTypes2.default.func,
    extra: _propTypes2.default.node,
    innerBeforeClassName: _propTypes2.default.string,
    innerAfterClassName: _propTypes2.default.string
}), _class.defaultProps = _extends({}, _base2.default.defaultProps, {
    size: 'medium',
    autoComplete: 'off',
    hasBorder: true,
    onPressEnter: _util.func.noop,
    inputRender: function inputRender(el) {
        return el;
    }
}), _temp);
exports.default = Input;
module.exports = exports['default'];

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _class, _temp, _initialiseProps;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _util = __webpack_require__(2);

var _base = __webpack_require__(207);

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function onNextFrame(cb) {
    if (window.requestAnimationFrame) {
        return window.requestAnimationFrame(cb);
    }
    return window.setTimeout(cb, 1);
}

function clearNextFrameAction(nextFrameId) {
    if (window.cancelAnimationFrame) {
        window.cancelAnimationFrame(nextFrameId);
    } else {
        window.clearTimeout(nextFrameId);
    }
}

var hiddenStyle = {
    visibility: 'hidden',
    position: 'absolute',
    zIndex: '-1000',
    top: '-1000px',
    overflowY: 'hidden',
    left: 0,
    right: 0
};

/**
 * Input.TextArea
 * @order 2
 */
var TextArea = (_temp = _class = function (_Base) {
    _inherits(TextArea, _Base);

    function TextArea(props) {
        _classCallCheck(this, TextArea);

        var _this = _possibleConstructorReturn(this, _Base.call(this, props));

        _initialiseProps.call(_this);

        var value = void 0;
        if ('value' in props) {
            value = props.value;
        } else {
            value = props.defaultValue;
        }

        _this.state = {
            value: typeof value === 'undefined' ? '' : value
        };
        return _this;
    }

    TextArea.prototype.componentDidMount = function componentDidMount() {
        var autoHeight = this.props.autoHeight;
        if (autoHeight) {
            if ((typeof autoHeight === 'undefined' ? 'undefined' : _typeof(autoHeight)) === 'object') {
                /* eslint-disable react/no-did-mount-set-state */
                this.setState(this._getMinMaxHeight(autoHeight, this.state.value));
            } else {
                this.setState({
                    height: this._getHeight(this.state.value),
                    overflowY: 'hidden'
                });
            }
        }
    };

    TextArea.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        _Base.prototype.componentWillReceiveProps.call(this, nextProps);

        if (this.props.autoHeight && this.props.value !== nextProps.value) {
            this._resizeTextArea(nextProps.value);
        }
    };

    TextArea.prototype._getMinMaxHeight = function _getMinMaxHeight(_ref, value) {
        var minRows = _ref.minRows,
            maxRows = _ref.maxRows;

        var node = _reactDom2.default.findDOMNode(this.helpRef);
        node.setAttribute('rows', minRows);
        var minHeight = node.clientHeight;

        node.setAttribute('rows', maxRows);
        var maxHeight = node.clientHeight;

        node.setAttribute('rows', '1');
        var height = this._getHeight(value);

        return {
            minHeight: minHeight,
            maxHeight: maxHeight,
            height: height,
            overflowY: height <= maxHeight ? 'hidden' : undefined
        };
    };

    TextArea.prototype._getHeight = function _getHeight(value) {
        var node = _reactDom2.default.findDOMNode(this.helpRef);
        node.value = value;

        return node.scrollHeight;
    };

    TextArea.prototype.ieHack = function ieHack(value) {
        // Fix: textarea dit not support maxLength in ie9
        /* istanbul ignore if */
        if (_util.env.ieVersion && this.props.maxLength && this.props.multiple) {
            var maxLength = parseInt(this.props.maxLength);
            var len = this.getValueLength(value, true);
            if (len > maxLength && this.props.cutString) {
                value = value.replace(/\n/g, '\n\n');
                value = value.substr(0, maxLength);
                value = value.replace(/\n\n/g, '\n');
            }
        }

        this.props.autoHeight && this._resizeTextArea(value);

        return value;
    };

    // `Enter` was considered to be two chars in chrome , but one char in ie.
    // so we make all `Enter` to be two chars


    TextArea.prototype.getValueLength = function getValueLength(value) {
        var nv = '' + value;
        var strLen = this.props.getValueLength(nv);
        if (typeof strLen !== 'number') {
            strLen = nv.length;
        }
        /* istanbul ignore if */
        if (_util.env.ieVersion) {
            return strLen + nv.split('\n').length - 1;
        }
        return strLen;
    };

    TextArea.prototype.saveTextAreaRef = function saveTextAreaRef(textArea) {
        this.inputRef = textArea;
    };

    TextArea.prototype.saveHelpRef = function saveHelpRef(ref) {
        this.helpRef = ref;
    };

    TextArea.prototype.render = function render() {
        var _classNames;

        var _props = this.props,
            rows = _props.rows,
            style = _props.style,
            className = _props.className,
            autoHeight = _props.autoHeight,
            prefix = _props.prefix,
            rtl = _props.rtl;


        var cls = (0, _classnames2.default)(this.getClass(), (_classNames = {}, _classNames[prefix + 'input-textarea'] = true, _classNames[className] = !!className, _classNames));

        var props = this.getProps();
        // custom data attributes are assigned to the top parent node
        // data-类自定义数据属性分配到顶层node节点
        var dataProps = _util.obj.pickAttrsWith(this.props, 'data-');
        // Custom props are transparently transmitted to the core input node by default
        // 自定义属性默认透传到核心node节点：input
        var others = _util.obj.pickOthers(_extends({}, dataProps, TextArea.propTypes), this.props);

        var textareStyle = _extends({}, props.style, {
            height: this.state.height,
            minHeight: this.state.minHeight,
            maxHeight: this.state.maxHeight,
            overflowY: this.state.overflowY
        });

        var wrapStyle = autoHeight ? _extends({}, style, {
            position: 'relative'
        }) : style;

        return _react2.default.createElement(
            'span',
            _extends({ className: cls, style: wrapStyle, dir: rtl ? 'rtl' : undefined }, dataProps),
            _react2.default.createElement('textarea', _extends({}, others, props, {
                'data-real': true,
                rows: rows,
                style: textareStyle,
                ref: this.saveRef.bind(this),
                onKeyDown: this.onKeyDown.bind(this) })),
            autoHeight ? _react2.default.createElement('textarea', { 'data-fake': true, ref: this.saveHelpRef.bind(this), style: _extends({}, props.style, hiddenStyle),
                rows: '1' }) : null,
            this.renderControl()
        );
    };

    return TextArea;
}(_base2.default), _class.propTypes = _extends({}, _base2.default.propTypes, {
    /**
     * 状态
     * @enumdesc 错误
     */
    state: _propTypes2.default.oneOf(['error']),
    /**
     * 自动高度 true / {minRows: 2, maxRows: 4}
     */
    autoHeight: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.object]),
    /**
     * 多行文本框高度 <br />(不要直接用height设置多行文本框的高度, ie9 10会有兼容性问题)
     */
    rows: _propTypes2.default.number
}), _class.defaultProps = _extends({}, _base2.default.defaultProps, {
    rows: 4,
    autoHeight: false
}), _initialiseProps = function _initialiseProps() {
    var _this2 = this;

    this._resizeTextArea = function (value) {
        if (_this2.nextFrameActionId) {
            clearNextFrameAction(_this2.nextFrameActionId);
        }
        _this2.nextFrameActionId = onNextFrame(function () {
            var height = _this2._getHeight(value);
            var maxHeight = _this2.state.maxHeight ? _this2.state.maxHeight : Infinity;

            _this2.setState({
                height: _this2._getHeight(value),
                overflowY: height <= maxHeight ? 'hidden' : undefined
            });
        });
    };
}, _temp);
exports.default = TextArea;
module.exports = exports['default'];

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _select = __webpack_require__(307);

var _select2 = _interopRequireDefault(_select);

var _autoComplete = __webpack_require__(315);

var _autoComplete2 = _interopRequireDefault(_autoComplete);

var _option = __webpack_require__(316);

var _option2 = _interopRequireDefault(_option);

var _optionGroup = __webpack_require__(317);

var _optionGroup2 = _interopRequireDefault(_optionGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

_select2.default.AutoComplete = _configProvider2.default.config(_autoComplete2.default, {
    componentName: 'Select'
});

_select2.default.Option = _option2.default;
_select2.default.OptionGroup = _optionGroup2.default;

// compatible with 0.x version
function _transform(props, deprecated) {
    var shape = props.shape,
        container = props.container,
        multiple = props.multiple,
        filterBy = props.filterBy,
        overlay = props.overlay,
        safeNode = props.safeNode,
        noFoundContent = props.noFoundContent,
        others = _objectWithoutProperties(props, ['shape', 'container', 'multiple', 'filterBy', 'overlay', 'safeNode', 'noFoundContent']);

    var newprops = others;
    if (shape === 'arrow-only') {
        deprecated('shape=arrow-only', 'hasBorder=false', 'Select');
        newprops.hasBorder = false;
    }
    if (container) {
        deprecated('container', 'popupContainer', 'Select');
        newprops.popupContainer = container;
    }
    if (multiple) {
        deprecated('multiple', 'mode=multiple', 'Select');
        newprops.mode = 'multiple';
    }
    if (filterBy) {
        deprecated('filterBy', 'filter', 'Select');
        newprops.filter = filterBy;
    }
    if (overlay) {
        deprecated('overlay', 'popupContent', 'Select');
        newprops.popupContent = overlay;
        newprops.autoWidth = false;
    }

    if (noFoundContent) {
        deprecated('noFoundContent', 'notFoundContent', 'Select');
        newprops.notFoundContent = noFoundContent;
    }

    if (safeNode) {
        deprecated('safeNode', 'popupProps={safeNode}', 'Select');
        newprops.popupProps = {
            safeNode: safeNode
        };
    }

    return newprops;
}

// compatible with 0.x version: Select.Combobox
_select2.default.Combobox = _configProvider2.default.config(_select2.default, {
    transform: function transform(props, deprecated) {
        deprecated('Select.Combobox', '<Select showSearch={true}/>', 'Select');

        var newprops = _transform(props, deprecated);
        if (props.onInputUpdate) {
            newprops.onSearch = props.onInputUpdate;
            newprops.showSearch = true;
        }
        return newprops;
    }
});

exports.default = _configProvider2.default.config(_select2.default, {
    transform: _transform
});
module.exports = exports['default'];

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _util = __webpack_require__(2);

var _tag = __webpack_require__(308);

var _tag2 = _interopRequireDefault(_tag);

var _input = __webpack_require__(178);

var _input2 = _interopRequireDefault(_input);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _base = __webpack_require__(209);

var _base2 = _interopRequireDefault(_base);

var _util2 = __webpack_require__(180);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var bindCtx = _util.func.bindCtx,
    noop = _util.func.noop;

var isIE9 = _util.env.ieVersion === 9;

/**
 * 无障碍化注意事项:
 * 1. Select 无搜索情况下，不应该让 Input 可focus，此时外层wrap必须可focus，并且需要相应focus事件让外边框发生变化
 */

// 自定义弹层：1. 不需要关心Menu的点击事件 2. 不需要关心dataSource变化

/**
 * Select
 */
var Select = (_temp = _class = function (_Base) {
    _inherits(Select, _Base);

    function Select(props) {
        _classCallCheck(this, Select);

        // @extend Base state
        var _this = _possibleConstructorReturn(this, _Base.call(this, props));

        _this.handleWrapClick = function (e) {
            e.preventDefault();
            _this.focusInput();
        };

        _this.handleArrowClick = function (e) {
            e.preventDefault();
            _this.focusInput();
            _this.setVisible(!_this.state.visible);
        };

        _this.handleClear = function (e) {
            e.stopPropagation();

            _this.handleChange(undefined, 'clear');
        };

        _extends(_this.state, {
            // search keyword
            searchValue: 'searchValue' in props ? props.searchValue : ''
        });

        // For cache choosen value
        _this.valueDataSource = {
            valueDS: [], // [{value,label}]
            mapValueDS: {} // {value: {value,label}}
        };

        bindCtx(_this, ['handleMenuSelect', 'handleItemClick', 'handleSearch', 'handleSearchKeyDown', 'handleSelectAll']);
        return _this;
    }

    Select.prototype.componentWillMount = function componentWillMount() {
        this.dataStore.setOptions({
            key: this.state.searchValue,
            addonKey: this.props.mode === 'tag' // tag 模式手动输入的数据
        });

        _Base.prototype.componentWillMount.call(this);

        // 根据value和计算后的dataSource，更新value对应的详细数据valueDataSource
        if (typeof this.state.value !== 'undefined') {
            this.valueDataSource = (0, _util2.getValueDataSource)(this.state.value, this.valueDataSource.mapValueDS, this.dataStore.getMapDS());
        }

        if (isIE9) {
            this.ie9Hack();
        }
    };

    Select.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if ('searchValue' in nextProps) {
            this.dataStore.setOptions({ key: nextProps.searchValue });
            this.setState({
                searchValue: typeof nextProps.searchValue === 'undefined' ? '' : nextProps.searchValue
            });
        }
        if (this.props.mode !== nextProps.mode) {
            this.dataStore.setOptions({
                addonKey: nextProps.mode === 'tag'
            });
        }

        _Base.prototype.componentWillReceiveProps.call(this, nextProps);

        if ('value' in nextProps) {
            // under controll
            this.valueDataSource = (0, _util2.getValueDataSource)(nextProps.value, this.valueDataSource.mapValueDS, this.dataStore.getMapDS());
        } else if ('defaultValue' in nextProps && (nextProps.children !== this.props.children || nextProps.dataSource !== this.props.dataSource)) {
            //has defaultValue and dataSource changed
            this.valueDataSource = (0, _util2.getValueDataSource)(nextProps.defaultValue, this.valueDataSource.mapValueDS, this.dataStore.getMapDS());
        }
    };

    Select.prototype.componentDidMount = function componentDidMount() {
        if (isIE9) {
            this.ie9Hack();
        }
        _Base.prototype.componentDidMount.call(this);
    };

    // ie9 下 table-cell 布局不支持宽度超出隐藏


    Select.prototype.ie9Hack = function ie9Hack() {
        try {
            var width = this.selectDOM.currentStyle.width;
            this.setState({
                fixWidth: width !== 'auto'
            });
        } catch (e) {
            //
        }
    };

    Select.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
        var props = this.props;
        // 随着输入自动伸展
        if (/tag|multiple/.test(props.mode) && prevState.searchValue !== this.state.searchValue) {
            this.syncWidth();
        } else {
            return _Base.prototype.componentDidUpdate.call(this, prevProps, prevState);
        }
    };

    Select.prototype.useDetailValue = function useDetailValue() {
        var _props = this.props,
            popupContent = _props.popupContent,
            useDetailValue = _props.useDetailValue,
            dataSource = _props.dataSource;

        return useDetailValue || popupContent && !dataSource;
    };

    Select.prototype.hasSearch = function hasSearch() {
        var _props2 = this.props,
            showSearch = _props2.showSearch,
            mode = _props2.mode;

        return showSearch || mode === 'tag';
    };

    /**
     * Menu.Item onSelect
     * @private
     * @param  {Array<string>} keys
     */


    Select.prototype.handleMenuSelect = function handleMenuSelect(keys) {
        var _props3 = this.props,
            mode = _props3.mode,
            readOnly = _props3.readOnly,
            disabled = _props3.disabled;


        if (readOnly || disabled) {
            return false;
        }

        var isSingle = mode === 'single';

        if (isSingle) {
            // 单选
            return this.handleSingleSelect(keys[0], 'itemClick');
        } else {
            // 正常多选
            return this.handleMultipleSelect(keys, 'itemClick');
        }
    };

    Select.prototype.handleItemClick = function handleItemClick() {
        this.focusInput();
    };

    /**
     * 单选模式
     */


    Select.prototype.handleSingleSelect = function handleSingleSelect(key, triggerType) {
        var cacheValue = this.props.cacheValue;
        // get data only from dataStore while cacheValue=false

        var itemObj = (0, _util2.getValueDataSource)(key, cacheValue ? this.valueDataSource.mapValueDS : {}, this.dataStore.getMapDS());
        this.valueDataSource = itemObj;

        this.setVisible(false, triggerType);

        if (this.useDetailValue()) {
            return this.handleChange(itemObj.valueDS, triggerType);
        } else {
            this.handleChange(itemObj.value, triggerType, itemObj.valueDS);
        }

        this.setState({
            highlightKey: key
        });

        // 清空搜索
        if (!('searchValue' in this.props) && this.state.searchValue) {
            this.handleSearchClear(triggerType);
        }
    };

    /**
     * 多选模式 multiple/tag
     */


    Select.prototype.handleMultipleSelect = function handleMultipleSelect(keys, triggerType) {
        var _this2 = this;

        var itemObj = (0, _util2.getValueDataSource)(keys, this.valueDataSource.mapValueDS, this.dataStore.getMapDS());

        var _props4 = this.props,
            cacheValue = _props4.cacheValue,
            mode = _props4.mode,
            hiddenSelected = _props4.hiddenSelected;

        // 非受控更新缓存map

        if (cacheValue || mode === 'tag') {
            this.valueDataSource = itemObj;
        }

        if (hiddenSelected) {
            this.setVisible(false, triggerType);
        }

        if (this.useDetailValue()) {
            this.handleChange(itemObj.valueDS, triggerType);
        } else {
            this.handleChange(itemObj.value, triggerType, itemObj.valueDS);
        }

        // 清空搜索
        if (!('searchValue' in this.props) && this.state.searchValue) {
            // 因为 SearchValue 被 clear 后会重新渲染 Menu，所以在 Overlay 检测 safeNode 的时候 e.target 可能会找不到导致弹窗关闭
            setTimeout(function () {
                _this2.handleSearchClear(triggerType);
            });
        }
    };

    Select.prototype.handleSearchValue = function handleSearchValue(value) {
        if (this.state.searchValue === value) {
            return;
        }

        var filterLocal = this.props.filterLocal;


        if (filterLocal) {
            if (!('searchValue' in this.props)) {
                this.setState({
                    searchValue: value,
                    dataSource: this.dataStore.updateByKey(value)
                });
                this.setFirstHightLightKeyForMenu();
            }
        } else if (!('searchValue' in this.props)) {
            this.setState({
                searchValue: value
            });
        }
    };

    /**
     * Handle search input change event
     * @param {Event} e change Event
     */


    Select.prototype.handleSearch = function handleSearch(value) {
        this.handleSearchValue(value);

        // inputing should trigger popup open
        if (!this.state.visible && value) {
            this.setVisible(true);
        }

        this.props.onSearch(value);
    };

    Select.prototype.handleSearchClear = function handleSearchClear(triggerType) {
        this.handleSearchValue('');
        this.props.onSearchClear(triggerType);
    };

    // 搜索框 keyDown 事件


    Select.prototype.handleSearchKeyDown = function handleSearchKeyDown(e) {
        var _props5 = this.props,
            popupContent = _props5.popupContent,
            onKeyDown = _props5.onKeyDown,
            showSearch = _props5.showSearch,
            mode = _props5.mode,
            hasClear = _props5.hasClear,
            onToggleHighlightItem = _props5.onToggleHighlightItem;


        if (popupContent) {
            return onKeyDown(e);
        }

        var proxy = 'search';
        var hasSearch = this.hasSearch();

        switch (e.keyCode) {
            case _util.KEYCODE.UP:
                e.preventDefault();
                onToggleHighlightItem(this.toggleHighlightItem(-1, e), 'up');
                break;
            case _util.KEYCODE.DOWN:
                e.preventDefault();
                onToggleHighlightItem(this.toggleHighlightItem(1, e), 'down');
                break;
            case _util.KEYCODE.ENTER:
                e.preventDefault();
                this.chooseHighlightItem(proxy, e);
                break;
            case _util.KEYCODE.ESC:
                e.preventDefault();
                this.state.visible && this.setVisible(false, 'keyDown');
                break;
            case _util.KEYCODE.SPACE:
                e.stopPropagation();
                !hasSearch && e.preventDefault();
                break;
            case _util.KEYCODE.BACKSPACE:
                if (mode === 'multiple' && showSearch || mode === 'tag') {
                    // 在多选并且有搜索的情况下，删除最后一个 tag
                    this.handleDeleteTag(e);
                } else if (mode === 'single' && hasClear && !this.state.visible) {
                    // 单选、非展开、并且可清除的情况，允许按删除键清除
                    this.handleClear(e);
                }
                break;
            default:
                break;
        }

        onKeyDown(e);
    };

    // 回车 选择高亮的 item


    Select.prototype.chooseHighlightItem = function chooseHighlightItem(proxy, e) {
        var prevVisible = this.state.visible;
        if (!prevVisible) {
            return false;
        }

        var highlightKey = this.state.highlightKey;

        // 没有高亮选项 或者 没有可选菜单

        if (highlightKey === null || !this.dataStore.getMenuDS().length) {
            return;
        }

        var mode = this.props.mode;


        if (mode === 'single') {
            this.handleSingleSelect(highlightKey, 'enter');
        } else {
            var value = this.state.value || [];
            var keys = value.map(function (v) {
                return (0, _util2.valueToSelectKey)(v);
            });
            var index = keys.map(function (v) {
                return '' + v;
            }).indexOf(highlightKey);
            if (index > -1) {
                // 反选
                keys.splice(index, 1);
            } else {
                // 勾选
                keys.push(highlightKey);
            }
            this.handleMultipleSelect(keys, 'enter');
            // 阻止事件冒泡到最外层，让Popup 监听到触发弹层关闭
            e && e.stopPropagation();
        }
    };

    /**
     * Handle Tag close event
     * @param  {Object} item
     * @return {Boolean} false  return false to prevent auto close
     * ----
     * It MUST be multiple mode, needn't additional judgement
     */


    Select.prototype.handleTagClose = function handleTagClose(item) {

        if (this.useDetailValue()) {
            var value = this.state.value.filter(function (v) {
                return item.value !== v.value;
            });

            this.handleChange(value, 'tag');
        } else {
            // filter out current item, and then call handleMenuSelect
            var _value = this.state.value.filter(function (v) {
                return item.value !== v;
            });

            this.handleMultipleSelect(_value, 'tag');
        }

        this.props.onRemove(item);

        // prevent tag close
        return false;
    };

    /**
     * Handle BACKSPACE key event
     * @param {Event} e keyDown event
     * ---
     * It MUST be multiple mode
     */


    Select.prototype.handleDeleteTag = function handleDeleteTag(e) {
        var value = this.state.value;
        var searchValue = this.state.searchValue;

        if (searchValue || !value || !value.length) {
            return false;
        }

        e.preventDefault();

        var nextValues = value.slice(0, value.length - 1);
        // 手动调用 handleMenuSelect 时直接传入原生的 value，可以减少 toString 的操作

        if (this.useDetailValue()) {
            this.handleChange(nextValues, 'tag');
        } else {
            this.handleMultipleSelect(nextValues, 'tag');
        }
    };

    /**
     * Handle SelectAll span click event
     * @param {Event} e click event
     */


    Select.prototype.handleSelectAll = function handleSelectAll(e) {
        e && e.preventDefault();
        var nextValues = this.dataStore.getEnableDS().map(function (item) {
            return item.value;
        });
        // 直接传 values，减少 toString 操作
        this.handleMultipleSelect(nextValues, 'selectAll');
    };

    Select.prototype.handleVisibleChange = function handleVisibleChange(visible, type) {
        this.setVisible(visible, type);
    };

    Select.prototype.afterClose = function afterClose() {
        // 关闭的时候清空搜索值
        if (this.hasSearch()) {
            this.handleSearchClear('popupClose');
        }
    };

    /**
     * 如果用户是自定义的弹层，则直接以 value 为准，不再校验 dataSource
     * @param {object} props
     */


    Select.prototype.renderValues = function renderValues() {
        var _this3 = this;

        var _props6 = this.props,
            mode = _props6.mode,
            size = _props6.size,
            valueRender = _props6.valueRender,
            fillProps = _props6.fillProps,
            disabled = _props6.disabled;

        var value = this.state.value;

        if ((0, _util2.isNull)(value)) {
            return null;
        }

        // get detail value
        if (!this.useDetailValue()) {
            value = this.valueDataSource.valueDS;
        }

        if (mode === 'single') {
            if (!value) {
                return null;
            }

            var retvalue = fillProps ? value[fillProps] : valueRender(value);
            return typeof retvalue === 'number' ? retvalue.toString() : retvalue;
        } else if (value) {
            if (!Array.isArray(value)) {
                value = [value];
            }
            return value.map(function (v) {
                if (!v) {
                    return null;
                }

                var labelNode = fillProps ? v[fillProps] : valueRender(v);
                return _react2.default.createElement(
                    _tag2.default,
                    { key: v.value,
                        disabled: disabled || v.disabled,
                        type: 'primary',
                        size: size === 'large' ? 'medium' : 'small',
                        animation: false,
                        onClose: _this3.handleTagClose.bind(_this3, v),
                        closable: true },
                    labelNode
                );
            });
        }

        return null;
    };
    /**
     * 1. fix flash while click <label/>
     * 2. fix onBlur while has clear
     */


    Select.prototype.hasClear = function hasClear() {
        var _props7 = this.props,
            hasClear = _props7.hasClear,
            readOnly = _props7.readOnly,
            disabled = _props7.disabled,
            mode = _props7.mode,
            showSearch = _props7.showSearch;
        var _state = this.state,
            value = _state.value,
            visible = _state.visible;


        return typeof value !== 'undefined' && hasClear && !readOnly && !disabled && mode === 'single' && !(showSearch && visible);
    };

    /**
     * render arrow
     * @param {object} props
     * @param {function} [clickHandler]
     */


    Select.prototype.renderExtraNode = function renderExtraNode() {
        var _props8 = this.props,
            hasArrow = _props8.hasArrow,
            hasClear = _props8.hasClear,
            prefix = _props8.prefix;


        var ret = [];

        if (hasArrow) {
            ret.push(_react2.default.createElement(
                'span',
                { key: 'arrow', onClick: this.handleArrowClick, className: prefix + 'select-arrow' },
                _react2.default.createElement(_icon2.default, {
                    type: 'arrow-down' })
            ));
        }

        // 不能使用 this.hasClear() 方法判断，要保证 clear 按钮 dom 结构一直存在，防止其不能成为弹层的安全节点，导致弹层没有必要的显示或隐藏
        if (hasClear) {
            ret.push(_react2.default.createElement(
                'span',
                { key: 'clear', onClick: this.handleClear, className: prefix + 'select-clear' },
                _react2.default.createElement(_icon2.default, {
                    type: 'delete-filling' })
            ));
        }

        return ret;
    };

    /**
     * 选择器
     * @override
     * @param {object} props
     */


    Select.prototype.renderSelect = function renderSelect() {
        var _classNames,
            _this4 = this;

        var _props9 = this.props,
            prefix = _props9.prefix,
            showSearch = _props9.showSearch,
            placeholder = _props9.placeholder,
            mode = _props9.mode,
            size = _props9.size,
            className = _props9.className,
            style = _props9.style,
            readOnly = _props9.readOnly,
            disabled = _props9.disabled,
            hasBorder = _props9.hasBorder,
            label = _props9.label,
            locale = _props9.locale,
            state = _props9.state,
            onBlur = _props9.onBlur,
            onFocus = _props9.onFocus,
            rtl = _props9.rtl;

        var others = _util.obj.pickOthers(Select.propTypes, this.props);
        var othersData = _util.obj.pickAttrsWith(others, 'data-');

        var visible = this.state.visible;
        var isSingle = mode === 'single';
        var hasSearch = this.hasSearch();
        var valueNodes = this.renderValues();

        // compatible with selectPlaceHolder. TODO: removed in 2.0 version
        var _placeholder = placeholder || locale.selectPlaceholder || locale.selectPlaceHolder;
        if (valueNodes && valueNodes.length) {
            _placeholder = null;
        }

        // 弹窗展开时将当前的值作为 placeholder，这个功能的前提是 valueNode 必须是一个字符串
        if (showSearch && visible && isSingle && typeof valueNodes === 'string') {
            _placeholder = valueNodes;
        }

        // 下拉箭头
        var extra = this.renderExtraNode();

        var triggerClazz = (0, _classnames2.default)([prefix + 'select', prefix + 'select-trigger', prefix + 'select-' + mode, '' + prefix + size, className], (_classNames = {}, _classNames[prefix + 'active'] = visible, _classNames[prefix + 'inactive'] = !visible, _classNames[prefix + 'no-search'] = !hasSearch, _classNames[prefix + 'has-search'] = hasSearch, _classNames[prefix + 'select-in-ie'] = isIE9, _classNames[prefix + 'select-in-ie-fixwidth'] = this.state.fixWidth, _classNames[prefix + 'has-clear'] = this.hasClear(), _classNames));

        var valuetext = this.valueDataSource.valueDS ? this.valueDataSource.valueDS.label : '';

        return _react2.default.createElement(
            'span',
            _extends({}, othersData, {
                className: triggerClazz,
                style: style,
                dir: rtl ? 'rtl' : undefined,
                ref: this.saveSelectRef,
                onClick: this.handleWrapClick,
                onMouseDown: this.handleWrapClick
            }),
            _react2.default.createElement(_input2.default, _extends({
                'aria-valuetext': valuetext
            }, _util.obj.pickOthers(othersData, others), {
                role: 'combobox',
                tabIndex: 0,
                'aria-expanded': this.state.visible,
                'aria-disabled': disabled,
                state: state,
                label: label,
                extra: extra,
                value: this.state.searchValue,
                size: size,
                readOnly: !this.hasSearch() || readOnly,
                disabled: disabled,
                placeholder: _placeholder,
                hasBorder: hasBorder,
                hasClear: false,
                htmlSize: '1',
                inputRender: function inputRender(inputEl) {
                    return _this4.renderSearchInput(valueNodes, _placeholder, inputEl);
                },
                onChange: this.handleSearch,
                onKeyDown: this.handleSearchKeyDown,
                onFocus: onFocus,
                onBlur: onBlur,
                className: prefix + 'select-inner',
                ref: this.saveInputRef }))
        );
    };

    Select.prototype.renderSearchInput = function renderSearchInput(valueNodes, placeholder, inputEl) {
        var _classNames2;

        var _props10 = this.props,
            prefix = _props10.prefix,
            mode = _props10.mode;

        var isSingle = mode === 'single';

        var mirrorText = this.state.searchValue;

        var cls = (0, _classnames2.default)((_classNames2 = {}, _classNames2[prefix + 'select-values'] = true, _classNames2[prefix + 'input-text-field'] = true, _classNames2));

        return _react2.default.createElement(
            'span',
            { className: cls },
            isSingle && valueNodes ? _react2.default.createElement(
                'em',
                null,
                valueNodes
            ) : valueNodes,
            _react2.default.createElement(
                'span',
                { className: prefix + 'select-trigger-search' },
                inputEl,
                _react2.default.createElement(
                    'span',
                    { 'aria-hidden': true },
                    mirrorText || placeholder,
                    '\xA0'
                )
            )
        );
    };

    /**
     * 渲染弹层的 header 内容
     * @override
     * @param {object} props
     */


    Select.prototype.renderMenuHeader = function renderMenuHeader() {
        var _props11 = this.props,
            prefix = _props11.prefix,
            hasSelectAll = _props11.hasSelectAll,
            mode = _props11.mode;


        var sourceCount = this.dataStore.getEnableDS().length;
        // 多选模式下才有全选
        if (!hasSelectAll || mode === 'single' || !sourceCount) {
            return null;
        }

        var text = typeof hasSelectAll === 'boolean' ? 'Select All' : hasSelectAll;

        return _react2.default.createElement(
            'div',
            { key: 'all', onClick: this.handleSelectAll, className: prefix + 'select-all' },
            _react2.default.createElement(
                'span',
                null,
                text
            )
        );
    };

    Select.prototype.render = function render() {
        var mode = this.props.mode;

        var props = _extends({}, this.props);

        // 搜索的时候不允许回车触发关闭
        if (this.hasSearch()) {
            props.canCloseByTrigger = false;
        }
        if (mode === 'single') {
            props.cache = true;
        }
        return _Base.prototype.render.call(this, props);
    };

    return Select;
}(_base2.default), _class.propTypes = _extends({}, _base2.default.propTypes, {
    /**
     * 选择器模式
     */
    mode: _propTypes2.default.oneOf(['single', 'multiple', 'tag']),
    /**
     * 当前值，用于受控模式
     */
    value: _propTypes2.default.any,
    /**
     * 初始的默认值
     */
    defaultValue: _propTypes2.default.any,
    /**
     * Select发生改变时触发的回调
     * @param {*} value 选中的值
     * @param {String} actionType 触发的方式, 'itemClick', 'enter', 'tag'
     * @param {*} item 选中的值的对象数据 (useDetailValue=false有效)
     */
    onChange: _propTypes2.default.func,
    /**
     * 传入的数据源，可以动态渲染子项，详见 [dataSource的使用](#dataSource的使用)
     */
    dataSource: _propTypes2.default.arrayOf(_propTypes2.default.oneOfType([_propTypes2.default.shape({
        value: _propTypes2.default.any,
        label: _propTypes2.default.any,
        disabled: _propTypes2.default.bool,
        children: _propTypes2.default.array
    }), _propTypes2.default.bool, _propTypes2.default.number, _propTypes2.default.string])),
    /**
     * 是否有边框
     */
    hasBorder: _propTypes2.default.bool,
    /**
     * 是否有下拉箭头
     */
    hasArrow: _propTypes2.default.bool,
    /**
     * 展开后是否能搜索（tag 模式下固定为true）
     */
    showSearch: _propTypes2.default.bool,
    /**
     * 当搜索框值变化时回调
     * @param {String} value 数据
     */
    onSearch: _propTypes2.default.func,
    /**
     * 当搜索框值被清空时候的回调
     * @param {String} actionType 触发的方式, 'select'(选择清空), 'popupClose'(弹窗关闭清空)
     */
    onSearchClear: _propTypes2.default.func,
    /**
     * 多选模式下是否有全选功能
     */
    hasSelectAll: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.string]),
    /**
     * 填充到选择框里的值的 key
     */
    fillProps: _propTypes2.default.string,
    /**
     * onChange 返回的 value 使用 dataSource 的对象
     */
    useDetailValue: _propTypes2.default.bool,
    /**
     * dataSource 变化的时是否保留已选的内容
     */
    cacheValue: _propTypes2.default.bool,
    /**
     * 渲染 Select 展现内容的方法
     * @param {Object} item 渲染节点的item
     * @return {ReactNode} 展现内容
     * @default item => item.label \|\| item.value
     */
    valueRender: _propTypes2.default.func,
    /**
     * 渲染 MenuItem 内容的方法
     * @param {Object} item 渲染节点的item
     * @param {String} searchValue 搜索关键字（如果开启搜索）
     * @return {ReactNode} item node
     */
    itemRender: _propTypes2.default.func,
    /**
     * 弹层内容为空的文案
     */
    notFoundContent: _propTypes2.default.node,
    style: _propTypes2.default.object,
    /**
     * 受控搜索值，一般不需要设置
     * @type {[type]}
     */
    searchValue: _propTypes2.default.string,
    /**
     * 选择后是否立即隐藏菜单 (mode=multiple/tag 模式生效)
     */
    hiddenSelected: _propTypes2.default.bool,
    /**
     * tag 删除回调
     * @param {object} item 渲染节点的item
     */
    onRemove: _propTypes2.default.func,
    /**
     * 焦点事件
     */
    onFocus: _propTypes2.default.func,
    /**
     * 失去焦点事件
     */
    onBlur: _propTypes2.default.func,
    onKeyDown: _propTypes2.default.func
}), _class.defaultProps = _extends({}, _base2.default.defaultProps, {
    mode: 'single',
    showSearch: false,
    cacheValue: true,
    onSearch: noop,
    onSearchClear: noop,
    hasArrow: true,
    onRemove: noop,
    valueRender: function valueRender(item) {
        return item.label || item.value;
    },
    onKeyDown: noop,
    onFocus: noop,
    onBlur: noop
}), _class.displayName = 'Select', _temp);
exports.default = Select;
module.exports = exports['default'];

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _util = __webpack_require__(2);

var _tag = __webpack_require__(179);

var _tag2 = _interopRequireDefault(_tag);

var _tagGroup = __webpack_require__(309);

var _tagGroup2 = _interopRequireDefault(_tagGroup);

var _selectable = __webpack_require__(310);

var _selectable2 = _interopRequireDefault(_selectable);

var _closeable = __webpack_require__(311);

var _closeable2 = _interopRequireDefault(_closeable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
var ConfigTag = _configProvider2.default.config(_tag2.default, {
    transfrom: function transfrom(props, deprecated) {
        var shape = props.shape,
            type = props.type;

        if (shape === 'selectable') {
            deprecated('shape=selectable', 'Tag.Selectable', 'Tag');
        }

        if (shape === 'deletable') {
            deprecated('shape=deletable', 'Tag.Closeable', 'Tag');
        }

        if (shape === 'link') {
            deprecated('shape=link', '<Tag><a href="x">x</a></Tag>', 'Tag');
        }

        if (shape === 'readonly' || shape === 'interactive') {
            _util.log.warning('Warning: [ shape=' + shape + ' ] is deprecated at [ Tag ]');
        }

        if (type === 'secondary') {
            _util.log.warning('Warning: [ type=secondary ] is deprecated at [ Tag ]');
        }

        ['count', 'marked', 'value', 'onChange'].forEach(function (key) {
            if (key in props) {
                _util.log.warning('Warning: [ ' + key + ' ] is deprecated at [ Tag ]');
            }
        });

        if ('selected' in props || 'defaultSelected' in props) {
            _util.log.warning('Warning: [ selected|defaultSelected  ] is deprecated at [ Tag ], use [ checked|defaultChecked ] at [ Tag.Selectable ] instead of it');
        }

        if ('closed' in props) {
            _util.log.warning('Warning: [ closed  ] is deprecated at [ Tag ], use [ onClose ] at [ Tag.Closeable ] instead of it');
        }

        if ('onSelect' in props) {
            deprecated('onSelect', '<Tag.Selectable onChange/>', 'Tag');
        }

        if ('afterClose' in props) {
            _util.log.warning('Warning: [ afterClose  ] is deprecated at [ Tag ], use [ afterClose ] at [ Tag.Closeable ] instead of it');
        }

        return props;
    }
});

ConfigTag.Group = _configProvider2.default.config(_tagGroup2.default);

ConfigTag.Selectable = _configProvider2.default.config(_selectable2.default);

// 有的地方叫做 Closeable 有的地方用Closeable, 为了保持兼容 文档类出现 Closeable, Closeable可以继续用
ConfigTag.Closable = _configProvider2.default.config(_closeable2.default);
ConfigTag.Closeable = ConfigTag.Closable;

exports.default = ConfigTag;
module.exports = exports['default'];

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var Group = (_temp = _class = function (_Component) {
    _inherits(Group, _Component);

    function Group() {
        _classCallCheck(this, Group);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    Group.prototype.render = function render() {
        var _props = this.props,
            className = _props.className,
            prefix = _props.prefix,
            children = _props.children,
            rtl = _props.rtl,
            others = _objectWithoutProperties(_props, ['className', 'prefix', 'children', 'rtl']);

        var clazz = (0, _classnames2.default)((prefix || 'next-') + 'tag-group', className);

        return _react2.default.createElement(
            'div',
            _extends({ className: clazz, dir: rtl ? 'rtl' : undefined }, others),
            children
        );
    };

    return Group;
}(_react.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    className: _propTypes2.default.any,
    children: _propTypes2.default.node,
    rtl: _propTypes2.default.bool
}, _class.defaultProps = {
    prefix: 'next-',
    rtl: false
}, _temp);
Group.displayName = 'Group';
exports.default = Group;
module.exports = exports['default'];

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _util = __webpack_require__(2);

var _tag = __webpack_require__(179);

var _tag2 = _interopRequireDefault(_tag);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = _util.func.noop,
    bindCtx = _util.func.bindCtx;

/**
 * Tag.Selectable
 */

var Selectable = (_temp = _class = function (_Component) {
    _inherits(Selectable, _Component);

    function Selectable(props) {
        _classCallCheck(this, Selectable);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        _this.state = {
            checked: 'checked' in props ? props.checked : props.defaultChecked || false
        };

        bindCtx(_this, ['handleClick']);
        return _this;
    }

    Selectable.prototype.handleClick = function handleClick(e) {
        e && e.preventDefault();
        // IE9 不支持 pointer-events，还是可能会触发 click 事件
        if (this.props.disabled) {
            return false;
        }

        this.setState(function (prevState) {
            return {
                checked: !prevState.checked
            };
        });

        this.props.onChange(!this.props.checked, e);
    };

    Selectable.prototype.render = function render() {
        var attrFilterTarget = ['checked', 'defaultChecked', 'onChange', 'className',
        // 防止这些额外的参数影响 tag 的类型
        '_shape', 'closable'];

        var others = _util.obj.pickOthers(attrFilterTarget, this.props);
        var isChecked = 'checked' in this.props ? this.props.checked : this.state.checked;
        var clazz = (0, _classnames2.default)(this.props.className, {
            checked: isChecked
        });
        return _react2.default.createElement(_tag2.default, _extends({}, others, { role: 'checkbox', _shape: 'checkable', 'aria-checked': isChecked, className: clazz, onClick: this.handleClick }));
    };

    return Selectable;
}(_react.Component), _class.propTypes = {
    /**
     * 标签是否被选中，受控用法
     * tag checked or not, a controlled way
     */
    checked: _propTypes2.default.bool,
    /**
     * 标签是否默认被选中，非受控用法
     * tag checked or not by default, a uncontrolled way
     */
    defaultChecked: _propTypes2.default.bool,
    /**
     * 选中状态变化时触发的事件
     * @param {Boolean} checked 是否选中
     * @param {Event} e Dom 事件对象
     */
    onChange: _propTypes2.default.func,
    /**
     * 标签是否被禁用
     */
    disabled: _propTypes2.default.bool,
    className: _propTypes2.default.any
}, _class.defaultProps = {
    onChange: noop
}, _temp);
Selectable.displayName = 'Selectable';
exports.default = Selectable;
module.exports = exports['default'];

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _tag = __webpack_require__(179);

var _tag2 = _interopRequireDefault(_tag);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Tag.Closeable
 */
var Closeable = (_temp = _class = function (_Component) {
    _inherits(Closeable, _Component);

    function Closeable() {
        _classCallCheck(this, Closeable);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    Closeable.prototype.render = function render() {
        var _props = this.props,
            disabled = _props.disabled,
            className = _props.className,
            closeArea = _props.closeArea,
            onClose = _props.onClose,
            afterClose = _props.afterClose,
            onClick = _props.onClick,
            type = _props.type,
            size = _props.size,
            children = _props.children,
            rtl = _props.rtl;


        return _react2.default.createElement(
            _tag2.default,
            {
                rtl: rtl,
                disabled: disabled,
                className: className,
                closeArea: closeArea,
                onClose: onClose,
                afterClose: afterClose,
                onClick: onClick,
                type: type,
                size: size,
                closable: true },
            children
        );
    };

    return Closeable;
}(_react.Component), _class.propTypes = {
    disabled: _propTypes2.default.bool,
    className: _propTypes2.default.any,
    /**
     * closeable 标签的 onClose 响应区域, tag: 标签体, tail(默认): 关闭按钮
     */
    closeArea: _propTypes2.default.oneOf(['tag', 'tail']),
    /**
     * 点击关闭按钮时的回调
     * @param {String} from 事件来源, tag: 标签体点击, tail: 关闭按钮点击
     * @returns {Boolean} true则关闭, false阻止关闭
     */
    onClose: _propTypes2.default.func,
    /**
     * 标签关闭后执行的回调
     */
    afterClose: _propTypes2.default.func,
    /**
     * 点击回调
     */
    onClick: _propTypes2.default.func,
    type: _propTypes2.default.oneOf(['normal', 'primary']),
    /**
     * 标签的尺寸（large 尺寸为兼容表单场景 large = medium）
     */
    size: _propTypes2.default.oneOf(['small', 'medium', 'large']),
    children: _propTypes2.default.any,
    rtl: _propTypes2.default.bool
}, _class.defaultProps = {
    disabled: false,
    type: 'normal'
}, _temp);
Closeable.displayName = 'Closeable';
exports.default = Closeable;
module.exports = exports['default'];

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _util = __webpack_require__(180);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * manage dataSource for menu list
 */
var DataStore = function () {
    function DataStore(options) {
        _classCallCheck(this, DataStore);

        this.options = _extends({
            filter: _util.filter,
            key: undefined,
            addonKey: false,
            filterLocal: true
        }, options);

        // origin data
        this.dataSource = [];
        // current data for menu display
        this.menuDataSource = [];
        // key=>value map for menuDataSource
        this.mapDataSource = {};
        // current data can be select (not disabled) on menu
        this.enabledDataSource = [];
    }

    DataStore.prototype.setOptions = function setOptions(options) {
        _extends(this.options, options);
    };

    DataStore.prototype.updateByDS = function updateByDS(dataSource) {
        var isChildren = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        this.dataSource = isChildren ? (0, _util.parseDataSourceFromChildren)(dataSource) : (0, _util.normalizeDataSource)(dataSource);
        return this.updateAll();
    };

    DataStore.prototype.updateByKey = function updateByKey(key) {
        if (key === this.options.key) {
            return this.getMenuDS();
        }

        this.options.key = key;
        return this.updateAll();
    };

    DataStore.prototype.getOriginDS = function getOriginDS() {
        return this.dataSource;
    };

    DataStore.prototype.getMenuDS = function getMenuDS() {
        return this.menuDataSource;
    };

    DataStore.prototype.getFlattenDS = function getFlattenDS() {
        return this.flattenDataSource;
    };

    DataStore.prototype.getEnableDS = function getEnableDS() {
        return this.enabledDataSource;
    };

    DataStore.prototype.getMapDS = function getMapDS() {
        return this.mapDataSource;
    };

    DataStore.prototype.updateAll = function updateAll() {
        var _this = this;

        var _options = this.options,
            key = _options.key,
            filter = _options.filter,
            filterLocal = _options.filterLocal;

        this.menuDataSource = (0, _util.filterDataSource)(this.dataSource, filterLocal ? key : '', filter, this.options.addonKey);

        this.flattenDataSource = (0, _util.flattingDataSource)(this.menuDataSource);

        this.mapDataSource = {};
        this.flattenDataSource.forEach(function (item) {
            _this.mapDataSource['' + item.value] = item;
        });

        this.enabledDataSource = this.flattenDataSource.filter(function (item) {
            return !item.disabled;
        });

        return this.menuDataSource;
    };

    return DataStore;
}();

exports.default = DataStore;
module.exports = exports['default'];

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _virtualList = __webpack_require__(314);

var _virtualList2 = _interopRequireDefault(_virtualList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _configProvider2.default.config(_virtualList2.default);
module.exports = exports['default'];

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _reactDom = __webpack_require__(4);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var NOOP = function NOOP() {};
var MAX_SYNC_UPDATES = 100;

var isEqualSubset = function isEqualSubset(a, b) {
    for (var key in b) {
        if (a[key] !== b[key]) {
            return false;
        }
    }

    return true;
};

/** VirtualList */
var VirtualList = (_temp = _class = function (_Component) {
    _inherits(VirtualList, _Component);

    function VirtualList(props) {
        _classCallCheck(this, VirtualList);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        var jumpIndex = props.jumpIndex;

        var _this$constrain = _this.constrain(jumpIndex, 0, props),
            from = _this$constrain.from,
            size = _this$constrain.size;

        _this.state = { from: from, size: size };
        _this.cache = {};
        _this.scrollTo = _this.scrollTo.bind(_this);
        _this.cachedScroll = null;
        _this.unstable = false;
        _this.updateCounter = 0;
        return _this;
    }

    VirtualList.prototype.componentDidMount = function componentDidMount() {
        var jumpIndex = this.props.jumpIndex;


        this.updateFrameAndClearCache = this.updateFrameAndClearCache.bind(this);

        _util.events.on(window, 'resize', this.updateFrameAndClearCache);

        this.updateFrame(this.scrollTo.bind(this, jumpIndex));
    };

    VirtualList.prototype.componentWillReceiveProps = function componentWillReceiveProps(next) {
        var _state = this.state,
            from = _state.from,
            size = _state.size;


        var oldIndex = this.props.jumpIndex;
        var newIndex = next.jumpIndex;

        if (oldIndex !== newIndex) {
            this.updateFrame(this.scrollTo.bind(this, newIndex));
        }

        this.maybeSetState(this.constrain(from, size, next), NOOP);
    };

    VirtualList.prototype.componentDidUpdate = function componentDidUpdate() {
        var _this2 = this;

        // If the list has reached an unstable state, prevent an infinite loop.
        if (this.unstable) {
            return;
        }

        if (++this.updateCounter > MAX_SYNC_UPDATES) {
            this.unstable = true;
        }

        if (!this.updateCounterTimeoutId) {
            this.updateCounterTimeoutId = setTimeout(function () {
                _this2.updateCounter = 0;
                delete _this2.updateCounterTimeoutId;
            }, 0);
        }

        this.updateFrame();
    };

    VirtualList.prototype.componentWillUnmount = function componentWillUnmount() {
        _util.events.off(window, 'resize', this.updateFrameAndClearCache);

        _util.events.off(this.scrollParent, 'scroll', this.updateFrameAndClearCache);
        _util.events.off(this.scrollParent, 'mousewheel', NOOP);
    };

    VirtualList.prototype.maybeSetState = function maybeSetState(b, cb) {

        if (isEqualSubset(this.state, b)) {
            return cb();
        }

        this.setState(b, cb);
    };

    VirtualList.prototype.getOffset = function getOffset(el) {
        var offset = el.clientLeft || 0;
        do {
            offset += el.offsetTop || 0;
            el = el.offsetParent;
        } while (el);
        return offset;
    };

    VirtualList.prototype.getEl = function getEl() {
        return this.el || this.items || {};
    };

    VirtualList.prototype.getScrollParent = function getScrollParent() {
        var el = this.getEl();
        el = el.parentElement;

        switch (window.getComputedStyle(el).overflowY) {
            case 'auto':case 'scroll':case 'overlay':case 'visible':
                return el;
        }

        return window;
    };

    VirtualList.prototype.getScroll = function getScroll() {
        // Cache scroll position as this causes a forced synchronous layout.
        // if (typeof this.cachedScroll === 'number') {
        //     return this.cachedScroll;
        // }
        var scrollParent = this.scrollParent;

        var scrollKey = 'scrollTop';
        var actual = scrollParent === window ?
        // Firefox always returns document.body[scrollKey] as 0 and Chrome/Safari
        // always return document.documentElement[scrollKey] as 0, so take
        // whichever has a value.
        document.body[scrollKey] || document.documentElement[scrollKey] : scrollParent[scrollKey];
        var max = this.getScrollSize() - this.getViewportSize();

        var scroll = Math.max(0, Math.min(actual, max));
        var el = this.getEl();
        this.cachedScroll = this.getOffset(scrollParent) + scroll - this.getOffset(el);

        return this.cachedScroll;
    };

    VirtualList.prototype.setScroll = function setScroll(offset) {
        var scrollParent = this.scrollParent;

        offset += this.getOffset(this.getEl());
        if (scrollParent === window) {
            return window.scrollTo(0, offset);
        }

        offset -= this.getOffset(this.scrollParent);
        scrollParent.scrollTop = offset;
    };

    VirtualList.prototype.getViewportSize = function getViewportSize() {
        var scrollParent = this.scrollParent;

        return scrollParent === window ? window.innerHeight : scrollParent.clientHeight;
    };

    VirtualList.prototype.getScrollSize = function getScrollSize() {
        var scrollParent = this.scrollParent;
        var _document = document,
            body = _document.body,
            documentElement = _document.documentElement;

        var key = 'scrollHeight';
        return scrollParent === window ? Math.max(body[key], documentElement[key]) : scrollParent[key];
    };

    VirtualList.prototype.getStartAndEnd = function getStartAndEnd() {
        var threshold = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.threshold;

        var scroll = this.getScroll();

        var trueScroll = scroll;
        var start = Math.max(0, trueScroll - threshold);
        var end = trueScroll + this.getViewportSize() + threshold;

        return { start: start, end: end };
    };

    // Called by 'scroll' and 'resize' events, clears scroll position cache.


    VirtualList.prototype.updateFrameAndClearCache = function updateFrameAndClearCache(cb) {
        this.cachedScroll = null;
        return this.updateFrame(cb);
    };

    VirtualList.prototype.updateFrame = function updateFrame(cb) {
        this.updateScrollParent();

        if (typeof cb !== 'function') {
            cb = NOOP;
        }

        return this.updateVariableFrame(cb);
    };

    VirtualList.prototype.updateScrollParent = function updateScrollParent() {
        var prev = this.scrollParent;
        this.scrollParent = this.getScrollParent();

        if (prev === this.scrollParent) {
            return;
        }
        if (prev) {
            _util.events.off(prev, 'scroll', this.updateFrameAndClearCache);
            _util.events.off(prev, 'mousewheel', NOOP);
        }

        _util.events.on(this.scrollParent, 'scroll', this.updateFrameAndClearCache);
        _util.events.on(this.scrollParent, 'mousewheel', NOOP);

        // You have to attach mousewheel listener to the scrollable element.
        // Just an empty listener. After that onscroll events will be fired synchronously.
    };

    VirtualList.prototype.updateVariableFrame = function updateVariableFrame(cb) {
        if (!this.props.itemSizeGetter) {
            this.cacheSizes();
        }

        var _getStartAndEnd = this.getStartAndEnd(),
            start = _getStartAndEnd.start,
            end = _getStartAndEnd.end;

        var _props = this.props,
            pageSize = _props.pageSize,
            children = _props.children;

        var length = children.length;
        var space = 0;
        var from = 0;
        var size = 0;
        var maxFrom = length - 1;

        while (from < maxFrom) {
            var itemSize = this.getSizeOf(from);
            if (itemSize === null || itemSize === undefined || space + itemSize > start) {
                break;
            }
            space += itemSize;
            ++from;
        }

        var maxSize = length - from;

        while (size < maxSize && space < end) {
            var _itemSize = this.getSizeOf(from + size);
            if (_itemSize === null || _itemSize === undefined) {
                size = Math.min(size + pageSize, maxSize);
                break;
            }
            space += _itemSize;
            ++size;
        }

        this.maybeSetState({ from: from, size: size }, cb);
    };

    VirtualList.prototype.getSpaceBefore = function getSpaceBefore(index) {
        var cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


        if (!index) {
            return 0;
        }
        if (cache[index] !== null && cache[index] !== undefined) {
            return cache[index] || 0;
        }

        // Find the closest space to index there is a cached value for.
        var from = index;
        while (from > 0 && (cache[from] === null || cache[from] === undefined)) {
            from--;
        }

        // Finally, accumulate sizes of items from - index.
        var space = cache[from] || 0;
        for (var i = from; i < index; ++i) {
            cache[i] = space;
            var itemSize = this.getSizeOf(i);
            if (itemSize === null || itemSize === undefined) {
                break;
            }
            space += itemSize;
        }

        cache[index] = space;

        return cache[index] || 0;
    };

    VirtualList.prototype.cacheSizes = function cacheSizes() {
        var cache = this.cache;
        var from = this.state.from;
        var _items = this.items,
            children = _items.children,
            _items$props = _items.props,
            props = _items$props === undefined ? {} : _items$props;

        var itemEls = children || props.children || [];
        for (var i = 0, l = itemEls.length; i < l; ++i) {
            var ulRef = (0, _reactDom.findDOMNode)(this.items);
            var height = ulRef.children[i].offsetHeight;
            if (height > 0) {
                cache[from + i] = height;
            }
        }
    };

    VirtualList.prototype.getSizeOf = function getSizeOf(index) {
        var cache = this.cache;
        var _props2 = this.props,
            itemSizeGetter = _props2.itemSizeGetter,
            jumpIndex = _props2.jumpIndex;

        // Try the cache.

        if (index in cache) {
            return cache[index];
        }
        if (itemSizeGetter) {
            return itemSizeGetter(index);
        }

        var height = Object.values(this.cache).pop();
        if (!this.defaultItemHeight && jumpIndex > -1 && height) {
            this.defaultItemHeight = height;
        }

        if (this.defaultItemHeight) {
            return this.defaultItemHeight;
        }
    };

    VirtualList.prototype.constrain = function constrain(from, size, _ref) {
        var children = _ref.children,
            minSize = _ref.minSize;

        var length = children && children.length;
        size = Math.max(size, minSize);
        if (size > length) {
            size = length;
        }
        from = from ? Math.max(Math.min(from, length - size), 0) : 0;

        return { from: from, size: size };
    };

    VirtualList.prototype.scrollTo = function scrollTo(index) {
        this.setScroll(this.getSpaceBefore(index));
    };

    VirtualList.prototype.renderMenuItems = function renderMenuItems() {
        var _this3 = this;

        var _props3 = this.props,
            children = _props3.children,
            itemsRenderer = _props3.itemsRenderer;
        var _state2 = this.state,
            from = _state2.from,
            size = _state2.size;

        var items = [];

        for (var i = 0; i < size; ++i) {
            items.push(children[from + i]);
        }

        return itemsRenderer(items, function (c) {
            _this3.items = c;
            return _this3.items;
        });
    };

    VirtualList.prototype.render = function render() {
        var _cx,
            _this4 = this;

        var _props4 = this.props,
            _props4$children = _props4.children,
            children = _props4$children === undefined ? [] : _props4$children,
            prefix = _props4.prefix,
            className = _props4.className;

        var length = children.length;
        var from = this.state.from;

        var items = this.renderMenuItems();

        var style = { position: 'relative' };
        var cache = {};

        var size = this.getSpaceBefore(length, cache);

        if (size) {
            style.height = size;
        }
        var offset = this.getSpaceBefore(from, cache);
        var transform = 'translate(0px, ' + offset + 'px)';
        var listStyle = {
            msTransform: transform,
            WebkitTransform: transform,
            transform: transform
        };

        var cls = (0, _classnames2.default)((_cx = {}, _cx[prefix + 'virtual-list-wrapper'] = true, _cx[className] = !!className, _cx));

        return _react2.default.createElement(
            'div',
            { className: cls, style: style, ref: function ref(c) {
                    _this4.el = c;
                    return _this4.el;
                } },
            _react2.default.createElement(
                'div',
                { style: listStyle },
                items
            )
        );
    };

    return VirtualList;
}(_react.Component), _class.displayName = 'VirtualList', _class.propTypes = {
    prefix: _propTypes2.default.string,
    /**
     * 渲染的子节点
     */
    children: _propTypes2.default.any,
    /**
     * 最小加载数量
     */
    minSize: _propTypes2.default.number,
    /**
     * 一屏数量
     */
    pageSize: _propTypes2.default.number,
    /**
     * 父渲染函数，默认为 (items, ref) => <ul ref={ref}>{items}</ul>
     */
    itemsRenderer: _propTypes2.default.func,
    /**
     * 缓冲区高度
     */
    threshold: _propTypes2.default.number,
    /**
     * 获取item高度的函数
     */
    itemSizeGetter: _propTypes2.default.func,
    /**
     * 设置跳转位置，需要设置 itemSizeGetter 才能生效, 不设置认为元素等高并取第一个元素高度作为默认高
     */
    jumpIndex: _propTypes2.default.number,
    className: _propTypes2.default.string
}, _class.defaultProps = {
    prefix: 'next-',
    itemsRenderer: function itemsRenderer(items, ref) {
        return _react2.default.createElement(
            'ul',
            { ref: ref },
            items
        );
    },
    minSize: 1,
    pageSize: 10,
    jumpIndex: 0,
    threshold: 100
}, _temp);
VirtualList.displayName = 'VirtualList';
exports.default = VirtualList;
module.exports = exports['default'];

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _util = __webpack_require__(2);

var _input = __webpack_require__(178);

var _input2 = _interopRequireDefault(_input);

var _base = __webpack_require__(209);

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var bindCtx = _util.func.bindCtx,
    noop = _util.func.noop;

/**
 * Select.AutoComplete
 */

var AutoComplete = (_temp = _class = function (_Base) {
    _inherits(AutoComplete, _Base);

    function AutoComplete(props) {
        _classCallCheck(this, AutoComplete);

        var _this = _possibleConstructorReturn(this, _Base.call(this, props));

        _this.handleChange = function (value, proxy, item) {
            var _this$props = _this.props,
                disabled = _this$props.disabled,
                readOnly = _this$props.readOnly,
                filterLocal = _this$props.filterLocal;


            if (disabled || readOnly) {
                return false;
            }

            var actionType = typeof proxy === 'string' ? proxy : 'change';

            _this.isInputing = actionType === 'change';

            if (filterLocal) {
                _this.setState({
                    dataSource: _this.dataStore.updateByKey(value)
                });

                _this.shouldControlPopup(_this.props, actionType);
                _this.setFirstHightLightKeyForMenu();
            }

            // 非受控模式清空内部数据
            if (!('value' in _this.props)) {
                _this.setState({
                    value: value
                });
            }

            _this.props.onChange(value, actionType, item);

            if (actionType === 'itemClick' || actionType === 'enter') {
                // 点击 item 的时候不会触发关闭，需要手动关闭，其它类型比如 keyDown 等都会有其它事件句柄处理
                _this.setVisible(false, actionType);
            }
        };

        _this.isAutoComplete = true;
        _this.isInputing = false;

        bindCtx(_this, ['handleTriggerKeyDown', 'handleMenuSelect', 'handleItemClick']);
        return _this;
    }

    AutoComplete.prototype.componentWillMount = function componentWillMount() {
        this.dataStore.setOptions({ key: this.state.value });

        _Base.prototype.componentWillMount.call(this);
    };

    AutoComplete.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if ('value' in nextProps) {
            this.dataStore.setOptions({ key: nextProps.value });
        }

        _Base.prototype.componentWillReceiveProps.call(this, nextProps);

        // remote dataSource and focused
        // 因为autoComplete没有下拉数据不展示，搜索并且有数据了需要自动展示下拉
        if (!nextProps.filterLocal && this.isInputing) {
            this.shouldControlPopup(nextProps, 'update');
        }

        if (!nextProps.filterLocal && !nextProps.popupContent) {
            this.setFirstHightLightKeyForMenu();
        }
    };

    AutoComplete.prototype.componentWillUpdate = function componentWillUpdate() {
        if (this.hasClear()) {
            var inputNode = _reactDom2.default.findDOMNode(this.inputRef);
            if (inputNode) {
                this.clearNode = inputNode.querySelector('.' + this.props.prefix + 'input-control');
            }
        }
    };

    AutoComplete.prototype.shouldControlPopup = function shouldControlPopup() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
        var type = arguments[1];

        var hasPopup = props.popupContent || this.dataStore.getMenuDS().length;
        if (hasPopup) {
            this.setVisible(true, type);
        } else {
            this.setVisible(false, type);
        }
    };

    AutoComplete.prototype.handleMenuSelect = function handleMenuSelect(keys) {
        var key = keys[0];
        if (this.state.value === keys[0]) {
            return this.setVisible(false, 'itemClick');
        }

        var mapDS = this.dataStore.getMapDS();

        if (key in mapDS) {
            var item = mapDS[key];
            this.handleSelectEvent(key, item, 'itemClick');
        }
    };

    AutoComplete.prototype.handleItemClick = function handleItemClick() {
        this.setVisible(false, 'itemClick');
    };

    AutoComplete.prototype.handleSelectEvent = function handleSelectEvent(key, item, triggerType) {
        var value = item && item[this.props.fillProps] || key;

        if (triggerType === 'itemClick' || triggerType === 'enter') {
            // 点击 item 的时候不会触发关闭，需要手动关闭，其它类型比如 keyDown 等都会有其它事件句柄处理
            this.setVisible(false, triggerType);
        }

        this.handleChange(value, triggerType, item);
    };

    AutoComplete.prototype.handleVisibleChange = function handleVisibleChange(visible, type) {
        if (!('visible' in this.props) && visible && !this.props.popupContent && !this.dataStore.getMenuDS().length) {
            return;
        }

        this.setVisible(visible, type);
    };

    AutoComplete.prototype.beforeClose = function beforeClose() {
        this.isInputing = false;
    };

    /**
     * Handle trigger keydown event
     * @param {Event} e
     */


    AutoComplete.prototype.handleTriggerKeyDown = function handleTriggerKeyDown(e) {
        var _props = this.props,
            popupContent = _props.popupContent,
            onToggleHighlightItem = _props.onToggleHighlightItem,
            onKeyDown = _props.onKeyDown;

        if (popupContent) {
            return onKeyDown(e);
        }

        switch (e.keyCode) {
            case _util.KEYCODE.UP:
                e.preventDefault();
                onToggleHighlightItem(this.toggleHighlightItem(-1, e), 'up');
                break;
            case _util.KEYCODE.DOWN:
                e.preventDefault();
                onToggleHighlightItem(this.toggleHighlightItem(1, e), 'down');
                break;
            case _util.KEYCODE.ENTER:
                e.preventDefault();
                this.chooseHighlightItem(e);
                break;
            case _util.KEYCODE.SPACE:
                // 防止 Popup 监听到 space key 触发 onVisibleChange
                e.stopPropagation();
                break;
            case _util.KEYCODE.ESC:
                e.preventDefault();
                this.state.visible && this.setVisible(false, 'esc');
                break;
            default:
                break;
        }

        onKeyDown(e);
    };

    // 回车 选择高亮的 item


    AutoComplete.prototype.chooseHighlightItem = function chooseHighlightItem() {
        if (!this.state.visible) {
            return false;
        }

        var highlightKey = this.state.highlightKey;

        var highlightItem = this.dataStore.getEnableDS().find(function (item) {
            return highlightKey === '' + item.value;
        });

        if (highlightItem) {
            this.handleSelectEvent(highlightKey, highlightItem, 'enter');
        }
    };

    AutoComplete.prototype.hasClear = function hasClear() {
        var _props2 = this.props,
            hasClear = _props2.hasClear,
            readOnly = _props2.readOnly,
            disabled = _props2.disabled;
        var value = this.state.value;


        return value && hasClear && !readOnly && !disabled;
    };

    /**
     * 选择器
     * @override
     * @param {object} props
     */


    AutoComplete.prototype.renderSelect = function renderSelect() {
        var _classNames;

        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
        var placeholder = props.placeholder,
            size = props.size,
            prefix = props.prefix,
            className = props.className,
            style = props.style,
            label = props.label,
            readOnly = props.readOnly,
            disabled = props.disabled,
            highlightHolder = props.highlightHolder,
            locale = props.locale,
            hasClear = props.hasClear,
            state = props.state,
            rtl = props.rtl;

        var others = _util.obj.pickOthers(AutoComplete.propTypes, props);
        var othersData = _util.obj.pickAttrsWith(others, 'data-');

        var value = this.state.value;
        var visible = this.state.visible;

        // // 下拉箭头
        // const arrowNode = this.renderArrowNode(props, () => {
        //     this.focusInput();
        //     this.setVisible(!this.state.visible);
        // });

        // trigger className
        var triggerClazz = (0, _classnames2.default)([prefix + 'select', prefix + 'select-auto-complete', prefix + 'size-' + size, className], (_classNames = {}, _classNames[prefix + 'active'] = visible, _classNames[prefix + 'disabled'] = disabled, _classNames));

        // highlightKey into placeholder
        // compatible with selectPlaceHolder. TODO: removed in 2.0 version
        var _placeholder = placeholder || locale.autoCompletePlaceholder || locale.autoCompletePlaceHolder;
        if (highlightHolder && visible) {
            _placeholder = this.state.highlightKey || _placeholder;
        }

        // Input props
        var _inputProps = _extends({}, _util.obj.pickOthers(othersData, others), {
            state: state,
            ref: this.saveInputRef,
            hasClear: hasClear,
            value: value || '',
            size: size,
            disabled: disabled,
            readOnly: readOnly,
            placeholder: _placeholder,
            label: label,
            // extra: arrowNode,
            onChange: this.handleChange,
            onKeyDown: this.handleTriggerKeyDown
        });

        return _react2.default.createElement(
            'span',
            _extends({}, othersData, {
                className: triggerClazz,
                style: style,
                dir: rtl ? 'rtl' : undefined,
                ref: this.saveSelectRef,
                onClick: this.focusInput }),
            _react2.default.createElement(_input2.default, _extends({}, _inputProps, {
                role: 'combobox',
                'aria-autocomplete': 'list',
                'aria-disabled': disabled,
                'aria-expanded': this.state.visible }))
        );
    };

    AutoComplete.prototype.render = function render() {
        var _this2 = this;

        if (this.hasClear()) {
            // clear 按钮点击后，会在 dom 结构中被删除掉，需要将其额外设置为安全节点，防止触发弹层的显示或隐藏
            var safeNode = this.props.popupProps.safeNode || [];
            var safeNodes = Array.isArray(safeNode) ? safeNode : [safeNode];
            safeNodes.push(function () {
                return _this2.clearNode;
            });
            this.props.popupProps.safeNode = safeNodes;
        }

        return _Base.prototype.render.call(this, _extends({}, this.props, { canCloseByTrigger: false }));
    };

    return AutoComplete;
}(_base2.default), _class.propTypes = _extends({}, _base2.default.propTypes, {
    /**
     * 当前值，用于受控模式
     */
    value: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
    /**
     * 初始化的默认值
     */
    defaultValue: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
    /**
     * Select发生改变时触发的回调
     * @param {*} value 选中的值
     * @param {String} actionType 触发的方式, 'itemClick', 'enter', 'change'
     * @param {*} item 选中的值的对象数据
     */
    onChange: _propTypes2.default.func,
    /**
     * 传入的数据源，可以动态渲染子项
     */
    dataSource: _propTypes2.default.arrayOf(_propTypes2.default.oneOfType([_propTypes2.default.shape({
        value: _propTypes2.default.string,
        label: _propTypes2.default.any,
        disabled: _propTypes2.default.bool,
        children: _propTypes2.default.array
    }), _propTypes2.default.string])),
    /**
     * 填充到选择框里的值的 key，默认是 value
     */
    fillProps: _propTypes2.default.string,
    /**
     * 渲染 MenuItem 内容的方法
     * @param {Object} item 渲染节点的 item
     * @return {ReactNode} item node
     */
    itemRender: _propTypes2.default.func,
    // input keydown
    onKeyDown: _propTypes2.default.func,
    // 是否将当前高亮的选项作为 placeholder
    highlightHolder: _propTypes2.default.bool,
    style: _propTypes2.default.object
}), _class.defaultProps = _extends({}, _base2.default.defaultProps, {
    onKeyDown: noop,
    fillProps: 'value'
}), _temp);
exports.default = AutoComplete;
module.exports = exports['default'];

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* istanbul ignore file */

/**
 * Select.Option
 */
var Option = (_temp = _class = function (_React$Component) {
  _inherits(Option, _React$Component);

  function Option() {
    _classCallCheck(this, Option);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Option.prototype.render = function render() {
    return this.props.children;
  };

  return Option;
}(_react2.default.Component), _class.propTypes = {
  /**
   * 选项值
   */
  value: _propTypes2.default.any.isRequired,
  /**
   * 是否禁用
   */
  disabled: _propTypes2.default.bool,
  children: _propTypes2.default.any
}, _class._typeMark = 'next_select_option', _temp);
Option.displayName = 'Option';
exports.default = Option;
module.exports = exports['default'];

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* istanbul ignore file */

/**
 * Select.OptionGroup
 */
var OptionGroup = (_temp = _class = function (_React$Component) {
    _inherits(OptionGroup, _React$Component);

    function OptionGroup() {
        _classCallCheck(this, OptionGroup);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    OptionGroup.prototype.render = function render() {
        return this.props.children;
    };

    return OptionGroup;
}(_react2.default.Component), _class.propTypes = {
    /**
     * 设置分组的文案
     */
    label: _propTypes2.default.node,
    children: _propTypes2.default.any
}, _class._typeMark = 'next_select_option_group', _temp);
OptionGroup.displayName = 'OptionGroup';
exports.default = OptionGroup;
module.exports = exports['default'];

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(72);

__webpack_require__(210);

__webpack_require__(320);

__webpack_require__(324);

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(181);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(181, function () {
			var newContent = __webpack_require__(181);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(11);

__webpack_require__(321);

__webpack_require__(36);

__webpack_require__(77);

__webpack_require__(210);

__webpack_require__(323);

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(11);

__webpack_require__(12);

__webpack_require__(322);

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(182);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(182, function () {
			var newContent = __webpack_require__(182);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(183);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(183, function () {
			var newContent = __webpack_require__(183);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(184);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(184, function () {
			var newContent = __webpack_require__(184);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(185);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(true) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept(185, function() {
			var newContent = __webpack_require__(185);
			if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ })
],[300]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ3aW5kb3cuUmVhY3RcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3Byb3AtdHlwZXNAMTUuNi4yQHByb3AtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19jbGFzc25hbWVzQDIuMi42QGNsYXNzbmFtZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwid2luZG93LlJlYWN0RE9NXCIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy1wcm92aWRlci9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL3NyYy90YWJsZS91dGlsLmpzIiwid2VicGFjazovLy8uL3NyYy9pY29uL2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvaWNvbi9zdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYW5pbWF0ZS9zdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21lbnUvdmlldy9pdGVtLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvb3ZlcmxheS9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2Jhc2UvYm9keS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2Jhc2Uvcm93LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvYmFzZS9jZWxsLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvZml4ZWQvaGVhZGVyLmpzeCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3Byb3AtdHlwZXNAMTUuNi4yQHByb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL3NyYy9vdmVybGF5L3V0aWxzL2ZpbmQtbm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWVudS92aWV3L3NlbGVjdGFibGUtaXRlbS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2NvbHVtbi5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2ZpeGVkL3dyYXBwZXIuanN4Iiwid2VicGFjazovLy8uL3NyYy9pY29uL21haW4uc2Nzcz83MDIyIiwid2VicGFjazovLy8uL3NyYy9hbmltYXRlL21haW4uc2Nzcz9lYmE4Iiwid2VicGFjazovLy8uL3NyYy9jaGVja2JveC9tYWluLnNjc3M/ZWZlYSIsIndlYnBhY2s6Ly8vLi9zcmMvcmFkaW8vbWFpbi5zY3NzPzhiNTQiLCJ3ZWJwYWNrOi8vLy4vc3JjL21lbnUvbWFpbi5zY3NzPzVkZTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2J1dHRvbi9tYWluLnNjc3M/MGFkNCIsIndlYnBhY2s6Ly8vLi9zcmMvb3ZlcmxheS9tYWluLnNjc3M/MmM2ZCIsIndlYnBhY2s6Ly8vLi9zcmMvZHJvcGRvd24vbWFpbi5zY3NzPzY1ODAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvYWRpbmcvbWFpbi5zY3NzP2M1NDIiLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL21haW4uc2Nzcz83ZGRlIiwid2VicGFjazovLy8uL3NyYy9sb2NhbGUvemgtY24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL292ZXJsYXkvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NoZWNrYm94L2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY2hlY2tib3gvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy1wcm92aWRlci9nZXQtY29udGV4dC1wcm9wcy5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvZG9tLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlsL3N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9lbnYuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwva2V5Y29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3NoYWxsb3ctZWxlbWVudC1lcXVhbHNAMS4wLjFAc2hhbGxvdy1lbGVtZW50LWVxdWFscy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvb3ZlcmxheS9vdmVybGF5LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvb3ZlcmxheS9nYXRld2F5LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvb3ZlcmxheS9wb3NpdGlvbi5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2Jhc2UvaGVhZGVyLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvYmFzZS9maWx0ZXIuanN4Iiwid2VicGFjazovLy8uL3NyYy9tZW51L3ZpZXcvbWVudS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2FuaW1hdGUvYW5pbWF0ZS5qc3giLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19yZWFjdC10cmFuc2l0aW9uLWdyb3VwQDIuNS4yQHJlYWN0LXRyYW5zaXRpb24tZ3JvdXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19yZWFjdC10cmFuc2l0aW9uLWdyb3VwQDIuNS4yQHJlYWN0LXRyYW5zaXRpb24tZ3JvdXAvVHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3JlYWN0LWxpZmVjeWNsZXMtY29tcGF0QDMuMC40QHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0L3JlYWN0LWxpZmVjeWNsZXMtY29tcGF0LmVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9fcmVhY3QtdHJhbnNpdGlvbi1ncm91cEAyLjUuMkByZWFjdC10cmFuc2l0aW9uLWdyb3VwL3V0aWxzL1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3JlYWN0LXRyYW5zaXRpb24tZ3JvdXBAMi41LjJAcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9UcmFuc2l0aW9uR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21lbnUvdmlldy9wb3B1cC1pdGVtLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvbWVudS92aWV3L2NoZWNrYWJsZS1pdGVtLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY2hlY2tib3gvY2hlY2tib3guanN4Iiwid2VicGFjazovLy8uL3NyYy9taXhpbi11aS1zdGF0ZS9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3JhZGlvL2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvcmFkaW8vcmFkaW8uanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS9iYXNlL3NvcnQuanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS9zZWxlY3Rpb24vcm93LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvZXhwYW5kZWQvcm93LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvbG9jay9yb3cuanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS9maXhlZC9ib2R5LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvbGlzdC1oZWFkZXIuanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS9saXN0LWZvb3Rlci5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3JhZGlvL3N0eWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9idXR0b24vaW5kZXguanN4Iiwid2VicGFjazovLy8uL3NyYy9idXR0b24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FuaW1hdGUvaW5kZXguanN4Iiwid2VicGFjazovLy8uL3NyYy9sb2FkaW5nL2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvbWVudS9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL21lbnUvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvYWRpbmcvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3Byb3AtdHlwZXNAMTUuNi4yQHByb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19vYmplY3QtYXNzaWduQDQuMS4xQG9iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19wcm9wLXR5cGVzQDE1LjYuMkBwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9fcHJvcC10eXBlc0AxNS42LjJAcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy1wcm92aWRlci9jb25maWcuanN4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9faG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3NAMi41LjVAaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvZGlzdC9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy5janMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlsL2Z1bmMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvbG9nLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlsL3N1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvZm9jdXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvZ3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnLXByb3ZpZGVyL2NvbnN1bWVyLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnLXByb3ZpZGVyL2NhY2hlLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcIndpbmRvdy5tb21lbnRcIiIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvYmFzZS5qc3giLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19zdHlsZS1lcXVhbEAxLjAuMEBzdHlsZS1lcXVhbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvb3ZlcmxheS9tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9vdmVybGF5L3V0aWxzL3Bvc2l0aW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9vdmVybGF5L3BvcHVwLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvZHJvcGRvd24vaW5kZXguanN4Iiwid2VicGFjazovLy8uL3NyYy9tZW51L3ZpZXcvc3ViLW1lbnUuanN4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9fcmVhY3QtdHJhbnNpdGlvbi1ncm91cEAyLjUuMkByZWFjdC10cmFuc2l0aW9uLWdyb3VwL0NTU1RyYW5zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19kb20taGVscGVyc0AzLjQuMEBkb20taGVscGVycy9jbGFzcy9hZGRDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX0BiYWJlbF9ydW50aW1lQDcuMi4wQEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9fZG9tLWhlbHBlcnNAMy40LjBAZG9tLWhlbHBlcnMvY2xhc3MvaGFzQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19kb20taGVscGVyc0AzLjQuMEBkb20taGVscGVycy9jbGFzcy9yZW1vdmVDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3JlYWN0LXRyYW5zaXRpb24tZ3JvdXBAMi41LjJAcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9SZXBsYWNlVHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3JlYWN0LXRyYW5zaXRpb24tZ3JvdXBAMi41LjJAcmVhY3QtdHJhbnNpdGlvbi1ncm91cC91dGlscy9DaGlsZE1hcHBpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FuaW1hdGUvY2hpbGQuanN4Iiwid2VicGFjazovLy8uL3NyYy9hbmltYXRlL2V4cGFuZC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL21lbnUvdmlldy9jaGVja2JveC1pdGVtLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY2hlY2tib3gvY2hlY2tib3gtZ3JvdXAuanN4Iiwid2VicGFjazovLy8uL3NyYy9yYWRpby9yYWRpby1ncm91cC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL21lbnUvdmlldy9yYWRpby1pdGVtLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvbWVudS92aWV3L2dyb3VwLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvbWVudS92aWV3L2RpdmlkZXIuanN4Iiwid2VicGFjazovLy8uL3NyYy9tZW51L3ZpZXcvY3JlYXRlLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvYnV0dG9uL3ZpZXcvYnV0dG9uLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvYnV0dG9uL3ZpZXcvZ3JvdXAuanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS9iYXNlL3Jlc2l6ZS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2Jhc2Uvd3JhcHBlci5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2NvbHVtbi1ncm91cC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL3RyZWUuanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS90cmVlL3Jvdy5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL3RyZWUvY2VsbC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2ZpeGVkLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvc2VsZWN0aW9uLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvZXhwYW5kZWQuanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS92aXJ0dWFsLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvdmlydHVhbC9ib2R5LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvbG9jay5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2xvY2svYm9keS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2xvY2svaGVhZGVyLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvbGlzdC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2xpc3Qvcm93LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvbGlzdC9ib2R5LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvc3RpY2t5LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvc3RpY2t5L2hlYWRlci5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2FmZml4L2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvYWZmaXgvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ljb24vbWFpbi5zY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDAuMTguMkBzdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FuaW1hdGUvbWFpbi5zY3NzIiwid2VicGFjazovLy8uL3NyYy9jaGVja2JveC9tYWluLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JhZGlvL21haW4uc2NzcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWVudS9tYWluLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2J1dHRvbi9tYWluLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Ryb3Bkb3duL3N0eWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9vdmVybGF5L21haW4uc2NzcyIsIndlYnBhY2s6Ly8vLi9zcmMvZHJvcGRvd24vbWFpbi5zY3NzIiwid2VicGFjazovLy8uL3NyYy9sb2FkaW5nL21haW4uc2NzcyIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvbWFpbi5zY3NzIiwid2VicGFjazovLy8uL3NyYy9pbnB1dC9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhZy90YWcuanN4Iiwid2VicGFjazovLy8uL3NyYy9zZWxlY3QvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5wdXQvbWFpbi5zY3NzPzVkMTQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhZy9tYWluLnNjc3M/ODk4ZSIsIndlYnBhY2s6Ly8vLi9zcmMvc2VsZWN0L21haW4uc2Nzcz83NmNlIiwid2VicGFjazovLy8uL3NyYy9wYWdpbmF0aW9uL21haW4uc2Nzcz8wZmFkIiwid2VicGFjazovLy8uL2RvY3MvdGFibGUvZGVtby9wYWdpbmF0aW9uLm1kPzRmYjgiLCJ3ZWJwYWNrOi8vLy4vc3JjL2lucHV0L2Jhc2UuanN4Iiwid2VicGFjazovLy8uL3NyYy9pbnB1dC9ncm91cC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3NlbGVjdC9iYXNlLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvaW5wdXQvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vZG9jcy90YWJsZS9kZW1vL3BhZ2luYXRpb24ubWQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2luYXRpb24vaW5kZXguanN4Iiwid2VicGFjazovLy8uL3NyYy9wYWdpbmF0aW9uL3BhZ2luYXRpb24uanN4Iiwid2VicGFjazovLy8uL3NyYy9pbnB1dC9pbnB1dC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2lucHV0L3RleHRhcmVhLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvc2VsZWN0L2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvc2VsZWN0L3NlbGVjdC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhZy9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhZy90YWctZ3JvdXAuanN4Iiwid2VicGFjazovLy8uL3NyYy90YWcvc2VsZWN0YWJsZS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhZy9jbG9zZWFibGUuanN4Iiwid2VicGFjazovLy8uL3NyYy9zZWxlY3QvZGF0YS1zdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlydHVhbC1saXN0L2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdmlydHVhbC1saXN0L3ZpcnR1YWwtbGlzdC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3NlbGVjdC9hdXRvLWNvbXBsZXRlLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvc2VsZWN0L29wdGlvbi5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3NlbGVjdC9vcHRpb24tZ3JvdXAuanN4Iiwid2VicGFjazovLy8uL3NyYy9wYWdpbmF0aW9uL3N0eWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnB1dC9tYWluLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NlbGVjdC9zdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdGFnL3N0eWxlLmpzIiwid2VicGFjazovLy8uL3NyYy90YWcvbWFpbi5zY3NzIiwid2VicGFjazovLy8uL3NyYy9zZWxlY3QvbWFpbi5zY3NzIiwid2VicGFjazovLy8uL3NyYy9wYWdpbmF0aW9uL21haW4uc2NzcyIsIndlYnBhY2s6Ly8vLi9kb2NzL3RhYmxlL2RlbW8vcGFnaW5hdGlvbi5tZD8zYTFlIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlN5bWJvbCIsImZvciIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiJCR0eXBlb2YiLCJ0aHJvd09uRGlyZWN0QWNjZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiLCJfZG9tIiwiX2VudiIsIl9ldmVudHMiLCJfZnVuYyIsIl9sb2ciLCJfb2JqZWN0IiwiX3N0cmluZyIsIl9zdXBwb3J0IiwiX2ZvY3VzIiwiZG9tIiwiZXZlbnRzIiwiZnVuYyIsImxvZyIsIm9iaiIsInN0ciIsInN1cHBvcnQiLCJmb2N1cyIsImd1aWQiLCJfZ3VpZCIsIktFWUNPREUiLCJfS0VZQ09ERSIsImhhc093biIsImhhc093blByb3BlcnR5IiwiY2xhc3NOYW1lcyIsImNsYXNzZXMiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJnIiwiYXJnVHlwZSIsInB1c2giLCJBcnJheSIsImlzQXJyYXkiLCJpbm5lciIsImFwcGx5Iiwia2V5IiwiY2FsbCIsImpvaW4iLCJkZWZhdWx0IiwiZGVmaW5lIiwid2luZG93IiwiY2hpbGRDb250ZXh0Q2FjaGUiLCJDYWNoZSIsIkNvbmZpZ1Byb3ZpZGVyIiwiYXJncyIsImFkZCIsImdldCIsImdldENoaWxkQ29udGV4dCIsInByb3BzIiwicHJlZml4IiwibG9jYWxlIiwicHVyZSIsIndhcm5pbmciLCJydGwiLCJuZXh0UHJlZml4IiwibmV4dExvY2FsZSIsIm5leHRQdXJlIiwibmV4dFJ0bCIsIm5leHRXYXJuaW5nIiwiY29tcG9uZW50V2lsbE1vdW50Iiwic2V0TW9tZW50TG9jYWxlIiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIm5leHRQcm9wcyIsImNvbXBvbmVudERpZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVtb3ZlIiwibW9tZW50IiwiZSIsIm1vbWVudExvY2FsZSIsInJlbmRlciIsIkNoaWxkcmVuIiwib25seSIsImNoaWxkcmVuIiwiQ29tcG9uZW50IiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwic3RyaW5nIiwiYm9vbCIsImVsZW1lbnQiLCJkZWZhdWx0UHJvcHMiLCJjaGlsZENvbnRleHRUeXBlcyIsImNvbmZpZyIsIm9wdGlvbnMiLCJnZXRDb250ZXh0UHJvcHMiLCJkaXNwbGF5TmFtZSIsInJvb3QiLCJpbml0TG9jYWxlcyIsInNldExhbmd1YWdlIiwic2V0TG9jYWxlIiwic2V0RGlyZWN0aW9uIiwiZ2V0TGFuZ3VhZ2UiLCJnZXRMb2NhbGUiLCJnZXREaXJlY3Rpb24iLCJDb25zdW1lciIsImdldENvbnRleHQiLCJ1c2VTb3VyY2VNYXAiLCJsaXN0IiwidG9TdHJpbmciLCJtYXAiLCJpdGVtIiwiY29udGVudCIsImNzc1dpdGhNYXBwaW5nVG9TdHJpbmciLCJtb2R1bGVzIiwibWVkaWFRdWVyeSIsImFscmVhZHlJbXBvcnRlZE1vZHVsZXMiLCJpZCIsImNzc01hcHBpbmciLCJidG9hIiwic291cmNlTWFwcGluZyIsInRvQ29tbWVudCIsInNvdXJjZVVSTHMiLCJzb3VyY2VzIiwic291cmNlIiwic291cmNlUm9vdCIsImNvbmNhdCIsInNvdXJjZU1hcCIsImJhc2U2NCIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsImRhdGEiLCJibGFja0xpc3QiLCJzdGF0aWNzIiwiVGFyZ2V0IiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJpbmRleE9mIiwicHJvcGVydHkiLCJmZXRjaERhdGFCeVBhdGgiLCJwYXRoIiwiZmllbGQiLCJzcGxpdCIsInZhbCIsIm1hdGNoIiwiY29sSW5kZXgiLCJJY29uIiwidHlwZSIsInNpemUiLCJjbGFzc05hbWUiLCJvdGhlciIsImRpciIsIm9uZU9mIiwiX3R5cGVNYXJrIiwidHlwZU9mIiwiaXNBcnJheUxpa2UiLCJpc1Byb21pc2UiLCJpc1BsYWluT2JqZWN0Iiwic2hhbGxvd0VxdWFsIiwiZWFjaCIsInBpY2tPdGhlcnMiLCJwaWNrQXR0cnNXaXRoIiwicHJvdG90eXBlIiwicmVwbGFjZSIsInRoZW4iLCJjdG9yIiwiY29uc3RydWN0b3IiLCJwcm90Iiwib2JqQSIsIm9iakIiLCJjb21wYXJlIiwia2V5QSIsImtleUIiLCJsZW4iLCJoYXNDYWxsYmFjayIsInZhbEEiLCJ2YWxCIiwicmV0IiwiY2FsbGJhY2siLCJkaXJlY3Rpb24iLCJyZXZlcnNlZCIsInZhbHVlIiwiX2lzSW5PYmoiLCJob2xkUHJvcHMiLCJvdGhlcnMiLCJiaW5kQ3R4IiwiSXRlbSIsImNvbXBvbmVudERpZE1vdW50IiwiaXRlbU5vZGUiLCJwYXJlbnRNb2RlIiwibWVudU5vZGUiLCJwYXJlbnROb2RlIiwiaGVhZGVyIiwiZm9vdGVyIiwicXVlcnlTZWxlY3RvciIsInNldEZvY3VzIiwiZm9jdXNhYmxlIiwiZGlzYWJsZWQiLCJnZXRGb2N1c2VkIiwiX2tleSIsImZvY3VzZWRLZXkiLCJzdGF0ZSIsImZvY3VzZWQiLCJwcmV2ZW50U2Nyb2xsIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsQm90dG9tIiwic2Nyb2xsVG9wIiwiaXRlbUJvdHRvbSIsIm9mZnNldFRvcCIsIm9mZnNldEhlaWdodCIsImhhbmRsZUNsaWNrIiwic3RvcFByb3BhZ2F0aW9uIiwiaGFuZGxlSXRlbUNsaWNrIiwib25DbGljayIsInByZXZlbnREZWZhdWx0IiwiaGFuZGxlS2V5RG93biIsImhhbmRsZUl0ZW1LZXlEb3duIiwib25LZXlEb3duIiwiZ2V0VGl0bGUiLCJsYWJlbFN0cmluZyIsImxvb3AiLCJjaGlsZCIsImxldmVsIiwicmVwbGFjZUNsYXNzTmFtZSIsImdyb3VwSW5kZW50IiwiY29tcG9uZW50IiwibmVlZEluZGVudCIsImlubGluZUluZGVudCIsIml0ZW1DbGFzc05hbWUiLCJuZXdDbGFzc05hbWUiLCJ0YWJJbmRleCIsInRhYmJhYmxlS2V5Iiwic3R5bGUiLCJUYWdOYW1lIiwibnVtYmVyIiwicGFyZW50IiwiT3ZlcmxheSIsIkdhdGV3YXkiLCJQb3NpdGlvbiIsIlBvcHVwIiwiZXhwb3J0TmFtZXMiLCJub29wIiwiQm9keSIsImdldFJvd1JlZiIsInJvdyIsInJvd1JlZiIsIm9uUm93Q2xpY2siLCJyZWNvcmQiLCJpbmRleCIsIm9uUm93TW91c2VFbnRlciIsIm9uUm93TW91c2VMZWF2ZSIsIlRhZyIsImNvbEdyb3VwIiwibG9hZGluZyIsImVtcHR5Q29udGVudCIsImNvbXBvbmVudHMiLCJnZXRDZWxsUHJvcHMiLCJwcmltYXJ5S2V5IiwiZ2V0Um93UHJvcHMiLCJkYXRhU291cmNlIiwiY2VsbFJlZiIsImNvbHVtbnMiLCJSb3ciLCJSb3dDb21wb25lbnQiLCJDZWxsIiwiQ2VsbENvbXBvbmVudCIsImVtcHR5Iiwicm93cyIsInJvd1Byb3BzIiwicm93Q2xhc3MiLCJmaXJzdCIsImxhc3QiLCJleHBhbmRlZCIsIl9fZXhwYW5kZWQiLCJiaW5kIiwiUmVhY3QiLCJhbnkiLCJhcnJheSIsInJvd0luZGV4Iiwib25Nb3VzZUVudGVyIiwib25Sb3dIb3ZlciIsIm9uTW91c2VMZWF2ZSIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsImlzRXF1YWwiLCJpc0VudGVyIiwiY3VycmVudFJvdyIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJyZW5kZXJDZWxscyIsImxvY2tUeXBlIiwiY29udGV4dCIsImRhdGFJbmRleCIsImFsaWduIiwid2lkdGgiLCJhdHRycyIsIm5vdFJlbmRlckNlbGxJbmRleCIsIm1hdGNoQ2VsbEluZGV4IiwiY2VsbEluZGV4Iiwic3BsaWNlIiwiY29sU3BhbiIsInJvd1NwYW4iLCJfZ2V0Tm90UmVuZGVyQ2VsbEluZGV4IiwiY2VsbCIsIm1heENvbEluZGV4IiwibWF4Um93SW5kZXgiLCJqIiwiY2xzIiwiY29udGV4dFR5cGVzIiwicmVzaXphYmxlIiwidGl0bGUiLCJpbm5lclN0eWxlIiwiX19ub3JtYWxpemVkIiwiZmlsdGVyTW9kZSIsImZpbHRlcnMiLCJzb3J0YWJsZSIsImxvY2siLCJ0YWdTdHlsZSIsImNlbGxQcm9wcyIsImNsb25lRWxlbWVudCIsInRleHRBbGlnbiIsIm9uZU9mVHlwZSIsIm5vZGUiLCJGaXhlZEhlYWRlciIsImdldE5vZGUiLCJSZWFjdFByb3BUeXBlc1NlY3JldCIsImZpbmROb2RlIiwidGFyZ2V0IiwicGFyYW0iLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiZXJyIiwiU2VsZWN0YWJsZUl0ZW0iLCJnZXRTZWxlY3RlZCIsInNlbGVjdGVkIiwic2VsZWN0TW9kZSIsInNlbGVjdGVkS2V5cyIsImhhbmRsZVNlbGVjdCIsIm9uU2VsZWN0Iiwia2V5Q29kZSIsIlNQQUNFIiwicmVuZGVyU2VsZWN0ZWRJY29uIiwiaGFzU2VsZWN0ZWRJY29uIiwicm9vdFNlbGVjdGVkSWNvbiIsImxlZnQiLCJoZWxwZXIiLCJuZXdQcm9wcyIsIm1lbnVDaGlsZFR5cGUiLCJDb2x1bW4iLCJhcnJheU9mIiwic2hhcGUiLCJsYWJlbCIsIkZpeGVkV3JhcHBlciIsIndyYXBwZXJDb250ZW50IiwiVGltZWxpbmUiLCJleHBhbmQiLCJmb2xkIiwiQ2FyZCIsIkNhbGVuZGFyIiwidG9kYXkiLCJub3ciLCJvayIsImNsZWFyIiwibW9udGgiLCJ5ZWFyIiwicHJldlllYXIiLCJuZXh0WWVhciIsInByZXZNb250aCIsIm5leHRNb250aCIsInByZXZEZWNhZGUiLCJuZXh0RGVjYWRlIiwiRGF0ZVBpY2tlciIsInBsYWNlaG9sZGVyIiwiZGF0ZXRpbWVQbGFjZWhvbGRlciIsIm1vbnRoUGxhY2Vob2xkZXIiLCJ5ZWFyUGxhY2Vob2xkZXIiLCJzZWxlY3RUaW1lIiwic2VsZWN0RGF0ZSIsInN0YXJ0UGxhY2Vob2xkZXIiLCJlbmRQbGFjZWhvbGRlciIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJEaWFsb2ciLCJjYW5jZWwiLCJQYWdpbmF0aW9uIiwicHJldiIsIm5leHQiLCJnb1RvIiwicGFnZSIsImdvIiwicGFnZVNpemUiLCJJbnB1dCIsIlNlbGVjdCIsInNlbGVjdFBsYWNlaG9sZGVyIiwiYXV0b0NvbXBsZXRlUGxhY2Vob2xkZXIiLCJub3RGb3VuZENvbnRlbnQiLCJUYWJsZSIsInJlc2V0IiwiYXNjIiwiZGVzYyIsImZvbGRlZCIsImZpbHRlciIsInNlbGVjdEFsbCIsIlRpbWVQaWNrZXIiLCJUcmFuc2ZlciIsIml0ZW1zIiwibW92ZUFsbCIsInNlYXJjaFBsYWNlaG9sZGVyIiwiVXBsb2FkIiwiY2FyZCIsImFkZFBob3RvIiwiZHJhZyIsInRleHQiLCJoaW50IiwiU2VhcmNoIiwiYnV0dG9uVGV4dCIsIkNoZWNrYm94IiwiR3JvdXAiLCJuZXdQcmVmaXgiLCJsb2NhbGVGcm9tQ29udGV4dCIsIm5ld0xvY2FsZSIsIm5ld1B1cmUiLCJuZXdSdGwiLCJoYXNDbGFzcyIsInRvZ2dsZUNsYXNzIiwiZ2V0U3R5bGUiLCJzZXRTdHlsZSIsInNjcm9sbGJhciIsImdldE9mZnNldCIsImhhc0RPTSIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsIl9mb3JjZSIsInRyaW0iLCJ0b2dnbGUiLCJmbGFnIiwibWF0Y2hlcyIsIm1hdGNoZXNGbiIsIl9ib2R5IiwiYm9keSIsImhlYWQiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsIm1vek1hdGNoZXNTZWxlY3RvciIsInNlbGVjdG9yIiwiX2dldENvbXB1dGVkU3R5bGUiLCJub2RlVHlwZSIsImdldENvbXB1dGVkU3R5bGUiLCJQSVhFTF9QQVRURVJOIiwicmVtb3ZlUGl4ZWwiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsIl9nZXRTdHlsZVZhbHVlIiwidG9Mb3dlckNhc2UiLCJvZmZzZXRXaWR0aCIsInRlc3QiLCJwYXJzZUZsb2F0IiwiZmxvYXRNYXAiLCJjc3NGbG9hdCIsInN0eWxlRmxvYXQiLCJmbG9hdCIsIm5hbWUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwic2Nyb2xsRGl2IiwicG9zaXRpb24iLCJoZWlnaHQiLCJvdmVyZmxvdyIsImFwcGVuZENoaWxkIiwic2Nyb2xsYmFyV2lkdGgiLCJjbGllbnRXaWR0aCIsInNjcm9sbGJhckhlaWdodCIsInJlbW92ZUNoaWxkIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndpbiIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsInBhZ2VZT2Zmc2V0IiwicGFnZVhPZmZzZXQiLCJjYW1lbGNhc2UiLCJoeXBoZW5hdGUiLCIkMCIsIiQxIiwidG9VcHBlckNhc2UiLCJpZVZlcnNpb24iLCJkb2N1bWVudE1vZGUiLCJ1bmRlZmluZWQiLCJpc1Byb2R1Y3Rpb24iLCJQUk9EVUNUSU9OX0VOViIsInJlc3VsdCIsIkJBQ0tTUEFDRSIsIlRBQiIsIkVOVEVSIiwiU0hJRlQiLCJDVFJMIiwiQUxUIiwiRVNDIiwiRU5EIiwiSE9NRSIsIkxFRlQiLCJVUCIsIlJJR0hUIiwiRE9XTiIsIkVTQ0FQRSIsIkxFRlRfQVJST1ciLCJVUF9BUlJPVyIsIlJJR0hUX0FSUk9XIiwiRE9XTl9BUlJPVyIsIkNPTlRST0wiLCJPUFRJT04iLCJDTUQiLCJDT01NQU5EIiwiREVMRVRFIiwic3R5bGVFcXVhbCIsImEiLCJlbGVtZW50RXF1YWxzIiwiYiIsInR5cGVPZkEiLCJ0eXBlT2ZCIiwicmVmIiwic2hhbGxvd0VsZW1lbnRFcXVhbHMiLCJhQ291bnQiLCJiQ291bnQiLCJzYXZlTGFzdEZvY3VzTm9kZSIsImdldEZvY3VzTm9kZUxpc3QiLCJiYWNrTGFzdEZvY3VzTm9kZSIsIm1ha2VDaGFpbiIsImlzU2Nyb2xsRGlzcGxheSIsInNjcm9sbGJhclN0eWxlIiwiaGFzU2Nyb2xsIiwiZG9jIiwiZG9jdW1lbnRFbGVtZW50IiwicHJlZml4ZXMiLCJnZXRTdHlsZVByb3BlcnR5IiwibW9kYWxzIiwiYm9keU92ZXJmbG93WSIsImJvZHlQYWRkaW5nUmlnaHQiLCJzYXZlQ29udGVudFJlZiIsImNvbnRlbnRSZWYiLCJzYXZlR2F0ZXdheVJlZiIsImdhdGV3YXlSZWYiLCJ2aXNpYmxlIiwic3RhdHVzIiwiYW5pbWF0aW9uIiwiZ2V0QW5pbWF0aW9uIiwibGFzdEFsaWduIiwidGltZW91dE1hcCIsImJlZm9yZU9wZW4iLCJlbnRlciIsImFkZERvY3VtZW50RXZlbnRzIiwib3ZlcmxheU1hbmFnZXIiLCJhZGRPdmVybGF5IiwiX2lzTW91bnRlZCIsIndpbGxPcGVuIiwid2lsbENsb3NlIiwiYmVmb3JlQ2xvc2UiLCJzZXRTdGF0ZSIsImxlYXZlIiwicHJldlByb3BzIiwib3BlbiIsImNsb3NlIiwiYWRkQW5pbWF0aW9uRXZlbnRzIiwid3JhcHBlck5vZGUiLCJnZXRXcmFwcGVyTm9kZSIsInNldFRpbWVvdXQiLCJvbk9wZW4iLCJhZnRlck9wZW4iLCJvbkNsb3NlIiwiYWZ0ZXJDbG9zZSIsInJlbW92ZU92ZXJsYXkiLCJzZXRGb2N1c05vZGUiLCJfaXNEZXN0cm95ZWQiLCJyZW1vdmVEb2N1bWVudEV2ZW50cyIsImZvY3VzVGltZW91dCIsImNsZWFyVGltZW91dCIsIl9hbmltYXRpb24iLCJvZmYiLCJnZXRBbmltYXRpb25CeUFsaWduIiwiaW4iLCJvdXQiLCJnZXRDb250ZW50Tm9kZSIsIm9uIiwiZW5kIiwiaGFuZGxlQW5pbWF0ZUVuZCIsImFuaW1hdGlvbkRlbGF5IiwiYW5pbWF0aW9uRHVyYXRpb24iLCJ0aW1lIiwiaGFuZGxlUG9zaXRpb24iLCJuZWVkQWRqdXN0Iiwib25MZWF2ZWQiLCJvbkVudGVyZWQiLCJvbkVudGVyaW5nIiwib25MZWF2aW5nIiwiZGlzYWJsZVNjcm9sbCIsIm92ZXJmbG93WSIsInBhZGRpbmdSaWdodCIsImF1dG9Gb2N1cyIsIl9oYXNGb2N1c2VkIiwiZm9jdXNOb2RlTGlzdCIsImdldENvbnRlbnQiLCJnZXRDaGlsZE5vZGUiLCJjYW5DbG9zZUJ5RXNjIiwiX2tleWRvd25FdmVudHMiLCJoYW5kbGVEb2N1bWVudEtleURvd24iLCJjYW5DbG9zZUJ5T3V0U2lkZUNsaWNrIiwiX2NsaWNrRXZlbnRzIiwiaGFuZGxlRG9jdW1lbnRDbGljayIsImlzQ3VycmVudE92ZXJsYXkiLCJvblJlcXVlc3RDbG9zZSIsInNhZmVOb2RlIiwic2FmZU5vZGVzIiwidW5zaGlmdCIsImhhbmRsZU1hc2tDbGljayIsImNhbkNsb3NlQnlNYXNrIiwiZ2V0SW5zdGFuY2UiLCJwcm9wQ2hpbGRyZW4iLCJvZmZzZXQiLCJjb250YWluZXIiLCJoYXNNYXNrIiwiYmVmb3JlUG9zaXRpb24iLCJvblBvc2l0aW9uIiwid3JhcHBlclN0eWxlIiwicHJvcFNob3VsZFVwZGF0ZVBvc2l0aW9uIiwic2hvdWxkVXBkYXRlUG9zaXRpb24iLCJjYWNoZSIsIndyYXBwZXJDbGFzc05hbWUiLCJvbk1hc2tNb3VzZUVudGVyIiwib25NYXNrTW91c2VMZWF2ZSIsInN0YXRlVmlzaWJsZSIsImNoaWxkQ2xhenoiLCJFcnJvciIsIndyYXBwZXJDbGF6eiIsIm5ld1dyYXBwZXJTdHlsZSIsImRpc3BsYXkiLCJWSUVXUE9SVCIsInNhdmVDaGlsZFJlZiIsImNvbnRhaW5lck5vZGUiLCJnZXRDb250YWluZXJOb2RlIiwiZm9yY2VVcGRhdGUiLCJ0YXJnZXROb2RlIiwicGxhY2UiLCJzZXRQb3NpdGlvbiIsIm5lZWRMaXN0ZW5SZXNpemUiLCJoYW5kbGVSZXNpemUiLCJyZXNpemVUaW1lb3V0IiwiY29udGVudE5vZGUiLCJnZXRUYXJnZXROb2RlIiwicmVzdWx0QWxpZ24iLCJwaW5FbGVtZW50IiwiYmFzZUVsZW1lbnQiLCJpc1J0bCIsIkhlYWRlciIsImdldENlbGxSZWYiLCJoZWFkZXJDZWxsUmVmIiwib25Tb3J0Iiwib3JkZXIiLCJzb3J0IiwiZmlsdGVyUGFyYW1zIiwib25GaWx0ZXIiLCJhZmZpeFJlZiIsIm9uUmVzaXplQ2hhbmdlIiwiRmlsdGVyIiwiRmlsdGVyQ29tcG9uZW50IiwiU29ydCIsIlNvcnRDb21wb25lbnQiLCJSZXNpemUiLCJSZXNpemVDb21wb25lbnQiLCJjb2xzIiwiY29sIiwic29ydEVsZW1lbnQiLCJmaWx0ZXJFbGVtZW50IiwicmVzaXplRWxlbWVudCIsImZpbHRlckNvbmZpZyIsIl9zZWxlY3RlZEtleXMiLCJyZW5kZXJNZW51SXRlbSIsInJlbmRlclN1Yk1lbnUiLCJyZW5kZXJNZW51Q29udGVudCIsIm9uRmlsdGVyQ29uZmlybSIsIm9uRmlsdGVyQ2xlYXIiLCJmaWx0ZXJLZXlkb3duIiwib25GaWx0ZXJWaXNpYmxlIiwib25GaWx0ZXJTZWxlY3QiLCJNZW51IiwiZGVmYXVsdFNlbGVjdGVkS2V5cyIsIm5ld0NoaWxkcmVuIiwiZ2V0TmV3Q2hpbGRyZW4iLCJnZXRGaXJzdEF2YWxpYWJsZWxDaGlsZEtleSIsIm9wZW5LZXlzIiwiZ2V0SW5pdE9wZW5LZXlzIiwibm9ybWFsaXplVG9BcnJheSIsInBvcHVwTm9kZXMiLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiazJuIiwib25CbHVyIiwiaW5pdE9wZW5LZXlzIiwiZGVmYXVsdE9wZW5LZXlzIiwiZGVmYXVsdE9wZW5BbGwiLCJtb2RlIiwib3Blbk1vZGUiLCJwMm4iLCJwb3NQcmVmaXgiLCJpbmRleFdyYXBwZXIiLCJuZXdDaGlsZCIsInBvcyIsImlzU2libGluZyIsImN1cnJlbnRQb3MiLCJ0YXJnZXRQb3MiLCJjdXJyZW50TnVtcyIsInNsaWNlIiwidGFyZ2V0TnVtcyIsImV2ZXJ5IiwibnVtIiwiaXNBbmNlc3RvciIsImhhbmRsZU9wZW4iLCJ0cmlnZ2VyVHlwZSIsIm5ld09wZW5LZXlzIiwiayIsInNvbWUiLCJnZXRQYXRoIiwia2V5UGF0aCIsImxhYmVsUGF0aCIsIm51bXMiLCJwYXJlbnROdW1zIiwicGFyZW50UG9zIiwic2VsZWN0IiwibWVudUl0ZW0iLCJzaGFsbG93U2VsZWN0IiwibmV3U2VsZWN0ZWRLZXlzIiwib25JdGVtRm9jdXMiLCJwcmV2S2V5IiwibmV4dEtleSIsIm9uSXRlbUNsaWNrIiwiaXNBdmFpbGFibGVQb3MiLCJyZWZQb3MiLCJnZXRBdmFpbGFibGVLZXkiLCJwcyIsInAiLCJ0YXJnZXRJbmRleCIsImZpbmQiLCJnZXRQYXJlbnRLZXkiLCJhdmFsaWFibGVLZXkiLCJwYXJlbnRLZXkiLCJvbkl0ZW1LZXlEb3duIiwiaG96QWxpZ24iLCJyb2xlIiwiaGVhZGVyRWxlbWVudCIsIml0ZW1zRWxlbWVudCIsImZvb3RlckVsZW1lbnQiLCJzaG91bGRXcmFwSXRlbXNBbmRGb290ZXIiLCJoYW5kbGVFbnRlciIsImlzTmV4dE1lbnUiLCJpbmxpbmVBcnJvd0RpcmVjdGlvbiIsInBvcHVwQXV0b1dpZHRoIiwicG9wdXBBbGlnbiIsInBvcHVwUHJvcHMiLCJwb3B1cENsYXNzTmFtZSIsInBvcHVwU3R5bGUiLCJsYWJlbFRvZ2dsZUNoZWNrZWQiLCJleHBhbmRBbmltYXRpb24iLCJGaXJzdENoaWxkIiwiY2hpbGRyZW5BcnJheSIsInRvQXJyYXkiLCJBbmltYXRlIiwibm9ybWFsaXplTmFtZXMiLCJuYW1lcyIsImFwcGVhciIsImFwcGVhckFjdGl2ZSIsImVudGVyQWN0aXZlIiwibGVhdmVBY3RpdmUiLCJhbmltYXRpb25BcHBlYXIiLCJzaW5nbGVNb2RlIiwiYmVmb3JlQXBwZWFyIiwib25BcHBlYXIiLCJhZnRlckFwcGVhciIsImJlZm9yZUVudGVyIiwib25FbnRlciIsImFmdGVyRW50ZXIiLCJiZWZvcmVMZWF2ZSIsIm9uTGVhdmUiLCJhZnRlckxlYXZlIiwiYW5pbWF0ZUNoaWxkcmVuIiwiX0NTU1RyYW5zaXRpb24iLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX1JlcGxhY2VUcmFuc2l0aW9uIiwiX1RyYW5zaXRpb25Hcm91cCIsIl9UcmFuc2l0aW9uIiwiX19lc01vZHVsZSIsIlRyYW5zaXRpb24iLCJUcmFuc2l0aW9uR3JvdXAiLCJSZXBsYWNlVHJhbnNpdGlvbiIsIkNTU1RyYW5zaXRpb24iLCJFWElUSU5HIiwiRU5URVJFRCIsIkVOVEVSSU5HIiwiRVhJVEVEIiwiVU5NT1VOVEVEIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfcmVhY3QiLCJfcmVhY3REb20iLCJfcmVhY3RMaWZlY3ljbGVzQ29tcGF0IiwiX1Byb3BUeXBlcyIsIm5ld09iaiIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwic2V0IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJleGNsdWRlZCIsInNvdXJjZUtleXMiLCJfaW5oZXJpdHNMb29zZSIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9SZWFjdCRDb21wb25lbnQiLCJfdGhpcyIsInBhcmVudEdyb3VwIiwidHJhbnNpdGlvbkdyb3VwIiwiaXNNb3VudGluZyIsImluaXRpYWxTdGF0dXMiLCJhcHBlYXJTdGF0dXMiLCJ1bm1vdW50T25FeGl0IiwibW91bnRPbkVudGVyIiwibmV4dENhbGxiYWNrIiwiX3Byb3RvIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiX3JlZiIsInByZXZTdGF0ZSIsIm5leHRJbiIsInVwZGF0ZVN0YXR1cyIsIm5leHRTdGF0dXMiLCJjYW5jZWxOZXh0Q2FsbGJhY2siLCJnZXRUaW1lb3V0cyIsInRpbWVvdXQiLCJleGl0IiwibW91bnRpbmciLCJmaW5kRE9NTm9kZSIsInBlcmZvcm1FbnRlciIsInBlcmZvcm1FeGl0IiwiX3RoaXMyIiwiYXBwZWFyaW5nIiwidGltZW91dHMiLCJzYWZlU2V0U3RhdGUiLCJvblRyYW5zaXRpb25FbmQiLCJfdGhpczMiLCJvbkV4aXRlZCIsIm9uRXhpdCIsIm9uRXhpdGluZyIsIm5leHRTdGF0ZSIsInNldE5leHRDYWxsYmFjayIsIl90aGlzNCIsImFjdGl2ZSIsImV2ZW50IiwiaGFuZGxlciIsImFkZEVuZExpc3RlbmVyIiwiX3RoaXMkcHJvcHMiLCJjaGlsZFByb3BzIiwiaXNSZXF1aXJlZCIsInB0IiwidGltZW91dHNTaGFwZSIsIl9sZW4iLCJfZGVmYXVsdCIsInBvbHlmaWxsIiwidXBkYXRlciIsIl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90RmxhZyIsIl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90IiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJfX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nIiwiaXNSZWFjdENvbXBvbmVudCIsImZvdW5kV2lsbE1vdW50TmFtZSIsImZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUiLCJmb3VuZFdpbGxVcGRhdGVOYW1lIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUiLCJjb21wb25lbnROYW1lIiwibmV3QXBpTmFtZSIsImNvbXBvbmVudERpZFVwZGF0ZVBvbHlmaWxsIiwibWF5YmVTbmFwc2hvdCIsInNuYXBzaG90IiwidHJhbnNpdGlvblRpbWVvdXQiLCJjbGFzc05hbWVzU2hhcGUiLCJfcHJvcFR5cGVzIiwidHJhbnNpdGlvblR5cGUiLCJ0aW1lb3V0UHJvcE5hbWUiLCJlbmFibGVkUHJvcE5hbWUiLCJlbnRlckRvbmUiLCJleGl0RG9uZSIsImV4aXRBY3RpdmUiLCJfQ2hpbGRNYXBwaW5nIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwic2VsZiIsIlJlZmVyZW5jZUVycm9yIiwidmFsdWVzIiwiY2hpbGRGYWN0b3J5IiwiaGFuZGxlRXhpdGVkIiwiZmlyc3RSZW5kZXIiLCJhcHBlYXJlZCIsIm1vdW50ZWQiLCJwcmV2Q2hpbGRNYXBwaW5nIiwiZ2V0SW5pdGlhbENoaWxkTWFwcGluZyIsImdldE5leHRDaGlsZE1hcHBpbmciLCJjdXJyZW50Q2hpbGRNYXBwaW5nIiwiZ2V0Q2hpbGRNYXBwaW5nIiwiUG9wdXBJdGVtIiwiZ2V0UG9wdXAiLCJwb3B1cCIsImdldE9wZW4iLCJnZXRQb3B1cFByb3BzIiwib25WaXNpYmxlQ2hhbmdlIiwiaGFuZGxlUG9wdXBPcGVuIiwiYXV0b1dpZHRoIiwicm9vdFBvcHVwQXV0b1dpZHRoIiwicm9vdFBvcHVwQWxpZ24iLCJwb3B1cE5vZGUiLCJvdmVybGF5IiwiaGFuZGxlUG9wdXBDbG9zZSIsInJlbmRlckl0ZW0iLCJzZWxlY3RhYmxlIiwiTmV3SXRlbSIsIml0ZW1Qcm9wcyIsInJlbmRlclBvcHVwIiwidHJpZ2dlciIsInBvc2l0aW9uUHJvcHMiLCJoYXNTdWJNZW51Iiwic2VsZWN0YWJsZUZyb21Qcm9wcyIsInJvb3RUcmlnZ2VyVHlwZSIsIm5ld1RyaWdnZXJUeXBlIiwidHJpZ2dlcklzSWNvbiIsImFycm93UHJvcHMiLCJhcnJvdyIsIkNoZWNrYWJsZUl0ZW0iLCJoYW5kbGVDaGVjayIsImNoZWNrVHlwZSIsImNoZWNrZWQiLCJvbkNoYW5nZSIsImNoZWNrRGlzYWJsZWQiLCJyZW5kZXJDaGVjayIsImluZGV0ZXJtaW5hdGUiLCJDaGVjayIsIlJhZGlvIiwiY2hlY2tQcm9wcyIsImlzQ2hlY2tlZCIsInNlbGVjdGVkVmFsdWUiLCJfX2dyb3VwX18iLCJkZWZhdWx0Q2hlY2tlZCIsImRlZmF1bHRJbmRldGVybWluYXRlIiwibmV4dENvbnRleHQiLCJvdGhlclByb3BzIiwib3RoZXJzRGF0YSIsImNoaWxkSW5wdXQiLCJnZXRTdGF0ZUVsZW1lbnQiLCJnZXRTdGF0ZUNsYXNzTmFtZSIsImxhYmVsQ2xzIiwiVUlTdGF0ZSIsImJhc2UiLCJvbkZvY3VzIiwiX29uVUlGb2N1cyIsIl9vblVJQmx1ciIsInJlc2V0VUlTdGF0ZSIsIlJhZGlvR3JvdXAiLCJpc0J1dHRvbiIsImlucHV0IiwiY2xzSW5uZXIiLCJwcmVzcyIsInVucHJlc3MiLCJjbHNXcmFwcGVyIiwiY2hpbGRyZW5DbHMiLCJyYWRpb0NvbXAiLCJfb25VSU1vdXNlRW50ZXIiLCJfb25VSU1vdXNlTGVhdmUiLCJkIiwia2V5ZG93bkhhbmRsZXIiLCJyZW5kZXJTb3J0Iiwic29ydFN0YXR1cyIsImljb25zIiwic29ydE9yZGVyIiwiU2VsZWN0aW9uUm93Iiwic2VsZWN0ZWRSb3dLZXlzIiwiRXhwYW5kZWRSb3ciLCJyZW5kZXJFeHBhbmRlZFJvdyIsImV4cGFuZGVkUm93UmVuZGVyIiwiZXhwYW5kZWRSb3dJbmRlbnQiLCJvcGVuUm93S2V5cyIsImxlZnRJbmRlbnQiLCJyaWdodEluZGVudCIsInRvdGFsSW5kZW50IiwicmVuZGVyQ29scyIsIkxvY2tSb3ciLCJGaXhlZEJvZHkiLCJvbkJvZHlTY3JvbGwiLCJvblNjcm9sbCIsIm1heEJvZHlIZWlnaHQiLCJmaXhlZEhlYWRlciIsIm1heEhlaWdodCIsIkxpc3RIZWFkZXIiLCJoYXNDaGlsZHJlblNlbGVjdGlvbiIsImhhc1NlbGVjdGlvbiIsIkxpc3RGb290ZXIiLCJCdXR0b24iLCJCdXR0b25Hcm91cCIsInRyYW5zZm9ybSIsImRlcHJlY2F0ZWQiLCJuZXdUeXBlIiwiZ2hvc3QiLCJwcmltYXJ5Iiwic2Vjb25kYXJ5Iiwibm9ybWFsIiwiZGFyayIsImxpZ2h0IiwiRXhwYW5kIiwiTG9hZGluZyIsInRpcCIsImluZGljYXRvciIsImNvbG9yIiwiZnVsbFNjcmVlbiIsInRpcEFsaWduIiwiaW5kaWNhdG9yRG9tIiwiZG90Q2xzIiwiYmFja2dyb3VuZENvbG9yIiwiZnVzaW9uUmVhY3RvckNscyIsImxvYWRpbmdDbHMiLCJ0aXBDbHMiLCJjb250ZW50Q2xzIiwiYW5pbWF0ZSIsIlN1Yk1lbnUiLCJDaGVja2JveEl0ZW0iLCJSYWRpb0l0ZW0iLCJEaXZpZGVyIiwiaW5kZW50U2l6ZSIsIm9uRGVzZWxlY3QiLCJuZXdPblNlbGVjdCIsImV4dHJhIiwiT1JERVJfTElTVCIsImZpeGVkIiwic2VsZWN0aW9uIiwidHJlZSIsInZpcnR1YWwiLCJzdGlja3kiLCJyZWR1Y2UiLCJjdXJyZW50IiwiQmFzZSIsIkdyb3VwSGVhZGVyIiwiR3JvdXBGb290ZXIiLCJleHBhbmRlZFJvd0tleXMiLCJvbkV4cGFuZGVkQ2hhbmdlIiwib25Sb3dPcGVuIiwiaXNMb2FkaW5nIiwiaW5kZW50Iiwib3B0aW1pemF0aW9uIiwiZ2V0Um93Q2xhc3NOYW1lIiwibmV3R2V0Um93UHJvcHMiLCJjaGVja1Byb3BUeXBlcyIsInByaW50V2FybmluZyIsIm1lc3NhZ2UiLCJjb25zb2xlIiwiZXJyb3IiLCJ4IiwiZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCIsIklURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIml0ZXJhdG9yRm4iLCJBTk9OWU1PVVMiLCJSZWFjdFByb3BUeXBlcyIsImNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyIiwic3ltYm9sIiwiY3JlYXRlQW55VHlwZUNoZWNrZXIiLCJjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIiLCJjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIiLCJpbnN0YW5jZU9mIiwiY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlciIsImNyZWF0ZU5vZGVDaGVja2VyIiwib2JqZWN0T2YiLCJjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyIiwiY3JlYXRlRW51bVR5cGVDaGVja2VyIiwiY3JlYXRlVW5pb25UeXBlQ2hlY2tlciIsImNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIiLCJleGFjdCIsImNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIiLCJpcyIsInkiLCJQcm9wVHlwZUVycm9yIiwic3RhY2siLCJjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlciIsInZhbGlkYXRlIiwibWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUiLCJtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCIsInByb3BOYW1lIiwibG9jYXRpb24iLCJwcm9wRnVsbE5hbWUiLCJzZWNyZXQiLCJjYWNoZUtleSIsImNoYWluZWRDaGVja1R5cGUiLCJleHBlY3RlZFR5cGUiLCJwcm9wVmFsdWUiLCJwcm9wVHlwZSIsImdldFByb3BUeXBlIiwicHJlY2lzZVR5cGUiLCJnZXRQcmVjaXNlVHlwZSIsInR5cGVDaGVja2VyIiwiZXhwZWN0ZWRDbGFzcyIsImV4cGVjdGVkQ2xhc3NOYW1lIiwiYWN0dWFsQ2xhc3NOYW1lIiwiZ2V0Q2xhc3NOYW1lIiwiZXhwZWN0ZWRWYWx1ZXMiLCJ2YWx1ZXNTdHJpbmciLCJhcnJheU9mVHlwZUNoZWNrZXJzIiwiY2hlY2tlciIsImdldFBvc3RmaXhGb3JUeXBlV2FybmluZyIsImlzTm9kZSIsInNoYXBlVHlwZXMiLCJhbGxLZXlzIiwic3RlcCIsImVudHJpZXMiLCJkb25lIiwiZW50cnkiLCJpc1N5bWJvbCIsIlJlZ0V4cCIsIkRhdGUiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJwcm9wSXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJ0b09iamVjdCIsIlR5cGVFcnJvciIsInNob3VsZFVzZU5hdGl2ZSIsInRlc3QxIiwiU3RyaW5nIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInRlc3QyIiwiZnJvbUNoYXJDb2RlIiwib3JkZXIyIiwibiIsInRlc3QzIiwibGV0dGVyIiwiZnJvbSIsInRvIiwic3ltYm9scyIsInMiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJ0eXBlU3BlY3MiLCJnZXRTdGFjayIsInR5cGVTcGVjTmFtZSIsImV4IiwiZW1wdHlGdW5jdGlvbiIsInNoaW0iLCJnZXRTaGltIiwiZ2V0RGlzcGxheU5hbWUiLCJnbG9iYWxMb2NhbGVzIiwiY3VycmVudEdsb2JhbExhbmd1YWdlIiwiY3VycmVudEdsb2JhbExvY2FsZSIsImN1cnJlbnRHbG9iYWxSdGwiLCJsb2NhbGVzIiwibGFuZ3VhZ2UiLCJDb25maWdlZENvbXBvbmVudCIsIl9nZXRJbnN0YW5jZSIsIl9kZXByZWNhdGVkIiwiX2luc3RhbmNlIiwiY29udGV4dFByb3BzIiwibmV3Q29udGV4dFByb3BzIiwibmV3T3RoZXJzIiwiUkVBQ1RfU1RBVElDUyIsImdldERlZmF1bHRQcm9wcyIsIm1peGlucyIsIktOT1dOX1NUQVRJQ1MiLCJjYWxsZXIiLCJjYWxsZWUiLCJhcml0eSIsImdldFByb3RvdHlwZU9mIiwib2JqZWN0UHJvdG90eXBlIiwiaG9pc3ROb25SZWFjdFN0YXRpY3MiLCJ0YXJnZXRDb21wb25lbnQiLCJzb3VyY2VDb21wb25lbnQiLCJibGFja2xpc3QiLCJpbmhlcml0ZWRDb21wb25lbnQiLCJkZXNjcmlwdG9yIiwib25jZSIsImV2ZW50TmFtZSIsInVzZUNhcHR1cmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9fZm4iLCJwcm9taXNlQ2FsbCIsImZucyIsImNoYWluZWRGdW5jdGlvbiIsImN0eCIsIm5zIiwiZm5OYW1lIiwic3VjY2VzcyIsImZhaWx1cmUiLCJjYXRjaCIsImluc3RlYWQiLCJtc2ciLCJhbmltYXRpb25FbmRFdmVudE5hbWVzIiwiV2Via2l0QW5pbWF0aW9uIiwiT0FuaW1hdGlvbiIsInRyYW5zaXRpb25FdmVudE5hbWVzIiwiV2Via2l0VHJhbnNpdGlvbiIsIk9UcmFuc2l0aW9uIiwidHJhbnNpdGlvbiIsIl9zdXBwb3J0RW5kIiwiZWwiLCJfc3VwcG9ydENTUyIsImZsZXgiLCJjbGVhckxhc3RGb2N1c05vZGUiLCJsaW1pdFRhYlJhbmdlIiwiX2lzVmlzaWJsZSIsInZpc2liaWxpdHkiLCJfaXNGb2N1c2FibGUiLCJub2RlTmFtZSIsInBhcnNlSW50IiwiZ2V0QXR0cmlidXRlIiwiaGFzVGFiSW5kZXgiLCJpc05hTiIsInJlcyIsIm5vZGVMaXN0IiwicXVlcnlTZWxlY3RvckFsbCIsIm1ldGhvZCIsImxhc3RGb2N1c0VsZW1lbnQiLCJhY3RpdmVFbGVtZW50IiwidGFiTm9kZUxpc3QiLCJtYXhJbmRleCIsInNoaWZ0S2V5IiwidGltZXN0YW1wIiwibWFwS2V5cyIsImZuIiwibmV3S2V5IiwicmVwbGFjZUtleSIsInAxIiwicDIiLCJ0cmFuc2Zvcm1Db250ZXh0IiwiX3Jvb3QiLCJfc3RvcmUiLCJNYXAiLCJoYXMiLCJkZWZhdWx0VmFsdWUiLCJ1cGRhdGUiLCJkZWxldGUiLCJnZXRXcmFwcGVyUmVmIiwid3JhcHBlciIsImdldEFmZml4UmVmIiwiZ2V0SGVhZGVyQ2VsbFJlZiIsImdldFRhYmxlSW5zdGFuY2UiLCJnZXRUYWJsZUluc3RhbmNlRm9yVmlydHVhbCIsIm5vcm1hbGl6ZUNoaWxkcmVuU3RhdGUiLCJub3JtYWxpemVDaGlsZHJlbiIsImZldGNoSW5mb0Zyb21CaW5hcnlDaGlsZHJlbiIsImdldENoaWxkcmVuIiwiaGFzR3JvdXBIZWFkZXIiLCJmbGF0Q2hpbGRyZW4iLCJncm91cENoaWxkcmVuIiwicHJvcHNDaGlsZHJlbiIsImdldENvbFNwYW4iLCJncm91cENoaWxkIiwicmVuZGVyQ29sR3JvdXAiLCJyZW5kZXJUYWJsZSIsImhhc0hlYWRlciIsIkhlYWRlckNvbXBvbmVudCIsIldyYXBwZXIiLCJXcmFwcGVyQ29tcG9uZW50IiwiQm9keUNvbXBvbmVudCIsImhhc0JvcmRlciIsImlzWmVicmEiLCJlbnRpcmVEYXRhU291cmNlIiwicmVmcyIsImxvYWRpbmdDb21wb25lbnQiLCJMb2FkaW5nQ29tcG9uZW50IiwiemVicmEiLCJ0YWJsZSIsImxvYWRpbmdDbGFzc05hbWUiLCJDb2x1bW5Hcm91cCIsImhhc0V4cGFuZGVkUm93Q3RybCIsImdldEV4cGFuZGVkQ29sUHJvcHMiLCJvbkV4cGFuZGVkUm93Q2xpY2siLCJyb3dTZWxlY3Rpb24iLCJzdGlja3lIZWFkZXIiLCJhZmZpeFByb3BzIiwiaXNUcmVlIiwidXNlVmlydHVhbCIsInJvd0hlaWdodCIsInpoQ04iLCJ0cmFuc2Zvcm1FbnRyeUVxdWFsIiwidHJhbnNmb3JtRXF1YWwiLCJzaGFsbG93T2JqZWN0RXF1YWxzIiwiYWxsT3ZlcmxheXMiLCJnZXRQYWdlWCIsInNjcm9sbExlZnQiLCJnZXRQYWdlWSIsIl9nZXRFbGVtZW50UmVjdCIsImVsZW0iLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0UGFyZW50IiwiX2dldFZpZXdwb3J0U2l6ZSIsImV4cGVjdGVkQWxpZ24iLCJfZ2V0RXhwZWN0ZWRBbGlnbiIsImlzUGluRml4ZWQiLCJpc0Jhc2VGaXhlZCIsImZpcnN0UG9zaXRpb25SZXN1bHQiLCJwaW5FbGVtZW50UG9pbnRzIiwiX25vcm1hbGl6ZVBvc2l0aW9uIiwiYmFzZUVsZW1lbnRQb2ludHMiLCJwaW5FbGVtZW50UGFyZW50T2Zmc2V0IiwiX2dldFBhcmVudE9mZnNldCIsImJhc2VFbGVtZW50T2Zmc2V0IiwiX2dldExlZnRUb3AiLCJfc2V0UGluRWxlbWVudFBvc3Rpb24iLCJfaXNJblZpZXdwb3J0IiwiaW5WaWV3cG9ydExlZnQiLCJfbWFrZUVsZW1lbnRJblZpZXdwb3J0IiwiaW5WaWV3cG9ydFRvcCIsIl9nZXRFbGVtZW50T2Zmc2V0IiwiZG9jRWxlbWVudCIsIk1hdGgiLCJtYXgiLCJwb2ludHMiLCJfbm9ybWFsaXplRWxlbWVudCIsIl9ub3JtYWxpemVYWSIsIl94eUNvbnZlcnRlciIsIm0iLCJpc1ZpZXdwb3J0IiwiZG9jQ2xpZW50TGVmdCIsImNsaWVudExlZnQiLCJkb2NDbGllbnRUb3AiLCJjbGllbnRUb3AiLCJfcmVwbGFjZUFsaWduRGlyIiwibCIsInIiLCJ0IiwiYyIsInJlZ0V4cCIsInZpZXdwb3J0U2l6ZSIsImVsZW1lbnRSZWN0IiwicG9zdGlvbiIsIm9mZnNldFBhcmVudFdpZHRoIiwiZGVmYXVsdFZpc2libGUiLCJoYW5kbGVWaXNpYmxlQ2hhbmdlIiwiaGFuZGxlVHJpZ2dlckNsaWNrIiwiY2FuQ2xvc2VCeVRyaWdnZXIiLCJoYW5kbGVUcmlnZ2VyS2V5RG93biIsImhhbmRsZVRyaWdnZXJNb3VzZUVudGVyIiwiX21vdXNlTm90Rmlyc3RPbk1hc2siLCJfaGlkZVRpbWVyIiwiX3Nob3dUaW1lciIsImRlbGF5IiwiaGFuZGxlVHJpZ2dlck1vdXNlTGVhdmUiLCJoYW5kbGVUcmlnZ2VyRm9jdXMiLCJoYW5kbGVUcmlnZ2VyQmx1ciIsIl9pc0ZvcndhcmRDb250ZW50IiwiaGFuZGxlQ29udGVudE1vdXNlRG93biIsImhhbmRsZUNvbnRlbnRNb3VzZUVudGVyIiwiaGFuZGxlQ29udGVudE1vdXNlTGVhdmUiLCJoYW5kbGVNYXNrTW91c2VFbnRlciIsImhhbmRsZU1hc2tNb3VzZUxlYXZlIiwiaGFuZGxlUmVxdWVzdENsb3NlIiwicmVuZGVyVHJpZ2dlciIsInRyaWdnZXJUeXBlcyIsInJlbmRlckNvbnRlbnQiLCJvbk1vdXNlRG93biIsInJlbmRlclBvcnRhbCIsImZvbGxvd1RyaWdnZXIiLCJmaW5kVHJpZ2dlck5vZGUiLCJEcm9wZG93biIsImdldFZpc2libGUiLCJvbk1lbnVDbGljayIsImhhbmRsZU1vdXNlRW50ZXIiLCJoYW5kbGVNb3VzZUxlYXZlIiwicGFzc1BhcmVudFRvQ2hpbGRyZW4iLCJyZW5kZXJJbmxpbmUiLCJzdWJNZW51Q29udGVudENsYXNzTmFtZSIsInByb3BzVHJpZ2dlclR5cGUiLCJsaVByb3BzIiwiYXJyb3JQcm9wcyIsIlNlbGVjdGFiZWxJdGVtIiwibmV3U3ViTWVudUNvbnRlbnRDbGFzc05hbWUiLCJzdWJNZW51IiwibmV3TW9kZSIsIl9hZGRDbGFzcyIsIl9yZW1vdmVDbGFzcyIsIl90aGlzJGdldENsYXNzTmFtZXMiLCJnZXRDbGFzc05hbWVzIiwicmVtb3ZlQ2xhc3NlcyIsIl90aGlzJGdldENsYXNzTmFtZXMyIiwiYWN0aXZlQ2xhc3NOYW1lIiwicmVmbG93QW5kQWRkQ2xhc3MiLCJfdGhpcyRnZXRDbGFzc05hbWVzMyIsImRvbmVDbGFzc05hbWUiLCJfdGhpcyRnZXRDbGFzc05hbWVzNCIsIl90aGlzJGdldENsYXNzTmFtZXM1IiwiX3RoaXMkZ2V0Q2xhc3NOYW1lczYiLCJfdGhpcyRnZXRDbGFzc05hbWVzNyIsIl9oYXNDbGFzcyIsInNldEF0dHJpYnV0ZSIsImJhc2VWYWwiLCJvcmlnQ2xhc3MiLCJjbGFzc1RvUmVtb3ZlIiwiY291bnQiLCJfYXJncyIsIl9sZW4yIiwiX2tleTIiLCJoYW5kbGVMaWZlY3ljbGUiLCJoYW5kbGVFbnRlcmluZyIsIl9sZW4zIiwiX2tleTMiLCJoYW5kbGVFbnRlcmVkIiwiX2xlbjQiLCJfa2V5NCIsImhhbmRsZUV4aXQiLCJfbGVuNSIsIl9rZXk1IiwiaGFuZGxlRXhpdGluZyIsIl9sZW42IiwiX2tleTYiLCJfbGVuNyIsIl9rZXk3IiwiaWR4Iiwib3JpZ2luYWxBcmdzIiwiX2NoaWxkJHByb3BzIiwiaW5Qcm9wIiwiX1JlYWN0JENoaWxkcmVuJHRvQXJyIiwibWVyZ2VDaGlsZE1hcHBpbmdzIiwibWFwRm4iLCJtYXBwZXIiLCJnZXRWYWx1ZUZvcktleSIsIm5leHRLZXlzUGVuZGluZyIsInBlbmRpbmdLZXlzIiwiY2hpbGRNYXBwaW5nIiwicGVuZGluZ05leHRLZXkiLCJnZXRQcm9wIiwicHJvcCIsIm5leHRDaGlsZE1hcHBpbmciLCJoYXNQcmV2IiwiaGFzTmV4dCIsInByZXZDaGlsZCIsImlzTGVhdmluZyIsIkFuaW1hdGVDaGlsZCIsImVuZExpc3RlbmVycyIsInRyYW5zaXRpb25lbmQiLCJhbmltYXRpb25lbmQiLCJsaXN0ZW5lciIsImdlbmVyYXRlRW5kTGlzdGVuZXIiLCJlbmRMaXN0ZW5lciIsImxpc3RlbmVycyIsInRyYW5zaXRpb25FbmRMaXN0ZW5lciIsImFuaW1hdGlvbkVuZExpc3RlbmVyIiwidHJhbnNpdGlvbkRlbGF5IiwidHJhbnNpdGlvbkR1cmF0aW9uIiwicmVtb3ZlRW5kdExpc3RlbmVyIiwidHJhbnNpdGlvbk9mZiIsImFuaW1hdGlvbk9mZiIsInJlbW92ZUNsYXNzTmFtZXMiLCJpc0FwcGVhcmluZyIsImhvb2siLCJvbkFwcGVhcmluZyIsIm9uQXBwZWFyZWQiLCJsZWF2aW5nIiwiY2FjaGVDdXJyZW50U3R5bGUiLCJjYWNoZUNvbXB1dGVkU3R5bGUiLCJzZXRDdXJyZW50U3R5bGVUb1plcm8iLCJzZXRDdXJyZW50U3R5bGVUb0NvbXB1dGVkU3R5bGUiLCJyZXN0b3JlQ3VycmVudFN0eWxlIiwic3R5bGVCb3JkZXJUb3BXaWR0aCIsImJvcmRlclRvcFdpZHRoIiwic3R5bGVQYWRkaW5nVG9wIiwicGFkZGluZ1RvcCIsInN0eWxlSGVpZ2h0Iiwic3R5bGVQYWRkaW5nQm90dG9tIiwicGFkZGluZ0JvdHRvbSIsInN0eWxlQm9yZGVyQm90dG9tV2lkdGgiLCJib3JkZXJCb3R0b21XaWR0aCIsIm5ld0FuaW1hdGlvbiIsImNoZWNrYm94RGlzYWJsZWQiLCJDaGVja2JveEdyb3VwIiwiY3VycmVudFZhbHVlIiwidmFsVGVtcCIsIml0ZW1EaXJlY3Rpb24iLCJvcHRpb24iLCJpc0J1dHRvblNoYXBlIiwibmV3Q2hpbGRDbGFzc05hbWUiLCJtZW51IiwibWVudUluc3RhbmNlIiwiQ29udGV4dE1lbnUiLCJnZXRPdmVybGF5IiwiaGFuZGxlT3ZlcmxheUNsb3NlIiwiY2xpY2tlZFBvcHVwTWVudSIsIm92ZXJsYXlQcm9wcyIsImhhbmRsZU92ZXJsYXlPcGVuIiwibmV3T3ZlcmxheVByb3BzIiwibWVudVByb3BzIiwiZGVzdHJveSIsImRpdiIsImNsb3NlQ2hhaW4iLCJuZXdDb250ZXh0IiwibWFwSWNvblNpemUiLCJsYXJnZSIsIm1lZGl1bSIsInNtYWxsIiwib25Nb3VzZVVwIiwiYnV0dG9uIiwiYmx1ciIsImJ1dHRvblJlZkhhbmRsZXIiLCJodG1sVHlwZSIsImljb25TaXplIiwiZ2hvc3RUeXBlIiwiYnRuQ2xzIiwiY2xvbmVkQ2hpbGRyZW4iLCJpY29uQ2xzIiwidGFnQXR0cnMiLCJocmVmIiwiZ3JvdXBDbHMiLCJjbG9uZUNoaWxkcmVuIiwibGFzdFBhZ2VYIiwicGFnZVgiLCJvbk1vdXNlTW92ZSIsInVuU2VsZWN0IiwiY2hhbmdlZFBhZ2VYIiwiZGVzdG9yeSIsInVzZXJTZWxlY3QiLCJjdXJzb3IiLCJyZW1vdmVBdHRyaWJ1dGUiLCJUIiwiQmFzZUNvbXBvbmVudCIsIlRyZWVUYWJsZSIsIm9uVHJlZU5vZGVDbGljayIsImRzIiwiZ2V0Q2hpbGRyZW5LZXlCeUlkIiwiaWRzIiwib3BlblRyZWVSb3dLZXlzIiwidHJlZVN0YXR1cyIsImdldFRyZWVOb2RlU3RhdHVzIiwibm9ybWFsaXplRGF0YVNvdXJjZSIsIl9fbGV2ZWwiLCJvcGVuS2V5IiwiVHJlZVJvdyIsIlRyZWVDZWxsIiwiaGlkZGVuIiwib3BlbmVkIiwiZXhwYW5kZWRLZXlkb3duIiwidHJlZUFycm93Tm9kZUluZGV4IiwiZmlyc3RDZWxsU3R5bGUiLCJ0cmVlQXJyb3dOb2RlIiwidHJlZUFycm93VHlwZSIsInBhZGRpbmdMZWZ0IiwiaGFzRXhwYW5kZWQiLCJGaXhlZFRhYmxlIiwiY2hhckF0Iiwic3Vic3RyIiwiaW5uZXJIZWFkZXJOb2RlIiwiaGVhZGVyTm9kZSIsInNjcm9sbFRvIiwiYm9keU5vZGUiLCJhZGp1c3RGaXhlZEhlYWRlclNpemUiLCJ1bmlxdWUiLCJhcnIiLCJ0ZW1wIiwiU2VsZWN0aW9uVGFibGUiLCJyZW5kZXJTZWxlY3Rpb25IZWFkZXIiLCJzZWxlY3RBbGxSb3ciLCJmbGF0RGF0YVNvdXJjZSIsImdldFByb3BzIiwicmVuZGVyU2VsZWN0aW9uQm9keSIsInNlbGVjdE9uZVJvdyIsInJlY29yZHMiLCJvblNlbGVjdEFsbCIsInRyaWdnZXJTZWxlY3Rpb24iLCJsaXN0SGVhZGVyIiwiRXhwYW5kZWRUYWJsZSIsIm9uRXhwYW5kZWRDbGljayIsInJlbmRlckV4cGFuZGVkQ2VsbCIsInN3aXRjaE5vZGUiLCJ0b0FycmF5Q2hpbGRyZW4iLCJpdGVtQ29weSIsIlZpcnR1YWxUYWJsZSIsInNjcm9sbFRvUm93IiwibGFzdFNjcm9sbFRvcCIsInN0YXJ0IiwiY29tcHV0ZVNjcm9sbFRvUm93IiwiZ2V0Qm9keU5vZGUiLCJpbnN0YW5jZSIsIm9uVmlydHVhbFNjcm9sbCIsImJvZHlIZWlnaHQiLCJjb21wdXRlQm9keUhlaWdodCIsImlubmVyVG9wIiwiY29tcHV0ZUlubmVyVG9wIiwiaGFzVmlydHVhbERhdGEiLCJhZGp1c3RTY3JvbGxUb3AiLCJhZGp1c3RTaXplIiwicmVDb21wdXRlU2l6ZSIsImdldFJvd05vZGUiLCJyb3dDbGllbnRIZWlnaHQiLCJnZXRWaXNpYmxlUmFuZ2UiLCJFeHBlY3RTdGFydCIsInZpc2libGVDb3VudCIsIm1pbiIsInZpcnR1YWxTY3JvbGxOb2RlIiwidGFibGVJbmMiLCJ0YWJsZU5vZGUiLCJoZWFkZXJDbGllbnRXaWR0aCIsImxlZnROb2RlIiwiYm9keUxlZnROb2RlIiwicmlnaHROb2RlIiwiYm9keVJpZ2h0Tm9kZSIsImhhc1Njcm9sbGJhciIsIlZpcnR1YWxCb2R5IiwidGFibGVSZWYiLCJ2aXJ0dWFsU2Nyb2xsUmVmIiwidmlydHVhbFNjcm9sbCIsIm9uTG9ja0JvZHlTY3JvbGwiLCJnZXRMb2NrTm9kZSIsIkxvY2tUYWJsZSIsImlzTG9jayIsImxlZnRSb3ciLCJyaWdodFJvdyIsIm9uTG9ja0JvZHlXaGVlbCIsImRlbHRhWSIsImxvY2tMZWZ0Qm9keSIsInNjcm9sbE5vZGUiLCJsb2NrUmlnaHRCb2R5IiwibmV3U2Nyb2xsVG9wIiwibG9ja1JpZ2h0VGFibGUiLCJsb2NrTGVmdFRhYmxlIiwic2hhZG93Q2xhc3NOYW1lIiwic2Nyb2xsV2lkdGgiLCJsb2NrTGVmdENoaWxkcmVuIiwibG9ja1JpZ2h0Q2hpbGRyZW4iLCJzY3JvbGwiLCJfaXNMb2NrIiwic3BsaXRDaGlsZHJlbiIsInNwbGl0RnJvbU5vcm1hbGl6ZUNoaWxkcmVuIiwibWVyZ2VGcm9tU3BsaXRMb2NrQ2hpbGRyZW4iLCJvcmlnaW5DaGlsZHJlbiIsImRlZXBDb3B5IiwibG9ja0NoaWxkcmVuIiwiY29uZGl0aW9uIiwic2Nyb2xsVG9Db2wiLCJjb2xDZWxsTm9kZSIsImdldENlbGxOb2RlIiwicm93Q2VsbE5vZGUiLCJib2R5Tm9kZU9mZnNldCIsImNlbGxOb2Rlb2Zmc2V0IiwiaXNPcmlnaW5Mb2NrIiwiYWRqdXN0SWZUYWJsZU5vdE5lZWRMb2NrIiwiYWRqdXN0SGVhZGVyU2l6ZSIsImFkanVzdEJvZHlTaXplIiwiYWRqdXN0Q2VsbFNpemUiLCJjb25maWdXaWR0aHMiLCJsb2NrTGVmdExlbiIsImxvY2tSaWdodExlbiIsIl9ub3ROZWVkQWRqdXN0TG9ja0xlZnQiLCJfbm90TmVlZEFkanVzdExvY2tSaWdodCIsImxvY2tSaWdodEJvZHlXcmFwcGVyIiwiaGFzSG96U2Nyb2xsIiwiaGFzVmVyU2Nyb2xsIiwibG9ja0JvZHlIZWlnaHQiLCJsYXN0SW5kZXgiLCJoZWFkZXJSaWdodFJvdyIsImdldEhlYWRlckNlbGxOb2RlIiwiaGVhZGVyTGVmdFJvdyIsImhlYWRlclJpZ2h0TG9ja1JvdyIsImhlYWRlckxlZnRMb2NrUm93IiwibWF4UmlnaHRSb3dIZWlnaHQiLCJ0YWJsZVJpZ2h0SW5jIiwidXBkYXRlUG9zaXRpb24iLCJtYXhMZWZ0Um93SGVpZ2h0IiwidGFibGVMZWZ0SW5jIiwibG9ja0xlZnRSb3ciLCJsb2NrUmlnaHRSb3ciLCJnZXRGaXJzdE5vcm1hbENlbGxOb2RlIiwibG9ja0xlZnRIZWlnaHQiLCJsb2NrUmlnaHRIZWlnaHQiLCJub3JtYWxpemVkQ2hpbGRyZW4iLCJMb2NrQm9keSIsIkxvY2tIZWFkZXIiLCJMb2NrV3JhcHBlciIsImNvcHkiLCJuZXdJdGVtIiwib25Cb2R5V2hlZWwiLCJMaXN0VGFibGUiLCJsaXN0Rm9vdGVyIiwiaXNMaXN0IiwiTGlzdFJvdyIsIkxpc3RCb2R5IiwiR3JvdXBMaXN0Um93IiwicmVuZGVyQ2hpbGRyZW4iLCJpc0NoaWxkcmVuU2VsZWN0aW9uIiwiaXNTZWxlY3Rpb24iLCJjZWxscyIsInNoaWZ0IiwiY2FtZVR5cGUiLCJsaXN0Tm9kZSIsIlN0aWNreVRhYmxlIiwiU3RpY2t5SGVhZGVyIiwiU3RpY2tIZWFkZXIiLCJuZXdBZmZpeFByb3BzIiwiQWZmaXgiLCJfdXBkYXRlTm9kZVBvc2l0aW9uIiwidXNlQWJzb2x1dGUiLCJhZmZpeENvbnRhaW5lciIsImNvbnRhaW5lclNjcm9sbFRvcCIsImFmZml4T2Zmc2V0IiwiX2dldE9mZnNldCIsImFmZml4Tm9kZSIsImNvbnRhaW5lckhlaWdodCIsImFmZml4SGVpZ2h0IiwiY29udGFpbmVyUmVjdCIsImFmZml4Q2hpbGRIZWlnaHQiLCJhZmZpeENoaWxkTm9kZSIsImFmZml4TW9kZSIsImFmZml4U3R5bGUiLCJjb250YWluZXJTdHlsZSIsIl9zZXRBZmZpeFN0eWxlIiwiX3NldENvbnRhaW5lclN0eWxlIiwiX2FmZml4Tm9kZVJlZkhhbmRsZXIiLCJfYWZmaXhDaGlsZE5vZGVSZWZIYW5kbGVyIiwiX2dldEFmZml4TW9kZSIsIl9zZXRFdmVudEhhbmRsZXJGb3JDb250YWluZXIiLCJfcmVtb3ZlRXZlbnRIYW5kbGVyRm9yQ29udGFpbmVyIiwiZ2V0Q29udGFpbmVyIiwib2Zmc2V0Qm90dG9tIiwiYWZmaXhlZCIsIm9uQWZmaXgiLCJhZmZpeFJlY3QiLCJjb250YWluZXJTY3JvbGxMZWZ0IiwiY29tYmluZWRTdHlsZSIsImdldFNjcm9sbCIsImdldFJlY3QiLCJnZXROb2RlSGVpZ2h0IiwiaXNWZXJ0aWNhbCIsIndpbmRvd1Byb3AiLCJlbGVtZW50UHJvcCIsImlubmVySGVpZ2h0IiwibG9jYWxzIiwiaG90IiwiYWNjZXB0IiwibmV3Q29udGVudCIsImRpc3Bvc2UiLCJjc3MiLCJiYXNlVXJsIiwicHJvdG9jb2wiLCJob3N0IiwiY3VycmVudERpciIsInBhdGhuYW1lIiwiZml4ZWRDc3MiLCJmdWxsTWF0Y2giLCJvcmlnVXJsIiwidW5xdW90ZWRPcmlnVXJsIiwibyIsIm5ld1VybCIsIlRleHRBcmVhIiwiY2xvc2FibGUiLCJjbG9zZUFyZWEiLCJoYW5kbGVDbG9zZSIsIl9fZGVzdHJveWVkIiwiaGFzQW5pbWF0aW9uIiwidGFnTm9kZSIsImhhbmRsZUJvZHlDbGljayIsImhhbmRsZVRhaWxDbGljayIsImhhbmRsZUFuaW1hdGlvbkluaXQiLCJoYW5kbGVBbmltYXRpb25FbmQiLCJyZW5kZXJBbmltYXRlZFRhZyIsImFuaW1hdGlvbk5hbWUiLCJyZW5kZXJUYWlsTm9kZSIsIl9zaGFwZSIsImJvZHlDbGF6eiIsInRhaWxOb2RlIiwiaXNTaW5nbGUiLCJpc051bGwiLCJlc2NhcGVGb3JSZWciLCJsb29wTWFwIiwicGFyc2VEYXRhU291cmNlRnJvbUNoaWxkcmVuIiwiZmxhdHRpbmdEYXRhU291cmNlIiwiZmlsdGVyRGF0YVNvdXJjZSIsImdldFZhbHVlRGF0YVNvdXJjZSIsInZhbHVlVG9TZWxlY3RLZXkiLCJ0bXAiLCJkZWVwIiwiaXRlbTIiLCJpc09wdGlvbiIsImlzT3B0aW9uR3JvdXAiLCJpc1N0ckNoaWxkIiwiX19pc0FkZG9uIiwiYWRkb25LZXkiLCJhZGRLZXkiLCJtZW51RGF0YVNvdXJjZSIsImdldEtleUl0ZW1CeVZhbHVlIiwidmFsdWVNYXAiLCJtYXBWYWx1ZURTIiwibWFwTWVudURTIiwibmV3VmFsdWUiLCJuZXdWYWx1ZURTIiwibmV3TWFwVmFsdWVEUyIsIl9uZXdNYXBEUyIsInYiLCJ2YWx1ZURTIiwic2F2ZVJlZiIsImlucHV0UmVmIiwiaWVIYWNrIiwiTnVtYmVyIiwibWF4TGVuZ3RoIiwiZ2V0VmFsdWVMZW5ndGgiLCJvcHRzIiwiYmVUcmltZWQiLCJvdmVyTWF4TGVuZ3RoIiwicmVuZGVyTGVuZ3RoIiwiaGFzTGltaXRIaW50IiwiY2xhc3Nlc0xlbldyYXAiLCJyZW5kZXJDb250cm9sIiwibGVuV3JhcCIsImdldENsYXNzIiwiaW5wdXRTdHlsZSIsInJlYWRPbmx5IiwiY3V0U3RyaW5nIiwiZ2V0SW5wdXROb2RlIiwic2VsZWN0aW9uU3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJhZGRvbkJlZm9yZSIsImFkZG9uQWZ0ZXIiLCJhZGRvbkJlZm9yZUNsYXNzTmFtZSIsImFkZG9uQWZ0ZXJDbGFzc05hbWUiLCJhZGRvbkNscyIsImJlZm9yZUNscyIsImFmdGVyQ2xzIiwiYmVmb3JlIiwiYWZ0ZXIiLCJNZW51SXRlbSIsIk1lbnVHcm91cCIsInNhdmVTZWxlY3RSZWYiLCJzZWxlY3RET00iLCJzYXZlSW5wdXRSZWYiLCJzYXZlUG9wdXBSZWYiLCJwb3B1cFJlZiIsImRhdGFTdG9yZSIsIkRhdGFTdG9yZSIsImZpbHRlckxvY2FsIiwiaGlnaGxpZ2h0S2V5Iiwic2V0RGF0YVNvdXJjZSIsInN5bmNXaWR0aCIsInNldE9wdGlvbnMiLCJ1cGRhdGVCeURTIiwic2V0VmlzaWJsZSIsInNldEZpcnN0SGlnaHRMaWdodEtleUZvck1lbnUiLCJnZXRNZW51RFMiLCJnZXRFbmFibGVEUyIsImhhbmRsZUNoYW5nZSIsImhhbmRsZU1lbnVCb2R5Q2xpY2siLCJmb2N1c0lucHV0IiwidG9nZ2xlSGlnaGxpZ2h0SXRlbSIsIm1heENvdW50IiwiaGlnaGxpZ2h0SW5kZXgiLCJoaWdobGlnaHRJdGVtIiwic2Nyb2xsTWVudUludG9WaWV3IiwiaGlnaGxpZ2h0VGltZXIiLCJtZW51UmVmIiwic2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCIsInJlbmRlck1lbnVIZWFkZXIiLCJyZW5kZXJNZW51IiwibWVudUNsYXNzTmFtZSIsIm1pbldpZHRoIiwiaGFuZGxlTWVudVNlbGVjdCIsIml0ZW1SZW5kZXIiLCJzZWFyY2hLZXkiLCJpc0F1dG9Db21wbGV0ZSIsInNlYXJjaFZhbHVlIiwicG9wdXBDb250YWluZXIiLCJwb3B1cENvbnRlbnQiLCJfcHJvcHMiLCJyZW5kZXJTZWxlY3QiLCJoYXNDbGVhciIsIm9uVG9nZ2xlSGlnaGxpZ2h0SXRlbSIsIkFwcCIsImN1cnJlbnRQYWdlIiwiUmVhY3RET00iLCJjb21wb25lbnREZXNjIiwiY29tcG9uZW50Qm9keSIsInJlbG9hZGluZyIsIk9wdGlvbiIsImRlZmF1bHRDdXJyZW50IiwidG90YWwiLCJjb3JyZWN0Q3VycmVudCIsImN1cnJlbnRQYWdlU2l6ZSIsIm9uSnVtcCIsInN0IiwibmV3Q3VycmVudCIsInRvdGFsUGFnZSIsImdldFRvdGFsUGFnZSIsImNlaWwiLCJpbnB1dFZhbHVlIiwib25QYWdlSXRlbUNsaWNrIiwib25JbnB1dENoYW5nZSIsIm9uU2VsZWN0U2l6ZSIsIm5ld1N0YXRlIiwib25QYWdlU2l6ZUNoYW5nZSIsInJlbmRlclBhZ2VUb3RhbCIsInRvdGFsUmVuZGVyIiwicmFuZ2UiLCJyZW5kZXJQYWdlSXRlbSIsImxpbmsiLCJwYWdlTnVtYmVyUmVuZGVyIiwiaXNDdXJyZW50IiwicmVuZGVyUGFnZUZpcnN0IiwiaXNGaXJzdCIsImljb24iLCJyZW5kZXJQYWdlTGFzdCIsImlzTGFzdCIsInJlbmRlclBhZ2VFbGxpcHNpcyIsInJlbmRlclBhZ2VKdW1wIiwicmVuZGVyUGFnZURpc3BsYXkiLCJyZW5kZXJQYWdlTGlzdCIsInBhZ2VTaG93Q291bnQiLCJwYWdlcyIsIm90aGVyc0NvdW50IiwiaGFsZkNvdW50IiwicmVuZGVyUGFnZVNpemVTZWxlY3RvciIsInBhZ2VTaXplU2VsZWN0b3IiLCJwYWdlU2l6ZVNwYW4iLCJyZW5kZXJQYWdlU2l6ZUZpbHRlciIsInJlbmRlclBhZ2VTaXplRHJvcGRvd24iLCJwYWdlU2l6ZUxpc3QiLCJwYWdlU2l6ZVBvc2l0aW9uIiwidXNlRmxvYXRMYXlvdXQiLCJoaWRlT25seU9uZVBhZ2UiLCJzaG93SnVtcCIsInBhZ2VGaXJzdCIsInBhZ2VMYXN0Iiwic2l6ZVNlbGVjdG9yIiwiaXNTdGFydCIsImJ1aWxkQ29tcG9uZW50IiwiY29tcyIsImNvbSIsInBhZ2VEaXNwbGF5IiwicGFnZUxpc3QiLCJwYWdlSnVtcCIsIm9uUHJlc3NFbnRlciIsImhhbmRsZUtleURvd25Gcm9tQ2xlYXIiLCJvbkNsZWFyIiwibnYiLCJzdHJMZW4iLCJzdGF0ZVdyYXAiLCJjbGVhcldyYXAiLCJzaG93Q2xlYXIiLCJoaW50SWNvbiIsInJlbmRlckxhYmVsIiwicmVuZGVySW5uZXIiLCJodG1sU2l6ZSIsImF1dG9Db21wbGV0ZSIsImlubmVyQmVmb3JlIiwiaW5uZXJBZnRlciIsImlubmVyQmVmb3JlQ2xhc3NOYW1lIiwiaW5uZXJBZnRlckNsYXNzTmFtZSIsImFkZG9uVGV4dEJlZm9yZSIsImFkZG9uVGV4dEFmdGVyIiwiaW5wdXRSZW5kZXIiLCJoYXNBZGRvbiIsImlubmVyQ2xzIiwiaW5uZXJCZWZvcmVDbHMiLCJpbm5lckFmdGVyQ2xzIiwiZGF0YVByb3BzIiwiaW5wdXRFbCIsImlucHV0V3JhcCIsImFkZG9uQmVmb3JlQ2xzIiwiYWRkb25BZnRlckNscyIsIm9uTmV4dEZyYW1lIiwiY2IiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjbGVhck5leHRGcmFtZUFjdGlvbiIsIm5leHRGcmFtZUlkIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJoaWRkZW5TdHlsZSIsInpJbmRleCIsImF1dG9IZWlnaHQiLCJfZ2V0TWluTWF4SGVpZ2h0IiwiX2dldEhlaWdodCIsIl9yZXNpemVUZXh0QXJlYSIsIm1pblJvd3MiLCJtYXhSb3dzIiwiaGVscFJlZiIsIm1pbkhlaWdodCIsIm11bHRpcGxlIiwic2F2ZVRleHRBcmVhUmVmIiwidGV4dEFyZWEiLCJzYXZlSGVscFJlZiIsInRleHRhcmVTdHlsZSIsIndyYXBTdHlsZSIsIm5leHRGcmFtZUFjdGlvbklkIiwiSW5maW5pdHkiLCJBdXRvQ29tcGxldGUiLCJPcHRpb25Hcm91cCIsImZpbHRlckJ5Iiwibm9Gb3VuZENvbnRlbnQiLCJuZXdwcm9wcyIsIkNvbWJvYm94Iiwib25JbnB1dFVwZGF0ZSIsIm9uU2VhcmNoIiwic2hvd1NlYXJjaCIsImlzSUU5IiwiaGFuZGxlV3JhcENsaWNrIiwiaGFuZGxlQXJyb3dDbGljayIsImhhbmRsZUNsZWFyIiwidmFsdWVEYXRhU291cmNlIiwiZ2V0TWFwRFMiLCJpZTlIYWNrIiwiY3VycmVudFN0eWxlIiwiZml4V2lkdGgiLCJ1c2VEZXRhaWxWYWx1ZSIsImhhc1NlYXJjaCIsImhhbmRsZVNpbmdsZVNlbGVjdCIsImhhbmRsZU11bHRpcGxlU2VsZWN0IiwiY2FjaGVWYWx1ZSIsIml0ZW1PYmoiLCJoYW5kbGVTZWFyY2hDbGVhciIsImhpZGRlblNlbGVjdGVkIiwiaGFuZGxlU2VhcmNoVmFsdWUiLCJ1cGRhdGVCeUtleSIsImhhbmRsZVNlYXJjaCIsIm9uU2VhcmNoQ2xlYXIiLCJoYW5kbGVTZWFyY2hLZXlEb3duIiwicHJveHkiLCJjaG9vc2VIaWdobGlnaHRJdGVtIiwiaGFuZGxlRGVsZXRlVGFnIiwicHJldlZpc2libGUiLCJoYW5kbGVUYWdDbG9zZSIsIm9uUmVtb3ZlIiwibmV4dFZhbHVlcyIsImhhbmRsZVNlbGVjdEFsbCIsInJlbmRlclZhbHVlcyIsInZhbHVlUmVuZGVyIiwiZmlsbFByb3BzIiwicmV0dmFsdWUiLCJsYWJlbE5vZGUiLCJyZW5kZXJFeHRyYU5vZGUiLCJoYXNBcnJvdyIsInZhbHVlTm9kZXMiLCJfcGxhY2Vob2xkZXIiLCJzZWxlY3RQbGFjZUhvbGRlciIsInRyaWdnZXJDbGF6eiIsInZhbHVldGV4dCIsInJlbmRlclNlYXJjaElucHV0IiwibWlycm9yVGV4dCIsImhhc1NlbGVjdEFsbCIsInNvdXJjZUNvdW50IiwiQ29uZmlnVGFnIiwidHJhbnNmcm9tIiwiU2VsZWN0YWJsZSIsIkNsb3NhYmxlIiwiQ2xvc2VhYmxlIiwiY2xhenoiLCJhdHRyRmlsdGVyVGFyZ2V0IiwibWFwRGF0YVNvdXJjZSIsImVuYWJsZWREYXRhU291cmNlIiwiaXNDaGlsZHJlbiIsInVwZGF0ZUFsbCIsImdldE9yaWdpbkRTIiwiZ2V0RmxhdHRlbkRTIiwiZmxhdHRlbkRhdGFTb3VyY2UiLCJWaXJ0dWFsTGlzdCIsIk5PT1AiLCJNQVhfU1lOQ19VUERBVEVTIiwiaXNFcXVhbFN1YnNldCIsImp1bXBJbmRleCIsImNvbnN0cmFpbiIsImNhY2hlZFNjcm9sbCIsInVuc3RhYmxlIiwidXBkYXRlQ291bnRlciIsInVwZGF0ZUZyYW1lQW5kQ2xlYXJDYWNoZSIsInVwZGF0ZUZyYW1lIiwib2xkSW5kZXgiLCJuZXdJbmRleCIsIm1heWJlU2V0U3RhdGUiLCJ1cGRhdGVDb3VudGVyVGltZW91dElkIiwic2Nyb2xsUGFyZW50IiwiZ2V0RWwiLCJnZXRTY3JvbGxQYXJlbnQiLCJwYXJlbnRFbGVtZW50Iiwic2Nyb2xsS2V5IiwiYWN0dWFsIiwiZ2V0U2Nyb2xsU2l6ZSIsImdldFZpZXdwb3J0U2l6ZSIsInNldFNjcm9sbCIsImdldFN0YXJ0QW5kRW5kIiwidGhyZXNob2xkIiwidHJ1ZVNjcm9sbCIsInVwZGF0ZVNjcm9sbFBhcmVudCIsInVwZGF0ZVZhcmlhYmxlRnJhbWUiLCJpdGVtU2l6ZUdldHRlciIsImNhY2hlU2l6ZXMiLCJzcGFjZSIsIm1heEZyb20iLCJpdGVtU2l6ZSIsImdldFNpemVPZiIsIm1heFNpemUiLCJnZXRTcGFjZUJlZm9yZSIsIml0ZW1FbHMiLCJ1bFJlZiIsInBvcCIsImRlZmF1bHRJdGVtSGVpZ2h0IiwibWluU2l6ZSIsInJlbmRlck1lbnVJdGVtcyIsIml0ZW1zUmVuZGVyZXIiLCJsaXN0U3R5bGUiLCJtc1RyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsImFjdGlvblR5cGUiLCJpc0lucHV0aW5nIiwic2hvdWxkQ29udHJvbFBvcHVwIiwiaW5wdXROb2RlIiwiY2xlYXJOb2RlIiwiaGFzUG9wdXAiLCJtYXBEUyIsImhhbmRsZVNlbGVjdEV2ZW50IiwiaGlnaGxpZ2h0SG9sZGVyIiwiYXV0b0NvbXBsZXRlUGxhY2VIb2xkZXIiLCJfaW5wdXRQcm9wcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDhCOzs7Ozs7Ozs7OztBQ0FBOzs7Ozs7O0FBT0EsSUFBSUEsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLE1BQUlDLHFCQUFzQixPQUFPQyxNQUFQLEtBQWtCLFVBQWxCLElBQ3hCQSxPQUFPQyxHQURpQixJQUV4QkQsT0FBT0MsR0FBUCxDQUFXLGVBQVgsQ0FGdUIsSUFHdkIsTUFIRjs7QUFLQSxNQUFJQyxpQkFBaUIsU0FBakJBLGNBQWlCLENBQVNDLE1BQVQsRUFBaUI7QUFDcEMsV0FBTyxRQUFPQSxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQWxCLElBQ0xBLFdBQVcsSUFETixJQUVMQSxPQUFPQyxRQUFQLEtBQW9CTCxrQkFGdEI7QUFHRCxHQUpEOztBQU1BO0FBQ0E7QUFDQSxNQUFJTSxzQkFBc0IsSUFBMUI7QUFDQUMsU0FBT0MsT0FBUCxHQUFpQkMsbUJBQU9BLENBQUMsRUFBUixFQUFxQ04sY0FBckMsRUFBcURHLG1CQUFyRCxDQUFqQjtBQUNELENBaEJELE1BZ0JPO0FBQ0w7QUFDQTtBQUNBQyxT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TUFBWCxDQUFrQixHQUFsQixFQUFnUSxZQUFXO0FBQzFRLE9BQUlDLGFBQWFsc0QsbUJBQU9BLENBQUMsR0FBUixDQUFqQjtBQUNBLE9BQUcsT0FBT2tzRCxVQUFQLEtBQXNCLFFBQXpCLEVBQW1DQSxhQUFhLENBQUMsQ0FBQ3BzRCxRQUFELEVBQVlvc0QsVUFBWixFQUF3QixFQUF4QixDQUFELENBQWI7QUFDbkNqZixVQUFPaWYsVUFBUDtBQUNBLEdBSkQ7QUFLQTtBQUNEO0FBQ0Fwc0QsUUFBT2tzRCxHQUFQLENBQVdHLE9BQVgsQ0FBbUIsWUFBVztBQUFFbGY7QUFBVyxFQUEzQztBQUNBLEM7Ozs7OztBQ3pCRDs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxHQUFrSTtBQUN4Siw0Q0FBNEMsUUFBUztBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxDQUEyRTtBQUNoRztBQUNBO0FBQ0EsR0FBRyxJQUFVO0FBQ2I7QUFDQTtBQUNBLG9CQUFvQixHQUFrSTtBQUN0SixvQkFBb0IsbUJBQU8sQ0FBQyxHQUFrSTtBQUM5SixxREFBcUQsUUFBUztBQUM5RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyxDIiwiZmlsZSI6Ii9Vc2Vycy96aGFvZ3VveWFuL2dpdGh1Yi9wdWIvZG9jcy90YWJsZS9kZW1vL3BhZ2luYXRpb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5SZWFjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIndpbmRvdy5SZWFjdFwiXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUgNiA3IDggOSAxMCAxMSAxMiAxMyAxNCAxNSAxNiAxNyAxOCAxOSAyMCAyMSAyMiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgU3ltYm9sLmZvciAmJlxuICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAweGVhYzc7XG5cbiAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9O1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fcHJvcC10eXBlc0AxNS42LjJAcHJvcC10eXBlcy9pbmRleC5qcyIsImltcG9ydCAqIGFzIF9kb20gZnJvbSAnLi9kb20nO1xuaW1wb3J0ICogYXMgX2VudiBmcm9tICcuL2Vudic7XG5pbXBvcnQgKiBhcyBfZXZlbnRzIGZyb20gJy4vZXZlbnRzJztcbmltcG9ydCAqIGFzIF9mdW5jIGZyb20gJy4vZnVuYyc7XG5pbXBvcnQgKiBhcyBfbG9nIGZyb20gJy4vbG9nJztcbmltcG9ydCAqIGFzIF9vYmplY3QgZnJvbSAnLi9vYmplY3QnO1xuaW1wb3J0ICogYXMgX3N0cmluZyBmcm9tICcuL3N0cmluZyc7XG5pbXBvcnQgKiBhcyBfc3VwcG9ydCBmcm9tICcuL3N1cHBvcnQnO1xuaW1wb3J0ICogYXMgX2ZvY3VzIGZyb20gJy4vZm9jdXMnO1xuaW1wb3J0IF9ndWlkIGZyb20gJy4vZ3VpZCc7XG5pbXBvcnQgX0tFWUNPREUgZnJvbSAnLi9rZXljb2RlJztcblxuZXhwb3J0IGNvbnN0IGRvbSA9IF9kb207XG5leHBvcnQgY29uc3QgZW52ID0gX2VudjtcbmV4cG9ydCBjb25zdCBldmVudHMgPSBfZXZlbnRzO1xuZXhwb3J0IGNvbnN0IGZ1bmMgPSBfZnVuYztcbmV4cG9ydCBjb25zdCBsb2cgPSBfbG9nO1xuZXhwb3J0IGNvbnN0IG9iaiA9IF9vYmplY3Q7XG5leHBvcnQgY29uc3Qgc3RyID0gX3N0cmluZztcbmV4cG9ydCBjb25zdCBzdXBwb3J0ID0gX3N1cHBvcnQ7XG5leHBvcnQgY29uc3QgZm9jdXMgPSBfZm9jdXM7XG5leHBvcnQgY29uc3QgZ3VpZCA9IF9ndWlkO1xuZXhwb3J0IGNvbnN0IEtFWUNPREUgPSBfS0VZQ09ERTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlsL2luZGV4LmpzIiwiLyohXG4gIENvcHlyaWdodCAoYykgMjAxNyBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmICghYXJnKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGFyZyk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSAmJiBhcmcubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpbm5lciA9IGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKTtcblx0XHRcdFx0aWYgKGlubmVyKSB7XG5cdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGlubmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Y2xhc3NOYW1lcy5kZWZhdWx0ID0gY2xhc3NOYW1lcztcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19jbGFzc25hbWVzQDIuMi42QGNsYXNzbmFtZXMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5SZWFjdERPTTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIndpbmRvdy5SZWFjdERPTVwiXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUgNiA3IDggOSAxMCAxMSAxMiAxMyAxNCAxNSAxNiAxNyAxOCAxOSAyMCAyMSAyMiIsImltcG9ydCB7IENvbXBvbmVudCwgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGdldENvbnRleHRQcm9wcyBmcm9tICcuL2dldC1jb250ZXh0LXByb3BzJztcbmltcG9ydCB7XG4gICAgY29uZmlnLFxuICAgIGluaXRMb2NhbGVzLFxuICAgIHNldExhbmd1YWdlLFxuICAgIHNldExvY2FsZSxcbiAgICBzZXREaXJlY3Rpb24sXG4gICAgZ2V0TG9jYWxlLFxuICAgIGdldExhbmd1YWdlLFxuICAgIGdldERpcmVjdGlvblxufSBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgQ29uc3VtZXIgZnJvbSAnLi9jb25zdW1lcic7XG5pbXBvcnQgQ2FjaGUgZnJvbSAnLi9jYWNoZSc7XG5cbmNvbnN0IGNoaWxkQ29udGV4dENhY2hlID0gbmV3IENhY2hlKCk7XG5cbi8qKlxuICogQ29uZmlnUHJvdmlkZXJcbiAqIEBwcm9wc0V4dGVuZHMgZmFsc2VcbiAqL1xuY2xhc3MgQ29uZmlnUHJvdmlkZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmoLflvI/nsbvlkI3nmoTlk4HniYzliY3nvIBcbiAgICAgICAgICovXG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWbvemZheWMluaWh+ahiOWvueixoe+8jOWxnuaAp+S4uue7hOS7tueahCBkaXNwbGF5TmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgbG9jYWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5byA5ZCvIFB1cmUgUmVuZGVyIOaooeW8j++8jOS8muaPkOmrmOaAp+iDve+8jOS9huaYr+S5n+S8muW4puadpeWJr+S9nOeUqFxuICAgICAgICAgKi9cbiAgICAgICAgcHVyZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblnKjlvIDlj5HmqKHlvI/kuIvmmL7npLrnu4Tku7blsZ7mgKfooqvlup/lvIPnmoQgd2FybmluZyDmj5DnpLpcbiAgICAgICAgICovXG4gICAgICAgIHdhcm5pbmc6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5byA5ZCvIHJ0bCDmqKHlvI9cbiAgICAgICAgICovXG4gICAgICAgIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnu4Tku7bmoJFcbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuZWxlbWVudFxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICB3YXJuaW5nOiB0cnVlXG4gICAgfTtcblxuICAgIHN0YXRpYyBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgbmV4dFByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgbmV4dExvY2FsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgbmV4dFB1cmU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBuZXh0UnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgbmV4dFdhcm5pbmc6IFByb3BUeXBlcy5ib29sXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOS8oOWFpee7hOS7tu+8jOeUn+aIkOWPlyBDb25maWdQcm92aWRlciDmjqfliLbnmoQgSE9DIOe7hOS7tlxuICAgICAqIEBwYXJhbSB7Q29tcG9uZW50fSBDb21wb25lbnQg57uE5Lu257G7XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMg5Y+v6YCJ6aG5XG4gICAgICogQHJldHVybnMge0NvbXBvbmVudH0gSE9DXG4gICAgICovXG4gICAgc3RhdGljIGNvbmZpZyA9IChDb21wb25lbnQsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZyhDb21wb25lbnQsIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDkvKDlhaXnu4Tku7bnmoQgcHJvcHMg5ZKMIGRpc3BsYXlOYW1l77yM5b6X5Yiw5ZKMIGNoaWxkQ29udGV4dCDorqHnrpfov4fnmoTljIXlkKvmnIkgcHJlaWZ4L2xvY2FsZS9wdXJlIOeahOWvueixoe+8jOS4gOiIrOeUqOS6jumAmui/h+mdmeaAgeaWueazleeUn+aIkOiEseemu+e7hOS7tuagkeeahOe7hOS7tlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyDnu4Tku7bnmoQgcHJvcHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGlzcGxheU5hbWUg57uE5Lu255qEIGRpc3BsYXlOYW1lXG4gICAgICogQHJldHVybnMge09iamVjdH0g5paw55qEIGNvbnRleHQgcHJvcHNcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q29udGV4dFByb3BzID0gKHByb3BzLCBkaXNwbGF5TmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dFByb3BzKHByb3BzLCBjaGlsZENvbnRleHRDYWNoZS5yb290KCkgfHwge30sIGRpc3BsYXlOYW1lKTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGluaXRMb2NhbGVzID0gaW5pdExvY2FsZXM7XG4gICAgc3RhdGljIHNldExhbmd1YWdlID0gc2V0TGFuZ3VhZ2U7XG4gICAgc3RhdGljIHNldExvY2FsZSA9IHNldExvY2FsZTtcbiAgICBzdGF0aWMgc2V0RGlyZWN0aW9uID0gc2V0RGlyZWN0aW9uO1xuICAgIHN0YXRpYyBnZXRMYW5ndWFnZSA9IGdldExhbmd1YWdlO1xuICAgIHN0YXRpYyBnZXRMb2NhbGUgPSBnZXRMb2NhbGU7XG4gICAgc3RhdGljIGdldERpcmVjdGlvbiA9IGdldERpcmVjdGlvbjtcbiAgICBzdGF0aWMgQ29uc3VtZXIgPSBDb25zdW1lcjtcblxuICAgIHN0YXRpYyBnZXRDb250ZXh0ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB7IG5leHRQcmVmaXgsIG5leHRMb2NhbGUsIG5leHRQdXJlLCBuZXh0UnRsLCBuZXh0V2FybmluZyB9ID0gY2hpbGRDb250ZXh0Q2FjaGUucm9vdCgpIHx8IHt9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcmVmaXg6IG5leHRQcmVmaXgsXG4gICAgICAgICAgICBsb2NhbGU6IG5leHRMb2NhbGUsXG4gICAgICAgICAgICBwdXJlOiBuZXh0UHVyZSxcbiAgICAgICAgICAgIHJ0bDogbmV4dFJ0bCxcbiAgICAgICAgICAgIHdhcm5pbmc6IG5leHRXYXJuaW5nXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIGNoaWxkQ29udGV4dENhY2hlLmFkZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBjaGlsZENvbnRleHRDYWNoZS5nZXQodGhpcywge30pLCB0aGlzLmdldENoaWxkQ29udGV4dCgpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIGxvY2FsZSwgcHVyZSwgd2FybmluZywgcnRsIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0UHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICBuZXh0TG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICBuZXh0UHVyZTogcHVyZSxcbiAgICAgICAgICAgIG5leHRSdGw6IHJ0bCxcbiAgICAgICAgICAgIG5leHRXYXJuaW5nOiB3YXJuaW5nXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICB0aGlzLnNldE1vbWVudExvY2FsZSh0aGlzLnByb3BzLmxvY2FsZSk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMubG9jYWxlICE9PSBuZXh0UHJvcHMubG9jYWxlKSB7XG4gICAgICAgICAgICB0aGlzLnNldE1vbWVudExvY2FsZShuZXh0UHJvcHMubG9jYWxlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgY2hpbGRDb250ZXh0Q2FjaGUuYWRkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIGNoaWxkQ29udGV4dENhY2hlLmdldCh0aGlzLCB7fSksIHRoaXMuZ2V0Q2hpbGRDb250ZXh0KCkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGNoaWxkQ29udGV4dENhY2hlLnJlbW92ZSh0aGlzKTtcbiAgICB9XG5cbiAgICBzZXRNb21lbnRMb2NhbGUobG9jYWxlKSB7XG4gICAgICAgIGxldCBtb21lbnQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50ICYmIGxvY2FsZSkge1xuICAgICAgICAgICAgbW9tZW50LmxvY2FsZShsb2NhbGUubW9tZW50TG9jYWxlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIENoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb25maWdQcm92aWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb25maWctcHJvdmlkZXIvaW5kZXguanN4IiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IpIHtcblx0XHRpZiAodHlwZW9mIG1lbW9bc2VsZWN0b3JdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRtZW1vW3NlbGVjdG9yXSA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtZW1vW3NlbGVjdG9yXVxuXHR9O1xufSkoZnVuY3Rpb24gKHRhcmdldCkge1xuXHRyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpXG59KTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24pIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG5cdGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUgNiA3IDggOSAxMCAxMSAxMiAxMyAxNCAxNSAxNiAxNyAxOCAxOSAyMCAyMSAyMiIsImNvbnN0IGJsYWNrTGlzdCA9IFsnZGVmYXVsdFByb3BzJywgJ3Byb3BUeXBlcycsICdjb250ZXh0VHlwZXMnLCAnY2hpbGRDb250ZXh0VHlwZXMnLCAnZGlzcGxheU5hbWUnXTtcblxuZXhwb3J0IGNvbnN0IHN0YXRpY3MgPSAoVGFyZ2V0LCBDb21wb25lbnQpID0+IHtcbiAgICBPYmplY3Qua2V5cyhDb21wb25lbnQpLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgICAgICBpZiAoYmxhY2tMaXN0LmluZGV4T2YocHJvcGVydHkpID09PSAtMSkge1xuICAgICAgICAgICAgVGFyZ2V0W3Byb3BlcnR5XSA9IENvbXBvbmVudFtwcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBmZXRjaERhdGFCeVBhdGggPSAob2JqZWN0LCBwYXRoKSA9PiB7XG4gICAgaWYgKCFvYmplY3QgfHwgIXBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBwYXRoID0gcGF0aC50b1N0cmluZygpO1xuICAgIGNvbnN0IGZpZWxkID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIGxldCB2YWwsIGtleTtcbiAgICBpZiAoZmllbGQubGVuZ3RoKSB7XG4gICAgICAgIGtleSA9IGZpZWxkWzBdO1xuICAgICAgICAvLyBsaXN0c1sxXS5uYW1lXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZignWycpID49IDApIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5tYXRjaCgvKC4qKVxcWyguKilcXF0vKTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBvYmplY3Rba2V5WzFdXVtrZXlbMl1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gb2JqZWN0W2ZpZWxkWzBdXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2xJbmRleCA9IDE7IGNvbEluZGV4IDwgZmllbGQubGVuZ3RoOyBjb2xJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gdmFsW2ZpZWxkW2NvbEluZGV4XV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS91dGlsLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgQ29uZmlnUHJvdmlkZXIgZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyJztcblxuLyoqXG4gKiBJY29uXG4gKi9cbmNsYXNzIEljb24gZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaMh+WumuaYvuekuuWTquenjeWbvuagh1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaMh+WumuWbvuagh+Wkp+Wwj1xuICAgICAgICAgKi9cbiAgICAgICAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsneHhzJywgJ3hzJywgJ3NtYWxsJywgJ21lZGl1bScsICdsYXJnZScsICd4bCcsICd4eGwnLCAneHh4bCddKSxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBwcmVmaXg6ICduZXh0LScsXG4gICAgICAgIHNpemU6ICdtZWRpdW0nXG4gICAgfTtcblxuICAgIHN0YXRpYyBfdHlwZU1hcmsgPSAnaWNvbic7XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzKi9cbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHR5cGUsIHNpemUsIGNsYXNzTmFtZSwgcnRsLCAuLi5vdGhlciB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBjb25zdCBjbGFzc2VzID0gY3goe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1pY29uYF06IHRydWUsXG4gICAgICAgICAgICBbYCR7cHJlZml4fWljb24tJHt0eXBlfWBdOiAhIXR5cGUsXG4gICAgICAgICAgICBbYCR7cHJlZml4fSR7c2l6ZX1gXTogISFzaXplLFxuICAgICAgICAgICAgW2NsYXNzTmFtZV06ICEhY2xhc3NOYW1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChydGwgJiYgWydhcnJvdy1sZWZ0JywgJ2Fycm93LXJpZ2h0JywgJ2Fycm93LWRvdWJsZS1sZWZ0JywgJ2Fycm93LWRvdWJsZS1yaWdodCcsICdzd2l0Y2gnLCAnc29ydGluZycsICdkZXNjZW5kaW5nJywgJ2FzY2VuZGluZyddLmluZGV4T2YodHlwZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBvdGhlci5kaXIgPSAncnRsJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiA8aSB7Li4ub3RoZXJ9IGNsYXNzTmFtZT17Y2xhc3Nlc30gLz47XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb25maWdQcm92aWRlci5jb25maWcoSWNvbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaWNvbi9pbmRleC5qc3giLCJpbXBvcnQgJy4vbWFpbi5zY3NzJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pY29uL3N0eWxlLmpzIiwiaW1wb3J0ICcuL21haW4uc2Nzcyc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYW5pbWF0ZS9zdHlsZS5qcyIsIi8qKlxuICog6I635Y+W5a+56LGh55qE57G75Z6LXG4gKiBAcGFyYW0gIHsqfSBvYmpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqXG4gKiBAZXhhbXBsZVxuICogdHlwZU9mKFtdKSA9PT0gJ0FycmF5J1xuICogdHlwZU9mKCkgPT09ICdVbmRlZmluZWQnXG4gKiB0eXBlT2YoMSkgPT09ICdOdW1iZXInXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0eXBlT2YgKG9iaikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKS5yZXBsYWNlKC9cXFtvYmplY3RcXHN8XS9nLCAnJyk7XG59XG5cbi8qKlxuICog5Yik5pat5piv5ZCm5piv5pWw57uE5oiW57G75pWw57uE5a+56LGhXG4gKiBAcGFyYW0gIHsqfSAgb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICpcbiAqIEBleGFtcGxlXG4gKiBpc0FycmF5TGlrZShbXSkgPT09IHRydWVcbiAqIGlzQXJyYXlMaWtlKGFyZ3VtZW50cykgPT09IHRydWVcbiAqIGlzQXJyYXlMaWtlKHRoaXMucHJvcHMuY2hpbGRyZW4pID09PSB0cnVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5TGlrZSAob2JqKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gISFvYmogJiYgJ2xlbmd0aCcgaW4gb2JqICYmIG9iai5sZW5ndGg7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVPZihvYmopO1xuXG4gICAgcmV0dXJuIHR5cGUgPT09ICdBcnJheScgfHwgbGVuZ3RoID09PSAwIHx8XG4gICAgICAgICh0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW5ndGggPiAwICYmIChsZW5ndGggLSAxKSBpbiBvYmopO1xufVxuXG4vKipcbiAqIOWIpOaWreWvueixoeaYr+WQpuaYr+S4gOS4qnByb21pc2XvvIzljbPmmK/lkKblj6/ku6XnlKgudGhlblxuICogQHBhcmFtICB7Kn0gIG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvbWlzZSAob2JqKSB7XG4gICAgcmV0dXJuICEhb2JqICYmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICog5piv5ZCm5piv5LiA5Liq57qv5YeA55qE5a+56LGhXG4gKiBAcGFyYW0gIHsqfSAgb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHJlZmVyZW5jZSBodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1wbGFpbi1vYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICAgIGlmICh0eXBlT2Yob2JqKSAhPT0gJ09iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGN0b3IgPSBvYmouY29uc3RydWN0b3I7XG5cbiAgICBpZiAodHlwZW9mIGN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHByb3QgPSBjdG9yLnByb3RvdHlwZTtcblxuICAgIGlmICh0eXBlT2YocHJvdCkgIT09ICdPYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXByb3QuaGFzT3duUHJvcGVydHkoJ2lzUHJvdG90eXBlT2YnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICog5a+56LGh5rWF5q+U6L6DXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iakFcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqQlxuICogQHBhcmFtICB7RnVuY3Rpb259ICBbY29tcGFyZV0g5omL5Yqo6LCD55So5pa55rOV5q+U6L6DXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIOWvueixoea1heavlOi+g+aYr+WQpuebuOetiVxuICpcbiAqIEBleGFtcGxlXG4gKiBvYmplY3Quc2hhbGxvd0VxdWFsKHthOiAxMDB9LCB7YTogMTAwfSk7IC8vIHRydWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbCAob2JqQSwgb2JqQiwgY29tcGFyZSkge1xuICAgIGlmIChvYmpBID09PSBvYmpCKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIOWFtuS4reS4gOS4quS4jeaYr29iamVjdO+8jOWImeS4jeebuOetiVxuICAgIGlmICghb2JqQSB8fCAhb2JqQiB8fCAodHlwZW9mIG9iakEgKyB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdG9iamVjdCcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gICAgY29uc3Qga2V5QiA9IE9iamVjdC5rZXlzKG9iakIpO1xuICAgIGNvbnN0IGxlbiA9IGtleUEubGVuZ3RoO1xuXG4gICAgLy8ga2V5IOaVsOmHj+S4jeS4gOiHtOWImeS4jeebuOetiVxuICAgIGlmIChsZW4gIT09IGtleUIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBoYXNDYWxsYmFjayA9IHR5cGVvZiBjb21wYXJlID09PSAnZnVuY3Rpb24nO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlBW2ldO1xuXG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbEEgPSBvYmpBW2tleV07XG4gICAgICAgIGNvbnN0IHZhbEIgPSBvYmpCW2tleV07XG5cbiAgICAgICAgY29uc3QgcmV0ID0gaGFzQ2FsbGJhY2sgPyBjb21wYXJlKHZhbEEsIHZhbEIsIGtleSkgOiB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UgfHwgcmV0ID09PSB2b2lkIDAgJiYgdmFsQSAhPT0gdmFsQikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICog6YGN5Y6G5a+56LGh5oiW5pWw57uE77yM5oiW6ICF57G75pWw57uE77yM5L6L5aaCUmVhY3TkuK3nmoRjaGlsZHJlbuWvueixoeOAgWFyZ3VtZW50c+etiVxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fSAgIG9ialxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIGZuKG4sIGkpIG9yIGZuKHZhbCwga2V5KVxuICogQHBhcmFtICB7TnVtYmVyfSAgIFtkaXJlY3Rpb24gPSAxXSDmmK/lkKblgJLluo/pgY3ljobvvIzlj6rlr7nmlbDnu4TmnInmlYhcbiAqIEByZXR1cm4ge09iamVjdHxBcnJheX1cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8g6YGN5Y6G5pWw57uEXG4gKiBvYmplY3QuZWFjaChbMTAwLCAyMDAsIDMwMF0sIChuLCBpKSA9PiBjb25zb2xlLmxvZyhuLCBpKSk7XG4gKiAvLyDpgY3ljoZqc29u5a+56LGhXG4gKiBvYmplY3QuZWFjaCh7YTogMTAwLCBiOiAyMDB9LCAodmFsdWUsIGtleSkgPT4gY29uc29sZS5sb2coa2V5LCB2YWx1ZSkpO1xuICogLy8g6YGN5Y6GUmVhY3TlrZDoioLngrlcbiAqIG9iamVjdC5lYWNoKHRoaXMucHJvcHMuY2hpbGRyZW4sIChjaGlsZCwgaW5kZXgpID0+IGNvbnNvbGUubG9nKGNoaWxkKSk7XG4gKiAvLyDpgY3ljoZhcmd1bWVudHNcbiAqIG9iamVjdC5lYWNoKGFyZ3VtZW50cywgKGFyZywgaSkgPT4gY29uc29sZS5sb2coYXJnKSk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWNoIChvYmosIGNhbGxiYWNrLCBkaXJlY3Rpb24pIHtcbiAgICBjb25zdCByZXZlcnNlZCA9IGRpcmVjdGlvbiA9PT0gLTE7XG4gICAgY29uc3QgbGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICBsZXQgdmFsdWUsXG4gICAgICAgIGkgPSByZXZlcnNlZCA/IGxlbmd0aCAtIDEgOiAwO1xuXG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGggJiYgaSA+PSAwOyByZXZlcnNlZCA/IGktLSA6IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9ialtpXSwgb2JqW2ldLCBpKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqW2ldLCBvYmpbaV0sIGkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufVxuXG4vLyBAcHJpdmF0ZSDliKTmlq1rZXnmmK/lkKblnKjmlbDnu4TmiJblr7nosaHkuK1cbmNvbnN0IF9pc0luT2JqID0gKGtleSwgb2JqLCBpc0FycmF5KSA9PiBpc0FycmF5ID8gKG9iai5pbmRleE9mKGtleSkgPiAtMSkgIDogKGtleSBpbiBvYmopO1xuXG4vKipcbiAqIOi/h+a7pOWHuuWFtuWug+WxnuaAp1xuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fSBob2xkUHJvcHMg6L+H5ruk55qE5Y+C54Wn5a+56LGh77yM5pyA57uI55qE57uT5p6c5Y+q5L+d55WZ5LiN5Zyo5Y+C54Wn5a+56LGh5Lit55qEa2V5XG4gKiBAcGFyYW0gIHtPYmplY3R9IHByb3BzICAgICDooqvov4fmu6TnmoTlr7nosaFcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgIG90aGVyc1xuICpcbiAqIEBleGFtcGxlXG4gKiBvYmplY3QucGlja090aGVycyhGb29Db21wb25lbnQucHJvcFR5cGVzLCB0aGlzLnByb3BzKTtcbiAqIG9iamVjdC5waWNrT3RoZXJzKFsnY2xhc3NOYW1lJywgJ29uQ2hhbmdlJ10sIHRoaXMucHJvcHMpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGlja090aGVycyAoaG9sZFByb3BzLCBwcm9wcykge1xuICAgIGNvbnN0IG90aGVycyA9IHt9O1xuICAgIGNvbnN0IGlzQXJyYXkgPSB0eXBlT2YoaG9sZFByb3BzKSA9PT0gJ0FycmF5JztcblxuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgIGlmICghX2lzSW5PYmooa2V5LCBob2xkUHJvcHMsIGlzQXJyYXkpKSB7XG4gICAgICAgICAgICBvdGhlcnNba2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3RoZXJzO1xufVxuXG4vKipcbiAqIOi/h+a7pOWHuuW4pnByZWZpeOeahOWxnuaAp1xuICogQHBhcmFtICB7T2JqZWN0fSBob2xkUHJvcHMg6L+H5ruk55qE5Y+C54Wn5a+56LGh77yM5pyA57uI55qE57uT5p6c5Y+q5L+d55WZ5LiN5Zyo5Y+C54Wn5a+56LGh5Lit55qEa2V5XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHByZWZpeCAgICDljIXlkKvnmoTlrZfnrKbkuLJcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgIG90aGVyc1xuICpcbiAqIEBleGFtcGxlXG4gKiBvYmplY3QucGlja0F0dHJzV2l0aChGb29Db21wb25lbnQucHJvcFR5cGVzLCAnZGF0YS0nKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBpY2tBdHRyc1dpdGggKGhvbGRQcm9wcywgcHJlZml4KSB7XG4gICAgY29uc3Qgb3RoZXJzID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBob2xkUHJvcHMpIHtcbiAgICAgICAgaWYgKGtleS5tYXRjaChwcmVmaXgpKSB7XG4gICAgICAgICAgICBvdGhlcnNba2V5XSA9IGhvbGRQcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG90aGVycztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlsL29iamVjdC5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIENoaWxkcmVuLCBpc1ZhbGlkRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBmdW5jLCBvYmogfSBmcm9tICcuLi8uLi91dGlsJztcblxuY29uc3QgeyBiaW5kQ3R4IH0gPSBmdW5jO1xuY29uc3QgeyBwaWNrT3RoZXJzIH0gPSBvYmo7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEl0ZW0gZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIF9rZXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGxldmVsOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBncm91cEluZGVudDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgcm9vdDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgcGFyZW50OiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBwYXJlbnRNb2RlOiBQcm9wVHlwZXMub25lT2YoWydpbmxpbmUnLCAncG9wdXAnXSksXG4gICAgICAgIHR5cGU6IFByb3BUeXBlcy5vbmVPZihbJ3N1Ym1lbnUnLCAnaXRlbSddKSxcbiAgICAgICAgY29tcG9uZW50OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uS2V5RG93bjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG5lZWRJbmRlbnQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICByZXBsYWNlQ2xhc3NOYW1lOiBQcm9wVHlwZXMuYm9vbFxuICAgIH1cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGNvbXBvbmVudDogJ2xpJyxcbiAgICAgICAgZ3JvdXBJbmRlbnQ6IDAsXG4gICAgICAgIHJlcGxhY2VDbGFzc05hbWU6IGZhbHNlLFxuICAgICAgICBuZWVkSW5kZW50OiB0cnVlXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICBiaW5kQ3R4KHRoaXMsIFsnaGFuZGxlQ2xpY2snLCAnaGFuZGxlS2V5RG93biddKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5pdGVtTm9kZSA9IGZpbmRET01Ob2RlKHRoaXMpO1xuXG4gICAgICAgIGNvbnN0IHsgcGFyZW50TW9kZSwgcm9vdCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKHBhcmVudE1vZGUgPT09ICdwb3B1cCcpIHtcbiAgICAgICAgICAgIHRoaXMubWVudU5vZGUgPSB0aGlzLml0ZW1Ob2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lbnVOb2RlID0gZmluZERPTU5vZGUocm9vdCk7XG4gICAgICAgICAgICBjb25zdCB7IHByZWZpeCwgaGVhZGVyLCBmb290ZXIgfSA9IHJvb3QucHJvcHM7XG4gICAgICAgICAgICBpZiAoaGVhZGVyIHx8IGZvb3Rlcikge1xuICAgICAgICAgICAgICAgIHRoaXMubWVudU5vZGUgPSB0aGlzLm1lbnVOb2RlLnF1ZXJ5U2VsZWN0b3IoYC4ke3ByZWZpeH1tZW51LWNvbnRlbnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0Rm9jdXMoKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuc2V0Rm9jdXMoKTtcbiAgICB9XG5cbiAgICBmb2N1c2FibGUoKSB7XG4gICAgICAgIGNvbnN0IHsgcm9vdCwgdHlwZSwgZGlzYWJsZWQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgZm9jdXNhYmxlIH0gPSByb290LnByb3BzO1xuICAgICAgICByZXR1cm4gZm9jdXNhYmxlICYmICh0eXBlID09PSAnc3VibWVudScgfHwgIWRpc2FibGVkKTtcbiAgICB9XG5cbiAgICBnZXRGb2N1c2VkKCkge1xuICAgICAgICBjb25zdCB7IF9rZXksIHJvb3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgZm9jdXNlZEtleSB9ID0gcm9vdC5zdGF0ZTtcbiAgICAgICAgcmV0dXJuIGZvY3VzZWRLZXkgPT09IF9rZXk7XG4gICAgfVxuXG4gICAgc2V0Rm9jdXMoKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzZWQgPSB0aGlzLmdldEZvY3VzZWQoKTtcbiAgICAgICAgaWYgKGZvY3VzZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvY3VzYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtTm9kZS5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tZW51Tm9kZSAmJiB0aGlzLm1lbnVOb2RlLnNjcm9sbEhlaWdodCA+IHRoaXMubWVudU5vZGUuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsQm90dG9tID0gdGhpcy5tZW51Tm9kZS5jbGllbnRIZWlnaHQgKyB0aGlzLm1lbnVOb2RlLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtQm90dG9tID0gdGhpcy5pdGVtTm9kZS5vZmZzZXRUb3AgKyB0aGlzLml0ZW1Ob2RlLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbUJvdHRvbSA+IHNjcm9sbEJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbnVOb2RlLnNjcm9sbFRvcCA9IGl0ZW1Cb3R0b20gLSB0aGlzLm1lbnVOb2RlLmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXRlbU5vZGUub2Zmc2V0VG9wIDwgdGhpcy5tZW51Tm9kZS5zY3JvbGxUb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW51Tm9kZS5zY3JvbGxUb3AgPSB0aGlzLml0ZW1Ob2RlLm9mZnNldFRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVDbGljayhlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgY29uc3QgeyBfa2V5LCByb290LCBkaXNhYmxlZCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICAgICAgICByb290LmhhbmRsZUl0ZW1DbGljayhfa2V5LCB0aGlzLCBlKTtcblxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNsaWNrICYmIHRoaXMucHJvcHMub25DbGljayhlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZUtleURvd24oZSkge1xuICAgICAgICBjb25zdCB7IF9rZXksIHJvb3QsIHR5cGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmICh0aGlzLmZvY3VzYWJsZSgpKSB7XG4gICAgICAgICAgICByb290LmhhbmRsZUl0ZW1LZXlEb3duKF9rZXksIHR5cGUsIHRoaXMsIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vbktleURvd24gJiYgdGhpcy5wcm9wcy5vbktleURvd24oZSk7XG4gICAgfVxuXG4gICAgZ2V0VGl0bGUoY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGxhYmVsU3RyaW5nID0gJyc7XG5cbiAgICAgICAgY29uc3QgbG9vcCA9IGNoaWxkcmVuID0+IHtcbiAgICAgICAgICAgIENoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpICYmICBjaGlsZC5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICBsb29wKGNoaWxkLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxTdHJpbmcgKz0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgbG9vcChjaGlsZHJlbik7XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsU3RyaW5nO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBsZXZlbCwgcm9vdCwgcmVwbGFjZUNsYXNzTmFtZSwgZ3JvdXBJbmRlbnQsIGNvbXBvbmVudCwgZGlzYWJsZWQsIGNsYXNzTmFtZSwgY2hpbGRyZW4sIG5lZWRJbmRlbnQsIHBhcmVudE1vZGUsIF9rZXkgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IG90aGVycyA9IHBpY2tPdGhlcnMoT2JqZWN0LmtleXMoSXRlbS5wcm9wVHlwZXMpLCB0aGlzLnByb3BzKTtcblxuICAgICAgICBjb25zdCB7IHByZWZpeCwgZm9jdXNhYmxlLCBpbmxpbmVJbmRlbnQsIGl0ZW1DbGFzc05hbWUsIHJ0bCB9ID0gcm9vdC5wcm9wcztcbiAgICAgICAgY29uc3QgZm9jdXNlZCA9IHRoaXMuZ2V0Rm9jdXNlZCgpO1xuXG4gICAgICAgIGNvbnN0IG5ld0NsYXNzTmFtZSA9IHJlcGxhY2VDbGFzc05hbWUgPyBjbGFzc05hbWUgOiBjeCh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fW1lbnUtaXRlbWBdOiB0cnVlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1kaXNhYmxlZGBdOiBkaXNhYmxlZCxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9Zm9jdXNlZGBdOiAhZm9jdXNhYmxlICYmIGZvY3VzZWQsXG4gICAgICAgICAgICBbaXRlbUNsYXNzTmFtZV06ICEhaXRlbUNsYXNzTmFtZSxcbiAgICAgICAgICAgIFtjbGFzc05hbWVdOiAhIWNsYXNzTmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgICBvdGhlcnNbJ2FyaWEtZGlzYWJsZWQnXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlcnMudGFiSW5kZXggPSByb290LnRhYmJhYmxlS2V5ID09PSBfa2V5ID8gJzAnIDogJy0xJztcblxuICAgICAgICBpZiAocGFyZW50TW9kZSA9PT0gJ2lubGluZScgJiYgbGV2ZWwgPiAxICYmIGlubGluZUluZGVudCA+IDAgJiYgbmVlZEluZGVudCkge1xuICAgICAgICAgICAgb3RoZXJzLnN0eWxlID0ge1xuICAgICAgICAgICAgICAgIC4uLihvdGhlcnMuc3R5bGUgfHwge30pLFxuICAgICAgICAgICAgICAgIFtydGwgPyAncGFkZGluZ1JpZ2h0JyA6ICdwYWRkaW5nTGVmdCddOiBgJHsobGV2ZWwgKiBpbmxpbmVJbmRlbnQpIC0gKChncm91cEluZGVudCB8fCAwKSAqIDAuNCAqIGlubGluZUluZGVudCl9cHhgXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFRhZ05hbWUgPSBjb21wb25lbnQ7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxUYWdOYW1lIHJvbGU9XCJtZW51aXRlbVwiXG4gICAgICAgICAgICAgICAgdGl0bGU9e3RoaXMuZ2V0VGl0bGUoY2hpbGRyZW4pfVxuICAgICAgICAgICAgICAgIHsuLi5vdGhlcnN9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtuZXdDbGFzc05hbWV9XG4gICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja31cbiAgICAgICAgICAgICAgICBvbktleURvd249e3RoaXMuaGFuZGxlS2V5RG93bn0+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH1tZW51LWl0ZW0taW5uZXJgfT57Y2hpbGRyZW59PC9kaXY+XG4gICAgICAgICAgICA8L1RhZ05hbWU+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21lbnUvdmlldy9pdGVtLmpzeCIsImltcG9ydCBDb25maWdQcm92aWRlciBmcm9tICcuLi9jb25maWctcHJvdmlkZXInO1xuaW1wb3J0IE92ZXJsYXkgZnJvbSAnLi9vdmVybGF5JztcbmltcG9ydCBHYXRld2F5IGZyb20gJy4vZ2F0ZXdheSc7XG5pbXBvcnQgUG9zaXRpb24gZnJvbSAnLi9wb3NpdGlvbic7XG5pbXBvcnQgUG9wdXAgZnJvbSAnLi9wb3B1cCc7XG5cbk92ZXJsYXkuR2F0ZXdheSA9IEdhdGV3YXk7XG5PdmVybGF5LlBvc2l0aW9uID0gUG9zaXRpb247XG5PdmVybGF5LlBvcHVwID0gQ29uZmlnUHJvdmlkZXIuY29uZmlnKFBvcHVwLCB7XG4gICAgZXhwb3J0TmFtZXM6IFsnb3ZlcmxheSddXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlnUHJvdmlkZXIuY29uZmlnKE92ZXJsYXksIHtcbiAgICBleHBvcnROYW1lczogWydnZXRDb250ZW50JywgJ2dldENvbnRlbnROb2RlJ11cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL292ZXJsYXkvaW5kZXguanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBSb3dDb21wb25lbnQgZnJvbSAnLi9yb3cnO1xuaW1wb3J0IENlbGxDb21wb25lbnQgZnJvbSAnLi9jZWxsJztcblxuY29uc3Qgbm9vcCA9ICgpID0+IHsgfTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQm9keSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgbG9hZGluZzogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGVtcHR5Q29udGVudDogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBwdXJlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgY29tcG9uZW50czogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgZ2V0Q2VsbFByb3BzOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgY2VsbFJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIHByaW1hcnlLZXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGdldFJvd1Byb3BzOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgcm93UmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgZGF0YVNvdXJjZTogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjb21wb25lbnQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNvbEdyb3VwOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBjb2x1bW5zOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIG9uUm93Q2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvblJvd01vdXNlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvblJvd01vdXNlTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBsb2NhbGU6IFByb3BUeXBlcy5vYmplY3RcbiAgICB9XG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgIHByZWZpeDogJ25leHQtJyxcbiAgICAgICAgY29tcG9uZW50czoge30sXG4gICAgICAgIGdldENlbGxQcm9wczogbm9vcCxcbiAgICAgICAgY2VsbFJlZjogbm9vcCxcbiAgICAgICAgcHJpbWFyeUtleTogJ2lkJyxcbiAgICAgICAgZ2V0Um93UHJvcHM6IG5vb3AsXG4gICAgICAgIHJvd1JlZjogbm9vcCxcbiAgICAgICAgZGF0YVNvdXJjZTogW10sXG4gICAgICAgIGNvbXBvbmVudDogJ3Rib2R5JyxcbiAgICAgICAgY29sdW1uczogW11cbiAgICB9XG5cbiAgICBnZXRSb3dSZWYgPSAoaSwgcm93KSA9PiB7XG4gICAgICAgIHRoaXMucHJvcHMucm93UmVmKGksIHJvdyk7XG4gICAgfVxuXG4gICAgb25Sb3dDbGljayA9IChyZWNvcmQsIGluZGV4LCBlKSA9PiB7XG4gICAgICAgIHRoaXMucHJvcHMub25Sb3dDbGljayhyZWNvcmQsIGluZGV4LCBlKTtcbiAgICB9XG5cbiAgICBvblJvd01vdXNlRW50ZXIgPSAocmVjb3JkLCBpbmRleCwgZSkgPT4ge1xuICAgICAgICB0aGlzLnByb3BzLm9uUm93TW91c2VFbnRlcihyZWNvcmQsIGluZGV4LCBlKTtcbiAgICB9XG5cbiAgICBvblJvd01vdXNlTGVhdmUgPSAocmVjb3JkLCBpbmRleCwgZSkgPT4ge1xuICAgICAgICB0aGlzLnByb3BzLm9uUm93TW91c2VMZWF2ZShyZWNvcmQsIGluZGV4LCBlKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8qZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIGNsYXNzTmFtZSwgY2hpbGRyZW4sIGNvbXBvbmVudDogVGFnLCBjb2xHcm91cCwgbG9hZGluZywgZW1wdHlDb250ZW50LCBjb21wb25lbnRzLCBnZXRDZWxsUHJvcHMsXG4gICAgICAgICAgICBwcmltYXJ5S2V5LCBnZXRSb3dQcm9wcywgZGF0YVNvdXJjZSwgY2VsbFJlZiwgY29sdW1ucywgcm93UmVmLCBvblJvd0NsaWNrLCBvblJvd01vdXNlRW50ZXIsIG9uUm93TW91c2VMZWF2ZSwgbG9jYWxlLCBwdXJlLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgY29uc3QgeyBSb3cgPSBSb3dDb21wb25lbnQsIENlbGwgPSBDZWxsQ29tcG9uZW50IH0gPSBjb21wb25lbnRzO1xuICAgICAgICBjb25zdCBlbXB0eSA9IGxvYWRpbmcgPyA8c3Bhbj4mbmJzcDs8L3NwYW4+IDogZW1wdHlDb250ZW50IHx8IGxvY2FsZS5lbXB0eTtcbiAgICAgICAgbGV0IHJvd3MgPSAoPHRyPlxuICAgICAgICAgICAgPHRkIGNvbFNwYW49e2NvbHVtbnMubGVuZ3RofT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLWVtcHR5YH0+e2VtcHR5fTwvZGl2PlxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgPC90cj4pO1xuICAgICAgICBpZiAoVGFnID09PSAnZGl2Jykge1xuICAgICAgICAgICAgcm93cyA9ICg8dGFibGUgcm9sZT1cInRhYmxlXCI+PHRib2R5Pntyb3dzfTwvdGJvZHk+PC90YWJsZT4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhU291cmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgcm93cyA9IGRhdGFTb3VyY2UubWFwKChyZWNvcmQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93UHJvcHMgPSBnZXRSb3dQcm9wcyhyZWNvcmQsIGluZGV4KSB8fCB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCByb3dDbGFzcyA9IHJvd1Byb3BzLmNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3Q6IGluZGV4ID09PSAwLFxuICAgICAgICAgICAgICAgICAgICBsYXN0OiBpbmRleCA9PT0gZGF0YVNvdXJjZS5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgICAgICBbcm93Q2xhc3NdOiByb3dDbGFzc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGFuZGVkID0gcmVjb3JkLl9fZXhwYW5kZWQgPyAnZXhwYW5kZWQnIDogJyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuICg8Um93IGtleT17YCR7cmVjb3JkW3ByaW1hcnlLZXldIHx8IGluZGV4fSR7ZXhwYW5kZWR9YH1cbiAgICAgICAgICAgICAgICAgICAgey4uLnJvd1Byb3BzfVxuICAgICAgICAgICAgICAgICAgICByZWY9e3RoaXMuZ2V0Um93UmVmLmJpbmQodGhpcywgaW5kZXgpfVxuICAgICAgICAgICAgICAgICAgICBjb2xHcm91cD17Y29sR3JvdXB9XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHVtbnN9XG4gICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXk9e3ByaW1hcnlLZXl9XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZD17cmVjb3JkfVxuICAgICAgICAgICAgICAgICAgICByb3dJbmRleD17aW5kZXh9XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeD17cHJlZml4fVxuICAgICAgICAgICAgICAgICAgICBwdXJlPXtwdXJlfVxuICAgICAgICAgICAgICAgICAgICBjZWxsUmVmPXtjZWxsUmVmfVxuICAgICAgICAgICAgICAgICAgICBnZXRDZWxsUHJvcHM9e2dldENlbGxQcm9wc31cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgICAgICAgICAgICAgICAgIENlbGw9e0NlbGx9XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25Sb3dDbGlja31cbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlPXtsb2NhbGV9XG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlcj17dGhpcy5vblJvd01vdXNlRW50ZXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17dGhpcy5vblJvd01vdXNlTGVhdmV9XG4gICAgICAgICAgICAgICAgLz4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICg8VGFnIGNsYXNzTmFtZT17Y2xhc3NOYW1lfSB7Li4ub3RoZXJzfT5cbiAgICAgICAgICAgIHtyb3dzfVxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L1RhZz4pO1xuICAgIH1cbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2Jhc2UvYm9keS5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgb2JqLCBkb20gfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IGZldGNoRGF0YUJ5UGF0aCB9IGZyb20gJy4uL3V0aWwnO1xuXG5jb25zdCBub29wID0gKCkgPT4geyB9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3cgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcHVyZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHByaW1hcnlLZXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY29sdW1uczogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICByZWNvcmQ6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIENlbGw6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICByb3dJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgZ2V0Q2VsbFByb3BzOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uTW91c2VFbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uTW91c2VMZWF2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBjZWxsUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgY29sR3JvdXA6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIGxvY2FsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBwcmVmaXg6ICduZXh0LScsXG4gICAgICAgIHByaW1hcnlLZXk6ICdpZCcsXG4gICAgICAgIGNvbHVtbnM6IFtdLFxuICAgICAgICByZWNvcmQ6IHt9LFxuICAgICAgICBnZXRDZWxsUHJvcHM6IG5vb3AsXG4gICAgICAgIG9uQ2xpY2s6IG5vb3AsXG4gICAgICAgIG9uTW91c2VFbnRlcjogbm9vcCxcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBub29wLFxuICAgICAgICBjZWxsUmVmOiBub29wLFxuICAgICAgICBjb2xHcm91cDoge31cbiAgICB9XG5cbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICBub3RSZW5kZXJDZWxsSW5kZXg6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgbG9ja1R5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2xlZnQnLCAncmlnaHQnXSlcbiAgICB9XG5cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcHMucHVyZSkge1xuICAgICAgICAgICAgY29uc3QgaXNFcXVhbCA9IG9iai5zaGFsbG93RXF1YWwodGhpcy5wcm9wcywgbmV4dFByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiAhaXNFcXVhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG9uQ2xpY2sgPSAoZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlY29yZCwgcm93SW5kZXggfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHRoaXMucHJvcHMub25DbGljayhyZWNvcmQsIHJvd0luZGV4LCBlKTtcbiAgICB9XG5cbiAgICBvbk1vdXNlRW50ZXIgPSAoZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlY29yZCwgcm93SW5kZXggfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHRoaXMub25Sb3dIb3ZlcihyZWNvcmQsIHJvd0luZGV4LCB0cnVlLCBlKTtcbiAgICB9XG5cbiAgICBvbk1vdXNlTGVhdmUgPSAoZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlY29yZCwgcm93SW5kZXggfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHRoaXMub25Sb3dIb3ZlcihyZWNvcmQsIHJvd0luZGV4LCBmYWxzZSwgZSk7XG4gICAgfVxuXG4gICAgb25Sb3dIb3ZlcihyZWNvcmQsIGluZGV4LCBpc0VudGVyLCBlKSB7XG4gICAgICAgIGNvbnN0IHsgb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmUgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBjdXJyZW50Um93ID0gZmluZERPTU5vZGUodGhpcyk7XG4gICAgICAgIGlmIChpc0VudGVyKSB7XG4gICAgICAgICAgICBvbk1vdXNlRW50ZXIocmVjb3JkLCBpbmRleCwgZSk7XG4gICAgICAgICAgICBjdXJyZW50Um93ICYmIGRvbS5hZGRDbGFzcyhjdXJyZW50Um93LCAnaG92ZXJlZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25Nb3VzZUxlYXZlKHJlY29yZCwgaW5kZXgsIGUpO1xuICAgICAgICAgICAgY3VycmVudFJvdyAmJiBkb20ucmVtb3ZlQ2xhc3MoY3VycmVudFJvdywgJ2hvdmVyZWQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlckNlbGxzKHJlY29yZCkge1xuICAgICAgICBjb25zdCB7IENlbGwsIGNvbHVtbnMsIGdldENlbGxQcm9wcywgY2VsbFJlZiwgcHJlZml4LCByb3dJbmRleCwgcHJpbWFyeUtleSwgcHVyZSwgbG9jYWxlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IGxvY2tUeXBlIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiBjb2x1bW5zLm1hcCgoY2hpbGQsIGNvbEluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGFJbmRleCwgYWxpZ24sIHdpZHRoLCAuLi5vdGhlcnMgfSA9IGNoaWxkO1xuXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZldGNoRGF0YUJ5UGF0aChyZWNvcmQsIGRhdGFJbmRleCk7XG4gICAgICAgICAgICBjb25zdCBhdHRycyA9IGdldENlbGxQcm9wcyhyb3dJbmRleCwgY29sSW5kZXgsIGRhdGFJbmRleCwgcmVjb3JkKSB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5ub3RSZW5kZXJDZWxsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaENlbGxJbmRleCA9IHRoaXMuY29udGV4dC5ub3RSZW5kZXJDZWxsSW5kZXgubWFwKGNlbGxJbmRleCA9PiBjZWxsSW5kZXgudG9TdHJpbmcoKSkuaW5kZXhPZihbcm93SW5kZXgsIGNvbEluZGV4XS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hDZWxsSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQubm90UmVuZGVyQ2VsbEluZGV4LnNwbGljZShtYXRjaENlbGxJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHRycy5jb2xTcGFuICYmIGF0dHJzLmNvbFNwYW4gPiAxIHx8IGF0dHJzLnJvd1NwYW4gJiYgYXR0cnMucm93U3BhbiA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXROb3RSZW5kZXJDZWxsSW5kZXgoY29sSW5kZXgsIHJvd0luZGV4LCBhdHRycy5jb2xTcGFuIHx8IDEsIGF0dHJzLnJvd1NwYW4gfHwgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgIGZpcnN0OiBsb2NrVHlwZSAhPT0gJ3JpZ2h0JyAmJiBjb2xJbmRleCA9PT0gMCxcbiAgICAgICAgICAgICAgICBsYXN0OiBsb2NrVHlwZSAhPT0gJ2xlZnQnICYmIChjb2xJbmRleCA9PT0gY29sdW1ucy5sZW5ndGggLSAxIHx8IGNvbEluZGV4ICsgYXR0cnMuY29sU3BhbiA9PT0gY29sdW1ucy5sZW5ndGgpLCAvLyDogIPomZHlkIjlubbljZXlhYPmoLznmoTmg4XlhrVcbiAgICAgICAgICAgICAgICBbY2hpbGQuY2xhc3NOYW1lXTogY2hpbGQuY2xhc3NOYW1lXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICg8Q2VsbCBrZXk9e2NvbEluZGV4fVxuICAgICAgICAgICAgICAgIHsuLi5vdGhlcnN9XG4gICAgICAgICAgICAgICAgey4uLmF0dHJzfVxuICAgICAgICAgICAgICAgIHJlZj17KGNlbGwpID0+IGNlbGxSZWYocm93SW5kZXgsIGNvbEluZGV4LCBjZWxsKX1cbiAgICAgICAgICAgICAgICBwcmVmaXg9e3ByZWZpeH1cbiAgICAgICAgICAgICAgICBwdXJlPXtwdXJlfVxuICAgICAgICAgICAgICAgIHByaW1hcnlLZXk9e3ByaW1hcnlLZXl9XG4gICAgICAgICAgICAgICAgcmVjb3JkPXtyZWNvcmR9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICAgICAgICAgIGNvbEluZGV4PXtjb2xJbmRleH1cbiAgICAgICAgICAgICAgICByb3dJbmRleD17cm93SW5kZXh9XG4gICAgICAgICAgICAgICAgYWxpZ249e2FsaWdufVxuICAgICAgICAgICAgICAgIGxvY2FsZT17bG9jYWxlfVxuICAgICAgICAgICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgICAgIC8+KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2dldE5vdFJlbmRlckNlbGxJbmRleChjb2xJbmRleCwgcm93SW5kZXgsIGNvbFNwYW4sIHJvd1NwYW4pIHtcbiAgICAgICAgY29uc3QgbWF4Q29sSW5kZXggPSBjb2xTcGFuO1xuICAgICAgICBjb25zdCBtYXhSb3dJbmRleCA9IHJvd1NwYW47XG4gICAgICAgIGNvbnN0IG5vdFJlbmRlckNlbGxJbmRleCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heENvbEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF4Um93SW5kZXg7IGorKykge1xuICAgICAgICAgICAgICAgIG5vdFJlbmRlckNlbGxJbmRleC5wdXNoKFtyb3dJbmRleCArIGosIGNvbEluZGV4ICsgaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFtdLnB1c2guYXBwbHkodGhpcy5jb250ZXh0Lm5vdFJlbmRlckNlbGxJbmRleCwgbm90UmVuZGVyQ2VsbEluZGV4KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzKi9cbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIGNsYXNzTmFtZSwgb25DbGljaywgb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmUsIGNvbHVtbnMsIENlbGwsIGdldENlbGxQcm9wcywgcm93SW5kZXgsIHJlY29yZCwgY2hpbGRyZW4sIHByaW1hcnlLZXksIGNlbGxSZWYsIGNvbEdyb3VwLCBwdXJlLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGNscyA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH10YWJsZS1yb3dgXTogdHJ1ZSxcbiAgICAgICAgICAgIFtjbGFzc05hbWVdOiBjbGFzc05hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoPHRyIGNsYXNzTmFtZT17Y2xzfSByb2xlPVwicm93XCIgey4uLm90aGVyc31cbiAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25DbGlja30gb25Nb3VzZUVudGVyPXt0aGlzLm9uTW91c2VFbnRlcn0gb25Nb3VzZUxlYXZlPXt0aGlzLm9uTW91c2VMZWF2ZX0+XG4gICAgICAgICAgICB7dGhpcy5yZW5kZXJDZWxscyhyZWNvcmQpfVxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L3RyPik7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2Jhc2Uvcm93LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBvYmogfSBmcm9tICcuLi8uLi91dGlsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2VsbCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBwdXJlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgcHJpbWFyeUtleTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICByZWNvcmQ6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIHZhbHVlOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBjb2xJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgcm93SW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIHRpdGxlOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICB3aWR0aDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgICAgICBjb250ZXh0OiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBjZWxsOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZWxlbWVudCwgUHJvcFR5cGVzLm5vZGUsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgICAgIGFsaWduOiBQcm9wVHlwZXMub25lT2YoWydsZWZ0JywgJ2NlbnRlcicsICdyaWdodCddKSxcbiAgICAgICAgY29tcG9uZW50OiBQcm9wVHlwZXMub25lT2YoWyd0ZCcsICd0aCcsICdkaXYnXSksXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgaW5uZXJTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgZmlsdGVyTW9kZTogUHJvcFR5cGVzLm9uZU9mKFsnc2luZ2xlJywgJ211bHRpcGxlJ10pLFxuICAgICAgICBmaWx0ZXJzOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIHNvcnRhYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgbG9jazogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgdHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnaGVhZGVyJywgJ2JvZHknXSksXG4gICAgICAgIHJlc2l6YWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIF9fbm9ybWFsaXplZDogUHJvcFR5cGVzLmJvb2xcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBjb21wb25lbnQ6ICd0ZCcsXG4gICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgY2VsbDogKHZhbHVlKSA9PiB2YWx1ZSxcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nXG4gICAgfVxuXG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuICAgICAgICBpZiAobmV4dFByb3BzLnB1cmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzRXF1YWwgPSBvYmouc2hhbGxvd0VxdWFsKHRoaXMucHJvcHMsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gIWlzRXF1YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgICAgICBjb25zdCB7cHJlZml4LCBjbGFzc05hbWUsIGNlbGwsIHZhbHVlLCByZXNpemFibGUsIGNvbEluZGV4LCByb3dJbmRleCwgcmVjb3JkLCBjb250ZXh0LCBhbGlnbiwgc3R5bGUgPSB7fSwgY29tcG9uZW50OiBUYWcsXG4gICAgICAgICAgICBjaGlsZHJlbiwgdGl0bGUsIHdpZHRoLCBpbm5lclN0eWxlLCBwcmltYXJ5S2V5LCBfX25vcm1hbGl6ZWQsIGZpbHRlck1vZGUsIGZpbHRlcnMsIHNvcnRhYmxlLCBsb2NrLCBwdXJlLCAuLi5vdGhlcnN9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgdGFnU3R5bGUgPSB7Li4uc3R5bGV9O1xuICAgICAgICBjb25zdCBjZWxsUHJvcHMgPSB7dmFsdWUsIGluZGV4OiByb3dJbmRleCwgcmVjb3JkLCBjb250ZXh0fTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBjZWxsO1xuICAgICAgICBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQoY29udGVudCkpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBSZWFjdC5jbG9uZUVsZW1lbnQoY29udGVudCwgY2VsbFByb3BzKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQodmFsdWUsIHJvd0luZGV4LCByZWNvcmQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGlnbikge1xuICAgICAgICAgICAgdGFnU3R5bGUudGV4dEFsaWduID0gYWxpZ247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xzID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fXRhYmxlLWNlbGxgXTogdHJ1ZSxcbiAgICAgICAgICAgIFtjbGFzc05hbWVdOiBjbGFzc05hbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuICg8VGFnIHsuLi5vdGhlcnN9IGNsYXNzTmFtZT17Y2xzfSBzdHlsZT17dGFnU3R5bGV9IHJvbGU9XCJncmlkY2VsbFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1jZWxsLXdyYXBwZXJgfSBzdHlsZT17aW5uZXJTdHlsZX0+XG4gICAgICAgICAgICAgICAge2NvbnRlbnR9XG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvVGFnPik7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2Jhc2UvY2VsbC5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBIZWFkZXJDb21wb25lbnQgZnJvbSAnLi4vYmFzZS9oZWFkZXInO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9wcmVmZXItc3RhdGVsZXNzLWZ1bmN0aW9uICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXhlZEhlYWRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjb2xHcm91cDogUHJvcFR5cGVzLmFueVxuICAgIH1cblxuICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIGdldE5vZGU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBsb2NrVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsICdyaWdodCddKVxuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmNvbnRleHQuZ2V0Tm9kZSgnaGVhZGVyJywgZmluZERPTU5vZGUodGhpcykpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIGNsYXNzTmFtZSwgY29sR3JvdXAsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuICg8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtaGVhZGVyLWlubmVyYH0+XG4gICAgICAgICAgICAgICAgPHRhYmxlPlxuICAgICAgICAgICAgICAgICAgICB7Y29sR3JvdXB9XG4gICAgICAgICAgICAgICAgICAgIDxIZWFkZXJDb21wb25lbnQgey4uLm90aGVyc30gcHJlZml4PXtwcmVmaXh9Lz5cbiAgICAgICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2Pik7XG4gICAgfVxufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvZml4ZWQvaGVhZGVyLmpzeCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19wcm9wLXR5cGVzQDE1LjYuMkBwcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsImltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmluZE5vZGUodGFyZ2V0LCBwYXJhbSkge1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQocGFyYW0pO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmaW5kRE9NTm9kZSh0YXJnZXQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9vdmVybGF5L3V0aWxzL2ZpbmQtbm9kZS5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi4vLi4vaWNvbic7XG5pbXBvcnQgeyBmdW5jLCBvYmosIEtFWUNPREUgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCBJdGVtIGZyb20gJy4vaXRlbSc7XG5cbmNvbnN0IHsgYmluZEN0eCB9ID0gZnVuYztcbmNvbnN0IHsgcGlja090aGVycyB9ID0gb2JqO1xuXG4vKipcbiAqIE1lbnUuSXRlbVxuICogQG9yZGVyIDBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VsZWN0YWJsZUl0ZW0gZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBtZW51Q2hpbGRUeXBlID0gJ2l0ZW0nO1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgX2tleTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcm9vdDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgc2VsZWN0ZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBvblNlbGVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGlubGluZUluZGVudDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuemgeeUqFxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5biu5Yqp5paH5pysXG4gICAgICAgICAqL1xuICAgICAgICBoZWxwZXI6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICAvKipcbiAgICAgICAgICog6I+c5Y2V6aG55qCH562+5YaF5a65XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgb25LZXlEb3duOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG5lZWRJbmRlbnQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBoYXNTZWxlY3RlZEljb246IFByb3BUeXBlcy5ib29sXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgbmVlZEluZGVudDogdHJ1ZVxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgYmluZEN0eCh0aGlzLCBbJ2hhbmRsZUtleURvd24nLCAnaGFuZGxlQ2xpY2snXSk7XG4gICAgfVxuXG4gICAgZ2V0U2VsZWN0ZWQoKSB7XG4gICAgICAgIGNvbnN0IHsgX2tleSwgcm9vdCwgc2VsZWN0ZWQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0TW9kZSB9ID0gcm9vdC5wcm9wcztcbiAgICAgICAgY29uc3QgeyBzZWxlY3RlZEtleXMgfSA9IHJvb3Quc3RhdGU7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZCB8fCAoISFzZWxlY3RNb2RlICYmIHNlbGVjdGVkS2V5cy5pbmRleE9mKF9rZXkpID4gLTEpO1xuICAgIH1cblxuICAgIGhhbmRsZVNlbGVjdChlKSB7XG4gICAgICAgIGNvbnN0IHsgX2tleSwgcm9vdCwgb25TZWxlY3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChvblNlbGVjdCkge1xuICAgICAgICAgICAgb25TZWxlY3QoIXRoaXMuZ2V0U2VsZWN0ZWQoKSwgdGhpcywgZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb290LmhhbmRsZVNlbGVjdChfa2V5LCAhdGhpcy5nZXRTZWxlY3RlZCgpLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZUtleURvd24oZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBLRVlDT0RFLlNQQUNFKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNlbGVjdChlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJvcHMub25LZXlEb3duICYmIHRoaXMucHJvcHMub25LZXlEb3duKGUpO1xuICAgIH1cblxuICAgIGhhbmRsZUNsaWNrKGUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3QoZSk7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vbkNsaWNrICYmIHRoaXMucHJvcHMub25DbGljayhlKTtcbiAgICB9XG5cbiAgICByZW5kZXJTZWxlY3RlZEljb24oc2VsZWN0ZWQpIHtcbiAgICAgICAgY29uc3QgeyByb290LCBpbmxpbmVJbmRlbnQsIG5lZWRJbmRlbnQsIGhhc1NlbGVjdGVkSWNvbiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIGhhc1NlbGVjdGVkSWNvbjogcm9vdFNlbGVjdGVkSWNvbiB9ID0gcm9vdC5wcm9wcztcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKCdoYXNTZWxlY3RlZEljb24nIGluIHRoaXMucHJvcHMgPyBoYXNTZWxlY3RlZEljb24gOiByb290U2VsZWN0ZWRJY29uKSAmJiBzZWxlY3RlZCA/XG4gICAgICAgICAgICAgICAgPEljb24gc3R5bGU9e25lZWRJbmRlbnQgJiYgaW5saW5lSW5kZW50ID4gMCA/IHsgbGVmdDogYCR7aW5saW5lSW5kZW50fXB4YCB9IDogbnVsbH0gY2xhc3NOYW1lPXtgJHtwcmVmaXh9bWVudS1pY29uLXNlbGVjdGVkYH0gdHlwZT1cInNlbGVjdFwiIC8+IDpcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IF9rZXksIHJvb3QsIGNsYXNzTmFtZSwgZGlzYWJsZWQsIGhlbHBlciwgY2hpbGRyZW4sIG5lZWRJbmRlbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4IH0gPSByb290LnByb3BzO1xuICAgICAgICBjb25zdCBvdGhlcnMgPSBwaWNrT3RoZXJzKE9iamVjdC5rZXlzKFNlbGVjdGFibGVJdGVtLnByb3BUeXBlcyksIHRoaXMucHJvcHMpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuZ2V0U2VsZWN0ZWQoKTtcblxuICAgICAgICBjb25zdCBuZXdQcm9wcyA9IHtcbiAgICAgICAgICAgIF9rZXksXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICB0eXBlOiAnaXRlbScsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGN4KHtcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4fXNlbGVjdGVkYF06IHNlbGVjdGVkLFxuICAgICAgICAgICAgICAgIFtjbGFzc05hbWVdOiAhIWNsYXNzTmFtZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvbktleURvd246IHRoaXMuaGFuZGxlS2V5RG93bixcbiAgICAgICAgICAgIG9uQ2xpY2s6ICFkaXNhYmxlZCA/IHRoaXMuaGFuZGxlQ2xpY2sgOiB0aGlzLnByb3BzLm9uQ2xpY2ssXG4gICAgICAgICAgICBuZWVkSW5kZW50LFxuICAgICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBzZWxlY3RlZCxcbiAgICAgICAgICAgIC4uLm90aGVyc1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8SXRlbSB7Li4ubmV3UHJvcHN9PlxuICAgICAgICAgICAgICAgIHt0aGlzLnJlbmRlclNlbGVjdGVkSWNvbihzZWxlY3RlZCl9XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtgJHtwcmVmaXh9bWVudS1pdGVtLXRleHRgfT57Y2hpbGRyZW59PC9zcGFuPlxuICAgICAgICAgICAgICAgIHtoZWxwZXIgPyA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fW1lbnUtaXRlbS1oZWxwZXJgfT57aGVscGVyfTwvZGl2PiA6IG51bGx9XG4gICAgICAgICAgICA8L0l0ZW0+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21lbnUvdmlldy9zZWxlY3RhYmxlLWl0ZW0uanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbi8qKlxuICogVGFibGUuQ29sdW1uXG4gKiBAb3JkZXIgMFxuICoqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sdW1uIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmjIflrprliJflr7nlupTnmoTlrZfmrrXvvIzmlK/mjIFgYS5iYOW9ouW8j+eahOW/q+mAn+WPluWAvFxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YUluZGV4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog6KGM5riy5p+T55qE6YC76L6RXG4gICAgICAgICAqIHZhbHVlLCByb3dJbmRleCwgcmVjb3JkLCBjb250ZXh05Zub5Liq5bGe5oCn5Y+q5Y+v6K+75LiN5Y+v6KKr5pu05pS5XG4gICAgICAgICAqIEZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgcmVjb3JkKSA9PiBFbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBjZWxsOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZWxlbWVudCwgUHJvcFR5cGVzLm5vZGUsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDooajlpLTmmL7npLrnmoTlhoXlrrlcbiAgICAgICAgICogdmFsdWUsIHJvd0luZGV4LCByZWNvcmQsIGNvbnRleHTlm5vkuKrlsZ7mgKflj6rlj6/or7vkuI3lj6/ooqvmm7TmlLlcbiAgICAgICAgICovXG4gICAgICAgIHRpdGxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZWxlbWVudCwgUHJvcFR5cGVzLm5vZGUsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbmlK/mjIHmjpLluo9cbiAgICAgICAgICovXG4gICAgICAgIHNvcnRhYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIl+Wuve+8jOazqOaEj+WcqOmUgeWIl+eahOaDheWGteS4i+S4gOWumumcgOimgemFjee9ruWuveW6plxuICAgICAgICAgKi9cbiAgICAgICAgd2lkdGg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWNleWFg+agvOeahOWvuem9kOaWueW8j1xuICAgICAgICAgKi9cbiAgICAgICAgYWxpZ246IFByb3BUeXBlcy5vbmVPZihbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog55Sf5oiQ5qCH6aKY6L+H5ruk55qE6I+c5Y2VLCDmoLzlvI/kuLpgW3tsYWJlbDoneHh4JywgdmFsdWU6J3h4eCd9XWBcbiAgICAgICAgICovXG4gICAgICAgIGZpbHRlcnM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICAgICAgICBsYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgICAgIHZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubm9kZSwgUHJvcFR5cGVzLnN0cmluZ10pXG4gICAgICAgIH0pKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOi/h+a7pOeahOaooeW8j+aYr+WNlemAiei/mOaYr+WkmumAiVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsdGVyTW9kZTogUHJvcFR5cGVzLm9uZU9mKFsnc2luZ2xlJywgJ211bHRpcGxlJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5pSv5oyB6ZSB5YiXLOWPr+mAieWAvOS4umBsZWZ0YCxgcmlnaHRgLCBgdHJ1ZWBcbiAgICAgICAgICovXG4gICAgICAgIGxvY2s6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbmlK/mjIHliJflrr3osIPmlbQsIOW9k+ivpeWAvOiuvuS4unRydWXvvIx0YWJsZeeahOW4g+WxgOaWueW8j+S8muS/ruaUueS4umZpeGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXphYmxlOiBQcm9wVHlwZXMuYm9vbFxuICAgIH1cblxuICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIHBhcmVudDogUHJvcFR5cGVzLmFueVxuICAgIH1cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGNlbGw6ICh2YWx1ZSkgPT4gdmFsdWUsXG4gICAgICAgIGZpbHRlck1vZGU6ICdtdWx0aXBsZScsXG4gICAgICAgIHJlc2l6YWJsZTogZmFsc2VcbiAgICB9XG5cbiAgICBzdGF0aWMgX3R5cGVNYXJrID0gJ2NvbHVtbic7XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9jb2x1bW4uanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3ByZWZlci1zdGF0ZWxlc3MtZnVuY3Rpb24gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpeGVkV3JhcHBlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY29sR3JvdXA6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIHdyYXBwZXJDb250ZW50OiBQcm9wVHlwZXMuYW55XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgd3JhcHBlckNvbnRlbnQsIHByZWZpeCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuICg8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLWlubmVyYH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICB7d3JhcHBlckNvbnRlbnR9XG4gICAgICAgIDwvZGl2Pik7XG4gICAgfVxufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvZml4ZWQvd3JhcHBlci5qc3giLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGNoYXJzZXQgXFxcIlVURi04XFxcIjtcXG4vKipcXG4gKiDlsLrlr7gg5Z+656GA5bC65a+4XFxuICog5ZG95ZCN6IO95Zyo6K+t5LmJ55qE5YmN5o+Q5LiL566A5Y2V5bCx5bC96YeP566A5Y2VLCDov5nph4zlj6/ku6XmmK8gc2l6ZS0yeCwgc3BhY2UtMngsIHNpemUtYmFzZSAuLi5cXG4gKiDkuI3ov4flj6/ku6XlnKjor63kuYnnmoTliY3mj5DkuIvlgZrnmoTmm7Tnsr7nroDkuIDkupssIOS6juaYr+eUqOS6hnMyLCBzMeetiVxcbiAqIOWPr+eUqOWPmOmHjzogYCRzMSAtICRzOGBcXG4gKiBAZXhhbXBsZSBzY3NzIC0g5L2/55SoXFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6ICRzMSAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKlxcbiAqIEBleGFtcGxlIGNzcyAtIENTUyDovpPlh7pcXG4gKiAgIC5lbGVtZW50IHtcXG4gKiAgICAgcGFkZGluZzogNHB4ICFkZWZhdWx0O1xcbiAqICAgfVxcbiAqL1xcbi5uZXh0LWljb25bZGlyPVxcXCJydGxcXFwiXTo6YmVmb3JlIHtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGVZKDE4MGRlZyk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlWSgxODBkZWcpOyB9XFxuXFxuQGZvbnQtZmFjZSB7XFxuICBmb250LWZhbWlseTogTmV4dEljb247XFxuICBzcmM6IHVybChcXFwiLy9hdC5hbGljZG4uY29tL3QvZm9udF81MTU3NzFfZW1jbnM1MDU0eDN3aGZyLmVvdFxcXCIpO1xcbiAgc3JjOiB1cmwoXFxcIi8vYXQuYWxpY2RuLmNvbS90L2ZvbnRfNTE1NzcxX2VtY25zNTA1NHgzd2hmci5lb3Q/I2llZml4XFxcIikgZm9ybWF0KFxcXCJlbWJlZGRlZC1vcGVudHlwZVxcXCIpLCB1cmwoXFxcIi8vYXQuYWxpY2RuLmNvbS90L2ZvbnRfNTE1NzcxX2VtY25zNTA1NHgzd2hmci53b2ZmXFxcIikgZm9ybWF0KFxcXCJ3b2ZmXFxcIiksIHVybChcXFwiLy9hdC5hbGljZG4uY29tL3QvZm9udF81MTU3NzFfZW1jbnM1MDU0eDN3aGZyLnR0ZlxcXCIpIGZvcm1hdChcXFwidHJ1ZXR5cGVcXFwiKSwgdXJsKFxcXCIvL2F0LmFsaWNkbi5jb20vdC9mb250XzUxNTc3MV9lbWNuczUwNTR4M3doZnIuc3ZnI05leHRJY29uXFxcIikgZm9ybWF0KFxcXCJzdmdcXFwiKTsgfVxcblxcbi5uZXh0LWljb24ge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgZm9udC1mYW1pbHk6IE5leHRJY29uO1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xcbiAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XFxuICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlOyB9XFxuICAubmV4dC1pY29uOmJlZm9yZSB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyOyB9XFxuICAubmV4dC1pY29uLXNtaWxlOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTY1RlxcXCI7IH1cXG4gIC5uZXh0LWljb24tY3J5OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTY1RFxcXCI7IH1cXG4gIC5uZXh0LWljb24tc3VjY2VzczpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MEFcXFwiOyB9XFxuICAubmV4dC1pY29uLXdhcm5pbmc6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjBCXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1wcm9tcHQ6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjBDXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1lcnJvcjpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MERcXFwiOyB9XFxuICAubmV4dC1pY29uLWhlbHA6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjczXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1jbG9jazpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MjFcXFwiOyB9XFxuICAubmV4dC1pY29uLXN1Y2Nlc3MtZmlsbGluZzpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2M0FcXFwiOyB9XFxuICAubmV4dC1pY29uLWRlbGV0ZS1maWxsaW5nOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYyM1xcXCI7IH1cXG4gIC5uZXh0LWljb24tZmF2b3JpdGVzLWZpbGxpbmc6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjBFXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1hZGQ6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjU1XFxcIjsgfVxcbiAgLm5leHQtaWNvbi1taW51czpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MDFcXFwiOyB9XFxuICAubmV4dC1pY29uLWFycm93LXVwOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYyNVxcXCI7IH1cXG4gIC5uZXh0LWljb24tYXJyb3ctZG93bjpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2M0RcXFwiOyB9XFxuICAubmV4dC1pY29uLWFycm93LWxlZnQ6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjFEXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1hcnJvdy1yaWdodDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MTlcXFwiOyB9XFxuICAubmV4dC1pY29uLWFycm93LWRvdWJsZS1sZWZ0OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTY1OVxcXCI7IH1cXG4gIC5uZXh0LWljb24tYXJyb3ctZG91YmxlLXJpZ2h0OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTY1RVxcXCI7IH1cXG4gIC5uZXh0LWljb24tc3dpdGNoOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTZCM1xcXCI7IH1cXG4gIC5uZXh0LWljb24tc29ydGluZzpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MzRcXFwiOyB9XFxuICAubmV4dC1pY29uLWRlc2NlbmRpbmc6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjFGXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1hc2NlbmRpbmc6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjFFXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1zZWxlY3Q6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjMyXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1zZW1pLXNlbGVjdDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MzNcXFwiOyB9XFxuICAubmV4dC1pY29uLXNlYXJjaDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2NTZcXFwiOyB9XFxuICAubmV4dC1pY29uLWNsb3NlOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYyNlxcXCI7IH1cXG4gIC5uZXh0LWljb24tZWxsaXBzaXM6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjU0XFxcIjsgfVxcbiAgLm5leHQtaWNvbi1waWN0dXJlOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYzMVxcXCI7IH1cXG4gIC5uZXh0LWljb24tY2FsZW5kYXI6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjA3XFxcIjsgfVxcbiAgLm5leHQtaWNvbi1hc2hiaW46YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjM5XFxcIjsgfVxcbiAgLm5leHQtaWNvbi11cGxvYWQ6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFN0VFXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1kb3dubG9hZDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MjhcXFwiOyB9XFxuICAubmV4dC1pY29uLXNldDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2ODNcXFwiOyB9XFxuICAubmV4dC1pY29uLWVkaXQ6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjNCXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1yZWZyZXNoOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTY3N1xcXCI7IH1cXG4gIC5uZXh0LWljb24tZmlsdGVyOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYyN1xcXCI7IH1cXG4gIC5uZXh0LWljb24tYXR0YWNobWVudDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2NjVcXFwiOyB9XFxuICAubmV4dC1pY29uLWFjY291bnQ6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjA4XFxcIjsgfVxcbiAgLm5leHQtaWNvbi1lbWFpbDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MDVcXFwiOyB9XFxuICAubmV4dC1pY29uLWF0bTpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MDZcXFwiOyB9XFxuICAubmV4dC1pY29uLWxvYWRpbmc6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjQ2XFxcIjtcXG4gICAgLXdlYmtpdC1hbmltYXRpb246IGxvYWRpbmdDaXJjbGUgMXMgaW5maW5pdGUgbGluZWFyO1xcbiAgICAgICAgICAgIGFuaW1hdGlvbjogbG9hZGluZ0NpcmNsZSAxcyBpbmZpbml0ZSBsaW5lYXI7IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgbG9hZGluZ0NpcmNsZSB7XFxuICAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogNTAlIDUwJTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpOyB9XFxuICAxMDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIGxvYWRpbmdDaXJjbGUge1xcbiAgMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XFxuICAgICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogNTAlIDUwJTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfVxcbiAgMTAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogNTAlIDUwJTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfSB9XFxuXFxuLm5leHQtaWNvbi5uZXh0LXh4czpiZWZvcmUge1xcbiAgd2lkdGg6IDhweDtcXG4gIGZvbnQtc2l6ZTogOHB4O1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG5cXG5AbWVkaWEgYWxsIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAwKSBhbmQgKG1pbi1yZXNvbHV0aW9uOiAwLjAwMWRwY20pIHtcXG4gIC5uZXh0LWljb24ubmV4dC14eHMge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC41KTtcXG4gICAgICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDAuNSk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjUpO1xcbiAgICBtYXJnaW4tbGVmdDogLTRweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtNHB4OyB9XFxuICAgIC5uZXh0LWljb24ubmV4dC14eHM6YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTZweDtcXG4gICAgICBmb250LXNpemU6IDE2cHg7IH0gfVxcblxcbi5uZXh0LWljb24ubmV4dC14czpiZWZvcmUge1xcbiAgd2lkdGg6IDEycHg7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcblxcbi5uZXh0LWljb24ubmV4dC1zbWFsbDpiZWZvcmUge1xcbiAgd2lkdGg6IDE2cHg7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcblxcbi5uZXh0LWljb24ubmV4dC1tZWRpdW06YmVmb3JlIHtcXG4gIHdpZHRoOiAyMHB4O1xcbiAgZm9udC1zaXplOiAyMHB4O1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG5cXG4ubmV4dC1pY29uLm5leHQtbGFyZ2U6YmVmb3JlIHtcXG4gIHdpZHRoOiAyNHB4O1xcbiAgZm9udC1zaXplOiAyNHB4O1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG5cXG4ubmV4dC1pY29uLm5leHQteGw6YmVmb3JlIHtcXG4gIHdpZHRoOiAzMnB4O1xcbiAgZm9udC1zaXplOiAzMnB4O1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG5cXG4ubmV4dC1pY29uLm5leHQteHhsOmJlZm9yZSB7XFxuICB3aWR0aDogNDhweDtcXG4gIGZvbnQtc2l6ZTogNDhweDtcXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuXFxuLm5leHQtaWNvbi5uZXh0LXh4eGw6YmVmb3JlIHtcXG4gIHdpZHRoOiA2NHB4O1xcbiAgZm9udC1zaXplOiA2NHB4O1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXI/P3JlZi0tMi0xIS4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWI/P3JlZi0tMi0yIS4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliIS4vc3JjL2ljb24vbWFpbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkgMTAgMTEgMTIgMTMgMTQgMTUgMTYgMTcgMTggMTkgMjAgMjEgMjIiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQC13ZWJraXQta2V5ZnJhbWVzIGZhZGVJbiB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDA7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIGZhZGVJbiB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDA7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxOyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZmFkZUluRG93biB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDBweCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwMHB4KTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDBweCk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIGZhZGVJbkRvd24ge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMTAwcHgpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDBweCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMTAwcHgpOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIGZhZGVJbkxlZnQge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMjBweCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTIwcHgpO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTIwcHgpOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTsgfSB9XFxuXFxuQGtleWZyYW1lcyBmYWRlSW5MZWZ0IHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTIwcHgpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0yMHB4KTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0yMHB4KTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBmYWRlSW5SaWdodCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDIwcHgpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDIwcHgpO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjBweCk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIGZhZGVJblJpZ2h0IHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjBweCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjBweCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgyMHB4KTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBmYWRlSW5VcCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDIwcHgpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDIwcHgpO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMjBweCk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIGZhZGVJblVwIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMjBweCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMjBweCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgyMHB4KTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBmYWRlT3V0IHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDA7IH0gfVxcblxcbkBrZXlmcmFtZXMgZmFkZU91dCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDE7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAwOyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZmFkZU91dERvd24ge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMjBweCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMjBweCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgyMHB4KTsgfSB9XFxuXFxuQGtleWZyYW1lcyBmYWRlT3V0RG93biB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgyMHB4KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWSgyMHB4KTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDIwcHgpOyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZmFkZU91dExlZnQge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTIwcHgpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0yMHB4KTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0yMHB4KTsgfSB9XFxuXFxuQGtleWZyYW1lcyBmYWRlT3V0TGVmdCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMjBweCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTIwcHgpO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTIwcHgpOyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZmFkZU91dFJpZ2h0IHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDIwcHgpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDIwcHgpO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjBweCk7IH0gfVxcblxcbkBrZXlmcmFtZXMgZmFkZU91dFJpZ2h0IHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDIwcHgpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDIwcHgpO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjBweCk7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBmYWRlT3V0VXAge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwMHB4KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMTAwcHgpO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwMHB4KTsgfSB9XFxuXFxuQGtleWZyYW1lcyBmYWRlT3V0VXAge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwMHB4KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMTAwcHgpO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwMHB4KTsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIHpvb21JbiB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZTNkKDAuMywgMC4zLCAwLjMpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZTNkKDAuMywgMC4zLCAwLjMpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlM2QoMC4zLCAwLjMsIDAuMyk7IH1cXG4gIDUwJSB7XFxuICAgIG9wYWNpdHk6IDE7IH0gfVxcblxcbkBrZXlmcmFtZXMgem9vbUluIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlM2QoMC4zLCAwLjMsIDAuMyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlM2QoMC4zLCAwLjMsIDAuMyk7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUzZCgwLjMsIDAuMywgMC4zKTsgfVxcbiAgNTAlIHtcXG4gICAgb3BhY2l0eTogMTsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIHpvb21PdXQge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAxOyB9XFxuICA1MCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUzZCgwLjMsIDAuMywgMC4zKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGUzZCgwLjMsIDAuMywgMC4zKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZTNkKDAuMywgMC4zLCAwLjMpOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMDsgfSB9XFxuXFxuQGtleWZyYW1lcyB6b29tT3V0IHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMTsgfVxcbiAgNTAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlM2QoMC4zLCAwLjMsIDAuMyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlM2QoMC4zLCAwLjMsIDAuMyk7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUzZCgwLjMsIDAuMywgMC4zKTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDA7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBleHBhbmRJbkRvd24ge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7XFxuICAgIC1tcy10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwO1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwO1xcbiAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDsgfSB9XFxuXFxuQGtleWZyYW1lcyBleHBhbmRJbkRvd24ge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7XFxuICAgIC1tcy10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwO1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwO1xcbiAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIGV4cGFuZEluVXAge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7XFxuICAgIC1tcy10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwO1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwO1xcbiAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDsgfSB9XFxuXFxuQGtleWZyYW1lcyBleHBhbmRJblVwIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwO1xcbiAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDtcXG4gICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBleHBhbmRJbldpdGhGYWRlIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDsgfVxcbiAgNDAlIHtcXG4gICAgb3BhY2l0eTogLjE7IH1cXG4gIDUwJSB7XFxuICAgIG9wYWNpdHk6IC45OyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMTsgfSB9XFxuXFxuQGtleWZyYW1lcyBleHBhbmRJbldpdGhGYWRlIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDsgfVxcbiAgNDAlIHtcXG4gICAgb3BhY2l0eTogLjE7IH1cXG4gIDUwJSB7XFxuICAgIG9wYWNpdHk6IC45OyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMTsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIGV4cGFuZE91dFVwIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwO1xcbiAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDtcXG4gICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7IH0gfVxcblxcbkBrZXlmcmFtZXMgZXhwYW5kT3V0VXAge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7XFxuICAgIC1tcy10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwO1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwO1xcbiAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIGV4cGFuZE91dERvd24ge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7XFxuICAgIC1tcy10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwO1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwO1xcbiAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDsgfSB9XFxuXFxuQGtleWZyYW1lcyBleHBhbmRPdXREb3duIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwO1xcbiAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDtcXG4gICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBleHBhbmRPdXRXaXRoRmFkZSB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDE7IH1cXG4gIDcwJSB7XFxuICAgIG9wYWNpdHk6IDA7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAwOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIGV4cGFuZE91dFdpdGhGYWRlIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMTsgfVxcbiAgNzAlIHtcXG4gICAgb3BhY2l0eTogMDsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDA7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBwdWxzZSB7XFxuICBmcm9tIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxKTsgfVxcbiAgMjAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEuMik7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDEuMik7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMS4yKTsgfVxcbiAgdG8ge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIHB1bHNlIHtcXG4gIGZyb20ge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpOyB9XFxuICAyMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMS4yKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGUoMS4yKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjIpOyB9XFxuICB0byB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7IH0gfVxcblxcbi5mYWRlSW4ge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogZmFkZUluO1xcbiAgYW5pbWF0aW9uLW5hbWU6IGZhZGVJbjtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIGFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblxcbi5mYWRlSW5Eb3duIHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGZhZGVJbkRvd247XFxuICBhbmltYXRpb24tbmFtZTogZmFkZUluRG93bjtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIGFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblxcbi5mYWRlSW5MZWZ0IHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGZhZGVJbkxlZnQ7XFxuICBhbmltYXRpb24tbmFtZTogZmFkZUluTGVmdDtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIGFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblxcbi5mYWRlSW5SaWdodCB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBmYWRlSW5SaWdodDtcXG4gIGFuaW1hdGlvbi1uYW1lOiBmYWRlSW5SaWdodDtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIGFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblxcbi5mYWRlSW5VcCB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBmYWRlSW5VcDtcXG4gIGFuaW1hdGlvbi1uYW1lOiBmYWRlSW5VcDtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIGFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblxcbi5mYWRlT3V0IHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGZhZGVPdXQ7XFxuICBhbmltYXRpb24tbmFtZTogZmFkZU91dDtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIGFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjc1NSwgMC4wNSwgMC44NTUsIDAuMDYpO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNik7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cXG4uZmFkZU91dERvd24ge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogZmFkZU91dERvd247XFxuICBhbmltYXRpb24tbmFtZTogZmFkZU91dERvd247XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogMHM7XFxuICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC43NTUsIDAuMDUsIDAuODU1LCAwLjA2KTtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjc1NSwgMC4wNSwgMC44NTUsIDAuMDYpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXFxuLmZhZGVPdXRMZWZ0IHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGZhZGVPdXRMZWZ0O1xcbiAgYW5pbWF0aW9uLW5hbWU6IGZhZGVPdXRMZWZ0O1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNik7XFxuICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC43NTUsIDAuMDUsIDAuODU1LCAwLjA2KTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblxcbi5mYWRlT3V0UmlnaHQge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogZmFkZU91dFJpZ2h0O1xcbiAgYW5pbWF0aW9uLW5hbWU6IGZhZGVPdXRSaWdodDtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIGFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjc1NSwgMC4wNSwgMC44NTUsIDAuMDYpO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNik7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cXG4uZmFkZU91dFVwIHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGZhZGVPdXRVcDtcXG4gIGFuaW1hdGlvbi1uYW1lOiBmYWRlT3V0VXA7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuMnM7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuMnM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogMHM7XFxuICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC43NTUsIDAuMDUsIDAuODU1LCAwLjA2KTtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjc1NSwgMC4wNSwgMC44NTUsIDAuMDYpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXFxuLnpvb21JbiB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiB6b29tSW47XFxuICBhbmltYXRpb24tbmFtZTogem9vbUluO1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXFxuLnpvb21PdXQge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogem9vbU91dDtcXG4gIGFuaW1hdGlvbi1uYW1lOiB6b29tT3V0O1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNik7XFxuICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC43NTUsIDAuMDUsIDAuODU1LCAwLjA2KTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblxcbi5leHBhbmRJbkRvd24ge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogZXhwYW5kSW5Eb3duO1xcbiAgYW5pbWF0aW9uLW5hbWU6IGV4cGFuZEluRG93bjtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIGFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblxcbi5leHBhbmRPdXRVcCB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBleHBhbmRPdXRVcDtcXG4gIGFuaW1hdGlvbi1uYW1lOiBleHBhbmRPdXRVcDtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4xNXM7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuMTVzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXFxuLmV4cGFuZEluVXAge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogZXhwYW5kSW5VcDtcXG4gIGFuaW1hdGlvbi1uYW1lOiBleHBhbmRJblVwO1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXFxuLmV4cGFuZE91dERvd24ge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogZXhwYW5kT3V0RG93bjtcXG4gIGFuaW1hdGlvbi1uYW1lOiBleHBhbmRPdXREb3duO1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjE1cztcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4xNXM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogMHM7XFxuICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cXG4ucHVsc2Uge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogcHVsc2U7XFxuICBhbmltYXRpb24tbmFtZTogcHVsc2U7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogMHM7XFxuICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cXG4uZXhwYW5kLWVudGVyIHtcXG4gIG92ZXJmbG93OiBoaWRkZW47IH1cXG5cXG4uZXhwYW5kLWVudGVyLWFjdGl2ZSB7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAuM3MgZWFzZS1vdXQ7XFxuICB0cmFuc2l0aW9uOiBhbGwgLjNzIGVhc2Utb3V0OyB9XFxuICAuZXhwYW5kLWVudGVyLWFjdGl2ZSA+ICoge1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBleHBhbmRJbldpdGhGYWRlO1xcbiAgICBhbmltYXRpb24tbmFtZTogZXhwYW5kSW5XaXRoRmFkZTtcXG4gICAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4ycztcXG4gICAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjJzO1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAgIGFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogXFxcImZvcndhcmRzXFxcIjtcXG4gICAgYW5pbWF0aW9uLWZpbGwtbW9kZTogXFxcImZvcndhcmRzXFxcIjtcXG4gICAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICAgIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblxcbi5leHBhbmQtbGVhdmUge1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjsgfVxcblxcbi5leHBhbmQtbGVhdmUtYWN0aXZlIHtcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYWxsIC4ycyBlYXNlLW91dDtcXG4gIHRyYW5zaXRpb246IGFsbCAuMnMgZWFzZS1vdXQ7IH1cXG4gIC5leHBhbmQtbGVhdmUtYWN0aXZlID4gKiB7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGV4cGFuZE91dFdpdGhGYWRlO1xcbiAgICBhbmltYXRpb24tbmFtZTogZXhwYW5kT3V0V2l0aEZhZGU7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gICAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gICAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuMnM7XFxuICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4ycztcXG4gICAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gICAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IFxcXCJmb3J3YXJkc1xcXCI7XFxuICAgIGFuaW1hdGlvbi1maWxsLW1vZGU6IFxcXCJmb3J3YXJkc1xcXCI7XFxuICAgIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXI/P3JlZi0tMi0xIS4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWI/P3JlZi0tMi0yIS4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliIS4vc3JjL2FuaW1hdGUvbWFpbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkgMTAgMTEgMTIgMTMgMTQgMTUgMTYgMTcgMTggMTkgMjAgMjEgMjIiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGNoYXJzZXQgXFxcIlVURi04XFxcIjtcXG4vKipcXG4gKiDlsLrlr7gg5Z+656GA5bC65a+4XFxuICog5ZG95ZCN6IO95Zyo6K+t5LmJ55qE5YmN5o+Q5LiL566A5Y2V5bCx5bC96YeP566A5Y2VLCDov5nph4zlj6/ku6XmmK8gc2l6ZS0yeCwgc3BhY2UtMngsIHNpemUtYmFzZSAuLi5cXG4gKiDkuI3ov4flj6/ku6XlnKjor63kuYnnmoTliY3mj5DkuIvlgZrnmoTmm7Tnsr7nroDkuIDkupssIOS6juaYr+eUqOS6hnMyLCBzMeetiVxcbiAqIOWPr+eUqOWPmOmHjzogYCRzMSAtICRzOGBcXG4gKiBAZXhhbXBsZSBzY3NzIC0g5L2/55SoXFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6ICRzMSAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKlxcbiAqIEBleGFtcGxlIGNzcyAtIENTUyDovpPlh7pcXG4gKiAgIC5lbGVtZW50IHtcXG4gKiAgICAgcGFkZGluZzogNHB4ICFkZWZhdWx0O1xcbiAqICAgfVxcbiAqL1xcbi8qIHN0eWxlbGludC1kaXNhYmxlIG1heC1uZXN0aW5nLWRlcHRoICovXFxuLm5leHQtY2hlY2tib3gtd3JhcHBlciB7XFxuICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH1cXG4gIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIgKixcXG4gIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIgKjpiZWZvcmUsXFxuICAubmV4dC1jaGVja2JveC13cmFwcGVyICo6YWZ0ZXIge1xcbiAgICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDsgfVxcbiAgLm5leHQtY2hlY2tib3gtd3JhcHBlciAubmV4dC1jaGVja2JveCB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsaW5lLWhlaWdodDogMTtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgfVxcbiAgLm5leHQtY2hlY2tib3gtd3JhcHBlciBpbnB1dFt0eXBlPVxcXCJjaGVja2JveFxcXCJdIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHdpZHRoOiAxNnB4O1xcbiAgICBoZWlnaHQ6IDE2cHg7XFxuICAgIG1hcmdpbjogMDsgfVxcbiAgLm5leHQtY2hlY2tib3gtd3JhcHBlciAubmV4dC1jaGVja2JveC1pbm5lciB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICB3aWR0aDogMTZweDtcXG4gICAgaGVpZ2h0OiAxNnB4O1xcbiAgICBiYWNrZ3JvdW5kOiAjRkZGRkZGO1xcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNDNEM2Q0Y7XFxuICAgIC13ZWJraXQtdHJhbnNpdGlvbjogZWFzZSBhbGwgLjNzIDBzO1xcbiAgICB0cmFuc2l0aW9uOiBlYXNlIGFsbCAuM3MgMHM7XFxuICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICAgIC8qIOmYsuatoue7p+aJv+eItue6pyAqL1xcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IG5vbmU7XFxuICAgICAgICAgICAgYm94LXNoYWRvdzogbm9uZTtcXG4gICAgLyogYm94LXNpemluZzogY29udGVudC1ib3g7ICovIH1cXG4gICAgLm5leHQtY2hlY2tib3gtd3JhcHBlciAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb24ge1xcbiAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwKTtcXG4gICAgICAgICAgLW1zLXRyYW5zZm9ybTogc2NhbGUoMCk7XFxuICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICB0b3A6IDA7XFxuICAgICAgb3BhY2l0eTogMDtcXG4gICAgICBsaW5lLWhlaWdodDogMTZweDtcXG4gICAgICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAwLjNzIGN1YmljLWJlemllcigwLjc4LCAwLjE0LCAwLjE1LCAwLjg2KTtcXG4gICAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBjdWJpYy1iZXppZXIoMC43OCwgMC4xNCwgMC4xNSwgMC44Nik7XFxuICAgICAgY29sb3I6ICNGRkZGRkY7XFxuICAgICAgbGVmdDogNHB4O1xcbiAgICAgIG1hcmdpbi1sZWZ0OiAwOyB9XFxuICAgICAgLm5leHQtY2hlY2tib3gtd3JhcHBlciAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb246YmVmb3JlIHtcXG4gICAgICAgIHdpZHRoOiA4cHg7XFxuICAgICAgICBmb250LXNpemU6IDhweDtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgICAgQG1lZGlhIGFsbCBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMCkgYW5kIChtaW4tcmVzb2x1dGlvbjogMC4wMDFkcGNtKSB7XFxuICAgICAgICAubmV4dC1jaGVja2JveC13cmFwcGVyIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbiB7XFxuICAgICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLjUpO1xcbiAgICAgICAgICAgICAgLW1zLXRyYW5zZm9ybTogc2NhbGUoMC41KTtcXG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNSk7XFxuICAgICAgICAgIG1hcmdpbi1sZWZ0OiAtNHB4O1xcbiAgICAgICAgICBtYXJnaW4tcmlnaHQ6IC00cHg7IH1cXG4gICAgICAgICAgLm5leHQtY2hlY2tib3gtd3JhcHBlciAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb246YmVmb3JlIHtcXG4gICAgICAgICAgICB3aWR0aDogMTZweDtcXG4gICAgICAgICAgICBmb250LXNpemU6IDE2cHg7IH0gfVxcbiAgICAubmV4dC1jaGVja2JveC13cmFwcGVyIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbjo6YmVmb3JlIHtcXG4gICAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xcbiAgICAgIG1hcmdpbi10b3A6IDA7IH1cXG4gIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuY2hlY2tlZCAubmV4dC1jaGVja2JveC1pbm5lciB7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM1NTg0RkY7IH1cXG4gICAgLm5leHQtY2hlY2tib3gtd3JhcHBlci5jaGVja2VkIC5uZXh0LWNoZWNrYm94LWlubmVyOmhvdmVyLCAubmV4dC1jaGVja2JveC13cmFwcGVyLmNoZWNrZWQgLm5leHQtY2hlY2tib3gtaW5uZXIuaG92ZXJlZCB7XFxuICAgICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbiAgICAubmV4dC1jaGVja2JveC13cmFwcGVyLmNoZWNrZWQgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uIHtcXG4gICAgICBvcGFjaXR5OiAxO1xcbiAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gICAgICAgICAgLW1zLXRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICAgIC8qIGZvbnQtc2l6ZSA8IDEycHjnmoTml7blgJnov5vooYzopobnm5bjgIIgKi8gfVxcbiAgICAgIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuY2hlY2tlZCAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb246YmVmb3JlIHtcXG4gICAgICAgIHdpZHRoOiA4cHg7XFxuICAgICAgICBmb250LXNpemU6IDhweDtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgICAgQG1lZGlhIGFsbCBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMCkgYW5kIChtaW4tcmVzb2x1dGlvbjogMC4wMDFkcGNtKSB7XFxuICAgICAgICAubmV4dC1jaGVja2JveC13cmFwcGVyLmNoZWNrZWQgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uIHtcXG4gICAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuNSk7XFxuICAgICAgICAgICAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgwLjUpO1xcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC41KTtcXG4gICAgICAgICAgbWFyZ2luLWxlZnQ6IC00cHg7XFxuICAgICAgICAgIG1hcmdpbi1yaWdodDogLTRweDsgfVxcbiAgICAgICAgICAubmV4dC1jaGVja2JveC13cmFwcGVyLmNoZWNrZWQgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uOmJlZm9yZSB7XFxuICAgICAgICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxNnB4OyB9IH1cXG4gIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuaW5kZXRlcm1pbmF0ZSAubmV4dC1jaGVja2JveC1pbm5lciB7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM1NTg0RkY7IH1cXG4gICAgLm5leHQtY2hlY2tib3gtd3JhcHBlci5pbmRldGVybWluYXRlIC5uZXh0LWNoZWNrYm94LWlubmVyOmhvdmVyLCAubmV4dC1jaGVja2JveC13cmFwcGVyLmluZGV0ZXJtaW5hdGUgLm5leHQtY2hlY2tib3gtaW5uZXIuaG92ZXJlZCB7XFxuICAgICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbiAgICAubmV4dC1jaGVja2JveC13cmFwcGVyLmluZGV0ZXJtaW5hdGUgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uIHtcXG4gICAgICBvcGFjaXR5OiAxO1xcbiAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZTNkKDEsIDEsIDEpO1xcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZTNkKDEsIDEsIDEpO1xcbiAgICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICAgIC8qIGZvbnQtc2l6ZSA8IDEycHjnmoTml7blgJnov5vooYzopobnm5bjgIIgKi8gfVxcbiAgICAgIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuaW5kZXRlcm1pbmF0ZSAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb246YmVmb3JlIHtcXG4gICAgICAgIHdpZHRoOiA4cHg7XFxuICAgICAgICBmb250LXNpemU6IDhweDtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgICAgQG1lZGlhIGFsbCBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMCkgYW5kIChtaW4tcmVzb2x1dGlvbjogMC4wMDFkcGNtKSB7XFxuICAgICAgICAubmV4dC1jaGVja2JveC13cmFwcGVyLmluZGV0ZXJtaW5hdGUgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uIHtcXG4gICAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuNSk7XFxuICAgICAgICAgICAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgwLjUpO1xcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC41KTtcXG4gICAgICAgICAgbWFyZ2luLWxlZnQ6IC00cHg7XFxuICAgICAgICAgIG1hcmdpbi1yaWdodDogLTRweDsgfVxcbiAgICAgICAgICAubmV4dC1jaGVja2JveC13cmFwcGVyLmluZGV0ZXJtaW5hdGUgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uOmJlZm9yZSB7XFxuICAgICAgICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxNnB4OyB9IH1cXG4gIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuZGlzYWJsZWQgaW5wdXRbdHlwZT1cXFwiY2hlY2tib3hcXFwiXSB7XFxuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7IH1cXG4gIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuZGlzYWJsZWQgLm5leHQtY2hlY2tib3gtaW5uZXIge1xcbiAgICBib3JkZXItY29sb3I6ICNFNkU3RUI7XFxuICAgIGJhY2tncm91bmQ6ICNGN0Y4RkE7IH1cXG4gIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuZGlzYWJsZWQuY2hlY2tlZCAubmV4dC1jaGVja2JveC1pbm5lcjpob3ZlciwgLm5leHQtY2hlY2tib3gtd3JhcHBlci5kaXNhYmxlZC5jaGVja2VkIC5uZXh0LWNoZWNrYm94LWlubmVyLmhvdmVyZWQsIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuZGlzYWJsZWQuaW5kZXRlcm1pbmF0ZSAubmV4dC1jaGVja2JveC1pbm5lcjpob3ZlciwgLm5leHQtY2hlY2tib3gtd3JhcHBlci5kaXNhYmxlZC5pbmRldGVybWluYXRlIC5uZXh0LWNoZWNrYm94LWlubmVyLmhvdmVyZWQge1xcbiAgICBib3JkZXItY29sb3I6ICNFNkU3RUI7IH1cXG4gIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuZGlzYWJsZWQuY2hlY2tlZCAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb24sIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuZGlzYWJsZWQuaW5kZXRlcm1pbmF0ZSAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb24ge1xcbiAgICBjb2xvcjogI0NDQ0NDQztcXG4gICAgb3BhY2l0eTogMTsgfVxcbiAgLm5leHQtY2hlY2tib3gtd3JhcHBlcjpub3QoLmRpc2FibGVkKTpob3ZlciAubmV4dC1jaGVja2JveC1pbm5lciwgLm5leHQtY2hlY2tib3gtd3JhcHBlci5ob3ZlcmVkIC5uZXh0LWNoZWNrYm94LWlubmVyLCAubmV4dC1jaGVja2JveC13cmFwcGVyLmZvY3VzZWQgLm5leHQtY2hlY2tib3gtaW5uZXIge1xcbiAgICBib3JkZXItY29sb3I6ICM1NTg0RkY7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNERUU4RkY7IH1cXG4gIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuaW5kZXRlcm1pbmF0ZTpub3QoLmRpc2FibGVkKTpob3ZlciAubmV4dC1jaGVja2JveC1pbm5lciwgLm5leHQtY2hlY2tib3gtd3JhcHBlci5pbmRldGVybWluYXRlOm5vdCguZGlzYWJsZWQpLmhvdmVyZWQgLm5leHQtY2hlY2tib3gtaW5uZXIsIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuaW5kZXRlcm1pbmF0ZS5mb2N1c2VkIC5uZXh0LWNoZWNrYm94LWlubmVyLCAubmV4dC1jaGVja2JveC13cmFwcGVyLmNoZWNrZWQ6bm90KC5kaXNhYmxlZCk6aG92ZXIgLm5leHQtY2hlY2tib3gtaW5uZXIsIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuY2hlY2tlZDpub3QoLmRpc2FibGVkKS5ob3ZlcmVkIC5uZXh0LWNoZWNrYm94LWlubmVyLCAubmV4dC1jaGVja2JveC13cmFwcGVyLmNoZWNrZWQuZm9jdXNlZCAubmV4dC1jaGVja2JveC1pbm5lciB7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMzRTcxRjc7IH1cXG4gICAgLm5leHQtY2hlY2tib3gtd3JhcHBlci5pbmRldGVybWluYXRlOm5vdCguZGlzYWJsZWQpOmhvdmVyIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbiwgLm5leHQtY2hlY2tib3gtd3JhcHBlci5pbmRldGVybWluYXRlOm5vdCguZGlzYWJsZWQpLmhvdmVyZWQgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uLCAubmV4dC1jaGVja2JveC13cmFwcGVyLmluZGV0ZXJtaW5hdGUuZm9jdXNlZCAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb24sIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuY2hlY2tlZDpub3QoLmRpc2FibGVkKTpob3ZlciAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb24sIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuY2hlY2tlZDpub3QoLmRpc2FibGVkKS5ob3ZlcmVkIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbiwgLm5leHQtY2hlY2tib3gtd3JhcHBlci5jaGVja2VkLmZvY3VzZWQgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uIHtcXG4gICAgICBjb2xvcjogI0ZGRkZGRjtcXG4gICAgICBvcGFjaXR5OiAxOyB9XFxuXFxuLm5leHQtY2hlY2tib3gtZ3JvdXAgLm5leHQtY2hlY2tib3gtd3JhcHBlciB7XFxuICBtYXJnaW4tbGVmdDogOHB4OyB9XFxuICAubmV4dC1jaGVja2JveC1ncm91cCAubmV4dC1jaGVja2JveC13cmFwcGVyOmZpcnN0LWNoaWxkIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7IH1cXG5cXG4ubmV4dC1jaGVja2JveC1ncm91cC12ZXIgLm5leHQtY2hlY2tib3gtd3JhcHBlciB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIG1hcmdpbi1sZWZ0OiAwO1xcbiAgbWFyZ2luLWJvdHRvbTogOHB4OyB9XFxuXFxuLm5leHQtY2hlY2tib3gtbGFiZWwge1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIG1hcmdpbjogMDtcXG4gIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICBsaW5lLWhlaWdodDogMTsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlcj8/cmVmLS0yLTEhLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYj8/cmVmLS0yLTIhLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIhLi9zcmMvY2hlY2tib3gvbWFpbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkgMTAgMTEgMTIgMTMgMTQgMTUgMTYgMTcgMTggMTkgMjAgMjEgMjIiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGNoYXJzZXQgXFxcIlVURi04XFxcIjtcXG4vKipcXG4gKiDlsLrlr7gg5Z+656GA5bC65a+4XFxuICog5ZG95ZCN6IO95Zyo6K+t5LmJ55qE5YmN5o+Q5LiL566A5Y2V5bCx5bC96YeP566A5Y2VLCDov5nph4zlj6/ku6XmmK8gc2l6ZS0yeCwgc3BhY2UtMngsIHNpemUtYmFzZSAuLi5cXG4gKiDkuI3ov4flj6/ku6XlnKjor63kuYnnmoTliY3mj5DkuIvlgZrnmoTmm7Tnsr7nroDkuIDkupssIOS6juaYr+eUqOS6hnMyLCBzMeetiVxcbiAqIOWPr+eUqOWPmOmHjzogYCRzMSAtICRzOGBcXG4gKiBAZXhhbXBsZSBzY3NzIC0g5L2/55SoXFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6ICRzMSAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKlxcbiAqIEBleGFtcGxlIGNzcyAtIENTUyDovpPlh7pcXG4gKiAgIC5lbGVtZW50IHtcXG4gKiAgICAgcGFkZGluZzogNHB4ICFkZWZhdWx0O1xcbiAqICAgfVxcbiAqL1xcbi5uZXh0LXJhZGlvLWJ1dHRvbi1sYXJnZVtkaXI9J3J0bCddID4gbGFiZWw6Zmlyc3QtY2hpbGQge1xcbiAgbWFyZ2luLWxlZnQ6IC0xcHg7XFxuICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogM3B4O1xcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDNweDtcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDA7XFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwOyB9XFxuXFxuLm5leHQtcmFkaW8tYnV0dG9uLWxhcmdlW2Rpcj0ncnRsJ10gPiBsYWJlbDpsYXN0LWNoaWxkIHtcXG4gIG1hcmdpbi1sZWZ0OiAwO1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMDtcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDNweDtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDNweDsgfVxcblxcbi5uZXh0LXJhZGlvLWJ1dHRvbi1sYXJnZVtkaXI9J3J0bCddIC5uZXh0LXJhZGlvLWxhYmVsIHtcXG4gIGhlaWdodDogMzhweDtcXG4gIGxpbmUtaGVpZ2h0OiAzOHB4O1xcbiAgZm9udC1zaXplOiAxNnB4OyB9XFxuXFxuLm5leHQtcmFkaW8tYnV0dG9uLW1lZGl1bVtkaXI9J3J0bCddID4gbGFiZWw6Zmlyc3QtY2hpbGQge1xcbiAgbWFyZ2luLWxlZnQ6IC0xcHg7XFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMDtcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAzcHg7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogM3B4OyB9XFxuXFxuLm5leHQtcmFkaW8tYnV0dG9uLW1lZGl1bVtkaXI9J3J0bCddID4gbGFiZWw6bGFzdC1jaGlsZCB7XFxuICBtYXJnaW4tbGVmdDogMDtcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAzcHg7XFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAzcHg7IH1cXG5cXG4ubmV4dC1yYWRpby1idXR0b24tc21hbGxbZGlyPSdydGwnXSA+IGxhYmVsOmZpcnN0LWNoaWxkIHtcXG4gIG1hcmdpbi1sZWZ0OiAtMXB4O1xcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxuICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogM3B4O1xcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDNweDsgfVxcblxcbi5uZXh0LXJhZGlvLWJ1dHRvbi1zbWFsbFtkaXI9J3J0bCddID4gbGFiZWw6bGFzdC1jaGlsZCB7XFxuICBtYXJnaW4tbGVmdDogMDtcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAzcHg7XFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAzcHg7IH1cXG5cXG4ubmV4dC1yYWRpby13cmFwcGVyW2Rpcj0ncnRsJ10gLm5leHQtcmFkaW8tbGFiZWwge1xcbiAgbWFyZ2luLWxlZnQ6IDA7XFxuICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcblxcbi5uZXh0LXJhZGlvLWdyb3VwW2Rpcj0ncnRsJ10gLm5leHQtcmFkaW8tbGFiZWwge1xcbiAgbWFyZ2luLXJpZ2h0OiA0cHg7XFxuICBtYXJnaW4tbGVmdDogMTZweDsgfVxcblxcbi5uZXh0LXJhZGlvLWJ1dHRvbltkaXI9J3J0bCddID4gbGFiZWwgLm5leHQtcmFkaW8tbGFiZWwge1xcbiAgbWFyZ2luOiAwOyB9XFxuXFxuLm5leHQtcmFkaW8td3JhcHBlciB7XFxuICBvdXRsaW5lOiAwOyB9XFxuICAubmV4dC1yYWRpby13cmFwcGVyIC5uZXh0LXJhZGlvIHtcXG4gICAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsaW5lLWhlaWdodDogMTsgfVxcbiAgICAubmV4dC1yYWRpby13cmFwcGVyIC5uZXh0LXJhZGlvICosXFxuICAgIC5uZXh0LXJhZGlvLXdyYXBwZXIgLm5leHQtcmFkaW8gKjpiZWZvcmUsXFxuICAgIC5uZXh0LXJhZGlvLXdyYXBwZXIgLm5leHQtcmFkaW8gKjphZnRlciB7XFxuICAgICAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDsgfVxcbiAgICAubmV4dC1yYWRpby13cmFwcGVyIC5uZXh0LXJhZGlvIGlucHV0W3R5cGU9XFxcInJhZGlvXFxcIl0ge1xcbiAgICAgIG9wYWNpdHk6IDA7XFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgICAgdG9wOiAwO1xcbiAgICAgIGxlZnQ6IDA7XFxuICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgaGVpZ2h0OiAxNnB4O1xcbiAgICAgIG1hcmdpbjogMDsgfVxcbiAgLm5leHQtcmFkaW8td3JhcHBlciAubmV4dC1yYWRpby1pbm5lciB7XFxuICAgIC8qIOWKqOeUu+W+heWumiAqL1xcbiAgICAvKiAmLm1vdXNlRG93biB7ICovXFxuICAgIC8qICAgICB0cmFuc2Zvcm06IHNjYWxlM2QoLjcsIC43LCAuNyk7ICovXFxuICAgIC8qICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gLjJzIGxpbmVhcjsgKi9cXG4gICAgLyogfSAqL1xcbiAgICAvKiAmLm1vdXNlVXAgeyAqL1xcbiAgICAvKiAgICAgdHJhbnNmb3JtOiBzY2FsZTNkKDEsIDEsIDEpOyAqL1xcbiAgICAvKiAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIC4ycyBsaW5lYXI7ICovXFxuICAgIC8qIH0gKi9cXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHdpZHRoOiAxNnB4O1xcbiAgICBoZWlnaHQ6IDE2cHg7XFxuICAgIGJhY2tncm91bmQ6ICNGRkZGRkY7XFxuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI0M0QzZDRjtcXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBlYXNlIGFsbCAuMzZzIDBzO1xcbiAgICB0cmFuc2l0aW9uOiBlYXNlIGFsbCAuMzZzIDBzO1xcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IG5vbmU7XFxuICAgICAgICAgICAgYm94LXNoYWRvdzogbm9uZTsgfVxcbiAgICAubmV4dC1yYWRpby13cmFwcGVyIC5uZXh0LXJhZGlvLWlubmVyOmFmdGVyIHtcXG4gICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMCk7XFxuICAgICAgICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDApO1xcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwKTtcXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgICAgIHRvcDogNTAlO1xcbiAgICAgIG1hcmdpbi10b3A6IC0ycHg7XFxuICAgICAgbGVmdDogNTAlO1xcbiAgICAgIG1hcmdpbi1sZWZ0OiAtMnB4O1xcbiAgICAgIGJhY2tncm91bmQ6ICNGRkZGRkY7XFxuICAgICAgY29udGVudDogJyAnO1xcbiAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjogYWxsIDAuM3MgY3ViaWMtYmV6aWVyKDAuNzgsIDAuMTQsIDAuMTUsIDAuODYpO1xcbiAgICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGN1YmljLWJlemllcigwLjc4LCAwLjE0LCAwLjE1LCAwLjg2KTsgfVxcbiAgLm5leHQtcmFkaW8td3JhcHBlci5jaGVja2VkIC5uZXh0LXJhZGlvLWlubmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjNTU4NEZGO1xcbiAgICBiYWNrZ3JvdW5kOiAjNTU4NEZGOyB9XFxuICAgIC5uZXh0LXJhZGlvLXdyYXBwZXIuY2hlY2tlZCAubmV4dC1yYWRpby1pbm5lcjphZnRlciB7XFxuICAgICAgd2lkdGg6IDRweDtcXG4gICAgICBoZWlnaHQ6IDRweDtcXG4gICAgICBmb250LXdlaWdodDogYm9sZDtcXG4gICAgICBiYWNrZ3JvdW5kOiAjRkZGRkZGO1xcbiAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gICAgICAgICAgLW1zLXRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpOyB9XFxuICAubmV4dC1yYWRpby13cmFwcGVyLmNoZWNrZWQ6aG92ZXIgLm5leHQtcmFkaW8taW5uZXIsIC5uZXh0LXJhZGlvLXdyYXBwZXIuY2hlY2tlZC5ob3ZlcmVkIC5uZXh0LXJhZGlvLWlubmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbiAgLm5leHQtcmFkaW8td3JhcHBlci5kaXNhYmxlZCBpbnB1dFt0eXBlPVxcXCJyYWRpb1xcXCJdIHtcXG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDsgfVxcbiAgLm5leHQtcmFkaW8td3JhcHBlci5kaXNhYmxlZCAubmV4dC1yYWRpby1pbm5lciB7XFxuICAgIGJvcmRlci1jb2xvcjogI0U2RTdFQjtcXG4gICAgYmFja2dyb3VuZDogI0Y3RjhGQTsgfVxcbiAgICAubmV4dC1yYWRpby13cmFwcGVyLmRpc2FibGVkIC5uZXh0LXJhZGlvLWlubmVyOmhvdmVyLCAubmV4dC1yYWRpby13cmFwcGVyLmRpc2FibGVkIC5uZXh0LXJhZGlvLWlubmVyLmhvdmVyZWQge1xcbiAgICAgIGJvcmRlci1jb2xvcjogI0U2RTdFQjsgfVxcbiAgLm5leHQtcmFkaW8td3JhcHBlci5kaXNhYmxlZC5jaGVja2VkIC5uZXh0LXJhZGlvLWlubmVyOmFmdGVyIHtcXG4gICAgYmFja2dyb3VuZDogI0NDQ0NDQzsgfVxcbiAgLm5leHQtcmFkaW8td3JhcHBlcjpub3QoLmRpc2FibGVkKTpob3ZlciAubmV4dC1yYWRpby1pbm5lciwgLm5leHQtcmFkaW8td3JhcHBlcjpub3QoLmRpc2FibGVkKS5ob3ZlcmVkIC5uZXh0LXJhZGlvLWlubmVyLCAubmV4dC1yYWRpby13cmFwcGVyOm5vdCguZGlzYWJsZWQpOmZvY3VzIC5uZXh0LXJhZGlvLWlubmVyLCAubmV4dC1yYWRpby13cmFwcGVyOm5vdCguZGlzYWJsZWQpLmZvY3VzZWQgLm5leHQtcmFkaW8taW5uZXIge1xcbiAgICBib3JkZXItY29sb3I6ICM1NTg0RkY7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNERUU4RkY7IH1cXG4gIC5uZXh0LXJhZGlvLXdyYXBwZXIuY2hlY2tlZDpub3QoLmRpc2FibGVkKTpob3ZlciAubmV4dC1yYWRpby1pbm5lciwgLm5leHQtcmFkaW8td3JhcHBlci5jaGVja2VkOm5vdCguZGlzYWJsZWQpLmhvdmVyZWQgLm5leHQtcmFkaW8taW5uZXIsIC5uZXh0LXJhZGlvLXdyYXBwZXIuY2hlY2tlZDpub3QoLmRpc2FibGVkKTpmb2N1cyAubmV4dC1yYWRpby1pbm5lciwgLm5leHQtcmFkaW8td3JhcHBlci5jaGVja2VkLmZvY3VzZWQgLm5leHQtcmFkaW8taW5uZXIge1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICBiYWNrZ3JvdW5kOiAjM0U3MUY3OyB9XFxuICAgIC5uZXh0LXJhZGlvLXdyYXBwZXIuY2hlY2tlZDpub3QoLmRpc2FibGVkKTpob3ZlciAubmV4dC1yYWRpby1pbm5lcjphZnRlciwgLm5leHQtcmFkaW8td3JhcHBlci5jaGVja2VkOm5vdCguZGlzYWJsZWQpLmhvdmVyZWQgLm5leHQtcmFkaW8taW5uZXI6YWZ0ZXIsIC5uZXh0LXJhZGlvLXdyYXBwZXIuY2hlY2tlZDpub3QoLmRpc2FibGVkKTpmb2N1cyAubmV4dC1yYWRpby1pbm5lcjphZnRlciwgLm5leHQtcmFkaW8td3JhcHBlci5jaGVja2VkLmZvY3VzZWQgLm5leHQtcmFkaW8taW5uZXI6YWZ0ZXIge1xcbiAgICAgIGJhY2tncm91bmQ6ICNGRkZGRkY7IH1cXG5cXG4ubmV4dC1yYWRpby1idXR0b24gLm5leHQtcmFkaW8ge1xcbiAgd2lkdGg6IDA7XFxuICBoZWlnaHQ6IDA7IH1cXG5cXG4ubmV4dC1yYWRpby1idXR0b24gaW5wdXRbdHlwZT1cXFwicmFkaW9cXFwiXSB7XFxuICB3aWR0aDogMDtcXG4gIGhlaWdodDogMDsgfVxcblxcbi5uZXh0LXJhZGlvLWJ1dHRvbiA+IGxhYmVsIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHotaW5kZXg6IDE7XFxuICBtYXJnaW46IDAgMCAwIC0xcHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjQzRDNkNGO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRjtcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogZWFzZSBhbGwgLjNzIDBzO1xcbiAgdHJhbnNpdGlvbjogZWFzZSBhbGwgLjNzIDBzOyB9XFxuICAubmV4dC1yYWRpby1idXR0b24gPiBsYWJlbCAubmV4dC1yYWRpby1sYWJlbCB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBjb2xvcjogIzMzMzMzMztcXG4gICAgbWFyZ2luOiAwO1xcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGVhc2UgYWxsIC4zcyAwcztcXG4gICAgdHJhbnNpdGlvbjogZWFzZSBhbGwgLjNzIDBzOyB9XFxuICAubmV4dC1yYWRpby1idXR0b24gPiBsYWJlbDpob3ZlciwgLm5leHQtcmFkaW8tYnV0dG9uID4gbGFiZWw6Zm9jdXMsIC5uZXh0LXJhZGlvLWJ1dHRvbiA+IGxhYmVsLmhvdmVyZWQge1xcbiAgICB6LWluZGV4OiAxMDtcXG4gICAgYm9yZGVyLWNvbG9yOiAjQTBBMkFEO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjJGM0Y3OyB9XFxuICAgIC5uZXh0LXJhZGlvLWJ1dHRvbiA+IGxhYmVsOmhvdmVyIC5uZXh0LXJhZGlvLWxhYmVsLCAubmV4dC1yYWRpby1idXR0b24gPiBsYWJlbDpmb2N1cyAubmV4dC1yYWRpby1sYWJlbCwgLm5leHQtcmFkaW8tYnV0dG9uID4gbGFiZWwuaG92ZXJlZCAubmV4dC1yYWRpby1sYWJlbCB7XFxuICAgICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gIC5uZXh0LXJhZGlvLWJ1dHRvbiA+IGxhYmVsLmNoZWNrZWQge1xcbiAgICB6LWluZGV4OiAxMDtcXG4gICAgYm9yZGVyLWNvbG9yOiAjNTU4NEZGO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGOyB9XFxuICAgIC5uZXh0LXJhZGlvLWJ1dHRvbiA+IGxhYmVsLmNoZWNrZWQgLm5leHQtcmFkaW8tbGFiZWwge1xcbiAgICAgIGNvbG9yOiAjNTU4NEZGOyB9XFxuICAubmV4dC1yYWRpby1idXR0b24gPiBsYWJlbC5kaXNhYmxlZCB7XFxuICAgIHotaW5kZXg6IDA7XFxuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxuICAgIGJvcmRlci1jb2xvcjogI0U2RTdFQjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjhGQTsgfVxcbiAgICAubmV4dC1yYWRpby1idXR0b24gPiBsYWJlbC5kaXNhYmxlZCAubmV4dC1yYWRpby1sYWJlbCB7XFxuICAgICAgY29sb3I6ICNDQ0NDQ0M7IH1cXG4gIC5uZXh0LXJhZGlvLWJ1dHRvbiA+IGxhYmVsLmNoZWNrZWQuZGlzYWJsZWQge1xcbiAgICB6LWluZGV4OiAwO1xcbiAgICBib3JkZXItY29sb3I6ICNFNkU3RUI7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGMkYzRjc7IH1cXG4gICAgLm5leHQtcmFkaW8tYnV0dG9uID4gbGFiZWwuY2hlY2tlZC5kaXNhYmxlZCAubmV4dC1yYWRpby1sYWJlbCB7XFxuICAgICAgY29sb3I6ICNDQ0NDQ0M7IH1cXG5cXG4ubmV4dC1yYWRpby1idXR0b24tbGFyZ2UgPiBsYWJlbCB7XFxuICBwYWRkaW5nOiAwIDhweDtcXG4gIGhlaWdodDogNDBweDtcXG4gIGxpbmUtaGVpZ2h0OiA0MHB4OyB9XFxuICAubmV4dC1yYWRpby1idXR0b24tbGFyZ2UgPiBsYWJlbDpmaXJzdC1jaGlsZCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAzcHg7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDNweDsgfVxcbiAgLm5leHQtcmFkaW8tYnV0dG9uLWxhcmdlID4gbGFiZWw6bGFzdC1jaGlsZCB7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAzcHg7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAzcHg7IH1cXG5cXG4ubmV4dC1yYWRpby1idXR0b24tbGFyZ2UgLm5leHQtcmFkaW8tbGFiZWwge1xcbiAgaGVpZ2h0OiAzOHB4O1xcbiAgbGluZS1oZWlnaHQ6IDM4cHg7XFxuICBmb250LXNpemU6IDE2cHg7IH1cXG5cXG4ubmV4dC1yYWRpby1idXR0b24tbWVkaXVtID4gbGFiZWwge1xcbiAgcGFkZGluZzogMCA4cHg7XFxuICBoZWlnaHQ6IDI4cHg7XFxuICBsaW5lLWhlaWdodDogMjhweDsgfVxcbiAgLm5leHQtcmFkaW8tYnV0dG9uLW1lZGl1bSA+IGxhYmVsOmZpcnN0LWNoaWxkIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDNweDtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogM3B4OyB9XFxuICAubmV4dC1yYWRpby1idXR0b24tbWVkaXVtID4gbGFiZWw6bGFzdC1jaGlsZCB7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAzcHg7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAzcHg7IH1cXG5cXG4ubmV4dC1yYWRpby1idXR0b24tbWVkaXVtIC5uZXh0LXJhZGlvLWxhYmVsIHtcXG4gIGhlaWdodDogMjZweDtcXG4gIGxpbmUtaGVpZ2h0OiAyNnB4O1xcbiAgZm9udC1zaXplOiAxMnB4OyB9XFxuXFxuLm5leHQtcmFkaW8tYnV0dG9uLXNtYWxsID4gbGFiZWwge1xcbiAgcGFkZGluZzogMCA4cHg7XFxuICBoZWlnaHQ6IDIwcHg7XFxuICBsaW5lLWhlaWdodDogMjBweDsgfVxcbiAgLm5leHQtcmFkaW8tYnV0dG9uLXNtYWxsID4gbGFiZWw6Zmlyc3QtY2hpbGQge1xcbiAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogM3B4O1xcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAzcHg7IH1cXG4gIC5uZXh0LXJhZGlvLWJ1dHRvbi1zbWFsbCA+IGxhYmVsOmxhc3QtY2hpbGQge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogM3B4O1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogM3B4OyB9XFxuXFxuLm5leHQtcmFkaW8tYnV0dG9uLXNtYWxsIC5uZXh0LXJhZGlvLWxhYmVsIHtcXG4gIGhlaWdodDogMThweDtcXG4gIGxpbmUtaGVpZ2h0OiAxOHB4O1xcbiAgZm9udC1zaXplOiAxMnB4OyB9XFxuXFxuLm5leHQtcmFkaW8tc2luZ2xlLWlucHV0IGlucHV0W3R5cGU9XFxcInJhZGlvXFxcIl0ge1xcbiAgb3BhY2l0eTogMDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICBtYXJnaW46IDA7IH1cXG5cXG4ubmV4dC1yYWRpby1ncm91cCB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IH1cXG4gIC5uZXh0LXJhZGlvLWdyb3VwIC5uZXh0LXJhZGlvLWxhYmVsIHtcXG4gICAgY29sb3I6ICMzMzMzMzM7XFxuICAgIG1hcmdpbi1yaWdodDogMTZweDsgfVxcbiAgLm5leHQtcmFkaW8tZ3JvdXAuZGlzYWJsZWQgLm5leHQtcmFkaW8tbGFiZWwge1xcbiAgICBjb2xvcjogI0NDQ0NDQzsgfVxcblxcbi5uZXh0LXJhZGlvLWdyb3VwLXZlciAubmV4dC1yYWRpby13cmFwcGVyIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgbWFyZ2luLWJvdHRvbTogOHB4OyB9XFxuXFxuLm5leHQtcmFkaW8tbGFiZWwge1xcbiAgbWFyZ2luOiAwO1xcbiAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBsaW5lLWhlaWdodDogMTsgfVxcblxcbkAtbW96LWRvY3VtZW50IHVybC1wcmVmaXgoKSB7XFxuICAubmV4dC1yYWRpbyB7XFxuICAgIG1hcmdpbi10b3A6IC0xcHg7IH1cXG4gIEBzdXBwb3J0cyAoKC13ZWJraXQtYW5pbWF0aW9uOiBjYWxjKDBzKSkgb3IgKGFuaW1hdGlvbjogY2FsYygwcykpKSB7XFxuICAgIC8qIGZpcmVmb3ggNTcrICovXFxuICAgIC5uZXh0LXJhZGlvIHtcXG4gICAgICBtYXJnaW4tdG9wOiAtM3B4OyB9IH0gfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlcj8/cmVmLS0yLTEhLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYj8/cmVmLS0yLTIhLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIhLi9zcmMvcmFkaW8vbWFpbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkgMTAgMTEgMTIgMTMgMTQgMTUgMTYgMTcgMTggMTkgMjAgMjEgMjIiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGNoYXJzZXQgXFxcIlVURi04XFxcIjtcXG4vKipcXG4gKiDlsLrlr7gg5Z+656GA5bC65a+4XFxuICog5ZG95ZCN6IO95Zyo6K+t5LmJ55qE5YmN5o+Q5LiL566A5Y2V5bCx5bC96YeP566A5Y2VLCDov5nph4zlj6/ku6XmmK8gc2l6ZS0yeCwgc3BhY2UtMngsIHNpemUtYmFzZSAuLi5cXG4gKiDkuI3ov4flj6/ku6XlnKjor63kuYnnmoTliY3mj5DkuIvlgZrnmoTmm7Tnsr7nroDkuIDkupssIOS6juaYr+eUqOS6hnMyLCBzMeetiVxcbiAqIOWPr+eUqOWPmOmHjzogYCRzMSAtICRzOGBcXG4gKiBAZXhhbXBsZSBzY3NzIC0g5L2/55SoXFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6ICRzMSAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKlxcbiAqIEBleGFtcGxlIGNzcyAtIENTUyDovpPlh7pcXG4gKiAgIC5lbGVtZW50IHtcXG4gKiAgICAgcGFkZGluZzogNHB4ICFkZWZhdWx0O1xcbiAqICAgfVxcbiAqL1xcbi5uZXh0LW1lbnVbZGlyPVxcXCJydGxcXFwiXSAubmV4dC1tZW51LWl0ZW0taGVscGVyIHtcXG4gIGZsb2F0OiBsZWZ0OyB9XFxuXFxuLm5leHQtbWVudVtkaXI9XFxcInJ0bFxcXCJdIC5uZXh0LW1lbnUtaXRlbSAubmV4dC1jaGVja2JveCxcXG4ubmV4dC1tZW51W2Rpcj1cXFwicnRsXFxcIl0gLm5leHQtbWVudS1pdGVtIC5uZXh0LXJhZGlvIHtcXG4gIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG5cXG4ubmV4dC1tZW51W2Rpcj1cXFwicnRsXFxcIl0gLm5leHQtbWVudS1ob3otcmlnaHQge1xcbiAgZmxvYXQ6IHJpZ2h0OyB9XFxuXFxuLm5leHQtbWVudVtkaXI9XFxcInJ0bFxcXCJdIC5uZXh0LW1lbnUtaWNvbi1hcnJvdy5uZXh0LWljb24ge1xcbiAgbGVmdDogMTBweDtcXG4gIHJpZ2h0OiBhdXRvOyB9XFxuXFxuLm5leHQtbWVudVtkaXI9XFxcInJ0bFxcXCJdIC5uZXh0LW1lbnUtaG96LWljb24tYXJyb3cubmV4dC1pY29uIHtcXG4gIGxlZnQ6IDZweDtcXG4gIHJpZ2h0OiBhdXRvOyB9XFxuXFxuLm5leHQtbWVudVtkaXI9XFxcInJ0bFxcXCJdIC5uZXh0LW1lbnUtaWNvbi1zZWxlY3RlZC5uZXh0LWljb24ge1xcbiAgbWFyZ2luLWxlZnQ6IDA7XFxuICBtYXJnaW4tcmlnaHQ6IC0xNnB4OyB9XFxuICAubmV4dC1tZW51W2Rpcj1cXFwicnRsXFxcIl0gLm5leHQtbWVudS1pY29uLXNlbGVjdGVkLm5leHQtaWNvbjpiZWZvcmUge1xcbiAgICB3aWR0aDogMTJweDtcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcblxcbi5uZXh0LW1lbnVbZGlyPVxcXCJydGxcXFwiXSAubmV4dC1tZW51LWljb24tYXJyb3cubmV4dC1pY29uIHtcXG4gIGxlZnQ6IDEwcHg7XFxuICByaWdodDogYXV0bzsgfVxcblxcbi5uZXh0LW1lbnUge1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbWluLXdpZHRoOiAxMDBweDtcXG4gIHBhZGRpbmc6IDhweCAwO1xcbiAgbWFyZ2luOiAwO1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNEQ0RFRTM7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IG5vbmU7XFxuICAgICAgICAgIGJveC1zaGFkb3c6IG5vbmU7XFxuICBiYWNrZ3JvdW5kOiAjRkZGRkZGO1xcbiAgbGluZS1oZWlnaHQ6IDMycHg7XFxuICBmb250LXNpemU6IDEycHg7XFxuICAvKiAmLXBvcHVwLWNvbnRlbnQubmV4dC1oaWRlIHsgKi9cXG4gIC8qICAgICBkaXNwbGF5OiBub25lOyAqL1xcbiAgLyogfSAqLyB9XFxuICAubmV4dC1tZW51ICosXFxuICAubmV4dC1tZW51ICo6YmVmb3JlLFxcbiAgLm5leHQtbWVudSAqOmFmdGVyIHtcXG4gICAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH1cXG4gIC5uZXh0LW1lbnU6Zm9jdXMsXFxuICAubmV4dC1tZW51ICo6Zm9jdXMge1xcbiAgICBvdXRsaW5lOiAwOyB9XFxuICAubmV4dC1tZW51LWNvbnRlbnQge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbGlzdC1zdHlsZTogbm9uZTsgfVxcbiAgLm5leHQtbWVudS1zdWItbWVudSB7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbGlzdC1zdHlsZTogbm9uZTsgfVxcbiAgICAubmV4dC1tZW51LXN1Yi1tZW51Lm5leHQtZXhwYW5kLWVudGVyIHtcXG4gICAgICBvdmVyZmxvdzogaGlkZGVuOyB9XFxuICAgIC5uZXh0LW1lbnUtc3ViLW1lbnUubmV4dC1leHBhbmQtZW50ZXItYWN0aXZlIHtcXG4gICAgICAtd2Via2l0LXRyYW5zaXRpb246IGhlaWdodCAuM3MgZWFzZS1vdXQ7XFxuICAgICAgdHJhbnNpdGlvbjogaGVpZ2h0IC4zcyBlYXNlLW91dDsgfVxcbiAgICAubmV4dC1tZW51LXN1Yi1tZW51Lm5leHQtZXhwYW5kLWxlYXZlIHtcXG4gICAgICBvdmVyZmxvdzogaGlkZGVuOyB9XFxuICAgIC5uZXh0LW1lbnUtc3ViLW1lbnUubmV4dC1leHBhbmQtbGVhdmUtYWN0aXZlIHtcXG4gICAgICAtd2Via2l0LXRyYW5zaXRpb246IGhlaWdodCAuM3MgZWFzZS1vdXQ7XFxuICAgICAgdHJhbnNpdGlvbjogaGVpZ2h0IC4zcyBlYXNlLW91dDsgfVxcbiAgLm5leHQtbWVudS1pdGVtIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBwYWRkaW5nOiAwIDIwcHg7XFxuICAgIC13ZWJraXQtdHJhbnNpdGlvbjogYmFja2dyb3VuZCAuMnMgZWFzZTtcXG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZCAuMnMgZWFzZTtcXG4gICAgY29sb3I6ICMzMzMzMzM7XFxuICAgIGN1cnNvcjogcG9pbnRlcjsgfVxcbiAgICAubmV4dC1tZW51LWl0ZW0taGVscGVyIHtcXG4gICAgICBmbG9hdDogcmlnaHQ7XFxuICAgICAgY29sb3I6ICM5OTk5OTk7XFxuICAgICAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDsgfVxcbiAgICAubmV4dC1tZW51LWl0ZW0gLm5leHQtY2hlY2tib3gsXFxuICAgIC5uZXh0LW1lbnUtaXRlbSAubmV4dC1yYWRpbyB7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gICAgLm5leHQtbWVudS1pdGVtLm5leHQtc2VsZWN0ZWQge1xcbiAgICAgIGNvbG9yOiAjMzMzMzMzO1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkY7IH1cXG4gICAgICAubmV4dC1tZW51LWl0ZW0ubmV4dC1zZWxlY3RlZCAubmV4dC1tZW51LWljb24tYXJyb3cge1xcbiAgICAgICAgY29sb3I6ICM2NjY2NjY7IH1cXG4gICAgICAubmV4dC1tZW51LWl0ZW0ubmV4dC1zZWxlY3RlZCAubmV4dC1tZW51LWljb24tc2VsZWN0ZWQge1xcbiAgICAgICAgY29sb3I6ICM1NTg0RkY7IH1cXG4gICAgLm5leHQtbWVudS1pdGVtLm5leHQtZGlzYWJsZWQsXFxuICAgIC5uZXh0LW1lbnUtaXRlbS5uZXh0LWRpc2FibGVkIC5uZXh0LW1lbnUtaXRlbS10ZXh0ID4gYSB7XFxuICAgICAgY29sb3I6ICNDQ0NDQ0M7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRjtcXG4gICAgICBjdXJzb3I6IG5vdC1hbGxvd2VkOyB9XFxuICAgICAgLm5leHQtbWVudS1pdGVtLm5leHQtZGlzYWJsZWQgLm5leHQtbWVudS1pY29uLWFycm93LFxcbiAgICAgIC5uZXh0LW1lbnUtaXRlbS5uZXh0LWRpc2FibGVkIC5uZXh0LW1lbnUtaXRlbS10ZXh0ID4gYSAubmV4dC1tZW51LWljb24tYXJyb3cge1xcbiAgICAgICAgY29sb3I6ICNDQ0NDQ0M7IH1cXG4gICAgICAubmV4dC1tZW51LWl0ZW0ubmV4dC1kaXNhYmxlZCAubmV4dC1tZW51LWljb24tc2VsZWN0ZWQsXFxuICAgICAgLm5leHQtbWVudS1pdGVtLm5leHQtZGlzYWJsZWQgLm5leHQtbWVudS1pdGVtLXRleHQgPiBhIC5uZXh0LW1lbnUtaWNvbi1zZWxlY3RlZCB7XFxuICAgICAgICBjb2xvcjogI0NDQ0NDQzsgfVxcbiAgICAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKTpob3ZlciwgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCkubmV4dC1zZWxlY3RlZDpob3ZlciwgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCkubmV4dC1zZWxlY3RlZC5uZXh0LWZvY3VzZWQ6aG92ZXIsIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpLm5leHQtc2VsZWN0ZWQ6Zm9jdXM6aG92ZXIsIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpLm5leHQtZm9jdXNlZCwgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCk6Zm9jdXMsIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpLm5leHQtc2VsZWN0ZWQubmV4dC1mb2N1c2VkLCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKS5uZXh0LXNlbGVjdGVkOmZvY3VzIHtcXG4gICAgICBjb2xvcjogIzMzMzMzMztcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjJGM0Y3OyB9XFxuICAgICAgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCk6aG92ZXIgLm5leHQtbWVudS1pY29uLWFycm93LCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKS5uZXh0LXNlbGVjdGVkOmhvdmVyIC5uZXh0LW1lbnUtaWNvbi1hcnJvdywgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCkubmV4dC1zZWxlY3RlZC5uZXh0LWZvY3VzZWQ6aG92ZXIgLm5leHQtbWVudS1pY29uLWFycm93LCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKS5uZXh0LXNlbGVjdGVkOmZvY3VzOmhvdmVyIC5uZXh0LW1lbnUtaWNvbi1hcnJvdywgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCkubmV4dC1mb2N1c2VkIC5uZXh0LW1lbnUtaWNvbi1hcnJvdywgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCk6Zm9jdXMgLm5leHQtbWVudS1pY29uLWFycm93LCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKS5uZXh0LXNlbGVjdGVkLm5leHQtZm9jdXNlZCAubmV4dC1tZW51LWljb24tYXJyb3csIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpLm5leHQtc2VsZWN0ZWQ6Zm9jdXMgLm5leHQtbWVudS1pY29uLWFycm93IHtcXG4gICAgICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuICAgICAgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCk6aG92ZXIgLm5leHQtbWVudS1pY29uLXNlbGVjdGVkLCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKS5uZXh0LXNlbGVjdGVkOmhvdmVyIC5uZXh0LW1lbnUtaWNvbi1zZWxlY3RlZCwgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCkubmV4dC1zZWxlY3RlZC5uZXh0LWZvY3VzZWQ6aG92ZXIgLm5leHQtbWVudS1pY29uLXNlbGVjdGVkLCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKS5uZXh0LXNlbGVjdGVkOmZvY3VzOmhvdmVyIC5uZXh0LW1lbnUtaWNvbi1zZWxlY3RlZCwgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCkubmV4dC1mb2N1c2VkIC5uZXh0LW1lbnUtaWNvbi1zZWxlY3RlZCwgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCk6Zm9jdXMgLm5leHQtbWVudS1pY29uLXNlbGVjdGVkLCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKS5uZXh0LXNlbGVjdGVkLm5leHQtZm9jdXNlZCAubmV4dC1tZW51LWljb24tc2VsZWN0ZWQsIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpLm5leHQtc2VsZWN0ZWQ6Zm9jdXMgLm5leHQtbWVudS1pY29uLXNlbGVjdGVkIHtcXG4gICAgICAgIGNvbG9yOiAjNTU4NEZGOyB9XFxuICAubmV4dC1tZW51LWl0ZW0taW5uZXIge1xcbiAgICBoZWlnaHQ6IDMycHg7XFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICAgIHdvcmQtd3JhcDogbm9ybWFsOyB9XFxuICAubmV4dC1tZW51LWl0ZW0tdGV4dCB7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IH1cXG4gICAgLm5leHQtbWVudS1pdGVtLXRleHQgPiBhIHtcXG4gICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuICAgICAgLm5leHQtbWVudS1pdGVtLXRleHQgPiBhOjpiZWZvcmUge1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICB0b3A6IDA7XFxuICAgICAgICBsZWZ0OiAwO1xcbiAgICAgICAgYm90dG9tOiAwO1xcbiAgICAgICAgcmlnaHQ6IDA7XFxuICAgICAgICBjb250ZW50OiAnJzsgfVxcbiAgLm5leHQtbWVudS5uZXh0LWhveiB7XFxuICAgIHBhZGRpbmc6IDA7IH1cXG4gICAgLm5leHQtbWVudS5uZXh0LWhveiA+IC5uZXh0LW1lbnUtaXRlbSxcXG4gICAgLm5leHQtbWVudS5uZXh0LWhveiAubmV4dC1tZW51LWNvbnRlbnQgPiAubmV4dC1tZW51LWl0ZW0ge1xcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wOyB9XFxuICAgIC5uZXh0LW1lbnUubmV4dC1ob3ogLm5leHQtbWVudS1oZWFkZXIsXFxuICAgIC5uZXh0LW1lbnUubmV4dC1ob3ogLm5leHQtbWVudS1jb250ZW50LFxcbiAgICAubmV4dC1tZW51Lm5leHQtaG96IC5uZXh0LW1lbnUtZm9vdGVyIHtcXG4gICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IH1cXG4gIC5uZXh0LW1lbnUtaG96LXJpZ2h0IHtcXG4gICAgZmxvYXQ6IHJpZ2h0OyB9XFxuICAubmV4dC1tZW51LWdyb3VwLWxhYmVsIHtcXG4gICAgcGFkZGluZzogMCAxMnB4O1xcbiAgICBjb2xvcjogIzk5OTk5OTsgfVxcbiAgLm5leHQtbWVudS1kaXZpZGVyIHtcXG4gICAgbWFyZ2luOiA4cHggMTJweDtcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNFNkU3RUI7IH1cXG4gIC5uZXh0LW1lbnUgLm5leHQtbWVudS1pY29uLXNlbGVjdGVkLm5leHQtaWNvbiB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICBtYXJnaW4tbGVmdDogLTE2cHg7IH1cXG4gICAgLm5leHQtbWVudSAubmV4dC1tZW51LWljb24tc2VsZWN0ZWQubmV4dC1pY29uOmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC1tZW51IC5uZXh0LW1lbnUtaWNvbi1hcnJvdy5uZXh0LWljb24ge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDEwcHg7XFxuICAgIGNvbG9yOiAjNjY2NjY2O1xcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCBlYXNlIC4zcztcXG4gICAgdHJhbnNpdGlvbjogYWxsIGVhc2UgLjNzOyB9XFxuICAgIC5uZXh0LW1lbnUgLm5leHQtbWVudS1pY29uLWFycm93Lm5leHQtaWNvbjpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiA4cHg7XFxuICAgICAgZm9udC1zaXplOiA4cHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgQG1lZGlhIGFsbCBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMCkgYW5kIChtaW4tcmVzb2x1dGlvbjogMC4wMDFkcGNtKSB7XFxuICAgICAgLm5leHQtbWVudSAubmV4dC1tZW51LWljb24tYXJyb3cubmV4dC1pY29uIHtcXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLjUpO1xcbiAgICAgICAgICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDAuNSk7XFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC41KTtcXG4gICAgICAgIG1hcmdpbi1sZWZ0OiAtNHB4O1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAtNHB4OyB9XFxuICAgICAgICAubmV4dC1tZW51IC5uZXh0LW1lbnUtaWNvbi1hcnJvdy5uZXh0LWljb246YmVmb3JlIHtcXG4gICAgICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMTZweDsgfSB9XFxuICAubmV4dC1tZW51IC5uZXh0LW1lbnUtaWNvbi1hcnJvdy1kb3duLm5leHQtb3BlbiB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG4gICAgICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7IH1cXG4gICAgLm5leHQtbWVudSAubmV4dC1tZW51LWljb24tYXJyb3ctZG93bi5uZXh0LW9wZW46YmVmb3JlIHtcXG4gICAgICB3aWR0aDogOHB4O1xcbiAgICAgIGZvbnQtc2l6ZTogOHB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgIEBtZWRpYSBhbGwgYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDApIGFuZCAobWluLXJlc29sdXRpb246IDAuMDAxZHBjbSkge1xcbiAgICAgIC5uZXh0LW1lbnUgLm5leHQtbWVudS1pY29uLWFycm93LWRvd24ubmV4dC1vcGVuIHtcXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLjUpIHJvdGF0ZSgxODBkZWcpO1xcbiAgICAgICAgICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDAuNSkgcm90YXRlKDE4MGRlZyk7XFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC41KSByb3RhdGUoMTgwZGVnKTtcXG4gICAgICAgIG1hcmdpbi1sZWZ0OiAtNHB4O1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAtNHB4OyB9XFxuICAgICAgICAubmV4dC1tZW51IC5uZXh0LW1lbnUtaWNvbi1hcnJvdy1kb3duLm5leHQtb3BlbjpiZWZvcmUge1xcbiAgICAgICAgICB3aWR0aDogMTZweDtcXG4gICAgICAgICAgZm9udC1zaXplOiAxNnB4OyB9IH1cXG4gIC5uZXh0LW1lbnUgLm5leHQtbWVudS1pY29uLWFycm93LXJpZ2h0Lm5leHQtb3BlbiB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoLTkwZGVnKTtcXG4gICAgICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgtOTBkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKC05MGRlZyk7IH1cXG4gICAgLm5leHQtbWVudSAubmV4dC1tZW51LWljb24tYXJyb3ctcmlnaHQubmV4dC1vcGVuOmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDhweDtcXG4gICAgICBmb250LXNpemU6IDhweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICBAbWVkaWEgYWxsIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAwKSBhbmQgKG1pbi1yZXNvbHV0aW9uOiAwLjAwMWRwY20pIHtcXG4gICAgICAubmV4dC1tZW51IC5uZXh0LW1lbnUtaWNvbi1hcnJvdy1yaWdodC5uZXh0LW9wZW4ge1xcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuNSkgcm90YXRlKC05MGRlZyk7XFxuICAgICAgICAgICAgLW1zLXRyYW5zZm9ybTogc2NhbGUoMC41KSByb3RhdGUoLTkwZGVnKTtcXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjUpIHJvdGF0ZSgtOTBkZWcpO1xcbiAgICAgICAgbWFyZ2luLWxlZnQ6IC00cHg7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IC00cHg7IH1cXG4gICAgICAgIC5uZXh0LW1lbnUgLm5leHQtbWVudS1pY29uLWFycm93LXJpZ2h0Lm5leHQtb3BlbjpiZWZvcmUge1xcbiAgICAgICAgICB3aWR0aDogMTZweDtcXG4gICAgICAgICAgZm9udC1zaXplOiAxNnB4OyB9IH1cXG4gIC5uZXh0LW1lbnUgLm5leHQtbWVudS1ob3otaWNvbi1hcnJvdy5uZXh0LWljb24ge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDZweDtcXG4gICAgY29sb3I6ICM2NjY2NjY7XFxuICAgIC13ZWJraXQtdHJhbnNpdGlvbjogYWxsIGVhc2UgLjNzO1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgZWFzZSAuM3M7IH1cXG4gICAgLm5leHQtbWVudSAubmV4dC1tZW51LWhvei1pY29uLWFycm93Lm5leHQtaWNvbjpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgLm5leHQtbWVudSAubmV4dC1tZW51LWhvei1pY29uLWFycm93Lm5leHQtb3BlbiB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG4gICAgICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7IH1cXG4gICAgLm5leHQtbWVudSAubmV4dC1tZW51LWhvei1pY29uLWFycm93Lm5leHQtb3BlbjpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgLm5leHQtbWVudS5uZXh0LWNvbnRleHQge1xcbiAgICBsaW5lLWhlaWdodDogMjRweDsgfVxcbiAgICAubmV4dC1tZW51Lm5leHQtY29udGV4dCAubmV4dC1tZW51LWl0ZW0taW5uZXIge1xcbiAgICAgIGhlaWdodDogMjRweDsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlcj8/cmVmLS0yLTEhLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYj8/cmVmLS0yLTIhLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIhLi9zcmMvbWVudS9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUgNiA3IDggOSAxMCAxMSAxMiAxMyAxNCAxNSAxNiAxNyAxOCAxOSAyMCAyMSAyMiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAY2hhcnNldCBcXFwiVVRGLThcXFwiO1xcbi8qKlxcbiAqIOWwuuWvuCDln7rnoYDlsLrlr7hcXG4gKiDlkb3lkI3og73lnKjor63kuYnnmoTliY3mj5DkuIvnroDljZXlsLHlsL3ph4/nroDljZUsIOi/memHjOWPr+S7peaYryBzaXplLTJ4LCBzcGFjZS0yeCwgc2l6ZS1iYXNlIC4uLlxcbiAqIOS4jei/h+WPr+S7peWcqOivreS5ieeahOWJjeaPkOS4i+WBmueahOabtOeyvueugOS4gOS6mywg5LqO5piv55So5LqGczIsIHMx562JXFxuICog5Y+v55So5Y+Y6YePOiBgJHMxIC0gJHM4YFxcbiAqIEBleGFtcGxlIHNjc3MgLSDkvb/nlKhcXG4gKiAgIC5lbGVtZW50IHtcXG4gKiAgICAgcGFkZGluZzogJHMxICFkZWZhdWx0O1xcbiAqICAgfVxcbiAqXFxuICogQGV4YW1wbGUgY3NzIC0gQ1NTIOi+k+WHulxcbiAqICAgLmVsZW1lbnQge1xcbiAqICAgICBwYWRkaW5nOiA0cHggIWRlZmF1bHQ7XFxuICogICB9XFxuICovXFxuLm5leHQtYnRuIHtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDsgfVxcbiAgLm5leHQtYnRuICosXFxuICAubmV4dC1idG4gKjpiZWZvcmUsXFxuICAubmV4dC1idG4gKjphZnRlciB7XFxuICAgIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XFxuICAubmV4dC1idG46Oi1tb3otZm9jdXMtaW5uZXIge1xcbiAgICBib3JkZXI6IDA7XFxuICAgIHBhZGRpbmc6IDA7IH1cXG4gIC5uZXh0LWJ0biwgLm5leHQtYnRuOmFjdGl2ZSwgLm5leHQtYnRuOmZvY3VzLCAubmV4dC1idG46aG92ZXIge1xcbiAgICBvdXRsaW5lOiAwOyB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIGxvYWRpbmdDaXJjbGUge1xcbiAgMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XFxuICAgICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogNTAlIDUwJTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfVxcbiAgMTAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogNTAlIDUwJTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfSB9XFxuXFxuQGtleWZyYW1lcyBsb2FkaW5nQ2lyY2xlIHtcXG4gIDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7IH1cXG4gIDEwMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XFxuICAgICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogNTAlIDUwJTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH0gfVxcblxcbi5uZXh0LWJ0biB7XFxuICAvKiDlsLrlr7jnu7TluqYgKi9cXG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXG4gIC8qIOaZrumAmuaMiemSriAqL1xcbiAgLyog5pmu6YCa5oCB56aB55So5qC35byPICovXFxuICAvKiDorablkYrmjInpkq4gKi9cXG4gIC8qIOaWh+acrOaMiemSriAqL1xcbiAgLyogbG9hZGluZyAqL1xcbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcbiAgLyog5bm954G15oyJ6ZKuICovXFxuICAvKiDnu4TlkIggKi9cXG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi8gfVxcbiAgLm5leHQtYnRuIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIC13ZWJraXQtYm94LXNoYWRvdzogbm9uZTtcXG4gICAgICAgICAgICBib3gtc2hhZG93OiBub25lO1xcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIC13ZWJraXQtdHJhbnNpdGlvbjogYWxsIC4zcyBlYXNlLW91dDtcXG4gICAgdHJhbnNpdGlvbjogYWxsIC4zcyBlYXNlLW91dDtcXG4gICAgY3Vyc29yOiBwb2ludGVyOyB9XFxuICAgIC5uZXh0LWJ0bjphZnRlciB7XFxuICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICBvcGFjaXR5OiAwO1xcbiAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXG4gICAgICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgLjVzIGVhc2U7XFxuICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAuNXMgZWFzZTsgfVxcbiAgICAubmV4dC1idG4gLm5leHQtaWNvbi5uZXh0LXhzOmJlZm9yZSB7XFxuICAgICAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lOyB9XFxuICAgIC5uZXh0LWJ0bi5ob3ZlciwgLm5leHQtYnRuOmhvdmVyIHtcXG4gICAgICAtd2Via2l0LWJveC1zaGFkb3c6IG5vbmU7XFxuICAgICAgICAgICAgICBib3gtc2hhZG93OiBub25lOyB9XFxuICAubmV4dC1idG4ubmV4dC1zbWFsbCB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gICAgcGFkZGluZzogMCA4cHg7XFxuICAgIGhlaWdodDogMjBweDtcXG4gICAgbGluZS1oZWlnaHQ6IDE4cHg7XFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgYm9yZGVyLXdpZHRoOiAxcHg7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtc21hbGwgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Qge1xcbiAgICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICAgIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuICAgICAgLm5leHQtYnRuLm5leHQtc21hbGwgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Q6YmVmb3JlIHtcXG4gICAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtc21hbGwgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdCB7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG4gICAgICAubmV4dC1idG4ubmV4dC1zbWFsbCA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0OmJlZm9yZSB7XFxuICAgICAgICB3aWR0aDogMTJweDtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LXNtYWxsID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWFsb25lOmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LXNtYWxsLm5leHQtYnRuLWxvYWRpbmcge1xcbiAgICAgIHBhZGRpbmctbGVmdDogMjRweDsgfVxcbiAgICAgIC5uZXh0LWJ0bi5uZXh0LXNtYWxsLm5leHQtYnRuLWxvYWRpbmc6YWZ0ZXIge1xcbiAgICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgICBoZWlnaHQ6IDEycHg7XFxuICAgICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgICBsaW5lLWhlaWdodDogMTJweDtcXG4gICAgICAgIGxlZnQ6IDhweDtcXG4gICAgICAgIHRvcDogNTAlO1xcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICAgICAgbWFyZ2luLXRvcDogLTZweDtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuICAgICAgLm5leHQtYnRuLm5leHQtc21hbGwubmV4dC1idG4tbG9hZGluZyA+IC5uZXh0LWljb24ge1xcbiAgICAgICAgZGlzcGxheTogbm9uZTsgfVxcbiAgLm5leHQtYnRuLm5leHQtbWVkaXVtIHtcXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgICBwYWRkaW5nOiAwIDEycHg7XFxuICAgIGhlaWdodDogMjhweDtcXG4gICAgbGluZS1oZWlnaHQ6IDI2cHg7XFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgYm9yZGVyLXdpZHRoOiAxcHg7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtbWVkaXVtID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0IHtcXG4gICAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgICAgIC5uZXh0LWJ0bi5uZXh0LW1lZGl1bSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdDpiZWZvcmUge1xcbiAgICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1tZWRpdW0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdCB7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG4gICAgICAubmV4dC1idG4ubmV4dC1tZWRpdW0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdDpiZWZvcmUge1xcbiAgICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1tZWRpdW0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tYWxvbmU6YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTJweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtbWVkaXVtLm5leHQtYnRuLWxvYWRpbmcge1xcbiAgICAgIHBhZGRpbmctbGVmdDogMjhweDsgfVxcbiAgICAgIC5uZXh0LWJ0bi5uZXh0LW1lZGl1bS5uZXh0LWJ0bi1sb2FkaW5nOmFmdGVyIHtcXG4gICAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgICAgaGVpZ2h0OiAxMnB4O1xcbiAgICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IDEycHg7XFxuICAgICAgICBsZWZ0OiAxMnB4O1xcbiAgICAgICAgdG9wOiA1MCU7XFxuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgICAgICBtYXJnaW4tdG9wOiAtNnB4O1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gICAgICAubmV4dC1idG4ubmV4dC1tZWRpdW0ubmV4dC1idG4tbG9hZGluZyA+IC5uZXh0LWljb24ge1xcbiAgICAgICAgZGlzcGxheTogbm9uZTsgfVxcbiAgLm5leHQtYnRuLm5leHQtbGFyZ2Uge1xcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICAgIHBhZGRpbmc6IDAgMTZweDtcXG4gICAgaGVpZ2h0OiA0MHB4O1xcbiAgICBsaW5lLWhlaWdodDogMzhweDtcXG4gICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICBib3JkZXItd2lkdGg6IDFweDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1sYXJnZSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdCB7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gICAgICAubmV4dC1idG4ubmV4dC1sYXJnZSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdDpiZWZvcmUge1xcbiAgICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1sYXJnZSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0IHtcXG4gICAgICBtYXJnaW4tbGVmdDogNHB4O1xcbiAgICAgIG1hcmdpbi1yaWdodDogMDsgfVxcbiAgICAgIC5uZXh0LWJ0bi5uZXh0LWxhcmdlID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Q6YmVmb3JlIHtcXG4gICAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtbGFyZ2UgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tYWxvbmU6YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTZweDtcXG4gICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtbGFyZ2UubmV4dC1idG4tbG9hZGluZyB7XFxuICAgICAgcGFkZGluZy1sZWZ0OiAzNnB4OyB9XFxuICAgICAgLm5leHQtYnRuLm5leHQtbGFyZ2UubmV4dC1idG4tbG9hZGluZzphZnRlciB7XFxuICAgICAgICB3aWR0aDogMTZweDtcXG4gICAgICAgIGhlaWdodDogMTZweDtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxNnB4O1xcbiAgICAgICAgbGVmdDogMTZweDtcXG4gICAgICAgIHRvcDogNTAlO1xcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICAgICAgbWFyZ2luLXRvcDogLThweDtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuICAgICAgLm5leHQtYnRuLm5leHQtbGFyZ2UubmV4dC1idG4tbG9hZGluZyA+IC5uZXh0LWljb24ge1xcbiAgICAgICAgZGlzcGxheTogbm9uZTsgfVxcbiAgLm5leHQtYnRuLm5leHQtYnRuLW5vcm1hbCB7XFxuICAgIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkY7XFxuICAgIGJvcmRlci1jb2xvcjogI0M0QzZDRjsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1idG4tbm9ybWFsLCAubmV4dC1idG4ubmV4dC1idG4tbm9ybWFsOmxpbmssIC5uZXh0LWJ0bi5uZXh0LWJ0bi1ub3JtYWw6dmlzaXRlZCwgLm5leHQtYnRuLm5leHQtYnRuLW5vcm1hbC52aXNpdGVkIHtcXG4gICAgICBjb2xvcjogIzMzMzMzMzsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1idG4tbm9ybWFsOmZvY3VzLCAubmV4dC1idG4ubmV4dC1idG4tbm9ybWFsOmhvdmVyLCAubmV4dC1idG4ubmV4dC1idG4tbm9ybWFsLmhvdmVyLCAubmV4dC1idG4ubmV4dC1idG4tbm9ybWFsOmFjdGl2ZSwgLm5leHQtYnRuLm5leHQtYnRuLW5vcm1hbC5hY3RpdmUge1xcbiAgICAgIGNvbG9yOiAjMzMzMzMzO1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNGMkYzRjc7XFxuICAgICAgYm9yZGVyLWNvbG9yOiAjQTBBMkFEO1xcbiAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbiAgLm5leHQtYnRuLm5leHQtYnRuLXByaW1hcnkge1xcbiAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNTU4NEZGO1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LWJ0bi1wcmltYXJ5LCAubmV4dC1idG4ubmV4dC1idG4tcHJpbWFyeTpsaW5rLCAubmV4dC1idG4ubmV4dC1idG4tcHJpbWFyeTp2aXNpdGVkLCAubmV4dC1idG4ubmV4dC1idG4tcHJpbWFyeS52aXNpdGVkIHtcXG4gICAgICBjb2xvcjogI0ZGRkZGRjsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1idG4tcHJpbWFyeTpmb2N1cywgLm5leHQtYnRuLm5leHQtYnRuLXByaW1hcnk6aG92ZXIsIC5uZXh0LWJ0bi5uZXh0LWJ0bi1wcmltYXJ5LmhvdmVyLCAubmV4dC1idG4ubmV4dC1idG4tcHJpbWFyeTphY3RpdmUsIC5uZXh0LWJ0bi5uZXh0LWJ0bi1wcmltYXJ5LmFjdGl2ZSB7XFxuICAgICAgY29sb3I6ICNGRkZGRkY7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzNFNzFGNztcXG4gICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbiAgLm5leHQtYnRuLm5leHQtYnRuLXNlY29uZGFyeSB7XFxuICAgIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkY7XFxuICAgIGJvcmRlci1jb2xvcjogIzU1ODRGRjsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1idG4tc2Vjb25kYXJ5LCAubmV4dC1idG4ubmV4dC1idG4tc2Vjb25kYXJ5OmxpbmssIC5uZXh0LWJ0bi5uZXh0LWJ0bi1zZWNvbmRhcnk6dmlzaXRlZCwgLm5leHQtYnRuLm5leHQtYnRuLXNlY29uZGFyeS52aXNpdGVkIHtcXG4gICAgICBjb2xvcjogIzU1ODRGRjsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1idG4tc2Vjb25kYXJ5OmZvY3VzLCAubmV4dC1idG4ubmV4dC1idG4tc2Vjb25kYXJ5OmhvdmVyLCAubmV4dC1idG4ubmV4dC1idG4tc2Vjb25kYXJ5LmhvdmVyLCAubmV4dC1idG4ubmV4dC1idG4tc2Vjb25kYXJ5OmFjdGl2ZSwgLm5leHQtYnRuLm5leHQtYnRuLXNlY29uZGFyeS5hY3RpdmUge1xcbiAgICAgIGNvbG9yOiAjRkZGRkZGO1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICMzRTcxRjc7XFxuICAgICAgYm9yZGVyLWNvbG9yOiAjM0U3MUY3O1xcbiAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbiAgLm5leHQtYnRuLmRpc2FibGVkLCAubmV4dC1idG5bZGlzYWJsZWRdIHtcXG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjhGQTtcXG4gICAgYm9yZGVyLWNvbG9yOiAjRTZFN0VCOyB9XFxuICAgIC5uZXh0LWJ0bi5kaXNhYmxlZCwgLm5leHQtYnRuLmRpc2FibGVkOmxpbmssIC5uZXh0LWJ0bi5kaXNhYmxlZDp2aXNpdGVkLCAubmV4dC1idG4uZGlzYWJsZWQudmlzaXRlZCwgLm5leHQtYnRuW2Rpc2FibGVkXSwgLm5leHQtYnRuW2Rpc2FibGVkXTpsaW5rLCAubmV4dC1idG5bZGlzYWJsZWRdOnZpc2l0ZWQsIC5uZXh0LWJ0bltkaXNhYmxlZF0udmlzaXRlZCB7XFxuICAgICAgY29sb3I6ICNDQ0NDQ0M7IH1cXG4gICAgLm5leHQtYnRuLmRpc2FibGVkOmZvY3VzLCAubmV4dC1idG4uZGlzYWJsZWQ6aG92ZXIsIC5uZXh0LWJ0bi5kaXNhYmxlZC5ob3ZlciwgLm5leHQtYnRuLmRpc2FibGVkOmFjdGl2ZSwgLm5leHQtYnRuLmRpc2FibGVkLmFjdGl2ZSwgLm5leHQtYnRuW2Rpc2FibGVkXTpmb2N1cywgLm5leHQtYnRuW2Rpc2FibGVkXTpob3ZlciwgLm5leHQtYnRuW2Rpc2FibGVkXS5ob3ZlciwgLm5leHQtYnRuW2Rpc2FibGVkXTphY3RpdmUsIC5uZXh0LWJ0bltkaXNhYmxlZF0uYWN0aXZlIHtcXG4gICAgICBjb2xvcjogI0NDQ0NDQztcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGOEZBO1xcbiAgICAgIGJvcmRlci1jb2xvcjogI0U2RTdFQjtcXG4gICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG4gIC5uZXh0LWJ0bi13YXJuaW5nIHtcXG4gICAgYm9yZGVyLXN0eWxlOiBzb2xpZDsgfVxcbiAgICAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5IHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkYzMDAwO1xcbiAgICAgIGJvcmRlci1jb2xvcjogI0ZGMzAwMDsgfVxcbiAgICAgIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnksIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnk6bGluaywgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeTp2aXNpdGVkLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5LnZpc2l0ZWQge1xcbiAgICAgICAgY29sb3I6ICNGRkZGRkY7IH1cXG4gICAgICAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5OmZvY3VzLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5OmhvdmVyLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5LmhvdmVyLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5OmFjdGl2ZSwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeS5hY3RpdmUge1xcbiAgICAgICAgY29sb3I6ICNGRkZGRkY7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRTcyQjAwO1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiAjRTcyQjAwO1xcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuICAgICAgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeS5kaXNhYmxlZCwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeVtkaXNhYmxlZF0ge1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjhGQTtcXG4gICAgICAgIGJvcmRlci1jb2xvcjogI0RDREVFMzsgfVxcbiAgICAgICAgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeS5kaXNhYmxlZCwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeS5kaXNhYmxlZDpsaW5rLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5LmRpc2FibGVkOnZpc2l0ZWQsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnkuZGlzYWJsZWQudmlzaXRlZCwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeVtkaXNhYmxlZF0sIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnlbZGlzYWJsZWRdOmxpbmssIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnlbZGlzYWJsZWRdOnZpc2l0ZWQsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnlbZGlzYWJsZWRdLnZpc2l0ZWQge1xcbiAgICAgICAgICBjb2xvcjogI0NDQ0NDQzsgfVxcbiAgICAgICAgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeS5kaXNhYmxlZDpmb2N1cywgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeS5kaXNhYmxlZDpob3ZlciwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeS5kaXNhYmxlZC5ob3ZlciwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeS5kaXNhYmxlZDphY3RpdmUsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnkuZGlzYWJsZWQuYWN0aXZlLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5W2Rpc2FibGVkXTpmb2N1cywgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeVtkaXNhYmxlZF06aG92ZXIsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnlbZGlzYWJsZWRdLmhvdmVyLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5W2Rpc2FibGVkXTphY3RpdmUsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnlbZGlzYWJsZWRdLmFjdGl2ZSB7XFxuICAgICAgICAgIGNvbG9yOiAjQ0NDQ0NDO1xcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGOEZBO1xcbiAgICAgICAgICBib3JkZXItY29sb3I6ICNEQ0RFRTM7XFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbiAgICAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWwge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkY7XFxuICAgICAgYm9yZGVyLWNvbG9yOiAjRkYzMDAwOyB9XFxuICAgICAgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWw6bGluaywgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsOnZpc2l0ZWQsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbC52aXNpdGVkIHtcXG4gICAgICAgIGNvbG9yOiAjRkYzMDAwOyB9XFxuICAgICAgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsOmZvY3VzLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWw6aG92ZXIsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbC5ob3ZlciwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsOmFjdGl2ZSwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsLmFjdGl2ZSB7XFxuICAgICAgICBjb2xvcjogI0ZGRkZGRjtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNFNzJCMDA7XFxuICAgICAgICBib3JkZXItY29sb3I6ICNFNzJCMDA7XFxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG4gICAgICAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWwuZGlzYWJsZWQsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbFtkaXNhYmxlZF0ge1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjhGQTtcXG4gICAgICAgIGJvcmRlci1jb2xvcjogI0U2RTdFQjsgfVxcbiAgICAgICAgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsLmRpc2FibGVkLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWwuZGlzYWJsZWQ6bGluaywgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsLmRpc2FibGVkOnZpc2l0ZWQsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbC5kaXNhYmxlZC52aXNpdGVkLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWxbZGlzYWJsZWRdLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWxbZGlzYWJsZWRdOmxpbmssIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbFtkaXNhYmxlZF06dmlzaXRlZCwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsW2Rpc2FibGVkXS52aXNpdGVkIHtcXG4gICAgICAgICAgY29sb3I6ICNDQ0NDQ0M7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbC5kaXNhYmxlZDpmb2N1cywgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsLmRpc2FibGVkOmhvdmVyLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWwuZGlzYWJsZWQuaG92ZXIsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbC5kaXNhYmxlZDphY3RpdmUsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbC5kaXNhYmxlZC5hY3RpdmUsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbFtkaXNhYmxlZF06Zm9jdXMsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbFtkaXNhYmxlZF06aG92ZXIsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbFtkaXNhYmxlZF0uaG92ZXIsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbFtkaXNhYmxlZF06YWN0aXZlLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWxbZGlzYWJsZWRdLmFjdGl2ZSB7XFxuICAgICAgICAgIGNvbG9yOiAjQ0NDQ0NDO1xcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGOEZBO1xcbiAgICAgICAgICBib3JkZXItY29sb3I6ICNFNkU3RUI7XFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbiAgLm5leHQtYnRuLXRleHQge1xcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IG5vbmU7XFxuICAgICAgICAgICAgYm94LXNoYWRvdzogbm9uZTtcXG4gICAgYm9yZGVyLXJhZGl1czogMDsgfVxcbiAgICAubmV4dC1idG4tdGV4dC5ob3ZlciwgLm5leHQtYnRuLXRleHQ6aG92ZXIge1xcbiAgICAgIC13ZWJraXQtYm94LXNoYWRvdzogbm9uZTtcXG4gICAgICAgICAgICAgIGJveC1zaGFkb3c6IG5vbmU7IH1cXG4gICAgLm5leHQtYnRuLXRleHQubmV4dC1idG4tcHJpbWFyeSB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXByaW1hcnksIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXByaW1hcnk6bGluaywgLm5leHQtYnRuLXRleHQubmV4dC1idG4tcHJpbWFyeTp2aXNpdGVkLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1wcmltYXJ5LnZpc2l0ZWQge1xcbiAgICAgICAgY29sb3I6ICM1NTg0RkY7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1wcmltYXJ5OmZvY3VzLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1wcmltYXJ5OmhvdmVyLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1wcmltYXJ5LmhvdmVyLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1wcmltYXJ5OmFjdGl2ZSwgLm5leHQtYnRuLXRleHQubmV4dC1idG4tcHJpbWFyeS5hY3RpdmUge1xcbiAgICAgICAgY29sb3I6ICMzRTcxRjc7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG4gICAgLm5leHQtYnRuLXRleHQubmV4dC1idG4tc2Vjb25kYXJ5IHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1idG4tc2Vjb25kYXJ5LCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1zZWNvbmRhcnk6bGluaywgLm5leHQtYnRuLXRleHQubmV4dC1idG4tc2Vjb25kYXJ5OnZpc2l0ZWQsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXNlY29uZGFyeS52aXNpdGVkIHtcXG4gICAgICAgIGNvbG9yOiAjNjY2NjY2OyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1idG4tc2Vjb25kYXJ5OmZvY3VzLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1zZWNvbmRhcnk6aG92ZXIsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXNlY29uZGFyeS5ob3ZlciwgLm5leHQtYnRuLXRleHQubmV4dC1idG4tc2Vjb25kYXJ5OmFjdGl2ZSwgLm5leHQtYnRuLXRleHQubmV4dC1idG4tc2Vjb25kYXJ5LmFjdGl2ZSB7XFxuICAgICAgICBjb2xvcjogIzU1ODRGRjtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbiAgICAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1ub3JtYWwge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1ub3JtYWwsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLW5vcm1hbDpsaW5rLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1ub3JtYWw6dmlzaXRlZCwgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbm9ybWFsLnZpc2l0ZWQge1xcbiAgICAgICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1ub3JtYWw6Zm9jdXMsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLW5vcm1hbDpob3ZlciwgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbm9ybWFsLmhvdmVyLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1ub3JtYWw6YWN0aXZlLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1ub3JtYWwuYWN0aXZlIHtcXG4gICAgICAgIGNvbG9yOiAjNTU4NEZGO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtbGFyZ2Uge1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDA7XFxuICAgICAgcGFkZGluZzogMCAwO1xcbiAgICAgIGhlaWdodDogMjRweDtcXG4gICAgICBsaW5lLWhlaWdodDogMjRweDtcXG4gICAgICBmb250LXNpemU6IDE0cHg7XFxuICAgICAgYm9yZGVyLXdpZHRoOiAwOyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1sYXJnZSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdCB7XFxuICAgICAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuICAgICAgICAubmV4dC1idG4tdGV4dC5uZXh0LWxhcmdlID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0OmJlZm9yZSB7XFxuICAgICAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1sYXJnZSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0IHtcXG4gICAgICAgIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtbGFyZ2UgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdDpiZWZvcmUge1xcbiAgICAgICAgICB3aWR0aDogMTZweDtcXG4gICAgICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtbGFyZ2UgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tYWxvbmU6YmVmb3JlIHtcXG4gICAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LWxhcmdlLm5leHQtYnRuLWxvYWRpbmcge1xcbiAgICAgICAgcGFkZGluZy1sZWZ0OiAyMHB4OyB9XFxuICAgICAgICAubmV4dC1idG4tdGV4dC5uZXh0LWxhcmdlLm5leHQtYnRuLWxvYWRpbmc6YWZ0ZXIge1xcbiAgICAgICAgICB3aWR0aDogMTZweDtcXG4gICAgICAgICAgaGVpZ2h0OiAxNnB4O1xcbiAgICAgICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxNnB4O1xcbiAgICAgICAgICBsZWZ0OiAwO1xcbiAgICAgICAgICB0b3A6IDUwJTtcXG4gICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICAgICAgICBtYXJnaW4tdG9wOiAtOHB4O1xcbiAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1sYXJnZS5uZXh0LWJ0bi1sb2FkaW5nID4gLm5leHQtaWNvbiB7XFxuICAgICAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gICAgLm5leHQtYnRuLXRleHQubmV4dC1tZWRpdW0ge1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDA7XFxuICAgICAgcGFkZGluZzogMCAwO1xcbiAgICAgIGhlaWdodDogMjBweDtcXG4gICAgICBsaW5lLWhlaWdodDogMjBweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgYm9yZGVyLXdpZHRoOiAwOyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1tZWRpdW0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Qge1xcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1tZWRpdW0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Q6YmVmb3JlIHtcXG4gICAgICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LW1lZGl1bSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0IHtcXG4gICAgICAgIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtbWVkaXVtID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Q6YmVmb3JlIHtcXG4gICAgICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LW1lZGl1bSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1hbG9uZTpiZWZvcmUge1xcbiAgICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtbWVkaXVtLm5leHQtYnRuLWxvYWRpbmcge1xcbiAgICAgICAgcGFkZGluZy1sZWZ0OiAxNnB4OyB9XFxuICAgICAgICAubmV4dC1idG4tdGV4dC5uZXh0LW1lZGl1bS5uZXh0LWJ0bi1sb2FkaW5nOmFmdGVyIHtcXG4gICAgICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgICAgIGhlaWdodDogMTJweDtcXG4gICAgICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogMTJweDtcXG4gICAgICAgICAgbGVmdDogMDtcXG4gICAgICAgICAgdG9wOiA1MCU7XFxuICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgICAgbWFyZ2luLXRvcDogLTZweDtcXG4gICAgICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtbWVkaXVtLm5leHQtYnRuLWxvYWRpbmcgPiAubmV4dC1pY29uIHtcXG4gICAgICAgICAgZGlzcGxheTogbm9uZTsgfVxcbiAgICAubmV4dC1idG4tdGV4dC5uZXh0LXNtYWxsIHtcXG4gICAgICBib3JkZXItcmFkaXVzOiAwO1xcbiAgICAgIHBhZGRpbmc6IDAgMDtcXG4gICAgICBoZWlnaHQ6IDE2cHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IDE2cHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGJvcmRlci13aWR0aDogMDsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtc21hbGwgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Qge1xcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1zbWFsbCA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdDpiZWZvcmUge1xcbiAgICAgICAgICB3aWR0aDogMTJweDtcXG4gICAgICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtc21hbGwgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdCB7XFxuICAgICAgICBtYXJnaW4tbGVmdDogNHB4O1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAwOyB9XFxuICAgICAgICAubmV4dC1idG4tdGV4dC5uZXh0LXNtYWxsID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Q6YmVmb3JlIHtcXG4gICAgICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LXNtYWxsID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWFsb25lOmJlZm9yZSB7XFxuICAgICAgICB3aWR0aDogMTJweDtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1zbWFsbC5uZXh0LWJ0bi1sb2FkaW5nIHtcXG4gICAgICAgIHBhZGRpbmctbGVmdDogMTZweDsgfVxcbiAgICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1zbWFsbC5uZXh0LWJ0bi1sb2FkaW5nOmFmdGVyIHtcXG4gICAgICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgICAgIGhlaWdodDogMTJweDtcXG4gICAgICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogMTJweDtcXG4gICAgICAgICAgbGVmdDogMDtcXG4gICAgICAgICAgdG9wOiA1MCU7XFxuICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgICAgbWFyZ2luLXRvcDogLTZweDtcXG4gICAgICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtc21hbGwubmV4dC1idG4tbG9hZGluZyA+IC5uZXh0LWljb24ge1xcbiAgICAgICAgICBkaXNwbGF5OiBub25lOyB9XFxuICAgIC5uZXh0LWJ0bi10ZXh0LmRpc2FibGVkLCAubmV4dC1idG4tdGV4dFtkaXNhYmxlZF0ge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5kaXNhYmxlZCwgLm5leHQtYnRuLXRleHQuZGlzYWJsZWQ6bGluaywgLm5leHQtYnRuLXRleHQuZGlzYWJsZWQ6dmlzaXRlZCwgLm5leHQtYnRuLXRleHQuZGlzYWJsZWQudmlzaXRlZCwgLm5leHQtYnRuLXRleHRbZGlzYWJsZWRdLCAubmV4dC1idG4tdGV4dFtkaXNhYmxlZF06bGluaywgLm5leHQtYnRuLXRleHRbZGlzYWJsZWRdOnZpc2l0ZWQsIC5uZXh0LWJ0bi10ZXh0W2Rpc2FibGVkXS52aXNpdGVkIHtcXG4gICAgICAgIGNvbG9yOiAjQ0NDQ0NDOyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQuZGlzYWJsZWQ6Zm9jdXMsIC5uZXh0LWJ0bi10ZXh0LmRpc2FibGVkOmhvdmVyLCAubmV4dC1idG4tdGV4dC5kaXNhYmxlZC5ob3ZlciwgLm5leHQtYnRuLXRleHQuZGlzYWJsZWQ6YWN0aXZlLCAubmV4dC1idG4tdGV4dC5kaXNhYmxlZC5hY3RpdmUsIC5uZXh0LWJ0bi10ZXh0W2Rpc2FibGVkXTpmb2N1cywgLm5leHQtYnRuLXRleHRbZGlzYWJsZWRdOmhvdmVyLCAubmV4dC1idG4tdGV4dFtkaXNhYmxlZF0uaG92ZXIsIC5uZXh0LWJ0bi10ZXh0W2Rpc2FibGVkXTphY3RpdmUsIC5uZXh0LWJ0bi10ZXh0W2Rpc2FibGVkXS5hY3RpdmUge1xcbiAgICAgICAgY29sb3I6ICNDQ0NDQ0M7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG4gICAgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbG9hZGluZyB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLWxvYWRpbmcsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLWxvYWRpbmc6bGluaywgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbG9hZGluZzp2aXNpdGVkLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1sb2FkaW5nLnZpc2l0ZWQge1xcbiAgICAgICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1sb2FkaW5nOmZvY3VzLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1sb2FkaW5nOmhvdmVyLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1sb2FkaW5nLmhvdmVyLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1sb2FkaW5nOmFjdGl2ZSwgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbG9hZGluZy5hY3RpdmUge1xcbiAgICAgICAgY29sb3I6ICMzMzMzMzM7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG4gIC5uZXh0LWJ0bi1sb2FkaW5nIHtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7IH1cXG4gICAgLm5leHQtYnRuLWxvYWRpbmc6YWZ0ZXIge1xcbiAgICAgIGZvbnQtZmFtaWx5OiBOZXh0SWNvbjtcXG4gICAgICBjb250ZW50OiBcXFwiXFxcXEU2NDZcXFwiO1xcbiAgICAgIG9wYWNpdHk6IDE7XFxuICAgICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gICAgICAtd2Via2l0LWFuaW1hdGlvbjogbG9hZGluZ0NpcmNsZSAycyBpbmZpbml0ZSBsaW5lYXI7XFxuICAgICAgICAgICAgICBhbmltYXRpb246IGxvYWRpbmdDaXJjbGUgMnMgaW5maW5pdGUgbGluZWFyOyB9XFxuICAubmV4dC1idG4tZ2hvc3Qge1xcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IG5vbmU7XFxuICAgICAgICAgICAgYm94LXNoYWRvdzogbm9uZTtcXG4gICAgYm9yZGVyLXN0eWxlOiBzb2xpZDsgfVxcbiAgICAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyayB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgYm9yZGVyLWNvbG9yOiAjRkZGRkZGOyB9XFxuICAgICAgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmssIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrOmxpbmssIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrOnZpc2l0ZWQsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrLnZpc2l0ZWQge1xcbiAgICAgICAgY29sb3I6ICNGRkZGRkY7IH1cXG4gICAgICAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyazpmb2N1cywgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcms6aG92ZXIsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrLmhvdmVyLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyazphY3RpdmUsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrLmFjdGl2ZSB7XFxuICAgICAgICBjb2xvcjogI0ZGRkZGRjtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcXG4gICAgICAgIGJvcmRlci1jb2xvcjogI0ZGRkZGRjtcXG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbiAgICAgIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrLmRpc2FibGVkLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFya1tkaXNhYmxlZF0ge1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICBib3JkZXItY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC40KTsgfVxcbiAgICAgICAgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmsuZGlzYWJsZWQsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrLmRpc2FibGVkOmxpbmssIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrLmRpc2FibGVkOnZpc2l0ZWQsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrLmRpc2FibGVkLnZpc2l0ZWQsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrW2Rpc2FibGVkXSwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmtbZGlzYWJsZWRdOmxpbmssIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrW2Rpc2FibGVkXTp2aXNpdGVkLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFya1tkaXNhYmxlZF0udmlzaXRlZCB7XFxuICAgICAgICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNCk7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrLmRpc2FibGVkOmZvY3VzLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyay5kaXNhYmxlZDpob3ZlciwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmsuZGlzYWJsZWQuaG92ZXIsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrLmRpc2FibGVkOmFjdGl2ZSwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmsuZGlzYWJsZWQuYWN0aXZlLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFya1tkaXNhYmxlZF06Zm9jdXMsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrW2Rpc2FibGVkXTpob3ZlciwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmtbZGlzYWJsZWRdLmhvdmVyLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFya1tkaXNhYmxlZF06YWN0aXZlLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFya1tkaXNhYmxlZF0uYWN0aXZlIHtcXG4gICAgICAgICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC40KTtcXG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICAgIGJvcmRlci1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjQpO1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG4gICAgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0IHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICBib3JkZXItY29sb3I6ICMzMzMzMzM7IH1cXG4gICAgICAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodDpsaW5rLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQ6dmlzaXRlZCwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0LnZpc2l0ZWQge1xcbiAgICAgICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gICAgICAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQ6Zm9jdXMsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodDpob3ZlciwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0LmhvdmVyLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQ6YWN0aXZlLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQuYWN0aXZlIHtcXG4gICAgICAgIGNvbG9yOiAjOTk5OTk5O1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjkyKTtcXG4gICAgICAgIGJvcmRlci1jb2xvcjogIzMzMzMzMztcXG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbiAgICAgIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodC5kaXNhYmxlZCwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0W2Rpc2FibGVkXSB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgIGJvcmRlci1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjEpOyB9XFxuICAgICAgICAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQuZGlzYWJsZWQsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodC5kaXNhYmxlZDpsaW5rLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQuZGlzYWJsZWQ6dmlzaXRlZCwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0LmRpc2FibGVkLnZpc2l0ZWQsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodFtkaXNhYmxlZF0sIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodFtkaXNhYmxlZF06bGluaywgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0W2Rpc2FibGVkXTp2aXNpdGVkLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHRbZGlzYWJsZWRdLnZpc2l0ZWQge1xcbiAgICAgICAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjEpOyB9XFxuICAgICAgICAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQuZGlzYWJsZWQ6Zm9jdXMsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodC5kaXNhYmxlZDpob3ZlciwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0LmRpc2FibGVkLmhvdmVyLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQuZGlzYWJsZWQ6YWN0aXZlLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQuZGlzYWJsZWQuYWN0aXZlLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHRbZGlzYWJsZWRdOmZvY3VzLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHRbZGlzYWJsZWRdOmhvdmVyLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHRbZGlzYWJsZWRdLmhvdmVyLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHRbZGlzYWJsZWRdOmFjdGl2ZSwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0W2Rpc2FibGVkXS5hY3RpdmUge1xcbiAgICAgICAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjEpO1xcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgICAgYm9yZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMSk7XFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbiAgLm5leHQtYnRuLWdyb3VwIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IH1cXG4gICAgLm5leHQtYnRuLWdyb3VwID4gLm5leHQtYnRuIHtcXG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICAgZmxvYXQ6IGxlZnQ7XFxuICAgICAgLXdlYmtpdC1ib3gtc2hhZG93OiBub25lO1xcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogbm9uZTsgfVxcbiAgICAgIC5uZXh0LWJ0bi1ncm91cCA+IC5uZXh0LWJ0bjpob3ZlciwgLm5leHQtYnRuLWdyb3VwID4gLm5leHQtYnRuOmZvY3VzLCAubmV4dC1idG4tZ3JvdXAgPiAubmV4dC1idG46YWN0aXZlLCAubmV4dC1idG4tZ3JvdXAgPiAubmV4dC1idG4uYWN0aXZlIHtcXG4gICAgICAgIHotaW5kZXg6IDE7IH1cXG4gICAgICAubmV4dC1idG4tZ3JvdXAgPiAubmV4dC1idG4uZGlzYWJsZWQsIC5uZXh0LWJ0bi1ncm91cCA+IC5uZXh0LWJ0bltkaXNhYmxlZF0ge1xcbiAgICAgICAgei1pbmRleDogMDsgfVxcbiAgICAubmV4dC1idG4tZ3JvdXAgLm5leHQtYnRuLm5leHQtYnRuIHtcXG4gICAgICBtYXJnaW46IDAgMCAwIC0xcHg7IH1cXG4gICAgLm5leHQtYnRuLWdyb3VwIC5uZXh0LWJ0bjpub3QoOmZpcnN0LWNoaWxkKTpub3QoOmxhc3QtY2hpbGQpIHtcXG4gICAgICBib3JkZXItcmFkaXVzOiAwOyB9XFxuICAgIC5uZXh0LWJ0bi1ncm91cCA+IC5uZXh0LWJ0bjpmaXJzdC1jaGlsZCB7XFxuICAgICAgbWFyZ2luOiAwOyB9XFxuICAgIC5uZXh0LWJ0bi1ncm91cCA+IC5uZXh0LWJ0bjpmaXJzdC1jaGlsZDpub3QoOmxhc3QtY2hpbGQpIHtcXG4gICAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMDtcXG4gICAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDsgfVxcbiAgICAubmV4dC1idG4tZ3JvdXAgPiAubmV4dC1idG46bGFzdC1jaGlsZDpub3QoOmZpcnN0LWNoaWxkKSB7XFxuICAgICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMDtcXG4gICAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwOyB9XFxuICAgIC5uZXh0LWJ0bi1ncm91cCA+IC5uZXh0LWJ0bi1wcmltYXJ5Om5vdCg6Zmlyc3QtY2hpbGQpIHtcXG4gICAgICBib3JkZXItbGVmdC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpOyB9XFxuICAgICAgLm5leHQtYnRuLWdyb3VwID4gLm5leHQtYnRuLXByaW1hcnk6bm90KDpmaXJzdC1jaGlsZCk6aG92ZXIge1xcbiAgICAgICAgYm9yZGVyLWxlZnQtY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuICAgICAgLm5leHQtYnRuLWdyb3VwID4gLm5leHQtYnRuLXByaW1hcnk6bm90KDpmaXJzdC1jaGlsZCkuZGlzYWJsZWQsIC5uZXh0LWJ0bi1ncm91cCA+IC5uZXh0LWJ0bi1wcmltYXJ5Om5vdCg6Zmlyc3QtY2hpbGQpW2Rpc2FibGVkXSB7XFxuICAgICAgICBib3JkZXItbGVmdC1jb2xvcjogI0U2RTdFQjsgfVxcblxcbi8qIOe7hOWQiCAqL1xcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXG4ubmV4dC1idG4tZ3JvdXBbZGlyPVxcXCJydGxcXFwiXSA+IC5uZXh0LWJ0biB7XFxuICBmbG9hdDogcmlnaHQ7IH1cXG5cXG4ubmV4dC1idG4tZ3JvdXBbZGlyPVxcXCJydGxcXFwiXSAubmV4dC1idG4ubmV4dC1idG4ge1xcbiAgbWFyZ2luOiAwIC0xcHggMCAwOyB9XFxuXFxuLm5leHQtYnRuLWdyb3VwW2Rpcj1cXFwicnRsXFxcIl0gPiAubmV4dC1idG46Zmlyc3QtY2hpbGQ6bm90KDpsYXN0LWNoaWxkKSB7XFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDsgfVxcblxcbi5uZXh0LWJ0bi1ncm91cFtkaXI9XFxcInJ0bFxcXCJdID4gLm5leHQtYnRuOmxhc3QtY2hpbGQ6bm90KDpmaXJzdC1jaGlsZCkge1xcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDsgfVxcblxcbi5uZXh0LWJ0bi1ncm91cFtkaXI9XFxcInJ0bFxcXCJdID4gLm5leHQtYnRuLXByaW1hcnk6bm90KDpmaXJzdC1jaGlsZCkge1xcbiAgYm9yZGVyLXJpZ2h0LWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7IH1cXG4gIC5uZXh0LWJ0bi1ncm91cFtkaXI9XFxcInJ0bFxcXCJdID4gLm5leHQtYnRuLXByaW1hcnk6bm90KDpmaXJzdC1jaGlsZCk6aG92ZXIge1xcbiAgICBib3JkZXItcmlnaHQtY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuICAubmV4dC1idG4tZ3JvdXBbZGlyPVxcXCJydGxcXFwiXSA+IC5uZXh0LWJ0bi1wcmltYXJ5Om5vdCg6Zmlyc3QtY2hpbGQpLmRpc2FibGVkLCAubmV4dC1idG4tZ3JvdXBbZGlyPVxcXCJydGxcXFwiXSA+IC5uZXh0LWJ0bi1wcmltYXJ5Om5vdCg6Zmlyc3QtY2hpbGQpW2Rpc2FibGVkXSB7XFxuICAgIGJvcmRlci1yaWdodC1jb2xvcjogI0U2RTdFQjsgfVxcblxcbi8qIOWwuuWvuOe7tOW6piAqL1xcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXG4ubmV4dC1idG4ubmV4dC1zbWFsbFtkaXI9XFxcInJ0bFxcXCJdIHtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDsgfVxcbiAgLm5leHQtYnRuLm5leHQtc21hbGxbZGlyPVxcXCJydGxcXFwiXSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICAgIG1hcmdpbi1yaWdodDogMDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1zbWFsbFtkaXI9XFxcInJ0bFxcXCJdID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0OmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC1idG4ubmV4dC1zbWFsbFtkaXI9XFxcInJ0bFxcXCJdID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Qge1xcbiAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtc21hbGxbZGlyPVxcXCJydGxcXFwiXSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0OmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC1idG4ubmV4dC1zbWFsbFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtYnRuLWxvYWRpbmcge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDhweDtcXG4gICAgcGFkZGluZy1yaWdodDogMjRweDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1zbWFsbFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtYnRuLWxvYWRpbmc6YWZ0ZXIge1xcbiAgICAgIHJpZ2h0OiA4cHg7XFxuICAgICAgdG9wOiA1MCU7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgICAgIG1hcmdpbi1sZWZ0OiA0cHg7IH1cXG5cXG4ubmV4dC1idG4ubmV4dC1tZWRpdW1bZGlyPVxcXCJydGxcXFwiXSB7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7IH1cXG4gIC5uZXh0LWJ0bi5uZXh0LW1lZGl1bVtkaXI9XFxcInJ0bFxcXCJdID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwOyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LW1lZGl1bVtkaXI9XFxcInJ0bFxcXCJdID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0OmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC1idG4ubmV4dC1tZWRpdW1bZGlyPVxcXCJydGxcXFwiXSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LW1lZGl1bVtkaXI9XFxcInJ0bFxcXCJdID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Q6YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTJweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gIC5uZXh0LWJ0bi5uZXh0LW1lZGl1bVtkaXI9XFxcInJ0bFxcXCJdLm5leHQtYnRuLWxvYWRpbmcge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDEycHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDI4cHg7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtbWVkaXVtW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1idG4tbG9hZGluZzphZnRlciB7XFxuICAgICAgcmlnaHQ6IDEycHg7XFxuICAgICAgdG9wOiA1MCU7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgICAgIG1hcmdpbi1sZWZ0OiA0cHg7IH1cXG5cXG4ubmV4dC1idG4ubmV4dC1sYXJnZVtkaXI9XFxcInJ0bFxcXCJdIHtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDsgfVxcbiAgLm5leHQtYnRuLm5leHQtbGFyZ2VbZGlyPVxcXCJydGxcXFwiXSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICAgIG1hcmdpbi1yaWdodDogMDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1sYXJnZVtkaXI9XFxcInJ0bFxcXCJdID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0OmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC1idG4ubmV4dC1sYXJnZVtkaXI9XFxcInJ0bFxcXCJdID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Qge1xcbiAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtbGFyZ2VbZGlyPVxcXCJydGxcXFwiXSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0OmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC1idG4ubmV4dC1sYXJnZVtkaXI9XFxcInJ0bFxcXCJdLm5leHQtYnRuLWxvYWRpbmcge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDE2cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDM2cHg7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtbGFyZ2VbZGlyPVxcXCJydGxcXFwiXS5uZXh0LWJ0bi1sb2FkaW5nOmFmdGVyIHtcXG4gICAgICByaWdodDogMTZweDtcXG4gICAgICB0b3A6IDUwJTtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDA7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDRweDsgfVxcblxcbi8qIOaWh+acrOaMiemSriAqL1xcbi5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1sYXJnZSB7XFxuICBib3JkZXItcmFkaXVzOiAwOyB9XFxuICAubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtbGFyZ2UgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Qge1xcbiAgICBtYXJnaW4tbGVmdDogNHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG4gICAgLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LWxhcmdlID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0OmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtbGFyZ2UgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgICAubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtbGFyZ2UgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdDpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LWxhcmdlLm5leHQtYnRuLWxvYWRpbmcge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDA7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDIwcHg7IH1cXG4gICAgLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LWxhcmdlLm5leHQtYnRuLWxvYWRpbmc6YWZ0ZXIge1xcbiAgICAgIHJpZ2h0OiAwO1xcbiAgICAgIHRvcDogNTAlO1xcbiAgICAgIG1hcmdpbi1yaWdodDogMDtcXG4gICAgICBtYXJnaW4tbGVmdDogNHB4OyB9XFxuXFxuLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LW1lZGl1bSB7XFxuICBib3JkZXItcmFkaXVzOiAwOyB9XFxuICAubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtbWVkaXVtID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwOyB9XFxuICAgIC5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1tZWRpdW0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Q6YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTJweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gIC5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1tZWRpdW0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgICAubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtbWVkaXVtID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Q6YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTJweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gIC5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1tZWRpdW0ubmV4dC1idG4tbG9hZGluZyB7XFxuICAgIHBhZGRpbmctbGVmdDogMDtcXG4gICAgcGFkZGluZy1yaWdodDogMTZweDsgfVxcbiAgICAubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtbWVkaXVtLm5leHQtYnRuLWxvYWRpbmc6YWZ0ZXIge1xcbiAgICAgIHJpZ2h0OiAwO1xcbiAgICAgIHRvcDogNTAlO1xcbiAgICAgIG1hcmdpbi1yaWdodDogMDtcXG4gICAgICBtYXJnaW4tbGVmdDogNHB4OyB9XFxuXFxuLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LXNtYWxsIHtcXG4gIGJvcmRlci1yYWRpdXM6IDA7IH1cXG4gIC5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1zbWFsbCA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICAgIG1hcmdpbi1yaWdodDogMDsgfVxcbiAgICAubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtc21hbGwgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Q6YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTJweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gIC5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1zbWFsbCA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuICAgIC5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1zbWFsbCA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0OmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtc21hbGwubmV4dC1idG4tbG9hZGluZyB7XFxuICAgIHBhZGRpbmctbGVmdDogMDtcXG4gICAgcGFkZGluZy1yaWdodDogMTZweDsgfVxcbiAgICAubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtc21hbGwubmV4dC1idG4tbG9hZGluZzphZnRlciB7XFxuICAgICAgcmlnaHQ6IDA7XFxuICAgICAgdG9wOiA1MCU7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgICAgIG1hcmdpbi1sZWZ0OiA0cHg7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXI/P3JlZi0tMi0xIS4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWI/P3JlZi0tMi0yIS4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliIS4vc3JjL2J1dHRvbi9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUgNiA3IDggOSAxMCAxMSAxMiAxMyAxNCAxNSAxNiAxNyAxOCAxOSAyMCAyMSAyMiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAY2hhcnNldCBcXFwiVVRGLThcXFwiO1xcbi8qKlxcbiAqIOWwuuWvuCDln7rnoYDlsLrlr7hcXG4gKiDlkb3lkI3og73lnKjor63kuYnnmoTliY3mj5DkuIvnroDljZXlsLHlsL3ph4/nroDljZUsIOi/memHjOWPr+S7peaYryBzaXplLTJ4LCBzcGFjZS0yeCwgc2l6ZS1iYXNlIC4uLlxcbiAqIOS4jei/h+WPr+S7peWcqOivreS5ieeahOWJjeaPkOS4i+WBmueahOabtOeyvueugOS4gOS6mywg5LqO5piv55So5LqGczIsIHMx562JXFxuICog5Y+v55So5Y+Y6YePOiBgJHMxIC0gJHM4YFxcbiAqIEBleGFtcGxlIHNjc3MgLSDkvb/nlKhcXG4gKiAgIC5lbGVtZW50IHtcXG4gKiAgICAgcGFkZGluZzogJHMxICFkZWZhdWx0O1xcbiAqICAgfVxcbiAqXFxuICogQGV4YW1wbGUgY3NzIC0gQ1NTIOi+k+WHulxcbiAqICAgLmVsZW1lbnQge1xcbiAqICAgICBwYWRkaW5nOiA0cHggIWRlZmF1bHQ7XFxuICogICB9XFxuICovXFxuLm5leHQtb3ZlcmxheS13cmFwcGVyIC5uZXh0LW92ZXJsYXktaW5uZXIge1xcbiAgei1pbmRleDogMTAwMTsgfVxcblxcbi5uZXh0LW92ZXJsYXktd3JhcHBlciAubmV4dC1vdmVybGF5LWJhY2tkcm9wIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHotaW5kZXg6IDEwMDE7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBiYWNrZ3JvdW5kOiAjMDAwMDAwO1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBvcGFjaXR5IC4zcztcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgLjNzO1xcbiAgb3BhY2l0eTogMDsgfVxcblxcbi5uZXh0LW92ZXJsYXktd3JhcHBlci5vcGVuZWQgLm5leHQtb3ZlcmxheS1iYWNrZHJvcCB7XFxuICBvcGFjaXR5OiAwLjI7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXI/P3JlZi0tMi0xIS4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWI/P3JlZi0tMi0yIS4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliIS4vc3JjL292ZXJsYXkvbWFpbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkgMTAgMTEgMTIgMTMgMTQgMTUgMTYgMTcgMTggMTkgMjAgMjEgMjIiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyPz9yZWYtLTItMSEuL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliPz9yZWYtLTItMiEuL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYiEuL3NyYy9kcm9wZG93bi9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUgNiA3IDggOSAxMCAxMSAxMiAxMyAxNCAxNSAxNiAxNyAxOCAxOSAyMCAyMSAyMiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAY2hhcnNldCBcXFwiVVRGLThcXFwiO1xcbi8qKlxcbiAqIOWwuuWvuCDln7rnoYDlsLrlr7hcXG4gKiDlkb3lkI3og73lnKjor63kuYnnmoTliY3mj5DkuIvnroDljZXlsLHlsL3ph4/nroDljZUsIOi/memHjOWPr+S7peaYryBzaXplLTJ4LCBzcGFjZS0yeCwgc2l6ZS1iYXNlIC4uLlxcbiAqIOS4jei/h+WPr+S7peWcqOivreS5ieeahOWJjeaPkOS4i+WBmueahOabtOeyvueugOS4gOS6mywg5LqO5piv55So5LqGczIsIHMx562JXFxuICog5Y+v55So5Y+Y6YePOiBgJHMxIC0gJHM4YFxcbiAqIEBleGFtcGxlIHNjc3MgLSDkvb/nlKhcXG4gKiAgIC5lbGVtZW50IHtcXG4gKiAgICAgcGFkZGluZzogJHMxICFkZWZhdWx0O1xcbiAqICAgfVxcbiAqXFxuICogQGV4YW1wbGUgY3NzIC0gQ1NTIOi+k+WHulxcbiAqICAgLmVsZW1lbnQge1xcbiAqICAgICBwYWRkaW5nOiA0cHggIWRlZmF1bHQ7XFxuICogICB9XFxuICovXFxuLyogcHV0IHlvdXIgY29kZSBoZXJlICovXFxuLm5leHQtbG9hZGluZyB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAvKiDpga7nvanlsYIgKi9cXG4gIC8qIGZvciBJRTksMTAgKi9cXG4gIC8qIHRleHQgb24gdGhlIHJpZ2h0IHNpZGUgb2YgKi9cXG4gIC8qIOWKqOaViCAqLyB9XFxuICAubmV4dC1sb2FkaW5nLm5leHQtb3BlbiB7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lOyB9XFxuICAubmV4dC1sb2FkaW5nIC5uZXh0LWxvYWRpbmctY29tcG9uZW50IHtcXG4gICAgb3BhY2l0eTogLjc7XFxuICAgIC13ZWJraXQtZmlsdGVyOiBibHVyKDFweCk7XFxuICAgIGZpbHRlcjogYmx1cigxcHgpO1xcbiAgICAtd2Via2l0LWZpbHRlcjogXFxcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5CbHVyKFBpeGVsUmFkaXVzPTEsIE1ha2VTaGFkb3c9ZmFsc2UpXFxcIjtcXG4gICAgICAgICAgICBmaWx0ZXI6IFxcXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQmx1cihQaXhlbFJhZGl1cz0xLCBNYWtlU2hhZG93PWZhbHNlKVxcXCI7XFxuICAgIC8qIElFNn5JRTkgKi9cXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTsgfVxcbiAgLm5leHQtbG9hZGluZy1tYXNrZXIge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgei1pbmRleDogOTk7XFxuICAgIG9wYWNpdHk6IC4yO1xcbiAgICBiYWNrZ3JvdW5kOiAjRkZGOyB9XFxuICAubmV4dC1sb2FkaW5nLXRpcCB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogNTAlO1xcbiAgICBsZWZ0OiA1MCU7XFxuICAgIHotaW5kZXg6IDQ7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICAgICAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjsgfVxcbiAgLm5leHQtbG9hZGluZy10aXAtcGxhY2Vob2xkZXIge1xcbiAgICBkaXNwbGF5OiBub25lOyB9XFxuICAubmV4dC1sb2FkaW5nLXJpZ2h0LXRpcCAubmV4dC1sb2FkaW5nLWluZGljYXRvciB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jazsgfVxcbiAgLm5leHQtbG9hZGluZy1yaWdodC10aXAgLm5leHQtbG9hZGluZy10aXAtY29udGVudCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHRvcDogNTAlO1xcbiAgICByaWdodDogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAtNTAlKTtcXG4gICAgICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAtNTAlKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAtNTAlKTsgfVxcbiAgLm5leHQtbG9hZGluZy1yaWdodC10aXAgLm5leHQtbG9hZGluZy10aXAtcGxhY2Vob2xkZXIge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXG4gICAgbWFyZ2luLWxlZnQ6IDFlbTsgfVxcbiAgLm5leHQtbG9hZGluZy1mdXNpb24tcmVhY3RvciB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgd2lkdGg6IDQ4cHg7XFxuICAgIGhlaWdodDogNDhweDtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiA1LjZzO1xcbiAgICBhbmltYXRpb24tZHVyYXRpb246IDUuNnM7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogaW5maW5pdGU7XFxuICAgIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IGluZmluaXRlO1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGxpbmVhcjtcXG4gICAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogbGluZWFyO1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBuZXh0VmVjdG9yUm91dGU7XFxuICAgIGFuaW1hdGlvbi1uYW1lOiBuZXh0VmVjdG9yUm91dGU7IH1cXG4gICAgLm5leHQtbG9hZGluZy1mdXNpb24tcmVhY3RvciAubmV4dC1sb2FkaW5nLWRvdCB7XFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgIG1hcmdpbjogYXV0bztcXG4gICAgICB3aWR0aDogMTJweDtcXG4gICAgICBoZWlnaHQ6IDEycHg7XFxuICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgICAgIGJhY2tncm91bmQ6ICM1NTg0RkY7XFxuICAgICAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluLW91dDtcXG4gICAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluLW91dDtcXG4gICAgICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IGluZmluaXRlO1xcbiAgICAgIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IGluZmluaXRlO1xcbiAgICAgIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAxLjRzO1xcbiAgICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogMS40czsgfVxcbiAgICAgIC5uZXh0LWxvYWRpbmctZnVzaW9uLXJlYWN0b3IgLm5leHQtbG9hZGluZy1kb3Q6bnRoLWNoaWxkKDEpIHtcXG4gICAgICAgIHRvcDogMDtcXG4gICAgICAgIGJvdHRvbTogMDtcXG4gICAgICAgIGxlZnQ6IDA7XFxuICAgICAgICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBuZXh0VmVjdG9yRG90c1g7XFxuICAgICAgICBhbmltYXRpb24tbmFtZTogbmV4dFZlY3RvckRvdHNYOyB9XFxuICAgICAgLm5leHQtbG9hZGluZy1mdXNpb24tcmVhY3RvciAubmV4dC1sb2FkaW5nLWRvdDpudGgtY2hpbGQoMikge1xcbiAgICAgICAgbGVmdDogMDtcXG4gICAgICAgIHJpZ2h0OiAwO1xcbiAgICAgICAgdG9wOiAwO1xcbiAgICAgICAgb3BhY2l0eTogLjg7XFxuICAgICAgICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBuZXh0VmVjdG9yRG90c1k7XFxuICAgICAgICBhbmltYXRpb24tbmFtZTogbmV4dFZlY3RvckRvdHNZOyB9XFxuICAgICAgLm5leHQtbG9hZGluZy1mdXNpb24tcmVhY3RvciAubmV4dC1sb2FkaW5nLWRvdDpudGgtY2hpbGQoMykge1xcbiAgICAgICAgdG9wOiAwO1xcbiAgICAgICAgYm90dG9tOiAwO1xcbiAgICAgICAgcmlnaHQ6IDA7XFxuICAgICAgICBvcGFjaXR5OiAuNjtcXG4gICAgICAgIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IG5leHRWZWN0b3JEb3RzWFI7XFxuICAgICAgICBhbmltYXRpb24tbmFtZTogbmV4dFZlY3RvckRvdHNYUjsgfVxcbiAgICAgIC5uZXh0LWxvYWRpbmctZnVzaW9uLXJlYWN0b3IgLm5leHQtbG9hZGluZy1kb3Q6bnRoLWNoaWxkKDQpIHtcXG4gICAgICAgIGxlZnQ6IDA7XFxuICAgICAgICByaWdodDogMDtcXG4gICAgICAgIGJvdHRvbTogMDtcXG4gICAgICAgIG9wYWNpdHk6IC4yO1xcbiAgICAgICAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogbmV4dFZlY3RvckRvdHNZUjtcXG4gICAgICAgIGFuaW1hdGlvbi1uYW1lOiBuZXh0VmVjdG9yRG90c1lSOyB9XFxuICAubmV4dC1sb2FkaW5nLW1lZGl1bS1mdXNpb24tcmVhY3RvciB7XFxuICAgIHdpZHRoOiAzMnB4O1xcbiAgICBoZWlnaHQ6IDMycHg7IH1cXG4gICAgLm5leHQtbG9hZGluZy1tZWRpdW0tZnVzaW9uLXJlYWN0b3IgLm5leHQtbG9hZGluZy1kb3Qge1xcbiAgICAgIHdpZHRoOiA4cHg7XFxuICAgICAgaGVpZ2h0OiA4cHg7IH1cXG4gICAgICAubmV4dC1sb2FkaW5nLW1lZGl1bS1mdXNpb24tcmVhY3RvciAubmV4dC1sb2FkaW5nLWRvdDpudGgtY2hpbGQoMSkge1xcbiAgICAgICAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogbmV4dFZlY3RvckRvdHNYLW1lZGl1bTtcXG4gICAgICAgIGFuaW1hdGlvbi1uYW1lOiBuZXh0VmVjdG9yRG90c1gtbWVkaXVtOyB9XFxuICAgICAgLm5leHQtbG9hZGluZy1tZWRpdW0tZnVzaW9uLXJlYWN0b3IgLm5leHQtbG9hZGluZy1kb3Q6bnRoLWNoaWxkKDIpIHtcXG4gICAgICAgIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IG5leHRWZWN0b3JEb3RzWS1tZWRpdW07XFxuICAgICAgICBhbmltYXRpb24tbmFtZTogbmV4dFZlY3RvckRvdHNZLW1lZGl1bTsgfVxcbiAgICAgIC5uZXh0LWxvYWRpbmctbWVkaXVtLWZ1c2lvbi1yZWFjdG9yIC5uZXh0LWxvYWRpbmctZG90Om50aC1jaGlsZCgzKSB7XFxuICAgICAgICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBuZXh0VmVjdG9yRG90c1hSLW1lZGl1bTtcXG4gICAgICAgIGFuaW1hdGlvbi1uYW1lOiBuZXh0VmVjdG9yRG90c1hSLW1lZGl1bTsgfVxcbiAgICAgIC5uZXh0LWxvYWRpbmctbWVkaXVtLWZ1c2lvbi1yZWFjdG9yIC5uZXh0LWxvYWRpbmctZG90Om50aC1jaGlsZCg0KSB7XFxuICAgICAgICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBuZXh0VmVjdG9yRG90c1lSLW1lZGl1bTtcXG4gICAgICAgIGFuaW1hdGlvbi1uYW1lOiBuZXh0VmVjdG9yRG90c1lSLW1lZGl1bTsgfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBuZXh0VmVjdG9yUm91dGUge1xcbiAgMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpOyB9XFxuICA1JSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7IH1cXG4gIDI1JSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7IH1cXG4gIDMwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7IH1cXG4gIDUwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7IH1cXG4gIDU1JSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMjcwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7IH1cXG4gIDc1JSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMjcwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7IH1cXG4gIDgwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH1cXG4gIDEwMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIG5leHRWZWN0b3JSb3V0ZSB7XFxuICAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7IH1cXG4gIDUlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTsgfVxcbiAgMjUlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTsgfVxcbiAgMzAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTsgfVxcbiAgNTAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTsgfVxcbiAgNTUlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMjcwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMjcwZGVnKTsgfVxcbiAgNzUlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMjcwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMjcwZGVnKTsgfVxcbiAgODAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfVxcbiAgMTAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH0gfVxcblxcbi8qIDIwJSDnmoTml7bpl7TlnKjml4vovawgKi9cXG5ALXdlYmtpdC1rZXlmcmFtZXMgbmV4dFZlY3RvckRvdHNZUiB7XFxuICAyNSUge1xcbiAgICBib3R0b206IDA7IH1cXG4gIDQ1JSxcXG4gIDUwJSB7XFxuICAgIGJvdHRvbTogMTYuOHB4O1xcbiAgICBoZWlnaHQ6IDE0LjRweDtcXG4gICAgd2lkdGg6IDE0LjRweDsgfVxcbiAgOTAlIHtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBoZWlnaHQ6IDEycHg7XFxuICAgIHdpZHRoOiAxMnB4OyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIG5leHRWZWN0b3JEb3RzWVIge1xcbiAgMjUlIHtcXG4gICAgYm90dG9tOiAwOyB9XFxuICA0NSUsXFxuICA1MCUge1xcbiAgICBib3R0b206IDE2LjhweDtcXG4gICAgaGVpZ2h0OiAxNC40cHg7XFxuICAgIHdpZHRoOiAxNC40cHg7IH1cXG4gIDkwJSB7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgaGVpZ2h0OiAxMnB4O1xcbiAgICB3aWR0aDogMTJweDsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIG5leHRWZWN0b3JEb3RzWSB7XFxuICAyNSUge1xcbiAgICB0b3A6IDA7IH1cXG4gIDQ1JSxcXG4gIDUwJSB7XFxuICAgIHRvcDogMTYuOHB4O1xcbiAgICBoZWlnaHQ6IDE0LjRweDtcXG4gICAgd2lkdGg6IDE0LjRweDsgfVxcbiAgOTAlIHtcXG4gICAgdG9wOiAwO1xcbiAgICBoZWlnaHQ6IDEycHg7XFxuICAgIHdpZHRoOiAxMnB4OyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIG5leHRWZWN0b3JEb3RzWSB7XFxuICAyNSUge1xcbiAgICB0b3A6IDA7IH1cXG4gIDQ1JSxcXG4gIDUwJSB7XFxuICAgIHRvcDogMTYuOHB4O1xcbiAgICBoZWlnaHQ6IDE0LjRweDtcXG4gICAgd2lkdGg6IDE0LjRweDsgfVxcbiAgOTAlIHtcXG4gICAgdG9wOiAwO1xcbiAgICBoZWlnaHQ6IDEycHg7XFxuICAgIHdpZHRoOiAxMnB4OyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgbmV4dFZlY3RvckRvdHNYIHtcXG4gIDI1JSB7XFxuICAgIGxlZnQ6IDA7IH1cXG4gIDQ1JSxcXG4gIDUwJSB7XFxuICAgIGxlZnQ6IDE2LjhweDtcXG4gICAgd2lkdGg6IDE0LjRweDtcXG4gICAgaGVpZ2h0OiAxNC40cHg7IH1cXG4gIDkwJSB7XFxuICAgIGxlZnQ6IDA7XFxuICAgIGhlaWdodDogMTJweDtcXG4gICAgd2lkdGg6IDEycHg7IH0gfVxcblxcbkBrZXlmcmFtZXMgbmV4dFZlY3RvckRvdHNYIHtcXG4gIDI1JSB7XFxuICAgIGxlZnQ6IDA7IH1cXG4gIDQ1JSxcXG4gIDUwJSB7XFxuICAgIGxlZnQ6IDE2LjhweDtcXG4gICAgd2lkdGg6IDE0LjRweDtcXG4gICAgaGVpZ2h0OiAxNC40cHg7IH1cXG4gIDkwJSB7XFxuICAgIGxlZnQ6IDA7XFxuICAgIGhlaWdodDogMTJweDtcXG4gICAgd2lkdGg6IDEycHg7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBuZXh0VmVjdG9yRG90c1hSIHtcXG4gIDI1JSB7XFxuICAgIHJpZ2h0OiAwOyB9XFxuICA0NSUsXFxuICA1MCUge1xcbiAgICByaWdodDogMTYuOHB4O1xcbiAgICB3aWR0aDogMTQuNHB4O1xcbiAgICBoZWlnaHQ6IDE0LjRweDsgfVxcbiAgOTAlIHtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGhlaWdodDogMTJweDtcXG4gICAgd2lkdGg6IDEycHg7IH0gfVxcblxcbkBrZXlmcmFtZXMgbmV4dFZlY3RvckRvdHNYUiB7XFxuICAyNSUge1xcbiAgICByaWdodDogMDsgfVxcbiAgNDUlLFxcbiAgNTAlIHtcXG4gICAgcmlnaHQ6IDE2LjhweDtcXG4gICAgd2lkdGg6IDE0LjRweDtcXG4gICAgaGVpZ2h0OiAxNC40cHg7IH1cXG4gIDkwJSB7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBoZWlnaHQ6IDEycHg7XFxuICAgIHdpZHRoOiAxMnB4OyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgbmV4dFZlY3RvckRvdHNZUi1tZWRpdW0ge1xcbiAgMjUlIHtcXG4gICAgYm90dG9tOiAwOyB9XFxuICA0NSUsXFxuICA1MCUge1xcbiAgICBib3R0b206IDExLjJweDtcXG4gICAgaGVpZ2h0OiA5LjZweDtcXG4gICAgd2lkdGg6IDkuNnB4OyB9XFxuICA5MCUge1xcbiAgICBib3R0b206IDA7XFxuICAgIGhlaWdodDogOHB4O1xcbiAgICB3aWR0aDogOHB4OyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIG5leHRWZWN0b3JEb3RzWVItbWVkaXVtIHtcXG4gIDI1JSB7XFxuICAgIGJvdHRvbTogMDsgfVxcbiAgNDUlLFxcbiAgNTAlIHtcXG4gICAgYm90dG9tOiAxMS4ycHg7XFxuICAgIGhlaWdodDogOS42cHg7XFxuICAgIHdpZHRoOiA5LjZweDsgfVxcbiAgOTAlIHtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBoZWlnaHQ6IDhweDtcXG4gICAgd2lkdGg6IDhweDsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIG5leHRWZWN0b3JEb3RzWS1tZWRpdW0ge1xcbiAgMjUlIHtcXG4gICAgdG9wOiAwOyB9XFxuICA0NSUsXFxuICA1MCUge1xcbiAgICB0b3A6IDExLjJweDtcXG4gICAgaGVpZ2h0OiA5LjZweDtcXG4gICAgd2lkdGg6IDkuNnB4OyB9XFxuICA5MCUge1xcbiAgICB0b3A6IDA7XFxuICAgIGhlaWdodDogOHB4O1xcbiAgICB3aWR0aDogOHB4OyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIG5leHRWZWN0b3JEb3RzWS1tZWRpdW0ge1xcbiAgMjUlIHtcXG4gICAgdG9wOiAwOyB9XFxuICA0NSUsXFxuICA1MCUge1xcbiAgICB0b3A6IDExLjJweDtcXG4gICAgaGVpZ2h0OiA5LjZweDtcXG4gICAgd2lkdGg6IDkuNnB4OyB9XFxuICA5MCUge1xcbiAgICB0b3A6IDA7XFxuICAgIGhlaWdodDogOHB4O1xcbiAgICB3aWR0aDogOHB4OyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgbmV4dFZlY3RvckRvdHNYLW1lZGl1bSB7XFxuICAyNSUge1xcbiAgICBsZWZ0OiAwOyB9XFxuICA0NSUsXFxuICA1MCUge1xcbiAgICBsZWZ0OiAxMS4ycHg7XFxuICAgIHdpZHRoOiA5LjZweDtcXG4gICAgaGVpZ2h0OiA5LjZweDsgfVxcbiAgOTAlIHtcXG4gICAgbGVmdDogMDtcXG4gICAgaGVpZ2h0OiA4cHg7XFxuICAgIHdpZHRoOiA4cHg7IH0gfVxcblxcbkBrZXlmcmFtZXMgbmV4dFZlY3RvckRvdHNYLW1lZGl1bSB7XFxuICAyNSUge1xcbiAgICBsZWZ0OiAwOyB9XFxuICA0NSUsXFxuICA1MCUge1xcbiAgICBsZWZ0OiAxMS4ycHg7XFxuICAgIHdpZHRoOiA5LjZweDtcXG4gICAgaGVpZ2h0OiA5LjZweDsgfVxcbiAgOTAlIHtcXG4gICAgbGVmdDogMDtcXG4gICAgaGVpZ2h0OiA4cHg7XFxuICAgIHdpZHRoOiA4cHg7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBuZXh0VmVjdG9yRG90c1hSLW1lZGl1bSB7XFxuICAyNSUge1xcbiAgICByaWdodDogMDsgfVxcbiAgNDUlLFxcbiAgNTAlIHtcXG4gICAgcmlnaHQ6IDExLjJweDtcXG4gICAgd2lkdGg6IDkuNnB4O1xcbiAgICBoZWlnaHQ6IDkuNnB4OyB9XFxuICA5MCUge1xcbiAgICByaWdodDogMDtcXG4gICAgaGVpZ2h0OiA4cHg7XFxuICAgIHdpZHRoOiA4cHg7IH0gfVxcblxcbkBrZXlmcmFtZXMgbmV4dFZlY3RvckRvdHNYUi1tZWRpdW0ge1xcbiAgMjUlIHtcXG4gICAgcmlnaHQ6IDA7IH1cXG4gIDQ1JSxcXG4gIDUwJSB7XFxuICAgIHJpZ2h0OiAxMS4ycHg7XFxuICAgIHdpZHRoOiA5LjZweDtcXG4gICAgaGVpZ2h0OiA5LjZweDsgfVxcbiAgOTAlIHtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGhlaWdodDogOHB4O1xcbiAgICB3aWR0aDogOHB4OyB9IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXI/P3JlZi0tMi0xIS4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWI/P3JlZi0tMi0yIS4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliIS4vc3JjL2xvYWRpbmcvbWFpbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkgMTAgMTEgMTIgMTMgMTQgMTUgMTYgMTcgMTggMTkgMjAgMjEgMjIiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGNoYXJzZXQgXFxcIlVURi04XFxcIjtcXG4vKipcXG4gKiDlsLrlr7gg5Z+656GA5bC65a+4XFxuICog5ZG95ZCN6IO95Zyo6K+t5LmJ55qE5YmN5o+Q5LiL566A5Y2V5bCx5bC96YeP566A5Y2VLCDov5nph4zlj6/ku6XmmK8gc2l6ZS0yeCwgc3BhY2UtMngsIHNpemUtYmFzZSAuLi5cXG4gKiDkuI3ov4flj6/ku6XlnKjor63kuYnnmoTliY3mj5DkuIvlgZrnmoTmm7Tnsr7nroDkuIDkupssIOS6juaYr+eUqOS6hnMyLCBzMeetiVxcbiAqIOWPr+eUqOWPmOmHjzogYCRzMSAtICRzOGBcXG4gKiBAZXhhbXBsZSBzY3NzIC0g5L2/55SoXFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6ICRzMSAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKlxcbiAqIEBleGFtcGxlIGNzcyAtIENTUyDovpPlh7pcXG4gKiAgIC5lbGVtZW50IHtcXG4gKiAgICAgcGFkZGluZzogNHB4ICFkZWZhdWx0O1xcbiAqICAgfVxcbiAqL1xcbi8qIHB1dCB5b3VyIGNvZGUgaGVyZSAqL1xcbi5uZXh0LXRhYmxlIHtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcbiAgLm5leHQtdGFibGUgKixcXG4gIC5uZXh0LXRhYmxlICo6YmVmb3JlLFxcbiAgLm5leHQtdGFibGUgKjphZnRlciB7XFxuICAgIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XFxuICAubmV4dC10YWJsZSB0YWJsZSB7XFxuICAgIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxuICAgIGJvcmRlci1zcGFjaW5nOiAwO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgYmFja2dyb3VuZDogI0ZGRkZGRjsgfVxcbiAgICAubmV4dC10YWJsZSB0YWJsZSB0cjpmaXJzdC1jaGlsZCB0ZCB7XFxuICAgICAgYm9yZGVyLXRvcC13aWR0aDogMDsgfVxcbiAgLm5leHQtdGFibGUgdGgge1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBiYWNrZ3JvdW5kOiAjRUJFQ0YwO1xcbiAgICBjb2xvcjogIzMzMzMzMztcXG4gICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI0RDREVFMzsgfVxcbiAgICAubmV4dC10YWJsZSB0aCAubmV4dC10YWJsZS1jZWxsLXdyYXBwZXIge1xcbiAgICAgIHBhZGRpbmc6IDEycHggMTZweDtcXG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xcbiAgICAgIHdvcmQtYnJlYWs6IGJyZWFrLWFsbDsgfVxcbiAgLm5leHQtdGFibGUtYWZmaXgge1xcbiAgICB6LWluZGV4OiAxOyB9XFxuICAubmV4dC10YWJsZS1oZWFkZXItcmVzaXphYmxlIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuICAgIC5uZXh0LXRhYmxlLWhlYWRlci1yZXNpemFibGUgLm5leHQtdGFibGUtcmVzaXplLWhhbmRsZXIge1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICByaWdodDogMDtcXG4gICAgICB0b3A6IDA7XFxuICAgICAgYm90dG9tOiAwO1xcbiAgICAgIHdpZHRoOiAzcHg7XFxuICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICAgICAgY3Vyc29yOiBldy1yZXNpemU7IH1cXG4gIC5uZXh0LXRhYmxlIHRkIHtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI0RDREVFMzsgfVxcbiAgICAubmV4dC10YWJsZSB0ZCAubmV4dC10YWJsZS1jZWxsLXdyYXBwZXIge1xcbiAgICAgIHBhZGRpbmc6IDEycHggMTZweDtcXG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xcbiAgICAgIHdvcmQtYnJlYWs6IGJyZWFrLWFsbDsgfVxcbiAgICAgIC5uZXh0LXRhYmxlIHRkIC5uZXh0LXRhYmxlLWNlbGwtd3JhcHBlciAubmV4dC1pY29uLWFycm93LWRvd24ubmV4dC10YWJsZS10cmVlLWFycm93LFxcbiAgICAgIC5uZXh0LXRhYmxlIHRkIC5uZXh0LXRhYmxlLWNlbGwtd3JhcHBlciAubmV4dC1pY29uLWFycm93LXJpZ2h0Lm5leHQtdGFibGUtdHJlZS1hcnJvdyxcXG4gICAgICAubmV4dC10YWJsZSB0ZCAubmV4dC10YWJsZS1jZWxsLXdyYXBwZXIgLm5leHQtdGFibGUtdHJlZS1wbGFjZWhvbGRlciB7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDNweDtcXG4gICAgICAgIGZsb2F0OiBsZWZ0OyB9XFxuICAgICAgLm5leHQtdGFibGUgdGQgLm5leHQtdGFibGUtY2VsbC13cmFwcGVyIC5uZXh0LWljb24tYXJyb3ctZG93bi5uZXh0LXRhYmxlLXRyZWUtYXJyb3c6YmVmb3JlLFxcbiAgICAgIC5uZXh0LXRhYmxlIHRkIC5uZXh0LXRhYmxlLWNlbGwtd3JhcHBlciAubmV4dC1pY29uLWFycm93LXJpZ2h0Lm5leHQtdGFibGUtdHJlZS1hcnJvdzpiZWZvcmUge1xcbiAgICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgLm5leHQtdGFibGUgLm5leHQtdGFibGUtZXhwYW5kZWQgLm5leHQtdGFibGUtY2VsbC13cmFwcGVyLFxcbiAgLm5leHQtdGFibGUgLm5leHQtdGFibGUtc2VsZWN0aW9uIC5uZXh0LXRhYmxlLWNlbGwtd3JhcHBlciB7XFxuICAgIG92ZXJmbG93OiB2aXNpYmxlOyB9XFxuICAubmV4dC10YWJsZS5uby1oZWFkZXIgdGFibGUgdHI6Zmlyc3QtY2hpbGQgdGQge1xcbiAgICBib3JkZXItdG9wLXdpZHRoOiAxcHg7IH1cXG4gIC5uZXh0LXRhYmxlLm9ubHktYm90dG9tLWJvcmRlciB7XFxuICAgIGJvcmRlci13aWR0aDogMDsgfVxcbiAgICAubmV4dC10YWJsZS5vbmx5LWJvdHRvbS1ib3JkZXIgdGgge1xcbiAgICAgIGJvcmRlci13aWR0aDogMCAwIDFweCAwOyB9XFxuICAgIC5uZXh0LXRhYmxlLm9ubHktYm90dG9tLWJvcmRlciB0ZCB7XFxuICAgICAgYm9yZGVyLXdpZHRoOiAwIDAgMXB4IDA7IH1cXG4gICAgLm5leHQtdGFibGUub25seS1ib3R0b20tYm9yZGVyIC5uZXh0LXRhYmxlLWV4cGFuZGVkLXJvdyB0aCB7XFxuICAgICAgYm9yZGVyLXdpZHRoOiAwIDAgMXB4IDA7IH1cXG4gICAgLm5leHQtdGFibGUub25seS1ib3R0b20tYm9yZGVyIC5uZXh0LXRhYmxlLWV4cGFuZGVkLXJvdyB0ZCB7XFxuICAgICAgYm9yZGVyLXdpZHRoOiAwIDAgMXB4IDA7IH1cXG4gIC5uZXh0LXRhYmxlLWxvYWRpbmcge1xcbiAgICBkaXNwbGF5OiBibG9jazsgfVxcbiAgLm5leHQtdGFibGUuemVicmEgdHI6bnRoLWNoaWxkKG9kZCkgdGQge1xcbiAgICBiYWNrZ3JvdW5kOiAjRkZGRkZGOyB9XFxuICAubmV4dC10YWJsZS56ZWJyYSB0cjpudGgtY2hpbGQoZXZlbikgdGQge1xcbiAgICBiYWNrZ3JvdW5kOiAjRjdGOEZBOyB9XFxuICAubmV4dC10YWJsZS56ZWJyYSAubmV4dC10YWJsZS1yb3cuaG92ZXJlZCB0ZCB7XFxuICAgIGJhY2tncm91bmQ6ICNGMkYzRjc7XFxuICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuICAubmV4dC10YWJsZS56ZWJyYSAubmV4dC10YWJsZS1yb3cuc2VsZWN0ZWQgdGQge1xcbiAgICBiYWNrZ3JvdW5kOiAjRjJGM0Y3O1xcbiAgICBjb2xvcjogIzMzMzMzMzsgfVxcbiAgLm5leHQtdGFibGUtZW1wdHkge1xcbiAgICBjb2xvcjogI0EwQTJBRDtcXG4gICAgcGFkZGluZzogMzJweCAwO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IH1cXG4gIC5uZXh0LXRhYmxlLWV4cGFuZGVkLXJvdyB0ZCB7XFxuICAgIGJvcmRlci13aWR0aDogMDsgfVxcbiAgICAubmV4dC10YWJsZS1leHBhbmRlZC1yb3cgdGQ6Zmlyc3QtY2hpbGQge1xcbiAgICAgIGJvcmRlci1sZWZ0LXdpZHRoOiAxcHg7IH1cXG4gICAgLm5leHQtdGFibGUtZXhwYW5kZWQtcm93IHRkOmxhc3QtY2hpbGQge1xcbiAgICAgIGJvcmRlci1yaWdodC13aWR0aDogMXB4OyB9XFxuICAubmV4dC10YWJsZS1leHBhbmRlZC1yb3c6bGFzdC1jaGlsZCB0ZCB7XFxuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDFweDsgfVxcbiAgLm5leHQtdGFibGUtZXhwYW5kZWQtcm93IC5uZXh0LXRhYmxlIC5sYXN0IHRkIHtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMDsgfVxcbiAgLm5leHQtdGFibGUtZmlsdGVyLWZvb3RlciB7XFxuICAgIG1hcmdpbjogMTBweCAxMHB4IDA7IH1cXG4gICAgLm5leHQtdGFibGUtZmlsdGVyLWZvb3RlciBidXR0b24ge1xcbiAgICAgIG1hcmdpbi1yaWdodDogNXB4OyB9XFxuICAubmV4dC10YWJsZS1yb3cge1xcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCBlYXNlIC4zcztcXG4gICAgdHJhbnNpdGlvbjogYWxsIGVhc2UgLjNzO1xcbiAgICBiYWNrZ3JvdW5kOiAjRkZGRkZGO1xcbiAgICBjb2xvcjogIzMzMzMzMzsgfVxcbiAgICAubmV4dC10YWJsZS1yb3cuaGlkZGVuIHtcXG4gICAgICBkaXNwbGF5OiBub25lOyB9XFxuICAgIC5uZXh0LXRhYmxlLXJvdy5ob3ZlcmVkIHtcXG4gICAgICBiYWNrZ3JvdW5kOiAjRjJGM0Y3O1xcbiAgICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuICAgIC5uZXh0LXRhYmxlLXJvdy5zZWxlY3RlZCB7XFxuICAgICAgYmFja2dyb3VuZDogI0YyRjNGNztcXG4gICAgICBjb2xvcjogIzMzMzMzMzsgfVxcbiAgLm5leHQtdGFibGUtdHJlZS1wbGFjZWhvbGRlciB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgd2lkdGg6IDEycHg7IH1cXG5cXG4ubGFzdCAubmV4dC10YWJsZS1leHBhbmRlZC1yb3cgdGQge1xcbiAgYm9yZGVyLWJvdHRvbS13aWR0aDogMXB4OyB9XFxuXFxuLm5leHQtdGFibGUtYm9keSxcXG4ubmV4dC10YWJsZS1oZWFkZXIge1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxuICBmb250LXNpemU6IDEycHg7IH1cXG5cXG4ubmV4dC10YWJsZS1ib2R5IHtcXG4gIGZvbnQtc2l6ZTogMTJweDsgfVxcblxcbi5uZXh0LXRhYmxlLWZpeGVkIHtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNEQ0RFRTM7IH1cXG4gIC5uZXh0LXRhYmxlLWZpeGVkIHRhYmxlIHtcXG4gICAgdGFibGUtbGF5b3V0OiBmaXhlZDsgfVxcbiAgLm5leHQtdGFibGUtZml4ZWQgLm5leHQtdGFibGUtaGVhZGVyIHtcXG4gICAgYmFja2dyb3VuZDogI0VCRUNGMDsgfVxcbiAgLm5leHQtdGFibGUtZml4ZWQgdGFibGUgdHIgdGQ6Zmlyc3QtY2hpbGQsXFxuICAubmV4dC10YWJsZS1maXhlZCB0YWJsZSB0ciB0aDpmaXJzdC1jaGlsZCB7XFxuICAgIGJvcmRlci1sZWZ0LXdpZHRoOiAwOyB9XFxuICAubmV4dC10YWJsZS1maXhlZCAubmV4dC10YWJsZS1oZWFkZXIgdGgge1xcbiAgICBib3JkZXItdG9wLXdpZHRoOiAwOyB9XFxuICAubmV4dC10YWJsZS1maXhlZCAubmV4dC10YWJsZS1oZWFkZXIgdHIgdGg6bGFzdC1jaGlsZCB7XFxuICAgIGJvcmRlci1yaWdodC13aWR0aDogMDsgfVxcbiAgLm5leHQtdGFibGUtZml4ZWQgLm5leHQtdGFibGUtYm9keSB0ZCB7XFxuICAgIGJvcmRlci10b3Atd2lkdGg6IDA7IH1cXG4gIC5uZXh0LXRhYmxlLWZpeGVkIC5uZXh0LXRhYmxlLWJvZHkgdHI6bGFzdC1jaGlsZCB0ZCB7XFxuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDA7IH1cXG4gIC5uZXh0LXRhYmxlLWZpeGVkIC5uZXh0LXRhYmxlLWJvZHkgdHIgdGQ6bGFzdC1jaGlsZCB7XFxuICAgIGJvcmRlci1yaWdodC13aWR0aDogMDsgfVxcbiAgLm5leHQtdGFibGUtZml4ZWQubmV4dC10YWJsZS1ncm91cCB0YWJsZSB0ciB0ZDpmaXJzdC1jaGlsZCxcXG4gIC5uZXh0LXRhYmxlLWZpeGVkLm5leHQtdGFibGUtZ3JvdXAgdGFibGUgdHIgdGg6Zmlyc3QtY2hpbGQge1xcbiAgICBib3JkZXItbGVmdC13aWR0aDogMXB4OyB9XFxuICAubmV4dC10YWJsZS1maXhlZC5uZXh0LXRhYmxlLWdyb3VwIC5uZXh0LXRhYmxlLWhlYWRlciB0aCB7XFxuICAgIGJvcmRlci10b3Atd2lkdGg6IDFweDsgfVxcbiAgLm5leHQtdGFibGUtZml4ZWQubmV4dC10YWJsZS1ncm91cCAubmV4dC10YWJsZS1oZWFkZXIgdHIgdGg6bGFzdC1jaGlsZCB7XFxuICAgIGJvcmRlci1yaWdodC13aWR0aDogMXB4OyB9XFxuICAubmV4dC10YWJsZS1maXhlZC5uZXh0LXRhYmxlLWdyb3VwIC5uZXh0LXRhYmxlLWJvZHkgdGQge1xcbiAgICBib3JkZXItdG9wLXdpZHRoOiAxcHg7IH1cXG4gIC5uZXh0LXRhYmxlLWZpeGVkLm5leHQtdGFibGUtZ3JvdXAgLm5leHQtdGFibGUtYm9keSB0cjpsYXN0LWNoaWxkIHRkIHtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMXB4OyB9XFxuICAubmV4dC10YWJsZS1maXhlZC5uZXh0LXRhYmxlLWdyb3VwIC5uZXh0LXRhYmxlLWJvZHkgdHIgdGQ6bGFzdC1jaGlsZCB7XFxuICAgIGJvcmRlci1yaWdodC13aWR0aDogMXB4OyB9XFxuXFxuLm5leHQtdGFibGUtbG9jayAubmV4dC10YWJsZS1ib2R5IHtcXG4gIG92ZXJmbG93LXg6IGF1dG87XFxuICBvdmVyZmxvdy15OiB2aXNpYmxlOyB9XFxuXFxuLm5leHQtdGFibGUtZ3JvdXAge1xcbiAgYm9yZGVyLXdpZHRoOiAwOyB9XFxuICAubmV4dC10YWJsZS1ncm91cCAubmV4dC10YWJsZS1ib2R5IHtcXG4gICAgbWFyZ2luLXRvcDogOHB4OyB9XFxuICAgIC5uZXh0LXRhYmxlLWdyb3VwIC5uZXh0LXRhYmxlLWJvZHkgdGFibGUge1xcbiAgICAgIG1hcmdpbi1ib3R0b206IDhweDsgfVxcbiAgICAgIC5uZXh0LXRhYmxlLWdyb3VwIC5uZXh0LXRhYmxlLWJvZHkgdGFibGUgdHI6Zmlyc3QtY2hpbGQgdGQge1xcbiAgICAgICAgYm9yZGVyLXRvcC13aWR0aDogMXB4OyB9XFxuICAubmV4dC10YWJsZS1ncm91cCAubmV4dC10YWJsZS1ncm91cC1oZWFkZXIgdGQge1xcbiAgICBiYWNrZ3JvdW5kOiAjRUJFQ0YwO1xcbiAgICBjb2xvcjogIzMzMzMzMzsgfVxcbiAgLm5leHQtdGFibGUtZ3JvdXAgLm5leHQtdGFibGUtZ3JvdXAtZm9vdGVyIHRkIHtcXG4gICAgYmFja2dyb3VuZDogI0VCRUNGMDtcXG4gICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gIC5uZXh0LXRhYmxlLWdyb3VwIC5uZXh0LXRhYmxlLXJvdy5ob3ZlcmVkLFxcbiAgLm5leHQtdGFibGUtZ3JvdXAgLm5leHQtdGFibGUtcm93LnNlbGVjdGVkIHtcXG4gICAgYmFja2dyb3VuZDogI0ZGRkZGRjtcXG4gICAgY29sb3I6ICMzMzMzMzM7IH1cXG5cXG4ubmV4dC10YWJsZS1sb2NrIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcbiAgLm5leHQtdGFibGUtbG9jayB0YWJsZSB7XFxuICAgIHRhYmxlLWxheW91dDogZml4ZWQ7IH1cXG5cXG4ubmV4dC10YWJsZS1oZWFkZXItaW5uZXIge1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjsgfVxcblxcbi5uZXh0LXRhYmxlLWxvY2stbGVmdCxcXG4ubmV4dC10YWJsZS1sb2NrLXJpZ2h0IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDA7XFxuICB6LWluZGV4OiAxO1xcbiAgYm9yZGVyOiAwOyB9XFxuICAubmV4dC10YWJsZS1sb2NrLWxlZnQgdGFibGUsXFxuICAubmV4dC10YWJsZS1sb2NrLXJpZ2h0IHRhYmxlIHtcXG4gICAgd2lkdGg6IGF1dG87IH1cXG4gIC5uZXh0LXRhYmxlLWxvY2stbGVmdCAubmV4dC10YWJsZS1ib2R5LFxcbiAgLm5leHQtdGFibGUtbG9jay1yaWdodCAubmV4dC10YWJsZS1ib2R5IHtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjsgfVxcblxcbi5uZXh0LXRhYmxlLWxvY2stcmlnaHQge1xcbiAgcmlnaHQ6IDA7XFxuICBsZWZ0OiBhdXRvOyB9XFxuICAubmV4dC10YWJsZS1sb2NrLXJpZ2h0IHRhYmxlIHRyIHRkOmZpcnN0LWNoaWxkLFxcbiAgLm5leHQtdGFibGUtbG9jay1yaWdodCB0YWJsZSB0ciB0aDpmaXJzdC1jaGlsZCB7XFxuICAgIGJvcmRlci1sZWZ0LXdpZHRoOiAxcHg7IH1cXG4gIC5uZXh0LXRhYmxlLWxvY2stcmlnaHQuc2hhZG93IHtcXG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiAtMnB4IDAgM3B4IHJnYmEoMCwgMCwgMCwgMC4xMik7XFxuICAgICAgICAgICAgYm94LXNoYWRvdzogLTJweCAwIDNweCByZ2JhKDAsIDAsIDAsIDAuMTIpOyB9XFxuXFxuLm5leHQtdGFibGUtbG9jay1sZWZ0LnNoYWRvdyB7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IDJweCAwIDNweCByZ2JhKDAsIDAsIDAsIDAuMTIpO1xcbiAgICAgICAgICBib3gtc2hhZG93OiAycHggMCAzcHggcmdiYSgwLCAwLCAwLCAwLjEyKTsgfVxcblxcbi5uZXh0LXRhYmxlLWZpbHRlciB7XFxuICBsaW5lLWhlaWdodDogMTsgfVxcblxcbi5uZXh0LXRhYmxlLXNvcnQge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2lkdGg6IDE2cHg7XFxuICBoZWlnaHQ6IDE1cHg7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgbGluZS1oZWlnaHQ6IDE7IH1cXG4gIC5uZXh0LXRhYmxlLXNvcnQgLm5leHQtaWNvbiB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgbGVmdDogMDtcXG4gICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gICAgLm5leHQtdGFibGUtc29ydCAubmV4dC1pY29uOmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC10YWJsZS1zb3J0IC5jdXJyZW50IC5uZXh0LWljb24ge1xcbiAgICBjb2xvcjogIzU1ODRGRjsgfVxcbiAgLm5leHQtdGFibGUtc29ydCAubmV4dC1pY29uLWFzY2VuZGluZyB7XFxuICAgIGxlZnQ6IDRweDsgfVxcblxcbi5uZXh0LXRhYmxlLWZpbHRlciB7XFxuICBtYXJnaW4tbGVmdDogNXB4O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgd2lkdGg6IDIwcHg7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IH1cXG4gIC5uZXh0LXRhYmxlLWZpbHRlciAubmV4dC1pY29uIHtcXG4gICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gICAgLm5leHQtdGFibGUtZmlsdGVyIC5uZXh0LWljb246YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTJweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG5cXG4ubmV4dC10YWJsZS1leHBhbmRlZC1jdHJsLmRpc2FibGVkIHtcXG4gIGNvbG9yOiAjOTk5OTk5OyB9XFxuXFxuLm5leHQtdGFibGUtZXhwYW5kZWQtY3RybCAubmV4dC1pY29uOmJlZm9yZSB7XFxuICB3aWR0aDogMTJweDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyPz9yZWYtLTItMSEuL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliPz9yZWYtLTItMiEuL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYiEuL3NyYy90YWJsZS9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUgNiA3IDggOSAxMCAxMSAxMiAxMyAxNCAxNSAxNiAxNyAxOCAxOSAyMCAyMSAyMiIsImV4cG9ydCBkZWZhdWx0IHtcbiAgICBtb21lbnRMb2NhbGU6ICd6aC1jbicsXG4gICAgVGltZWxpbmU6IHtcbiAgICAgICAgZXhwYW5kOiAn5bGV5byAJyxcbiAgICAgICAgZm9sZDogJ+aUtui1tycsXG4gICAgfSxcbiAgICBDYXJkOiB7XG4gICAgICAgIGV4cGFuZDogJ+WxleW8gCcsXG4gICAgICAgIGZvbGQ6ICfmlLbotbcnLFxuICAgIH0sXG4gICAgQ2FsZW5kYXI6IHtcbiAgICAgICAgdG9kYXk6ICfku4rlpKknLFxuICAgICAgICBub3c6ICfmraTliLsnLFxuICAgICAgICBvazogJ+ehruWumicsXG4gICAgICAgIGNsZWFyOiAn5riF6ZmkJyxcbiAgICAgICAgbW9udGg6ICfmnIgnLFxuICAgICAgICB5ZWFyOiAn5bm0JyxcbiAgICAgICAgcHJldlllYXI6ICfkuIrkuIDlubQnLFxuICAgICAgICBuZXh0WWVhcjogJ+S4i+S4gOW5tCcsXG4gICAgICAgIHByZXZNb250aDogJ+S4iuS4quaciCcsXG4gICAgICAgIG5leHRNb250aDogJ+S4i+S4quaciCcsXG4gICAgICAgIHByZXZEZWNhZGU6ICfkuIrljYHlubQnLFxuICAgICAgICBuZXh0RGVjYWRlOiAn5ZCO5Y2B5bm0JyxcbiAgICB9LFxuICAgIERhdGVQaWNrZXI6IHtcbiAgICAgICAgcGxhY2Vob2xkZXI6ICfor7fpgInmi6nml6XmnJ8nLFxuICAgICAgICBkYXRldGltZVBsYWNlaG9sZGVyOiAn6K+36YCJ5oup5pel5pyf5ZKM5pe26Ze0JyxcbiAgICAgICAgbW9udGhQbGFjZWhvbGRlcjogJ+ivt+mAieaLqeaciCcsXG4gICAgICAgIHllYXJQbGFjZWhvbGRlcjogJ+ivt+mAieaLqeW5tCcsXG4gICAgICAgIG5vdzogJ+atpOWIuycsXG4gICAgICAgIHNlbGVjdFRpbWU6ICfpgInmi6nml7bpl7QnLFxuICAgICAgICBzZWxlY3REYXRlOiAn6YCJ5oup5pel5pyfJyxcbiAgICAgICAgb2s6ICfnoa7lrponLFxuICAgICAgICBjbGVhcjogJ+a4hemZpCcsXG4gICAgICAgIHN0YXJ0UGxhY2Vob2xkZXI6ICfotbflp4vml6XmnJ8nLFxuICAgICAgICBlbmRQbGFjZWhvbGRlcjogJ+e7k+adn+aXpeacnycsXG4gICAgICAgIGhvdXI6ICfml7YnLFxuICAgICAgICBtaW51dGU6ICfliIYnLFxuICAgICAgICBzZWNvbmQ6ICfnp5InXG4gICAgfSxcbiAgICBEaWFsb2c6IHtcbiAgICAgICAgb2s6ICfnoa7orqQnLFxuICAgICAgICBjYW5jZWw6ICflj5bmtognXG4gICAgfSxcbiAgICBQYWdpbmF0aW9uOiB7XG4gICAgICAgIHByZXY6ICfkuIrkuIDpobUnLFxuICAgICAgICBuZXh0OiAn5LiL5LiA6aG1JyxcbiAgICAgICAgZ29UbzogJ+WIsOesrCcsXG4gICAgICAgIHBhZ2U6ICfpobUnLFxuICAgICAgICBnbzogJ+ehruWumicsXG4gICAgICAgIHBhZ2VTaXplOiAn5q+P6aG15pi+56S677yaJ1xuICAgIH0sXG4gICAgSW5wdXQ6IHtcbiAgICAgICAgY2xlYXI6ICfmuIXpmaQnXG4gICAgfSxcbiAgICBTZWxlY3Q6IHtcbiAgICAgICAgc2VsZWN0UGxhY2Vob2xkZXI6ICfor7fpgInmi6knLFxuICAgICAgICBhdXRvQ29tcGxldGVQbGFjZWhvbGRlcjogJ+ivt+i+k+WFpScsXG4gICAgICAgIG5vdEZvdW5kQ29udGVudDogJ+aXoOmAiemhuSdcbiAgICB9LFxuICAgIFRhYmxlOiB7XG4gICAgICAgIGVtcHR5OiAn5rKh5pyJ5pWw5o2uJyxcbiAgICAgICAgb2s6ICfnoa7orqQnLFxuICAgICAgICByZXNldDogJ+mHjee9ricsXG4gICAgICAgIGFzYzogJ+WNh+W6jycsXG4gICAgICAgIGRlc2M6ICfpmY3luo8nLFxuICAgICAgICBleHBhbmRlZDogJ+W3suWxleW8gCcsXG4gICAgICAgIGZvbGRlZDogJ+W3suaKmOWPoCcsXG4gICAgICAgIGZpbHRlcjogJ+etm+mAiScsXG4gICAgICAgIHNlbGVjdEFsbDogJ+WFqOmAiSdcbiAgICB9LFxuICAgIFRpbWVQaWNrZXI6IHtcbiAgICAgICAgcGxhY2Vob2xkZXI6ICfor7fpgInmi6nml7bpl7QnLFxuICAgICAgICBjbGVhcjogJ+a4hemZpCcsXG4gICAgICAgIGhvdXI6ICfml7YnLFxuICAgICAgICBtaW51dGU6ICfliIYnLFxuICAgICAgICBzZWNvbmQ6ICfnp5InXG4gICAgfSxcbiAgICBUcmFuc2Zlcjoge1xuICAgICAgICBpdGVtczogJ+mhuScsXG4gICAgICAgIGl0ZW06ICfpobknLFxuICAgICAgICBtb3ZlQWxsOiAn56e75Yqo5YWo6YOoJyxcbiAgICAgICAgc2VhcmNoUGxhY2Vob2xkZXI6ICfor7fovpPlhaUnXG4gICAgfSxcbiAgICBVcGxvYWQ6IHtcbiAgICAgICAgY2FyZDoge1xuICAgICAgICAgICAgY2FuY2VsOiAn5Y+W5raIJyxcbiAgICAgICAgICAgIGFkZFBob3RvOiAn5LiK5Lyg5Zu+54mHJ1xuICAgICAgICB9LFxuICAgICAgICBkcmFnOiB7XG4gICAgICAgICAgICB0ZXh0OiAn54K55Ye75oiW6ICF5ouW5Yqo5paH5Lu25Yiw6Jma57q/5qGG5YaF5LiK5LygJyxcbiAgICAgICAgICAgIGhpbnQ6ICfmlK/mjIEgZG9jeCwgeGxzLCBQREYsIHJhciwgemlwLCBQTkcsIEpQRyDnrYnnsbvlnovnmoTmlofku7YnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFNlYXJjaDoge1xuICAgICAgICBidXR0b25UZXh0OiAn5pCc57SiJyxcbiAgICB9LFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9sb2NhbGUvemgtY24uanMiLCJpbXBvcnQgJy4uL2FuaW1hdGUvc3R5bGUuanMnO1xuaW1wb3J0ICcuL21haW4uc2Nzcyc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvb3ZlcmxheS9zdHlsZS5qcyIsImltcG9ydCBDaGVja2JveCBmcm9tICcuL2NoZWNrYm94JztcbmltcG9ydCBHcm91cCBmcm9tICcuL2NoZWNrYm94LWdyb3VwJztcblxuQ2hlY2tib3guR3JvdXAgPSBHcm91cDtcblxuZXhwb3J0IGRlZmF1bHQgQ2hlY2tib3g7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY2hlY2tib3gvaW5kZXguanN4IiwiaW1wb3J0ICcuLi9pY29uL3N0eWxlLmpzJztcbmltcG9ydCAnLi4vYW5pbWF0ZS9zdHlsZS5qcyc7XG5pbXBvcnQgJy4vbWFpbi5zY3NzJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jaGVja2JveC9zdHlsZS5qcyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbnRleHRQcm9wcyhwcm9wcywgY29udGV4dCwgZGlzcGxheU5hbWUpIHtcbiAgICBjb25zdCB7IHByZWZpeCwgbG9jYWxlLCBwdXJlLCBydGwgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgbmV4dFByZWZpeCwgbmV4dExvY2FsZSwgbmV4dFB1cmUsIG5leHRXYXJuaW5nLCBuZXh0UnRsIH0gPSBjb250ZXh0O1xuXG4gICAgY29uc3QgbmV3UHJlZml4ID0gcHJlZml4IHx8IG5leHRQcmVmaXg7XG5cbiAgICBsZXQgbG9jYWxlRnJvbUNvbnRleHQ7XG4gICAgaWYgKG5leHRMb2NhbGUpIHtcbiAgICAgICAgbG9jYWxlRnJvbUNvbnRleHQgPSBuZXh0TG9jYWxlW2Rpc3BsYXlOYW1lXTtcbiAgICAgICAgaWYgKGxvY2FsZUZyb21Db250ZXh0KSB7XG4gICAgICAgICAgICBsb2NhbGVGcm9tQ29udGV4dC5tb21lbnRMb2NhbGUgPSBuZXh0TG9jYWxlLm1vbWVudExvY2FsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgbmV3TG9jYWxlO1xuICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgbmV3TG9jYWxlID0geyAuLi4obG9jYWxlRnJvbUNvbnRleHQgfHwge30pLCAuLi5sb2NhbGUgfTtcbiAgICB9IGVsc2UgaWYgKGxvY2FsZUZyb21Db250ZXh0KSB7XG4gICAgICAgIG5ld0xvY2FsZSA9IGxvY2FsZUZyb21Db250ZXh0O1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1B1cmUgPSB0eXBlb2YgcHVyZSA9PT0gJ2Jvb2xlYW4nID8gcHVyZSA6IG5leHRQdXJlO1xuICAgIGNvbnN0IG5ld1J0bCA9IHR5cGVvZiBydGwgPT09ICdib29sZWFuJyA/IHJ0bCA6IG5leHRSdGw7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBwcmVmaXg6IG5ld1ByZWZpeCxcbiAgICAgICAgbG9jYWxlOiBuZXdMb2NhbGUsXG4gICAgICAgIHB1cmU6IG5ld1B1cmUsXG4gICAgICAgIHJ0bDogbmV3UnRsLFxuICAgICAgICB3YXJuaW5nOiBuZXh0V2FybmluZ1xuICAgIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29uZmlnLXByb3ZpZGVyL2dldC1jb250ZXh0LXByb3BzLmpzeCIsImltcG9ydCB7Y2FtZWxjYXNlLCBoeXBoZW5hdGV9IGZyb20gJy4vc3RyaW5nJztcbmltcG9ydCB7ZWFjaH0gZnJvbSAnLi9vYmplY3QnO1xuXG4vKipcbiAqIOaYr+WQpuiDveS9v+eUqCBET00g5pa55rOVXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGhhc0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICEhd2luZG93LmRvY3VtZW50ICYmICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudDtcblxuLyoqXG4gKiDoioLngrnmmK/lkKbljIXlkKvmjIflrpogY2xhc3NOYW1lXG4gKiBAcGFyYW0gIHtFbGVtZW50fSAgbm9kZVxuICogQHBhcmFtICB7U3RyaW5nfSAgY2xhc3NOYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICpcbiAqIEBleGFtcGxlXG4gKiBkb20uaGFzQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2ZvbycpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzQ2xhc3MgKG5vZGUsIGNsYXNzTmFtZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaGFzRE9NIHx8ICFub2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5jbGFzc0xpc3QpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2xhc3NOYW1lLmluZGV4T2YoY2xhc3NOYW1lKSA+IC0xO1xuICAgIH1cbn1cblxuLyoqXG4gKiDmt7vliqAgY2xhc3NOYW1lXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAqXG4gKiBAZXhhbXBsZVxuICogZG9tLmFkZENsYXNzKGRvY3VtZW50LmJvZHksICdmb28nKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENsYXNzIChub2RlLCBjbGFzc05hbWUsIF9mb3JjZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaGFzRE9NIHx8ICFub2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5jbGFzc0xpc3QpIHtcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgfSBlbHNlIGlmIChfZm9yY2UgPT09IHRydWUgfHwgIWhhc0NsYXNzKG5vZGUsIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgbm9kZS5jbGFzc05hbWUgKz0gYCAke2NsYXNzTmFtZX1gO1xuICAgIH1cbn1cblxuLyoqXG4gKiDnp7vpmaQgY2xhc3NOYW1lXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGNsYXNzTmFtZVxuICpcbiAqIEBleGFtcGxlXG4gKiBkb20ucmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2ZvbycpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKG5vZGUsIGNsYXNzTmFtZSwgX2ZvcmNlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFoYXNET00gfHwgIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLmNsYXNzTGlzdCkge1xuICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICB9IGVsc2UgaWYgKF9mb3JjZSA9PT0gdHJ1ZSB8fCBoYXNDbGFzcyhub2RlLCBjbGFzc05hbWUpKSB7XG4gICAgICAgIG5vZGUuY2xhc3NOYW1lID0gbm9kZS5jbGFzc05hbWUucmVwbGFjZShjbGFzc05hbWUsICcnKS5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiDliIfmjaIgY2xhc3NOYW1lXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGNsYXNzTmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgIOaJp+ihjOWQjuiKgueCueS4iuaYr+WQpui/mOacieatpCBjbGFzc05hbWVcbiAqXG4gKiBAZXhhbXBsZVxuICogZG9tLnRvZ2dsZUNsYXNzKGRvY3VtZW50LmJvZHksICdmb28nKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzIChub2RlLCBjbGFzc05hbWUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWhhc0RPTSB8fCAhbm9kZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuY2xhc3NMaXN0KSB7XG4gICAgICAgIHJldHVybiBub2RlLmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmbGFnID0gaGFzQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTtcbiAgICAgICAgZmxhZyA/IHJlbW92ZUNsYXNzKG5vZGUsIGNsYXNzTmFtZSwgdHJ1ZSkgOiBhZGRDbGFzcyhub2RlLCBjbGFzc05hbWUsIHRydWUpO1xuXG4gICAgICAgIHJldHVybiAhZmxhZztcbiAgICB9XG59XG5cbi8qKlxuICog5YWD57Sg5piv5ZCm5Yy56YWNIENTUyDpgInmi6nlmahcbiAqIEBwYXJhbSAge0VsZW1lbnR9IG5vZGUgICAgICAgRE9NIOiKgueCuVxuICogQHBhcmFtICB7U3RyaW5nfSAgc2VsZWN0b3IgICBDU1Mg6YCJ5oup5ZmoXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICpcbiAqIEBleGFtcGxlXG4gKiBkb20ubWF0Y2hlcyhtb3VudE5vZGUsICcuY29udGFpbmVyJyk7IC8vIGJvb2xlYW5cbiAqL1xuZXhwb3J0IGNvbnN0IG1hdGNoZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IG1hdGNoZXNGbiA9IG51bGw7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaGFzRE9NKSB7XG4gICAgICAgIGNvbnN0IF9ib2R5ID0gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5oZWFkO1xuICAgICAgICBtYXRjaGVzRm4gPSBfYm9keS5tYXRjaGVzID8gJ21hdGNoZXMnIDpcbiAgICAgICAgICAgIF9ib2R5LndlYmtpdE1hdGNoZXNTZWxlY3RvciA/ICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InIDpcbiAgICAgICAgICAgICAgICBfYm9keS5tc01hdGNoZXNTZWxlY3RvciA/ICdtc01hdGNoZXNTZWxlY3RvcicgOlxuICAgICAgICAgICAgICAgICAgICBfYm9keS5tb3pNYXRjaGVzU2VsZWN0b3IgPyAnbW96TWF0Y2hlc1NlbGVjdG9yJyA6IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlLCBzZWxlY3Rvcikge1xuICAgICAgICBpZiAoIWhhc0RPTSB8fCAhbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoZXNGbiA/IG5vZGVbbWF0Y2hlc0ZuXShzZWxlY3RvcikgOiBmYWxzZTtcbiAgICB9O1xufSgpO1xuXG4vKipcbiAqIOiOt+WPluWFg+e0oOiuoeeul+WQjueahOagt+W8j1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge0VsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gX2dldENvbXB1dGVkU3R5bGUgKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSAxID8gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCkgOiB7fTtcbn1cblxuY29uc3QgUElYRUxfUEFUVEVSTiA9IC9tYXJnaW58cGFkZGluZ3x3aWR0aHxoZWlnaHR8bWF4fG1pbnxvZmZzZXR8c2l6ZS9pO1xuY29uc3QgcmVtb3ZlUGl4ZWwgPSB7bGVmdDogMSwgdG9wOiAxLCByaWdodDogMSwgYm90dG9tOiAxfTtcblxuLyoqXG4gKiDmoKHpqozlubbkv67mraPlhYPntKDnmoTmoLflvI/lsZ7mgKflgLxcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSAge051bWJlcn0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gX2dldFN0eWxlVmFsdWUgKG5vZGUsIHR5cGUsIHZhbHVlKSB7XG4gICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnaGVpZ2h0Jykge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUub2Zmc2V0SGVpZ2h0IHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICd3aWR0aCcpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLm9mZnNldFdpZHRoIHx8IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoISh0eXBlIGluIHJlbW92ZVBpeGVsKSkge1xuICAgICAgICAvLyDlsZ7mgKflgLzmmK/lkKbpnIDopoHljrvmjokgcHgg5Y2V5L2N77yM6L+Z6YeM5YGH5a6a5q2k57G755qE5bGe5oCn5YC86YO95pivIHB4IOS4uuWNleS9jeeahFxuICAgICAgICByZW1vdmVQaXhlbFt0eXBlXSA9IFBJWEVMX1BBVFRFUk4udGVzdCh0eXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVtb3ZlUGl4ZWxbdHlwZV0gPyAocGFyc2VGbG9hdCh2YWx1ZSkgfHwgMCkgOiB2YWx1ZTtcbn1cblxuY29uc3QgZmxvYXRNYXAgPSB7Y3NzRmxvYXQ6IDEsIHN0eWxlRmxvYXQ6IDEsIGZsb2F0OiAxfTtcblxuLyoqXG4gKiDojrflj5blhYPntKDorqHnrpflkI7nmoTmoLflvI9cbiAqIEBwYXJhbSAge0VsZW1lbnR9IG5vZGUgRE9NIOiKgueCuVxuICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIOWxnuaAp+WQjVxuICogQHJldHVybiB7TnVtYmVyfE9iamVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0eWxlIChub2RlLCBuYW1lKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFoYXNET00gfHwgIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qgc3R5bGUgPSBfZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblxuICAgIC8vIOWmguaenOS4jeaMh+WumuWxnuaAp+WQje+8jOWImei/lOWbnuWFqOmDqOWAvFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG5cbiAgICBuYW1lID0gZmxvYXRNYXBbbmFtZV0gPyAnY3NzRmxvYXQnIGluIG5vZGUuc3R5bGUgPyAnY3NzRmxvYXQnIDogJ3N0eWxlRmxvYXQnIDogbmFtZTtcblxuICAgIHJldHVybiBfZ2V0U3R5bGVWYWx1ZShub2RlLCBuYW1lLCBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGh5cGhlbmF0ZShuYW1lKSkgfHwgbm9kZS5zdHlsZVtjYW1lbGNhc2UobmFtZSldKTtcbn1cblxuLyoqXG4gKiDorr7nva7lhYPntKDnmoTmoLflvI9cbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSAgRE9NIOiKgueCuVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBuYW1lICDlsZ7mgKflkI3vvIzmiJbogIXmmK/kuIDkuKrlr7nosaHvvIzljIXlkKvlpJrkuKrlsZ7mgKdcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWUg5bGe5oCn5YC8XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIOiuvue9ruWNleS4quWxnuaAp+WAvFxuICogZG9tLnNldFN0eWxlKG1vdW50Tm9kZSwgJ3dpZHRoJywgMTAwKTtcbiAqIC8vIOiuvue9ruWkmuadoeWxnuaAp+WAvFxuICogZG9tLnNldFN0eWxlKG1vdW50Tm9kZSwge1xuICogICAgIHdpZHRoOiAxMDAsXG4gKiAgICAgaGVpZ2h0OiAyMDBcbiAqIH0pO1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0U3R5bGUgKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFoYXNET00gfHwgIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIOaJuemHj+iuvue9ruWkmuS4quWAvFxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBlYWNoKG5hbWUsICh2YWwsIGtleSkgPT4gc2V0U3R5bGUobm9kZSwga2V5LCB2YWwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gZmxvYXRNYXBbbmFtZV0gPyAnY3NzRmxvYXQnIGluIG5vZGUuc3R5bGUgPyAnY3NzRmxvYXQnIDogJ3N0eWxlRmxvYXQnIDogbmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgUElYRUxfUEFUVEVSTi50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGAke3ZhbHVlfXB4YDtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnN0eWxlW2NhbWVsY2FzZShuYW1lKV0gPSB2YWx1ZTsgLy8gSUU4IHN1cHBvcnRcbiAgICB9XG59XG5cbi8qKlxuICog6I635Y+W6buY6K6k55qE5rua5Yqo5p2h5aSn5bCPXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpZHRoLCBoZWlnaHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbGJhciAoKSB7XG4gICAgY29uc3Qgc2Nyb2xsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBzZXRTdHlsZShzY3JvbGxEaXYsIHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHdpZHRoOiAnMTAwcHgnLFxuICAgICAgICBoZWlnaHQ6ICcxMDBweCcsXG4gICAgICAgIG92ZXJmbG93OiAnc2Nyb2xsJyxcbiAgICAgICAgdG9wOiAnLTk5OTlweCdcbiAgICB9KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcm9sbERpdik7XG4gICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSBzY3JvbGxEaXYub2Zmc2V0V2lkdGggLSBzY3JvbGxEaXYuY2xpZW50V2lkdGg7XG4gICAgY29uc3Qgc2Nyb2xsYmFySGVpZ2h0ID0gc2Nyb2xsRGl2Lm9mZnNldEhlaWdodCAtIHNjcm9sbERpdi5jbGllbnRIZWlnaHQ7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHNjcm9sbGJhcldpZHRoLFxuICAgICAgICBoZWlnaHQ6IHNjcm9sbGJhckhlaWdodFxuICAgIH07XG59XG5cbi8qKlxuICog6I635Y+W5YWD57Sg6Led56a76KeG5Y+j6aG26YOo5ZKM5bem6L6555qE5YGP56e76Led56a7XG4gKiBAcmV0dXJuIHtPYmplY3R9IHRvcCwgbGVmdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T2Zmc2V0IChub2RlKSB7XG4gICAgY29uc3QgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgd2luID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxuICAgIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbC9kb20uanMiLCIvKipcbiAqIOWwhuWtl+espuS4sui9rOWMluS4uumpvOWzsOW8j+WGmeazlVxuICogQHBhcmFtICB7U3RyaW5nfSBzdHIg5L6L77yaLXdlYmtpdC10cmFuc2l0aW9uXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICDkvovvvJpXZWJraXRUcmFuc2l0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYW1lbGNhc2UgKHN0cikge1xuICAgIGlmICghLy0vLnRlc3Qoc3RyKSkge1xuICAgICAgICByZXR1cm4gc3RyIHx8ICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLShbYS16XSkvZywgKCQwLCAkMSkgPT4gJDEudG9VcHBlckNhc2UoKSk7XG59XG5cbi8qKlxuICog5bCG6am85bOw5byP5a2X56ym5Liy6L2s5YyW5Li66L+e5a2X56ym5YaZ5rOVXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0ciDkvovvvJpXZWJraXRUcmFuc2l0aW9uXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICDkvovvvJotd2Via2l0LXRyYW5zaXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5cGhlbmF0ZSAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csICQwID0+IGAtJHskMC50b0xvd2VyQ2FzZSgpfWApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWwvc3RyaW5nLmpzIiwiLyoqXG4gKiBJRea1j+iniOWZqOeahOa4suafk+W8leaTjueJiOacrOWPt1xuICog5rOo5oSP77ya5q2k5bGe5oCn5LiO5rWP6KeI5Zmo54mI5pys5Y+35LiN5ZCM77yMSUXnmoTmuLLmn5PlvJXmk47niYjmnKzlj7fmmK/lj6/ku6XpgJrov4dIVE1MIGhlYWRlcuaIluaJi+WKqOiuvue9ruWOu+abtOaUueeahFxuICogQHR5cGUge051bWJlcn0gNiB+IDEwXG4gKi9cbmV4cG9ydCBjb25zdCBpZVZlcnNpb24gPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIOWIpOaWreaYr+WQpuaYr+eUn+S6p+eOr+Wig1xuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc1Byb2R1Y3Rpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgUFJPRFVDVElPTl9FTlYgPSAncHJvZHVjdGlvbic7XG4gICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gUFJPRFVDVElPTl9FTlYpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy9cbiAgICB9XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5wcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gUFJPRFVDVElPTl9FTlYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaWVWZXJzaW9uLFxuICAgIGlzUHJvZHVjdGlvbixcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbC9lbnYuanMiLCJleHBvcnQgZGVmYXVsdCB7XG4gICAgQkFDS1NQQUNFOiA4LFxuICAgIFRBQjogOSxcbiAgICBFTlRFUjogMTMsXG4gICAgU0hJRlQ6IDE2LFxuICAgIENUUkw6IDE3LFxuICAgIEFMVDogMTgsXG4gICAgRVNDOiAyNyxcbiAgICBTUEFDRTogMzIsXG4gICAgRU5EOiAzNSxcbiAgICBIT01FOiAzNixcbiAgICBMRUZUOiAzNyxcbiAgICBVUDogMzgsXG4gICAgUklHSFQ6IDM5LFxuICAgIERPV046IDQwLFxuXG4gICAgLy8gdmVyc2lvbiAwLnhcbiAgICBFU0NBUEU6IDI3LFxuICAgIExFRlRfQVJST1c6IDM3LFxuICAgIFVQX0FSUk9XOiAzOCxcbiAgICBSSUdIVF9BUlJPVzogMzksXG4gICAgRE9XTl9BUlJPVzogNDAsXG5cbiAgICAvLyBNYWNPU1xuICAgIENPTlRST0w6IDE3LFxuICAgIE9QVElPTjogMTgsXG4gICAgQ01EOiA5MSxcbiAgICBDT01NQU5EOiA5MSxcbiAgICBERUxFVEU6IDgsXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWwva2V5Y29kZS5qcyIsInZhciBzdHlsZUVxdWFsID0gcmVxdWlyZSgnc3R5bGUtZXF1YWwnKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHR5cGUoYSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhKSA/ICdhcnJheScgOiB0eXBlb2YgYTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudEVxdWFscyhhLCBiKSB7XG4gIHZhciB0eXBlT2ZBID0gdHlwZShhKTtcbiAgdmFyIHR5cGVPZkIgPSB0eXBlKGIpO1xuXG4gIGlmICh0eXBlT2ZBICE9PSB0eXBlT2ZCKSByZXR1cm4gZmFsc2U7XG5cbiAgc3dpdGNoICh0eXBlT2ZBKSB7XG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghZWxlbWVudEVxdWFscyhhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuIGEgPT09IGI7XG4gICAgICBpZiAoYS50eXBlICE9PSBiLnR5cGUpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChhLmtleSAhPT0gYi5rZXkpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChhLnJlZiAhPT0gYi5yZWYpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBzaGFsbG93RWxlbWVudEVxdWFscyhhLnByb3BzLCBiLnByb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaGFsbG93RWxlbWVudEVxdWFscyhhLCBiKSB7XG4gIHZhciBhQ291bnQgPSAwO1xuICB2YXIgYkNvdW50ID0gMDtcblxuICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGtleSkpIHtcbiAgICAgIGlmIChrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgLy8gTk9URShsbXIpOiBraW5kIG9mIHJpc2t5LCBidXQgaSdtIGFzc3VtaW5nIHRoYXQgYSBgc3R5bGVgIHByb3AgaXMgYSBSZWFjdCBOYXRpdmUgc3R5bGUsXG4gICAgICAgIC8vIGFuZCB1c2luZyB0aGUgYHN0eWxlRXF1YWxgIGFsZ29yaXRobSBoZXJlLlxuICAgICAgICBpZiAoIXN0eWxlRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2NoaWxkcmVuJykge1xuICAgICAgICAvLyB3aWxsIGNvbXBhcmUgY2hpbGRyZW4gbGF0ZXJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYUNvdW50Kys7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIGIpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXkpKSB7XG4gICAgICBiQ291bnQrKztcbiAgICB9XG4gIH1cblxuICBpZiAoYUNvdW50ICE9PSBiQ291bnQpIHJldHVybiBmYWxzZTtcblxuICAvLyBjb21wYXJlIGNoaWxkcmVuIGxhc3QuLi5cbiAgcmV0dXJuIGVsZW1lbnRFcXVhbHMoYS5jaGlsZHJlbiwgYi5jaGlsZHJlbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0VsZW1lbnRFcXVhbHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX3NoYWxsb3ctZWxlbWVudC1lcXVhbHNAMS4wLjFAc2hhbGxvdy1lbGVtZW50LWVxdWFscy9pbmRleC5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgZG9tLCBldmVudHMsIGZ1bmMsIHN1cHBvcnQsIGZvY3VzLCBLRVlDT0RFLCBndWlkIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgb3ZlcmxheU1hbmFnZXIgZnJvbSAnLi9tYW5hZ2VyJztcbmltcG9ydCBHYXRld2F5IGZyb20gJy4vZ2F0ZXdheSc7XG5pbXBvcnQgUG9zaXRpb24gZnJvbSAnLi9wb3NpdGlvbic7XG5pbXBvcnQgZmluZE5vZGUgZnJvbSAnLi91dGlscy9maW5kLW5vZGUnO1xuXG5jb25zdCB7IHNhdmVMYXN0Rm9jdXNOb2RlLCBnZXRGb2N1c05vZGVMaXN0LCBiYWNrTGFzdEZvY3VzTm9kZSB9ID0gZm9jdXM7XG5jb25zdCB7IG1ha2VDaGFpbiwgbm9vcCwgYmluZEN0eCB9ID0gZnVuYztcblxuY29uc3QgaXNTY3JvbGxEaXNwbGF5ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNjcm9sbGJhclN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgJzo6LXdlYmtpdC1zY3JvbGxiYXInKTtcbiAgICAgICAgcmV0dXJuICFzY3JvbGxiYXJTdHlsZSB8fCBzY3JvbGxiYXJTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXNwbGF5JykgIT09ICdub25lJztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlnbm9yZSBlcnJvciBmb3IgZmlyZWZveFxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IGhhc1Njcm9sbCA9ICgpID0+IHtcbiAgICBjb25zdCBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgcmV0dXJuIGRvYy5zY3JvbGxIZWlnaHQgPiBkb2MuY2xpZW50SGVpZ2h0ICYmIGRvbS5zY3JvbGxiYXIoKS53aWR0aCA+IDAgJiYgaXNTY3JvbGxEaXNwbGF5KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkgJiYgaXNTY3JvbGxEaXNwbGF5KGRvY3VtZW50LmJvZHkpO1xufTtcbmNvbnN0IHByZWZpeGVzID0gWyctd2Via2l0LScsICctbW96LScsICctby0nLCAnbXMtJywgJyddO1xuY29uc3QgZ2V0U3R5bGVQcm9wZXJ0eSA9IChub2RlLCBuYW1lKSA9PiB7XG4gICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBsZXQgcmV0ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXQgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByZWZpeGVzW2ldICsgbmFtZSk7XG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5jb25zdCBtb2RhbHMgPSBbXTtcbmxldCBib2R5T3ZlcmZsb3dZLCBib2R5UGFkZGluZ1JpZ2h0O1xuXG4vKipcbiAqIE92ZXJsYXlcbiAqICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPdmVybGF5IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHB1cmU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBydGw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5YaF5a65XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuaYvuekuuW8ueWxglxuICAgICAgICAgKi9cbiAgICAgICAgdmlzaWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLor7fmsYLlhbPpl63ml7bop6blj5Hkuovku7bnmoTlm57osIPlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5by55bGC5YWz6Zet55qE5p2l5rqQXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIERPTSDkuovku7ZcbiAgICAgICAgICovXG4gICAgICAgIG9uUmVxdWVzdENsb3NlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguWumuS9jeeahOWPgueFp+WFg+e0oFxuICAgICAgICAgKi9cbiAgICAgICAgdGFyZ2V0OiBQcm9wVHlwZXMuYW55LFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC55u45a+55LqO5Y+C54Wn5YWD57Sg55qE5a6a5L2NLCDor6bop4HlvIDlj5HmjIfljZfnmoRb5a6a5L2N6YOo5YiGXSgj5a6a5L2NKVxuICAgICAgICAgKi9cbiAgICAgICAgYWxpZ246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5ib29sXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLnm7jlr7nkuo7lj4LnhaflhYPntKDlrprkvY3nmoTlvq7osINcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNldDogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICAvKipcbiAgICAgICAgICog5riy5p+T57uE5Lu255qE5a655Zmo77yM5aaC5p6c5piv5Ye95pWw6ZyA6KaB6L+U5ZueIHJlZu+8jOWmguaenOaYr+Wtl+espuS4suWImeaYr+ivpSBET00g55qEIGlk77yM5Lmf5Y+v5Lul55u05o6l5Lyg5YWlIERPTSDoioLngrlcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5lcjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuaYvuekuumBrue9qVxuICAgICAgICAgKi9cbiAgICAgICAgaGFzTWFzazogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbmlK/mjIEgZXNjIOaMiemUruWFs+mXreW8ueWxglxuICAgICAgICAgKi9cbiAgICAgICAgY2FuQ2xvc2VCeUVzYzogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDngrnlh7vlvLnlsYLlpJbnmoTljLrln5/mmK/lkKblhbPpl63lvLnlsYLvvIzkuI3mmL7npLrpga7nvanml7bnlJ/mlYhcbiAgICAgICAgICovXG4gICAgICAgIGNhbkNsb3NlQnlPdXRTaWRlQ2xpY2s6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog54K55Ye76YGu572p5Yy65Z+f5piv5ZCm5YWz6Zet5by55bGC77yM5pi+56S66YGu572p5pe255Sf5pWIXG4gICAgICAgICAqL1xuICAgICAgICBjYW5DbG9zZUJ5TWFzazogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLmiZPlvIDliY3op6blj5Hkuovku7bnmoTlm57osIPlh73mlbBcbiAgICAgICAgICovXG4gICAgICAgIGJlZm9yZU9wZW46IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5omT5byA5pe26Kem5Y+R5LqL5Lu255qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqL1xuICAgICAgICBvbk9wZW46IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5omT5byA5ZCO6Kem5Y+R5LqL5Lu255qE5Zue6LCD5Ye95pWwLCDlpoLmnpzmnInliqjnlLvvvIzliJnlnKjliqjnlLvnu5PmnZ/lkI7op6blj5FcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyT3BlbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLlhbPpl63liY3op6blj5Hkuovku7bnmoTlm57osIPlh73mlbBcbiAgICAgICAgICovXG4gICAgICAgIGJlZm9yZUNsb3NlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguWFs+mXreaXtuinpuWPkeS6i+S7tueahOWbnuiwg+WHveaVsFxuICAgICAgICAgKi9cbiAgICAgICAgb25DbG9zZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLlhbPpl63lkI7op6blj5Hkuovku7bnmoTlm57osIPlh73mlbAsIOWmguaenOacieWKqOeUu++8jOWImeWcqOWKqOeUu+e7k+adn+WQjuinpuWPkVxuICAgICAgICAgKi9cbiAgICAgICAgYWZ0ZXJDbG9zZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLlrprkvY3lrozmiJDliY3op6blj5HnmoTkuovku7ZcbiAgICAgICAgICovXG4gICAgICAgIGJlZm9yZVBvc2l0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguWumuS9jeWujOaIkOaXtuinpuWPkeeahOS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIOWumuS9jeeahOWPguaVsFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWcuYWxpZ24g5a+56b2Q5pa55byP77yM5aaCIFsnY2MnLCAnY2MnXe+8iOWmguaenOW8gOWQryBuZWVkQWRqdXN077yM5Y+v6IO95ZKM6aKE5YWI6K6+572u55qEIGFsaWduIOS4jeWQjO+8iVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnRvcCDot53nprvop4blj6Ppobbpg6jot53nprtcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5sZWZ0IOi3neemu+inhuWPo+W3puS+p+i3neemu1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSDlrprkvY3lj4LnhafnmoTlrrnlmajoioLngrlcbiAgICAgICAgICovXG4gICAgICAgIG9uUG9zaXRpb246IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5Zyo5q+P5qyh5by55bGC6YeN5paw5riy5p+T5ZCO5by65Yi25pu05paw5a6a5L2N5L+h5oGv77yM5LiA6Iis55So5LqO5by55bGC5YaF5a655Yy65Z+f5aSn5bCP5Y+R55Sf5Y+Y5YyW5pe277yM5LuN6ZyA5L+d5oyB5Y6f5p2l55qE5a6a5L2N5pa55byPXG4gICAgICAgICAqL1xuICAgICAgICBzaG91bGRVcGRhdGVQb3NpdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLmiZPlvIDml7bmmK/lkKborqnlhbbkuK3nmoTlhYPntKDoh6rliqjojrflj5bnhKbngrlcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Gb2N1czogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvZPlvLnlsYLnlLHkuo7pobXpnaLmu5rliqjnrYnmg4XlhrXkuI3lnKjlj6/op4bljLrln5/ml7bvvIzmmK/lkKboh6rliqjosIPmlbTlrprkvY3ku6Xlh7rnjrDlnKjlj6/op4bljLrln59cbiAgICAgICAgICovXG4gICAgICAgIG5lZWRBZGp1c3Q6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm56aB55So6aG16Z2i5rua5YqoXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlU2Nyb2xsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmakOiXj+aXtuaYr+WQpuS/neeVmeWtkOiKgueCuVxuICAgICAgICAgKi9cbiAgICAgICAgY2FjaGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5a6J5YWo6IqC54K577yM5b2T54K55Ye7IGRvY3VtZW50IOeahOaXtuWAme+8jOWmguaenOWMheWQq+ivpeiKgueCueWImeS4jeS8muWFs+mXreW8ueWxgu+8jOWmguaenOaYr+WHveaVsOmcgOimgei/lOWbniByZWbvvIzlpoLmnpzmmK/lrZfnrKbkuLLliJnmmK/or6UgRE9NIOeahCBpZO+8jOS5n+WPr+S7peebtOaOpeS8oOWFpSBET00g6IqC54K577yM5oiW6ICF5Lul5LiK5YC857uE5oiQ55qE5pWw57uEXG4gICAgICAgICAqL1xuICAgICAgICBzYWZlTm9kZTogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxgueahOagueiKgueCueeahOagt+W8j+exu1xuICAgICAgICAgKi9cbiAgICAgICAgd3JhcHBlckNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxgueahOagueiKgueCueeahOWGheiBlOagt+W8j1xuICAgICAgICAgKi9cbiAgICAgICAgd3JhcHBlclN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAvKipcbiAgICAgICAgICog6YWN572u5Yqo55S755qE5pKt5pS+5pa55byP77yM5pSv5oyBIHsgaW46ICdlbnRlci1jbGFzcycsIG91dDogJ2xlYXZlLWNsYXNzJyB9IOeahOWvueixoeWPguaVsO+8jOWmguaenOiuvue9ruS4uiBmYWxzZe+8jOWImeS4jeaSreaUvuWKqOeUu1xuICAgICAgICAgKiBAZGVmYXVsdCB7IGluOiAnZXhwYW5kSW5Eb3duJywgb3V0OiAnZXhwYW5kT3V0VXAnIH1cbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmJvb2xdKSxcbiAgICAgICAgb25NYXNrTW91c2VFbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uTWFza01vdXNlTGVhdmU6IFByb3BUeXBlcy5mdW5jXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHByZWZpeDogJ25leHQtJyxcbiAgICAgICAgcHVyZTogZmFsc2UsXG4gICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICBvblJlcXVlc3RDbG9zZTogbm9vcCxcbiAgICAgICAgdGFyZ2V0OiBQb3NpdGlvbi5WSUVXUE9SVCxcbiAgICAgICAgYWxpZ246ICd0bCBibCcsXG4gICAgICAgIG9mZnNldDogWzAsIDBdLFxuICAgICAgICBoYXNNYXNrOiBmYWxzZSxcbiAgICAgICAgY2FuQ2xvc2VCeUVzYzogdHJ1ZSxcbiAgICAgICAgY2FuQ2xvc2VCeU91dFNpZGVDbGljazogdHJ1ZSxcbiAgICAgICAgY2FuQ2xvc2VCeU1hc2s6IHRydWUsXG4gICAgICAgIGJlZm9yZU9wZW46IG5vb3AsXG4gICAgICAgIG9uT3Blbjogbm9vcCxcbiAgICAgICAgYWZ0ZXJPcGVuOiBub29wLFxuICAgICAgICBiZWZvcmVDbG9zZTogbm9vcCxcbiAgICAgICAgb25DbG9zZTogbm9vcCxcbiAgICAgICAgYWZ0ZXJDbG9zZTogbm9vcCxcbiAgICAgICAgYmVmb3JlUG9zaXRpb246IG5vb3AsXG4gICAgICAgIG9uUG9zaXRpb246IG5vb3AsXG4gICAgICAgIG9uTWFza01vdXNlRW50ZXI6IG5vb3AsXG4gICAgICAgIG9uTWFza01vdXNlTGVhdmU6IG5vb3AsXG4gICAgICAgIHNob3VsZFVwZGF0ZVBvc2l0aW9uOiBmYWxzZSxcbiAgICAgICAgYXV0b0ZvY3VzOiBmYWxzZSxcbiAgICAgICAgbmVlZEFkanVzdDogdHJ1ZSxcbiAgICAgICAgZGlzYWJsZVNjcm9sbDogZmFsc2UsXG4gICAgICAgIGNhY2hlOiBmYWxzZVxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHZpc2libGU6IHByb3BzLnZpc2libGUsXG4gICAgICAgICAgICBzdGF0dXM6ICdub25lJyxcbiAgICAgICAgICAgIGFuaW1hdGlvbjogdGhpcy5nZXRBbmltYXRpb24ocHJvcHMpXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5sYXN0QWxpZ24gPSBwcm9wcy5hbGlnbjtcblxuICAgICAgICBiaW5kQ3R4KHRoaXMsIFtcbiAgICAgICAgICAgICdoYW5kbGVQb3NpdGlvbicsXG4gICAgICAgICAgICAnaGFuZGxlQW5pbWF0ZUVuZCcsXG4gICAgICAgICAgICAnaGFuZGxlRG9jdW1lbnRLZXlEb3duJyxcbiAgICAgICAgICAgICdoYW5kbGVEb2N1bWVudENsaWNrJyxcbiAgICAgICAgICAgICdoYW5kbGVNYXNrQ2xpY2snLFxuICAgICAgICAgICAgJ2JlZm9yZU9wZW4nLFxuICAgICAgICAgICAgJ2JlZm9yZUNsb3NlJ1xuICAgICAgICBdKTtcblxuICAgICAgICB0aGlzLnRpbWVvdXRNYXAgPSB7fTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmVmb3JlT3BlbigpO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5iZWZvcmVPcGVuKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmFuaW1hdGlvbiAmJiBzdXBwb3J0LmFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW50ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSh7IHZpc2libGU6IGZhbHNlIH0pO1xuICAgICAgICB0aGlzLmFkZERvY3VtZW50RXZlbnRzKCk7XG5cbiAgICAgICAgb3ZlcmxheU1hbmFnZXIuYWRkT3ZlcmxheSh0aGlzKTtcblxuICAgICAgICBpZiAodGhpcy5zdGF0ZS52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc01vdW50ZWQgJiYgbmV4dFByb3BzLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3aWxsT3BlbiA9ICF0aGlzLnByb3BzLnZpc2libGUgJiYgbmV4dFByb3BzLnZpc2libGU7XG4gICAgICAgIGNvbnN0IHdpbGxDbG9zZSA9IHRoaXMucHJvcHMudmlzaWJsZSAmJiAhbmV4dFByb3BzLnZpc2libGU7XG4gICAgICAgIGlmICh3aWxsT3Blbikge1xuICAgICAgICAgICAgdGhpcy5iZWZvcmVPcGVuKCk7XG4gICAgICAgICAgICBuZXh0UHJvcHMuYmVmb3JlT3BlbigpO1xuICAgICAgICB9IGVsc2UgaWYgKHdpbGxDbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5iZWZvcmVDbG9zZSgpO1xuICAgICAgICAgICAgbmV4dFByb3BzLmJlZm9yZUNsb3NlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dFByb3BzLmFuaW1hdGlvbiB8fCBuZXh0UHJvcHMuYW5pbWF0aW9uID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uOiBuZXh0UHJvcHMuYW5pbWF0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0UHJvcHMuYW5pbWF0aW9uICE9PSBmYWxzZSAmJiBzdXBwb3J0LmFuaW1hdGlvbikge1xuICAgICAgICAgICAgaWYgKHdpbGxPcGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRlcigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3aWxsQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlYXZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiBuZXh0UHJvcHMudmlzaWJsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGNvbnN0IG9wZW4gPSAhcHJldlByb3BzLnZpc2libGUgJiYgdGhpcy5wcm9wcy52aXNpYmxlO1xuICAgICAgICBjb25zdCBjbG9zZSA9IHByZXZQcm9wcy52aXNpYmxlICYmICF0aGlzLnByb3BzLnZpc2libGU7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmFuaW1hdGlvbiAmJiBzdXBwb3J0LmFuaW1hdGlvbikge1xuICAgICAgICAgICAgaWYgKG9wZW4gfHwgY2xvc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEFuaW1hdGlvbkV2ZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgd3JhcHBlck5vZGUgPSB0aGlzLmdldFdyYXBwZXJOb2RlKCk7XG4gICAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uT3BlbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmFmdGVyT3BlbigpO1xuICAgICAgICAgICAgICAgICAgICBkb20uYWRkQ2xhc3Mod3JhcHBlck5vZGUsICdvcGVuZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheU1hbmFnZXIuYWRkT3ZlcmxheSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xvc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmFmdGVyQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3Mod3JhcHBlck5vZGUsICdvcGVuZWQnKTtcbiAgICAgICAgICAgICAgICBvdmVybGF5TWFuYWdlci5yZW1vdmVPdmVybGF5KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRGb2N1c05vZGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICBvdmVybGF5TWFuYWdlci5yZW1vdmVPdmVybGF5KHRoaXMpO1xuICAgICAgICB0aGlzLnJlbW92ZURvY3VtZW50RXZlbnRzKCk7XG4gICAgICAgIGlmICh0aGlzLmZvY3VzVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZm9jdXNUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRpb24ub2ZmKCk7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmVmb3JlQ2xvc2UoKTtcbiAgICB9XG5cbiAgICBnZXRBbmltYXRpb24ocHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzLmFuaW1hdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5hbmltYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbmltYXRpb25CeUFsaWduKHByb3BzLmFsaWduKTtcbiAgICB9XG5cbiAgICBnZXRBbmltYXRpb25CeUFsaWduKGFsaWduKSB7XG4gICAgICAgIHN3aXRjaCAoYWxpZ25bMF0pIHtcbiAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGluOiAnZXhwYW5kSW5Eb3duJyxcbiAgICAgICAgICAgICAgICAgICAgb3V0OiAnZXhwYW5kT3V0VXAnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGluOiAnZXhwYW5kSW5VcCcsXG4gICAgICAgICAgICAgICAgICAgIG91dDogJ2V4cGFuZE91dERvd24nXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW46ICdleHBhbmRJbkRvd24nLFxuICAgICAgICAgICAgICAgICAgICBvdXQ6ICdleHBhbmRPdXRVcCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkQW5pbWF0aW9uRXZlbnRzKCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldENvbnRlbnROb2RlKCk7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gZ3VpZCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uID0gZXZlbnRzLm9uKG5vZGUsIHN1cHBvcnQuYW5pbWF0aW9uLmVuZCwgdGhpcy5oYW5kbGVBbmltYXRlRW5kLmJpbmQodGhpcywgaWQpKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbkRlbGF5ID0gcGFyc2VGbG9hdChnZXRTdHlsZVByb3BlcnR5KG5vZGUsICdhbmltYXRpb24tZGVsYXknKSkgfHwgMDtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmltYXRpb25EdXJhdGlvbiA9IHBhcnNlRmxvYXQoZ2V0U3R5bGVQcm9wZXJ0eShub2RlLCAnYW5pbWF0aW9uLWR1cmF0aW9uJykpIHx8IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZSA9IGFuaW1hdGlvbkRlbGF5ICsgYW5pbWF0aW9uRHVyYXRpb247XG4gICAgICAgICAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0TWFwW2lkXSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBbmltYXRlRW5kKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGltZSAqIDEwMDAgKyAyMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaGFuZGxlUG9zaXRpb24oY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGFsaWduID0gY29uZmlnLmFsaWduLmpvaW4oJyAnKTtcblxuICAgICAgICBpZiAoISgnYW5pbWF0aW9uJyBpbiB0aGlzLnByb3BzKSAmJiB0aGlzLnByb3BzLm5lZWRBZGp1c3QgJiYgdGhpcy5sYXN0QWxpZ24gIT09IGFsaWduKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb246IHRoaXMuZ2V0QW5pbWF0aW9uQnlBbGlnbihhbGlnbilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0QWxpZ24gPSBhbGlnbjtcbiAgICB9XG5cbiAgICBoYW5kbGVBbmltYXRlRW5kKGlkKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXRNYXBbaWRdKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0TWFwW2lkXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMudGltZW91dE1hcFtpZF07XG5cbiAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uLm9mZigpO1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5faXNNb3VudGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdsZWF2aW5nJykge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAnbm9uZSdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLm9uTGVhdmVkKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdlbnRlcmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHN0YXR1czogJ25vbmUnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5vbkVudGVyZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVudGVyKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgICAgICBzdGF0dXM6ICdlbnRlcmluZydcbiAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgLy8gTk9URTogc2V0U3RhdGUgY2FsbGJhY2sgKHNlY29uZCBhcmd1bWVudCkgbm93IGZpcmVzIGltbWVkaWF0ZWx5IGFmdGVyIGNvbXBvbmVudERpZE1vdW50IC8gY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQgb2YgYWZ0ZXIgYWxsIGNvbXBvbmVudHMgaGF2ZSByZW5kZXJlZC5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVudGVyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxlYXZlKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHN0YXR1czogJ2xlYXZpbmcnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMub25MZWF2aW5nKCk7XG4gICAgfVxuXG4gICAgb25FbnRlcmluZygpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlck5vZGUgPSB0aGlzLmdldFdyYXBwZXJOb2RlKCk7XG4gICAgICAgIGRvbS5hZGRDbGFzcyh3cmFwcGVyTm9kZSwgJ29wZW5lZCcpO1xuICAgICAgICB0aGlzLnByb3BzLm9uT3BlbigpO1xuICAgIH1cblxuICAgIG9uTGVhdmluZygpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlck5vZGUgPSB0aGlzLmdldFdyYXBwZXJOb2RlKCk7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyh3cmFwcGVyTm9kZSwgJ29wZW5lZCcpO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2xvc2UoKTtcbiAgICB9XG5cbiAgICBvbkVudGVyZWQoKSB7XG4gICAgICAgIG92ZXJsYXlNYW5hZ2VyLmFkZE92ZXJsYXkodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0Rm9jdXNOb2RlKCk7XG4gICAgICAgIHRoaXMucHJvcHMuYWZ0ZXJPcGVuKCk7XG4gICAgfVxuXG4gICAgb25MZWF2ZWQoKSB7XG4gICAgICAgIG92ZXJsYXlNYW5hZ2VyLnJlbW92ZU92ZXJsYXkodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0Rm9jdXNOb2RlKCk7XG4gICAgICAgIHRoaXMucHJvcHMuYWZ0ZXJDbG9zZSgpO1xuICAgIH1cblxuICAgIGJlZm9yZU9wZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmRpc2FibGVTY3JvbGwpIHtcbiAgICAgICAgICAgIGlmIChtb2RhbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93WTogJ2hpZGRlbidcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICAgICAgICAgIGJvZHlPdmVyZmxvd1kgPSBib2R5LnN0eWxlLm92ZXJmbG93WTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2Nyb2xsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keVBhZGRpbmdSaWdodCA9IGJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5wYWRkaW5nUmlnaHQgPSBgJHtkb20uZ2V0U3R5bGUoYm9keSwgJ3BhZGRpbmdSaWdodCcpICsgZG9tLnNjcm9sbGJhcigpLndpZHRofXB4YDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkb20uc2V0U3R5bGUoYm9keSwgc3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kYWxzLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBiZWZvcmVDbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZVNjcm9sbCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBtb2RhbHMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGFscy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd1k6IGJvZHlPdmVyZmxvd1lcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1Njcm9sbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5wYWRkaW5nUmlnaHQgPSBib2R5UGFkZGluZ1JpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZG9tLnNldFN0eWxlKGRvY3VtZW50LmJvZHksIHN0eWxlKTtcblxuICAgICAgICAgICAgICAgICAgICBib2R5T3ZlcmZsb3dZID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBib2R5UGFkZGluZ1JpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZGFscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0Rm9jdXNOb2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdGF0ZS52aXNpYmxlICYmICF0aGlzLl9oYXNGb2N1c2VkKSB7XG4gICAgICAgICAgICBzYXZlTGFzdEZvY3VzTm9kZSgpO1xuICAgICAgICAgICAgLy8g6L+Z5Liq5pe25YCZ5b6I5Y+v6IO95LiK5LiA5Liq5by55bGC55qE5YWz6Zet5LqL5Lu26L+Y5pyq6Kem5Y+R77yM5a+86Ie054Sm54K55bey57uP5Zue5Yiw6Kem5Y+R55qE5YWD57SgXG4gICAgICAgICAgICAvLyDov5nph4zlu7bml7blpITnkIbkuIDkuIvvvIzlu7bml7bnmoTml7bpl7TkuLogZG9jdW1lbnQuY2xpY2sg5o2V6I636Kem5Y+R55qE5bu25pe25pe26Ze0XG4gICAgICAgICAgICB0aGlzLmZvY3VzVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldENvbnRlbnROb2RlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9jdXNOb2RlTGlzdCA9IGdldEZvY3VzTm9kZUxpc3Qobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2N1c05vZGVMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNOb2RlTGlzdFswXS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuc3RhdGUudmlzaWJsZSAmJiB0aGlzLl9oYXNGb2N1c2VkKSB7XG4gICAgICAgICAgICBiYWNrTGFzdEZvY3VzTm9kZSgpO1xuICAgICAgICAgICAgdGhpcy5faGFzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Q29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFJlZjtcbiAgICB9XG5cbiAgICBnZXRDb250ZW50Tm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRET01Ob2RlKHRoaXMuY29udGVudFJlZik7XG4gICAgfVxuXG4gICAgZ2V0V3JhcHBlck5vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdhdGV3YXlSZWYgPyB0aGlzLmdhdGV3YXlSZWYuZ2V0Q2hpbGROb2RlKCkgOiBudWxsO1xuICAgIH1cblxuICAgIGFkZERvY3VtZW50RXZlbnRzKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5jYW5DbG9zZUJ5RXNjKSB7XG4gICAgICAgICAgICB0aGlzLl9rZXlkb3duRXZlbnRzID0gZXZlbnRzLm9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9wcy5jYW5DbG9zZUJ5T3V0U2lkZUNsaWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGlja0V2ZW50cyA9IGV2ZW50cy5vbihkb2N1bWVudCwgJ2NsaWNrJywgdGhpcy5oYW5kbGVEb2N1bWVudENsaWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZURvY3VtZW50RXZlbnRzKCkge1xuICAgICAgICBpZiAodGhpcy5fa2V5ZG93bkV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5fa2V5ZG93bkV2ZW50cy5vZmYoKTtcbiAgICAgICAgICAgIHRoaXMuX2tleWRvd25FdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jbGlja0V2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5fY2xpY2tFdmVudHMub2ZmKCk7XG4gICAgICAgICAgICB0aGlzLl9jbGlja0V2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVEb2N1bWVudEtleURvd24oZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS52aXNpYmxlICYmIGUua2V5Q29kZSA9PT0gS0VZQ09ERS5FU0MgJiYgb3ZlcmxheU1hbmFnZXIuaXNDdXJyZW50T3ZlcmxheSh0aGlzKSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblJlcXVlc3RDbG9zZSgna2V5Ym9hcmQnLCBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZURvY3VtZW50Q2xpY2soZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS52aXNpYmxlKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNhZmVOb2RlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgY29uc3Qgc2FmZU5vZGVzICA9IEFycmF5LmlzQXJyYXkoc2FmZU5vZGUpID8gWy4uLnNhZmVOb2RlXSA6IFtzYWZlTm9kZV07XG4gICAgICAgICAgICBzYWZlTm9kZXMudW5zaGlmdCgoKSA9PiB0aGlzLmdldFdyYXBwZXJOb2RlKCkpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhZmVOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBmaW5kTm9kZShzYWZlTm9kZXNbaV0sIHRoaXMucHJvcHMpO1xuICAgICAgICAgICAgICAgIC8vIEhBQ0s6IOWmguaenOinpuWPkeeCueWHu+eahOiKgueCueaYr+W8ueWxguWGhemDqOeahOiKgueCue+8jOW5tuS4lOWcqOiiq+eCueWHu+WQjueri+WNs+mUgOavge+8jOmCo+S5iOatpOaXtuaXoOazleS9v+eUqCBub2RlLmNvbnRhaW5zKGUudGFyZ2V0KVxuICAgICAgICAgICAgICAgIC8vIOadpeWIpOaWreatpOaXtueCueWHu+eahOiKgueCueaYr+WQpuaYr+W8ueWxguWGhemDqOeahOiKgueCue+8jOmineWkluWIpOaWrVxuICAgICAgICAgICAgICAgIGlmIChub2RlICYmIChub2RlID09PSBlLnRhcmdldCB8fCBub2RlLmNvbnRhaW5zKGUudGFyZ2V0KSB8fFxuICAgICAgICAgICAgICAgIChlLnRhcmdldCAhPT0gZG9jdW1lbnQgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhlLnRhcmdldCkpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uUmVxdWVzdENsb3NlKCdkb2NDbGljaycsIGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlTWFza0NsaWNrKGUpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuY2FuQ2xvc2VCeU1hc2spIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25SZXF1ZXN0Q2xvc2UoJ21hc2tDbGljaycsIGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2F2ZUNvbnRlbnRSZWYgPSAocmVmKSA9PiB7XG4gICAgICAgIHRoaXMuY29udGVudFJlZiA9IHJlZjtcbiAgICB9XG5cbiAgICBzYXZlR2F0ZXdheVJlZiA9IChyZWYpID0+IHtcbiAgICAgICAgdGhpcy5nYXRld2F5UmVmID0gcmVmO1xuICAgIH1cblxuICAgIC8vIOWFvOWuuei/h+WOu+eahOeUqOazlTogdGhpcy5wb3B1cFJlZi5nZXRJbnN0YW5jZSgpLm92ZXJsYXkuZ2V0SW5zdGFuY2UoKS5nZXRDb250ZW50Tm9kZSgpXG4gICAgZ2V0SW5zdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgcHJlZml4LCBjbGFzc05hbWUsIHN0eWxlLCBjaGlsZHJlbjogcHJvcENoaWxkcmVuLFxuICAgICAgICAgICAgdGFyZ2V0LCBhbGlnbiwgb2Zmc2V0LCBjb250YWluZXIsIGhhc01hc2ssIG5lZWRBZGp1c3QsXG4gICAgICAgICAgICBiZWZvcmVQb3NpdGlvbiwgb25Qb3NpdGlvbiwgd3JhcHBlclN0eWxlLCBydGwsXG4gICAgICAgICAgICBzaG91bGRVcGRhdGVQb3NpdGlvbjogcHJvcFNob3VsZFVwZGF0ZVBvc2l0aW9uLFxuICAgICAgICAgICAgY2FjaGUsIHdyYXBwZXJDbGFzc05hbWUsIG9uTWFza01vdXNlRW50ZXIsIG9uTWFza01vdXNlTGVhdmVcbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgdmlzaWJsZTogc3RhdGVWaXNpYmxlLCBzdGF0dXMsIGFuaW1hdGlvbiB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBsZXQgY2hpbGRyZW4gPSBzdGF0ZVZpc2libGUgfHwgKGNhY2hlICYmIHRoaXMuX2lzTW91bnRlZCkgPyBwcm9wQ2hpbGRyZW4gOiBudWxsO1xuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgICAgICAgICBjb25zdCBjaGlsZENsYXp6ID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1vdmVybGF5LWlubmVyYF06IHRydWUsXG4gICAgICAgICAgICAgICAgW2FuaW1hdGlvbi5pbl06IHN0YXR1cyA9PT0gJ2VudGVyaW5nJyxcbiAgICAgICAgICAgICAgICBbYW5pbWF0aW9uLm91dF06IHN0YXR1cyA9PT0gJ2xlYXZpbmcnLFxuICAgICAgICAgICAgICAgIFtjaGlsZC5wcm9wcy5jbGFzc05hbWVdOiAhIWNoaWxkLnByb3BzLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBbY2xhc3NOYW1lXTogISFjbGFzc05hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC5yZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IHNldCByZWYgYnkgc3RyaW5nIGluIE92ZXJsYXksIHVzZSBmdW5jdGlvbiBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZHJlbiA9IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2hpbGRDbGF6eixcbiAgICAgICAgICAgICAgICBzdHlsZTogey4uLmNoaWxkLnByb3BzLnN0eWxlLCAuLi5zdHlsZX0sXG4gICAgICAgICAgICAgICAgcmVmOiBtYWtlQ2hhaW4odGhpcy5zYXZlQ29udGVudFJlZiwgY2hpbGQucmVmKSxcbiAgICAgICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiAhc3RhdGVWaXNpYmxlICYmIGNhY2hlICYmIHRoaXMuX2lzTW91bnRlZFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChhbGlnbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZVBvc2l0aW9uID0gc3RhdHVzID09PSAnbGVhdmluZycgPyBmYWxzZSA6IHByb3BTaG91bGRVcGRhdGVQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IChcbiAgICAgICAgICAgICAgICAgICAgPFBvc2l0aW9uIHsuLi4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4sIHRhcmdldCwgYWxpZ24sIG9mZnNldCwgbmVlZEFkanVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZVBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25Qb3NpdGlvbjogbWFrZUNoYWluKHRoaXMuaGFuZGxlUG9zaXRpb24sIG9uUG9zaXRpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlUG9zaXRpb24sIHJ0bFxuICAgICAgICAgICAgICAgICAgICB9KX0gLz5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyQ2xhenogPSBjbGFzc25hbWVzKFtcbiAgICAgICAgICAgICAgICBgJHtwcmVmaXh9b3ZlcmxheS13cmFwcGVyYCxcbiAgICAgICAgICAgICAgICB3cmFwcGVyQ2xhc3NOYW1lXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1dyYXBwZXJTdHlsZSA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBzdGF0ZVZpc2libGUgPyAnJyA6ICdub25lJ1xuICAgICAgICAgICAgfSwgd3JhcHBlclN0eWxlKTtcblxuICAgICAgICAgICAgY2hpbGRyZW4gPSAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3dyYXBwZXJDbGF6en0gc3R5bGU9e25ld1dyYXBwZXJTdHlsZX0gZGlyPXtydGwgPyAncnRsJyA6IHVuZGVmaW5lZH0+XG4gICAgICAgICAgICAgICAgICAgIHtoYXNNYXNrID9cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9b3ZlcmxheS1iYWNrZHJvcGB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVNYXNrQ2xpY2t9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyPXtvbk1hc2tNb3VzZUVudGVyfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17b25NYXNrTW91c2VMZWF2ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXI9e3J0bCA/ICdydGwnIDogdW5kZWZpbmVkfSAvPiA6XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsfVxuICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDxHYXRld2F5IHsuLi4oe2NvbnRhaW5lciwgdGFyZ2V0LCBjaGlsZHJlbn0pfSByZWY9e3RoaXMuc2F2ZUdhdGV3YXlSZWZ9IC8+O1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9vdmVybGF5L292ZXJsYXkuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmaW5kRE9NTm9kZSwgY3JlYXRlUG9ydGFsIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBmdW5jIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgZmluZE5vZGUgZnJvbSAnLi91dGlscy9maW5kLW5vZGUnO1xuXG5jb25zdCB7IG1ha2VDaGFpbiB9ID0gZnVuYztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2F0ZXdheSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICBjb250YWluZXI6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIHRhcmdldDogUHJvcFR5cGVzLmFueSxcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgY29udGFpbmVyOiAoKSA9PiBkb2N1bWVudC5ib2R5XG4gICAgfTtcblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lck5vZGUgPSB0aGlzLmdldENvbnRhaW5lck5vZGUodGhpcy5wcm9wcyk7XG4gICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICB0aGlzLmNvbnRhaW5lck5vZGUgPSB0aGlzLmdldENvbnRhaW5lck5vZGUobmV4dFByb3BzKTtcbiAgICB9XG5cbiAgICBnZXRDb250YWluZXJOb2RlKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBmaW5kTm9kZShwcm9wcy50YXJnZXQpO1xuICAgICAgICByZXR1cm4gZmluZE5vZGUocHJvcHMuY29udGFpbmVyLCB0YXJnZXROb2RlKTtcbiAgICB9XG5cbiAgICBnZXRDaGlsZE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBmaW5kRE9NTm9kZSh0aGlzLmNoaWxkKTtcbiAgICB9XG5cbiAgICBzYXZlQ2hpbGRSZWYgPSByZWYgPT4ge1xuICAgICAgICB0aGlzLmNoaWxkID0gcmVmO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lck5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW4gPyBDaGlsZHJlbi5vbmx5KGNoaWxkcmVuKSA6IG51bGw7XG4gICAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC5yZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3Qgc2V0IHJlZiBieSBzdHJpbmcgaW4gR2F0ZXdheSwgdXNlIGZ1bmN0aW9uIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQgPSBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgICAgIHJlZjogbWFrZUNoYWluKHRoaXMuc2F2ZUNoaWxkUmVmLCBjaGlsZC5yZWYpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGQsIHRoaXMuY29udGFpbmVyTm9kZSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL292ZXJsYXkvZ2F0ZXdheS5qc3giLCJpbXBvcnQgeyBDb21wb25lbnQsIENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGZ1bmMsIGRvbSwgZXZlbnRzIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgcG9zaXRpb24gZnJvbSAnLi91dGlscy9wb3NpdGlvbic7XG5pbXBvcnQgZmluZE5vZGUgZnJvbSAnLi91dGlscy9maW5kLW5vZGUnO1xuXG5jb25zdCB7IG5vb3AsIGJpbmRDdHggfSA9IGZ1bmM7XG5jb25zdCB7IGdldFN0eWxlIH0gPSBkb207XG5jb25zdCBwbGFjZSA9IHBvc2l0aW9uLnBsYWNlO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3NpdGlvbiBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIFZJRVdQT1JUID0gcG9zaXRpb24uVklFV1BPUlQ7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIHRhcmdldDogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgYWxpZ246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5ib29sXSksXG4gICAgICAgIG9mZnNldDogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBiZWZvcmVQb3NpdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uUG9zaXRpb246IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBuZWVkQWRqdXN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgbmVlZExpc3RlblJlc2l6ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHNob3VsZFVwZGF0ZVBvc2l0aW9uOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgcnRsOiBQcm9wVHlwZXMuYm9vbFxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBhbGlnbjogJ3RsIGJsJyxcbiAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXG4gICAgICAgIGJlZm9yZVBvc2l0aW9uOiBub29wLFxuICAgICAgICBvblBvc2l0aW9uOiBub29wLFxuICAgICAgICBuZWVkQWRqdXN0OiB0cnVlLFxuICAgICAgICBuZWVkTGlzdGVuUmVzaXplOiB0cnVlLFxuICAgICAgICBzaG91bGRVcGRhdGVQb3NpdGlvbjogZmFsc2UsXG4gICAgICAgIHJ0bDogZmFsc2UsXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICBiaW5kQ3R4KHRoaXMsIFsnaGFuZGxlUmVzaXplJ10pO1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKCk7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMubmVlZExpc3RlblJlc2l6ZSkge1xuICAgICAgICAgICAgZXZlbnRzLm9uKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIGlmICgnYWxpZ24nIGluIG5leHRQcm9wcyAmJiBuZXh0UHJvcHMuYWxpZ24gIT09IHRoaXMucHJvcHMuYWxpZ24gfHwgbmV4dFByb3BzLnNob3VsZFVwZGF0ZVBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNob3VsZFVwZGF0ZVBvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkVXBkYXRlUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkVXBkYXRlUG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5uZWVkTGlzdGVuUmVzaXplKSB7XG4gICAgICAgICAgICBldmVudHMub2ZmKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVvdXQpO1xuICAgIH1cblxuICAgIHNldFBvc2l0aW9uKCkge1xuICAgICAgICBjb25zdCB7IGFsaWduLCBvZmZzZXQsIGJlZm9yZVBvc2l0aW9uLCBvblBvc2l0aW9uLCBuZWVkQWRqdXN0LCBydGwgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgYmVmb3JlUG9zaXRpb24oKTtcblxuICAgICAgICBjb25zdCBjb250ZW50Tm9kZSA9IHRoaXMuZ2V0Q29udGVudE5vZGUoKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRoaXMuZ2V0VGFyZ2V0Tm9kZSgpO1xuICAgICAgICBpZiAoY29udGVudE5vZGUgJiYgdGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0QWxpZ24gPSBwbGFjZSh7XG4gICAgICAgICAgICAgICAgcGluRWxlbWVudDogY29udGVudE5vZGUsXG4gICAgICAgICAgICAgICAgYmFzZUVsZW1lbnQ6IHRhcmdldE5vZGUsXG4gICAgICAgICAgICAgICAgYWxpZ24sXG4gICAgICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgICAgIG5lZWRBZGp1c3QsXG4gICAgICAgICAgICAgICAgaXNSdGw6IHJ0bCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdG9wID0gZ2V0U3R5bGUoY29udGVudE5vZGUsICd0b3AnKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBnZXRTdHlsZShjb250ZW50Tm9kZSwgJ2xlZnQnKTtcblxuICAgICAgICAgICAgb25Qb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgYWxpZ246IHJlc3VsdEFsaWduLnNwbGl0KCcgJyksXG4gICAgICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgICAgIGxlZnRcbiAgICAgICAgICAgIH0sIGNvbnRlbnROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldENvbnRlbnROb2RlKCkge1xuICAgICAgICByZXR1cm4gZmluZERPTU5vZGUodGhpcyk7XG4gICAgfVxuXG4gICAgZ2V0VGFyZ2V0Tm9kZSgpIHtcbiAgICAgICAgY29uc3QgeyB0YXJnZXQgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldCA9PT0gcG9zaXRpb24uVklFV1BPUlQgPyBwb3NpdGlvbi5WSUVXUE9SVCA6IGZpbmROb2RlKHRhcmdldCwgdGhpcy5wcm9wcyk7XG4gICAgfVxuXG4gICAgaGFuZGxlUmVzaXplKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcblxuICAgICAgICB0aGlzLnJlc2l6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24oKTtcbiAgICAgICAgfSwgMjAwKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBDaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9vdmVybGF5L3Bvc2l0aW9uLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgRmlsdGVyQ29tcG9uZW50IGZyb20gJy4vZmlsdGVyJztcbmltcG9ydCBTb3J0Q29tcG9uZW50IGZyb20gJy4vc29ydCc7XG5pbXBvcnQgQ2VsbENvbXBvbmVudCBmcm9tICcuL2NlbGwnO1xuaW1wb3J0IFJlc2l6ZUNvbXBvbmVudCBmcm9tICcuL3Jlc2l6ZSc7XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWFkZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHB1cmU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNvbXBvbmVudDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY29sdW1uczogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBjb2xHcm91cDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgaGVhZGVyQ2VsbFJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGxvY2FsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgZmlsdGVyUGFyYW1zOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBvbkZpbHRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGNvbXBvbmVudHM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIHNvcnQ6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIG9uU29ydDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uUmVzaXplQ2hhbmdlOiBQcm9wVHlwZXMuZnVuY1xuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBjb21wb25lbnQ6ICd0aGVhZCcsXG4gICAgICAgIGNvbHVtbnM6IFtdLFxuICAgICAgICBoZWFkZXJDZWxsUmVmOiBub29wLFxuICAgICAgICBvbkZpbHRlcjogbm9vcCxcbiAgICAgICAgY29tcG9uZW50czoge30sXG4gICAgICAgIG9uU29ydDogbm9vcCxcbiAgICAgICAgb25SZXNpemVDaGFuZ2U6IG5vb3BcbiAgICB9XG5cbiAgICBnZXRDZWxsUmVmID0gKGksIGosIGNlbGwpID0+IHtcbiAgICAgICAgdGhpcy5wcm9wcy5oZWFkZXJDZWxsUmVmKGksIGosIGNlbGwpO1xuICAgIH1cblxuICAgIG9uU29ydCA9IChkYXRhSW5kZXgsIG9yZGVyLCBzb3J0KSA9PiB7XG4gICAgICAgIHRoaXMucHJvcHMub25Tb3J0KGRhdGFJbmRleCwgb3JkZXIsIHNvcnQpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLyplc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgY2xhc3NOYW1lLCBjaGlsZHJlbiwgY29tcG9uZW50OiBUYWcsIGNvbEdyb3VwLCBjb2x1bW5zLCBsb2NhbGUsIGZpbHRlclBhcmFtcyxcbiAgICAgICAgICAgIG9uRmlsdGVyLCBjb21wb25lbnRzLCBhZmZpeFJlZiwgaGVhZGVyQ2VsbFJlZiwgb25Tb3J0LCBzb3J0LCBvblJlc2l6ZUNoYW5nZSwgcHVyZSwgLi4ub3RoZXJzXG4gICAgICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGNvbnN0IHsgQ2VsbCA9IENlbGxDb21wb25lbnQsIEZpbHRlciA9IEZpbHRlckNvbXBvbmVudCwgU29ydCA9IFNvcnRDb21wb25lbnQsIFJlc2l6ZSA9IFJlc2l6ZUNvbXBvbmVudCB9ID0gY29tcG9uZW50cztcbiAgICAgICAgY29uc3Qgcm93U3BhbiA9IGNvbHVtbnMubGVuZ3RoO1xuXG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGNvbHVtbnMubWFwKChjb2xzLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sID0gY29scy5tYXAoKGNvbCwgaikgPT4ge1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBwcmVmZXItY29uc3QgKi9cbiAgICAgICAgICAgICAgICBsZXQgeyB0aXRsZSwgY29sU3Bhbiwgc29ydGFibGUsIHJlc2l6YWJsZSwgZGF0YUluZGV4LCBmaWx0ZXJzLCBmaWx0ZXJNb2RlLCB3aWR0aCwgYWxpZ24sIGNsYXNzTmFtZSwgX19ub3JtYWxpemVkLCBsb2NrLCAuLi5vdGhlcnMgfSA9IGNvbDtcblxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4fXRhYmxlLWhlYWRlci1ub2RlYF06IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9dGFibGUtaGVhZGVyLXJlc2l6YWJsZWBdOiByZXNpemFibGUsXG4gICAgICAgICAgICAgICAgICAgIFtjbGFzc05hbWVdOiBjbGFzc05hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgYXR0cnMgPSB7fSwgc29ydEVsZW1lbnQsIGZpbHRlckVsZW1lbnQsIHJlc2l6ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGNvbC5jaGlsZHJlbiAmJiBjb2wuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLmNvbFNwYW4gPSBjb2xTcGFuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3J0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ydEVsZW1lbnQgPSAoPFNvcnQgcHJlZml4PXtwcmVmaXh9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUluZGV4PXtkYXRhSW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Tb3J0PXt0aGlzLm9uU29ydH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0PXtzb3J0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZT17bG9jYWxlfS8+KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzaXphYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNpemVFbGVtZW50ID0gPFJlc2l6ZSBwcmVmaXg9e3ByZWZpeH0gZGF0YUluZGV4PXtkYXRhSW5kZXh9IG9uQ2hhbmdlPXtvblJlc2l6ZUNoYW5nZX0vPjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJFbGVtZW50ID0gZmlsdGVycy5sZW5ndGggP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICg8RmlsdGVyIGRhdGFJbmRleD17ZGF0YUluZGV4fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJzPXtmaWx0ZXJzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXg9e3ByZWZpeH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlPXtsb2NhbGV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlclBhcmFtcz17ZmlsdGVyUGFyYW1zfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJNb2RlPXtmaWx0ZXJNb2RlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkZpbHRlcj17b25GaWx0ZXJ9IC8+KSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXR0cnMucm93U3BhbiA9IHJvd1NwYW4gLSBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICg8Q2VsbCB7Li4ub3RoZXJzfSB7Li4uYXR0cnN9XG4gICAgICAgICAgICAgICAgICAgIGtleT17an1cbiAgICAgICAgICAgICAgICAgICAgcHJlZml4PXtwcmVmaXh9XG4gICAgICAgICAgICAgICAgICAgIHB1cmU9e3B1cmV9XG4gICAgICAgICAgICAgICAgICAgIGNlbGw9e3RpdGxlfVxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ9XCJ0aFwiXG4gICAgICAgICAgICAgICAgICAgIGFsaWduPXthbGlnbn1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgICAgICAgICAgICAgICAgIHJlZj17dGhpcy5nZXRDZWxsUmVmLmJpbmQodGhpcywgaW5kZXgsIGopfVxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiaGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgICAgIHtzb3J0RWxlbWVudH17ZmlsdGVyRWxlbWVudH17cmVzaXplRWxlbWVudH1cbiAgICAgICAgICAgICAgICA8L0NlbGw+KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIDx0ciBrZXk9e2luZGV4fT57Y29sfTwvdHI+O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gKDxUYWcgY2xhc3NOYW1lPXtjbGFzc05hbWV9IHsuLi5vdGhlcnN9PlxuICAgICAgICAgICAge2hlYWRlcn1cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9UYWc+KTtcbiAgICB9XG59XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9iYXNlL2hlYWRlci5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBEcm9wZG93biBmcm9tICcuLi8uLi9kcm9wZG93bic7XG5pbXBvcnQgTWVudSBmcm9tICcuLi8uLi9tZW51JztcbmltcG9ydCBCdXR0b24gZnJvbSAnLi4vLi4vYnV0dG9uJztcbmltcG9ydCBJY29uIGZyb20gJy4uLy4uL2ljb24nO1xuaW1wb3J0IHsgS0VZQ09ERSB9IGZyb20gJy4uLy4uL3V0aWwnO1xuXG4vLyDlhbHkuqvnirbmgIHnmoTnu4Tku7bpnIDopoHlj5jmiJDpnZ7lj5fmjqfnu4Tku7ZcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbHRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgZGF0YUluZGV4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBmaWx0ZXJzOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIGZpbHRlck1vZGU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGZpbHRlclBhcmFtczogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgbG9jYWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBvbkZpbHRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZ1xuICAgIH1cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIG9uRmlsdGVyOiAoKSA9PiB7fVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgY29uc3QgZmlsdGVyUGFyYW1zID0gcHJvcHMuZmlsdGVyUGFyYW1zIHx8IHt9O1xuICAgICAgICBjb25zdCBmaWx0ZXJDb25maWcgPSBmaWx0ZXJQYXJhbXNbcHJvcHMuZGF0YUluZGV4XSB8fCB7fTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHZpc2libGU6IGZpbHRlckNvbmZpZy52aXNpYmxlIHx8IGZhbHNlLFxuICAgICAgICAgICAgc2VsZWN0ZWRLZXlzOiBmaWx0ZXJDb25maWcuc2VsZWN0ZWRLZXlzIHx8IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkS2V5cyA9IFsuLi50aGlzLnN0YXRlLnNlbGVjdGVkS2V5c107XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZmlsdGVyUGFyYW1zJykgJiYgdHlwZW9mIG5leHRQcm9wcy5maWx0ZXJQYXJhbXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhSW5kZXggPSBuZXh0UHJvcHMuZGF0YUluZGV4IHx8IHRoaXMucHJvcHMuZGF0YUluZGV4O1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyUGFyYW1zID0gbmV4dFByb3BzLmZpbHRlclBhcmFtcyB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckNvbmZpZyA9IGZpbHRlclBhcmFtc1tkYXRhSW5kZXhdIHx8IHt9O1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRLZXlzID0gZmlsdGVyQ29uZmlnLnNlbGVjdGVkS2V5cyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkS2V5c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEtleXMgPSBbLi4uc2VsZWN0ZWRLZXlzXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZpbHRlcktleWRvd24gPSBlID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IEtFWUNPREUuRU5URVIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHZpc2libGU6ICF0aGlzLnN0YXRlLnZpc2libGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25GaWx0ZXJWaXNpYmxlID0gKHZpc2libGUpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB2aXNpYmxlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRLZXlzID0gWy4uLnRoaXMuX3NlbGVjdGVkS2V5c107XG5cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkS2V5c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkZpbHRlclNlbGVjdCA9IChzZWxlY3RlZEtleXMpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgc2VsZWN0ZWRLZXlzXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uRmlsdGVyQ29uZmlybSA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRLZXlzID0gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXM7XG4gICAgICAgIGNvbnN0IGZpbHRlclBhcmFtcyA9IHt9LCB7IGRhdGFJbmRleCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBmaWx0ZXJQYXJhbXNbZGF0YUluZGV4XSA9IHtcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgc2VsZWN0ZWRLZXlzOiBzZWxlY3RlZEtleXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRLZXlzID0gWy4uLnNlbGVjdGVkS2V5c107XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIOWFvOWuueS5i+WJjeeahOagvOW8j1xuICAgICAgICB0aGlzLnByb3BzLm9uRmlsdGVyKGZpbHRlclBhcmFtcyk7XG4gICAgfVxuXG4gICAgb25GaWx0ZXJDbGVhciA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZmlsdGVyUGFyYW1zID0ge30sIHsgZGF0YUluZGV4IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGZpbHRlclBhcmFtc1tkYXRhSW5kZXhdID0ge1xuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBzZWxlY3RlZEtleXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkS2V5cyA9IFtdO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHNlbGVjdGVkS2V5czogW10sXG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8g5YW85a655LmL5YmN55qE5qC85byPXG4gICAgICAgIHRoaXMucHJvcHMub25GaWx0ZXIoZmlsdGVyUGFyYW1zKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgZmlsdGVycywgcHJlZml4LCBsb2NhbGUsIGZpbHRlck1vZGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgdmlzaWJsZSwgc2VsZWN0ZWRLZXlzIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlbmRlck1lbnVJdGVtKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiA8TWVudS5JdGVtIGtleT17aXRlbS52YWx1ZX0+e2l0ZW0ubGFiZWx9PC9NZW51Lkl0ZW0+O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVuZGVyU3ViTWVudShwYXJlbnQsIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxNZW51LlN1Yk1lbnUgbGFiZWw9e3BhcmVudC5sYWJlbH0ga2V5PXtwYXJlbnQudmFsdWV9IHNlbGVjdGFibGU9e2ZhbHNlfT5cbiAgICAgICAgICAgICAgICAgICAge3JlbmRlck1lbnVDb250ZW50KGNoaWxkcmVuKX1cbiAgICAgICAgICAgICAgICA8L01lbnUuU3ViTWVudT5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZW5kZXJNZW51Q29udGVudChsaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdC5tYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlclN1Yk1lbnUoaXRlbSwgaXRlbS5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlck1lbnVJdGVtKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGVudCA9IHJlbmRlck1lbnVDb250ZW50KGZpbHRlcnMpLFxuICAgICAgICAgICAgZm9vdGVyID0gKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtZmlsdGVyLWZvb3RlcmB9PlxuICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIHR5cGU9XCJwcmltYXJ5XCIgb25DbGljaz17dGhpcy5vbkZpbHRlckNvbmZpcm19Pntsb2NhbGUub2t9PC9CdXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b24gb25DbGljaz17dGhpcy5vbkZpbHRlckNsZWFyfT57bG9jYWxlLnJlc2V0fTwvQnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPERyb3Bkb3duIHRyaWdnZXI9e1xuICAgICAgICAgICAgICAgIDxzcGFuIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPXtsb2NhbGUuZmlsdGVyfVxuICAgICAgICAgICAgICAgICAgICBvbktleURvd249e3RoaXMuZmlsdGVyS2V5ZG93bn1cbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg9XCIwXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtZmlsdGVyYH0+XG4gICAgICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9XCJmaWx0ZXJcIiBzaXplPVwic21hbGxcIiAvPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJUeXBlPVwiY2xpY2tcIlxuICAgICAgICAgICAgdmlzaWJsZT17dmlzaWJsZX1cbiAgICAgICAgICAgIGF1dG9Gb2N1c1xuICAgICAgICAgICAgY29udGFpbmVyPXtub2RlID0+IG5vZGUucGFyZW50Tm9kZX1cbiAgICAgICAgICAgIG9uVmlzaWJsZUNoYW5nZT17dGhpcy5vbkZpbHRlclZpc2libGV9PlxuICAgICAgICAgICAgICAgIDxNZW51IGZvb3Rlcj17Zm9vdGVyfVxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEtleXM9e3NlbGVjdGVkS2V5c31cbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0TW9kZT17ZmlsdGVyTW9kZX1cbiAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Q9e3RoaXMub25GaWx0ZXJTZWxlY3R9PlxuICAgICAgICAgICAgICAgICAgICB7Y29udGVudH1cbiAgICAgICAgICAgICAgICA8L01lbnU+XG4gICAgICAgICAgICA8L0Ryb3Bkb3duPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9iYXNlL2ZpbHRlci5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBDaGlsZHJlbiwgY2xvbmVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IGZ1bmMsIG9iaiwgS0VZQ09ERSB9IGZyb20gJy4uLy4uL3V0aWwnO1xuXG5jb25zdCB7IGJpbmRDdHggfSA9IGZ1bmM7XG5jb25zdCB7IHBpY2tPdGhlcnMgfSA9IG9iajtcbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcblxuLyoqXG4gKiBNZW51XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lbnUgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBpc05leHRNZW51ID0gdHJ1ZTtcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcHVyZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiPnOWNlemhueWSjOWtkOiPnOWNlVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICAvKipcbiAgICAgICAgICog54K55Ye76I+c5Y2V6aG56Kem5Y+R55qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkg54K55Ye755qE6I+c5Y2V6aG555qEIGtleSDlgLxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0g54K55Ye755qE6I+c5Y2V6aG55a+56LGhXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDngrnlh7vnmoTkuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIG9uSXRlbUNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW9k+WJjeaJk+W8gOeahOWtkOiPnOWNleeahCBrZXkg5YC8XG4gICAgICAgICAqL1xuICAgICAgICBvcGVuS2V5czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmFycmF5XSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliJ3lp4vmiZPlvIDnmoTlrZDoj5zljZXnmoQga2V5IOWAvFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdE9wZW5LZXlzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYXJyYXldKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIneWni+WxleW8gOaJgOacieeahOWtkOiPnOWNle+8jOWPquWcqCBtb2RlIOiuvue9ruS4uiAnaW5saW5lJyDku6Xlj4ogb3Blbk1vZGUg6K6+572u5Li6ICdtdWx0aXBsZScg5LiL55Sf5pWI77yM5LyY5YWI57qn6auY5LqOIGRlZmF1bHRPcGVuS2V5c1xuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdE9wZW5BbGw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5omT5byA5oiW5YWz6Zet5a2Q6I+c5Y2V6Kem5Y+R55qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkg5omT5byA55qE5omA5pyJ5a2Q6I+c5Y2V55qEIGtleSDlgLxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV4dHJhIOmineWkluWPguaVsFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXh0cmEua2V5IOW9k+WJjeaTjeS9nOWtkOiPnOWNleeahCBrZXkg5YC8XG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXh0cmEub3BlbiDmmK/lkKbmmK/miZPlvIBcbiAgICAgICAgICovXG4gICAgICAgIG9uT3BlbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlrZDoj5zljZXmiZPlvIDnmoTmqKHlvI9cbiAgICAgICAgICovXG4gICAgICAgIG1vZGU6IFByb3BUeXBlcy5vbmVPZihbJ2lubGluZScsICdwb3B1cCddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWtkOiPnOWNleaJk+W8gOeahOinpuWPkeihjOS4ulxuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlclR5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2NsaWNrJywgJ2hvdmVyJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5bGV5byA5YaF6L+e5a2Q6I+c5Y2V55qE5qih5byP77yM5ZCM5pe25Y+v5Lul5bGV5byA5LiA5Liq5a2Q6I+c5Y2V6L+Y5piv5aSa5Liq5a2Q6I+c5Y2V77yM6K+l5bGe5oCn5LuF5ZyoIG1vZGUg5Li6IGlubGluZSDml7bnlJ/mlYhcbiAgICAgICAgICovXG4gICAgICAgIG9wZW5Nb2RlOiBQcm9wVHlwZXMub25lT2YoWydzaW5nbGUnLCAnbXVsdGlwbGUnXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlhoXov57lrZDoj5zljZXnvKnov5vot53nprtcbiAgICAgICAgICovXG4gICAgICAgIGlubGluZUluZGVudDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgaW5saW5lQXJyb3dEaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbJ2Rvd24nLCAncmlnaHQnXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKboh6rliqjorqnlvLnlsYLnmoTlrr3luqblkozoj5zljZXpobnkv53mjIHkuIDoh7TvvIzlpoLmnpzlvLnlsYLnmoTlrr3luqbmr5Toj5zljZXpobnlsI/liJnlkozoj5zljZXpobnkv53mjIHkuIDoh7TvvIzlpoLmnpzlrr3luqblpKfkuo7oj5zljZXpobnliJnkuI3lgZrlpITnkIZcbiAgICAgICAgICovXG4gICAgICAgIHBvcHVwQXV0b1dpZHRoOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxgueahOWvuem9kOaWueW8j1xuICAgICAgICAgKi9cbiAgICAgICAgcG9wdXBBbGlnbjogUHJvcFR5cGVzLm9uZU9mKFsnZm9sbG93JywgJ291dHNpZGUnXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLoh6rlrprkuYkgcHJvcHNcbiAgICAgICAgICovXG4gICAgICAgIHBvcHVwUHJvcHM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlh7rlrZDoj5zljZXoh6rlrprkuYkgY2xhc3NOYW1lXG4gICAgICAgICAqL1xuICAgICAgICBwb3B1cENsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWHuuWtkOiPnOWNleiHquWumuS5iSBzdHlsZVxuICAgICAgICAgKi9cbiAgICAgICAgcG9wdXBTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW9k+WJjemAieS4reiPnOWNlemhueeahCBrZXkg5YC8XG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3RlZEtleXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5hcnJheV0pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5Yid5aeL6YCJ5Lit6I+c5Y2V6aG555qEIGtleSDlgLxcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRTZWxlY3RlZEtleXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5hcnJheV0pLFxuICAgICAgICAvKipcbiAgICAgICAgICog6YCJ5Lit5oiW5Y+W5raI6YCJ5Lit6I+c5Y2V6aG56Kem5Y+R55qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkS2V5cyDpgInkuK3nmoTmiYDmnInoj5zljZXpobnnmoTlgLxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0g6YCJ5Lit5oiW5Y+W5raI6YCJ5Lit55qE6I+c5Y2V6aG5XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHRyYSDpop3lpJblj4LmlbBcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBleHRyYS5zZWxlY3Qg5piv5ZCm5piv6YCJ5LitXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGV4dHJhLmtleSDoj5zljZXpobnnmoQga2V5XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHRyYS5sYWJlbCDoj5zljZXpobnnmoTmlofmnKxcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gZXh0cmEua2V5UGF0aCDoj5zljZXpobkga2V5IOeahOi3r+W+hFxuICAgICAgICAgKi9cbiAgICAgICAgb25TZWxlY3Q6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog6YCJ5Lit5qih5byP77yM5Y2V6YCJ6L+Y5piv5aSa6YCJ77yM6buY6K6k5peg5YC877yM5LiN5Y+v6YCJXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3RNb2RlOiBQcm9wVHlwZXMub25lT2YoWydzaW5nbGUnLCAnbXVsdGlwbGUnXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblj6rog73pgInmi6nnrKzkuIDlsYLoj5zljZXpobnvvIjkuI3og73pgInmi6nlrZDoj5zljZXkuK3nmoToj5zljZXpobnvvIlcbiAgICAgICAgICovXG4gICAgICAgIHNoYWxsb3dTZWxlY3Q6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5pi+56S66YCJ5Lit5Zu+5qCH77yM5aaC5p6c6K6+572u5Li6IGZhbHNlIOmcgOmFjeWQiOmFjee9ruW5s+WPsOiuvue9rumAieS4reaXtueahOiDjOaZr+iJsuS7peekuuWMuuWIhlxuICAgICAgICAgKi9cbiAgICAgICAgaGFzU2VsZWN0ZWRJY29uOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgbGFiZWxUb2dnbGVDaGVja2VkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiPnOWNleesrOS4gOWxguWxleekuuaWueWQkVxuICAgICAgICAgKi9cbiAgICAgICAgZGlyZWN0aW9uOiBQcm9wVHlwZXMub25lT2YoWyd2ZXInLCAnaG96J10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5qiq5ZCR6I+c5Y2V5p2hIGl0ZW0g5ZKMIGZvb3RlciDnmoTlr7npvZDmlrnlkJHvvIzlnKggZGlyZWN0aW9uIOiuvue9ruS4uiAnaG96JyDlubbkuJQgaGVhZGVyIOWtmOWcqOaXtueUn+aViFxuICAgICAgICAgKi9cbiAgICAgICAgaG96QWxpZ246IFByb3BUeXBlcy5vbmVPZihbJ2xlZnQnLCAncmlnaHQnXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnoj5zljZXlpLTpg6hcbiAgICAgICAgICovXG4gICAgICAgIGhlYWRlcjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnoj5zljZXlsL7pg6hcbiAgICAgICAgICovXG4gICAgICAgIGZvb3RlcjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKboh6rliqjojrflvpfnhKbngrlcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Gb2N1czogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvZPliY3ojrflvpfnhKbngrnnmoTlrZDoj5zljZXmiJboj5zljZXpobkga2V5IOWAvFxuICAgICAgICAgKi9cbiAgICAgICAgZm9jdXNlZEtleTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgZm9jdXNhYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgb25JdGVtRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkl0ZW1LZXlEb3duOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgZXhwYW5kQW5pbWF0aW9uOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgaXRlbUNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZ1xuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBwcmVmaXg6ICduZXh0LScsXG4gICAgICAgIHB1cmU6IGZhbHNlLFxuICAgICAgICBkZWZhdWx0T3BlbktleXM6IFtdLFxuICAgICAgICBkZWZhdWx0T3BlbkFsbDogZmFsc2UsXG4gICAgICAgIG9uT3Blbjogbm9vcCxcbiAgICAgICAgbW9kZTogJ2lubGluZScsXG4gICAgICAgIHRyaWdnZXJUeXBlOiAnY2xpY2snLFxuICAgICAgICBvcGVuTW9kZTogJ211bHRpcGxlJyxcbiAgICAgICAgaW5saW5lSW5kZW50OiAyMCxcbiAgICAgICAgaW5saW5lQXJyb3dEaXJlY3Rpb246ICdkb3duJyxcbiAgICAgICAgcG9wdXBBdXRvV2lkdGg6IGZhbHNlLFxuICAgICAgICBwb3B1cEFsaWduOiAnZm9sbG93JyxcbiAgICAgICAgcG9wdXBQcm9wczoge30sXG4gICAgICAgIGRlZmF1bHRTZWxlY3RlZEtleXM6IFtdLFxuICAgICAgICBvblNlbGVjdDogbm9vcCxcbiAgICAgICAgc2hhbGxvd1NlbGVjdDogZmFsc2UsXG4gICAgICAgIGhhc1NlbGVjdGVkSWNvbjogdHJ1ZSxcbiAgICAgICAgbGFiZWxUb2dnbGVDaGVja2VkOiB0cnVlLFxuICAgICAgICBkaXJlY3Rpb246ICd2ZXInLFxuICAgICAgICBob3pBbGlnbjogJ2xlZnQnLFxuICAgICAgICBhdXRvRm9jdXM6IGZhbHNlLFxuICAgICAgICBmb2N1c2FibGU6IHRydWUsXG4gICAgICAgIG9uSXRlbUZvY3VzOiBub29wLFxuICAgICAgICBvbkl0ZW1LZXlEb3duOiBub29wLFxuICAgICAgICBvbkl0ZW1DbGljazogbm9vcCxcbiAgICAgICAgZXhwYW5kQW5pbWF0aW9uOiB0cnVlXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuLCBzZWxlY3RlZEtleXMsIGRlZmF1bHRTZWxlY3RlZEtleXMsIGZvY3VzZWRLZXksIGZvY3VzYWJsZSwgYXV0b0ZvY3VzIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIHRoaXMubmV3Q2hpbGRyZW4gPSB0aGlzLmdldE5ld0NoaWxkcmVuKGNoaWxkcmVuKTtcblxuICAgICAgICBpZiAoZm9jdXNhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnRhYmJhYmxlS2V5ID0gdGhpcy5nZXRGaXJzdEF2YWxpYWJsZWxDaGlsZEtleSgnMCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBvcGVuS2V5czogdGhpcy5nZXRJbml0T3BlbktleXMocHJvcHMpLFxuICAgICAgICAgICAgc2VsZWN0ZWRLZXlzOiB0aGlzLm5vcm1hbGl6ZVRvQXJyYXkoc2VsZWN0ZWRLZXlzIHx8IGRlZmF1bHRTZWxlY3RlZEtleXMpLFxuICAgICAgICAgICAgZm9jdXNlZEtleTogJ2ZvY3VzZWRLZXknIGluIHRoaXMucHJvcHMgPyBmb2N1c2VkS2V5IDogKGZvY3VzYWJsZSAmJiBhdXRvRm9jdXMgPyB0aGlzLnRhYmJhYmxlS2V5IDogbnVsbClcbiAgICAgICAgfTtcblxuICAgICAgICBiaW5kQ3R4KHRoaXMsIFsnaGFuZGxlT3BlbicsICdoYW5kbGVTZWxlY3QnLCAnaGFuZGxlSXRlbUNsaWNrJywgJ2hhbmRsZUl0ZW1LZXlEb3duJywgJ29uQmx1ciddKTtcblxuICAgICAgICB0aGlzLnBvcHVwTm9kZXMgPSBbXTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5tZW51Tm9kZSA9IGZpbmRET01Ob2RlKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0ge307XG5cbiAgICAgICAgaWYgKCdvcGVuS2V5cycgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuS2V5cyA9IHRoaXMubm9ybWFsaXplVG9BcnJheShuZXh0UHJvcHMub3BlbktleXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnc2VsZWN0ZWRLZXlzJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIHN0YXRlLnNlbGVjdGVkS2V5cyA9IHRoaXMubm9ybWFsaXplVG9BcnJheShuZXh0UHJvcHMuc2VsZWN0ZWRLZXlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2ZvY3VzZWRLZXknIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgc3RhdGUuZm9jdXNlZEtleSA9IG5leHRQcm9wcy5mb2N1c2VkS2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHN0YXRlKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICAgICAgdGhpcy5uZXdDaGlsZHJlbiA9IHRoaXMuZ2V0TmV3Q2hpbGRyZW4obmV4dFByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZm9jdXNhYmxlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50YWJiYWJsZUtleSBpbiB0aGlzLmsybikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmZvY3VzZWRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWJiYWJsZUtleSA9IHRoaXMuc3RhdGUuZm9jdXNlZEtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGFiYmFibGVLZXkgPSB0aGlzLmdldEZpcnN0QXZhbGlhYmxlbENoaWxkS2V5KCcwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkJsdXIoZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZvY3VzZWRLZXk6ICcnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucHJvcHMub25CbHVyICYmIHRoaXMucHJvcHMub25CbHVyKGUpO1xuICAgIH1cblxuICAgIGdldEluaXRPcGVuS2V5cyhwcm9wcykge1xuICAgICAgICBsZXQgaW5pdE9wZW5LZXlzO1xuXG4gICAgICAgIGNvbnN0IHsgb3BlbktleXMsIGRlZmF1bHRPcGVuS2V5cywgZGVmYXVsdE9wZW5BbGwsIG1vZGUsIG9wZW5Nb2RlIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKG9wZW5LZXlzKSB7XG4gICAgICAgICAgICBpbml0T3BlbktleXMgPSBvcGVuS2V5cztcbiAgICAgICAgfSBlbHNlIGlmIChkZWZhdWx0T3BlbkFsbCAmJiBtb2RlID09PSAnaW5saW5lJyAmJiBvcGVuTW9kZSA9PT0gJ211bHRpcGxlJykge1xuICAgICAgICAgICAgaW5pdE9wZW5LZXlzID0gT2JqZWN0LmtleXModGhpcy5rMm4pLmZpbHRlcihrZXkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmsybltrZXldLnR5cGUgPT09ICdzdWJtZW51JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5pdE9wZW5LZXlzID0gZGVmYXVsdE9wZW5LZXlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplVG9BcnJheShpbml0T3BlbktleXMpO1xuICAgIH1cblxuICAgIGdldE5ld0NoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuazJuID0ge307XG4gICAgICAgIHRoaXMucDJuID0ge307XG4gICAgICAgIGNvbnN0IGxvb3AgPSAoY2hpbGRyZW4sIHBvc1ByZWZpeCwgaW5kZXhXcmFwcGVyID0geyBpbmRleDogMCB9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkICYmIHR5cGVvZiBjaGlsZC50eXBlID09PSAnZnVuY3Rpb24nICYmICgnbWVudUNoaWxkVHlwZScgaW4gY2hpbGQudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0NoaWxkO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3M7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0geyByb290OiB0aGlzIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFsnaXRlbScsICdzdWJtZW51JywgJ2dyb3VwJ10uaW5kZXhPZihjaGlsZC50eXBlLm1lbnVDaGlsZFR5cGUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGAke3Bvc1ByZWZpeH0tJHtpbmRleFdyYXBwZXIuaW5kZXgrK31gO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gdHlwZW9mIGNoaWxkLmtleSA9PT0gJ3N0cmluZycgPyBjaGlsZC5rZXkgOiBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZXZlbCA9IHBvcy5zcGxpdCgnLScpLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmsybltrZXldID0gdGhpcy5wMm5bcG9zXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGNoaWxkLnR5cGUubWVudUNoaWxkVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogY2hpbGQucHJvcHMuZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGNoaWxkLnByb3BzLmxhYmVsIHx8IGNoaWxkLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5fa2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmdyb3VwSW5kZW50ID0gY2hpbGQudHlwZS5tZW51Q2hpbGRUeXBlID09PSAnZ3JvdXAnID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoaWxkLnR5cGUubWVudUNoaWxkVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3VibWVudSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBjbG9uZUVsZW1lbnQoY2hpbGQsIHByb3BzLCBsb29wKGNoaWxkLnByb3BzLmNoaWxkcmVuLCBwb3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dyb3VwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNsb25lRWxlbWVudChjaGlsZCwgcHJvcHMsIGxvb3AoY2hpbGQucHJvcHMuY2hpbGRyZW4sIHBvc1ByZWZpeCwgaW5kZXhXcmFwcGVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpdGVtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RpdmlkZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gY2xvbmVFbGVtZW50KGNoaWxkLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3Q2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGxvb3AoY2hpbGRyZW4sICcwJyk7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplVG9BcnJheShpdGVtcykge1xuICAgICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbaXRlbXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlzU2libGluZyhjdXJyZW50UG9zLCB0YXJnZXRQb3MpIHtcbiAgICAgICAgY29uc3QgY3VycmVudE51bXMgPSBjdXJyZW50UG9zLnNwbGl0KCctJykuc2xpY2UoMCwgLTEpO1xuICAgICAgICBjb25zdCB0YXJnZXROdW1zID0gdGFyZ2V0UG9zLnNwbGl0KCctJykuc2xpY2UoMCwgLTEpO1xuXG4gICAgICAgIHJldHVybiBjdXJyZW50TnVtcy5sZW5ndGggPT09IHRhcmdldE51bXMubGVuZ3RoICYmIGN1cnJlbnROdW1zLmV2ZXJ5KChudW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbnVtID09PSB0YXJnZXROdW1zW2luZGV4XTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaXNBbmNlc3RvcihjdXJyZW50UG9zLCB0YXJnZXRQb3MpIHtcbiAgICAgICAgY29uc3QgY3VycmVudE51bXMgPSBjdXJyZW50UG9zLnNwbGl0KCctJyk7XG4gICAgICAgIGNvbnN0IHRhcmdldE51bXMgPSB0YXJnZXRQb3Muc3BsaXQoJy0nKTtcblxuICAgICAgICByZXR1cm4gY3VycmVudE51bXMubGVuZ3RoID4gdGFyZ2V0TnVtcy5sZW5ndGggJiYgdGFyZ2V0TnVtcy5ldmVyeSgobnVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG51bSA9PT0gY3VycmVudE51bXNbaW5kZXhdO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoYW5kbGVPcGVuKGtleSwgb3BlbiwgdHJpZ2dlclR5cGUsIGUpIHtcbiAgICAgICAgbGV0IG5ld09wZW5LZXlzO1xuXG4gICAgICAgIGNvbnN0IHsgbW9kZSwgb3Blbk1vZGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgb3BlbktleXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gb3BlbktleXMuaW5kZXhPZihrZXkpO1xuICAgICAgICBpZiAob3BlbiAmJiBpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgICAgIGlmIChvcGVuTW9kZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3T3BlbktleXMgPSBvcGVuS2V5cy5maWx0ZXIoayA9PiAhdGhpcy5pc1NpYmxpbmcodGhpcy5rMm5ba2V5XS5wb3MsIHRoaXMuazJuW2tdLnBvcykpO1xuICAgICAgICAgICAgICAgICAgICBuZXdPcGVuS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3T3BlbktleXMgPSBvcGVuS2V5cy5jb25jYXQoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld09wZW5LZXlzID0gb3BlbktleXMuZmlsdGVyKGsgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc0FuY2VzdG9yKHRoaXMuazJuW2tleV0ucG9zLCB0aGlzLmsybltrXS5wb3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG5ld09wZW5LZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghb3BlbiAmJiBpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICAgICBuZXdPcGVuS2V5cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgLi4ub3BlbktleXMuc2xpY2UoMCwgaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAuLi5vcGVuS2V5cy5zbGljZShpbmRleCArIDEpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHJpZ2dlclR5cGUgPT09ICdkb2NDbGljaycpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucG9wdXBOb2Rlcy5jb25jYXQodGhpcy5tZW51Tm9kZSkuc29tZShub2RlID0+IG5vZGUuY29udGFpbnMoZS50YXJnZXQpKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdPcGVuS2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3T3BlbktleXMgPSBvcGVuS2V5cy5maWx0ZXIoayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrICE9PSBrZXkgJiYgIXRoaXMuaXNBbmNlc3Rvcih0aGlzLmsybltrXS5wb3MsIHRoaXMuazJuW2tleV0ucG9zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdPcGVuS2V5cykge1xuICAgICAgICAgICAgaWYgKCEoJ29wZW5LZXlzJyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBvcGVuS2V5czogbmV3T3BlbktleXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbk9wZW4obmV3T3BlbktleXMsIHtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgb3BlblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRQYXRoKGtleSkge1xuICAgICAgICBjb25zdCBrZXlQYXRoID0gW107XG4gICAgICAgIGNvbnN0IGxhYmVsUGF0aCA9IFtdO1xuXG4gICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuazJuW2tleV0ucG9zO1xuICAgICAgICBjb25zdCBudW1zID0gcG9zLnNwbGl0KCctJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE51bXMgPSBudW1zLnNsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFBvcyA9IHBhcmVudE51bXMuam9pbignLScpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5wMm5bcGFyZW50UG9zXTtcbiAgICAgICAgICAgIGtleVBhdGgucHVzaChwYXJlbnQua2V5KTtcbiAgICAgICAgICAgIGxhYmVsUGF0aC5wdXNoKHBhcmVudC5sYWJlbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgIGxhYmVsUGF0aFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGhhbmRsZVNlbGVjdChrZXksIHNlbGVjdCwgbWVudUl0ZW0pIHtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5rMm5ba2V5XS5wb3M7XG4gICAgICAgIGNvbnN0IGxldmVsID0gcG9zLnNwbGl0KCctJykubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuc2hhbGxvd1NlbGVjdCAmJiBsZXZlbCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuZXdTZWxlY3RlZEtleXM7XG5cbiAgICAgICAgY29uc3QgeyBzZWxlY3RNb2RlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHNlbGVjdGVkS2V5cyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzZWxlY3RlZEtleXMuaW5kZXhPZihrZXkpO1xuICAgICAgICBpZiAoc2VsZWN0ICYmIGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdE1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgbmV3U2VsZWN0ZWRLZXlzID0gW2tleV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdE1vZGUgPT09ICdtdWx0aXBsZScpIHtcbiAgICAgICAgICAgICAgICBuZXdTZWxlY3RlZEtleXMgPSBzZWxlY3RlZEtleXMuY29uY2F0KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXNlbGVjdCAmJiBpbmRleCA+IC0xICYmIHNlbGVjdE1vZGUgPT09ICdtdWx0aXBsZScpIHtcbiAgICAgICAgICAgIG5ld1NlbGVjdGVkS2V5cyA9IFtcbiAgICAgICAgICAgICAgICAuLi5zZWxlY3RlZEtleXMuc2xpY2UoMCwgaW5kZXgpLFxuICAgICAgICAgICAgICAgIC4uLnNlbGVjdGVkS2V5cy5zbGljZShpbmRleCArIDEpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld1NlbGVjdGVkS2V5cykge1xuICAgICAgICAgICAgaWYgKCEoJ3NlbGVjdGVkS2V5cycgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRLZXlzOiBuZXdTZWxlY3RlZEtleXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblNlbGVjdChuZXdTZWxlY3RlZEtleXMsIG1lbnVJdGVtLCB7XG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHNlbGVjdCxcbiAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5rMm5ba2V5XS5sYWJlbCxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmdldFBhdGgoa2V5KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVJdGVtQ2xpY2soa2V5LCBpdGVtLCBlKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmZvY3VzYWJsZSkge1xuICAgICAgICAgICAgaWYgKCEoJ2ZvY3VzZWRLZXknIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzZWRLZXk6IGtleVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uSXRlbUZvY3VzKGtleSwgaXRlbSwgZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbS5wcm9wcy50eXBlID09PSAnaXRlbScpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLnByb3BzLnBhcmVudE1vZGUgPT09ICdwb3B1cCcgJiYgdGhpcy5zdGF0ZS5vcGVuS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoISgnb3BlbktleXMnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbktleXM6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25PcGVuKFtdLCB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogdGhpcy5zdGF0ZS5vcGVuS2V5cy5zb3J0KChwcmV2S2V5LCBuZXh0S2V5KSA9PiB0aGlzLmsybltuZXh0S2V5XS5wb3Muc3BsaXQoJy0nKS5sZW5ndGggLSB0aGlzLmsybltwcmV2S2V5XS5wb3Muc3BsaXQoJy0nKS5sZW5ndGgpWzBdLFxuICAgICAgICAgICAgICAgICAgICBvcGVuOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uSXRlbUNsaWNrKGtleSwgaXRlbSwgZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0F2YWlsYWJsZVBvcyhyZWZQb3MsIHRhcmdldFBvcykge1xuICAgICAgICBjb25zdCB7IHR5cGUsIGRpc2FibGVkIH0gPSB0aGlzLnAyblt0YXJnZXRQb3NdO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmlzU2libGluZyhyZWZQb3MsIHRhcmdldFBvcykgJiZcbiAgICAgICAgICAgICh0eXBlID09PSAnaXRlbScgJiYgIWRpc2FibGVkIHx8IHR5cGUgPT09ICdzdWJtZW51Jyk7XG4gICAgfVxuXG4gICAgZ2V0QXZhaWxhYmxlS2V5KHBvcywgcHJldikge1xuICAgICAgICBjb25zdCBwcyA9IE9iamVjdC5rZXlzKHRoaXMucDJuKS5maWx0ZXIocCA9PiB0aGlzLmlzQXZhaWxhYmxlUG9zKHBvcywgcCkpO1xuICAgICAgICBpZiAocHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwcy5pbmRleE9mKHBvcyk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0SW5kZXg7XG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgIHRhcmdldEluZGV4ID0gaW5kZXggPT09IDAgPyBwcy5sZW5ndGggLSAxIDogaW5kZXggLSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRJbmRleCA9IGluZGV4ID09PSBwcy5sZW5ndGggLSAxID8gMCA6IGluZGV4ICsgMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucDJuW3BzW3RhcmdldEluZGV4XV0ua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZ2V0Rmlyc3RBdmFsaWFibGVsQ2hpbGRLZXkocGFyZW50UG9zKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IE9iamVjdC5rZXlzKHRoaXMucDJuKS5maW5kKHAgPT4gdGhpcy5pc0F2YWlsYWJsZVBvcyhgJHtwYXJlbnRQb3N9LTBgLCBwKSk7XG4gICAgICAgIHJldHVybiBwb3MgPyB0aGlzLnAybltwb3NdLmtleSA6IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0UGFyZW50S2V5KHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5wMm5bcG9zLnNsaWNlKDAsIHBvcy5sZW5ndGggLSAyKV0ua2V5O1xuICAgIH1cblxuICAgIGhhbmRsZUl0ZW1LZXlEb3duKGtleSwgdHlwZSwgaXRlbSwgZSkge1xuICAgICAgICBpZiAoW1xuICAgICAgICAgICAgS0VZQ09ERS5VUCwgS0VZQ09ERS5ET1dOLCBLRVlDT0RFLlJJR0hULCBLRVlDT0RFLkxFRlQsXG4gICAgICAgICAgICBLRVlDT0RFLkVOVEVSLCBLRVlDT0RFLkVTQywgS0VZQ09ERS5TUEFDRVxuICAgICAgICBdLmluZGV4T2YoZS5rZXlDb2RlKSA+IC0xKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZvY3VzZWRLZXkgPSB0aGlzLnN0YXRlLmZvY3VzZWRLZXk7XG5cbiAgICAgICAgY29uc3QgeyBkaXJlY3Rpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuazJuW2tleV0ucG9zO1xuICAgICAgICBjb25zdCBsZXZlbCA9IHBvcy5zcGxpdCgnLScpLmxlbmd0aCAtIDE7XG4gICAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIEtFWUNPREUuVVA6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdmFsaWFibGVLZXkgPSB0aGlzLmdldEF2YWlsYWJsZUtleShwb3MsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChhdmFsaWFibGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNlZEtleSA9IGF2YWxpYWJsZUtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEtFWUNPREUuRE9XTjoge1xuICAgICAgICAgICAgICAgIGxldCBhdmFsaWFibGVLZXk7XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2hveicgJiYgbGV2ZWwgPT09IDEgJiYgdHlwZSA9PT0gJ3N1Ym1lbnUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlT3BlbihrZXksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBhdmFsaWFibGVLZXkgPSB0aGlzLmdldEZpcnN0QXZhbGlhYmxlbENoaWxkS2V5KHBvcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXZhbGlhYmxlS2V5ID0gdGhpcy5nZXRBdmFpbGFibGVLZXkocG9zLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhdmFsaWFibGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNlZEtleSA9IGF2YWxpYWJsZUtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEtFWUNPREUuUklHSFQ6IHtcbiAgICAgICAgICAgICAgICBsZXQgYXZhbGlhYmxlS2V5O1xuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdob3onICYmIGxldmVsID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGF2YWxpYWJsZUtleSA9IHRoaXMuZ2V0QXZhaWxhYmxlS2V5KHBvcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N1Ym1lbnUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlT3BlbihrZXksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBhdmFsaWFibGVLZXkgPSB0aGlzLmdldEZpcnN0QXZhbGlhYmxlbENoaWxkS2V5KHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhdmFsaWFibGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNlZEtleSA9IGF2YWxpYWJsZUtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEtFWUNPREUuRU5URVI6IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3N1Ym1lbnUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlT3BlbihrZXksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdmFsaWFibGVLZXkgPSB0aGlzLmdldEZpcnN0QXZhbGlhYmxlbENoaWxkS2V5KHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdmFsaWFibGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzZWRLZXkgPSBhdmFsaWFibGVLZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEtFWUNPREUuTEVGVDoge1xuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdob3onICYmIGxldmVsID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF2YWxpYWJsZUtleSA9IHRoaXMuZ2V0QXZhaWxhYmxlS2V5KHBvcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdmFsaWFibGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzZWRLZXkgPSBhdmFsaWFibGVLZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxldmVsID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRLZXkgPSB0aGlzLmdldFBhcmVudEtleShwb3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU9wZW4ocGFyZW50S2V5LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzZWRLZXkgPSBwYXJlbnRLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBLRVlDT0RFLkVTQzpcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudEtleSA9IHRoaXMuZ2V0UGFyZW50S2V5KHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlT3BlbihwYXJlbnRLZXksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNlZEtleSA9IHBhcmVudEtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgS0VZQ09ERS5UQUI6XG4gICAgICAgICAgICAgICAgZm9jdXNlZEtleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvY3VzZWRLZXkgIT09IHRoaXMuc3RhdGUuZm9jdXNlZEtleSkge1xuICAgICAgICAgICAgaWYgKCEoJ2ZvY3VzZWRLZXknIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzZWRLZXlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkl0ZW1LZXlEb3duKGZvY3VzZWRLZXksIGl0ZW0sIGUpO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkl0ZW1Gb2N1cyhmb2N1c2VkS2V5LCBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIGNsYXNzTmFtZSwgZGlyZWN0aW9uLCBob3pBbGlnbiwgaGVhZGVyLCBmb290ZXIsIHNlbGVjdE1vZGUsIHJ0bCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gcGlja090aGVycyhPYmplY3Qua2V5cyhNZW51LnByb3BUeXBlcyksIHRoaXMucHJvcHMpO1xuXG4gICAgICAgIGNvbnN0IG5ld0NsYXNzTmFtZSA9IGN4KHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9bWVudWBdOiB0cnVlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH12ZXJgXTogZGlyZWN0aW9uID09PSAndmVyJyxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9aG96YF06IGRpcmVjdGlvbiA9PT0gJ2hveicsXG4gICAgICAgICAgICBbY2xhc3NOYW1lXTogISFjbGFzc05hbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgcm9sZSA9IGRpcmVjdGlvbiA9PT0gJ2hveicgPyAnbWVudWJhcicgOiAnbWVudSc7XG4gICAgICAgIGNvbnN0IGhlYWRlckVsZW1lbnQgPSBoZWFkZXIgPyA8bGkgY2xhc3NOYW1lPXtgJHtwcmVmaXh9bWVudS1oZWFkZXJgfT57aGVhZGVyfTwvbGk+IDogbnVsbDtcbiAgICAgICAgY29uc3QgaXRlbXNFbGVtZW50ID0gaGVhZGVyIHx8IGZvb3RlciA/ICA8dWwgY2xhc3NOYW1lPXtgJHtwcmVmaXh9bWVudS1jb250ZW50YH0+e3RoaXMubmV3Q2hpbGRyZW59PC91bD4gOiB0aGlzLm5ld0NoaWxkcmVuO1xuICAgICAgICBjb25zdCBmb290ZXJFbGVtZW50ID0gZm9vdGVyID8gPGxpIGNsYXNzTmFtZT17YCR7cHJlZml4fW1lbnUtZm9vdGVyYH0+e2Zvb3Rlcn08L2xpPiA6IG51bGw7XG4gICAgICAgIGNvbnN0IHNob3VsZFdyYXBJdGVtc0FuZEZvb3RlciA9IGhvekFsaWduID09PSAncmlnaHQnICYmICEhaGVhZGVyO1xuXG4gICAgICAgIGlmIChydGwpIHtcbiAgICAgICAgICAgIG90aGVycy5kaXIgPSAncnRsJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8dWwgcm9sZT17cm9sZX0gb25CbHVyPXt0aGlzLm9uQmx1cn0gY2xhc3NOYW1lPXtuZXdDbGFzc05hbWV9IG9uS2V5RG93bj17dGhpcy5oYW5kbGVFbnRlcn0gYXJpYS1tdWx0aXNlbGVjdGFibGU9e3NlbGVjdE1vZGUgPT09ICdtdWx0aXBsZSd9IHsuLi5vdGhlcnN9PlxuICAgICAgICAgICAgICAgIHtoZWFkZXJFbGVtZW50fVxuICAgICAgICAgICAgICAgIHtzaG91bGRXcmFwSXRlbXNBbmRGb290ZXIgP1xuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fW1lbnUtaG96LXJpZ2h0YH0+XG4gICAgICAgICAgICAgICAgICAgICAgICB7aXRlbXNFbGVtZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAge2Zvb3RlckVsZW1lbnR9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PiA6IG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeyFzaG91bGRXcmFwSXRlbXNBbmRGb290ZXIgPyBpdGVtc0VsZW1lbnQgOiBudWxsfVxuICAgICAgICAgICAgICAgIHshc2hvdWxkV3JhcEl0ZW1zQW5kRm9vdGVyID8gZm9vdGVyRWxlbWVudCA6IG51bGx9XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tZW51L3ZpZXcvbWVudS5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uR3JvdXAgfSBmcm9tICdyZWFjdC10cmFuc2l0aW9uLWdyb3VwJztcbmltcG9ydCBBbmltYXRlQ2hpbGQgZnJvbSAnLi9jaGlsZCc7XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcbmNvbnN0IEZpcnN0Q2hpbGQgPSBwcm9wcyA9PiB7XG4gICAgY29uc3QgY2hpbGRyZW5BcnJheSA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkocHJvcHMuY2hpbGRyZW4pO1xuICAgIHJldHVybiBjaGlsZHJlbkFycmF5WzBdIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIEFuaW1hdGVcbiAqL1xuY2xhc3MgQW5pbWF0ZSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWKqOeUuyBjbGFzc05hbWVcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5a2Q5YWD57Sg56ys5LiA5qyh5oyC6L295pe25piv5ZCm5omn6KGM5Yqo55S7XG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRpb25BcHBlYXI6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5YyF6KO55a2Q5YWD57Sg55qE5qCH562+XG4gICAgICAgICAqL1xuICAgICAgICBjb21wb25lbnQ6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblj6rmnInljZXkuKrlrZDlhYPntKDvvIzlpoLmnpzmnInlpJrkuKrlrZDlhYPntKDvvIzor7forr7nva7kuLogZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZU1vZGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5a2Q5YWD57SgXG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmVsZW1lbnQsIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5lbGVtZW50KV0pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5omn6KGM56ys5LiA5qyh5oyC6L295Yqo55S75YmN6Kem5Y+R55qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqL1xuICAgICAgICBiZWZvcmVBcHBlYXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5omn6KGM56ys5LiA5qyh5oyC6L295Yqo55S777yM5re75YqgIHh4eC1hcHBlYXItYWN0aXZlIOexu+WQjeWQjuinpuWPkeeahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiAgQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBcYuaJp+ihjOWKqOeUu+eahCBkb20g5YWD57SgXG4gICAgICAgICAqL1xuICAgICAgICBvbkFwcGVhcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmiafooYzlroznrKzkuIDmrKHmjILovb3liqjnlLvlkI7op6blj5HnmoTlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBcYuaJp+ihjOWKqOeUu+eahCBkb20g5YWD57SgXG4gICAgICAgICAqL1xuICAgICAgICBhZnRlckFwcGVhcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmiafooYzov5vlnLrliqjnlLvliY3op6blj5HnmoTlm57osIPlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBcYuaJp+ihjOWKqOeUu+eahCBkb20g5YWD57SgXG4gICAgICAgICAqL1xuICAgICAgICBiZWZvcmVFbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmiafooYzov5vlnLrliqjnlLvvvIzmt7vliqAgeHh4LWVudGVyLWFjdGl2ZSDnsbvlkI3lkI7op6blj5HnmoTlm57osIPlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBcYuaJp+ihjOWKqOeUu+eahCBkb20g5YWD57SgXG4gICAgICAgICAqL1xuICAgICAgICBvbkVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaJp+ihjOWujOi/m+WcuuWKqOeUu+WQjuinpuWPkeeahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIFxi5omn6KGM5Yqo55S755qEIGRvbSDlhYPntKBcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5omn6KGM56a75Zy65Yqo55S75YmN6Kem5Y+R55qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgXGLmiafooYzliqjnlLvnmoQgZG9tIOWFg+e0oFxuICAgICAgICAgKi9cbiAgICAgICAgYmVmb3JlTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5omn6KGM56a75Zy65Yqo55S777yM5re75YqgIHh4eC1sZWF2ZS1hY3RpdmUg57G75ZCN5ZCO6Kem5Y+R55qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgXGLmiafooYzliqjnlLvnmoQgZG9tIOWFg+e0oFxuICAgICAgICAgKi9cbiAgICAgICAgb25MZWF2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmiafooYzlroznprvlnLrliqjnlLvlkI7op6blj5HnmoTlm57osIPlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBcYuaJp+ihjOWKqOeUu+eahCBkb20g5YWD57SgXG4gICAgICAgICAqL1xuICAgICAgICBhZnRlckxlYXZlOiBQcm9wVHlwZXMuZnVuY1xuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBhbmltYXRpb25BcHBlYXI6IHRydWUsXG4gICAgICAgIGNvbXBvbmVudDogJ2RpdicsXG4gICAgICAgIHNpbmdsZU1vZGU6IHRydWUsXG4gICAgICAgIGJlZm9yZUFwcGVhcjogbm9vcCxcbiAgICAgICAgb25BcHBlYXI6IG5vb3AsXG4gICAgICAgIGFmdGVyQXBwZWFyOiBub29wLFxuICAgICAgICBiZWZvcmVFbnRlcjogbm9vcCxcbiAgICAgICAgb25FbnRlcjogbm9vcCxcbiAgICAgICAgYWZ0ZXJFbnRlcjogbm9vcCxcbiAgICAgICAgYmVmb3JlTGVhdmU6IG5vb3AsXG4gICAgICAgIG9uTGVhdmU6IG5vb3AsXG4gICAgICAgIGFmdGVyTGVhdmU6IG5vb3BcbiAgICB9O1xuXG4gICAgbm9ybWFsaXplTmFtZXMobmFtZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXBwZWFyOiBgJHtuYW1lc30tYXBwZWFyYCxcbiAgICAgICAgICAgICAgICBhcHBlYXJBY3RpdmU6IGAke25hbWVzfS1hcHBlYXItYWN0aXZlYCxcbiAgICAgICAgICAgICAgICBlbnRlcjogYCR7bmFtZXN9LWVudGVyYCxcbiAgICAgICAgICAgICAgICBlbnRlckFjdGl2ZTogYCR7bmFtZXN9LWVudGVyLWFjdGl2ZWAsXG4gICAgICAgICAgICAgICAgbGVhdmU6IGAke25hbWVzfS1sZWF2ZWAsXG4gICAgICAgICAgICAgICAgbGVhdmVBY3RpdmU6IGAke25hbWVzfS1sZWF2ZS1hY3RpdmVgXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFwcGVhcjogbmFtZXMuYXBwZWFyLFxuICAgICAgICAgICAgICAgIGFwcGVhckFjdGl2ZTogYCR7bmFtZXMuYXBwZWFyfS1hY3RpdmVgLFxuICAgICAgICAgICAgICAgIGVudGVyOiBgJHtuYW1lcy5lbnRlcn1gLFxuICAgICAgICAgICAgICAgIGVudGVyQWN0aXZlOiBgJHtuYW1lcy5lbnRlcn0tYWN0aXZlYCxcbiAgICAgICAgICAgICAgICBsZWF2ZTogYCR7bmFtZXMubGVhdmV9YCxcbiAgICAgICAgICAgICAgICBsZWF2ZUFjdGl2ZTogYCR7bmFtZXMubGVhdmV9LWFjdGl2ZWAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uLCBjaGlsZHJlbiwgYW5pbWF0aW9uQXBwZWFyLCBzaW5nbGVNb2RlLCBjb21wb25lbnQsXG4gICAgICAgICAgICBiZWZvcmVBcHBlYXIsIG9uQXBwZWFyLCBhZnRlckFwcGVhcixcbiAgICAgICAgICAgIGJlZm9yZUVudGVyLCBvbkVudGVyLCBhZnRlckVudGVyLFxuICAgICAgICAgICAgYmVmb3JlTGVhdmUsIG9uTGVhdmUsIGFmdGVyTGVhdmUsXG4gICAgICAgICAgICAuLi5vdGhlcnNcbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuICAgICAgICBjb25zdCBhbmltYXRlQ2hpbGRyZW4gPSBDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGNoaWxkID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPEFuaW1hdGVDaGlsZCBrZXk9e2NoaWxkLmtleX1cbiAgICAgICAgICAgICAgICAgICAgbmFtZXM9e3RoaXMubm9ybWFsaXplTmFtZXMoYW5pbWF0aW9uKX1cbiAgICAgICAgICAgICAgICAgICAgb25BcHBlYXI9e2JlZm9yZUFwcGVhcn1cbiAgICAgICAgICAgICAgICAgICAgb25BcHBlYXJpbmc9e29uQXBwZWFyfVxuICAgICAgICAgICAgICAgICAgICBvbkFwcGVhcmVkPXthZnRlckFwcGVhcn1cbiAgICAgICAgICAgICAgICAgICAgb25FbnRlcj17YmVmb3JlRW50ZXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uRW50ZXJpbmc9e29uRW50ZXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uRW50ZXJlZD17YWZ0ZXJFbnRlcn1cbiAgICAgICAgICAgICAgICAgICAgb25FeGl0PXtiZWZvcmVMZWF2ZX1cbiAgICAgICAgICAgICAgICAgICAgb25FeGl0aW5nPXtvbkxlYXZlfVxuICAgICAgICAgICAgICAgICAgICBvbkV4aXRlZD17YWZ0ZXJMZWF2ZX0+XG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZH1cbiAgICAgICAgICAgICAgICA8L0FuaW1hdGVDaGlsZD5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8VHJhbnNpdGlvbkdyb3VwIGFwcGVhcj17YW5pbWF0aW9uQXBwZWFyfSBjb21wb25lbnQ9e3NpbmdsZU1vZGUgPyBGaXJzdENoaWxkIDogY29tcG9uZW50fSB7Li4ub3RoZXJzfT5cbiAgICAgICAgICAgICAgICB7YW5pbWF0ZUNoaWxkcmVufVxuICAgICAgICAgICAgPC9UcmFuc2l0aW9uR3JvdXA+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBbmltYXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FuaW1hdGUvYW5pbWF0ZS5qc3giLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9DU1NUcmFuc2l0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9DU1NUcmFuc2l0aW9uXCIpKTtcblxudmFyIF9SZXBsYWNlVHJhbnNpdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vUmVwbGFjZVRyYW5zaXRpb25cIikpO1xuXG52YXIgX1RyYW5zaXRpb25Hcm91cCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vVHJhbnNpdGlvbkdyb3VwXCIpKTtcblxudmFyIF9UcmFuc2l0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9UcmFuc2l0aW9uXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFRyYW5zaXRpb246IF9UcmFuc2l0aW9uLmRlZmF1bHQsXG4gIFRyYW5zaXRpb25Hcm91cDogX1RyYW5zaXRpb25Hcm91cC5kZWZhdWx0LFxuICBSZXBsYWNlVHJhbnNpdGlvbjogX1JlcGxhY2VUcmFuc2l0aW9uLmRlZmF1bHQsXG4gIENTU1RyYW5zaXRpb246IF9DU1NUcmFuc2l0aW9uLmRlZmF1bHRcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19yZWFjdC10cmFuc2l0aW9uLWdyb3VwQDIuNS4yQHJlYWN0LXRyYW5zaXRpb24tZ3JvdXAvaW5kZXguanMiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuRVhJVElORyA9IGV4cG9ydHMuRU5URVJFRCA9IGV4cG9ydHMuRU5URVJJTkcgPSBleHBvcnRzLkVYSVRFRCA9IGV4cG9ydHMuVU5NT1VOVEVEID0gdm9pZCAwO1xuXG52YXIgUHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX3JlYWN0RG9tID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcblxudmFyIF9yZWFjdExpZmVjeWNsZXNDb21wYXQgPSByZXF1aXJlKFwicmVhY3QtbGlmZWN5Y2xlcy1jb21wYXRcIik7XG5cbnZhciBfUHJvcFR5cGVzID0gcmVxdWlyZShcIi4vdXRpbHMvUHJvcFR5cGVzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBVTk1PVU5URUQgPSAndW5tb3VudGVkJztcbmV4cG9ydHMuVU5NT1VOVEVEID0gVU5NT1VOVEVEO1xudmFyIEVYSVRFRCA9ICdleGl0ZWQnO1xuZXhwb3J0cy5FWElURUQgPSBFWElURUQ7XG52YXIgRU5URVJJTkcgPSAnZW50ZXJpbmcnO1xuZXhwb3J0cy5FTlRFUklORyA9IEVOVEVSSU5HO1xudmFyIEVOVEVSRUQgPSAnZW50ZXJlZCc7XG5leHBvcnRzLkVOVEVSRUQgPSBFTlRFUkVEO1xudmFyIEVYSVRJTkcgPSAnZXhpdGluZyc7XG4vKipcbiAqIFRoZSBUcmFuc2l0aW9uIGNvbXBvbmVudCBsZXRzIHlvdSBkZXNjcmliZSBhIHRyYW5zaXRpb24gZnJvbSBvbmUgY29tcG9uZW50XG4gKiBzdGF0ZSB0byBhbm90aGVyIF9vdmVyIHRpbWVfIHdpdGggYSBzaW1wbGUgZGVjbGFyYXRpdmUgQVBJLiBNb3N0IGNvbW1vbmx5XG4gKiBpdCdzIHVzZWQgdG8gYW5pbWF0ZSB0aGUgbW91bnRpbmcgYW5kIHVubW91bnRpbmcgb2YgYSBjb21wb25lbnQsIGJ1dCBjYW4gYWxzb1xuICogYmUgdXNlZCB0byBkZXNjcmliZSBpbi1wbGFjZSB0cmFuc2l0aW9uIHN0YXRlcyBhcyB3ZWxsLlxuICpcbiAqIEJ5IGRlZmF1bHQgdGhlIGBUcmFuc2l0aW9uYCBjb21wb25lbnQgZG9lcyBub3QgYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHRoZVxuICogY29tcG9uZW50IGl0IHJlbmRlcnMsIGl0IG9ubHkgdHJhY2tzIFwiZW50ZXJcIiBhbmQgXCJleGl0XCIgc3RhdGVzIGZvciB0aGUgY29tcG9uZW50cy5cbiAqIEl0J3MgdXAgdG8geW91IHRvIGdpdmUgbWVhbmluZyBhbmQgZWZmZWN0IHRvIHRob3NlIHN0YXRlcy4gRm9yIGV4YW1wbGUgd2UgY2FuXG4gKiBhZGQgc3R5bGVzIHRvIGEgY29tcG9uZW50IHdoZW4gaXQgZW50ZXJzIG9yIGV4aXRzOlxuICpcbiAqIGBgYGpzeFxuICogaW1wb3J0IFRyYW5zaXRpb24gZnJvbSAncmVhY3QtdHJhbnNpdGlvbi1ncm91cC9UcmFuc2l0aW9uJztcbiAqXG4gKiBjb25zdCBkdXJhdGlvbiA9IDMwMDtcbiAqXG4gKiBjb25zdCBkZWZhdWx0U3R5bGUgPSB7XG4gKiAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7ZHVyYXRpb259bXMgZWFzZS1pbi1vdXRgLFxuICogICBvcGFjaXR5OiAwLFxuICogfVxuICpcbiAqIGNvbnN0IHRyYW5zaXRpb25TdHlsZXMgPSB7XG4gKiAgIGVudGVyaW5nOiB7IG9wYWNpdHk6IDAgfSxcbiAqICAgZW50ZXJlZDogIHsgb3BhY2l0eTogMSB9LFxuICogfTtcbiAqXG4gKiBjb25zdCBGYWRlID0gKHsgaW46IGluUHJvcCB9KSA9PiAoXG4gKiAgIDxUcmFuc2l0aW9uIGluPXtpblByb3B9IHRpbWVvdXQ9e2R1cmF0aW9ufT5cbiAqICAgICB7KHN0YXRlKSA9PiAoXG4gKiAgICAgICA8ZGl2IHN0eWxlPXt7XG4gKiAgICAgICAgIC4uLmRlZmF1bHRTdHlsZSxcbiAqICAgICAgICAgLi4udHJhbnNpdGlvblN0eWxlc1tzdGF0ZV1cbiAqICAgICAgIH19PlxuICogICAgICAgICBJJ20gYSBmYWRlIFRyYW5zaXRpb24hXG4gKiAgICAgICA8L2Rpdj5cbiAqICAgICApfVxuICogICA8L1RyYW5zaXRpb24+XG4gKiApO1xuICogYGBgXG4gKlxuICogQXMgbm90ZWQgdGhlIGBUcmFuc2l0aW9uYCBjb21wb25lbnQgZG9lc24ndCBfZG9fIGFueXRoaW5nIGJ5IGl0c2VsZiB0byBpdHMgY2hpbGQgY29tcG9uZW50LlxuICogV2hhdCBpdCBkb2VzIGRvIGlzIHRyYWNrIHRyYW5zaXRpb24gc3RhdGVzIG92ZXIgdGltZSBzbyB5b3UgY2FuIHVwZGF0ZSB0aGVcbiAqIGNvbXBvbmVudCAoc3VjaCBhcyBieSBhZGRpbmcgc3R5bGVzIG9yIGNsYXNzZXMpIHdoZW4gaXQgY2hhbmdlcyBzdGF0ZXMuXG4gKlxuICogVGhlcmUgYXJlIDQgbWFpbiBzdGF0ZXMgYSBUcmFuc2l0aW9uIGNhbiBiZSBpbjpcbiAqICAtIGAnZW50ZXJpbmcnYFxuICogIC0gYCdlbnRlcmVkJ2BcbiAqICAtIGAnZXhpdGluZydgXG4gKiAgLSBgJ2V4aXRlZCdgXG4gKlxuICogVHJhbnNpdGlvbiBzdGF0ZSBpcyB0b2dnbGVkIHZpYSB0aGUgYGluYCBwcm9wLiBXaGVuIGB0cnVlYCB0aGUgY29tcG9uZW50IGJlZ2lucyB0aGVcbiAqIFwiRW50ZXJcIiBzdGFnZS4gRHVyaW5nIHRoaXMgc3RhZ2UsIHRoZSBjb21wb25lbnQgd2lsbCBzaGlmdCBmcm9tIGl0cyBjdXJyZW50IHRyYW5zaXRpb24gc3RhdGUsXG4gKiB0byBgJ2VudGVyaW5nJ2AgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgdHJhbnNpdGlvbiBhbmQgdGhlbiB0byB0aGUgYCdlbnRlcmVkJ2Agc3RhZ2Ugb25jZVxuICogaXQncyBjb21wbGV0ZS4gTGV0J3MgdGFrZSB0aGUgZm9sbG93aW5nIGV4YW1wbGU6XG4gKlxuICogYGBganN4XG4gKiBzdGF0ZSA9IHsgaW46IGZhbHNlIH07XG4gKlxuICogdG9nZ2xlRW50ZXJTdGF0ZSA9ICgpID0+IHtcbiAqICAgdGhpcy5zZXRTdGF0ZSh7IGluOiB0cnVlIH0pO1xuICogfVxuICpcbiAqIHJlbmRlcigpIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8ZGl2PlxuICogICAgICAgPFRyYW5zaXRpb24gaW49e3RoaXMuc3RhdGUuaW59IHRpbWVvdXQ9ezUwMH0gLz5cbiAqICAgICAgIDxidXR0b24gb25DbGljaz17dGhpcy50b2dnbGVFbnRlclN0YXRlfT5DbGljayB0byBFbnRlcjwvYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICApO1xuICogfVxuICogYGBgXG4gKlxuICogV2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWQgdGhlIGNvbXBvbmVudCB3aWxsIHNoaWZ0IHRvIHRoZSBgJ2VudGVyaW5nJ2Agc3RhdGUgYW5kXG4gKiBzdGF5IHRoZXJlIGZvciA1MDBtcyAodGhlIHZhbHVlIG9mIGB0aW1lb3V0YCkgYmVmb3JlIGl0IGZpbmFsbHkgc3dpdGNoZXMgdG8gYCdlbnRlcmVkJ2AuXG4gKlxuICogV2hlbiBgaW5gIGlzIGBmYWxzZWAgdGhlIHNhbWUgdGhpbmcgaGFwcGVucyBleGNlcHQgdGhlIHN0YXRlIG1vdmVzIGZyb20gYCdleGl0aW5nJ2AgdG8gYCdleGl0ZWQnYC5cbiAqXG4gKiAjIyBUaW1pbmdcbiAqXG4gKiBUaW1pbmcgaXMgb2Z0ZW4gdGhlIHRyaWNraWVzdCBwYXJ0IG9mIGFuaW1hdGlvbiwgbWlzdGFrZXMgY2FuIHJlc3VsdCBpbiBzbGlnaHQgZGVsYXlzXG4gKiB0aGF0IGFyZSBoYXJkIHRvIHBpbiBkb3duLiBBIGNvbW1vbiBleGFtcGxlIGlzIHdoZW4geW91IHdhbnQgdG8gYWRkIGFuIGV4aXQgdHJhbnNpdGlvbixcbiAqIHlvdSBzaG91bGQgc2V0IHRoZSBkZXNpcmVkIGZpbmFsIHN0eWxlcyB3aGVuIHRoZSBzdGF0ZSBpcyBgJ2V4aXRpbmcnYC4gVGhhdCdzIHdoZW4gdGhlXG4gKiB0cmFuc2l0aW9uIHRvIHRob3NlIHN0eWxlcyB3aWxsIHN0YXJ0IGFuZCwgaWYgeW91IG1hdGNoZWQgdGhlIGB0aW1lb3V0YCBwcm9wIHdpdGggdGhlXG4gKiBDU1MgVHJhbnNpdGlvbiBkdXJhdGlvbiwgaXQgd2lsbCBlbmQgZXhhY3RseSB3aGVuIHRoZSBzdGF0ZSBjaGFuZ2VzIHRvIGAnZXhpdGVkJ2AuXG4gKlxuICogPiAqKk5vdGUqKjogRm9yIHNpbXBsZXIgdHJhbnNpdGlvbnMgdGhlIGBUcmFuc2l0aW9uYCBjb21wb25lbnQgbWlnaHQgYmUgZW5vdWdoLCBidXRcbiAqID4gdGFrZSBpbnRvIGFjY291bnQgdGhhdCBpdCdzIHBsYXRmb3JtLWFnbm9zdGljLCB3aGlsZSB0aGUgYENTU1RyYW5zaXRpb25gIGNvbXBvbmVudFxuICogPiBbZm9yY2VzIHJlZmxvd3NdKGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvYmxvYi81MDA3MzAzZTcyOWE3NGJlNjZhMjFjM2UyMjA1ZTQ5MTY4MjE1MjRiL3NyYy9DU1NUcmFuc2l0aW9uLmpzI0wyMDgtTDIxNSlcbiAqID4gaW4gb3JkZXIgdG8gbWFrZSBtb3JlIGNvbXBsZXggdHJhbnNpdGlvbnMgbW9yZSBwcmVkaWN0YWJsZS4gRm9yIGV4YW1wbGUsIGV2ZW4gdGhvdWdoXG4gKiA+IGNsYXNzZXMgYGV4YW1wbGUtZW50ZXJgIGFuZCBgZXhhbXBsZS1lbnRlci1hY3RpdmVgIGFyZSBhcHBsaWVkIGltbWVkaWF0ZWx5IG9uZSBhZnRlclxuICogPiBhbm90aGVyLCB5b3UgY2FuIHN0aWxsIHRyYW5zaXRpb24gZnJvbSBvbmUgdG8gdGhlIG90aGVyIGJlY2F1c2Ugb2YgdGhlIGZvcmNlZCByZWZsb3dcbiAqID4gKHJlYWQgW3RoaXMgaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvaXNzdWVzLzE1OSNpc3N1ZWNvbW1lbnQtMzIyNzYxMTcxKVxuICogPiBmb3IgbW9yZSBpbmZvKS4gVGFrZSB0aGlzIGludG8gYWNjb3VudCB3aGVuIGNob29zaW5nIGJldHdlZW4gYFRyYW5zaXRpb25gIGFuZFxuICogPiBgQ1NTVHJhbnNpdGlvbmAuXG4gKi9cblxuZXhwb3J0cy5FWElUSU5HID0gRVhJVElORztcblxudmFyIFRyYW5zaXRpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoVHJhbnNpdGlvbiwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVHJhbnNpdGlvbihwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgIHZhciBwYXJlbnRHcm91cCA9IGNvbnRleHQudHJhbnNpdGlvbkdyb3VwOyAvLyBJbiB0aGUgY29udGV4dCBvZiBhIFRyYW5zaXRpb25Hcm91cCBhbGwgZW50ZXJzIGFyZSByZWFsbHkgYXBwZWFyc1xuXG4gICAgdmFyIGFwcGVhciA9IHBhcmVudEdyb3VwICYmICFwYXJlbnRHcm91cC5pc01vdW50aW5nID8gcHJvcHMuZW50ZXIgOiBwcm9wcy5hcHBlYXI7XG4gICAgdmFyIGluaXRpYWxTdGF0dXM7XG4gICAgX3RoaXMuYXBwZWFyU3RhdHVzID0gbnVsbDtcblxuICAgIGlmIChwcm9wcy5pbikge1xuICAgICAgaWYgKGFwcGVhcikge1xuICAgICAgICBpbml0aWFsU3RhdHVzID0gRVhJVEVEO1xuICAgICAgICBfdGhpcy5hcHBlYXJTdGF0dXMgPSBFTlRFUklORztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRpYWxTdGF0dXMgPSBFTlRFUkVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcHMudW5tb3VudE9uRXhpdCB8fCBwcm9wcy5tb3VudE9uRW50ZXIpIHtcbiAgICAgICAgaW5pdGlhbFN0YXR1cyA9IFVOTU9VTlRFRDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRpYWxTdGF0dXMgPSBFWElURUQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBzdGF0dXM6IGluaXRpYWxTdGF0dXNcbiAgICB9O1xuICAgIF90aGlzLm5leHRDYWxsYmFjayA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRyYW5zaXRpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zaXRpb25Hcm91cDogbnVsbCAvLyBhbGxvd3MgZm9yIG5lc3RlZCBUcmFuc2l0aW9uc1xuXG4gICAgfTtcbiAgfTtcblxuICBUcmFuc2l0aW9uLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhfcmVmLCBwcmV2U3RhdGUpIHtcbiAgICB2YXIgbmV4dEluID0gX3JlZi5pbjtcblxuICAgIGlmIChuZXh0SW4gJiYgcHJldlN0YXRlLnN0YXR1cyA9PT0gVU5NT1VOVEVEKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IEVYSVRFRFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTsgLy8gZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUocHJldlByb3BzKSB7XG4gIC8vICAgbGV0IG5leHRTdGF0dXMgPSBudWxsXG4gIC8vICAgaWYgKHByZXZQcm9wcyAhPT0gdGhpcy5wcm9wcykge1xuICAvLyAgICAgY29uc3QgeyBzdGF0dXMgfSA9IHRoaXMuc3RhdGVcbiAgLy8gICAgIGlmICh0aGlzLnByb3BzLmluKSB7XG4gIC8vICAgICAgIGlmIChzdGF0dXMgIT09IEVOVEVSSU5HICYmIHN0YXR1cyAhPT0gRU5URVJFRCkge1xuICAvLyAgICAgICAgIG5leHRTdGF0dXMgPSBFTlRFUklOR1xuICAvLyAgICAgICB9XG4gIC8vICAgICB9IGVsc2Uge1xuICAvLyAgICAgICBpZiAoc3RhdHVzID09PSBFTlRFUklORyB8fCBzdGF0dXMgPT09IEVOVEVSRUQpIHtcbiAgLy8gICAgICAgICBuZXh0U3RhdHVzID0gRVhJVElOR1xuICAvLyAgICAgICB9XG4gIC8vICAgICB9XG4gIC8vICAgfVxuICAvLyAgIHJldHVybiB7IG5leHRTdGF0dXMgfVxuICAvLyB9XG5cblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnVwZGF0ZVN0YXR1cyh0cnVlLCB0aGlzLmFwcGVhclN0YXR1cyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICB2YXIgbmV4dFN0YXR1cyA9IG51bGw7XG5cbiAgICBpZiAocHJldlByb3BzICE9PSB0aGlzLnByb3BzKSB7XG4gICAgICB2YXIgc3RhdHVzID0gdGhpcy5zdGF0ZS5zdGF0dXM7XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLmluKSB7XG4gICAgICAgIGlmIChzdGF0dXMgIT09IEVOVEVSSU5HICYmIHN0YXR1cyAhPT0gRU5URVJFRCkge1xuICAgICAgICAgIG5leHRTdGF0dXMgPSBFTlRFUklORztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gRU5URVJJTkcgfHwgc3RhdHVzID09PSBFTlRFUkVEKSB7XG4gICAgICAgICAgbmV4dFN0YXR1cyA9IEVYSVRJTkc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVN0YXR1cyhmYWxzZSwgbmV4dFN0YXR1cyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5jYW5jZWxOZXh0Q2FsbGJhY2soKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VGltZW91dHMgPSBmdW5jdGlvbiBnZXRUaW1lb3V0cygpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMucHJvcHMudGltZW91dDtcbiAgICB2YXIgZXhpdCwgZW50ZXIsIGFwcGVhcjtcbiAgICBleGl0ID0gZW50ZXIgPSBhcHBlYXIgPSB0aW1lb3V0O1xuXG4gICAgaWYgKHRpbWVvdXQgIT0gbnVsbCAmJiB0eXBlb2YgdGltZW91dCAhPT0gJ251bWJlcicpIHtcbiAgICAgIGV4aXQgPSB0aW1lb3V0LmV4aXQ7XG4gICAgICBlbnRlciA9IHRpbWVvdXQuZW50ZXI7XG4gICAgICBhcHBlYXIgPSB0aW1lb3V0LmFwcGVhcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXhpdDogZXhpdCxcbiAgICAgIGVudGVyOiBlbnRlcixcbiAgICAgIGFwcGVhcjogYXBwZWFyXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8udXBkYXRlU3RhdHVzID0gZnVuY3Rpb24gdXBkYXRlU3RhdHVzKG1vdW50aW5nLCBuZXh0U3RhdHVzKSB7XG4gICAgaWYgKG1vdW50aW5nID09PSB2b2lkIDApIHtcbiAgICAgIG1vdW50aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG5leHRTdGF0dXMgIT09IG51bGwpIHtcbiAgICAgIC8vIG5leHRTdGF0dXMgd2lsbCBhbHdheXMgYmUgRU5URVJJTkcgb3IgRVhJVElORy5cbiAgICAgIHRoaXMuY2FuY2VsTmV4dENhbGxiYWNrKCk7XG5cbiAgICAgIHZhciBub2RlID0gX3JlYWN0RG9tLmRlZmF1bHQuZmluZERPTU5vZGUodGhpcyk7XG5cbiAgICAgIGlmIChuZXh0U3RhdHVzID09PSBFTlRFUklORykge1xuICAgICAgICB0aGlzLnBlcmZvcm1FbnRlcihub2RlLCBtb3VudGluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBlcmZvcm1FeGl0KG5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy51bm1vdW50T25FeGl0ICYmIHRoaXMuc3RhdGUuc3RhdHVzID09PSBFWElURUQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzdGF0dXM6IFVOTU9VTlRFRFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wZXJmb3JtRW50ZXIgPSBmdW5jdGlvbiBwZXJmb3JtRW50ZXIobm9kZSwgbW91bnRpbmcpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBlbnRlciA9IHRoaXMucHJvcHMuZW50ZXI7XG4gICAgdmFyIGFwcGVhcmluZyA9IHRoaXMuY29udGV4dC50cmFuc2l0aW9uR3JvdXAgPyB0aGlzLmNvbnRleHQudHJhbnNpdGlvbkdyb3VwLmlzTW91bnRpbmcgOiBtb3VudGluZztcbiAgICB2YXIgdGltZW91dHMgPSB0aGlzLmdldFRpbWVvdXRzKCk7IC8vIG5vIGVudGVyIGFuaW1hdGlvbiBza2lwIHJpZ2h0IHRvIEVOVEVSRURcbiAgICAvLyBpZiB3ZSBhcmUgbW91bnRpbmcgYW5kIHJ1bm5pbmcgdGhpcyBpdCBtZWFucyBhcHBlYXIgX211c3RfIGJlIHNldFxuXG4gICAgaWYgKCFtb3VudGluZyAmJiAhZW50ZXIpIHtcbiAgICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgc3RhdHVzOiBFTlRFUkVEXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5wcm9wcy5vbkVudGVyZWQobm9kZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzLm9uRW50ZXIobm9kZSwgYXBwZWFyaW5nKTtcbiAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICBzdGF0dXM6IEVOVEVSSU5HXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMyLnByb3BzLm9uRW50ZXJpbmcobm9kZSwgYXBwZWFyaW5nKTsgLy8gRklYTUU6IGFwcGVhciB0aW1lb3V0P1xuXG5cbiAgICAgIF90aGlzMi5vblRyYW5zaXRpb25FbmQobm9kZSwgdGltZW91dHMuZW50ZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgICAgc3RhdHVzOiBFTlRFUkVEXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIucHJvcHMub25FbnRlcmVkKG5vZGUsIGFwcGVhcmluZyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnBlcmZvcm1FeGl0ID0gZnVuY3Rpb24gcGVyZm9ybUV4aXQobm9kZSkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdmFyIGV4aXQgPSB0aGlzLnByb3BzLmV4aXQ7XG4gICAgdmFyIHRpbWVvdXRzID0gdGhpcy5nZXRUaW1lb3V0cygpOyAvLyBubyBleGl0IGFuaW1hdGlvbiBza2lwIHJpZ2h0IHRvIEVYSVRFRFxuXG4gICAgaWYgKCFleGl0KSB7XG4gICAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgIHN0YXR1czogRVhJVEVEXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5wcm9wcy5vbkV4aXRlZChub2RlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucHJvcHMub25FeGl0KG5vZGUpO1xuICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgIHN0YXR1czogRVhJVElOR1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMy5wcm9wcy5vbkV4aXRpbmcobm9kZSk7XG5cbiAgICAgIF90aGlzMy5vblRyYW5zaXRpb25FbmQobm9kZSwgdGltZW91dHMuZXhpdCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgICBzdGF0dXM6IEVYSVRFRFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMzLnByb3BzLm9uRXhpdGVkKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5jYW5jZWxOZXh0Q2FsbGJhY2sgPSBmdW5jdGlvbiBjYW5jZWxOZXh0Q2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMubmV4dENhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB0aGlzLm5leHRDYWxsYmFjay5jYW5jZWwoKTtcbiAgICAgIHRoaXMubmV4dENhbGxiYWNrID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnNhZmVTZXRTdGF0ZSA9IGZ1bmN0aW9uIHNhZmVTZXRTdGF0ZShuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgLy8gVGhpcyBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5LCBidXQgdGhlcmUgYXJlIHdlaXJkIHJhY2UgY29uZGl0aW9ucyB3aXRoXG4gICAgLy8gc2V0U3RhdGUgY2FsbGJhY2tzIGFuZCB1bm1vdW50aW5nIGluIHRlc3RpbmcsIHNvIGFsd2F5cyBtYWtlIHN1cmUgdGhhdFxuICAgIC8vIHdlIGNhbiBjYW5jZWwgYW55IHBlbmRpbmcgc2V0U3RhdGUgY2FsbGJhY2tzIGFmdGVyIHdlIHVubW91bnQuXG4gICAgY2FsbGJhY2sgPSB0aGlzLnNldE5leHRDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUsIGNhbGxiYWNrKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0TmV4dENhbGxiYWNrID0gZnVuY3Rpb24gc2V0TmV4dENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgYWN0aXZlID0gdHJ1ZTtcblxuICAgIHRoaXMubmV4dENhbGxiYWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBfdGhpczQubmV4dENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm5leHRDYWxsYmFjay5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBhY3RpdmUgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMubmV4dENhbGxiYWNrO1xuICB9O1xuXG4gIF9wcm90by5vblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiBvblRyYW5zaXRpb25FbmQobm9kZSwgdGltZW91dCwgaGFuZGxlcikge1xuICAgIHRoaXMuc2V0TmV4dENhbGxiYWNrKGhhbmRsZXIpO1xuXG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmFkZEVuZExpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMucHJvcHMuYWRkRW5kTGlzdGVuZXIobm9kZSwgdGhpcy5uZXh0Q2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5uZXh0Q2FsbGJhY2ssIHRpbWVvdXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMubmV4dENhbGxiYWNrLCAwKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgc3RhdHVzID0gdGhpcy5zdGF0ZS5zdGF0dXM7XG5cbiAgICBpZiAoc3RhdHVzID09PSBVTk1PVU5URUQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGNoaWxkUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiY2hpbGRyZW5cIl0pOyAvLyBmaWx0ZXIgcHJvcHMgZm9yIFRyYW5zdGl0aW9uXG5cblxuICAgIGRlbGV0ZSBjaGlsZFByb3BzLmluO1xuICAgIGRlbGV0ZSBjaGlsZFByb3BzLm1vdW50T25FbnRlcjtcbiAgICBkZWxldGUgY2hpbGRQcm9wcy51bm1vdW50T25FeGl0O1xuICAgIGRlbGV0ZSBjaGlsZFByb3BzLmFwcGVhcjtcbiAgICBkZWxldGUgY2hpbGRQcm9wcy5lbnRlcjtcbiAgICBkZWxldGUgY2hpbGRQcm9wcy5leGl0O1xuICAgIGRlbGV0ZSBjaGlsZFByb3BzLnRpbWVvdXQ7XG4gICAgZGVsZXRlIGNoaWxkUHJvcHMuYWRkRW5kTGlzdGVuZXI7XG4gICAgZGVsZXRlIGNoaWxkUHJvcHMub25FbnRlcjtcbiAgICBkZWxldGUgY2hpbGRQcm9wcy5vbkVudGVyaW5nO1xuICAgIGRlbGV0ZSBjaGlsZFByb3BzLm9uRW50ZXJlZDtcbiAgICBkZWxldGUgY2hpbGRQcm9wcy5vbkV4aXQ7XG4gICAgZGVsZXRlIGNoaWxkUHJvcHMub25FeGl0aW5nO1xuICAgIGRlbGV0ZSBjaGlsZFByb3BzLm9uRXhpdGVkO1xuXG4gICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuKHN0YXR1cywgY2hpbGRQcm9wcyk7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG5cbiAgICByZXR1cm4gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKTtcbiAgfTtcblxuICByZXR1cm4gVHJhbnNpdGlvbjtcbn0oX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50KTtcblxuVHJhbnNpdGlvbi5jb250ZXh0VHlwZXMgPSB7XG4gIHRyYW5zaXRpb25Hcm91cDogUHJvcFR5cGVzLm9iamVjdFxufTtcblRyYW5zaXRpb24uY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHRyYW5zaXRpb25Hcm91cDogZnVuY3Rpb24gdHJhbnNpdGlvbkdyb3VwKCkge31cbn07XG5UcmFuc2l0aW9uLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgLyoqXG4gICAqIEEgYGZ1bmN0aW9uYCBjaGlsZCBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIGEgUmVhY3QgZWxlbWVudC5cbiAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB0aGUgY3VycmVudCB0cmFuc2l0aW9uIHN0YXR1c1xuICAgKiAoJ2VudGVyaW5nJywgJ2VudGVyZWQnLCAnZXhpdGluZycsICdleGl0ZWQnLCAndW5tb3VudGVkJyksIHdoaWNoIGNhbiBiZSB1c2VkXG4gICAqIHRvIGFwcGx5IGNvbnRleHQgc3BlY2lmaWMgcHJvcHMgdG8gYSBjb21wb25lbnQuXG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiA8VHJhbnNpdGlvbiB0aW1lb3V0PXsxNTB9PlxuICAgKiAgIHsoc3RhdHVzKSA9PiAoXG4gICAqICAgICA8TXlDb21wb25lbnQgY2xhc3NOYW1lPXtgZmFkZSBmYWRlLSR7c3RhdHVzfWB9IC8+XG4gICAqICAgKX1cbiAgICogPC9UcmFuc2l0aW9uPlxuICAgKiBgYGBcbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLCBQcm9wVHlwZXMuZWxlbWVudC5pc1JlcXVpcmVkXSkuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogU2hvdyB0aGUgY29tcG9uZW50OyB0cmlnZ2VycyB0aGUgZW50ZXIgb3IgZXhpdCBzdGF0ZXNcbiAgICovXG4gIGluOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQnkgZGVmYXVsdCB0aGUgY2hpbGQgY29tcG9uZW50IGlzIG1vdW50ZWQgaW1tZWRpYXRlbHkgYWxvbmcgd2l0aFxuICAgKiB0aGUgcGFyZW50IGBUcmFuc2l0aW9uYCBjb21wb25lbnQuIElmIHlvdSB3YW50IHRvIFwibGF6eSBtb3VudFwiIHRoZSBjb21wb25lbnQgb24gdGhlXG4gICAqIGZpcnN0IGBpbj17dHJ1ZX1gIHlvdSBjYW4gc2V0IGBtb3VudE9uRW50ZXJgLiBBZnRlciB0aGUgZmlyc3QgZW50ZXIgdHJhbnNpdGlvbiB0aGUgY29tcG9uZW50IHdpbGwgc3RheVxuICAgKiBtb3VudGVkLCBldmVuIG9uIFwiZXhpdGVkXCIsIHVubGVzcyB5b3UgYWxzbyBzcGVjaWZ5IGB1bm1vdW50T25FeGl0YC5cbiAgICovXG4gIG1vdW50T25FbnRlcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQgdGhlIGNoaWxkIGNvbXBvbmVudCBzdGF5cyBtb3VudGVkIGFmdGVyIGl0IHJlYWNoZXMgdGhlIGAnZXhpdGVkJ2Agc3RhdGUuXG4gICAqIFNldCBgdW5tb3VudE9uRXhpdGAgaWYgeW91J2QgcHJlZmVyIHRvIHVubW91bnQgdGhlIGNvbXBvbmVudCBhZnRlciBpdCBmaW5pc2hlcyBleGl0aW5nLlxuICAgKi9cbiAgdW5tb3VudE9uRXhpdDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE5vcm1hbGx5IGEgY29tcG9uZW50IGlzIG5vdCB0cmFuc2l0aW9uZWQgaWYgaXQgaXMgc2hvd24gd2hlbiB0aGUgYDxUcmFuc2l0aW9uPmAgY29tcG9uZW50IG1vdW50cy5cbiAgICogSWYgeW91IHdhbnQgdG8gdHJhbnNpdGlvbiBvbiB0aGUgZmlyc3QgbW91bnQgc2V0IGBhcHBlYXJgIHRvIGB0cnVlYCwgYW5kIHRoZVxuICAgKiBjb21wb25lbnQgd2lsbCB0cmFuc2l0aW9uIGluIGFzIHNvb24gYXMgdGhlIGA8VHJhbnNpdGlvbj5gIG1vdW50cy5cbiAgICpcbiAgICogPiBOb3RlOiB0aGVyZSBhcmUgbm8gc3BlY2lmaWMgXCJhcHBlYXJcIiBzdGF0ZXMuIGBhcHBlYXJgIG9ubHkgYWRkcyBhbiBhZGRpdGlvbmFsIGBlbnRlcmAgdHJhbnNpdGlvbi5cbiAgICovXG4gIGFwcGVhcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGVudGVyIHRyYW5zaXRpb25zLlxuICAgKi9cbiAgZW50ZXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBleGl0IHRyYW5zaXRpb25zLlxuICAgKi9cbiAgZXhpdDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBkdXJhdGlvbiBvZiB0aGUgdHJhbnNpdGlvbiwgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBSZXF1aXJlZCB1bmxlc3MgYGFkZEVuZExpc3RlbmVyYCBpcyBwcm92aWRlZFxuICAgKlxuICAgKiBZb3UgbWF5IHNwZWNpZnkgYSBzaW5nbGUgdGltZW91dCBmb3IgYWxsIHRyYW5zaXRpb25zIGxpa2U6IGB0aW1lb3V0PXs1MDB9YCxcbiAgICogb3IgaW5kaXZpZHVhbGx5IGxpa2U6XG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiB0aW1lb3V0PXt7XG4gICAqICBlbnRlcjogMzAwLFxuICAgKiAgZXhpdDogNTAwLFxuICAgKiB9fVxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge251bWJlciB8IHsgZW50ZXI/OiBudW1iZXIsIGV4aXQ/OiBudW1iZXIgfX1cbiAgICovXG4gIHRpbWVvdXQ6IGZ1bmN0aW9uIHRpbWVvdXQocHJvcHMpIHtcbiAgICB2YXIgcHQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBfUHJvcFR5cGVzLnRpbWVvdXRzU2hhcGUgOiB7fTs7XG4gICAgaWYgKCFwcm9wcy5hZGRFbmRMaXN0ZW5lcikgcHQgPSBwdC5pc1JlcXVpcmVkO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHB0LmFwcGx5KHZvaWQgMCwgW3Byb3BzXS5jb25jYXQoYXJncykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgYSBjdXN0b20gdHJhbnNpdGlvbiBlbmQgdHJpZ2dlci4gQ2FsbGVkIHdpdGggdGhlIHRyYW5zaXRpb25pbmdcbiAgICogRE9NIG5vZGUgYW5kIGEgYGRvbmVgIGNhbGxiYWNrLiBBbGxvd3MgZm9yIG1vcmUgZmluZSBncmFpbmVkIHRyYW5zaXRpb24gZW5kXG4gICAqIGxvZ2ljLiAqKk5vdGU6KiogVGltZW91dHMgYXJlIHN0aWxsIHVzZWQgYXMgYSBmYWxsYmFjayBpZiBwcm92aWRlZC5cbiAgICpcbiAgICogYGBganN4XG4gICAqIGFkZEVuZExpc3RlbmVyPXsobm9kZSwgZG9uZSkgPT4ge1xuICAgKiAgIC8vIHVzZSB0aGUgY3NzIHRyYW5zaXRpb25lbmQgZXZlbnQgdG8gbWFyayB0aGUgZmluaXNoIG9mIGEgdHJhbnNpdGlvblxuICAgKiAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGRvbmUsIGZhbHNlKTtcbiAgICogfX1cbiAgICogYGBgXG4gICAqL1xuICBhZGRFbmRMaXN0ZW5lcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGJlZm9yZSB0aGUgXCJlbnRlcmluZ1wiIHN0YXR1cyBpcyBhcHBsaWVkLiBBbiBleHRyYSBwYXJhbWV0ZXJcbiAgICogYGlzQXBwZWFyaW5nYCBpcyBzdXBwbGllZCB0byBpbmRpY2F0ZSBpZiB0aGUgZW50ZXIgc3RhZ2UgaXMgb2NjdXJyaW5nIG9uIHRoZSBpbml0aWFsIG1vdW50XG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbCkgLT4gdm9pZFxuICAgKi9cbiAgb25FbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHRoZSBcImVudGVyaW5nXCIgc3RhdHVzIGlzIGFwcGxpZWQuIEFuIGV4dHJhIHBhcmFtZXRlclxuICAgKiBgaXNBcHBlYXJpbmdgIGlzIHN1cHBsaWVkIHRvIGluZGljYXRlIGlmIHRoZSBlbnRlciBzdGFnZSBpcyBvY2N1cnJpbmcgb24gdGhlIGluaXRpYWwgbW91bnRcbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKVxuICAgKi9cbiAgb25FbnRlcmluZzogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHRoZSBcImVudGVyZWRcIiBzdGF0dXMgaXMgYXBwbGllZC4gQW4gZXh0cmEgcGFyYW1ldGVyXG4gICAqIGBpc0FwcGVhcmluZ2AgaXMgc3VwcGxpZWQgdG8gaW5kaWNhdGUgaWYgdGhlIGVudGVyIHN0YWdlIGlzIG9jY3VycmluZyBvbiB0aGUgaW5pdGlhbCBtb3VudFxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpIC0+IHZvaWRcbiAgICovXG4gIG9uRW50ZXJlZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGJlZm9yZSB0aGUgXCJleGl0aW5nXCIgc3RhdHVzIGlzIGFwcGxpZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KSAtPiB2b2lkXG4gICAqL1xuICBvbkV4aXQ6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciB0aGUgXCJleGl0aW5nXCIgc3RhdHVzIGlzIGFwcGxpZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KSAtPiB2b2lkXG4gICAqL1xuICBvbkV4aXRpbmc6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciB0aGUgXCJleGl0ZWRcIiBzdGF0dXMgaXMgYXBwbGllZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpIC0+IHZvaWRcbiAgICovXG4gIG9uRXhpdGVkOiBQcm9wVHlwZXMuZnVuYyAvLyBOYW1lIHRoZSBmdW5jdGlvbiBzbyBpdCBpcyBjbGVhcmVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG5cbn0gOiB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cblRyYW5zaXRpb24uZGVmYXVsdFByb3BzID0ge1xuICBpbjogZmFsc2UsXG4gIG1vdW50T25FbnRlcjogZmFsc2UsXG4gIHVubW91bnRPbkV4aXQ6IGZhbHNlLFxuICBhcHBlYXI6IGZhbHNlLFxuICBlbnRlcjogdHJ1ZSxcbiAgZXhpdDogdHJ1ZSxcbiAgb25FbnRlcjogbm9vcCxcbiAgb25FbnRlcmluZzogbm9vcCxcbiAgb25FbnRlcmVkOiBub29wLFxuICBvbkV4aXQ6IG5vb3AsXG4gIG9uRXhpdGluZzogbm9vcCxcbiAgb25FeGl0ZWQ6IG5vb3Bcbn07XG5UcmFuc2l0aW9uLlVOTU9VTlRFRCA9IDA7XG5UcmFuc2l0aW9uLkVYSVRFRCA9IDE7XG5UcmFuc2l0aW9uLkVOVEVSSU5HID0gMjtcblRyYW5zaXRpb24uRU5URVJFRCA9IDM7XG5UcmFuc2l0aW9uLkVYSVRJTkcgPSA0O1xuXG52YXIgX2RlZmF1bHQgPSAoMCwgX3JlYWN0TGlmZWN5Y2xlc0NvbXBhdC5wb2x5ZmlsbCkoVHJhbnNpdGlvbik7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fcmVhY3QtdHJhbnNpdGlvbi1ncm91cEAyLjUuMkByZWFjdC10cmFuc2l0aW9uLWdyb3VwL1RyYW5zaXRpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgLy8gQ2FsbCB0aGlzLmNvbnN0cnVjdG9yLmdEU0ZQIHRvIHN1cHBvcnQgc3ViLWNsYXNzZXMuXG4gIHZhciBzdGF0ZSA9IHRoaXMuY29uc3RydWN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHRoaXMucHJvcHMsIHRoaXMuc3RhdGUpO1xuICBpZiAoc3RhdGUgIT09IG51bGwgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gIC8vIENhbGwgdGhpcy5jb25zdHJ1Y3Rvci5nRFNGUCB0byBzdXBwb3J0IHN1Yi1jbGFzc2VzLlxuICAvLyBVc2UgdGhlIHNldFN0YXRlKCkgdXBkYXRlciB0byBlbnN1cmUgc3RhdGUgaXNuJ3Qgc3RhbGUgaW4gY2VydGFpbiBlZGdlIGNhc2VzLlxuICBmdW5jdGlvbiB1cGRhdGVyKHByZXZTdGF0ZSkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuY29uc3RydWN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcbiAgICByZXR1cm4gc3RhdGUgIT09IG51bGwgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCA/IHN0YXRlIDogbnVsbDtcbiAgfVxuICAvLyBCaW5kaW5nIFwidGhpc1wiIGlzIGltcG9ydGFudCBmb3Igc2hhbGxvdyByZW5kZXJlciBzdXBwb3J0LlxuICB0aGlzLnNldFN0YXRlKHVwZGF0ZXIuYmluZCh0aGlzKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgdHJ5IHtcbiAgICB2YXIgcHJldlByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcHJldlN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB0aGlzLnByb3BzID0gbmV4dFByb3BzO1xuICAgIHRoaXMuc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgdGhpcy5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEZsYWcgPSB0cnVlO1xuICAgIHRoaXMuX19yZWFjdEludGVybmFsU25hcHNob3QgPSB0aGlzLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKFxuICAgICAgcHJldlByb3BzLFxuICAgICAgcHJldlN0YXRlXG4gICAgKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0aGlzLnByb3BzID0gcHJldlByb3BzO1xuICAgIHRoaXMuc3RhdGUgPSBwcmV2U3RhdGU7XG4gIH1cbn1cblxuLy8gUmVhY3QgbWF5IHdhcm4gYWJvdXQgY1dNL2NXUlAvY1dVIG1ldGhvZHMgYmVpbmcgZGVwcmVjYXRlZC5cbi8vIEFkZCBhIGZsYWcgdG8gc3VwcHJlc3MgdGhlc2Ugd2FybmluZ3MgZm9yIHRoaXMgc3BlY2lhbCBjYXNlLlxuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgPSB0cnVlO1xuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nID0gdHJ1ZTtcbmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyA9IHRydWU7XG5cbmZ1bmN0aW9uIHBvbHlmaWxsKENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcblxuICBpZiAoIXByb3RvdHlwZSB8fCAhcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IHBvbHlmaWxsIGNsYXNzIGNvbXBvbmVudHMnKTtcbiAgfVxuXG4gIGlmIChcbiAgICB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBwcm90b3R5cGUuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuIENvbXBvbmVudDtcbiAgfVxuXG4gIC8vIElmIG5ldyBjb21wb25lbnQgQVBJcyBhcmUgZGVmaW5lZCwgXCJ1bnNhZmVcIiBsaWZlY3ljbGVzIHdvbid0IGJlIGNhbGxlZC5cbiAgLy8gRXJyb3IgaWYgYW55IG9mIHRoZXNlIGxpZmVjeWNsZXMgYXJlIHByZXNlbnQsXG4gIC8vIEJlY2F1c2UgdGhleSB3b3VsZCB3b3JrIGRpZmZlcmVudGx5IGJldHdlZW4gb2xkZXIgYW5kIG5ld2VyICgxNi4zKykgdmVyc2lvbnMgb2YgUmVhY3QuXG4gIHZhciBmb3VuZFdpbGxNb3VudE5hbWUgPSBudWxsO1xuICB2YXIgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9IG51bGw7XG4gIHZhciBmb3VuZFdpbGxVcGRhdGVOYW1lID0gbnVsbDtcbiAgaWYgKHR5cGVvZiBwcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm91bmRXaWxsTW91bnROYW1lID0gJ2NvbXBvbmVudFdpbGxNb3VudCc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb3RvdHlwZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm91bmRXaWxsTW91bnROYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm90b3R5cGUuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgfVxuICBpZiAodHlwZW9mIHByb3RvdHlwZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdjb21wb25lbnRXaWxsVXBkYXRlJztcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvdG90eXBlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gIH1cbiAgaWYgKFxuICAgIGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCB8fFxuICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgfHxcbiAgICBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsXG4gICkge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lO1xuICAgIHZhciBuZXdBcGlOYW1lID1cbiAgICAgIHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gJ2dldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpJ1xuICAgICAgICA6ICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpJztcblxuICAgIHRocm93IEVycm9yKFxuICAgICAgJ1Vuc2FmZSBsZWdhY3kgbGlmZWN5Y2xlcyB3aWxsIG5vdCBiZSBjYWxsZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgbmV3IGNvbXBvbmVudCBBUElzLlxcblxcbicgK1xuICAgICAgICBjb21wb25lbnROYW1lICtcbiAgICAgICAgJyB1c2VzICcgK1xuICAgICAgICBuZXdBcGlOYW1lICtcbiAgICAgICAgJyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOicgK1xuICAgICAgICAoZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsID8gJ1xcbiAgJyArIGZvdW5kV2lsbE1vdW50TmFtZSA6ICcnKSArXG4gICAgICAgIChmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsXG4gICAgICAgICAgPyAnXFxuICAnICsgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZVxuICAgICAgICAgIDogJycpICtcbiAgICAgICAgKGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGwgPyAnXFxuICAnICsgZm91bmRXaWxsVXBkYXRlTmFtZSA6ICcnKSArXG4gICAgICAgICdcXG5cXG5UaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vZmIubWUvcmVhY3QtYXN5bmMtY29tcG9uZW50LWxpZmVjeWNsZS1ob29rcydcbiAgICApO1xuICB9XG5cbiAgLy8gUmVhY3QgPD0gMTYuMiBkb2VzIG5vdCBzdXBwb3J0IHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuXG4gIC8vIEFzIGEgd29ya2Fyb3VuZCwgdXNlIGNXTSBhbmQgY1dSUCB0byBpbnZva2UgdGhlIG5ldyBzdGF0aWMgbGlmZWN5Y2xlLlxuICAvLyBOZXdlciB2ZXJzaW9ucyBvZiBSZWFjdCB3aWxsIGlnbm9yZSB0aGVzZSBsaWZlY3ljbGVzIGlmIGdEU0ZQIGV4aXN0cy5cbiAgaWYgKHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGNvbXBvbmVudFdpbGxNb3VudDtcbiAgICBwcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM7XG4gIH1cblxuICAvLyBSZWFjdCA8PSAxNi4yIGRvZXMgbm90IHN1cHBvcnQgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuXG4gIC8vIEFzIGEgd29ya2Fyb3VuZCwgdXNlIGNXVSB0byBpbnZva2UgdGhlIG5ldyBsaWZlY3ljbGUuXG4gIC8vIE5ld2VyIHZlcnNpb25zIG9mIFJlYWN0IHdpbGwgaWdub3JlIHRoYXQgbGlmZWN5Y2xlIGlmIGdTQlUgZXhpc3RzLlxuICBpZiAodHlwZW9mIHByb3RvdHlwZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICh0eXBlb2YgcHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2Fubm90IHBvbHlmaWxsIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgZm9yIGNvbXBvbmVudHMgdGhhdCBkbyBub3QgZGVmaW5lIGNvbXBvbmVudERpZFVwZGF0ZSgpIG9uIHRoZSBwcm90b3R5cGUnXG4gICAgICApO1xuICAgIH1cblxuICAgIHByb3RvdHlwZS5jb21wb25lbnRXaWxsVXBkYXRlID0gY29tcG9uZW50V2lsbFVwZGF0ZTtcblxuICAgIHZhciBjb21wb25lbnREaWRVcGRhdGUgPSBwcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlO1xuXG4gICAgcHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZVBvbHlmaWxsKFxuICAgICAgcHJldlByb3BzLFxuICAgICAgcHJldlN0YXRlLFxuICAgICAgbWF5YmVTbmFwc2hvdFxuICAgICkge1xuICAgICAgLy8gMTYuMysgd2lsbCBub3QgZXhlY3V0ZSBvdXIgd2lsbC11cGRhdGUgbWV0aG9kO1xuICAgICAgLy8gSXQgd2lsbCBwYXNzIGEgc25hcHNob3QgdmFsdWUgdG8gZGlkLXVwZGF0ZSB0aG91Z2guXG4gICAgICAvLyBPbGRlciB2ZXJzaW9ucyB3aWxsIHJlcXVpcmUgb3VyIHBvbHlmaWxsZWQgd2lsbC11cGRhdGUgdmFsdWUuXG4gICAgICAvLyBXZSBuZWVkIHRvIGhhbmRsZSBib3RoIGNhc2VzLCBidXQgY2FuJ3QganVzdCBjaGVjayBmb3IgdGhlIHByZXNlbmNlIG9mIFwibWF5YmVTbmFwc2hvdFwiLFxuICAgICAgLy8gQmVjYXVzZSBmb3IgPD0gMTUueCB2ZXJzaW9ucyB0aGlzIG1pZ2h0IGJlIGEgXCJwcmV2Q29udGV4dFwiIG9iamVjdC5cbiAgICAgIC8vIFdlIGFsc28gY2FuJ3QganVzdCBjaGVjayBcIl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90XCIsXG4gICAgICAvLyBCZWNhdXNlIGdldC1zbmFwc2hvdCBtaWdodCByZXR1cm4gYSBmYWxzeSB2YWx1ZS5cbiAgICAgIC8vIFNvIGNoZWNrIGZvciB0aGUgZXhwbGljaXQgX19yZWFjdEludGVybmFsU25hcHNob3RGbGFnIGZsYWcgdG8gZGV0ZXJtaW5lIGJlaGF2aW9yLlxuICAgICAgdmFyIHNuYXBzaG90ID0gdGhpcy5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEZsYWdcbiAgICAgICAgPyB0aGlzLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90XG4gICAgICAgIDogbWF5YmVTbmFwc2hvdDtcblxuICAgICAgY29tcG9uZW50RGlkVXBkYXRlLmNhbGwodGhpcywgcHJldlByb3BzLCBwcmV2U3RhdGUsIHNuYXBzaG90KTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIENvbXBvbmVudDtcbn1cblxuZXhwb3J0IHsgcG9seWZpbGwgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXRAMy4wLjRAcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQvcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQuZXMuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudHJhbnNpdGlvblRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbmV4cG9ydHMuY2xhc3NOYW1lc1NoYXBlID0gZXhwb3J0cy50aW1lb3V0c1NoYXBlID0gdm9pZCAwO1xuXG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uVGltZW91dCh0cmFuc2l0aW9uVHlwZSkge1xuICB2YXIgdGltZW91dFByb3BOYW1lID0gJ3RyYW5zaXRpb24nICsgdHJhbnNpdGlvblR5cGUgKyAnVGltZW91dCc7XG4gIHZhciBlbmFibGVkUHJvcE5hbWUgPSAndHJhbnNpdGlvbicgKyB0cmFuc2l0aW9uVHlwZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwcm9wcykge1xuICAgIC8vIElmIHRoZSB0cmFuc2l0aW9uIGlzIGVuYWJsZWRcbiAgICBpZiAocHJvcHNbZW5hYmxlZFByb3BOYW1lXSkge1xuICAgICAgLy8gSWYgbm8gdGltZW91dCBkdXJhdGlvbiBpcyBwcm92aWRlZFxuICAgICAgaWYgKHByb3BzW3RpbWVvdXRQcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKHRpbWVvdXRQcm9wTmFtZSArICcgd2FzblxcJ3Qgc3VwcGxpZWQgdG8gQ1NTVHJhbnNpdGlvbkdyb3VwOiAnICsgJ3RoaXMgY2FuIGNhdXNlIHVucmVsaWFibGUgYW5pbWF0aW9ucyBhbmQgd29uXFwndCBiZSBzdXBwb3J0ZWQgaW4gJyArICdhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJlYWN0LiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWFuaW1hdGlvbi10cmFuc2l0aW9uLWdyb3VwLXRpbWVvdXQgZm9yIG1vcmUgJyArICdpbmZvcm1hdGlvbi4nKTsgLy8gSWYgdGhlIGR1cmF0aW9uIGlzbid0IGEgbnVtYmVyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9wc1t0aW1lb3V0UHJvcE5hbWVdICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKHRpbWVvdXRQcm9wTmFtZSArICcgbXVzdCBiZSBhIG51bWJlciAoaW4gbWlsbGlzZWNvbmRzKScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xufVxuXG52YXIgdGltZW91dHNTaGFwZSA9IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsIF9wcm9wVHlwZXMuZGVmYXVsdC5zaGFwZSh7XG4gIGVudGVyOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICBleGl0OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyXG59KS5pc1JlcXVpcmVkXSk7XG5cbmV4cG9ydHMudGltZW91dHNTaGFwZSA9IHRpbWVvdXRzU2hhcGU7XG5cbnZhciBjbGFzc05hbWVzU2hhcGUgPSBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLCBfcHJvcFR5cGVzLmRlZmF1bHQuc2hhcGUoe1xuICBlbnRlcjogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgZXhpdDogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgYWN0aXZlOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nXG59KSwgX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgZW50ZXI6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIGVudGVyRG9uZTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgZW50ZXJBY3RpdmU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIGV4aXQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIGV4aXREb25lOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICBleGl0QWN0aXZlOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nXG59KV0pO1xuXG5leHBvcnRzLmNsYXNzTmFtZXNTaGFwZSA9IGNsYXNzTmFtZXNTaGFwZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX3JlYWN0LXRyYW5zaXRpb24tZ3JvdXBAMi41LjJAcmVhY3QtdHJhbnNpdGlvbi1ncm91cC91dGlscy9Qcm9wVHlwZXMuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcblxudmFyIF9yZWFjdExpZmVjeWNsZXNDb21wYXQgPSByZXF1aXJlKFwicmVhY3QtbGlmZWN5Y2xlcy1jb21wYXRcIik7XG5cbnZhciBfQ2hpbGRNYXBwaW5nID0gcmVxdWlyZShcIi4vdXRpbHMvQ2hpbGRNYXBwaW5nXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxudmFyIHZhbHVlcyA9IE9iamVjdC52YWx1ZXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gb2JqW2tdO1xuICB9KTtcbn07XG5cbnZhciBwcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIC8qKlxuICAgKiBgPFRyYW5zaXRpb25Hcm91cD5gIHJlbmRlcnMgYSBgPGRpdj5gIGJ5IGRlZmF1bHQuIFlvdSBjYW4gY2hhbmdlIHRoaXNcbiAgICogYmVoYXZpb3IgYnkgcHJvdmlkaW5nIGEgYGNvbXBvbmVudGAgcHJvcC5cbiAgICogSWYgeW91IHVzZSBSZWFjdCB2MTYrIGFuZCB3b3VsZCBsaWtlIHRvIGF2b2lkIGEgd3JhcHBpbmcgYDxkaXY+YCBlbGVtZW50XG4gICAqIHlvdSBjYW4gcGFzcyBpbiBgY29tcG9uZW50PXtudWxsfWAuIFRoaXMgaXMgdXNlZnVsIGlmIHRoZSB3cmFwcGluZyBkaXZcbiAgICogYm9ya3MgeW91ciBjc3Mgc3R5bGVzLlxuICAgKi9cbiAgY29tcG9uZW50OiBfcHJvcFR5cGVzLmRlZmF1bHQuYW55LFxuXG4gIC8qKlxuICAgKiBBIHNldCBvZiBgPFRyYW5zaXRpb24+YCBjb21wb25lbnRzLCB0aGF0IGFyZSB0b2dnbGVkIGBpbmAgYW5kIG91dCBhcyB0aGV5XG4gICAqIGxlYXZlLiB0aGUgYDxUcmFuc2l0aW9uR3JvdXA+YCB3aWxsIGluamVjdCBzcGVjaWZpYyB0cmFuc2l0aW9uIHByb3BzLCBzb1xuICAgKiByZW1lbWJlciB0byBzcHJlYWQgdGhlbSB0aHJvdWdoIGlmIHlvdSBhcmUgd3JhcHBpbmcgdGhlIGA8VHJhbnNpdGlvbj5gIGFzXG4gICAqIHdpdGggb3VyIGA8RmFkZT5gIGV4YW1wbGUuXG4gICAqL1xuICBjaGlsZHJlbjogX3Byb3BUeXBlcy5kZWZhdWx0Lm5vZGUsXG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgcHJvcCB0aGF0IGVuYWJsZXMgb3IgZGlzYWJsZXMgYXBwZWFyIGFuaW1hdGlvbnNcbiAgICogZm9yIGFsbCBjaGlsZHJlbi4gTm90ZSB0aGF0IHNwZWNpZnlpbmcgdGhpcyB3aWxsIG92ZXJyaWRlIGFueSBkZWZhdWx0cyBzZXRcbiAgICogb24gaW5kaXZpZHVhbCBjaGlsZHJlbiBUcmFuc2l0aW9ucy5cbiAgICovXG4gIGFwcGVhcjogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgcHJvcCB0aGF0IGVuYWJsZXMgb3IgZGlzYWJsZXMgZW50ZXIgYW5pbWF0aW9uc1xuICAgKiBmb3IgYWxsIGNoaWxkcmVuLiBOb3RlIHRoYXQgc3BlY2lmeWluZyB0aGlzIHdpbGwgb3ZlcnJpZGUgYW55IGRlZmF1bHRzIHNldFxuICAgKiBvbiBpbmRpdmlkdWFsIGNoaWxkcmVuIFRyYW5zaXRpb25zLlxuICAgKi9cbiAgZW50ZXI6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBBIGNvbnZlbmllbmNlIHByb3AgdGhhdCBlbmFibGVzIG9yIGRpc2FibGVzIGV4aXQgYW5pbWF0aW9uc1xuICAgKiBmb3IgYWxsIGNoaWxkcmVuLiBOb3RlIHRoYXQgc3BlY2lmeWluZyB0aGlzIHdpbGwgb3ZlcnJpZGUgYW55IGRlZmF1bHRzIHNldFxuICAgKiBvbiBpbmRpdmlkdWFsIGNoaWxkcmVuIFRyYW5zaXRpb25zLlxuICAgKi9cbiAgZXhpdDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIFlvdSBtYXkgbmVlZCB0byBhcHBseSByZWFjdGl2ZSB1cGRhdGVzIHRvIGEgY2hpbGQgYXMgaXQgaXMgZXhpdGluZy5cbiAgICogVGhpcyBpcyBnZW5lcmFsbHkgZG9uZSBieSB1c2luZyBgY2xvbmVFbGVtZW50YCBob3dldmVyIGluIHRoZSBjYXNlIG9mIGFuIGV4aXRpbmdcbiAgICogY2hpbGQgdGhlIGVsZW1lbnQgaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkIGFuZCBub3QgYWNjZXNzaWJsZSB0byB0aGUgY29uc3VtZXIuXG4gICAqXG4gICAqIElmIHlvdSBkbyBuZWVkIHRvIHVwZGF0ZSBhIGNoaWxkIGFzIGl0IGxlYXZlcyB5b3UgY2FuIHByb3ZpZGUgYSBgY2hpbGRGYWN0b3J5YFxuICAgKiB0byB3cmFwIGV2ZXJ5IGNoaWxkLCBldmVuIHRoZSBvbmVzIHRoYXQgYXJlIGxlYXZpbmcuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKGNoaWxkOiBSZWFjdEVsZW1lbnQpIC0+IFJlYWN0RWxlbWVudFxuICAgKi9cbiAgY2hpbGRGYWN0b3J5OiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuY1xufSA6IHt9OztcbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGNvbXBvbmVudDogJ2RpdicsXG4gIGNoaWxkRmFjdG9yeTogZnVuY3Rpb24gY2hpbGRGYWN0b3J5KGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYDxUcmFuc2l0aW9uR3JvdXA+YCBjb21wb25lbnQgbWFuYWdlcyBhIHNldCBvZiB0cmFuc2l0aW9uIGNvbXBvbmVudHNcbiAgICogKGA8VHJhbnNpdGlvbj5gIGFuZCBgPENTU1RyYW5zaXRpb24+YCkgaW4gYSBsaXN0LiBMaWtlIHdpdGggdGhlIHRyYW5zaXRpb25cbiAgICogY29tcG9uZW50cywgYDxUcmFuc2l0aW9uR3JvdXA+YCBpcyBhIHN0YXRlIG1hY2hpbmUgZm9yIG1hbmFnaW5nIHRoZSBtb3VudGluZ1xuICAgKiBhbmQgdW5tb3VudGluZyBvZiBjb21wb25lbnRzIG92ZXIgdGltZS5cbiAgICpcbiAgICogQ29uc2lkZXIgdGhlIGV4YW1wbGUgYmVsb3cuIEFzIGl0ZW1zIGFyZSByZW1vdmVkIG9yIGFkZGVkIHRvIHRoZSBUb2RvTGlzdCB0aGVcbiAgICogYGluYCBwcm9wIGlzIHRvZ2dsZWQgYXV0b21hdGljYWxseSBieSB0aGUgYDxUcmFuc2l0aW9uR3JvdXA+YC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGA8VHJhbnNpdGlvbkdyb3VwPmAgIGRvZXMgbm90IGRlZmluZSBhbnkgYW5pbWF0aW9uIGJlaGF2aW9yIVxuICAgKiBFeGFjdGx5IF9ob3dfIGEgbGlzdCBpdGVtIGFuaW1hdGVzIGlzIHVwIHRvIHRoZSBpbmRpdmlkdWFsIHRyYW5zaXRpb25cbiAgICogY29tcG9uZW50LiBUaGlzIG1lYW5zIHlvdSBjYW4gbWl4IGFuZCBtYXRjaCBhbmltYXRpb25zIGFjcm9zcyBkaWZmZXJlbnQgbGlzdFxuICAgKiBpdGVtcy5cbiAgICovXG5cbn07XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoVHJhbnNpdGlvbkdyb3VwLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUcmFuc2l0aW9uR3JvdXAocHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkgfHwgdGhpcztcblxuICAgIHZhciBoYW5kbGVFeGl0ZWQgPSBfdGhpcy5oYW5kbGVFeGl0ZWQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7IC8vIEluaXRpYWwgY2hpbGRyZW4gc2hvdWxkIGFsbCBiZSBlbnRlcmluZywgZGVwZW5kZW50IG9uIGFwcGVhclxuXG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGhhbmRsZUV4aXRlZDogaGFuZGxlRXhpdGVkLFxuICAgICAgZmlyc3RSZW5kZXI6IHRydWVcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUcmFuc2l0aW9uR3JvdXAucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zaXRpb25Hcm91cDoge1xuICAgICAgICBpc01vdW50aW5nOiAhdGhpcy5hcHBlYXJlZFxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5hcHBlYXJlZCA9IHRydWU7XG4gICAgdGhpcy5tb3VudGVkID0gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgfTtcblxuICBUcmFuc2l0aW9uR3JvdXAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgX3JlZikge1xuICAgIHZhciBwcmV2Q2hpbGRNYXBwaW5nID0gX3JlZi5jaGlsZHJlbixcbiAgICAgICAgaGFuZGxlRXhpdGVkID0gX3JlZi5oYW5kbGVFeGl0ZWQsXG4gICAgICAgIGZpcnN0UmVuZGVyID0gX3JlZi5maXJzdFJlbmRlcjtcbiAgICByZXR1cm4ge1xuICAgICAgY2hpbGRyZW46IGZpcnN0UmVuZGVyID8gKDAsIF9DaGlsZE1hcHBpbmcuZ2V0SW5pdGlhbENoaWxkTWFwcGluZykobmV4dFByb3BzLCBoYW5kbGVFeGl0ZWQpIDogKDAsIF9DaGlsZE1hcHBpbmcuZ2V0TmV4dENoaWxkTWFwcGluZykobmV4dFByb3BzLCBwcmV2Q2hpbGRNYXBwaW5nLCBoYW5kbGVFeGl0ZWQpLFxuICAgICAgZmlyc3RSZW5kZXI6IGZhbHNlXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlRXhpdGVkID0gZnVuY3Rpb24gaGFuZGxlRXhpdGVkKGNoaWxkLCBub2RlKSB7XG4gICAgdmFyIGN1cnJlbnRDaGlsZE1hcHBpbmcgPSAoMCwgX0NoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcpKHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICAgIGlmIChjaGlsZC5rZXkgaW4gY3VycmVudENoaWxkTWFwcGluZykgcmV0dXJuO1xuXG4gICAgaWYgKGNoaWxkLnByb3BzLm9uRXhpdGVkKSB7XG4gICAgICBjaGlsZC5wcm9wcy5vbkV4aXRlZChub2RlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tb3VudGVkKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBfZXh0ZW5kcyh7fSwgc3RhdGUuY2hpbGRyZW4pO1xuXG4gICAgICAgIGRlbGV0ZSBjaGlsZHJlbltjaGlsZC5rZXldO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgQ29tcG9uZW50ID0gX3RoaXMkcHJvcHMuY29tcG9uZW50LFxuICAgICAgICBjaGlsZEZhY3RvcnkgPSBfdGhpcyRwcm9wcy5jaGlsZEZhY3RvcnksXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIFtcImNvbXBvbmVudFwiLCBcImNoaWxkRmFjdG9yeVwiXSk7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB2YWx1ZXModGhpcy5zdGF0ZS5jaGlsZHJlbikubWFwKGNoaWxkRmFjdG9yeSk7XG4gICAgZGVsZXRlIHByb3BzLmFwcGVhcjtcbiAgICBkZWxldGUgcHJvcHMuZW50ZXI7XG4gICAgZGVsZXRlIHByb3BzLmV4aXQ7XG5cbiAgICBpZiAoQ29tcG9uZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBwcm9wcywgY2hpbGRyZW4pO1xuICB9O1xuXG4gIHJldHVybiBUcmFuc2l0aW9uR3JvdXA7XG59KF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCk7XG5cblRyYW5zaXRpb25Hcm91cC5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgdHJhbnNpdGlvbkdyb3VwOiBfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5UcmFuc2l0aW9uR3JvdXAucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gcHJvcFR5cGVzIDoge307XG5UcmFuc2l0aW9uR3JvdXAuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG52YXIgX2RlZmF1bHQgPSAoMCwgX3JlYWN0TGlmZWN5Y2xlc0NvbXBhdC5wb2x5ZmlsbCkoVHJhbnNpdGlvbkdyb3VwKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fcmVhY3QtdHJhbnNpdGlvbi1ncm91cEAyLjUuMkByZWFjdC10cmFuc2l0aW9uLWdyb3VwL1RyYW5zaXRpb25Hcm91cC5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmaW5kRE9NTm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi4vLi4vaWNvbic7XG5pbXBvcnQgT3ZlcmxheSBmcm9tICcuLi8uLi9vdmVybGF5JztcbmltcG9ydCB7IGZ1bmMsIG9iaiwgZG9tIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgSXRlbSBmcm9tICcuL2l0ZW0nO1xuaW1wb3J0IFNlbGVjdGFibGVJdGVtIGZyb20gJy4vc2VsZWN0YWJsZS1pdGVtJztcblxuY29uc3QgeyBiaW5kQ3R4IH0gPSBmdW5jO1xuY29uc3QgeyBzZXRTdHlsZSB9ID0gZG9tO1xuY29uc3QgUG9wdXAgPSBPdmVybGF5LlBvcHVwO1xuXG4vKipcbiAqIE1lbnUuUG9wdXBJdGVtXG4gKiBAb3JkZXIgMlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3B1cEl0ZW0gZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBtZW51Q2hpbGRUeXBlID0gJ3N1Ym1lbnUnO1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgX2tleTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcm9vdDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgbGV2ZWw6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGhhc1N1Yk1lbnU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBydGw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBzZWxlY3RhYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOagh+etvuWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ5by55bGC5YaF5a65XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgdHJpZ2dlclR5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2NsaWNrJywgJ2hvdmVyJ10pLFxuICAgICAgICBhbGlnbjogUHJvcFR5cGVzLm9uZU9mKFsnb3V0c2lkZScsICdmb2xsb3cnXSksXG4gICAgICAgIGF1dG9XaWR0aDogUHJvcFR5cGVzLmJvb2xcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgc2VsZWN0YWJsZTogZmFsc2VcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIGJpbmRDdHgodGhpcywgWyAnaGFuZGxlT3BlbicsICdoYW5kbGVQb3B1cE9wZW4nLCAnaGFuZGxlUG9wdXBDbG9zZScsICdnZXRQb3B1cCddKTtcbiAgICB9XG5cbiAgICBnZXRQb3B1cChyZWYpIHtcbiAgICAgICAgdGhpcy5wb3B1cCA9IHJlZjtcbiAgICB9XG5cbiAgICBnZXRPcGVuKCkge1xuICAgICAgICBjb25zdCB7IF9rZXksIHJvb3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgb3BlbktleXMgfSA9IHJvb3Quc3RhdGU7XG5cbiAgICAgICAgcmV0dXJuIG9wZW5LZXlzLmluZGV4T2YoX2tleSkgPiAtMTtcbiAgICB9XG5cbiAgICBnZXRQb3B1cFByb3BzKCkge1xuICAgICAgICBsZXQgeyBwb3B1cFByb3BzIH0gPSB0aGlzLnByb3BzLnJvb3QucHJvcHM7XG4gICAgICAgIGlmICh0eXBlb2YgcG9wdXBQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcG9wdXBQcm9wcyA9IHBvcHVwUHJvcHModGhpcy5wcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcHVwUHJvcHM7XG4gICAgfVxuXG4gICAgaGFuZGxlT3BlbihvcGVuLCB0cmlnZ2VyVHlwZSwgZSkge1xuICAgICAgICBjb25zdCB7IF9rZXksIHJvb3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJvb3QuaGFuZGxlT3Blbihfa2V5LCBvcGVuLCB0cmlnZ2VyVHlwZSwgZSk7XG5cbiAgICAgICAgY29uc3QgcG9wdXBQcm9wcyA9IHRoaXMucG9wdXBQcm9wcztcbiAgICAgICAgcG9wdXBQcm9wcy5vblZpc2libGVDaGFuZ2UgJiYgcG9wdXBQcm9wcy5vblZpc2libGVDaGFuZ2Uob3BlbiwgdHJpZ2dlclR5cGUsIGUpO1xuICAgIH1cblxuICAgIGhhbmRsZVBvcHVwT3BlbigpIHtcbiAgICAgICAgY29uc3QgeyByb290LCBsZXZlbCwgYWxpZ24sIGF1dG9XaWR0aCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBwb3B1cEF1dG9XaWR0aDogcm9vdFBvcHVwQXV0b1dpZHRoLCBwb3B1cEFsaWduOiByb290UG9wdXBBbGlnbiwgZGlyZWN0aW9uIH0gPSByb290LnByb3BzO1xuICAgICAgICBjb25zdCBwb3B1cEFsaWduID0gYWxpZ24gfHwgcm9vdFBvcHVwQWxpZ247XG4gICAgICAgIGNvbnN0IHBvcHVwQXV0b1dpZHRoID0gJ2F1dG9XaWR0aCcgaW4gdGhpcy5wcm9wcyA/IGF1dG9XaWR0aCA6IHJvb3RQb3B1cEF1dG9XaWR0aDtcbiAgICAgICAgY29uc3QgaXRlbU5vZGUgPSBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgICAgY29uc3QgbWVudU5vZGUgPSBpdGVtTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB0aGlzLnBvcHVwTm9kZSA9IHRoaXMucG9wdXAuZ2V0SW5zdGFuY2UoKS5vdmVybGF5LmdldEluc3RhbmNlKCkuZ2V0Q29udGVudE5vZGUoKTtcbiAgICAgICAgcm9vdC5wb3B1cE5vZGVzLnB1c2godGhpcy5wb3B1cE5vZGUpO1xuXG4gICAgICAgIGlmIChwb3B1cEF1dG9XaWR0aCkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IGRpcmVjdGlvbiA9PT0gJ2hveicgJiYgbGV2ZWwgPT09IDEgPyBpdGVtTm9kZSA6IG1lbnVOb2RlO1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0Tm9kZS5vZmZzZXRXaWR0aCA+IHRoaXMucG9wdXBOb2RlLm9mZnNldFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgc2V0U3R5bGUodGhpcy5wb3B1cE5vZGUsICd3aWR0aCcsIGAke3RhcmdldE5vZGUub2Zmc2V0V2lkdGh9cHhgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wdXBBbGlnbiA9PT0gJ291dHNpZGUnICYmICEoZGlyZWN0aW9uID09PSAnaG96JyAmJiBsZXZlbCA9PT0gMSkpIHtcbiAgICAgICAgICAgIHNldFN0eWxlKHRoaXMucG9wdXBOb2RlLCAnaGVpZ2h0JywgYCR7bWVudU5vZGUub2Zmc2V0SGVpZ2h0fXB4YCk7XG4gICAgICAgICAgICBzZXRTdHlsZSh0aGlzLnBvcHVwTm9kZSwgJ292ZXJmbG93LXknLCAnc2Nyb2xsJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlQ2xhc3ModGhpcy5wb3B1cE5vZGUsIGAke3ByZWZpeH1oaWRlYCk7XG5cbiAgICAgICAgY29uc3QgcG9wdXBQcm9wcyA9IHRoaXMucG9wdXBQcm9wcztcbiAgICAgICAgcG9wdXBQcm9wcy5vbk9wZW4gJiYgcG9wdXBQcm9wcy5vbk9wZW4oKTtcbiAgICB9XG5cbiAgICBoYW5kbGVQb3B1cENsb3NlKCkge1xuICAgICAgICBjb25zdCB7IHJvb3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHBvcHVwTm9kZXMgPSByb290LnBvcHVwTm9kZXM7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcG9wdXBOb2Rlcy5pbmRleE9mKHRoaXMucG9wdXBOb2RlKTtcbiAgICAgICAgaW5kZXggPiAtMSAmJiBwb3B1cE5vZGVzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgY29uc3QgcG9wdXBQcm9wcyA9IHRoaXMucG9wdXBQcm9wcztcbiAgICAgICAgcG9wdXBQcm9wcy5vbkNsb3NlICYmIHBvcHVwUHJvcHMub25DbG9zZSgpO1xuICAgIH1cblxuICAgIHJlbmRlckl0ZW0oc2VsZWN0YWJsZSwgY2hpbGRyZW4sIG90aGVycykge1xuICAgICAgICBjb25zdCB7IF9rZXksIHJvb3QsIGxldmVsLCBsYWJlbCwgY2xhc3NOYW1lIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHByZWZpeCB9ID0gcm9vdC5wcm9wcztcbiAgICAgICAgY29uc3QgTmV3SXRlbSA9IHNlbGVjdGFibGUgPyBTZWxlY3RhYmxlSXRlbSA6IEl0ZW07XG4gICAgICAgIGNvbnN0IG9wZW4gPSB0aGlzLmdldE9wZW4oKTtcblxuICAgICAgICBjb25zdCBpdGVtUHJvcHMgPSB7XG4gICAgICAgICAgICAnYXJpYS1oYXNwb3B1cCc6IHRydWUsXG4gICAgICAgICAgICAnYXJpYS1leHBhbmRlZCc6IG9wZW4sXG4gICAgICAgICAgICBfa2V5LFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgICAgdHlwZTogJ3N1Ym1lbnUnXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICBpdGVtUHJvcHMuY2xhc3NOYW1lID0gY3goe1xuICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9b3BlbmVkYF06IHRydWUsXG4gICAgICAgICAgICAgICAgW2NsYXNzTmFtZV06ICEhY2xhc3NOYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW1Qcm9wcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPE5ld0l0ZW0gey4uLml0ZW1Qcm9wc30gey4uLm90aGVyc30+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtgJHtwcmVmaXh9bWVudS1pdGVtLXRleHRgfT57bGFiZWx9PC9zcGFuPlxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgIDwvTmV3SXRlbT5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXJQb3B1cCh0cmlnZ2VyLCB0cmlnZ2VyVHlwZSwgcG9zaXRpb25Qcm9wcywgY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgeyByb290LCBsZXZlbCwgc2VsZWN0YWJsZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBkaXJlY3Rpb24gfSA9IHJvb3QucHJvcHM7XG4gICAgICAgIHRoaXMucG9wdXBQcm9wcyA9IHRoaXMuZ2V0UG9wdXBQcm9wcygpO1xuICAgICAgICBjb25zdCBvcGVuID0gdGhpcy5nZXRPcGVuKCk7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2hveicgJiYgbGV2ZWwgPT09IDEgJiYgc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgcG9zaXRpb25Qcm9wcy50YXJnZXQgPSAoKSA9PiBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8UG9wdXAgcmVmPXt0aGlzLmdldFBvcHVwfVxuICAgICAgICAgICAgICAgIHsuLi5wb3NpdGlvblByb3BzfVxuICAgICAgICAgICAgICAgIHsuLi50aGlzLnBvcHVwUHJvcHN9XG4gICAgICAgICAgICAgICAgY2FuQ2xvc2VCeUVzYz17ZmFsc2V9XG4gICAgICAgICAgICAgICAgdHJpZ2dlcj17dHJpZ2dlcn1cbiAgICAgICAgICAgICAgICB0cmlnZ2VyVHlwZT17dHJpZ2dlclR5cGV9XG4gICAgICAgICAgICAgICAgdmlzaWJsZT17b3Blbn1cbiAgICAgICAgICAgICAgICBvblZpc2libGVDaGFuZ2U9e3RoaXMuaGFuZGxlT3Blbn1cbiAgICAgICAgICAgICAgICBvbk9wZW49e3RoaXMuaGFuZGxlUG9wdXBPcGVufVxuICAgICAgICAgICAgICAgIG9uQ2xvc2U9e3RoaXMuaGFuZGxlUG9wdXBDbG9zZX0+XG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgPC9Qb3B1cD5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcm9vdCwgbGV2ZWwsIGhhc1N1Yk1lbnUsIHNlbGVjdGFibGU6IHNlbGVjdGFibGVGcm9tUHJvcHMsIGNoaWxkcmVuLCB0cmlnZ2VyVHlwZSwgYWxpZ24sIHJ0bCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gb2JqLnBpY2tPdGhlcnMoT2JqZWN0LmtleXMoUG9wdXBJdGVtLnByb3BUeXBlcyksIHRoaXMucHJvcHMpO1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgc2VsZWN0TW9kZSwgZGlyZWN0aW9uLCBwb3B1cEFsaWduOiByb290UG9wdXBBbGlnbiwgdHJpZ2dlclR5cGU6IHJvb3RUcmlnZ2VyVHlwZSB9ID0gcm9vdC5wcm9wcztcbiAgICAgICAgY29uc3QgcG9wdXBBbGlnbiA9IGFsaWduIHx8IHJvb3RQb3B1cEFsaWduO1xuICAgICAgICBjb25zdCBuZXdUcmlnZ2VyVHlwZSA9IHRyaWdnZXJUeXBlIHx8IChoYXNTdWJNZW51ID8gcm9vdFRyaWdnZXJUeXBlIDogJ2hvdmVyJyk7XG4gICAgICAgIGNvbnN0IG5ld0NoaWxkcmVuID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlblswXSA6IGNoaWxkcmVuO1xuICAgICAgICAvLyBsZXQgbmV3Q2hpbGRyZW4gPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuWzBdIDogY2hpbGRyZW47XG4gICAgICAgIC8vIG5ld0NoaWxkcmVuID0gY2xvbmVFbGVtZW50KG5ld0NoaWxkcmVuLCB7XG4gICAgICAgIC8vICAgICBjbGFzc05hbWU6IGN4KHtcbiAgICAgICAgLy8gICAgICAgICBbYCR7cHJlZml4fW1lbnUtcG9wdXAtY29udGVudGBdOiB0cnVlLFxuICAgICAgICAvLyAgICAgICAgIFtuZXdDaGlsZHJlbi5wcm9wcy5jbGFzc05hbWVdOiAhIW5ld0NoaWxkcmVuLnByb3BzLmNsYXNzTmFtZSxcbiAgICAgICAgLy8gICAgICAgICBbYCR7cHJlZml4fWhpZGVgXTogcG9wdXBBdXRvV2lkdGggfHwgcG9wdXBBbGlnbiA9PT0gJ291dHNpZGUnXG4gICAgICAgIC8vICAgICB9KVxuICAgICAgICAvLyB9KTtcbiAgICAgICAgY29uc3Qgc2VsZWN0YWJsZSA9IHNlbGVjdE1vZGUgJiYgc2VsZWN0YWJsZUZyb21Qcm9wcztcbiAgICAgICAgY29uc3QgdHJpZ2dlcklzSWNvbiA9IHNlbGVjdGFibGUgJiYgbmV3VHJpZ2dlclR5cGUgPT09ICdjbGljayc7XG4gICAgICAgIGNvbnN0IG9wZW4gPSB0aGlzLmdldE9wZW4oKTtcblxuICAgICAgICBjb25zdCBwb3NpdGlvblByb3BzID0ge307XG4gICAgICAgIGxldCBhcnJvd1Byb3BzO1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdob3onICYmIGxldmVsID09PSAxKSB7XG4gICAgICAgICAgICBwb3NpdGlvblByb3BzLmFsaWduID0gJ3RsIGJsJztcbiAgICAgICAgICAgIHBvc2l0aW9uUHJvcHMub2Zmc2V0ID0gWzAsIDBdO1xuXG4gICAgICAgICAgICBhcnJvd1Byb3BzID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhcnJvdy1kb3duJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGN4KHtcbiAgICAgICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1tZW51LWhvei1pY29uLWFycm93YF06IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9b3BlbmBdOiBvcGVuXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBvcHVwQWxpZ24gPT09ICdvdXRzaWRlJykge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uUHJvcHMudGFyZ2V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluZERPTU5vZGUocm9vdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvblByb3BzLmFsaWduID0gJ3RsIHRyJztcblxuICAgICAgICAgICAgICAgIHJ0bCA/XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uUHJvcHMub2Zmc2V0ID0gWy0yLCAwXSA6XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uUHJvcHMub2Zmc2V0ID0gWzIsIDBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlcklzSWNvbikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblByb3BzLnRhcmdldCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zaXRpb25Qcm9wcy5hbGlnbiA9ICd0bCB0cic7XG5cbiAgICAgICAgICAgICAgICBydGwgP1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblByb3BzLm9mZnNldCA9IFsyLCAtOF0gOlxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblByb3BzLm9mZnNldCA9IFstMiwgLThdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcnJvd1Byb3BzID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhcnJvdy1yaWdodCcsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBgJHtwcmVmaXh9bWVudS1pY29uLWFycm93YFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFycm93ID0gPEljb24gey4uLmFycm93UHJvcHN9IC8+O1xuICAgICAgICBjb25zdCB0cmlnZ2VyID0gdHJpZ2dlcklzSWNvbiA/IGFycm93IDogdGhpcy5yZW5kZXJJdGVtKHNlbGVjdGFibGUsIGFycm93LCBvdGhlcnMpO1xuICAgICAgICBjb25zdCBwb3B1cCA9IHRoaXMucmVuZGVyUG9wdXAodHJpZ2dlciwgbmV3VHJpZ2dlclR5cGUsIHBvc2l0aW9uUHJvcHMsIG5ld0NoaWxkcmVuKTtcbiAgICAgICAgcmV0dXJuIHRyaWdnZXJJc0ljb24gPyB0aGlzLnJlbmRlckl0ZW0oc2VsZWN0YWJsZSwgcG9wdXAsIG90aGVycykgOiBwb3B1cDtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWVudS92aWV3L3BvcHVwLWl0ZW0uanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQ2hlY2tib3ggZnJvbSAnLi4vLi4vY2hlY2tib3gnO1xuaW1wb3J0IFJhZGlvIGZyb20gJy4uLy4uL3JhZGlvJztcbmltcG9ydCB7IGZ1bmMsIG9iaiwgS0VZQ09ERSB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IEl0ZW0gZnJvbSAnLi9pdGVtJztcblxuY29uc3Qgbm9vcCA9IHt9O1xuY29uc3QgeyBiaW5kQ3R4IH0gPSBmdW5jO1xuY29uc3QgeyBwaWNrT3RoZXJzIH0gPSBvYmo7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoZWNrYWJsZUl0ZW0gZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIF9rZXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHJvb3Q6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgaW5saW5lSW5kZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBjaGVja2VkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgaW5kZXRlcm1pbmF0ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgY2hlY2tUeXBlOiBQcm9wVHlwZXMub25lT2YoWydjaGVja2JveCcsICdyYWRpbyddKSxcbiAgICAgICAgY2hlY2tEaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGhlbHBlcjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgb25LZXlEb3duOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25DbGljazogUHJvcFR5cGVzLmZ1bmNcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjaGVja2VkOiBmYWxzZSxcbiAgICAgICAgaW5kZXRlcm1pbmF0ZTogZmFsc2UsXG4gICAgICAgIGNoZWNrVHlwZTogJ2NoZWNrYm94JyxcbiAgICAgICAgY2hlY2tEaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIG9uQ2hhbmdlOiBub29wXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICBiaW5kQ3R4KHRoaXMsIFsnc3RvcFByb3BhZ2F0aW9uJywgJ2hhbmRsZUtleURvd24nLCAnaGFuZGxlQ2xpY2snXSk7XG4gICAgfVxuXG4gICAgc3RvcFByb3BhZ2F0aW9uKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDaGVjayhlKSB7XG4gICAgICAgIGNvbnN0IHsgY2hlY2tUeXBlLCBjaGVja2VkLCBvbkNoYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKCEoY2hlY2tUeXBlID09PSAncmFkaW8nICYmIGNoZWNrZWQpKSB7XG4gICAgICAgICAgICBvbkNoYW5nZSghY2hlY2tlZCwgZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVLZXlEb3duKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERS5TUEFDRSAmJiAhdGhpcy5wcm9wcy5jaGVja0Rpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNoZWNrKGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vbktleURvd24gJiYgdGhpcy5wcm9wcy5vbktleURvd24oZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlQ2xpY2soZSkge1xuICAgICAgICB0aGlzLmhhbmRsZUNoZWNrKGUpO1xuXG4gICAgICAgIHRoaXMucHJvcHMub25DbGljayAmJiB0aGlzLnByb3BzLm9uQ2xpY2soZSk7XG4gICAgfVxuXG4gICAgcmVuZGVyQ2hlY2soKSB7XG4gICAgICAgIGNvbnN0IHsgcm9vdCwgY2hlY2tlZCwgaW5kZXRlcm1pbmF0ZSwgZGlzYWJsZWQsIGNoZWNrVHlwZSwgY2hlY2tEaXNhYmxlZCwgb25DaGFuZ2UgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgbGFiZWxUb2dnbGVDaGVja2VkIH0gPSByb290LnByb3BzO1xuICAgICAgICBjb25zdCBDaGVjayA9IGNoZWNrVHlwZSA9PT0gJ3JhZGlvJyA/IFJhZGlvIDogQ2hlY2tib3g7XG5cbiAgICAgICAgY29uc3QgY2hlY2tQcm9wcyA9IHtcbiAgICAgICAgICAgIHRhYkluZGV4OiAnLTEnLFxuICAgICAgICAgICAgY2hlY2tlZCxcbiAgICAgICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZCB8fCBjaGVja0Rpc2FibGVkXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjaGVja1R5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgIGNoZWNrUHJvcHMuaW5kZXRlcm1pbmF0ZSA9IGluZGV0ZXJtaW5hdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYWJlbFRvZ2dsZUNoZWNrZWQpIHtcbiAgICAgICAgICAgIGNoZWNrUHJvcHMub25DaGFuZ2UgPSBvbkNoYW5nZTtcbiAgICAgICAgICAgIGNoZWNrUHJvcHMub25DbGljayA9IHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxDaGVjayB7Li4uY2hlY2tQcm9wc30gLz5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgX2tleSwgcm9vdCwgY2hlY2tlZCwgZGlzYWJsZWQsIG9uQ2xpY2ssIGhlbHBlciwgY2hpbGRyZW4gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBsYWJlbFRvZ2dsZUNoZWNrZWQgfSA9IHJvb3QucHJvcHM7XG4gICAgICAgIGNvbnN0IG90aGVycyA9IHBpY2tPdGhlcnMoT2JqZWN0LmtleXMoQ2hlY2thYmxlSXRlbS5wcm9wVHlwZXMpLCB0aGlzLnByb3BzKTtcblxuICAgICAgICBjb25zdCBuZXdQcm9wcyA9IHtcbiAgICAgICAgICAgIF9rZXksXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICB0eXBlOiAnaXRlbScsXG4gICAgICAgICAgICBvbkNsaWNrLFxuICAgICAgICAgICAgb25LZXlEb3duOiB0aGlzLmhhbmRsZUtleURvd24sXG4gICAgICAgICAgICAuLi5vdGhlcnNcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxhYmVsVG9nZ2xlQ2hlY2tlZCAmJiAhZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIG5ld1Byb3BzLm9uQ2xpY2sgPSB0aGlzLmhhbmRsZUNsaWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxJdGVtIGFyaWEtY2hlY2tlZD17Y2hlY2tlZH0gey4uLm5ld1Byb3BzfT5cbiAgICAgICAgICAgICAgICB7dGhpcy5yZW5kZXJDaGVjaygpfVxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YCR7cHJlZml4fW1lbnUtaXRlbS10ZXh0YH0+e2NoaWxkcmVufTwvc3Bhbj5cbiAgICAgICAgICAgICAgICB7aGVscGVyID8gPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH1tZW51LWl0ZW0taGVscGVyYH0+e2hlbHBlcn08L2Rpdj4gOiBudWxsfVxuICAgICAgICAgICAgPC9JdGVtPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tZW51L3ZpZXcvY2hlY2thYmxlLWl0ZW0uanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBVSVN0YXRlIGZyb20gJy4uL21peGluLXVpLXN0YXRlJztcbmltcG9ydCBDb25maWdQcm92aWRlciBmcm9tICcuLi9jb25maWctcHJvdmlkZXInO1xuaW1wb3J0IEljb24gZnJvbSAnLi4vaWNvbic7XG5pbXBvcnQgeyBvYmosIGZ1bmMgfSBmcm9tICcuLi91dGlsJztcblxuY29uc3Qgbm9vcCA9IGZ1bmMubm9vcDtcbmZ1bmN0aW9uIGlzQ2hlY2tlZChzZWxlY3RlZFZhbHVlLCB2YWx1ZSkge1xuICAgIHJldHVybiBzZWxlY3RlZFZhbHVlLmluZGV4T2YodmFsdWUpID4gLTE7XG59XG4vKipcbiAqIENoZWNrYm94XG4gKiBAb3JkZXIgMVxuICovXG5jbGFzcyBDaGVja2JveCBleHRlbmRzIFVJU3RhdGUge1xuICAgIHN0YXRpYyBkaXNwbGF5TmFtZSA9ICdDaGVja2JveCc7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBydGw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ57G75ZCNXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGVja2JveCBpZCwg5oyC6L295ZyoaW5wdXTkuIpcbiAgICAgICAgICovXG4gICAgICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ5YaF5pWb5qC35byPXG4gICAgICAgICAqL1xuICAgICAgICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmAieS4reeKtuaAgVxuICAgICAgICAgKi9cbiAgICAgICAgY2hlY2tlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpu5jorqTpgInkuK3nirbmgIFcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRDaGVja2VkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOemgeeUqFxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6YCa6L+H5bGe5oCn6YWN572ubGFiZWzvvIxcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrYm94IOeahOS4remXtOeKtuaAge+8jOWPquS8muW9seWTjeWIsCBDaGVja2JveCDnmoTmoLflvI/vvIzlubbkuI3lvbHlk43lhbYgY2hlY2tlZCDlsZ7mgKdcbiAgICAgICAgICovXG4gICAgICAgIGluZGV0ZXJtaW5hdGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICogIENoZWNrYm94IOeahOm7mOiupOS4remXtOaAge+8jOWPquS8muW9seWTjeWIsCBDaGVja2JveCDnmoTmoLflvI/vvIzlubbkuI3lvbHlk43lhbYgY2hlY2tlZCDlsZ7mgKdcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRJbmRldGVybWluYXRlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeKtuaAgeWPmOWMluaXtuinpuWPkeeahOS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNoZWNrZWQg5piv5ZCm6YCJ5LitXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRG9tIOS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog6byg5qCH6L+b5YWlZW50ZXLkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSBEb20g5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBvbk1vdXNlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog6byg5qCH56a75byATGVhdmXkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSBEb20g5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBvbk1vdXNlTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuICAgIH1cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGRlZmF1bHRDaGVja2VkOiBmYWxzZSxcbiAgICAgICAgZGVmYXVsdEluZGV0ZXJtaW5hdGU6IGZhbHNlLFxuICAgICAgICBvbkNoYW5nZTogbm9vcCxcbiAgICAgICAgb25Nb3VzZUVudGVyOiBub29wLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IG5vb3AsXG4gICAgICAgIHByZWZpeDogJ25leHQtJyxcbiAgICB9XG5cbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIF9fZ3JvdXBfXzogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHNlbGVjdGVkVmFsdWU6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIGxldCBjaGVja2VkLCBpbmRldGVybWluYXRlO1xuICAgICAgICBpZiAoY29udGV4dC5fX2dyb3VwX18pIHtcbiAgICAgICAgICAgIGluZGV0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNoZWNrZWQgPSBpc0NoZWNrZWQoY29udGV4dC5zZWxlY3RlZFZhbHVlLCBwcm9wcy52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoJ2NoZWNrZWQnIGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoZWNrZWQgPSBwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCdpbmRldGVybWluYXRlJyBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGluZGV0ZXJtaW5hdGUgPSBwcm9wcy5pbmRldGVybWluYXRlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmRldGVybWluYXRlID0gcHJvcHMuZGVmYXVsdEluZGV0ZXJtaW5hdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgY2hlY2tlZCxcbiAgICAgICAgICAgIGluZGV0ZXJtaW5hdGUsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9ICBwcm9wcy5kaXNhYmxlZCB8fCAoY29udGV4dC5fX2dyb3VwX18gJiYgKCdkaXNhYmxlZCcgaW4gY29udGV4dCkgJiYgY29udGV4dC5kaXNhYmxlZCk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSB0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAgICAgIGlmIChuZXh0Q29udGV4dC5fX2dyb3VwX18pIHtcbiAgICAgICAgICAgIGlmICgnc2VsZWN0ZWRWYWx1ZScgaW4gbmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogaXNDaGVja2VkKG5leHRDb250ZXh0LnNlbGVjdGVkVmFsdWUsIG5leHRQcm9wcy52YWx1ZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZWQgPSBuZXh0UHJvcHMuZGlzYWJsZWQgfHwgKFxuICAgICAgICAgICAgICAgICdkaXNhYmxlZCcgaW4gbmV4dENvbnRleHQgJiZcbiAgICAgICAgICAgICAgICBuZXh0Q29udGV4dC5kaXNhYmxlZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICgnY2hlY2tlZCcgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IG5leHRQcm9wcy5jaGVja2VkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ2luZGV0ZXJtaW5hdGUnIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBpbmRldGVybWluYXRlOiBuZXh0UHJvcHMuaW5kZXRlcm1pbmF0ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNhYmxlZCA9IG5leHRQcm9wcy5kaXNhYmxlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHsgc2hhbGxvd0VxdWFsIH0gPSBvYmo7XG4gICAgICAgIHJldHVybiAhc2hhbGxvd0VxdWFsKHRoaXMucHJvcHMsIG5leHRQcm9wcykgfHxcbiAgICAgICAgICAgICFzaGFsbG93RXF1YWwodGhpcy5zdGF0ZSwgbmV4dFN0YXRlKSB8fFxuICAgICAgICAgICAgIXNoYWxsb3dFcXVhbCh0aGlzLmNvbnRleHQsIG5leHRDb250ZXh0KTtcbiAgICB9XG5cbiAgICBvbkNoYW5nZShlKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrZWQgPSBlLnRhcmdldC5jaGVja2VkO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucHJvcHMudmFsdWU7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5fX2dyb3VwX18pIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5vbkNoYW5nZSh2YWx1ZSwgZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISgnY2hlY2tlZCcgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogY2hlY2tlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISgnaW5kZXRlcm1pbmF0ZScgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoY2hlY2tlZCwgZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICAgIGNvbnN0IHsgaWQsIGNsYXNzTmFtZSwgY2hpbGRyZW4sIHN0eWxlLCBsYWJlbCwgb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmUsIHJ0bCxcbiAgICAgICAgICAgIC4uLm90aGVyUHJvcHMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGNoZWNrZWQgPSAhIXRoaXMuc3RhdGUuY2hlY2tlZDtcbiAgICAgICAgY29uc3QgZGlzYWJsZWQgPSB0aGlzLmRpc2FibGVkO1xuICAgICAgICBjb25zdCBpbmRldGVybWluYXRlID0gISF0aGlzLnN0YXRlLmluZGV0ZXJtaW5hdGU7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHRoaXMuY29udGV4dC5wcmVmaXggfHwgdGhpcy5wcm9wcy5wcmVmaXg7XG5cbiAgICAgICAgY29uc3Qgb3RoZXJzID0gb2JqLnBpY2tPdGhlcnMoQ2hlY2tib3gucHJvcFR5cGVzLCBvdGhlclByb3BzKTtcbiAgICAgICAgY29uc3Qgb3RoZXJzRGF0YSA9IG9iai5waWNrQXR0cnNXaXRoKG90aGVycywgJ2RhdGEtJyk7XG5cblxuXG4gICAgICAgIGxldCBjaGlsZElucHV0ID0gKDxpbnB1dFxuICAgICAgICAgICAgey4uLm9iai5waWNrT3RoZXJzKENoZWNrYm94LnByb3BUeXBlcywgb3RoZXJQcm9wcyl9XG4gICAgICAgICAgICBpZD17aWR9XG4gICAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgICBjaGVja2VkPXtjaGVja2VkfVxuICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uQ2hhbmdlfVxuICAgICAgICAgICAgYXJpYS1jaGVja2VkPXtpbmRldGVybWluYXRlID8gJ21peGVkJyA6IGNoZWNrZWR9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2Ake3ByZWZpeH1jaGVja2JveC1pbnB1dGB9XG4gICAgICAgIC8+KTtcblxuICAgICAgICAvLyBkaXNhYmxlIOaXoOeKtuaAgeaTjeS9nFxuICAgICAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICAgICAgICBjaGlsZElucHV0ID0gdGhpcy5nZXRTdGF0ZUVsZW1lbnQoY2hpbGRJbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xzID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fWNoZWNrYm94LXdyYXBwZXJgXTogdHJ1ZSxcbiAgICAgICAgICAgIFtjbGFzc05hbWVdOiAhIWNsYXNzTmFtZSxcbiAgICAgICAgICAgIGNoZWNrZWQsXG4gICAgICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgICAgIGluZGV0ZXJtaW5hdGUsXG4gICAgICAgICAgICBbdGhpcy5nZXRTdGF0ZUNsYXNzTmFtZSgpXTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbGFiZWxDbHMgPSBgJHtwcmVmaXh9Y2hlY2tib3gtbGFiZWxgO1xuICAgICAgICBjb25zdCB0eXBlID0gaW5kZXRlcm1pbmF0ZSA/ICdzZW1pLXNlbGVjdCcgOiAnc2VsZWN0JztcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGxhYmVsXG4gICAgICAgICAgICAgICAgey4uLm90aGVyc0RhdGF9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbHN9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3N0eWxlfVxuICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlcj17b25Nb3VzZUVudGVyfVxuICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17b25Nb3VzZUxlYXZlfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YCR7cHJlZml4fWNoZWNrYm94YH0+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YCR7cHJlZml4fWNoZWNrYm94LWlubmVyYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPXt0eXBlfSBzaXplPVwieHNcIiBjbGFzc05hbWU9e2luZGV0ZXJtaW5hdGUgPyAnem9vbUluJyA6ICcnfSAvPlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZElucHV0fVxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICB7W2xhYmVsLCBjaGlsZHJlbl0ubWFwKChpdGVtLCBpKSA9PiAoaXRlbSA/IDxzcGFuIGtleT17aX0gY2xhc3NOYW1lPXtsYWJlbENsc30+e2l0ZW19PC9zcGFuPiA6IG51bGwpKX1cbiAgICAgICAgICAgIDwvbGFiZWw+KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZ1Byb3ZpZGVyLmNvbmZpZyhDaGVja2JveCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY2hlY2tib3gvY2hlY2tib3guanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgZnVuYyB9IGZyb20gJy4uL3V0aWwnO1xuXG5jb25zdCB7IG1ha2VDaGFpbiB9ID0gZnVuYztcbi8vIFVJU3RhdGUg5Li65LiA5Lqb54m55q6K5YWD57Sg55qE54q25oCB5ZON5bqU5o+Q5L6b5LqG5qCH5YeG55qE5pa55byP77yMXG4vLyDlsKTlhbbpgILlkIhDU1Pml6Dms5XlrozlhajlrprliLbnmoTmjqfku7bvvIzmr5TlpoJjaGVja2JveO+8jHJhZGlv562J44CCXG4vLyDoi6Xnu4Tku7YgZGlzYWJsZSDliJnoh6rooYzliKTmlq3mmK/lkKbpnIDopoHnu5HlrprnirbmgIHnrqHnkIbjgIJcbi8vIOazqOaEj++8mmRpc2FibGUg5LiN5Lya6Kem5Y+R5LqL5Lu277yM6K+35L2/55SocmVzZXRVSVN0YXRl6L+Y5Y6f54q25oCBXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9wcm9wLXR5cGVzICovXG5jbGFzcyBVSVN0YXRlIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICAgICAgWydfb25VSUZvY3VzJywgJ19vblVJQmx1ciddLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICB0aGlzW2l0ZW1dID0gdGhpc1tpdGVtXS5iaW5kKHRoaXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gYmFzZSDkuovku7bnu5HlrprnmoTlhYPntKBcbiAgICBnZXRTdGF0ZUVsZW1lbnQoYmFzZSkge1xuICAgICAgICBjb25zdCB7IG9uRm9jdXMsIG9uQmx1ciB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChiYXNlLCB7XG4gICAgICAgICAgICBvbkZvY3VzOiBtYWtlQ2hhaW4odGhpcy5fb25VSUZvY3VzLCBvbkZvY3VzKSxcbiAgICAgICAgICAgIG9uQmx1cjogbWFrZUNoYWluKHRoaXMuX29uVUlCbHVyLCBvbkJsdXIpXG4gICAgICAgIH0pO1xuXG4gICAgfVxuICAgIC8vIOiOt+WPlueKtuaAgWNsYXNzbmFtZVxuICAgIGdldFN0YXRlQ2xhc3NOYW1lKCkge1xuICAgICAgICBjb25zdCB7IGZvY3VzZWQgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHJldHVybiBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgIGZvY3VzZWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIOWkjeWOn+eKtuaAgVxuICAgIHJlc2V0VUlTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBmb2N1c2VkOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9vblVJRm9jdXMoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZm9jdXNlZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX29uVUlCbHVyKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZvY3VzZWQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVUlTdGF0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9taXhpbi11aS1zdGF0ZS9pbmRleC5qc3giLCJpbXBvcnQgUmFkaW8gZnJvbSAnLi9yYWRpbyc7XG5pbXBvcnQgUmFkaW9Hcm91cCBmcm9tICcuL3JhZGlvLWdyb3VwJztcblxuUmFkaW8uR3JvdXAgPSBSYWRpb0dyb3VwO1xuXG5leHBvcnQgZGVmYXVsdCBSYWRpbztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yYWRpby9pbmRleC5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFVJU3RhdGUgZnJvbSAnLi4vbWl4aW4tdWktc3RhdGUnO1xuaW1wb3J0IENvbmZpZ1Byb3ZpZGVyIGZyb20gJy4uL2NvbmZpZy1wcm92aWRlcic7XG5pbXBvcnQgeyBvYmosIGZ1bmMgfSBmcm9tICcuLi91dGlsJztcblxuY29uc3QgeyBtYWtlQ2hhaW4sIG5vb3AgfSA9IGZ1bmM7XG4vKipcbiAqIFJhZGlvXG4gKiBAb3JkZXIgMVxuICovXG5jbGFzcyBSYWRpbyBleHRlbmRzIFVJU3RhdGUge1xuICAgIHN0YXRpYyBkaXNwbGF5TmFtZSA9ICdSYWRpbyc7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBydGw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ57G75ZCNXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnu4Tku7ZpbnB1dOeahGlkXG4gICAgICAgICAqL1xuICAgICAgICBpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieWGheaVm+agt+W8j1xuICAgICAgICAgKi9cbiAgICAgICAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva5yYWRpb+aYr+WQpumAieS4rVxuICAgICAgICAgKi9cbiAgICAgICAgY2hlY2tlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva5yYWRpb+aYr+WQpum7mOiupOmAieS4rVxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdENoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6YCa6L+H5bGe5oCn6YWN572ubGFiZWxcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeKtuaAgeWPmOWMluaXtuinpuWPkeeahOS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNoZWNrZWQg5piv5ZCm6YCJ5LitXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRG9tIOS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog6byg5qCH6L+b5YWlZW50ZXLkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSBEb20g5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBvbk1vdXNlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog6byg5qCH56a75byA5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRG9tIOS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgb25Nb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJhZGlv5piv5ZCm6KKr56aB55SoXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByYWRpbyDnmoR2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5ib29sXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBuYW1lXG4gICAgICAgICAqL1xuICAgICAgICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIH1cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIG9uQ2hhbmdlOiBub29wLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IG5vb3AsXG4gICAgICAgIG9uTW91c2VFbnRlcjogbm9vcCxcbiAgICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICAgIHByZWZpeDogJ25leHQtJ1xuICAgIH1cblxuICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgX19ncm91cF9fOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgaXNCdXR0b246IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBzZWxlY3RlZFZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuYm9vbF0pLFxuICAgICAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIGxldCBjaGVja2VkO1xuICAgICAgICBpZiAoY29udGV4dC5fX2dyb3VwX18pIHtcbiAgICAgICAgICAgIGNoZWNrZWQgPSBjb250ZXh0LnNlbGVjdGVkVmFsdWUgPT09IHByb3BzLnZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKCdjaGVja2VkJyBpbiBwcm9wcykge1xuICAgICAgICAgICAgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja2VkID0gcHJvcHMuZGVmYXVsdENoZWNrZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlID0geyBjaGVja2VkIH07XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkIHx8ICAoY29udGV4dC5fX2dyb3VwX18gJiYgKCdkaXNhYmxlZCcgaW4gY29udGV4dCkgJiYgY29udGV4dC5kaXNhYmxlZCk7XG5cbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICAgICAgaWYgKG5leHRDb250ZXh0Ll9fZ3JvdXBfXykge1xuICAgICAgICAgICAgY29uc3QgeyBzZWxlY3RlZFZhbHVlIH0gPSBuZXh0Q29udGV4dDtcbiAgICAgICAgICAgIGlmICgnc2VsZWN0ZWRWYWx1ZScgaW4gbmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogc2VsZWN0ZWRWYWx1ZSA9PT0gbmV4dFByb3BzLnZhbHVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCdjaGVja2VkJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGNoZWNrZWQ6IG5leHRQcm9wcy5jaGVja2VkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBuZXh0UHJvcHMuZGlzYWJsZWQgfHwgIChuZXh0Q29udGV4dC5fX2dyb3VwX18gJiYgKCdkaXNhYmxlZCcgaW4gbmV4dENvbnRleHQpICYmIG5leHRDb250ZXh0LmRpc2FibGVkKTtcblxuICAgICAgICAvLyB3aGVuIGRpc2FibGVkLCByZXNldCBVSVN0YXRlXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAvLyBvbmx5IGNsYXNzIGhhcyBhbiBpbXBhY3QsIG5vIGVmZmVjdCBvbiB2aXN1YWxcbiAgICAgICAgICAgIHRoaXMucmVzZXRVSVN0YXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHsgc2hhbGxvd0VxdWFsIH0gPSBvYmo7XG4gICAgICAgIHJldHVybiAhc2hhbGxvd0VxdWFsKHRoaXMucHJvcHMsIG5leHRQcm9wcykgfHxcbiAgICAgICAgICAgICFzaGFsbG93RXF1YWwodGhpcy5zdGF0ZSwgbmV4dFN0YXRlKSB8fFxuICAgICAgICAgICAgIXNoYWxsb3dFcXVhbCh0aGlzLm5leHRDb250ZXh0LCBuZXh0Q29udGV4dCk7XG4gICAgfVxuXG4gICAgb25DaGFuZ2UoZSkge1xuICAgICAgICBjb25zdCBjaGVja2VkID0gZS50YXJnZXQuY2hlY2tlZDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnByb3BzLnZhbHVlO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuX19ncm91cF9fKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQub25DaGFuZ2UodmFsdWUsIGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuY2hlY2tlZCAhPT0gY2hlY2tlZCkge1xuICAgICAgICAgICAgaWYgKCEoJ2NoZWNrZWQnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IGNoZWNrZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoY2hlY2tlZCwgZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICAgIGNvbnN0IHsgaWQsIGNsYXNzTmFtZSwgY2hpbGRyZW4sIHN0eWxlLCBsYWJlbCwgb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmUsIHRhYkluZGV4LCBydGwsXG4gICAgICAgICAgICAuLi5vdGhlclByb3BzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBjaGVja2VkID0gISF0aGlzLnN0YXRlLmNoZWNrZWQ7XG4gICAgICAgIGNvbnN0IGRpc2FibGVkID0gdGhpcy5kaXNhYmxlZDtcbiAgICAgICAgY29uc3QgaXNCdXR0b24gPSB0aGlzLmNvbnRleHQuaXNCdXR0b247XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHRoaXMuY29udGV4dC5wcmVmaXggfHwgdGhpcy5wcm9wcy5wcmVmaXg7XG5cbiAgICAgICAgY29uc3Qgb3RoZXJzID0gb2JqLnBpY2tPdGhlcnMoUmFkaW8ucHJvcFR5cGVzLCBvdGhlclByb3BzKTtcbiAgICAgICAgY29uc3Qgb3RoZXJzRGF0YSA9IG9iai5waWNrQXR0cnNXaXRoKG90aGVycywgJ2RhdGEtJyk7XG5cblxuICAgICAgICBsZXQgaW5wdXQgPSAoPGlucHV0XG4gICAgICAgICAgICB7Li4ub2JqLnBpY2tPdGhlcnMob3RoZXJzRGF0YSwgb3RoZXJzKX1cbiAgICAgICAgICAgIGlkPXtpZH1cbiAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICAgIGNoZWNrZWQ9e2NoZWNrZWR9XG4gICAgICAgICAgICB0eXBlPVwicmFkaW9cIlxuICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25DaGFuZ2V9XG4gICAgICAgICAgICBhcmlhLWNoZWNrZWQ9e2NoZWNrZWR9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2Ake3ByZWZpeH1yYWRpby1pbnB1dGB9XG4gICAgICAgIC8+KTtcblxuICAgICAgICAvLyBkaXNhYmxlZCBkbyBub3QgaG92ZSBmb2N1cyBzdGF0ZVxuICAgICAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHRoaXMuZ2V0U3RhdGVFbGVtZW50KGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNscyA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1yYWRpb2BdOiB0cnVlLFxuICAgICAgICAgICAgY2hlY2tlZCxcbiAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgW3RoaXMuZ2V0U3RhdGVDbGFzc05hbWUoKV06IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNsc0lubmVyID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fXJhZGlvLWlubmVyYF06IHRydWUsXG4gICAgICAgICAgICBwcmVzczogY2hlY2tlZCxcbiAgICAgICAgICAgIHVucHJlc3M6ICFjaGVja2VkXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbHNXcmFwcGVyID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fXJhZGlvLXdyYXBwZXJgXTogdHJ1ZSxcbiAgICAgICAgICAgIFtjbGFzc05hbWVdOiAhIWNsYXNzTmFtZSxcbiAgICAgICAgICAgIGNoZWNrZWQsXG4gICAgICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgICAgIFt0aGlzLmdldFN0YXRlQ2xhc3NOYW1lKCldOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjaGlsZHJlbkNscyA9IGAke3ByZWZpeH1yYWRpby1sYWJlbGA7XG5cbiAgICAgICAgY29uc3QgcmFkaW9Db21wID0gIWlzQnV0dG9uID9cbiAgICAgICAgICAgICg8c3BhbiBjbGFzc05hbWU9e2Nsc30+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtjbHNJbm5lcn0+PC9zcGFuPlxuICAgICAgICAgICAgICAgIHtpbnB1dH1cbiAgICAgICAgICAgIDwvc3Bhbj4pIDpcbiAgICAgICAgICAgICg8c3BhbiBjbGFzc05hbWU9e2Ake3ByZWZpeH1yYWRpby1zaW5nbGUtaW5wdXRgfT5cbiAgICAgICAgICAgICAgICB7aW5wdXR9XG4gICAgICAgICAgICA8L3NwYW4+KTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGxhYmVsXG4gICAgICAgICAgICAgICAgey4uLm90aGVyc0RhdGF9XG4gICAgICAgICAgICAgICAgcm9sZT1cInJhZGlvXCJcbiAgICAgICAgICAgICAgICBkaXI9e3J0bCA/ICdydGwnIDogJ2x0cid9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3N0eWxlfVxuICAgICAgICAgICAgICAgIHRhYkluZGV4PXt0YWJJbmRleH1cbiAgICAgICAgICAgICAgICBhcmlhLWNoZWNrZWQ9e2NoZWNrZWR9XG4gICAgICAgICAgICAgICAgYXJpYS1kaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbHNXcmFwcGVyfVxuICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlcj17ZGlzYWJsZWQgPyBvbk1vdXNlRW50ZXIgOiBtYWtlQ2hhaW4odGhpcy5fb25VSU1vdXNlRW50ZXIsIG9uTW91c2VFbnRlcil9XG4gICAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXtkaXNhYmxlZCA/IG9uTW91c2VMZWF2ZSA6IG1ha2VDaGFpbih0aGlzLl9vblVJTW91c2VMZWF2ZSwgb25Nb3VzZUxlYXZlKX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7cmFkaW9Db21wfVxuICAgICAgICAgICAgICAgIHtbY2hpbGRyZW4sIGxhYmVsXS5tYXAoKGQsIGkpID0+IGQgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGtleT17aX0gY2xhc3NOYW1lPXtjaGlsZHJlbkNsc30+e2R9PC9zcGFuPiA6IG51bGwpfVxuICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZ1Byb3ZpZGVyLmNvbmZpZyhSYWRpbyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmFkaW8vcmFkaW8uanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgSWNvbiBmcm9tICcuLi8uLi9pY29uJztcbmltcG9ydCB7IEtFWUNPREUgfSBmcm9tICcuLi8uLi91dGlsJztcblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcHJlZmVyLXN0YXRlbGVzcy1mdW5jdGlvbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU29ydCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHNvcnQ6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIG9uU29ydDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGRhdGFJbmRleDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgbG9jYWxlOiBQcm9wVHlwZXMub2JqZWN0XG4gICAgfVxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHNvcnQ6IHt9XG4gICAgfVxuICAgIC8vIOa4suafk+aOkuW6j1xuICAgIHJlbmRlclNvcnQoKSB7XG4gICAgICAgIGNvbnN0IHtwcmVmaXgsIHNvcnQsIGRhdGFJbmRleCwgbG9jYWxlfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBzb3J0U3RhdHVzID0gc29ydFtkYXRhSW5kZXhdLFxuICAgICAgICAgICAgbWFwID0ge1xuICAgICAgICAgICAgICAgIGRlc2M6ICdkZXNjZW5kaW5nJyxcbiAgICAgICAgICAgICAgICBhc2M6ICdhc2NlbmRpbmcnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGljb25zID0gWydhc2MnLCAnZGVzYyddLm1hcChzb3J0T3JkZXIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8YSBocmVmPVwiamF2YXNjcmlwdDo7XCJcbiAgICAgICAgICAgICAgICAgICAga2V5PXtzb3J0T3JkZXJ9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c29ydFN0YXR1cyA9PT0gc29ydE9yZGVyID8gJ2N1cnJlbnQnIDogJyd9PlxuICAgICAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPXttYXBbc29ydE9yZGVyXX0gc2l6ZT1cInNtYWxsXCIvPlxuICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8c3BhbiByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICB0YWJJbmRleD1cIjBcIlxuICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e2xvY2FsZVtzb3J0U3RhdHVzXX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1zb3J0YH1cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrLmJpbmQodGhpcyl9XG4gICAgICAgICAgICAgICAgb25LZXlEb3duPXt0aGlzLmtleWRvd25IYW5kbGVyfT5cbiAgICAgICAgICAgICAgICB7aWNvbnN9XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaGFuZGxlQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHtzb3J0LCBkYXRhSW5kZXh9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy5vblNvcnQoZGF0YUluZGV4LCBzb3J0W2RhdGFJbmRleF0gPT09ICdkZXNjJyA/ICdhc2MnIDogJ2Rlc2MnKTtcbiAgICB9XG5cbiAgICBrZXlkb3duSGFuZGxlciA9IGUgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERS5FTlRFUikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDbGljaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25Tb3J0ID0gKGRhdGFJbmRleCwgb3JkZXIpID0+IHtcbiAgICAgICAgY29uc3Qgc29ydCA9IHt9O1xuICAgICAgICBzb3J0W2RhdGFJbmRleF0gPSBvcmRlcjtcblxuICAgICAgICB0aGlzLnByb3BzLm9uU29ydChkYXRhSW5kZXgsIG9yZGVyLCBzb3J0KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlclNvcnQoKTtcbiAgICB9XG5cbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2Jhc2Uvc29ydC5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFJvdyBmcm9tICcuLi9leHBhbmRlZC9yb3cnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9wcmVmZXItc3RhdGVsZXNzLWZ1bmN0aW9uICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWxlY3Rpb25Sb3cgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC4uLlJvdy5wcm9wVHlwZXNcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAuLi5Sb3cuZGVmYXVsdFByb3BzXG4gICAgfVxuXG4gICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgc2VsZWN0ZWRSb3dLZXlzOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyovXG4gICAgICAgIGNvbnN0IHsgY2xhc3NOYW1lLCByZWNvcmQsIHByaW1hcnlLZXkgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0ZWRSb3dLZXlzIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGNvbnN0IGNscyA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkUm93S2V5cy5pbmRleE9mKHJlY29yZFtwcmltYXJ5S2V5XSkgPiAtMSxcbiAgICAgICAgICAgIFtjbGFzc05hbWVdOiBjbGFzc05hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoPFJvdyB7Li4udGhpcy5wcm9wc30gY2xhc3NOYW1lPXtjbHN9IC8+KTtcbiAgICB9XG59XG5cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL3NlbGVjdGlvbi9yb3cuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBsb2cgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCBSb3cgZnJvbSAnLi4vbG9jay9yb3cnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeHBhbmRlZFJvdyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLi4uUm93LnByb3BUeXBlc1xuICAgIH1cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIC4uLlJvdy5kZWZhdWx0UHJvcHMsXG4gICAgfVxuXG4gICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgb3BlblJvd0tleXM6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgZXhwYW5kZWRSb3dSZW5kZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBleHBhbmRlZFJvd0luZGVudDogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBsb2NrVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsICdyaWdodCddKVxuICAgIH1cblxuICAgIHJlbmRlckV4cGFuZGVkUm93KHJlY29yZCwgaW5kZXgsIGNvbFNwYW4pIHtcbiAgICAgICAgY29uc3QgeyBleHBhbmRlZFJvd1JlbmRlciwgZXhwYW5kZWRSb3dJbmRlbnQsIG9wZW5Sb3dLZXlzLCBsb2NrVHlwZSB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBjb25zdCB7IGNvbHVtbnMsIGNlbGxSZWYgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChleHBhbmRlZFJvd1JlbmRlcikge1xuICAgICAgICAgICAgY29uc3QgeyBwcmltYXJ5S2V5LCBwcmVmaXggfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgbGVmdEluZGVudCA9IGV4cGFuZGVkUm93SW5kZW50WzBdLFxuICAgICAgICAgICAgICAgIHJpZ2h0SW5kZW50ID0gZXhwYW5kZWRSb3dJbmRlbnRbMV0sXG4gICAgICAgICAgICAgICAgdG90YWxJbmRlbnQgPSBsZWZ0SW5kZW50ICsgcmlnaHRJbmRlbnQsXG4gICAgICAgICAgICAgICAgcmVuZGVyQ29scyA9IChudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKDx0ZCBrZXk9e2l9IHJlZj17KGNlbGwpID0+IGNlbGxSZWYoaW5kZXgsIGksIGNlbGwpfT4mbmJzcDs8L3RkPik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0b3RhbEluZGVudCA+IGNvbFNwYW4gJiYgIWxvY2tUeXBlKSB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm5pbmcoJ0l0XFwncyBub3QgYWxsb3dlZCBleHBhbmRlZFJvd0luZGVudCBpcyBtb3JlIHRoYW4gdGhlIG51bWJlciBvZiBjb2x1bW5zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZnRJbmRlbnQgPCBjb2x1bW5zLmxlbmd0aCAmJiBsb2NrVHlwZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm5pbmcoJ2V4cGFuZGVkUm93SW5kZW50IGxlZnQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgbGVmdCBsb2NrIGNvbHVtbnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmlnaHRJbmRlbnQgPCBjb2x1bW5zLmxlbmd0aCAmJiBsb2NrVHlwZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuaW5nKCdleHBhbmRlZFJvd0luZGVudCByaWdodCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiByaWdodCBsb2NrIGNvbHVtbnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9ja1R5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICBvcGVuUm93S2V5cy5pbmRleE9mKHJlY29yZFtwcmltYXJ5S2V5XSkgPiAtMSA/IDx0ciBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1leHBhbmRlZC1yb3dgfSAga2V5PXtgZXhwYW5kZWQtJHtpbmRleH1gfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjb2xTcGFuPXtjb2xTcGFufSByZWY9eyhjZWxsKSA9PiBjZWxsUmVmKGluZGV4LCAwLCBjZWxsKX0+Jm5ic3A7PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj4gOiBudWxsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRlbnQgPSBleHBhbmRlZFJvd1JlbmRlcihyZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLWNlbGwtd3JhcHBlcmB9PlxuICAgICAgICAgICAgICAgICAgICAgICAge2NvbnRlbnR9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIG9wZW5Sb3dLZXlzLmluZGV4T2YocmVjb3JkW3ByaW1hcnlLZXldKSA+IC0xID8gPHRyIGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLWV4cGFuZGVkLXJvd2B9IGtleT17YGV4cGFuZGVkLSR7cmVjb3JkW3ByaW1hcnlLZXldIHx8IGluZGV4fWB9PlxuICAgICAgICAgICAgICAgICAgICB7cmVuZGVyQ29scyhsZWZ0SW5kZW50KX1cbiAgICAgICAgICAgICAgICAgICAgPHRkIGNvbFNwYW49e2NvbFNwYW4gLSB0b3RhbEluZGVudH0+XG4gICAgICAgICAgICAgICAgICAgICAgICB7Y29udGVudH1cbiAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAge3JlbmRlckNvbHMocmlnaHRJbmRlbnQpfVxuICAgICAgICAgICAgICAgIDwvdHI+IDogbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyovXG4gICAgICAgIGNvbnN0IHsgcmVjb3JkLCByb3dJbmRleCwgY29sdW1ucyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKHJlY29yZC5fX2V4cGFuZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJFeHBhbmRlZFJvdyhyZWNvcmQsIHJvd0luZGV4LCBjb2x1bW5zLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICg8Um93IHsuLi50aGlzLnByb3BzfSAvPik7XG4gICAgfVxufVxuXG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9leHBhbmRlZC9yb3cuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUm93IGZyb20gJy4uL2Jhc2Uvcm93JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9ja1JvdyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLi4uUm93LnByb3BUeXBlc1xuICAgIH1cblxuICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIG9uUm93TW91c2VFbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uUm93TW91c2VMZWF2ZTogUHJvcFR5cGVzLmZ1bmNcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAuLi5Sb3cuZGVmYXVsdFByb3BzXG4gICAgfVxuXG4gICAgb25Nb3VzZUVudGVyID0gKHJlY29yZCwgaW5kZXgsIGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBvblJvd01vdXNlRW50ZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgY29uc3QgeyBvbk1vdXNlRW50ZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIG9uUm93TW91c2VFbnRlciAmJiBvblJvd01vdXNlRW50ZXIocmVjb3JkLCBpbmRleCwgZSk7XG4gICAgICAgIG9uTW91c2VFbnRlcihyZWNvcmQsIGluZGV4LCBlKTtcbiAgICB9XG5cbiAgICBvbk1vdXNlTGVhdmUgPSAocmVjb3JkLCBpbmRleCwgZSkgPT4ge1xuICAgICAgICBjb25zdCB7IG9uUm93TW91c2VMZWF2ZSB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBjb25zdCB7IG9uTW91c2VMZWF2ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgb25Sb3dNb3VzZUxlYXZlICYmIG9uUm93TW91c2VMZWF2ZShyZWNvcmQsIGluZGV4LCBlKTtcbiAgICAgICAgb25Nb3VzZUxlYXZlKHJlY29yZCwgaW5kZXgsIGUpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMqL1xuICAgICAgICByZXR1cm4gKDxSb3cgey4uLnRoaXMucHJvcHN9IG9uTW91c2VFbnRlcj17dGhpcy5vbk1vdXNlRW50ZXJ9IG9uTW91c2VMZWF2ZT17dGhpcy5vbk1vdXNlTGVhdmV9IC8+KTtcbiAgICB9XG59XG5cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2xvY2svcm93LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmaW5kRE9NTm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEJvZHlDb21wb25lbnQgZnJvbSAnLi4vYmFzZS9ib2R5JztcblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcHJlZmVyLXN0YXRlbGVzcy1mdW5jdGlvbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRml4ZWRCb2R5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNvbEdyb3VwOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBvblNjcm9sbDogUHJvcFR5cGVzLmZ1bmNcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBvblNjcm9sbDogKCkgPT4ge31cbiAgICB9XG5cbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICBmaXhlZEhlYWRlcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIG1heEJvZHlIZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgICAgICAgb25Cb2R5U2Nyb2xsOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgZ2V0Tm9kZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHsgZ2V0Tm9kZSB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBnZXROb2RlICYmIGdldE5vZGUoJ2JvZHknLCBmaW5kRE9NTm9kZSh0aGlzKSk7XG4gICAgfVxuXG4gICAgb25Cb2R5U2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB7IG9uQm9keVNjcm9sbCB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBvbkJvZHlTY3JvbGwgJiYgb25Cb2R5U2Nyb2xsKCk7XG4gICAgICAgIHRoaXMucHJvcHMub25TY3JvbGwoKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY2xhc3NOYW1lLCBjb2xHcm91cCwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IG1heEJvZHlIZWlnaHQsIGZpeGVkSGVhZGVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGNvbnN0IHN0eWxlID0ge307XG4gICAgICAgIGlmIChmaXhlZEhlYWRlcikge1xuICAgICAgICAgICAgc3R5bGUubWF4SGVpZ2h0ID0gbWF4Qm9keUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDxkaXYgc3R5bGU9e3N0eWxlfSBjbGFzc05hbWU9e2NsYXNzTmFtZX0gb25TY3JvbGw9e3RoaXMub25Cb2R5U2Nyb2xsfT5cbiAgICAgICAgICAgIDx0YWJsZT5cbiAgICAgICAgICAgICAgICB7Y29sR3JvdXB9XG4gICAgICAgICAgICAgICAgPEJvZHlDb21wb25lbnQgey4uLm90aGVyc30gY29sR3JvdXA9e2NvbEdyb3VwfS8+XG4gICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICA8L2Rpdj4pO1xuICAgIH1cbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2ZpeGVkL2JvZHkuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbi8qKlxuICogVGFibGUuR3JvdXBIZWFkZXJcbiAqIEBvcmRlciAyXG4gKiovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXN0SGVhZGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDooYzmuLLmn5PnmoTpgLvovpFcbiAgICAgICAgICovXG4gICAgICAgIGNlbGw6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5lbGVtZW50LCBQcm9wVHlwZXMubm9kZSwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuWcqENoaWxkcmVu5LiK6Z2i5riy5p+Tc2VsZWN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBoYXNDaGlsZHJlblNlbGVjdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblnKhHcm91cEhlYWRlcuS4iumdoua4suafk3NlbGVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgaGFzU2VsZWN0aW9uOiBQcm9wVHlwZXMuYm9vbCxcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBjZWxsOiAoKSA9PiAnJyxcbiAgICAgICAgaGFzU2VsZWN0aW9uOiB0cnVlLFxuICAgICAgICBoYXNDaGlsZHJlblNlbGVjdGlvbjogZmFsc2VcbiAgICB9O1xuXG4gICAgc3RhdGljIF90eXBlTWFyayA9ICdsaXN0SGVhZGVyJztcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2xpc3QtaGVhZGVyLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG4vKipcbiAqIFRhYmxlLkdyb3VwRm9vdGVyXG4gKiBAb3JkZXIgM1xuICoqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlzdEZvb3RlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog6KGM5riy5p+T55qE6YC76L6RXG4gICAgICAgICAqL1xuICAgICAgICBjZWxsOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZWxlbWVudCwgUHJvcFR5cGVzLm5vZGUsIFByb3BUeXBlcy5mdW5jXSlcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBjZWxsOiAoKSA9PiAnJ1xuICAgIH07XG5cbiAgICBzdGF0aWMgX3R5cGVNYXJrID0gJ2xpc3RGb290ZXInO1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvbGlzdC1mb290ZXIuanN4IiwiaW1wb3J0ICcuLi9hbmltYXRlL3N0eWxlLmpzJztcbmltcG9ydCAnLi9tYWluLnNjc3MnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JhZGlvL3N0eWxlLmpzIiwiaW1wb3J0IENvbmZpZ1Byb3ZpZGVyIGZyb20gJy4uL2NvbmZpZy1wcm92aWRlcic7XG5pbXBvcnQgQnV0dG9uIGZyb20gJy4vdmlldy9idXR0b24nO1xuaW1wb3J0IEJ1dHRvbkdyb3VwIGZyb20gJy4vdmlldy9ncm91cCc7XG5cbkJ1dHRvbi5Hcm91cCA9IEJ1dHRvbkdyb3VwO1xuXG5leHBvcnQgZGVmYXVsdCBDb25maWdQcm92aWRlci5jb25maWcoQnV0dG9uLCB7XG4gICAgdHJhbnNmb3JtOiAocHJvcHMsIGRlcHJlY2F0ZWQpID0+IHtcbiAgICAgICAgaWYgKCdzaGFwZScgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZWQoJ3NoYXBlJywgJ3RleHQgfCB3YXJuaW5nIHwgZ2hvc3QnLCAnQnV0dG9uJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgc2hhcGUsIHR5cGUsIC4uLm90aGVycyB9ID0gcHJvcHM7XG5cbiAgICAgICAgICAgIGxldCBuZXdUeXBlID0gdHlwZTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbGlnaHQnIHx8IHR5cGUgPT09ICdkYXJrJyB8fCAodHlwZSA9PT0gJ3NlY29uZGFyeScgJiYgc2hhcGUgPT09ICd3YXJuaW5nJykpIHtcbiAgICAgICAgICAgICAgICBuZXdUeXBlID0gJ25vcm1hbCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBnaG9zdDtcbiAgICAgICAgICAgIGlmIChzaGFwZSA9PT0gJ2dob3N0Jykge1xuICAgICAgICAgICAgICAgIGdob3N0ID0gKHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbWFyeTogJ2RhcmsnLFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRhcnk6ICdkYXJrJyxcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsOiAnbGlnaHQnLFxuICAgICAgICAgICAgICAgICAgICBkYXJrOiAnZGFyaycsXG4gICAgICAgICAgICAgICAgICAgIGxpZ2h0OiAnbGlnaHQnXG4gICAgICAgICAgICAgICAgfSlbdHlwZSB8fCBCdXR0b24uZGVmYXVsdFByb3BzLnR5cGVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gc2hhcGUgPT09ICd0ZXh0JztcbiAgICAgICAgICAgIGNvbnN0IHdhcm5pbmcgPSBzaGFwZSA9PT0gJ3dhcm5pbmcnO1xuXG4gICAgICAgICAgICBwcm9wcyA9IHsgdHlwZTogbmV3VHlwZSwgZ2hvc3QsIHRleHQsIHdhcm5pbmcsIC4uLm90aGVycyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2J1dHRvbi9pbmRleC5qc3giLCJpbXBvcnQgJy4uL2ljb24vc3R5bGUuanMnO1xuaW1wb3J0ICcuL21haW4uc2Nzcyc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYnV0dG9uL3N0eWxlLmpzIiwiaW1wb3J0IEFuaW1hdGUgZnJvbSAnLi9hbmltYXRlJztcbmltcG9ydCBFeHBhbmQgZnJvbSAnLi9leHBhbmQnO1xuXG5BbmltYXRlLkV4cGFuZCA9IEV4cGFuZDtcblxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hbmltYXRlL2luZGV4LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgT3ZlcmxheSBmcm9tICcuLi9vdmVybGF5JztcbmltcG9ydCBDb25maWdQcm92aWRlciBmcm9tICcuLi9jb25maWctcHJvdmlkZXInO1xuaW1wb3J0IHtvYmosIGZ1bmN9IGZyb20gJy4uL3V0aWwnO1xuXG4vKiogTG9hZGluZyAqL1xuY2xhc3MgTG9hZGluZyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOagt+W8j+WJjee8gFxuICAgICAgICAgKi9cbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ5YaF5a65XG4gICAgICAgICAqL1xuICAgICAgICB0aXA6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnlhoXlrrnkvY3nva5cbiAgICAgICAgICogQGVudW1kZXNjIOWHuueOsOWcqOWKqOeUu+WPs+i+uSwg5Ye6546w5Zyo5Yqo55S75LiL6Z2iXG4gICAgICAgICAqL1xuICAgICAgICB0aXBBbGlnbjogUHJvcFR5cGVzLm9uZU9mKFsncmlnaHQnLCAnYm90dG9tJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICogbG9hZGluZyDnirbmgIEsIOm7mOiupCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICB2aXNpYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgb25WaXNpYmxlQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5iWNsYXNzXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnlhoXogZTmoLflvI9cbiAgICAgICAgICovXG4gICAgICAgIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5Yqo55S75bC65a+4XG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDku4Xku4Xlr7npu5jorqTliqjnlLvmlYjmnpzotbfkvZznlKhcbiAgICAgICAgICogQGVudW1kZXNjIOWkp+WPtywg5Lit5Y+3XG4gICAgICAgICAqL1xuICAgICAgICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydsYXJnZScsICdtZWRpdW0nXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnliqjnlLtcbiAgICAgICAgICovXG4gICAgICAgIGluZGljYXRvcjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWKqOeUu+minOiJslxuICAgICAgICAgKi9cbiAgICAgICAgY29sb3I6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlhajlsY/lsZXnpLpcbiAgICAgICAgICovXG4gICAgICAgIGZ1bGxTY3JlZW46IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5a2Q5YWD57SgXG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmFueSxcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICBvblZpc2libGVDaGFuZ2U6IGZ1bmMubm9vcCxcbiAgICAgICAgYW5pbWF0ZTogbnVsbCxcbiAgICAgICAgdGlwQWxpZ246ICdib3R0b20nLFxuICAgICAgICBzaXplOiAnbGFyZ2UnLFxuICAgIH07XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRpcCxcbiAgICAgICAgICAgIHZpc2libGUsXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgICAgaW5kaWNhdG9yLFxuICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICBmdWxsU2NyZWVuLFxuICAgICAgICAgICAgb25WaXNpYmxlQ2hhbmdlLFxuICAgICAgICAgICAgdGlwQWxpZ24sXG4gICAgICAgICAgICBzaXplXG4gICAgICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGxldCBpbmRpY2F0b3JEb20gPSBudWxsO1xuICAgICAgICBjb25zdCBkb3RDbHMgPSBgJHtwcmVmaXh9bG9hZGluZy1kb3RgO1xuXG4gICAgICAgIGlmIChpbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIGluZGljYXRvckRvbSA9IGluZGljYXRvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuICAgICAgICAgICAgY29uc3QgZnVzaW9uUmVhY3RvckNscyA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9bG9hZGluZy1mdXNpb24tcmVhY3RvcmBdOiB0cnVlLFxuICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9bG9hZGluZy1tZWRpdW0tZnVzaW9uLXJlYWN0b3JgXTogc2l6ZSA9PT0gJ21lZGl1bScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGluZGljYXRvckRvbSA9ICg8ZGl2IGNsYXNzTmFtZT17ZnVzaW9uUmVhY3RvckNsc30+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtkb3RDbHN9IHN0eWxlPXt7YmFja2dyb3VuZENvbG9yfX0+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17ZG90Q2xzfSBzdHlsZT17e2JhY2tncm91bmRDb2xvcn19Pjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2RvdENsc30gc3R5bGU9e3tiYWNrZ3JvdW5kQ29sb3J9fT48L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtkb3RDbHN9IHN0eWxlPXt7YmFja2dyb3VuZENvbG9yfX0+PC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvYWRpbmdDbHMgPSBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9bG9hZGluZ2BdOiB0cnVlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1vcGVuYF06IHZpc2libGUsXG4gICAgICAgICAgICBbY2xhc3NOYW1lXTogY2xhc3NOYW1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHRpcENscyA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1sb2FkaW5nLXRpcGBdOiB0cnVlLFxuICAgICAgICAgICAgLy8g6buY6K6k6Z2eIHJpZ2h05bCx5pivIGJvdHRvbVxuICAgICAgICAgICAgW2Ake3ByZWZpeH1sb2FkaW5nLXJpZ2h0LXRpcGBdOiB0aXBBbGlnbiA9PT0gJ3JpZ2h0JyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgb3RoZXJzID0gb2JqLnBpY2tPdGhlcnMoTG9hZGluZy5wcm9wVHlwZXMsIHRoaXMucHJvcHMpO1xuXG4gICAgICAgIGNvbnN0IGNvbnRlbnRDbHMgPSBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9bG9hZGluZy1jb21wb25lbnRgXTogdmlzaWJsZSxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9bG9hZGluZy13cmFwYF06IHRydWUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmdWxsU2NyZWVuID9cbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgICAgICA8T3ZlcmxheSBrZXk9XCJvdmVybGF5XCIgaGFzTWFzayBhbGlnbj1cImNjIGNjXCIgey4uLm90aGVyc31cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXtzdHlsZX1cbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZT17dmlzaWJsZX1cbiAgICAgICAgICAgICAgICAgICAgb25SZXF1ZXN0Q2xvc2U9e29uVmlzaWJsZUNoYW5nZX0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXt0aXBDbHN9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH1sb2FkaW5nLWluZGljYXRvcmB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpbmRpY2F0b3JEb219XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9bG9hZGluZy10aXAtY29udGVudGB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aXB9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsvKiDnlLHkuo7mkpHlvIDpl67popgg5L2/55So5ZCM5qC355qE5Lik5LiqRE9NICovfVxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH1sb2FkaW5nLXRpcC1wbGFjZWhvbGRlcmB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aXB9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9PdmVybGF5PlxuICAgICAgICAgICAgXSA6IChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17bG9hZGluZ0Nsc30gc3R5bGU9e3N0eWxlfSB7Li4ub3RoZXJzfT5cbiAgICAgICAgICAgICAgICAgICAge3Zpc2libGUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgKDxkaXYgY2xhc3NOYW1lPXt0aXBDbHN9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9bG9hZGluZy1pbmRpY2F0b3JgfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2luZGljYXRvckRvbX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fWxvYWRpbmctdGlwLWNvbnRlbnRgfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RpcH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fWxvYWRpbmctdGlwLXBsYWNlaG9sZGVyYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aXB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4pIDogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjb250ZW50Q2xzfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt2aXNpYmxlID8gPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH1sb2FkaW5nLW1hc2tlcmB9PjwvZGl2PiA6IG51bGx9XG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZ1Byb3ZpZGVyLmNvbmZpZyhMb2FkaW5nKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9sb2FkaW5nL2luZGV4LmpzeCIsImltcG9ydCBDb25maWdQcm92aWRlciBmcm9tICcuLi9jb25maWctcHJvdmlkZXInO1xuaW1wb3J0IE1lbnUgZnJvbSAnLi92aWV3L21lbnUnO1xuaW1wb3J0IFN1Yk1lbnUgZnJvbSAnLi92aWV3L3N1Yi1tZW51JztcbmltcG9ydCBTZWxlY3RhYmxlSXRlbSBmcm9tICcuL3ZpZXcvc2VsZWN0YWJsZS1pdGVtJztcbmltcG9ydCBDaGVja2JveEl0ZW0gZnJvbSAnLi92aWV3L2NoZWNrYm94LWl0ZW0nO1xuaW1wb3J0IFJhZGlvSXRlbSBmcm9tICcuL3ZpZXcvcmFkaW8taXRlbSc7XG5pbXBvcnQgUG9wdXBJdGVtIGZyb20gJy4vdmlldy9wb3B1cC1pdGVtJztcbmltcG9ydCBHcm91cCBmcm9tICcuL3ZpZXcvZ3JvdXAnO1xuaW1wb3J0IERpdmlkZXIgZnJvbSAnLi92aWV3L2RpdmlkZXInO1xuaW1wb3J0IGNyZWF0ZSBmcm9tICcuL3ZpZXcvY3JlYXRlJztcblxuTWVudS5TdWJNZW51ID0gU3ViTWVudTtcbk1lbnUuSXRlbSA9IFNlbGVjdGFibGVJdGVtO1xuTWVudS5DaGVja2JveEl0ZW0gPSBDaGVja2JveEl0ZW07XG5NZW51LlJhZGlvSXRlbSA9IFJhZGlvSXRlbTtcbk1lbnUuUG9wdXBJdGVtID0gUG9wdXBJdGVtO1xuTWVudS5Hcm91cCA9IEdyb3VwO1xuTWVudS5EaXZpZGVyID0gRGl2aWRlcjtcbk1lbnUuY3JlYXRlID0gY3JlYXRlO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgdHJhbnNmb3JtID0gKHByb3BzLCBkZXByZWNhdGVkKSA9PiB7XG4gICAgaWYgKCdpbmRlbnRTaXplJyBpbiBwcm9wcykge1xuICAgICAgICBkZXByZWNhdGVkKCdpbmRlbnRTaXplJywgJ2lubGluZUluZGVudCcsICdNZW51Jyk7XG5cbiAgICAgICAgY29uc3QgeyBpbmRlbnRTaXplLCAuLi5vdGhlcnMgfSA9IHByb3BzO1xuICAgICAgICBwcm9wcyA9IHsgaW5saW5lSW5kZW50OiBpbmRlbnRTaXplLCAuLi5vdGhlcnMgfTtcbiAgICB9XG5cbiAgICBpZiAoJ29uRGVzZWxlY3QnIGluIHByb3BzKSB7XG4gICAgICAgIGRlcHJlY2F0ZWQoJ29uRGVzZWxlY3QnLCAnb25TZWxlY3QnLCAnTWVudScpO1xuICAgICAgICBpZiAocHJvcHMub25EZXNlbGVjdCkge1xuICAgICAgICAgICAgY29uc3QgeyBvbkRlc2VsZWN0LCBvblNlbGVjdCwgLi4ub3RoZXJzIH0gPSBwcm9wcztcbiAgICAgICAgICAgIGNvbnN0IG5ld09uU2VsZWN0ID0gKHNlbGVjdGVkS2V5cywgaXRlbSwgZXh0cmEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWV4dHJhLnNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICBvbkRlc2VsZWN0KGV4dHJhLmtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvblNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICBvblNlbGVjdChzZWxlY3RlZEtleXMsIGl0ZW0sIGV4dHJhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBwcm9wcyA9IHsgb25TZWxlY3Q6IG5ld09uU2VsZWN0LCAuLi5vdGhlcnMgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wcztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZ1Byb3ZpZGVyLmNvbmZpZyhNZW51LCB7XG4gICAgdHJhbnNmb3JtXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tZW51L2luZGV4LmpzeCIsImltcG9ydCAnLi4vaWNvbi9zdHlsZS5qcyc7XG5pbXBvcnQgJy4uL2FuaW1hdGUvc3R5bGUuanMnO1xuaW1wb3J0ICcuLi9yYWRpby9zdHlsZS5qcyc7XG5pbXBvcnQgJy4uL2NoZWNrYm94L3N0eWxlLmpzJztcbmltcG9ydCAnLi9tYWluLnNjc3MnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21lbnUvc3R5bGUuanMiLCJpbXBvcnQgJy4uL2ljb24vc3R5bGUuanMnO1xuaW1wb3J0ICcuLi9hbmltYXRlL3N0eWxlLmpzJztcbmltcG9ydCAnLi4vb3ZlcmxheS9zdHlsZS5qcyc7XG5pbXBvcnQgJy4vbWFpbi5zY3NzJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9sb2FkaW5nL3N0eWxlLmpzIiwiaW1wb3J0IENvbmZpZ1Byb3ZpZGVyIGZyb20gJy4uL2NvbmZpZy1wcm92aWRlcic7XG5pbXBvcnQgQmFzZSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHRyZWUgZnJvbSAnLi90cmVlJztcbmltcG9ydCBmaXhlZCBmcm9tICcuL2ZpeGVkJztcbmltcG9ydCBzZWxlY3Rpb24gZnJvbSAnLi9zZWxlY3Rpb24nO1xuaW1wb3J0IGV4cGFuZGVkIGZyb20gJy4vZXhwYW5kZWQnO1xuaW1wb3J0IHZpcnR1YWwgZnJvbSAnLi92aXJ0dWFsJztcbmltcG9ydCBsb2NrIGZyb20gJy4vbG9jayc7XG5pbXBvcnQgbGlzdCBmcm9tICcuL2xpc3QnO1xuaW1wb3J0IHN0aWNreSBmcm9tICcuL3N0aWNreSc7XG5pbXBvcnQgTGlzdEhlYWRlciBmcm9tICcuL2xpc3QtaGVhZGVyJztcbmltcG9ydCBMaXN0Rm9vdGVyIGZyb20gJy4vbGlzdC1mb290ZXInO1xuXG5jb25zdCBPUkRFUl9MSVNUID0gW2ZpeGVkLCBsb2NrLCBzZWxlY3Rpb24sIGV4cGFuZGVkLCB0cmVlLCB2aXJ0dWFsLCBsaXN0LCBzdGlja3ldO1xuY29uc3QgVGFibGUgPSBPUkRFUl9MSVNULnJlZHVjZSgocmV0LCBjdXJyZW50KSA9PiB7XG4gICAgcmV0ID0gY3VycmVudChyZXQpO1xuICAgIHJldHVybiByZXQ7XG59LCBCYXNlKTtcblRhYmxlLkJhc2UgPSBCYXNlO1xuVGFibGUuZml4ZWQgPSBmaXhlZDtcblRhYmxlLmxvY2sgPSBsb2NrO1xuVGFibGUuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuVGFibGUuZXhwYW5kZWQgPSBleHBhbmRlZDtcblRhYmxlLnRyZWUgPSB0cmVlO1xuVGFibGUudmlydHVhbCA9IHZpcnR1YWw7XG5UYWJsZS5saXN0ID0gbGlzdDtcblRhYmxlLnN0aWNreSA9IHN0aWNreTtcblxuVGFibGUuR3JvdXBIZWFkZXIgPSBMaXN0SGVhZGVyO1xuVGFibGUuR3JvdXBGb290ZXIgPSBMaXN0Rm9vdGVyO1xuXG5leHBvcnQgZGVmYXVsdCBDb25maWdQcm92aWRlci5jb25maWcoVGFibGUsIHtcbiAgICBjb21wb25lbnROYW1lOiAnVGFibGUnLFxuICAgIHRyYW5zZm9ybTogKHByb3BzLCBkZXByZWNhdGVkKSA9PiB7XG4gICAgICAgIGlmICgnZXhwYW5kZWRSb3dLZXlzJyBpbiBwcm9wcykge1xuICAgICAgICAgICAgZGVwcmVjYXRlZCgnZXhwYW5kZWRSb3dLZXlzJywgJ29wZW5Sb3dLZXlzJywgJ1RhYmxlJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgZXhwYW5kZWRSb3dLZXlzLCAuLi5vdGhlcnMgfSA9IHByb3BzO1xuICAgICAgICAgICAgcHJvcHMgPSB7IG9wZW5Sb3dLZXlzOiBleHBhbmRlZFJvd0tleXMsIC4uLm90aGVycyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICgnb25FeHBhbmRlZENoYW5nZScgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZWQoJ29uRXhwYW5kZWRDaGFuZ2UnLCAnb25Sb3dPcGVuJywgJ1RhYmxlJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgb25FeHBhbmRlZENoYW5nZSwgLi4ub3RoZXJzIH0gPSBwcm9wcztcbiAgICAgICAgICAgIHByb3BzID0geyBvblJvd09wZW46IG9uRXhwYW5kZWRDaGFuZ2UsIC4uLm90aGVycyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICgnaXNMb2FkaW5nJyBpbiBwcm9wcykge1xuICAgICAgICAgICAgZGVwcmVjYXRlZCgnaXNMb2FkaW5nJywgJ2xvYWRpbmcnLCAnVGFibGUnKTtcblxuICAgICAgICAgICAgY29uc3QgeyBpc0xvYWRpbmcsIC4uLm90aGVycyB9ID0gcHJvcHM7XG4gICAgICAgICAgICBwcm9wcyA9IHsgbG9hZGluZzogaXNMb2FkaW5nLCAuLi5vdGhlcnMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2luZGVudFNpemUnIGluIHByb3BzKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVkKCdpbmRlbnRTaXplJywgJ2luZGVudCcsICdUYWJsZScpO1xuXG4gICAgICAgICAgICBjb25zdCB7IGluZGVudFNpemUsIC4uLm90aGVycyB9ID0gcHJvcHM7XG4gICAgICAgICAgICBwcm9wcyA9IHsgaW5kZW50OiBpbmRlbnRTaXplLCAuLi5vdGhlcnMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ29wdGltaXphdGlvbicgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZWQoJ29wdGltaXphdGlvbicsICdwdXJlJywgJ1RhYmxlJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW1pemF0aW9uLCAuLi5vdGhlcnMgfSA9IHByb3BzO1xuICAgICAgICAgICAgcHJvcHMgPSB7IHB1cmU6IG9wdGltaXphdGlvbiwgLi4ub3RoZXJzIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdnZXRSb3dDbGFzc05hbWUnIGluIHByb3BzKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVkKCdnZXRSb3dDbGFzc05hbWUnLCAnZ2V0Um93UHJvcHMnLCAnVGFibGUnKTtcblxuICAgICAgICAgICAgY29uc3QgeyBnZXRSb3dDbGFzc05hbWUsIGdldFJvd1Byb3BzLCAuLi5vdGhlcnMgfSA9IHByb3BzO1xuICAgICAgICAgICAgaWYgKGdldFJvd0NsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0dldFJvd1Byb3BzID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZ2V0Um93Q2xhc3NOYW1lKC4uLmFyZ3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKGdldFJvd1Byb3BzID8gZ2V0Um93UHJvcHMoLi4uYXJncykgOiB7fSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcHJvcHMgPSB7IGdldFJvd1Byb3BzOiBuZXdHZXRSb3dQcm9wcywgLi4ub3RoZXJzIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3BzID0geyBnZXRSb3dQcm9wcywgLi4ub3RoZXJzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvaW5kZXguanN4IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAnICsgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpICsgJyBhdCBpbmRleCAnICsgaSArICcuJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fcHJvcC10eXBlc0AxNS42LjJAcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX29iamVjdC1hc3NpZ25ANC4xLjFAb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKVxuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX3Byb3AtdHlwZXNAMTUuNi4yQHByb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHNoaW0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBpZiAoc2VjcmV0ID09PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgJ1VzZSBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKSB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgKTtcbiAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB0aHJvdyBlcnI7XG4gIH07XG4gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gICAgcmV0dXJuIHNoaW07XG4gIH07XG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltLFxuICAgIGV4YWN0OiBnZXRTaGltXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBlbXB0eUZ1bmN0aW9uO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19wcm9wLXR5cGVzQDE1LjYuMkBwcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGhvaXN0Tm9uUmVhY3RTdGF0aWMgZnJvbSAnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnO1xuaW1wb3J0IHsgb2JqLCBsb2cgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBnZXRDb250ZXh0UHJvcHMgZnJvbSAnLi9nZXQtY29udGV4dC1wcm9wcyc7XG5cbmNvbnN0IHsgc2hhbGxvd0VxdWFsIH0gPSBvYmo7XG5cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKENvbXBvbmVudCkge1xuICAgIHJldHVybiBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCc7XG59XG5cbmxldCBnbG9iYWxMb2NhbGVzO1xubGV0IGN1cnJlbnRHbG9iYWxMYW5ndWFnZSA9ICd6aC1jbic7XG5sZXQgY3VycmVudEdsb2JhbExvY2FsZSA9IHt9O1xubGV0IGN1cnJlbnRHbG9iYWxSdGwgPSBmYWxzZTtcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRMb2NhbGVzKGxvY2FsZXMpIHtcbiAgICBnbG9iYWxMb2NhbGVzID0gbG9jYWxlcztcbiAgICBjdXJyZW50R2xvYmFsTG9jYWxlID0gbG9jYWxlc1tjdXJyZW50R2xvYmFsTGFuZ3VhZ2VdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0TGFuZ3VhZ2UobGFuZ3VhZ2UpIHtcbiAgICBpZiAoZ2xvYmFsTG9jYWxlcykge1xuICAgICAgICBjdXJyZW50R2xvYmFsTGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgICAgICAgY3VycmVudEdsb2JhbExvY2FsZSA9IGdsb2JhbExvY2FsZXNbbGFuZ3VhZ2VdO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldExvY2FsZShsb2NhbGUpIHtcbiAgICBjdXJyZW50R2xvYmFsTG9jYWxlID0ge1xuICAgICAgICAuLi4oZ2xvYmFsTG9jYWxlcyA/IGdsb2JhbExvY2FsZXNbY3VycmVudEdsb2JhbExhbmd1YWdlXSA6IHt9KSxcbiAgICAgICAgLi4ubG9jYWxlXG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldERpcmVjdGlvbihkaXIpIHtcbiAgICBjdXJyZW50R2xvYmFsUnRsID0gZGlyID09PSAncnRsJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvY2FsZSgpIHtcbiAgICByZXR1cm4gY3VycmVudEdsb2JhbExvY2FsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExhbmd1YWdlKCkge1xuICAgIHJldHVybiBjdXJyZW50R2xvYmFsTGFuZ3VhZ2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRHbG9iYWxSdGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25maWcoQ29tcG9uZW50LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgIG5leHRTdGF0ZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLnB1cmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAhc2hhbGxvd0VxdWFsKHRoaXMucHJvcHMsIG5leHRQcm9wcykgfHxcbiAgICAgICAgICAgICAgICAgICAgIXNoYWxsb3dFcXVhbCh0aGlzLnN0YXRlLCBuZXh0U3RhdGUpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY2xhc3MgQ29uZmlnZWRDb21wb25lbnQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgICAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAgICAgLi4uKENvbXBvbmVudC5wcm9wVHlwZXMgfHwge30pLFxuICAgICAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAgICAgbG9jYWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAgICAgcHVyZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgICAgICBydGw6IFByb3BUeXBlcy5ib29sXG4gICAgICAgIH07XG4gICAgICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgICAgICAgICAuLi4oQ29tcG9uZW50LmNvbnRleHRUeXBlcyB8fCB7fSksXG4gICAgICAgICAgICBuZXh0UHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAgICAgbmV4dExvY2FsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgICAgIG5leHRQdXJlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgICAgIG5leHRSdGw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAgICAgbmV4dFdhcm5pbmc6IFByb3BUeXBlcy5ib29sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgdGhpcy5fZ2V0SW5zdGFuY2UgPSB0aGlzLl9nZXRJbnN0YW5jZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fZGVwcmVjYXRlZCA9IHRoaXMuX2RlcHJlY2F0ZWQuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9nZXRJbnN0YW5jZShyZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gcmVmO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UgJiYgb3B0aW9ucy5leHBvcnROYW1lcykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZXhwb3J0TmFtZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLl9pbnN0YW5jZVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tuYW1lXSA9IGZpZWxkLmJpbmQodGhpcy5faW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tuYW1lXSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfZGVwcmVjYXRlZCguLi5hcmdzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0Lm5leHRXYXJuaW5nICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGxvZy5kZXByZWNhdGVkKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2V0SW5zdGFuY2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByZWZpeCwgbG9jYWxlLCBwdXJlLCBydGwsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBuZXh0UHJlZml4LFxuICAgICAgICAgICAgICAgIG5leHRMb2NhbGUgPSB7fSxcbiAgICAgICAgICAgICAgICBuZXh0UHVyZSxcbiAgICAgICAgICAgICAgICBuZXh0UnRsXG4gICAgICAgICAgICB9ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICAgICAgICBjb25zdCBkaXNwbGF5TmFtZSA9XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb21wb25lbnROYW1lIHx8IGdldERpc3BsYXlOYW1lKENvbXBvbmVudCk7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0UHJvcHMgPSBnZXRDb250ZXh0UHJvcHMoXG4gICAgICAgICAgICAgICAgeyBwcmVmaXgsIGxvY2FsZSwgcHVyZSwgcnRsIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UHJlZml4LFxuICAgICAgICAgICAgICAgICAgICBuZXh0TG9jYWxlOiB7IC4uLmN1cnJlbnRHbG9iYWxMb2NhbGUsIC4uLm5leHRMb2NhbGUgfSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFB1cmUsXG4gICAgICAgICAgICAgICAgICAgIG5leHRSdGw6IHR5cGVvZiBuZXh0UnRsID09PSAnYm9vbGVhbicgPyBuZXh0UnRsIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHbG9iYWxSdGwgPT09IHRydWUgPyB0cnVlIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgbmV3Q29udGV4dFByb3BzID0gWydwcmVmaXgnLCAnbG9jYWxlJywgJ3B1cmUnLCAncnRsJ10ucmVkdWNlKFxuICAgICAgICAgICAgICAgIChyZXQsIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0UHJvcHNbbmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRbbmFtZV0gPSBjb250ZXh0UHJvcHNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHt9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb25zdCBuZXdPdGhlcnMgPSBvcHRpb25zLnRyYW5zZm9ybSA/XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50cmFuc2Zvcm0ob3RoZXJzLCB0aGlzLl9kZXByZWNhdGVkKSA6XG4gICAgICAgICAgICAgICAgb3RoZXJzO1xuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxDb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgey4uLm5ld090aGVyc31cbiAgICAgICAgICAgICAgICAgICAgey4uLm5ld0NvbnRleHRQcm9wc31cbiAgICAgICAgICAgICAgICAgICAgcmVmPXt0aGlzLl9nZXRJbnN0YW5jZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIENvbmZpZ2VkQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gYENvbmZpZygke2dldERpc3BsYXlOYW1lKENvbXBvbmVudCl9KWA7XG5cbiAgICBob2lzdE5vblJlYWN0U3RhdGljKENvbmZpZ2VkQ29tcG9uZW50LCBDb21wb25lbnQpO1xuXG4gICAgcmV0dXJuIENvbmZpZ2VkQ29tcG9uZW50O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbmZpZy1wcm92aWRlci9jb25maWcuanN4IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBjb250ZXh0VHlwZXM6IHRydWUsXG4gICAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIGRpc3BsYXlOYW1lOiB0cnVlLFxuICAgIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHRydWUsXG4gICAgbWl4aW5zOiB0cnVlLFxuICAgIHByb3BUeXBlczogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlXG59O1xuXG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgICBuYW1lOiB0cnVlLFxuICAgIGxlbmd0aDogdHJ1ZSxcbiAgICBwcm90b3R5cGU6IHRydWUsXG4gICAgY2FsbGVyOiB0cnVlLFxuICAgIGNhbGxlZTogdHJ1ZSxcbiAgICBhcmd1bWVudHM6IHRydWUsXG4gICAgYXJpdHk6IHRydWVcbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIG9iamVjdFByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mICYmIGdldFByb3RvdHlwZU9mKE9iamVjdCk7XG5cbmZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBibGFja2xpc3QpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gJ3N0cmluZycpIHsgLy8gZG9uJ3QgaG9pc3Qgb3ZlciBzdHJpbmcgKGh0bWwpIGNvbXBvbmVudHNcblxuICAgICAgICBpZiAob2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgICAgICB2YXIgaW5oZXJpdGVkQ29tcG9uZW50ID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlQ29tcG9uZW50KTtcbiAgICAgICAgICAgIGlmIChpbmhlcml0ZWRDb21wb25lbnQgJiYgaW5oZXJpdGVkQ29tcG9uZW50ICE9PSBvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCwgYmxhY2tsaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFSRUFDVF9TVEFUSUNTW2tleV0gJiYgIUtOT1dOX1NUQVRJQ1Nba2V5XSAmJiAoIWJsYWNrbGlzdCB8fCAhYmxhY2tsaXN0W2tleV0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlQ29tcG9uZW50LCBrZXkpO1xuICAgICAgICAgICAgICAgIHRyeSB7IC8vIEF2b2lkIGZhaWx1cmVzIGZyb20gcmVhZC1vbmx5IHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0Q29tcG9uZW50LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaG9pc3ROb25SZWFjdFN0YXRpY3M7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzQDIuNS41QGhvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2Rpc3QvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MuY2pzLmpzIiwiLyoqXG4gKiDlj5bmtojkuovku7bnu5HlrppcbiAqIEBwYXJhbSAgeyp9ICAgbm9kZSAgICAgICBET03oioLngrnmiJbku7vkvZXlj6/ku6Xnu5Hlrprkuovku7bnmoTlr7nosaFcbiAqIEBwYXJhbSAge1N0cmluZ30gICBldmVudE5hbWUgIOS6i+S7tuWQjVxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrICAg5Zue6LCD5pa55rOVXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgIFt1c2VDYXB0dXJlPWZhbHNlXSDmmK/lkKblvIDlkK/kuovku7bmjZXojrfkvJjlhYhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9mZiAobm9kZSwgZXZlbnROYW1lLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSB8fCBmYWxzZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIOe7keWumuS6i+S7tlxuICogQHBhcmFtICB7Kn0gICBub2RlICAgICAgIERPTeiKgueCueaIluS7u+S9leWPr+S7pee7keWumuS6i+S7tueahOWvueixoVxuICogQHBhcmFtICB7U3RyaW5nfSAgIGV2ZW50TmFtZSAg5LqL5Lu25ZCNXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgICDlm57osIPmlrnms5VcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgdXNlQ2FwdHVyZSDmmK/lkKblvIDlkK/kuovku7bmjZXojrfkvJjlhYhcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICDov5Tlm57nmoRvYmplY3TkuK3ljIXlkKvkuIDkuKpvZmbmlrnms5XvvIznlKjkuo7lj5bmtojkuovku7bnm5HlkKxcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgaGFuZGxlciA9IGV2ZW50cy5vbihkb2N1bWVudC5ib2R5LCAnY2xpY2snLCBlID0+IHtcbiAqICAgICAvLyBoYW5kbGUgY2xpY2sgLi4uXG4gKiB9KTtcbiAqIC8vIOWPlua2iOS6i+S7tue7keWumlxuICogaGFuZGxlci5vZmYoKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uIChub2RlLCBldmVudE5hbWUsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAobm9kZS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrLCB1c2VDYXB0dXJlIHx8IGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBvZmY6ICgpID0+IG9mZihub2RlLCBldmVudE5hbWUsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKVxuICAgIH07XG59XG5cbi8qKlxuICog57uR5a6a5LqL5Lu277yM5Y+q5omn6KGM5LiA5qyh5ZCO6ZSA5q+BXG4gKiBAcGFyYW0gIHsqfSAgIG5vZGUgICAgICAgRE9N6IqC54K55oiW5Lu75L2V5Y+v5Lul57uR5a6a5LqL5Lu255qE5a+56LGhXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgZXZlbnROYW1lICDkuovku7blkI1cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAgIOWbnuiwg+aWueazlVxuICogQHBhcmFtICB7Qm9vbGVhbn0gICB1c2VDYXB0dXJlIOaYr+WQpuW8gOWQr+S6i+S7tuaNleiOt+S8mOWFiFxuICogQHJldHVybiB7RnVuY3Rpb259ICAgICAgICAgICAgIOi/lOWbnueahG9iamVjdOS4reWMheWQq+S4gOS4qm9mZuaWueazle+8jOeUqOS6juWPlua2iOS6i+S7tuebkeWQrFxuICovXG5leHBvcnQgZnVuY3Rpb24gb25jZSAobm9kZSwgZXZlbnROYW1lLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSkge1xuICAgIHJldHVybiBvbihub2RlLCBldmVudE5hbWUsIGZ1bmN0aW9uIF9fZm4gKC4uLmFyZ3MpIHtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAgICAgLy8g55Sx5LqOYWRkRXZlbnRMaXN0ZW5lcuS4reeahOWPguaVsG9wdGlvbnPlj6rlnKhDaHJvbWUgNTXjgIFGaXJlZm94KEdlY2tvKeS7peS4iueJiOacrOaUr+aMge+8jOaVhei/mOaYr+eUqOS8oOe7n+eahOaWueazleWunueOsG9uY2VcbiAgICAgICAgb2ZmKG5vZGUsIGV2ZW50TmFtZSwgX19mbiwgdXNlQ2FwdHVyZSk7XG4gICAgfSwgdXNlQ2FwdHVyZSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbC9ldmVudHMuanMiLCJpbXBvcnQge2lzUHJvbWlzZX0gZnJvbSAnLi9vYmplY3QnO1xuXG4vKipcbiAqIOS4gOS4quepuuaWueazle+8jOi/lOWbnuWFpeWPguacrOi6q+aIluepuuWvueixoVxuICovXG5leHBvcnQgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG4vKipcbiAqIOWwhk7kuKrmlrnms5XlkIjlubbkuLrkuIDkuKrpk77lvI/osIPnlKjnmoTmlrnms5VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAgICAg5ZCI5bm25ZCO55qE5pa55rOVXG4gKiDlj4LogIMgaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0LWNvbXBvbmVudC91dGlsL1xuICpcbiAqIEBleGFtcGxlXG4gKiBmdW5jLm1ha2VDaGFpbih0aGlzLmhhbmRsZUNoYW5nZSwgdGhpcy5wcm9wcy5vbkNoYW5nZSk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQ2hhaW4gKC4uLmZucykge1xuICAgIGlmIChmbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBmbnNbMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWRGdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IGZucy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmbnNbaV0gJiYgZm5zW2ldLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgZm5zW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cblxuLyoqXG4gKiDmibnph4/mlLnlj5jmlrnms5XnmoTkuIrkuIvmlodcbiAqIOatpOaWueazleWcqHJlYWN057uE5Lu25Lit5b6I5pyJ55So77yM5ZyoY29uc3RydWN0b3LkuK3mibnph4/lsIbnu4Tku7bkuIrnmoTmlrnms5XmiafooYzkuIrkuIvmlofnu5HlrprliLDnu4Tku7bmnKzouqtcbiAqIOazqOaEj++8mueUqGJpbmTmlLnlj5jlh73mlbDov5DooYznmoTkuIrkuIvmloflj6rkvJrnlJ/mlYjkuIDmrKFcbiAqIEBwYXJhbSAge09iamVjdH0gY3R4IOaWueazleaMgui9veeahOWvueixoeS7peWPiuaJp+ihjOeahOS4iuS4i+aWh1xuICogQHBhcmFtICB7QXJyYXk8U3RyaW5nPn0gZm5zIOaWueazleWQjeWIl+ihqFxuICpcbiAqIEBleGFtcGxlXG4gKiBmdW5jLmJpbmRDdHgodGhpcywgWydoYW5kbGVDbGljaycsICdoYW5kbGVDaGFuZ2UnXSk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kQ3R4IChjdHgsIGZucywgbnMpIHtcbiAgICBpZiAodHlwZW9mIGZucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm5zID0gW2Zuc107XG4gICAgfVxuXG4gICAgLy8g5pa55rOV55qE5oyC6L2956m66Ze077yM5aaC5p6c5LiN5Lyg77yM6buY6K6k5LiOY3R455u45ZCMXG4gICAgbnMgPSBucyB8fCBjdHg7XG5cbiAgICBmbnMuZm9yRWFjaChmbk5hbWUgPT4ge1xuICAgICAgICAvLyDov5nph4zkuI3opoHmt7vliqDnqbrmlrnms5XliKTmlq3vvIznlLHosIPnlKjogIXkv53or4HmraPnoa7mgKfvvIzlkKbliJnlh7rkuobpl67popjml6Dms5XmjpLmn6VcbiAgICAgICAgbnNbZm5OYW1lXSA9IG5zW2ZuTmFtZV0uYmluZChjdHgpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIOeUqOS6juaJp+ihjOWbnuiwg+aWueazleWQjueahOmAu+i+kVxuICogQHBhcmFtICB7Kn0gcmV0ICAgICAgICAgICAg5Zue6LCD5pa55rOV5omn6KGM57uT5p6cXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gc3VjY2VzcyDmiafooYznu5Pmnpzov5Tlm57pnZ5mYWxzZeeahOWbnuiwg1xuICogQHBhcmFtICB7RnVuY3Rpb259IFtmYWlsdXJlPW5vb3BdIOaJp+ihjOe7k+aenOi/lOWbnmZhbHNl55qE5Zue6LCDXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9taXNlQ2FsbCAocmV0LCBzdWNjZXNzLCBmYWlsdXJlID0gbm9vcCkge1xuICAgIGlmIChpc1Byb21pc2UocmV0KSkge1xuICAgICAgICByZXR1cm4gcmV0LnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIHN1Y2Nlc3MocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgZmFpbHVyZShlKTtcbiAgICAgICAgICAgIC8vIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXQgIT09IGZhbHNlID8gc3VjY2VzcyhyZXQpIDogZmFpbHVyZShyZXQpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWwvZnVuYy5qcyIsImltcG9ydCB7IGlzUHJvZHVjdGlvbiB9IGZyb20gJy4vZW52JztcblxuLyogZXNsaW50IG5vLWNvbnNvbGU6IDAgKi9cblxuLyoqXG4gKiDlj43lr7nkvb/nlKjmn5DkuIDmlrnms5XmiJblsZ7mgKfnmoTorablkYpcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcHMgICAgIOi/h+aXtueahOWxnuaAp+aIluaWueazleWQjVxuICogQHBhcmFtICB7U3RyaW5nfSBpbnN0ZWFkICAg5pu/5Luj55qE5bGe5oCn5oiW5pa55rOV5ZCNXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGNvbXBvbmVudCDnu4Tku7blkI1cbiAqXG4gKiBAZXhhbXBsZVxuICogbG9nLmRlcHJlY2F0ZWQoJ29uQmVmb3JlQ2xvc2UnLCAnYmVmb3JlQ2xvc2UnLCAnRGlhbG9nJyk7XG4gKiAvLyBXYXJuaW5nOiBvbkJlZm9yZUNsb3NlIGlzIGRlcHJlY2F0ZWQgYXQgWyBEaWFsb2cgXSwgdXNlIFsgYmVmb3JlQ2xvc2UgXSBpbnN0ZWFkIG9mIGl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVwcmVjYXRlZCAocHJvcHMsIGluc3RlYWQsIGNvbXBvbmVudCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKCFpc1Byb2R1Y3Rpb24oKSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIGBXYXJuaW5nOiBbICR7cHJvcHN9IF0gaXMgZGVwcmVjYXRlZCBhdCBbICR7Y29tcG9uZW50fSBdLCBgICtcbiAgICAgICAgICAgIGB1c2UgWyAke2luc3RlYWR9IF0gaW5zdGVhZCBvZiBpdC5gXG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIOaOp+WItuWPsOitpuWRiuaXpeW/l1xuICogQHBhcmFtICB7U3RyaW5nfSBtc2dcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdhcm5pbmcgKG1zZykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiAke21zZ31gKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbC9sb2cuanMiLCJpbXBvcnQge2hhc0RPTX0gZnJvbSAnLi9kb20nO1xuaW1wb3J0IHtlYWNofSBmcm9tICcuL29iamVjdCc7XG5cbmNvbnN0IGFuaW1hdGlvbkVuZEV2ZW50TmFtZXMgPSB7XG4gICAgV2Via2l0QW5pbWF0aW9uOiAnd2Via2l0QW5pbWF0aW9uRW5kJyxcbiAgICBPQW5pbWF0aW9uOiAnb0FuaW1hdGlvbkVuZCcsXG4gICAgYW5pbWF0aW9uOiAnYW5pbWF0aW9uZW5kJ1xufTtcblxuY29uc3QgdHJhbnNpdGlvbkV2ZW50TmFtZXMgPSB7XG4gICAgV2Via2l0VHJhbnNpdGlvbjogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgIE9UcmFuc2l0aW9uOiAnb1RyYW5zaXRpb25FbmQnLFxuICAgIHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJ1xufTtcblxuLyoqXG4gKiDmmK/lkKbmlK/mjIHmn5DkupvliqjmlYjkuovku7bvvIzlpoLmnpzmlK/mjIHvvIzov5Tlm57nm7jlupTnmoRlbmTkuovku7blkI1cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtPYmplY3Q8U3RyaW5nPn0gbmFtZXNcbiAqIEByZXR1cm4ge09iamVjdHxmYWxzZX1cbiAqL1xuZnVuY3Rpb24gX3N1cHBvcnRFbmQgKG5hbWVzKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFoYXNET00pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbGV0IHJldCA9IGZhbHNlO1xuXG4gICAgZWFjaChuYW1lcywgKHZhbCwga2V5KSA9PiB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChlbC5zdHlsZVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldCA9IHtlbmQ6IHZhbH07XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICog5piv5ZCm5pSv5oyB5p+Q5LqbQ1NT5bGe5oCnXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7T2JqZWN0PEFycmF5PFN0cmluZz4+fSBuYW1lc1xuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgaXMgc3VwcG9ydFxuICovXG5mdW5jdGlvbiBfc3VwcG9ydENTUyAobmFtZXMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWhhc0RPTSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBsZXQgcmV0ID0gZmFsc2U7XG5cbiAgICBlYWNoKG5hbWVzLCAodmFsLCBrZXkpID0+IHtcbiAgICAgICAgZWFjaCh2YWwsIGl0ZW0gPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZVtrZXldID0gaXRlbTtcbiAgICAgICAgICAgICAgICByZXQgPSByZXQgfHwgZWwuc3R5bGVba2V5XSA9PT0gaXRlbTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCB3aWxsIGJlIHRocm93IGVycm9yIHdoZW4gc2V0IHVua25vd24gcHJvcGVydHkgdW5kZXIgSUU4XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gIXJldDsgLy8g5aaC5p6c5pyJ5LiA5Liq5pSv5oyB5bCx6L+U5ZueZmFsc2XvvIzlkI7pnaLkuI3pnIDopoHlho3liKTmlq1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuICFyZXQ7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIOaYr+WQpuaUr+aMgWFuaW1hdGlvbuS7peWPiuWKqOeUu+e7k+adn+S6i+S7tuWQjVxuICogQHR5cGUge09iamVjdHxmYWxzZX1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBlbmQg5Yqo55S757uT5p2f5LqL5Lu25ZCNXG4gKi9cbmV4cG9ydCBjb25zdCBhbmltYXRpb24gPSBfc3VwcG9ydEVuZChhbmltYXRpb25FbmRFdmVudE5hbWVzKTtcblxuLyoqXG4gKiDmmK/lkKbmlK/mjIF0cmFuc2l0aW9u5Lul5Y+K6L+H5ruk5pWI5p6c57uT5p2f5LqL5Lu25ZCNXG4gKiBAdHlwZSB7T2JqZWN0fGZhbHNlfVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGVuZCDov4fmuKHmlYjmnpznu5PmnZ/kuovku7blkI1cbiAqL1xuZXhwb3J0IGNvbnN0IHRyYW5zaXRpb24gPSBfc3VwcG9ydEVuZCh0cmFuc2l0aW9uRXZlbnROYW1lcyk7XG5cbi8qKlxuICog5piv5ZCm5pSv5oyBZmxleOWxnuaAp1xuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBmbGV4ID0gX3N1cHBvcnRDU1Moe1xuICAgIGRpc3BsYXk6IFsnZmxleCcsICctd2Via2l0LWZsZXgnLCAnLW1vei1mbGV4JywgJy1tcy1mbGV4Ym94J11cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWwvc3VwcG9ydC5qcyIsImltcG9ydCBLRVlDT0RFIGZyb20gJy4va2V5Y29kZSc7XG5pbXBvcnQge2VhY2h9IGZyb20gJy4vb2JqZWN0JztcblxuLyoqXG4gKiDnlKjkuo7liIfmjaLpobXpnaLlhYPntKDnmoTnhKbngrlcbiAqL1xuXG5cbi8qKlxuICog5YWD57Sg5piv5ZCm5Y+v6KeBXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge0VsZW1lbnR9ICBub2RlXG4gKiBAcmV0dXJuICB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gX2lzVmlzaWJsZShub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT09IGRvY3VtZW50LmJvZHkgfHwgbm9kZSA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgfHwgbm9kZS5zdHlsZS52aXNpYmlsaXR5ID09PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIOWFg+e0oOaYr+WQpuWPr+S7peiOt+WPlueEpueCuVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAgIHtFbGVtZW50fSAgbm9kZVxuICogQHJldHVybiAge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIF9pc0ZvY3VzYWJsZShub2RlKSB7XG4gICAgY29uc3Qgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgdGFiSW5kZXggPSBwYXJzZUludChub2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSwgMTApO1xuICAgIGNvbnN0IGhhc1RhYkluZGV4ID0gIWlzTmFOKHRhYkluZGV4KSAmJiB0YWJJbmRleCA+IC0xO1xuXG4gICAgaWYgKF9pc1Zpc2libGUobm9kZSkpIHtcbiAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgICAgICAgICByZXR1cm4gIW5vZGUuZGlzYWJsZWQgJiYgbm9kZS50eXBlICE9PSAnaGlkZGVuJztcbiAgICAgICAgfSBlbHNlIGlmIChbJ3NlbGVjdCcsICd0ZXh0YXJlYScsICdidXR0b24nXS5pbmRleE9mKG5vZGVOYW1lKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gIW5vZGUuZGlzYWJsZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZU5hbWUgPT09ICdhJykge1xuICAgICAgICAgICAgcmV0dXJuIChub2RlLmdldEF0dHJpYnV0ZSgnaHJlZicpIHx8IGhhc1RhYkluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNUYWJJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICog5YiX5Ye66IO96I635Y+W54Sm54K555qE5a2Q6IqC54K5XG4gKiBAcGFyYW0gIHtFbGVtZW50fSBub2RlIOWuueWZqOiKgueCuVxuICogQHJldHVybiB7QXJyYXk8RWxlbWVudD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGb2N1c05vZGVMaXN0KG5vZGUpIHtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBjb25zdCBub2RlTGlzdCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgnKicpO1xuXG4gICAgZWFjaChub2RlTGlzdCwgaXRlbSA9PiB7XG4gICAgICAgIGlmIChfaXNGb2N1c2FibGUoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWF1dG8tZm9jdXMnKSA/ICd1bnNoaWZ0JyA6ICdwdXNoJztcbiAgICAgICAgICAgIHJlc1ttZXRob2RdKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoX2lzRm9jdXNhYmxlKG5vZGUpKSB7XG4gICAgICAgIHJlcy51bnNoaWZ0KG5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIOeUqOS6juiusOW9leS4iuS4gOasoeiOt+W+l+eEpueCueeahOaXoOe0oFxubGV0IGxhc3RGb2N1c0VsZW1lbnQgPSBudWxsO1xuXG4vKipcbiAqIOS/neWtmOacgOi/keS4gOasoeiOt+W+l+eEpueCueeahOaXoOe0oFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2F2ZUxhc3RGb2N1c05vZGUoKSB7XG4gICAgbGFzdEZvY3VzRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG59XG5cbi8qKlxuICog5riF6Zmk54Sm54K56K6w5b2VXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckxhc3RGb2N1c05vZGUoKSB7XG4gICAgbGFzdEZvY3VzRWxlbWVudCA9IG51bGw7XG59XG5cbi8qKlxuICog5bCd6K+V5bCG54Sm54K55YiH5o2i5Yiw5LiK5LiA5Liq5YWD57SgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYWNrTGFzdEZvY3VzTm9kZSgpIHtcbiAgICBpZiAobGFzdEZvY3VzRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8g5YWD57Sg5Y+v6IO95bey57uP6KKr56e75Yqo5LqGXG4gICAgICAgICAgICBsYXN0Rm9jdXNFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSAuLi5cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiDlnKjpmZDliLbnmoTojIPlm7TlhoXliIfmjaLnhKbngrlcbiAqIEBwYXJhbSAge0VsZW1lbnR9IG5vZGUg5a655Zmo6IqC54K5XG4gKiBAcGFyYW0gIHtFdmVudH0gZSAgICAgIOmUruebmOS6i+S7tlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGltaXRUYWJSYW5nZShub2RlLCBlKSB7XG4gICAgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERS5UQUIpIHtcbiAgICAgICAgY29uc3QgdGFiTm9kZUxpc3QgPSBnZXRGb2N1c05vZGVMaXN0KG5vZGUpO1xuICAgICAgICBjb25zdCBtYXhJbmRleCA9IHRhYk5vZGVMaXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGFiTm9kZUxpc3QuaW5kZXhPZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcblxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgbGV0IHRhcmdldEluZGV4ID0gaW5kZXggKyAoZS5zaGlmdEtleSA/IC0xIDogMSk7XG4gICAgICAgICAgICB0YXJnZXRJbmRleCA8IDAgJiYgKHRhcmdldEluZGV4ID0gbWF4SW5kZXgpO1xuICAgICAgICAgICAgdGFyZ2V0SW5kZXggPiBtYXhJbmRleCAmJiAodGFyZ2V0SW5kZXggPSAwKTtcbiAgICAgICAgICAgIHRhYk5vZGVMaXN0W3RhcmdldEluZGV4XS5mb2N1cygpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWwvZm9jdXMuanMiLCJsZXQgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuLyoqXG4gKiDnlJ/miJDlhajlsYDllK/kuIDnmoRpZFxuICogQHBhcmFtICB7U3RyaW5nfSBbcHJlZml4PScnXSDliY3nvIDlrZfnrKbkuLJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqXG4gKiBAZXhhbXBsZVxuICogZ3VpZCgpOyAvLyBqN2p2NTA5Y1xuICogZ3VpZCgncHJlZml4LScpOyAvLyBwcmVmaXgtajdqdjUwOWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICAgIHJldHVybiBwcmVmaXggKyAodGltZXN0YW1wKyspLnRvU3RyaW5nKDM2KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlsL2d1aWQuanMiLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIG9iamVjdCBhbmQga2V5c1xuICogZ2VuZXJhdGVkIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHlcbiAqIG9mIG9iamVjdCB0aHJ1IGl0ZXJhdGVlLlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuY29uc3QgbWFwS2V5cyA9IChvYmosIGZuKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICAgICAgY29uc3QgbmV3S2V5ID0gZm4oa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICByZXN1bHRbbmV3S2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmVwbGFjZSBzcGVjaWZpYyBrZXkgd2l0aCBwcmVmaXggYG5leHRgXG4gKiBhbmQgbG93ZXJjYXNlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgcmVzdWx0LlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5jb25zdCByZXBsYWNlS2V5ID0ga2V5ID0+XG4gICAga2V5LnJlcGxhY2UoL14obmV4dCkoW0EtWl0pLywgKG1hdGNoLCBwMSwgcDIpID0+IHAyLnRvTG93ZXJDYXNlKCkpO1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuY29uc3QgdHJhbnNmb3JtQ29udGV4dCA9IHNvdXJjZSA9PiBtYXBLZXlzKHNvdXJjZSwgcmVwbGFjZUtleSk7XG5cbi8qKlxuICogQ29uc3VtZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5jb25zdCBDb25zdW1lciA9ICh7IGNoaWxkcmVuIH0sIGNvbnRleHQpID0+XG4gICAgdHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nID8gY2hpbGRyZW4odHJhbnNmb3JtQ29udGV4dChjb250ZXh0KSkgOiBudWxsO1xuXG4vKipcbiAqIFByb3BUeXBlc1xuICogQHR5cGUge09iamVjdH1cbiAqIEBzdGF0aWNcbiAqL1xuQ29uc3VtZXIucHJvcFR5cGVzID0ge1xuICAgIC8vIFJlbmRlciBjb250ZXh0IGFzIGZ1bmN0aW9uXG4gICAgLy8gRnVuY3Rpb24oY29udGV4dDogb2JqZWN0KTogUmVhY3RFbGVtZW50XG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5mdW5jXG59O1xuXG4vKipcbiAqIENvbnRleHRUeXBlcyAobGVnYWN5IGNvbnRleHQpXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHN0YXRpY1xuICovXG5Db25zdW1lci5jb250ZXh0VHlwZXMgPSB7XG4gICAgbmV4dFByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBuZXh0TG9jYWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIG5leHRQdXJlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBuZXdSdGw6IFByb3BUeXBlcy5ib29sLFxuICAgIG5leHRXYXJuaW5nOiBQcm9wVHlwZXMuYm9vbFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQ29uc3VtZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29uZmlnLXByb3ZpZGVyL2NvbnN1bWVyLmpzeCIsImNsYXNzIENhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N0b3JlID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcmUuc2l6ZSA9PT0gMDtcbiAgICB9XG5cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9yZS5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICBnZXQoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5oYXMoa2V5KSA/IHRoaXMuX3N0b3JlLmdldChrZXkpIDogdGhpcy5yb290KCk7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHJlcyA9PT0gJ3VuZGVmaW5lZCcgfHwgcmVzID09PSBudWxsKSA/XG4gICAgICAgICAgICBkZWZhdWx0VmFsdWUgOiByZXM7XG4gICAgfVxuXG4gICAgYWRkKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IGtleTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdG9yZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgdXBkYXRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3JlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZShrZXkpIHtcbiAgICAgICAgdGhpcy5fc3RvcmUuZGVsZXRlKGtleSk7XG4gICAgfVxuXG4gICAgcm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlLmdldCh0aGlzLl9yb290KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhY2hlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbmZpZy1wcm92aWRlci9jYWNoZS5qcyIsImlmKHR5cGVvZiB3aW5kb3cubW9tZW50ID09PSAndW5kZWZpbmVkJykge3ZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlIFxcXCJ3aW5kb3cubW9tZW50XFxcIlwiKTsgZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnOyB0aHJvdyBlO31cbm1vZHVsZS5leHBvcnRzID0gd2luZG93Lm1vbWVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIndpbmRvdy5tb21lbnRcIlxuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIDEyIDEzIDE0IDE1IDE2IDE3IDE4IDE5IDIwIDIxIDIyIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBzaGFsbG93RWxlbWVudEVxdWFscyBmcm9tICdzaGFsbG93LWVsZW1lbnQtZXF1YWxzJztcbmltcG9ydCBMb2FkaW5nIGZyb20gJy4uL2xvYWRpbmcnO1xuaW1wb3J0IHpoQ04gZnJvbSAnLi4vbG9jYWxlL3poLWNuJztcbmltcG9ydCB7IGxvZywgb2JqIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgQm9keUNvbXBvbmVudCBmcm9tICcuL2Jhc2UvYm9keSc7XG5pbXBvcnQgSGVhZGVyQ29tcG9uZW50IGZyb20gJy4vYmFzZS9oZWFkZXInO1xuaW1wb3J0IFdyYXBwZXJDb21wb25lbnQgZnJvbSAnLi9iYXNlL3dyYXBwZXInO1xuaW1wb3J0IFJvd0NvbXBvbmVudCBmcm9tICcuL2Jhc2Uvcm93JztcbmltcG9ydCBDZWxsQ29tcG9uZW50IGZyb20gJy4vYmFzZS9jZWxsJztcbmltcG9ydCBGaWx0ZXJDb21wb25lbnQgZnJvbSAnLi9iYXNlL2ZpbHRlcic7XG5pbXBvcnQgU29ydENvbXBvbmVudCBmcm9tICcuL2Jhc2Uvc29ydCc7XG5pbXBvcnQgQ29sdW1uIGZyb20gJy4vY29sdW1uJztcbmltcG9ydCBDb2x1bW5Hcm91cCBmcm9tICcuL2NvbHVtbi1ncm91cCc7XG5cbmNvbnN0IENoaWxkcmVuID0gUmVhY3QuQ2hpbGRyZW4sXG4gICAgbm9vcCA9ICgpID0+IHt9O1xuXG4vLzxUYWJsZT5cbi8vICAgIDxUYWJsZS5Db2x1bW4vPlxuLy8gICAgPFRhYmxlLkNvbHVtbkdyb3VwPlxuLy8gICAgICA8VGFibGUuQ29sdW1uLz5cbi8vICAgICAgPFRhYmxlLkNvbHVtbi8+XG4vLyAgICA8L1RhYmxlLkNvbHVtbkdyb3VwPlxuLy88L1RhYmxlPlxuXG4vKiogVGFibGUgKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhYmxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgQ29sdW1uID0gQ29sdW1uO1xuICAgIHN0YXRpYyBDb2x1bW5Hcm91cCA9IENvbHVtbkdyb3VwO1xuICAgIHN0YXRpYyBIZWFkZXIgPSBIZWFkZXJDb21wb25lbnQ7XG4gICAgc3RhdGljIEJvZHkgPSBCb2R5Q29tcG9uZW50O1xuICAgIHN0YXRpYyBXcmFwcGVyID0gV3JhcHBlckNvbXBvbmVudDtcbiAgICBzdGF0aWMgUm93ID0gUm93Q29tcG9uZW50O1xuICAgIHN0YXRpYyBDZWxsID0gQ2VsbENvbXBvbmVudDtcbiAgICBzdGF0aWMgRmlsdGVyID0gRmlsdGVyQ29tcG9uZW50O1xuICAgIHN0YXRpYyBTb3J0ID0gU29ydENvbXBvbmVudDtcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmoLflvI/nsbvlkI3nmoTlk4HniYzliY3nvIBcbiAgICAgICAgICovXG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcHVyZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnnsbvlkI1cbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieWGheiBlOagt+W8j1xuICAgICAgICAgKi9cbiAgICAgICAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDooajmoLzlsZXnpLrnmoTmlbDmja7mupBcbiAgICAgICAgICovXG4gICAgICAgIGRhdGFTb3VyY2U6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgZW50aXJlRGF0YVNvdXJjZTogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICAvKipcbiAgICAgICAgICog54K55Ye76KGo5qC85q+P5LiA6KGM6Kem5Y+R55qE5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmQg6K+l6KGM5omA5a+55bqU55qE5pWw5o2uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCDor6XooYzmiYDlr7nlupTnmoTluo/liJdcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSBET03kuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIG9uUm93Q2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5oKs5rWu5Zyo6KGo5qC85q+P5LiA6KGM55qE5pe25YCZ6Kem5Y+R55qE5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmQg6K+l6KGM5omA5a+55bqU55qE5pWw5o2uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCDor6XooYzmiYDlr7nlupTnmoTluo/liJdcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSBET03kuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIG9uUm93TW91c2VFbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnprvlvIDooajmoLzmr4/kuIDooYznmoTml7blgJnop6blj5HnmoTkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZCDor6XooYzmiYDlr7nlupTnmoTmlbDmja5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IOivpeihjOaJgOWvueW6lOeahOW6j+WIl1xuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIERPTeS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgb25Sb3dNb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeCueWHu+WIl+aOkuW6j+inpuWPkeeahOS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YUluZGV4IOaMh+WumueahOaOkuW6j+eahOWtl+autVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JkZXIg5o6S5bqP5a+55bqU55qE6aG65bqPLCDmnIlgZGVzY2DlkoxgYXNjYOS4pOenjVxuICAgICAgICAgKi9cbiAgICAgICAgb25Tb3J0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeCueWHu+i/h+a7pOehruiupOaMiemSruinpuWPkeeahOS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZmlsdGVyUGFyYW1zIOi/h+a7pOeahOWtl+auteS/oeaBr1xuICAgICAgICAgKi9cbiAgICAgICAgb25GaWx0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog6YeN6K6+5YiX5bC65a+455qE5pe25YCZ6Kem5Y+R55qE5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhSW5kZXgg5oyH5a6a6YeN6K6+55qE5a2X5q61XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSDliJflrr3lj5jliqjnmoTmlbDlgLxcbiAgICAgICAgICovXG4gICAgICAgIG9uUmVzaXplQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruavj+S4gOihjOeahOWxnuaAp++8jOWmguaenOi/lOWbnuWAvOWSjOWFtuS7lumSiOWvueihjOaTjeS9nOeahOWxnuaAp+WGsueqgeWImeaXoOaViOOAglxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkIOivpeihjOaJgOWvueW6lOeahOaVsOaNrlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXgg6K+l6KGM5omA5a+55bqU55qE5bqP5YiXXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IOmcgOimgeiuvue9rueahOihjOWxnuaAp1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Um93UHJvcHM6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5Y2V5YWD5qC855qE5bGe5oCn77yM6YCa6L+H6K+l5bGe5oCn5Y+v5Lul6L+b6KGM5ZCI5bm25Y2V5YWD5qC8XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSByb3dJbmRleCDor6XooYzmiYDlr7nlupTnmoTluo/liJdcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbEluZGV4IOivpeWIl+aJgOWvueW6lOeahOW6j+WIl1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YUluZGV4IOivpeWIl+aJgOWvueW6lOeahOWtl+auteWQjeensFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkIOivpeihjOWvueW6lOeahOiusOW9lVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSDov5Tlm550ZOWFg+e0oOeahOaJgOaUr+aMgeeahOWxnuaAp+WvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2VsbFByb3BzOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOihqOagvOaYr+WQpuWFt+aciei+ueahhlxuICAgICAgICAgKi9cbiAgICAgICAgaGFzQm9yZGVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOihqOagvOaYr+WQpuWFt+acieWktOmDqFxuICAgICAgICAgKi9cbiAgICAgICAgaGFzSGVhZGVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOihqOagvOaYr+WQpuaYr+aWkemprOe6v1xuICAgICAgICAgKi9cbiAgICAgICAgaXNaZWJyYTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDooajmoLzmmK/lkKblnKjliqDovb3kuK1cbiAgICAgICAgICovXG4gICAgICAgIGxvYWRpbmc6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJIExvYWRpbmcg57uE5Lu2XG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIGxvYWRpbmdDb21wb25lbnQ6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5b2T5YmN6L+H5ruk55qE55qEa2V5cyzkvb/nlKjmraTlsZ7mgKflj6/ku6XmjqfliLbooajmoLznmoTlpLTpg6jnmoTov4fmu6TpgInpobnkuK3lk6rkuKroj5zljZXooqvpgInkuK0s5qC85byP5Li6IHtkYXRhSW5kZXg6IHtzZWxlY3RlZEtleXM6W119fVxuICAgICAgICAgKiDnpLrkvos6XG4gICAgICAgICAqIOWBh+iuvuimgeaOp+WItmRhdGFJbmRleOS4umlk55qE5YiX55qE6L+H5ruk6I+c5Y2V5Lita2V55Li6b25l55qE6I+c5Y2V6aG56YCJ5LitXG4gICAgICAgICAqIGA8VGFibGUgZmlsdGVyUGFyYW1zPXt7aWQ6IHtzZWxlY3RlZEtleXM6IFsnb25lJ119fX0vPmBcbiAgICAgICAgICovXG4gICAgICAgIGZpbHRlclBhcmFtczogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW9k+WJjeaOkuW6j+eahOWtl+autSzkvb/nlKjmraTlsZ7mgKflj6/ku6XmjqfliLbooajmoLznmoTlrZfmrrXnmoTmjpLluo8s5qC85byP5Li6e2RhdGFJbmRleDogJ2FzYyd9XG4gICAgICAgICAqL1xuICAgICAgICBzb3J0OiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ5Zu96ZmF5YyW5paH5qGI5a+56LGhXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBvayDov4fmu6TlmajkuK3noa7orqTmjInpkq7mlofmoYhcbiAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IHJlc2V0IOi/h+a7pOWZqOS4remHjee9ruaMiemSruaWh+ahiFxuICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gZW1wdHkg5rKh5pyJ5pWw5o2u5oOF5Ya15LiLIHRhYmxl5YaF55qE5paH5qGIXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBhc2Mg5o6S5bqP5Y2H5bqP54q25oCB5LiL55qE5paH5qGIXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkZXNjIOaOkuW6j+WwhuW6j+eKtuaAgeS4i+eahOaWh+ahiFxuICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gZXhwYW5kZWQg5Y+v5oqY5Y+g6KGM77yM5bGV5byA54q25oCB5LiL55qE5paH5qGIXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmb2xkZWQg5Y+v5oqY5Y+g6KGM77yM5oqY5Y+g54q25oCB5LiL55qE5paH5qGIXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmaWx0ZXIg6L+H5ruk5Zmo5paH5qGIXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzZWxlY3RBbGwgaGVhZGVy6YeM5YWo6YCJ55qE5oyJ6ZKu5paH5qGIXG4gICAgICAgICAqL1xuICAgICAgICBsb2NhbGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIGNvbXBvbmVudHM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIGNvbHVtbnM6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruaVsOaNruS4uuepuueahOaXtuWAmeeahOihqOagvOWGheWuueWxleeOsFxuICAgICAgICAgKi9cbiAgICAgICAgZW1wdHlDb250ZW50OiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGFTb3VyY2XlvZPkuK3mlbDmja7nmoTkuLvplK7vvIzlpoLmnpznu5nlrprnmoTmlbDmja7mupDkuK3nmoTlsZ7mgKfkuI3ljIXlkKvor6XkuLvplK7vvIzkvJrpgKDmiJDpgInmi6nnirbmgIHlhajpg6jpgInkuK1cbiAgICAgICAgICovXG4gICAgICAgIHByaW1hcnlLZXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGxvY2tUeXBlOiBQcm9wVHlwZXMub25lT2YoWydsZWZ0JywgJ3JpZ2h0J10pLFxuICAgICAgICB3cmFwcGVyQ29udGVudDogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgcmVmczogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmineWklua4suafk+ihjOeahOa4suafk+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkIOivpeihjOaJgOWvueW6lOeahOaVsOaNrlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXgg6K+l6KGM5omA5a+55bqU55qE5bqP5YiXXG4gICAgICAgICAqIEByZXR1cm5zIHtFbGVtZW50fSDmuLLmn5PlhoXlrrlcbiAgICAgICAgICovXG4gICAgICAgIGV4cGFuZGVkUm93UmVuZGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmineWklua4suafk+ihjOeahOe8qei/m1xuICAgICAgICAgKi9cbiAgICAgICAgZXhwYW5kZWRSb3dJbmRlbnQ6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOm7mOiupOaDheWGteS4i+WxleW8gOeahOa4suafk+ihjOaIluiAhVRyZWUsIOS8oOWFpeatpOWxnuaAp+S4uuWPl+aOp+eKtuaAgVxuICAgICAgICAgKi9cbiAgICAgICAgb3BlblJvd0tleXM6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuaYvuekuueCueWHu+WxleW8gOmineWklua4suafk+ihjOeahCvlj7fmjInpkq5cbiAgICAgICAgICovXG4gICAgICAgIGhhc0V4cGFuZGVkUm93Q3RybDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7pop3lpJbmuLLmn5PooYznmoTlsZ7mgKdcbiAgICAgICAgICovXG4gICAgICAgIGdldEV4cGFuZGVkQ29sUHJvcHM6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5Zyo6aKd5aSW5riy5p+T6KGM5oiW6ICFVHJlZeWxleW8gOaIluiAheaUtui1t+eahOaXtuWAmeinpuWPkeeahOS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBvcGVuUm93S2V5cyDlsZXlvIDnmoTmuLLmn5PooYznmoRrZXlcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGN1cnJlbnRSb3dLZXkg5b2T5YmN54K55Ye755qE5riy5p+T6KGM55qEa2V5XG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXhwYW5kZWQg5b2T5YmN54K55Ye75piv5bGV5byA6L+Y5piv5pS26LW3XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdXJyZW50UmVjb3JkIOW9k+WJjeeCueWHu+mineWklua4suafk+ihjOeahOiusOW9lVxuICAgICAgICAgKi9cbiAgICAgICAgb25Sb3dPcGVuOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeCueWHu+mineWklua4suafk+ihjOinpuWPkeeahOS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkIOivpeihjOaJgOWvueW6lOeahOaVsOaNrlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXgg6K+l6KGM5omA5a+55bqU55qE5bqP5YiXXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRE9N5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBvbkV4cGFuZGVkUm93Q2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog6KGo5aS05piv5ZCm5Zu65a6a77yM6K+l5bGe5oCn6YWN5ZCIbWF4Qm9keUhlaWdodOS9v+eUqO+8jOW9k+WGheWuueWMuuWfn+eahOmrmOW6pui2hei/h21heEJvZHlIZWlnaHTnmoTml7blgJnvvIzlnKjlhoXlrrnljLrln5/kvJrlh7rnjrDmu5rliqjmnaFcbiAgICAgICAgICovXG4gICAgICAgIGZpeGVkSGVhZGVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOacgOWkp+WGheWuueWMuuWfn+eahOmrmOW6pizlnKhgZml4ZWRIZWFkZXJg5Li6YHRydWVg55qE5pe25YCZLOi2hei/h+i/meS4qumrmOW6puS8muWHuueOsOa7muWKqOadoVxuICAgICAgICAgKi9cbiAgICAgICAgbWF4Qm9keUhlaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5ZCv55So6YCJ5oup5qih5byPXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGdldFByb3BzIGBGdW5jdGlvbihyZWNvcmQsIGluZGV4KT0+T2JqZWN0YCDojrflj5ZzZWxlY3Rpb27nmoTpu5jorqTlsZ7mgKdcbiAgICAgICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb25DaGFuZ2UgYEZ1bmN0aW9uKHNlbGVjdGVkUm93S2V5czpBcnJheSwgcmVjb3JkczpBcnJheSlgIOmAieaLqeaUueWPmOeahOaXtuWAmeinpuWPkeeahOS6i+S7tu+8jCoq5rOo5oSPOioqIOWFtuS4rXJlY29yZHPlj6rkvJrljIXlkKvlvZPliY1kYXRhU291cmNl55qE5pWw5o2u77yM5b6I5Y+v6IO95Lya5bCP5LqOc2VsZWN0ZWRSb3dLZXlz55qE6ZW/5bqm44CCXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG9uU2VsZWN0IGBGdW5jdGlvbihzZWxlY3RlZDpCb29sZWFuLCByZWNvcmQ6T2JqZWN0LCByZWNvcmRzOkFycmF5KWAg55So5oi35omL5Yqo6YCJ5oupL+WPlua2iOmAieaLqeafkOihjOeahOWbnuiwg1xuICAgICAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvblNlbGVjdEFsbCBgRnVuY3Rpb24oc2VsZWN0ZWQ6Qm9vbGVhbiwgcmVjb3JkczpBcnJheSlgIOeUqOaIt+aJi+WKqOmAieaLqS/lj5bmtojpgInmi6nmiYDmnInooYznmoTlm57osINcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gc2VsZWN0ZWRSb3dLZXlzIOiuvue9ruS6huatpOWxnuaApyzlsIZyb3dTZWxlY3Rpb27lj5jkuLrlj5fmjqfnirbmgIEs5o6l5pS25YC85Li66K+l6KGM5pWw5o2u55qEcHJpbWFyeUtleeeahOWAvFxuICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gbW9kZSDpgInmi6lzZWxlY3Rpb27nmoTmqKHlvI8sIOWPr+mAieWAvOS4umBzaW5nbGVgLCBgbXVsdGlwbGVg77yM6buY6K6k5Li6YG11bHRpcGxlYFxuICAgICAgICAgKi9cbiAgICAgICAgcm93U2VsZWN0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAvKipcbiAgICAgICAgICog6KGo5aS05piv5ZCm5pivc3RpY2t5XG4gICAgICAgICAqL1xuICAgICAgICBzdGlja3lIZWFkZXI6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Led56a756qX5Y+j6aG26YOo6L6+5Yiw5oyH5a6a5YGP56e76YeP5ZCO6Kem5Y+RXG4gICAgICAgICAqL1xuICAgICAgICBvZmZzZXRUb3A6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhZmZpeOe7hOS7tueahOeahOWxnuaAp1xuICAgICAgICAgKi9cbiAgICAgICAgYWZmaXhQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWcqHRyZWXmqKHlvI/kuIvnmoTnvKnov5vlsLrlr7jvvIwg5LuF5ZyoaXNUcmVl5Li6dHJ1ZeaXtuWAmeacieaViFxuICAgICAgICAgKi9cbiAgICAgICAgaW5kZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICog5byA5ZCvVGFibGXnmoR0cmVl5qih5byPLCDmjqXmlLbnmoTmlbDmja7moLzlvI/kuK3ljIXlkKtjaGlsZHJlbuWImea4suafk+aIkHRyZWUgdGFibGVcbiAgICAgICAgICovXG4gICAgICAgIGlzVHJlZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblvIDlkK/omZrmi5/mu5rliqhcbiAgICAgICAgICovXG4gICAgICAgIHVzZVZpcnR1YWw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u6KGM6auYXG4gICAgICAgICAqL1xuICAgICAgICByb3dIZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlnKjlhoXlrrnljLrln5/mu5rliqjnmoTml7blgJnop6blj5HnmoTlh73mlbBcbiAgICAgICAgICovXG4gICAgICAgIG9uQm9keVNjcm9sbDogUHJvcFR5cGVzLmZ1bmNcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgZGF0YVNvdXJjZTogW10sXG4gICAgICAgIG9uUm93Q2xpY2s6IG5vb3AsXG4gICAgICAgIG9uUm93TW91c2VFbnRlcjogbm9vcCxcbiAgICAgICAgb25Sb3dNb3VzZUxlYXZlOiBub29wLFxuICAgICAgICBvblNvcnQ6IG5vb3AsXG4gICAgICAgIG9uRmlsdGVyOiBub29wLFxuICAgICAgICBvblJlc2l6ZUNoYW5nZTogbm9vcCxcbiAgICAgICAgZ2V0Um93UHJvcHM6IG5vb3AsXG4gICAgICAgIGdldENlbGxQcm9wczogbm9vcCxcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgICAgICBoYXNCb3JkZXI6IHRydWUsXG4gICAgICAgIGhhc0hlYWRlcjogdHJ1ZSxcbiAgICAgICAgaXNaZWJyYTogZmFsc2UsXG4gICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICBwcmltYXJ5S2V5OiAnaWQnLFxuICAgICAgICBjb21wb25lbnRzOiB7fSxcbiAgICAgICAgbG9jYWxlOiB6aENOLlRhYmxlXG4gICAgfTtcblxuICAgIHN0YXRpYyBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgbm90UmVuZGVyQ2VsbEluZGV4OiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIGxvY2tUeXBlOiBQcm9wVHlwZXMub25lT2YoWydsZWZ0JywgJ3JpZ2h0J10pXG4gICAgfTtcblxuICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIGdldFRhYmxlSW5zdGFuY2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBnZXRUYWJsZUluc3RhbmNlRm9yVmlydHVhbDogUHJvcFR5cGVzLmZ1bmNcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBjb25zdCB7IGdldFRhYmxlSW5zdGFuY2UsIGdldFRhYmxlSW5zdGFuY2VGb3JWaXJ0dWFsIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGdldFRhYmxlSW5zdGFuY2UgJiYgZ2V0VGFibGVJbnN0YW5jZShwcm9wcy5sb2NrVHlwZSwgdGhpcyk7XG4gICAgICAgIGdldFRhYmxlSW5zdGFuY2VGb3JWaXJ0dWFsICYmXG4gICAgICAgICAgICBnZXRUYWJsZUluc3RhbmNlRm9yVmlydHVhbChwcm9wcy5sb2NrVHlwZSwgdGhpcyk7XG4gICAgICAgIHRoaXMubm90UmVuZGVyQ2VsbEluZGV4ID0gW107XG4gICAgfVxuXG4gICAgc3RhdGUgPSB7XG4gICAgICAgIHNvcnQ6IHRoaXMucHJvcHMuc29ydCB8fCB7fVxuICAgIH07XG5cbiAgICBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub3RSZW5kZXJDZWxsSW5kZXg6IHRoaXMubm90UmVuZGVyQ2VsbEluZGV4LFxuICAgICAgICAgICAgbG9ja1R5cGU6IHRoaXMucHJvcHMubG9ja1R5cGVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMuc29ydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHNvcnQ6IG5leHRQcm9wcy5zb3J0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wcy5wdXJlKSB7XG4gICAgICAgICAgICBjb25zdCBpc0VxdWFsID1cbiAgICAgICAgICAgICAgICBzaGFsbG93RWxlbWVudEVxdWFscyhuZXh0UHJvcHMsIHRoaXMucHJvcHMpICYmXG4gICAgICAgICAgICAgICAgb2JqLnNoYWxsb3dFcXVhbChuZXh0U3RhdGUsIHRoaXMuc3RhdGUpICYmXG4gICAgICAgICAgICAgICAgb2JqLnNoYWxsb3dFcXVhbChuZXh0Q29udGV4dCwgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiAhaXNFcXVhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMubm90UmVuZGVyQ2VsbEluZGV4ID0gW107XG4gICAgfVxuXG4gICAgbm9ybWFsaXplQ2hpbGRyZW5TdGF0ZShwcm9wcykge1xuICAgICAgICBsZXQgY29sdW1ucyA9IHByb3BzLmNvbHVtbnM7XG4gICAgICAgIGlmIChwcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgY29sdW1ucyA9IHRoaXMubm9ybWFsaXplQ2hpbGRyZW4ocHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoSW5mb0Zyb21CaW5hcnlDaGlsZHJlbihjb2x1bW5zKTtcbiAgICB9XG5cbiAgICAvLyDlsIZSZWFjdOe7k+aehOWMluaVsOaNruaPkOWPlnByb3Bz6L2s5o2i5oiQ5pWw57uEXG4gICAgbm9ybWFsaXplQ2hpbGRyZW4ocHJvcHMpIHtcbiAgICAgICAgbGV0IHsgY29sdW1ucyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGdldENoaWxkcmVuID0gY2hpbGRyZW4gPT4ge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICAgICAgICBDaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0geyAuLi5jaGlsZC5wcm9wcyB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY2hpbGQudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjaGlsZC50eXBlLl90eXBlTWFyayA9PT0gJ2NvbHVtbicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQudHlwZS5fdHlwZU1hcmsgPT09ICdjb2x1bW5Hcm91cCcpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLndhcm5pbmcoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VzZSA8VGFibGUuQ29sdW1uLz4sIDxUYWJsZS5Db2x1bW5Hcm91cC8+IGFzIGNoaWxkLidcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2gocHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oY2hpbGQucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbHVtbnMgPSBnZXRDaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbHVtbnM7XG4gICAgfVxuXG4gICAgZmV0Y2hJbmZvRnJvbUJpbmFyeUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBoYXNHcm91cEhlYWRlciA9IGZhbHNlO1xuICAgICAgICBjb25zdCBmbGF0Q2hpbGRyZW4gPSBbXSxcbiAgICAgICAgICAgIGdyb3VwQ2hpbGRyZW4gPSBbXSxcbiAgICAgICAgICAgIGdldENoaWxkcmVuID0gKHByb3BzQ2hpbGRyZW4sIGxldmVsKSA9PiB7XG4gICAgICAgICAgICAgICAgZ3JvdXBDaGlsZHJlbltsZXZlbF0gPSBncm91cENoaWxkcmVuW2xldmVsXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBwcm9wc0NoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0dyb3VwSGVhZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENoaWxkcmVuKGNoaWxkLmNoaWxkcmVuLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhdENoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwQ2hpbGRyZW5bbGV2ZWxdLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENvbFNwYW4gPSAoY2hpbGRyZW4sIGNvbFNwYW4pID0+IHtcbiAgICAgICAgICAgICAgICBjb2xTcGFuID0gY29sU3BhbiB8fCAwO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbFNwYW4gPSBnZXRDb2xTcGFuKGNoaWxkLmNoaWxkcmVuLCBjb2xTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbFNwYW4gKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2xTcGFuO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBnZXRDaGlsZHJlbihjaGlsZHJlbiwgMCk7XG5cbiAgICAgICAgZ3JvdXBDaGlsZHJlbi5mb3JFYWNoKChncm91cENoaWxkLCBpKSA9PiB7XG4gICAgICAgICAgICBncm91cENoaWxkLmZvckVhY2goKGNoaWxkLCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbFNwYW47XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBjaGlsZC5jaGlsZHJlbjtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICBjb2xTcGFuID0gZ2V0Q29sU3BhbihjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmNvbFNwYW4gPSBjb2xTcGFuO1xuICAgICAgICAgICAgICAgICAgICBncm91cENoaWxkcmVuW2ldW2pdID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmbGF0Q2hpbGRyZW4sXG4gICAgICAgICAgICBncm91cENoaWxkcmVuLFxuICAgICAgICAgICAgaGFzR3JvdXBIZWFkZXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZW5kZXJDb2xHcm91cChmbGF0Q2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgY29scyA9IGZsYXRDaGlsZHJlbi5tYXAoKGNvbCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gY29sLndpZHRoO1xuICAgICAgICAgICAgbGV0IHN0eWxlID0ge307XG4gICAgICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIDxjb2wgc3R5bGU9e3N0eWxlfSBrZXk9e2luZGV4fSAvPjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiA8Y29sZ3JvdXAga2V5PVwidGFibGUtY29sZ3JvdXBcIj57Y29sc308L2NvbGdyb3VwPjtcbiAgICB9XG5cbiAgICBvblNvcnQgPSAoZGF0YUluZGV4LCBvcmRlciwgc29ydCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMuc29ydCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzb3J0OiBzb3J0XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Tb3J0KGRhdGFJbmRleCwgb3JkZXIsIHNvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uU29ydChkYXRhSW5kZXgsIG9yZGVyLCBzb3J0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBvbkZpbHRlciA9IGZpbHRlclBhcmFtcyA9PiB7XG4gICAgICAgIHRoaXMucHJvcHMub25GaWx0ZXIoZmlsdGVyUGFyYW1zKTtcbiAgICB9O1xuXG4gICAgb25SZXNpemVDaGFuZ2UgPSAoZGF0YUluZGV4LCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLnByb3BzLm9uUmVzaXplQ2hhbmdlKGRhdGFJbmRleCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICAvLyDpgJrov4flpLTpg6jlkozmiYHlubPnmoTnu5PmnoTmuLLmn5PooajmoLxcbiAgICByZW5kZXJUYWJsZShncm91cENoaWxkcmVuLCBmbGF0Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZmxhdENoaWxkcmVuLmxlbmd0aCB8fFxuICAgICAgICAgICAgKCFmbGF0Q2hpbGRyZW4ubGVuZ3RoICYmICF0aGlzLnByb3BzLmxvY2tUeXBlKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBoYXNIZWFkZXIsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICAgICAgd3JhcHBlckNvbnRlbnQsXG4gICAgICAgICAgICAgICAgZmlsdGVyUGFyYW1zLFxuICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICBkYXRhU291cmNlLFxuICAgICAgICAgICAgICAgIGVtcHR5Q29udGVudCxcbiAgICAgICAgICAgICAgICBsb2FkaW5nLFxuICAgICAgICAgICAgICAgIGdldENlbGxQcm9wcyxcbiAgICAgICAgICAgICAgICBwcmltYXJ5S2V5LFxuICAgICAgICAgICAgICAgIGdldFJvd1Byb3BzLFxuICAgICAgICAgICAgICAgIG9uUm93Q2xpY2ssXG4gICAgICAgICAgICAgICAgb25Sb3dNb3VzZUVudGVyLFxuICAgICAgICAgICAgICAgIG9uUm93TW91c2VMZWF2ZSxcbiAgICAgICAgICAgICAgICBwdXJlXG4gICAgICAgICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGNvbnN0IHsgc29ydCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBIZWFkZXIgPSBIZWFkZXJDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgV3JhcHBlciA9IFdyYXBwZXJDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgQm9keSA9IEJvZHlDb21wb25lbnRcbiAgICAgICAgICAgIH0gPSBjb21wb25lbnRzO1xuICAgICAgICAgICAgY29uc3QgY29sR3JvdXAgPSB0aGlzLnJlbmRlckNvbEdyb3VwKGZsYXRDaGlsZHJlbik7XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPFdyYXBwZXJcbiAgICAgICAgICAgICAgICAgICAgY29sR3JvdXA9e2NvbEdyb3VwfVxuICAgICAgICAgICAgICAgICAgICByZWY9e3RoaXMuZ2V0V3JhcHBlclJlZn1cbiAgICAgICAgICAgICAgICAgICAgcHJlZml4PXtwcmVmaXh9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7aGFzSGVhZGVyID8gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPEhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeD17cHJlZml4fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1cmU9e3B1cmV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZmaXhSZWY9e3RoaXMuZ2V0QWZmaXhSZWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sR3JvdXA9e2NvbEdyb3VwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLWhlYWRlcmB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyUGFyYW1zPXtmaWx0ZXJQYXJhbXN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1ucz17Z3JvdXBDaGlsZHJlbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU9e2xvY2FsZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJDZWxsUmVmPXt0aGlzLmdldEhlYWRlckNlbGxSZWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cz17Y29tcG9uZW50c31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkZpbHRlcj17dGhpcy5vbkZpbHRlcn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0PXtzb3J0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVzaXplQ2hhbmdlPXt0aGlzLm9uUmVzaXplQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU29ydD17dGhpcy5vblNvcnR9XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICApIDogbnVsbH1cbiAgICAgICAgICAgICAgICAgICAgPEJvZHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeD17cHJlZml4fVxuICAgICAgICAgICAgICAgICAgICAgICAgcHVyZT17cHVyZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbEdyb3VwPXtjb2xHcm91cH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLWJvZHlgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cz17Y29tcG9uZW50c31cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmc9e2xvYWRpbmd9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbXB0eUNvbnRlbnQ9e2VtcHR5Q29udGVudH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENlbGxQcm9wcz17Z2V0Q2VsbFByb3BzfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleT17cHJpbWFyeUtleX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFJvd1Byb3BzPXtnZXRSb3dQcm9wc31cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnM9e2ZsYXRDaGlsZHJlbn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd1JlZj17dGhpcy5nZXRSb3dSZWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsUmVmPXt0aGlzLmdldENlbGxSZWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICBvblJvd0NsaWNrPXtvblJvd0NsaWNrfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25Sb3dNb3VzZUVudGVyPXtvblJvd01vdXNlRW50ZXJ9XG4gICAgICAgICAgICAgICAgICAgICAgICBvblJvd01vdXNlTGVhdmU9e29uUm93TW91c2VMZWF2ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFTb3VyY2U9e2RhdGFTb3VyY2V9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU9e2xvY2FsZX1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAge3dyYXBwZXJDb250ZW50fVxuICAgICAgICAgICAgICAgIDwvV3JhcHBlcj5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFdyYXBwZXJSZWYgPSB3cmFwcGVyID0+IHtcbiAgICAgICAgaWYgKCF3cmFwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JhcHBlciA9IHdyYXBwZXI7XG4gICAgfTtcblxuICAgIGdldEFmZml4UmVmID0gKGFmZml4UmVmKSA9PiB7XG4gICAgICAgIGlmICghYWZmaXhSZWYpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFmZml4UmVmO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWZmaXhSZWYgPSBhZmZpeFJlZjtcbiAgICB9O1xuXG4gICAgZ2V0SGVhZGVyQ2VsbFJlZiA9IChpLCBqLCBjZWxsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNlbGxSZWYgPSBgaGVhZGVyX2NlbGxfJHtpfV8ke2p9YDtcbiAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tjZWxsUmVmXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2NlbGxSZWZdID0gY2VsbDtcbiAgICB9O1xuXG4gICAgZ2V0Um93UmVmID0gKGksIHJvdykgPT4ge1xuICAgICAgICBjb25zdCByb3dSZWYgPSBgcm93XyR7aX1gO1xuICAgICAgICBpZiAoIXJvdykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbcm93UmVmXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW3Jvd1JlZl0gPSByb3c7XG4gICAgfTtcblxuICAgIGdldENlbGxSZWYgPSAoaSwgaiwgY2VsbCkgPT4ge1xuICAgICAgICBjb25zdCBjZWxsUmVmID0gYGNlbGxfJHtpfV8ke2p9YDtcbiAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tjZWxsUmVmXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2NlbGxSZWZdID0gY2VsbDtcbiAgICB9O1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB0aGlzLm5vcm1hbGl6ZUNoaWxkcmVuU3RhdGUodGhpcy5wcm9wcyk7XG4gICAgICAgIHRoaXMuZ3JvdXBDaGlsZHJlbiA9IHJldC5ncm91cENoaWxkcmVuO1xuICAgICAgICB0aGlzLmZsYXRDaGlsZHJlbiA9IHJldC5mbGF0Q2hpbGRyZW47XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBwcmVmZXItY29uc3QgKi9cbiAgICAgICAgbGV0IHRhYmxlID0gdGhpcy5yZW5kZXJUYWJsZShyZXQuZ3JvdXBDaGlsZHJlbiwgcmV0LmZsYXRDaGlsZHJlbiksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIGhhc0JvcmRlcixcbiAgICAgICAgICAgICAgICBpc1plYnJhLFxuICAgICAgICAgICAgICAgIGxvYWRpbmcsXG4gICAgICAgICAgICAgICAgaGFzSGVhZGVyLFxuICAgICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgICBkYXRhU291cmNlLFxuICAgICAgICAgICAgICAgIGVudGlyZURhdGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgb25Tb3J0LFxuICAgICAgICAgICAgICAgIG9uUmVzaXplQ2hhbmdlLFxuICAgICAgICAgICAgICAgIG9uUm93Q2xpY2ssXG4gICAgICAgICAgICAgICAgb25Sb3dNb3VzZUVudGVyLFxuICAgICAgICAgICAgICAgIG9uUm93TW91c2VMZWF2ZSxcbiAgICAgICAgICAgICAgICBvbkZpbHRlcixcbiAgICAgICAgICAgICAgICBnZXRSb3dQcm9wcyxcbiAgICAgICAgICAgICAgICBnZXRDZWxsUHJvcHMsXG4gICAgICAgICAgICAgICAgcHJpbWFyeUtleSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLFxuICAgICAgICAgICAgICAgIHdyYXBwZXJDb250ZW50LFxuICAgICAgICAgICAgICAgIGxvY2tUeXBlLFxuICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICByZWZzLFxuICAgICAgICAgICAgICAgIHB1cmUsXG4gICAgICAgICAgICAgICAgcnRsLFxuICAgICAgICAgICAgICAgIGVtcHR5Q29udGVudCxcbiAgICAgICAgICAgICAgICBmaWx0ZXJQYXJhbXMsXG4gICAgICAgICAgICAgICAgbG9hZGluZ0NvbXBvbmVudDogTG9hZGluZ0NvbXBvbmVudCA9IExvYWRpbmcsXG4gICAgICAgICAgICAgICAgLi4ub3RoZXJzXG4gICAgICAgICAgICB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGNscyA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9dGFibGVgXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnb25seS1ib3R0b20tYm9yZGVyJzogIWhhc0JvcmRlcixcbiAgICAgICAgICAgICAgICAnbm8taGVhZGVyJzogIWhhc0hlYWRlcixcbiAgICAgICAgICAgICAgICB6ZWJyYTogaXNaZWJyYSxcbiAgICAgICAgICAgICAgICBbY2xhc3NOYW1lXTogY2xhc3NOYW1lXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgICBvdGhlcnMuZGlyID0gJ3J0bCc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGVudCA9IChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbHN9IHsuLi5vdGhlcnN9PlxuICAgICAgICAgICAgICAgIHt0YWJsZX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgICAgICBpZiAobG9hZGluZykge1xuICAgICAgICAgICAgY29uc3QgbG9hZGluZ0NsYXNzTmFtZSA9IGAke3ByZWZpeH10YWJsZS1sb2FkaW5nYDtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPExvYWRpbmdDb21wb25lbnQgY2xhc3NOYW1lPXtsb2FkaW5nQ2xhc3NOYW1lfT5cbiAgICAgICAgICAgICAgICAgICAge2NvbnRlbnR9XG4gICAgICAgICAgICAgICAgPC9Mb2FkaW5nQ29tcG9uZW50PlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvYmFzZS5qc3giLCJ2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1FbnRyeUVxdWFsKGEsIGIpIHtcbiAgZm9yICh2YXIgayBpbiBhKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYSwgaykpIHtcbiAgICAgIHJldHVybiBhW2tdID09PSBiW2tdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUVxdWFsKGEsIGIpIHtcbiAgaWYgKCghYSAmJiAhYikgfHwgKGEgPT09IGIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFhICE9PSAhYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghdHJhbnNmb3JtRW50cnlFcXVhbChhW2ldLCBiW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc2hhbGxvd09iamVjdEVxdWFscyhhLCBiKSB7XG4gIHZhciBrO1xuICB2YXIgaSA9IDA7XG4gIHZhciBqID0gMDtcbiAgZm9yIChrIGluIGEpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhLCBrKSkge1xuICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgIGNhc2UgJ3RyYW5zZm9ybSc6XG4gICAgICAgICAgaWYgKCF0cmFuc2Zvcm1FcXVhbChhW2tdLCBiW2tdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2hhZG93T2Zmc2V0JzpcbiAgICAgICAgICBpZiAoIXNoYWxsb3dPYmplY3RFcXVhbHMoYVtrXSwgYltrXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGFba10gIT09IGJba10pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICB9XG4gIGZvciAoayBpbiBiKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYiwgaykpIHtcbiAgICAgIGorKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGkgPT09IGo7XG59XG5cbmZ1bmN0aW9uIHN0eWxlRXF1YWwoYSwgYikge1xuICBpZiAoKCFhICYmICFiKSB8fCAoYSA9PT0gYikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIWEgIT09ICFiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIGEpIHtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXN0eWxlRXF1YWwoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzaGFsbG93T2JqZWN0RXF1YWxzKGEsIGIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZUVxdWFsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19zdHlsZS1lcXVhbEAxLjAuMEBzdHlsZS1lcXVhbC9pbmRleC5qcyIsImNvbnN0IG92ZXJsYXlNYW5hZ2VyID0ge1xuICAgIGFsbE92ZXJsYXlzOiBbXSxcblxuICAgIGFkZE92ZXJsYXkob3ZlcmxheSkge1xuICAgICAgICB0aGlzLnJlbW92ZU92ZXJsYXkob3ZlcmxheSk7XG4gICAgICAgIHRoaXMuYWxsT3ZlcmxheXMudW5zaGlmdChvdmVybGF5KTtcbiAgICB9LFxuXG4gICAgaXNDdXJyZW50T3ZlcmxheShvdmVybGF5KSB7XG4gICAgICAgIHJldHVybiBvdmVybGF5ICYmIHRoaXMuYWxsT3ZlcmxheXNbMF0gPT09IG92ZXJsYXk7XG4gICAgfSxcblxuICAgIHJlbW92ZU92ZXJsYXkob3ZlcmxheSkge1xuICAgICAgICBjb25zdCBpID0gdGhpcy5hbGxPdmVybGF5cy5pbmRleE9mKG92ZXJsYXkpO1xuICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmFsbE92ZXJsYXlzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IG92ZXJsYXlNYW5hZ2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL292ZXJsYXkvbWFuYWdlci5qcyIsImltcG9ydCB7ZG9tfSBmcm9tICcuLi8uLi91dGlsJztcblxuY29uc3QgVklFV1BPUlQgPSAndmlld3BvcnQnO1xuXG4vLyBJRTggbm90IHN1cHBvcnQgcGFnZVhPZmZzZXRcbmNvbnN0IGdldFBhZ2VYID0gKCkgPT4gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuY29uc3QgZ2V0UGFnZVkgPSAoKSA9PiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcblxuLyoqXG4gKiBAcHJpdmF0ZSBnZXQgZWxlbWVudCByZWN0XG4gKiBAcGFyYW0gICAgICAge0VsZW1lbnR9IGVsZW1cbiAqIEByZXR1cm4gICAgICB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBfZ2V0RWxlbWVudFJlY3QgKGVsZW0pIHtcbiAgICBsZXQgb2Zmc2V0VG9wID0gMCxcbiAgICAgICAgb2Zmc2V0TGVmdCA9IDA7XG5cbiAgICBjb25zdCBvZmZzZXRIZWlnaHQgPSBlbGVtLm9mZnNldEhlaWdodDtcbiAgICBjb25zdCBvZmZzZXRXaWR0aCA9IGVsZW0ub2Zmc2V0V2lkdGg7XG5cbiAgICBkbyB7XG4gICAgICAgIGlmICghaXNOYU4oZWxlbS5vZmZzZXRUb3ApKSB7XG4gICAgICAgICAgICBvZmZzZXRUb3AgKz0gZWxlbS5vZmZzZXRUb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc05hTihlbGVtLm9mZnNldExlZnQpKSB7XG4gICAgICAgICAgICBvZmZzZXRMZWZ0ICs9IGVsZW0ub2Zmc2V0TGVmdDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKChlbGVtID0gZWxlbS5vZmZzZXRQYXJlbnQpICE9PSBudWxsKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogb2Zmc2V0VG9wIC0gKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3ApLFxuICAgICAgICBsZWZ0OiBvZmZzZXRMZWZ0IC0gKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCksXG4gICAgICAgIGhlaWdodDogb2Zmc2V0SGVpZ2h0LFxuICAgICAgICB3aWR0aDogb2Zmc2V0V2lkdGhcbiAgICB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlIGdldCB2aWV3cG9ydCBzaXplXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIF9nZXRWaWV3cG9ydFNpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgfTtcbn1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc2l0aW9uIHtcblxuICAgIHN0YXRpYyBWSUVXUE9SVCA9IFZJRVdQT1JUO1xuXG4gICAgLyoqXG4gICAgICogQHB1YmxpYyBzdGF0aWMgcGxhY2UgbWV0aG9kXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgICBwcm9wc1xuICAgICAqICAgICBAcGFyYW0gIHtET019ICAgICAgcHJvcHMucGluRWxlbWVudFxuICAgICAqICAgICBAcGFyYW0gIHtET019ICAgICAgcHJvcHMuYmFzZUVsZW1lbnRcbiAgICAgKiAgICAgQHBhcmFtICB7U3RyaW5nfSAgIHByb3BzLmFsaWduXG4gICAgICogICAgIEBwYXJhbSAge051bWJlcn0gICBwcm9wcy5vZmZzZXRcbiAgICAgKiAgICAgQHBhcmFtICB7Qm9vbGVhbn0gIHByb3BzLm5lZWRBZGp1c3RcbiAgICAgKiAgICAgQHBhcmFtICB7Qm9vbGVhbn0gIHByb3BzLmlzUnRsXG4gICAgICogQHJldHVybiB7UG9zaXRpb259XG4gICAgICovXG4gICAgc3RhdGljIHBsYWNlID0gcHJvcHMgPT4gbmV3IFBvc2l0aW9uKHByb3BzKS5zZXRQb3NpdGlvbigpO1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICB0aGlzLnBpbkVsZW1lbnQgPSBwcm9wcy5waW5FbGVtZW50O1xuICAgICAgICB0aGlzLmJhc2VFbGVtZW50ID0gcHJvcHMuYmFzZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMuYWxpZ24gPSBwcm9wcy5hbGlnbiB8fCAndGwgdGwnO1xuICAgICAgICB0aGlzLm9mZnNldCA9IHByb3BzLm9mZnNldCB8fCBbMCwgMF07XG4gICAgICAgIHRoaXMubmVlZEFkanVzdCA9IHByb3BzLm5lZWRBZGp1c3QgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuaXNSdGwgPSBwcm9wcy5pc1J0bCB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICBzZXRQb3NpdGlvbigpIHtcbiAgICAgICAgY29uc3QgcGluRWxlbWVudCA9IHRoaXMucGluRWxlbWVudDtcbiAgICAgICAgY29uc3QgYmFzZUVsZW1lbnQgPSB0aGlzLmJhc2VFbGVtZW50O1xuICAgICAgICBjb25zdCBleHBlY3RlZEFsaWduID0gdGhpcy5fZ2V0RXhwZWN0ZWRBbGlnbigpO1xuICAgICAgICBsZXQgaXNQaW5GaXhlZCwgaXNCYXNlRml4ZWQsIGZpcnN0UG9zaXRpb25SZXN1bHQ7XG4gICAgICAgIGlmIChwaW5FbGVtZW50ID09PSBWSUVXUE9SVCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb20uZ2V0U3R5bGUocGluRWxlbWVudCwgJ3Bvc2l0aW9uJykgIT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZShwaW5FbGVtZW50LCAncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcbiAgICAgICAgICAgIGlzUGluRml4ZWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzUGluRml4ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlRWxlbWVudCA9PT0gVklFV1BPUlQgfHwgZG9tLmdldFN0eWxlKGJhc2VFbGVtZW50LCAncG9zaXRpb24nKSAhPT0gJ2ZpeGVkJykge1xuICAgICAgICAgICAgaXNCYXNlRml4ZWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzQmFzZUZpeGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyDmoLnmja7mnJ/mnJvnmoTlrprkvY1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHBlY3RlZEFsaWduLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhbGlnbiA9IGV4cGVjdGVkQWxpZ25baV07XG4gICAgICAgICAgICBjb25zdCBwaW5FbGVtZW50UG9pbnRzID0gdGhpcy5fbm9ybWFsaXplUG9zaXRpb24ocGluRWxlbWVudCwgYWxpZ24uc3BsaXQoJyAnKVswXSwgaXNQaW5GaXhlZCk7XG4gICAgICAgICAgICBjb25zdCBiYXNlRWxlbWVudFBvaW50cyA9IHRoaXMuX25vcm1hbGl6ZVBvc2l0aW9uKGJhc2VFbGVtZW50LCBhbGlnbi5zcGxpdCgnICcpWzFdLCBpc1BpbkZpeGVkKTtcbiAgICAgICAgICAgIGNvbnN0IHBpbkVsZW1lbnRQYXJlbnRPZmZzZXQgPSB0aGlzLl9nZXRQYXJlbnRPZmZzZXQocGluRWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBiYXNlRWxlbWVudE9mZnNldCA9IChpc1BpbkZpeGVkICYmIGlzQmFzZUZpeGVkKSA/IHRoaXMuX2dldExlZnRUb3AoYmFzZUVsZW1lbnQpIDogYmFzZUVsZW1lbnRQb2ludHMub2Zmc2V0KCk7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSBiYXNlRWxlbWVudE9mZnNldC50b3AgKyBiYXNlRWxlbWVudFBvaW50cy55IC0gcGluRWxlbWVudFBhcmVudE9mZnNldC50b3AgLSBwaW5FbGVtZW50UG9pbnRzLnk7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gYmFzZUVsZW1lbnRPZmZzZXQubGVmdCArIGJhc2VFbGVtZW50UG9pbnRzLnggLSBwaW5FbGVtZW50UGFyZW50T2Zmc2V0LmxlZnQgIC0gcGluRWxlbWVudFBvaW50cy54O1xuICAgICAgICAgICAgdGhpcy5fc2V0UGluRWxlbWVudFBvc3Rpb24ocGluRWxlbWVudCwge2xlZnQsIHRvcH0sIHRoaXMub2Zmc2V0KTtcblxuICAgICAgICAgICAgaWYgKCFmaXJzdFBvc2l0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RQb3NpdGlvblJlc3VsdCA9IHtsZWZ0LCB0b3B9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5WaWV3cG9ydChwaW5FbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbGlnbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGluVmlld3BvcnRMZWZ0ID0gdGhpcy5fbWFrZUVsZW1lbnRJblZpZXdwb3J0KHBpbkVsZW1lbnQsIGZpcnN0UG9zaXRpb25SZXN1bHQubGVmdCwgJ0xlZnQnLCBpc1BpbkZpeGVkKTtcbiAgICAgICAgY29uc3QgaW5WaWV3cG9ydFRvcCA9IHRoaXMuX21ha2VFbGVtZW50SW5WaWV3cG9ydChwaW5FbGVtZW50LCBmaXJzdFBvc2l0aW9uUmVzdWx0LnRvcCwgJ1RvcCcsIGlzUGluRml4ZWQpO1xuXG4gICAgICAgIHRoaXMuX3NldFBpbkVsZW1lbnRQb3N0aW9uKHBpbkVsZW1lbnQsIHtsZWZ0OiBpblZpZXdwb3J0TGVmdCwgdG9wOiBpblZpZXdwb3J0VG9wfSk7XG4gICAgICAgIHJldHVybiBleHBlY3RlZEFsaWduWzBdO1xuICAgIH1cblxuICAgIF9nZXRQYXJlbnRPZmZzZXQoZWxlbWVudCkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIGxldCBvZmZzZXQ7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IGRvY3VtZW50LmJvZHkgJiYgZG9tLmdldFN0eWxlKHBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSB7XG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9nZXRFbGVtZW50T2Zmc2V0KHBhcmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBvZmZzZXQudG9wICs9IHBhcnNlRmxvYXQoZG9tLmdldFN0eWxlKHBhcmVudCwgJ2JvcmRlci10b3Atd2lkdGgnKSwgMTApO1xuICAgICAgICBvZmZzZXQubGVmdCArPSBwYXJzZUZsb2F0KGRvbS5nZXRTdHlsZShwYXJlbnQsICdib3JkZXItbGVmdC13aWR0aCcpLCAxMCk7XG4gICAgICAgIG9mZnNldC5vZmZzZXRQYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgX21ha2VFbGVtZW50SW5WaWV3cG9ydChwaW5FbGVtZW50LCBudW1iZXIsIHR5cGUsIGlzUGluRml4ZWQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bWJlcjtcbiAgICAgICAgY29uc3QgZG9jRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0UGFyZW50ID0gcGluRWxlbWVudC5vZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICAgIGlmIChyZXN1bHQgPCAwKSB7XG4gICAgICAgICAgICBpZiAoaXNQaW5GaXhlZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9mZnNldFBhcmVudCA9PT0gZG9jdW1lbnQuYm9keSAmJiBkb20uZ2V0U3R5bGUob2Zmc2V0UGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHdoZW4gZGl2J3Mgb2Zmc2V0UGFyZW50IGlzIGRvY3VtZW50LmJvZHksIHdlIHNldCBuZXcgcG9zaXRpb24gcmVzdWx0LlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IE1hdGgubWF4KGRvY0VsZW1lbnRbYHNjcm9sbCR7dHlwZX1gXSwgZG9jdW1lbnQuYm9keVtgc2Nyb2xsJHt0eXBlfWBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgX25vcm1hbGl6ZVBvc2l0aW9uKGVsZW1lbnQsIGFsaWduLCBpc1BpbkZpeGVkKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX25vcm1hbGl6ZUVsZW1lbnQoZWxlbWVudCwgaXNQaW5GaXhlZCk7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZVhZKHBvaW50cywgYWxpZ24pO1xuXG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuXG4gICAgX25vcm1hbGl6ZVhZKHBvaW50cywgYWxpZ24pIHtcbiAgICAgICAgY29uc3QgeCA9IGFsaWduLnNwbGl0KCcnKVsxXTtcbiAgICAgICAgY29uc3QgeSA9IGFsaWduLnNwbGl0KCcnKVswXTtcblxuICAgICAgICBwb2ludHMueCA9IHRoaXMuX3h5Q29udmVydGVyKHgsIHBvaW50cywgJ3dpZHRoJyk7XG4gICAgICAgIHBvaW50cy55ID0gdGhpcy5feHlDb252ZXJ0ZXIoeSwgcG9pbnRzLCAnaGVpZ2h0Jyk7XG5cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG5cbiAgICBfeHlDb252ZXJ0ZXIoYWxpZ24sIHBvaW50cywgdHlwZSkge1xuICAgICAgICBjb25zdCByZXMgPSBhbGlnbi5yZXBsYWNlKC90fGwvZ2ksICcwJScpXG4gICAgICAgICAgICAucmVwbGFjZSgvYy9naSwgJzUwJScpXG4gICAgICAgICAgICAucmVwbGFjZSgvYnxyL2dpLCAnMTAwJScpXG4gICAgICAgICAgICAucmVwbGFjZSgvKFxcZCspJS9naSwgZnVuY3Rpb24obSwgZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludHMuc2l6ZSgpW3R5cGVdICogKGQgLyAxMDApO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocmVzLCAxMCkgfHwgMDtcbiAgICB9XG5cbiAgICBfZ2V0TGVmdFRvcChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBwYXJzZUZsb2F0KGRvbS5nZXRTdHlsZShlbGVtZW50LCAnbGVmdCcpKSB8fCAwLFxuICAgICAgICAgICAgdG9wOiBwYXJzZUZsb2F0KGRvbS5nZXRTdHlsZShlbGVtZW50LCAndG9wJykpIHx8IDBcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBfbm9ybWFsaXplRWxlbWVudChlbGVtZW50LCBpc1BpbkZpeGVkKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfSwgaXNWaWV3cG9ydCA9IChlbGVtZW50ID09PSBWSUVXUE9SVCksIGRvY0VsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgcmVzdWx0Lm9mZnNldCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1BpbkZpeGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNWaWV3cG9ydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGdldFBhZ2VYKCksXG4gICAgICAgICAgICAgICAgICAgIHRvcDogZ2V0UGFnZVkoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRFbGVtZW50T2Zmc2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlc3VsdC5zaXplID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogZG9jRWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBkb2NFbGVtZW50LmNsaWVudEhlaWdodFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIF9nZXRFbGVtZW50T2Zmc2V0KGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IGRvY0VsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICBjb25zdCBkb2NDbGllbnRMZWZ0ID0gKGRvY0VsZW1lbnQuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMCk7XG4gICAgICAgIGNvbnN0IGRvY0NsaWVudFRvcCA9IChkb2NFbGVtZW50LmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgKGdldFBhZ2VYKCkgLSBkb2NDbGllbnRMZWZ0KSxcbiAgICAgICAgICAgIHRvcDogcmVjdC50b3AgKyAoZ2V0UGFnZVkoKSAtIGRvY0NsaWVudFRvcClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIGxvY2F0aW9uIG9mIHRoZSBvdmVyZmxvdyB0byBjYWxjdWxhdGUgdGhlIGRlc2lyZWQgcG9zaXRpb25pbmdcbiAgICBfZ2V0RXhwZWN0ZWRBbGlnbigpIHtcbiAgICAgICAgY29uc3QgYWxpZ24gPSB0aGlzLmlzUnRsID8gdGhpcy5fcmVwbGFjZUFsaWduRGlyKHRoaXMuYWxpZ24sIC9sfHIvZywge2w6ICdyJywgcjogJ2wnfSkgOiB0aGlzLmFsaWduO1xuICAgICAgICBjb25zdCBleHBlY3RlZEFsaWduID0gW2FsaWduXTtcblxuICAgICAgICBpZiAodGhpcy5uZWVkQWRqdXN0KSB7XG4gICAgICAgICAgICBpZiAoL3R8Yi9nLnRlc3QoYWxpZ24pKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRBbGlnbi5wdXNoKHRoaXMuX3JlcGxhY2VBbGlnbkRpcihhbGlnbiwgL3R8Yi9nLCB7dDogJ2InLCBiOiAndCd9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoL2x8ci9nLnRlc3QoYWxpZ24pKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRBbGlnbi5wdXNoKHRoaXMuX3JlcGxhY2VBbGlnbkRpcihhbGlnbiwgL2x8ci9nLCB7bDogJ3InLCByOiAnbCd9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoL2MvZy50ZXN0KGFsaWduKSkge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkQWxpZ24ucHVzaCh0aGlzLl9yZXBsYWNlQWxpZ25EaXIoYWxpZ24sIC9jKD89IHwkKS9nLCB7YzogJ2wnfSkpO1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkQWxpZ24ucHVzaCh0aGlzLl9yZXBsYWNlQWxpZ25EaXIoYWxpZ24sIC9jKD89IHwkKS9nLCB7YzogJ3InfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwZWN0ZWRBbGlnbi5wdXNoKHRoaXMuX3JlcGxhY2VBbGlnbkRpcihhbGlnbiwgL2x8cnx0fGIvZywge2w6ICdyJywgcjogJ2wnLCB0OiAnYicsIGI6ICd0J30pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwZWN0ZWRBbGlnbjtcbiAgICB9XG5cbiAgICAvLyBUcmFuc2Zvcm0gYWxpZ24gb3JkZXIuXG4gICAgX3JlcGxhY2VBbGlnbkRpcihhbGlnbiwgcmVnRXhwLCBtYXApIHtcbiAgICAgICAgcmV0dXJuIGFsaWduLnJlcGxhY2UocmVnRXhwLCByZXMgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG1hcFtyZXNdO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEZXRlY3RpbmcgZWxlbWVudCBpcyBpbiB0aGUgd2luZG9377yMIHdlIHdhbnQgdG8gYWRqdXN0IHBvc2l0aW9uIGxhdGVyLlxuICAgIF9pc0luVmlld3BvcnQoZWxlbWVudCkge1xuICAgICAgICBjb25zdCB2aWV3cG9ydFNpemUgPSBfZ2V0Vmlld3BvcnRTaXplKCk7XG4gICAgICAgIC8vIEF2b2lkIGFuaW1hdGUgcHJvYmxlbSB0aGF0IHVzZSBvZmZzZXRXaWR0aCBpbnN0ZWFkIG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdC5cbiAgICAgICAgY29uc3QgZWxlbWVudFJlY3QgPSBfZ2V0RWxlbWVudFJlY3QoZWxlbWVudCk7XG4gICAgICAgIHJldHVybiAoZWxlbWVudFJlY3QubGVmdCA+PSAwICYmIGVsZW1lbnRSZWN0LmxlZnQgKyBlbGVtZW50Lm9mZnNldFdpZHRoIDw9IHZpZXdwb3J0U2l6ZS53aWR0aCAmJlxuICAgICAgICAgICAgZWxlbWVudFJlY3QudG9wID49IDAgJiYgZWxlbWVudFJlY3QudG9wICsgZWxlbWVudC5vZmZzZXRIZWlnaHQgPD0gdmlld3BvcnRTaXplLmhlaWdodCk7XG4gICAgfVxuICAgIC8vIOWcqOi/memHjOWBmlJUTOWIpOaWrSB0b3AtbGVmdCDlrprkvY3ovazljJbkuLrnrYnmlYjnmoQgdG9wLXJpZ2h05a6a5L2NXG4gICAgX3NldFBpbkVsZW1lbnRQb3N0aW9uKHBpbkVsZW1lbnQsIHBvc3Rpb24sIG9mZnNldCA9IFswLCAwXSkge1xuICAgICAgICBjb25zdCB7dG9wLCBsZWZ0fSA9IHBvc3Rpb247XG4gICAgICAgIGlmICghdGhpcy5pc1J0bCkge1xuICAgICAgICAgICAgZG9tLnNldFN0eWxlKHBpbkVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBgJHtsZWZ0ICsgb2Zmc2V0WzBdfXB4YCxcbiAgICAgICAgICAgICAgICB0b3A6IGAke3RvcCArIG9mZnNldFsxXX1weGAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyYW5zZmVyIHtsZWZ0LHRvcH0gZXF1YWx5IHRvIHtyaWdodCx0b3B9XG4gICAgICAgIGNvbnN0IHBpbkVsZW1lbnRQYXJlbnRPZmZzZXQgPSB0aGlzLl9nZXRQYXJlbnRPZmZzZXQocGluRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHt3aWR0aDogb2Zmc2V0UGFyZW50V2lkdGh9ID0gIF9nZXRFbGVtZW50UmVjdChwaW5FbGVtZW50UGFyZW50T2Zmc2V0Lm9mZnNldFBhcmVudCk7XG4gICAgICAgIGNvbnN0IHt3aWR0aH0gPSBfZ2V0RWxlbWVudFJlY3QocGluRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gb2Zmc2V0UGFyZW50V2lkdGggLSAobGVmdCArIHdpZHRoKTtcbiAgICAgICAgZG9tLnNldFN0eWxlKHBpbkVsZW1lbnQsIHtcbiAgICAgICAgICAgIGxlZnQ6ICdhdXRvJyxcbiAgICAgICAgICAgIHJpZ2h0OiBgJHtyaWdodCArIG9mZnNldFswXX1weGAsXG4gICAgICAgICAgICB0b3A6IGAke3RvcCArIG9mZnNldFsxXX1weGAsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9vdmVybGF5L3V0aWxzL3Bvc2l0aW9uLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmaW5kRE9NTm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgZnVuYywgS0VZQ09ERSB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IE92ZXJsYXkgZnJvbSAnLi9vdmVybGF5JztcblxuY29uc3QgeyBub29wLCBtYWtlQ2hhaW4sIGJpbmRDdHggfSA9IGZ1bmM7XG5cbi8qKlxuICogT3ZlcmxheS5Qb3B1cFxuICogQGRlc2NyaXB0aW9uIOe7p+aJvyBPdmVybGF5IOeahCBBUEnvvIzpmaTpnZ7nibnliKvor7TmmI5cbiAqICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3B1cCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Kem5Y+R5by55bGC5pi+56S65oiW6ZqQ6JeP55qE5YWD57SgXG4gICAgICAgICAqL1xuICAgICAgICB0cmlnZ2VyOiBQcm9wVHlwZXMuZWxlbWVudCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOinpuWPkeW8ueWxguaYvuekuuaIlumakOiXj+eahOaTjeS9nOexu+Wei++8jOWPr+S7peaYryAnY2xpY2sn77yMJ2hvdmVyJ++8jCdmb2N1cyfvvIzmiJbogIXlroPku6znu4TmiJDnmoTmlbDnu4TvvIzlpoIgWydob3ZlcicsICdmb2N1cyddXG4gICAgICAgICAqL1xuICAgICAgICB0cmlnZ2VyVHlwZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmFycmF5XSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLlvZPliY3mmK/lkKbmmL7npLpcbiAgICAgICAgICovXG4gICAgICAgIHZpc2libGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC6buY6K6k5piv5ZCm5pi+56S6XG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0VmlzaWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLmmL7npLrmiJbpmpDol4/ml7bop6blj5HnmoTlm57osIPlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlIOW8ueWxguaYr+WQpuaYvuekulxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSDop6blj5HlvLnlsYLmmL7npLrmiJbpmpDol4/nmoTmnaXmupBcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGUgRE9N5LqL5Lu2XG4gICAgICAgICAqL1xuICAgICAgICBvblZpc2libGVDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5q2k5bGe5oCn77yM5by55bGC5peg5rOV5pi+56S65oiW6ZqQ6JePXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLmmL7npLrmiJbpmpDol4/nmoTlu7bml7bml7bpl7TvvIjku6Xmr6vnp5LkuLrljZXkvY3vvInvvIzlnKggdHJpZ2dlclR5cGUg6KKr6K6+572u5Li6IGhvdmVyIOaXtueUn+aViFxuICAgICAgICAgKi9cbiAgICAgICAgZGVsYXk6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDop6blj5HlhYPntKDmmK/lkKblj6/ku6XlhbPpl63lvLnlsYJcbiAgICAgICAgICovXG4gICAgICAgIGNhbkNsb3NlQnlUcmlnZ2VyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguWumuS9jeeahOWPgueFp+WFg+e0oFxuICAgICAgICAgKiBAZGVmYXVsdCB0YXJnZXQg5bGe5oCn77yM5Y2z6Kem5Y+R5YWD57SgXG4gICAgICAgICAqL1xuICAgICAgICB0YXJnZXQ6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIHNhZmVOb2RlOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm6Lef6ZqPdHJpZ2dlcua7muWKqFxuICAgICAgICAgKi9cbiAgICAgICAgZm9sbG93VHJpZ2dlcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGNvbnRhaW5lcjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgaGFzTWFzazogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHdyYXBwZXJTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgcnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgdHJpZ2dlclR5cGU6ICdob3ZlcicsXG4gICAgICAgIGRlZmF1bHRWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgb25WaXNpYmxlQ2hhbmdlOiBub29wLFxuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIGRlbGF5OiAyMDAsXG4gICAgICAgIGNhbkNsb3NlQnlUcmlnZ2VyOiB0cnVlLFxuICAgICAgICBmb2xsb3dUcmlnZ2VyOiBmYWxzZSxcbiAgICAgICAgY29udGFpbmVyOiAoKSA9PiBkb2N1bWVudC5ib2R5LFxuICAgICAgICBydGw6IGZhbHNlLFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHZpc2libGU6IHR5cGVvZiBwcm9wcy52aXNpYmxlID09PSAndW5kZWZpbmVkJyA/IHByb3BzLmRlZmF1bHRWaXNpYmxlIDogcHJvcHMudmlzaWJsZVxuICAgICAgICB9O1xuXG4gICAgICAgIGJpbmRDdHgodGhpcywgW1xuICAgICAgICAgICAgJ2hhbmRsZVRyaWdnZXJDbGljaycsICdoYW5kbGVUcmlnZ2VyS2V5RG93bicsXG4gICAgICAgICAgICAnaGFuZGxlVHJpZ2dlck1vdXNlRW50ZXInLCAnaGFuZGxlVHJpZ2dlck1vdXNlTGVhdmUnLFxuICAgICAgICAgICAgJ2hhbmRsZVRyaWdnZXJGb2N1cycsICdoYW5kbGVUcmlnZ2VyQmx1cicsXG4gICAgICAgICAgICAnaGFuZGxlQ29udGVudE1vdXNlRW50ZXInLCAnaGFuZGxlQ29udGVudE1vdXNlTGVhdmUnLFxuICAgICAgICAgICAgJ2hhbmRsZUNvbnRlbnRNb3VzZURvd24nLCAnaGFuZGxlUmVxdWVzdENsb3NlJyxcbiAgICAgICAgICAgICdoYW5kbGVNYXNrTW91c2VFbnRlcicsICdoYW5kbGVNYXNrTW91c2VMZWF2ZSdcbiAgICAgICAgXSk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKCd2aXNpYmxlJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHZpc2libGU6IG5leHRQcm9wcy52aXNpYmxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBbJ190aW1lcicsICdfaGlkZVRpbWVyJywgJ19zaG93VGltZXInXS5mb3JFYWNoKHRpbWUgPT4ge1xuICAgICAgICAgICAgdGhpc1t0aW1lXSAmJiBjbGVhclRpbWVvdXQodGhpc1t0aW1lXSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGhhbmRsZVZpc2libGVDaGFuZ2UodmlzaWJsZSwgdHlwZSwgZSkge1xuICAgICAgICBpZiAoISgndmlzaWJsZScgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHZpc2libGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vblZpc2libGVDaGFuZ2UodmlzaWJsZSwgdHlwZSwgZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlVHJpZ2dlckNsaWNrKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudmlzaWJsZSAmJiAhdGhpcy5wcm9wcy5jYW5DbG9zZUJ5VHJpZ2dlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYW5kbGVWaXNpYmxlQ2hhbmdlKCF0aGlzLnN0YXRlLnZpc2libGUsICdmcm9tVHJpZ2dlcicsIGUpO1xuICAgIH1cblxuICAgIGhhbmRsZVRyaWdnZXJLZXlEb3duKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERS5TUEFDRSB8fCBlLmtleUNvZGUgPT09IEtFWUNPREUuRU5URVIpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVHJpZ2dlckNsaWNrKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlVHJpZ2dlck1vdXNlRW50ZXIoZSkge1xuICAgICAgICB0aGlzLl9tb3VzZU5vdEZpcnN0T25NYXNrID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuX2hpZGVUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2hpZGVUaW1lcik7XG4gICAgICAgICAgICB0aGlzLl9oaWRlVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zaG93VGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zaG93VGltZXIpO1xuICAgICAgICAgICAgdGhpcy5fc2hvd1RpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc3RhdGUudmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fc2hvd1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVWaXNpYmxlQ2hhbmdlKHRydWUsICdmcm9tVHJpZ2dlcicsIGUpO1xuICAgICAgICAgICAgfSwgdGhpcy5wcm9wcy5kZWxheSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVUcmlnZ2VyTW91c2VMZWF2ZShlLCB0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zaG93VGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zaG93VGltZXIpO1xuICAgICAgICAgICAgdGhpcy5fc2hvd1RpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZS52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9oaWRlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVZpc2libGVDaGFuZ2UoZmFsc2UsIHR5cGUgfHwgJ2Zyb21UcmlnZ2VyJywgZSk7XG4gICAgICAgICAgICB9LCB0aGlzLnByb3BzLmRlbGF5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVRyaWdnZXJGb2N1cyhlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlVmlzaWJsZUNoYW5nZSh0cnVlLCAnZnJvbVRyaWdnZXInLCBlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVUcmlnZ2VyQmx1cihlKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNGb3J3YXJkQ29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVWaXNpYmxlQ2hhbmdlKGZhbHNlLCAnZnJvbVRyaWdnZXInLCBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0ZvcndhcmRDb250ZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaGFuZGxlQ29udGVudE1vdXNlRG93bigpIHtcbiAgICAgICAgdGhpcy5faXNGb3J3YXJkQ29udGVudCA9IHRydWU7XG4gICAgfVxuXG4gICAgaGFuZGxlQ29udGVudE1vdXNlRW50ZXIoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9oaWRlVGltZXIpO1xuICAgIH1cblxuICAgIGhhbmRsZUNvbnRlbnRNb3VzZUxlYXZlKGUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVUcmlnZ2VyTW91c2VMZWF2ZShlLCAnZnJvbUNvbnRlbnQnKTtcbiAgICB9XG5cbiAgICBoYW5kbGVNYXNrTW91c2VFbnRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tb3VzZU5vdEZpcnN0T25NYXNrKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5faGlkZVRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuX2hpZGVUaW1lciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9tb3VzZU5vdEZpcnN0T25NYXNrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVNYXNrTW91c2VMZWF2ZSgpIHtcbiAgICAgICAgdGhpcy5fbW91c2VOb3RGaXJzdE9uTWFzayA9IHRydWU7XG4gICAgfVxuXG4gICAgaGFuZGxlUmVxdWVzdENsb3NlKHR5cGUsIGUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVWaXNpYmxlQ2hhbmdlKGZhbHNlLCB0eXBlLCBlKTtcbiAgICB9XG5cbiAgICByZW5kZXJUcmlnZ2VyKCkge1xuICAgICAgICBjb25zdCB7IHRyaWdnZXIsIGRpc2FibGVkIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgICAgIGtleTogJ3RyaWdnZXInLFxuICAgICAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiB0cnVlLFxuICAgICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiB0aGlzLnN0YXRlLnZpc2libGVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyaWdnZXJUeXBlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgY29uc3QgdHJpZ2dlclR5cGVzID0gQXJyYXkuaXNBcnJheSh0cmlnZ2VyVHlwZSkgPyB0cmlnZ2VyVHlwZSA6IFt0cmlnZ2VyVHlwZV07XG4gICAgICAgICAgICBjb25zdCB7IG9uQ2xpY2ssIG9uS2V5RG93biwgb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmUsIG9uRm9jdXMsIG9uQmx1ciB9ID0gdHJpZ2dlci5wcm9wcztcbiAgICAgICAgICAgIHRyaWdnZXJUeXBlcy5mb3JFYWNoKHRyaWdnZXJUeXBlID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRyaWdnZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLm9uQ2xpY2sgPSBtYWtlQ2hhaW4odGhpcy5oYW5kbGVUcmlnZ2VyQ2xpY2ssIG9uQ2xpY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMub25LZXlEb3duID0gbWFrZUNoYWluKHRoaXMuaGFuZGxlVHJpZ2dlcktleURvd24sIG9uS2V5RG93bik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaG92ZXInIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLm9uTW91c2VFbnRlciA9IG1ha2VDaGFpbih0aGlzLmhhbmRsZVRyaWdnZXJNb3VzZUVudGVyLCBvbk1vdXNlRW50ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMub25Nb3VzZUxlYXZlID0gbWFrZUNoYWluKHRoaXMuaGFuZGxlVHJpZ2dlck1vdXNlTGVhdmUsIG9uTW91c2VMZWF2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9jdXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMub25Gb2N1cyA9IG1ha2VDaGFpbih0aGlzLmhhbmRsZVRyaWdnZXJGb2N1cywgb25Gb2N1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5vbkJsdXIgPSBtYWtlQ2hhaW4odGhpcy5oYW5kbGVUcmlnZ2VyQmx1ciwgb25CbHVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KHRyaWdnZXIsIHByb3BzKTtcbiAgICB9XG5cbiAgICByZW5kZXJDb250ZW50KCkge1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuLCB0cmlnZ2VyVHlwZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgdHJpZ2dlclR5cGVzID0gQXJyYXkuaXNBcnJheSh0cmlnZ2VyVHlwZSkgPyB0cmlnZ2VyVHlwZSA6IFt0cmlnZ2VyVHlwZV07XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBDaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICAgICAgY29uc3QgeyBvbk1vdXNlRG93biwgb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmUgfSA9IGNvbnRlbnQucHJvcHM7XG4gICAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICAgICAga2V5OiAncG9ydGFsJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHRyaWdnZXJUeXBlcy5mb3JFYWNoKHRyaWdnZXJUeXBlID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHJpZ2dlclR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLm9uTW91c2VEb3duID0gbWFrZUNoYWluKHRoaXMuaGFuZGxlQ29udGVudE1vdXNlRG93biwgb25Nb3VzZURvd24pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdob3Zlcic6XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLm9uTW91c2VFbnRlciA9IG1ha2VDaGFpbih0aGlzLmhhbmRsZUNvbnRlbnRNb3VzZUVudGVyLCBvbk1vdXNlRW50ZXIpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5vbk1vdXNlTGVhdmUgPSBtYWtlQ2hhaW4odGhpcy5oYW5kbGVDb250ZW50TW91c2VMZWF2ZSwgb25Nb3VzZUxlYXZlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY29udGVudCwgcHJvcHMpO1xuICAgIH1cblxuICAgIHJlbmRlclBvcnRhbCgpIHtcbiAgICAgICAgY29uc3QgeyB0YXJnZXQsIHNhZmVOb2RlLCBmb2xsb3dUcmlnZ2VyLCB0cmlnZ2VyVHlwZSwgaGFzTWFzaywgd3JhcHBlclN0eWxlLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB7Y29udGFpbmVyfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGZpbmRUcmlnZ2VyTm9kZSA9ICgpID0+IChmaW5kRE9NTm9kZSh0aGlzKSB8fCB7fSk7XG4gICAgICAgIGNvbnN0IHNhZmVOb2RlcyA9IEFycmF5LmlzQXJyYXkoc2FmZU5vZGUpID8gWy4uLnNhZmVOb2RlXSA6IFtzYWZlTm9kZV07XG4gICAgICAgIHNhZmVOb2Rlcy51bnNoaWZ0KGZpbmRUcmlnZ2VyTm9kZSk7XG5cbiAgICAgICAgY29uc3QgbmV3V3JhcHBlclN0eWxlID0gd3JhcHBlclN0eWxlIHx8IHt9O1xuXG4gICAgICAgIGlmIChmb2xsb3dUcmlnZ2VyKSB7XG4gICAgICAgICAgICBjb250YWluZXIgPSB0cmlnZ2VyID0+IHRyaWdnZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIG5ld1dyYXBwZXJTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJpZ2dlclR5cGUgPT09ICdob3ZlcicgJiYgaGFzTWFzaykge1xuICAgICAgICAgICAgb3RoZXJzLm9uTWFza01vdXNlRW50ZXIgPSB0aGlzLmhhbmRsZU1hc2tNb3VzZUVudGVyO1xuICAgICAgICAgICAgb3RoZXJzLm9uTWFza01vdXNlTGVhdmUgPSB0aGlzLmhhbmRsZU1hc2tNb3VzZUxlYXZlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxPdmVybGF5IHsuLi5vdGhlcnN9XG4gICAgICAgICAgICAgICAga2V5PVwib3ZlcmxheVwiXG4gICAgICAgICAgICAgICAgcmVmPXtvdmVybGF5ID0+ICh0aGlzLm92ZXJsYXkgPSBvdmVybGF5KX1cbiAgICAgICAgICAgICAgICB2aXNpYmxlPXt0aGlzLnN0YXRlLnZpc2libGV9XG4gICAgICAgICAgICAgICAgdGFyZ2V0PXt0YXJnZXQgfHwgZmluZFRyaWdnZXJOb2RlfVxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcj17Y29udGFpbmVyfVxuICAgICAgICAgICAgICAgIHNhZmVOb2RlPXtzYWZlTm9kZXN9XG4gICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlPXtuZXdXcmFwcGVyU3R5bGV9XG4gICAgICAgICAgICAgICAgdHJpZ2dlclR5cGU9e3RyaWdnZXJUeXBlfVxuICAgICAgICAgICAgICAgIGhhc01hc2s9e2hhc01hc2t9XG4gICAgICAgICAgICAgICAgb25SZXF1ZXN0Q2xvc2U9e3RoaXMuaGFuZGxlUmVxdWVzdENsb3NlfT5cbiAgICAgICAgICAgICAgICB7dGhpcy5yZW5kZXJDb250ZW50KCl9XG4gICAgICAgICAgICA8L092ZXJsYXk+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJUcmlnZ2VyKCksXG4gICAgICAgICAgICB0aGlzLnJlbmRlclBvcnRhbCgpXG4gICAgICAgIF07XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL292ZXJsYXkvcG9wdXAuanN4IiwiaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50LCBDaGlsZHJlbn0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBPdmVybGF5IGZyb20gJy4uL292ZXJsYXknO1xuaW1wb3J0IENvbmZpZ1Byb3ZpZGVyIGZyb20gJy4uL2NvbmZpZy1wcm92aWRlcic7XG5pbXBvcnQge2Z1bmN9IGZyb20gJy4uL3V0aWwnO1xuXG5jb25zdCB7bm9vcCwgbWFrZUNoYWluLCBiaW5kQ3R4fSA9IGZ1bmM7XG5jb25zdCBQb3B1cCA9IE92ZXJsYXkuUG9wdXA7XG5cbi8qKlxuICogRHJvcGRvd25cbiAqIEBkZXNjcmlwdGlvbiDnu6fmib8gUG9wdXAg55qEIEFQSe+8jOmZpOmdnueJueWIq+ivtOaYjlxuICovXG5jbGFzcyBEcm9wZG93biBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBwdXJlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5YaF5a65XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLlvZPliY3mmK/lkKbmmL7npLpcbiAgICAgICAgICovXG4gICAgICAgIHZpc2libGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC6buY6K6k5piv5ZCm5pi+56S6XG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0VmlzaWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLmmL7npLrmiJbpmpDol4/ml7bop6blj5HnmoTlm57osIPlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlIOW8ueWxguaYr+WQpuaYvuekulxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSDop6blj5HlvLnlsYLmmL7npLrmiJbpmpDol4/nmoTmnaXmupBcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGUgRE9N5LqL5Lu2XG4gICAgICAgICAqL1xuICAgICAgICBvblZpc2libGVDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Kem5Y+R5by55bGC5pi+56S65oiW6ICF6ZqQ6JeP55qE5YWD57SgXG4gICAgICAgICAqL1xuICAgICAgICB0cmlnZ2VyOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOinpuWPkeW8ueWxguaYvuekuuaIlumakOiXj+eahOaTjeS9nOexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlclR5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2hvdmVyJywgJ2NsaWNrJywgJ2ZvY3VzJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5q2k5bGe5oCn77yM5by55bGC5peg5rOV5pi+56S65oiW6ZqQ6JePXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLnm7jlr7nkuo7op6blj5HlhYPntKDnmoTlrprkvY0sIOivpuingSBPdmVybGF5IOeahOWumuS9jemDqOWIhlxuICAgICAgICAgKi9cbiAgICAgICAgYWxpZ246IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLnm7jlr7nkuo7op6blj5HlhYPntKDlrprkvY3nmoTlvq7osINcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNldDogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5pi+56S65oiW6ZqQ6JeP55qE5bu25pe25pe26Ze077yI5Lul5q+r56eS5Li65Y2V5L2N77yJ77yM5ZyoIHRyaWdnZXJUeXBlIOiiq+iuvue9ruS4uiBob3ZlciDml7bnlJ/mlYhcbiAgICAgICAgICovXG4gICAgICAgIGRlbGF5OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5omT5byA5pe25piv5ZCm6K6p5YW25Lit55qE5YWD57Sg6Ieq5Yqo6I635Y+W54Sm54K5XG4gICAgICAgICAqL1xuICAgICAgICBhdXRvRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5pi+56S66YGu572pXG4gICAgICAgICAqL1xuICAgICAgICBoYXNNYXNrOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmakOiXj+aXtuaYr+WQpuS/neeVmeWtkOiKgueCuVxuICAgICAgICAgKi9cbiAgICAgICAgY2FjaGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6YWN572u5Yqo55S755qE5pKt5pS+5pa55byP77yM5pSv5oyBIHsgaW46ICdlbnRlci1jbGFzcycsIG91dDogJ2xlYXZlLWNsYXNzJyB9IOeahOWvueixoeWPguaVsO+8jOWmguaenOiuvue9ruS4uiBmYWxzZe+8jOWImeS4jeaSreaUvuWKqOeUu1xuICAgICAgICAgKiBAZGVmYXVsdCB7IGluOiAnZXhwYW5kSW5Eb3duJywgb3V0OiAnZXhwYW5kT3V0VXAnIH1cbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmJvb2xdKSxcbiAgICB9O1xuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHByZWZpeDogJ25leHQtJyxcbiAgICAgICAgcHVyZTogZmFsc2UsXG4gICAgICAgIGRlZmF1bHRWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgb25WaXNpYmxlQ2hhbmdlOiBub29wLFxuICAgICAgICB0cmlnZ2VyVHlwZTogJ2hvdmVyJyxcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBhbGlnbjogJ3RsIGJsJyxcbiAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXG4gICAgICAgIGRlbGF5OiAyMDAsXG4gICAgICAgIGF1dG9Gb2N1czogdHJ1ZSxcbiAgICAgICAgaGFzTWFzazogZmFsc2UsXG4gICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgb25Qb3NpdGlvbjogbm9vcFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHZpc2libGU6ICd2aXNpYmxlJyBpbiBwcm9wcyA/IHByb3BzLnZpc2libGUgOiAocHJvcHMuZGVmYXVsdFZpc2libGUgfHwgZmFsc2UpXG4gICAgICAgIH07XG5cbiAgICAgICAgYmluZEN0eCh0aGlzLCBbXG4gICAgICAgICAgICAnb25NZW51Q2xpY2snLFxuICAgICAgICAgICAgJ29uVmlzaWJsZUNoYW5nZSdcbiAgICAgICAgXSk7XG4gICAgfVxuXG4gICAgZ2V0VmlzaWJsZShwcm9wcyA9IHRoaXMucHJvcHMpIHtcbiAgICAgICAgcmV0dXJuICd2aXNpYmxlJyBpbiBwcm9wcyA/IHByb3BzLnZpc2libGUgOiB0aGlzLnN0YXRlLnZpc2libGU7XG4gICAgfVxuXG4gICAgb25NZW51Q2xpY2soKSB7XG4gICAgICAgIHRoaXMub25WaXNpYmxlQ2hhbmdlKGZhbHNlLCAnZnJvbUNvbnRlbnQnKTtcbiAgICB9XG5cbiAgICBvblZpc2libGVDaGFuZ2UodmlzaWJsZSwgZnJvbSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHt2aXNpYmxlfSk7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vblZpc2libGVDaGFuZ2UodmlzaWJsZSwgZnJvbSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgY2hpbGQgPSBDaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICBpZiAodHlwZW9mIGNoaWxkLnR5cGUgPT09ICdmdW5jdGlvbicgJiYgY2hpbGQudHlwZS5pc05leHRNZW51KSB7XG4gICAgICAgICAgICBjaGlsZCA9IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgICAgICAgIG9uSXRlbUNsaWNrOiBtYWtlQ2hhaW4odGhpcy5vbk1lbnVDbGljaywgY2hpbGQucHJvcHMub25JdGVtQ2xpY2spXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8UG9wdXAgey4uLnRoaXMucHJvcHN9XG4gICAgICAgICAgICAgICAgdmlzaWJsZT17dGhpcy5nZXRWaXNpYmxlKCl9XG4gICAgICAgICAgICAgICAgb25WaXNpYmxlQ2hhbmdlPXt0aGlzLm9uVmlzaWJsZUNoYW5nZX1cbiAgICAgICAgICAgICAgICBjYW5DbG9zZUJ5T3V0U2lkZUNsaWNrPntjaGlsZH08L1BvcHVwPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlnUHJvdmlkZXIuY29uZmlnKERyb3Bkb3duKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9kcm9wZG93bi9pbmRleC5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBDaGlsZHJlbiwgY2xvbmVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBBbmltYXRlIGZyb20gJy4uLy4uL2FuaW1hdGUnO1xuaW1wb3J0IEljb24gZnJvbSAnLi4vLi4vaWNvbic7XG5pbXBvcnQgeyBmdW5jLCBvYmogfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCBJdGVtIGZyb20gJy4vaXRlbSc7XG5pbXBvcnQgU2VsZWN0YWJlbEl0ZW0gZnJvbSAnLi9zZWxlY3RhYmxlLWl0ZW0nO1xuaW1wb3J0IFBvcHVwSXRlbSBmcm9tICcuL3BvcHVwLWl0ZW0nO1xuXG5jb25zdCB7IEV4cGFuZCB9ID0gQW5pbWF0ZTtcbmNvbnN0IHsgYmluZEN0eCB9ID0gZnVuYztcblxuLyoqXG4gKiBNZW51LlN1Yk1lbnVcbiAqIEBvcmRlciAxXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN1Yk1lbnUgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBtZW51Q2hpbGRUeXBlID0gJ3N1Ym1lbnUnO1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgX2tleTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcm9vdDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgbGV2ZWw6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGdyb3VwSW5kZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICog5qCH562+5YaF5a65XG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblj6/pgInvvIzor6XlsZ7mgKfku4XlnKjorr7nva4gTWVudSDnu4Tku7Ygc2VsZWN0TW9kZSDlsZ7mgKflkI7nlJ/mlYhcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGFibGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5a2Q6I+c5Y2V5omT5byA5pa55byP77yM5aaC5p6c6K6+572u5Lya6KaG55uWIE1lbnUg5LiK55qE5ZCM5ZCN5bGe5oCnXG4gICAgICAgICAqIEBkZWZhdWx0IE1lbnUg55qEIG1vZGUg5bGe5oCn5YC8XG4gICAgICAgICAqL1xuICAgICAgICBtb2RlOiBQcm9wVHlwZXMub25lT2YoWydpbmxpbmUnLCAncG9wdXAnXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoj5zljZXpobnmiJbkuIvkuIDnuqflrZDoj5zljZVcbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgb25Nb3VzZUVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgc3ViTWVudUNvbnRlbnRDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHRyaWdnZXJUeXBlOiBQcm9wVHlwZXMub25lT2YoWydjbGljaycsICdob3ZlciddKSxcbiAgICAgICAgYWxpZ246IFByb3BUeXBlcy5vbmVPZihbJ291dHNpZGUnLCAnZm9sbG93J10pLFxuICAgICAgICBwYXJlbnRNb2RlOiBQcm9wVHlwZXMub25lT2YoWydpbmxpbmUnLCAncG9wdXAnXSlcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgZ3JvdXBJbmRlbnQ6IDAsXG4gICAgICAgIHNlbGVjdGFibGU6IGZhbHNlXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICBiaW5kQ3R4KHRoaXMsIFtcbiAgICAgICAgICAgICdoYW5kbGVNb3VzZUVudGVyJywgJ2hhbmRsZU1vdXNlTGVhdmUnLCAnaGFuZGxlQ2xpY2snLFxuICAgICAgICAgICAgJ2hhbmRsZU9wZW4nLCAnYWZ0ZXJMZWF2ZSdcbiAgICAgICAgXSk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuaXRlbU5vZGUgPSBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgICB9XG5cbiAgICBhZnRlckxlYXZlKCkge1xuICAgICAgICBjb25zdCB7IGZvY3VzZWQsIHJvb3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgZm9jdXNhYmxlIH0gPSByb290LnByb3BzO1xuICAgICAgICBpZiAoZm9jdXNhYmxlICYmIGZvY3VzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbU5vZGUuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldE9wZW4oKSB7XG4gICAgICAgIGNvbnN0IHsgX2tleSwgcm9vdCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBvcGVuS2V5cyB9ID0gcm9vdC5zdGF0ZTtcblxuICAgICAgICByZXR1cm4gb3BlbktleXMuaW5kZXhPZihfa2V5KSA+IC0xO1xuICAgIH1cblxuICAgIGhhbmRsZU1vdXNlRW50ZXIoZSkge1xuICAgICAgICB0aGlzLmhhbmRsZU9wZW4odHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vbk1vdXNlRW50ZXIgJiYgdGhpcy5wcm9wcy5vbk1vdXNlRW50ZXIoZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlTW91c2VMZWF2ZShlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlT3BlbihmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vbk1vdXNlTGVhdmUgJiYgdGhpcy5wcm9wcy5vbk1vdXNlTGVhdmUoZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlQ2xpY2soZSkge1xuICAgICAgICBjb25zdCB7IHJvb3QsIHNlbGVjdGFibGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0TW9kZSB9ID0gcm9vdC5wcm9wcztcbiAgICAgICAgaWYgKHNlbGVjdE1vZGUgJiYgc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9wZW4gPSB0aGlzLmdldE9wZW4oKTtcbiAgICAgICAgdGhpcy5oYW5kbGVPcGVuKCFvcGVuKTtcbiAgICB9XG5cbiAgICBoYW5kbGVPcGVuKG9wZW4sIHRyaWdnZXJUeXBlLCBlKSB7XG4gICAgICAgIGNvbnN0IHsgX2tleSwgcm9vdCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgcm9vdC5oYW5kbGVPcGVuKF9rZXksIG9wZW4sIHRyaWdnZXJUeXBlLCBlKTtcbiAgICB9XG5cbiAgICBwYXNzUGFyZW50VG9DaGlsZHJlbihjaGlsZHJlbikge1xuICAgICAgICBjb25zdCB7IG1vZGUsIHJvb3QgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgcmV0dXJuIENoaWxkcmVuLm1hcChjaGlsZHJlbiwgY2hpbGQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgICAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgICAgICAgICAgICBwYXJlbnRNb2RlOiBtb2RlIHx8IHJvb3QucHJvcHMubW9kZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbmRlcklubGluZSgpIHtcbiAgICAgICAgY29uc3QgeyBfa2V5LCBsZXZlbCwgcm9vdCwgY2xhc3NOYW1lLCBzZWxlY3RhYmxlOiBzZWxlY3RhYmxlRnJvbVByb3BzLCBsYWJlbCwgY2hpbGRyZW4sIHN1Yk1lbnVDb250ZW50Q2xhc3NOYW1lLCB0cmlnZ2VyVHlwZTogcHJvcHNUcmlnZ2VyVHlwZSwgcGFyZW50TW9kZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHNlbGVjdE1vZGUsIHRyaWdnZXJUeXBlOiByb290VHJpZ2dlclR5cGUsIGlubGluZUFycm93RGlyZWN0aW9uLCBleHBhbmRBbmltYXRpb24sIHJ0bCB9ID0gcm9vdC5wcm9wcztcbiAgICAgICAgY29uc3QgdHJpZ2dlclR5cGUgPSBwcm9wc1RyaWdnZXJUeXBlIHx8IHJvb3RUcmlnZ2VyVHlwZTtcbiAgICAgICAgY29uc3Qgb3BlbiA9IHRoaXMuZ2V0T3BlbigpO1xuICAgICAgICBjb25zdCBvdGhlcnMgPSBvYmoucGlja090aGVycyhPYmplY3Qua2V5cyhTdWJNZW51LnByb3BUeXBlcyksIHRoaXMucHJvcHMpO1xuXG4gICAgICAgIGNvbnN0IGxpUHJvcHMgPSB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IGN4KHtcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4fW1lbnUtc3ViLW1lbnUtd3JhcHBlcmBdOiB0cnVlLFxuICAgICAgICAgICAgICAgIFtjbGFzc05hbWVdOiAhIWNsYXNzTmFtZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaXRlbVByb3BzID0ge1xuICAgICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBvcGVuLFxuICAgICAgICAgICAgX2tleSxcbiAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIHR5cGU6ICdzdWJtZW51JyxcbiAgICAgICAgICAgIGNvbXBvbmVudDogJ2RpdicsXG4gICAgICAgICAgICBwYXJlbnRNb2RlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFycm9yUHJvcHMgPSB7XG4gICAgICAgICAgICB0eXBlOiBpbmxpbmVBcnJvd0RpcmVjdGlvbiA9PT0gJ3JpZ2h0JyA/ICdhcnJvdy1yaWdodCcgOiAnYXJyb3ctZG93bicsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGN4KHtcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4fW1lbnUtaWNvbi1hcnJvd2BdOiB0cnVlLFxuICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9bWVudS1pY29uLWFycm93LWRvd25gXTogaW5saW5lQXJyb3dEaXJlY3Rpb24gPT09ICdkb3duJyxcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4fW1lbnUtaWNvbi1hcnJvdy1yaWdodGBdOiBpbmxpbmVBcnJvd0RpcmVjdGlvbiA9PT0gJ3JpZ2h0JyxcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4fW9wZW5gXTogb3BlblxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBzZWxlY3RhYmxlID0gISFzZWxlY3RNb2RlICYmIHNlbGVjdGFibGVGcm9tUHJvcHM7XG4gICAgICAgIGNvbnN0IE5ld0l0ZW0gPSBzZWxlY3RhYmxlID8gU2VsZWN0YWJlbEl0ZW0gOiBJdGVtO1xuXG4gICAgICAgIGlmICh0cmlnZ2VyVHlwZSA9PT0gJ2hvdmVyJykge1xuICAgICAgICAgICAgbGlQcm9wcy5vbk1vdXNlRW50ZXIgPSB0aGlzLmhhbmRsZU1vdXNlRW50ZXI7XG4gICAgICAgICAgICBsaVByb3BzLm9uTW91c2VMZWF2ZSA9IHRoaXMuaGFuZGxlTW91c2VMZWF2ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICBhcnJvclByb3BzLm9uQ2xpY2sgPSB0aGlzLmhhbmRsZUNsaWNrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbVByb3BzLm9uQ2xpY2sgPSB0aGlzLmhhbmRsZUNsaWNrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICBpdGVtUHJvcHMuY2xhc3NOYW1lID0gYCR7cHJlZml4fW9wZW5lZGA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdTdWJNZW51Q29udGVudENsYXNzTmFtZSA9IGN4KHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9bWVudS1zdWItbWVudWBdOiB0cnVlLFxuICAgICAgICAgICAgW3N1Yk1lbnVDb250ZW50Q2xhc3NOYW1lXTogISFzdWJNZW51Q29udGVudENsYXNzTmFtZVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBzdWJNZW51ID0gb3BlbiA/IChcbiAgICAgICAgICAgIDx1bCByb2xlPVwibWVudVwiIGRpcj17cnRsID8gJ3J0bCcgOiB1bmRlZmluZWR9IHJlZj1cInN1Yk1lbnVcIiBjbGFzc05hbWU9e25ld1N1Yk1lbnVDb250ZW50Q2xhc3NOYW1lfT5cbiAgICAgICAgICAgICAgICB7dGhpcy5wYXNzUGFyZW50VG9DaGlsZHJlbihjaGlsZHJlbil9XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICApIDogbnVsbDtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGxpIHsuLi5vdGhlcnN9IHsuLi5saVByb3BzfT5cbiAgICAgICAgICAgICAgICA8TmV3SXRlbSB7Li4uaXRlbVByb3BzfT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtgJHtwcmVmaXh9bWVudS1pdGVtLXRleHRgfT57bGFiZWx9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8SWNvbiB7Li4uYXJyb3JQcm9wc30gLz5cbiAgICAgICAgICAgICAgICA8L05ld0l0ZW0+XG4gICAgICAgICAgICAgICAge2V4cGFuZEFuaW1hdGlvbiA/IChcbiAgICAgICAgICAgICAgICAgICAgPEV4cGFuZCBhbmltYXRpb25BcHBlYXI9e2ZhbHNlfSBhZnRlckxlYXZlPXt0aGlzLmFmdGVyTGVhdmV9PlxuICAgICAgICAgICAgICAgICAgICAgICAge3N1Yk1lbnV9XG4gICAgICAgICAgICAgICAgICAgIDwvRXhwYW5kPlxuICAgICAgICAgICAgICAgICkgOiBzdWJNZW51fVxuXG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJlbmRlclBvcHVwKCkge1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuLCBzdWJNZW51Q29udGVudENsYXNzTmFtZSwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCByb290ID0gdGhpcy5wcm9wcy5yb290O1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgcG9wdXBDbGFzc05hbWUsIHBvcHVwU3R5bGUsIHJ0bCB9ID0gcm9vdC5wcm9wcztcblxuICAgICAgICBjb25zdCBuZXdDbGFzc05hbWUgPSBjeCh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fW1lbnVgXTogdHJ1ZSxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9dmVyYF06IHRydWUsXG4gICAgICAgICAgICBbcG9wdXBDbGFzc05hbWVdOiAhIXBvcHVwQ2xhc3NOYW1lLFxuICAgICAgICAgICAgW3N1Yk1lbnVDb250ZW50Q2xhc3NOYW1lXTogISFzdWJNZW51Q29udGVudENsYXNzTmFtZVxuICAgICAgICB9KTtcblxuICAgICAgICBvdGhlcnMucnRsID0gcnRsO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8UG9wdXBJdGVtIHsuLi5vdGhlcnN9IGhhc1N1Yk1lbnU+XG4gICAgICAgICAgICAgICAgPHVsIHJvbGU9XCJtZW51XCIgZGlyPXtydGwgPyAncnRsJyA6IHVuZGVmaW5lZH0gY2xhc3NOYW1lPXtuZXdDbGFzc05hbWV9IHN0eWxlPXtwb3B1cFN0eWxlfT5cbiAgICAgICAgICAgICAgICAgICAge3RoaXMucGFzc1BhcmVudFRvQ2hpbGRyZW4oY2hpbGRyZW4pfVxuICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICA8L1BvcHVwSXRlbT5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgbW9kZSwgcm9vdCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgbmV3TW9kZSA9IG1vZGUgfHwgcm9vdC5wcm9wcy5tb2RlO1xuXG4gICAgICAgIHJldHVybiBuZXdNb2RlID09PSAncG9wdXAnID9cbiAgICAgICAgICAgIHRoaXMucmVuZGVyUG9wdXAoKSA6XG4gICAgICAgICAgICB0aGlzLnJlbmRlcklubGluZSgpO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tZW51L3ZpZXcvc3ViLW1lbnUuanN4IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBQcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG5cbnZhciBfYWRkQ2xhc3MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJkb20taGVscGVycy9jbGFzcy9hZGRDbGFzc1wiKSk7XG5cbnZhciBfcmVtb3ZlQ2xhc3MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJkb20taGVscGVycy9jbGFzcy9yZW1vdmVDbGFzc1wiKSk7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfVHJhbnNpdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vVHJhbnNpdGlvblwiKSk7XG5cbnZhciBfUHJvcFR5cGVzID0gcmVxdWlyZShcIi4vdXRpbHMvUHJvcFR5cGVzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG52YXIgYWRkQ2xhc3MgPSBmdW5jdGlvbiBhZGRDbGFzcyhub2RlLCBjbGFzc2VzKSB7XG4gIHJldHVybiBub2RlICYmIGNsYXNzZXMgJiYgY2xhc3Nlcy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gKDAsIF9hZGRDbGFzcy5kZWZhdWx0KShub2RlLCBjKTtcbiAgfSk7XG59O1xuXG52YXIgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiByZW1vdmVDbGFzcyhub2RlLCBjbGFzc2VzKSB7XG4gIHJldHVybiBub2RlICYmIGNsYXNzZXMgJiYgY2xhc3Nlcy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gKDAsIF9yZW1vdmVDbGFzcy5kZWZhdWx0KShub2RlLCBjKTtcbiAgfSk7XG59O1xuXG52YXIgcHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gX2V4dGVuZHMoe30sIF9UcmFuc2l0aW9uLmRlZmF1bHQucHJvcFR5cGVzLCB7XG4gIC8qKlxuICAgKiBUaGUgYW5pbWF0aW9uIGNsYXNzTmFtZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50IGFzIGl0IGVudGVycywgZXhpdHMgb3IgaGFzIGZpbmlzaGVkIHRoZSB0cmFuc2l0aW9uLlxuICAgKiBBIHNpbmdsZSBuYW1lIGNhbiBiZSBwcm92aWRlZCBhbmQgaXQgd2lsbCBiZSBzdWZmaXhlZCBmb3IgZWFjaCBzdGFnZTogZS5nLlxuICAgKlxuICAgKiBgY2xhc3NOYW1lcz1cImZhZGVcImAgYXBwbGllcyBgZmFkZS1lbnRlcmAsIGBmYWRlLWVudGVyLWFjdGl2ZWAsIGBmYWRlLWVudGVyLWRvbmVgLFxuICAgKiBgZmFkZS1leGl0YCwgYGZhZGUtZXhpdC1hY3RpdmVgLCBgZmFkZS1leGl0LWRvbmVgLCBgZmFkZS1hcHBlYXJgLCBhbmQgYGZhZGUtYXBwZWFyLWFjdGl2ZWAuXG4gICAqIEVhY2ggaW5kaXZpZHVhbCBjbGFzc05hbWVzIGNhbiBhbHNvIGJlIHNwZWNpZmllZCBpbmRlcGVuZGVudGx5IGxpa2U6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNsYXNzTmFtZXM9e3tcbiAgICogIGFwcGVhcjogJ215LWFwcGVhcicsXG4gICAqICBhcHBlYXJBY3RpdmU6ICdteS1hY3RpdmUtYXBwZWFyJyxcbiAgICogIGVudGVyOiAnbXktZW50ZXInLFxuICAgKiAgZW50ZXJBY3RpdmU6ICdteS1hY3RpdmUtZW50ZXInLFxuICAgKiAgZW50ZXJEb25lOiAnbXktZG9uZS1lbnRlcicsXG4gICAqICBleGl0OiAnbXktZXhpdCcsXG4gICAqICBleGl0QWN0aXZlOiAnbXktYWN0aXZlLWV4aXQnLFxuICAgKiAgZXhpdERvbmU6ICdteS1kb25lLWV4aXQnLFxuICAgKiB9fVxuICAgKiBgYGBcbiAgICpcbiAgICogSWYgeW91IHdhbnQgdG8gc2V0IHRoZXNlIGNsYXNzZXMgdXNpbmcgQ1NTIE1vZHVsZXM6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGltcG9ydCBzdHlsZXMgZnJvbSAnLi9zdHlsZXMuY3NzJztcbiAgICogYGBgXG4gICAqXG4gICAqIHlvdSBtaWdodCB3YW50IHRvIHVzZSBjYW1lbENhc2UgaW4geW91ciBDU1MgZmlsZSwgdGhhdCB3YXkgY291bGQgc2ltcGx5IHNwcmVhZFxuICAgKiB0aGVtIGluc3RlYWQgb2YgbGlzdGluZyB0aGVtIG9uZSBieSBvbmU6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNsYXNzTmFtZXM9e3sgLi4uc3R5bGVzIH19XG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nIHwge1xuICAgKiAgYXBwZWFyPzogc3RyaW5nLFxuICAgKiAgYXBwZWFyQWN0aXZlPzogc3RyaW5nLFxuICAgKiAgZW50ZXI/OiBzdHJpbmcsXG4gICAqICBlbnRlckFjdGl2ZT86IHN0cmluZyxcbiAgICogIGVudGVyRG9uZT86IHN0cmluZyxcbiAgICogIGV4aXQ/OiBzdHJpbmcsXG4gICAqICBleGl0QWN0aXZlPzogc3RyaW5nLFxuICAgKiAgZXhpdERvbmU/OiBzdHJpbmcsXG4gICAqIH19XG4gICAqL1xuICBjbGFzc05hbWVzOiBfUHJvcFR5cGVzLmNsYXNzTmFtZXNTaGFwZSxcblxuICAvKipcbiAgICogQSBgPFRyYW5zaXRpb24+YCBjYWxsYmFjayBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgJ2VudGVyJyBvciAnYXBwZWFyJyBjbGFzcyBpc1xuICAgKiBhcHBsaWVkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpXG4gICAqL1xuICBvbkVudGVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQSBgPFRyYW5zaXRpb24+YCBjYWxsYmFjayBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgJ2VudGVyLWFjdGl2ZScgb3JcbiAgICogJ2FwcGVhci1hY3RpdmUnIGNsYXNzIGlzIGFwcGxpZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbClcbiAgICovXG4gIG9uRW50ZXJpbmc6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBBIGA8VHJhbnNpdGlvbj5gIGNhbGxiYWNrIGZpcmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSAnZW50ZXInIG9yXG4gICAqICdhcHBlYXInIGNsYXNzZXMgYXJlICoqcmVtb3ZlZCoqIGFuZCB0aGUgYGRvbmVgIGNsYXNzIGlzIGFkZGVkIHRvIHRoZSBET00gbm9kZS5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKVxuICAgKi9cbiAgb25FbnRlcmVkOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQSBgPFRyYW5zaXRpb24+YCBjYWxsYmFjayBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgJ2V4aXQnIGNsYXNzIGlzXG4gICAqIGFwcGxpZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KVxuICAgKi9cbiAgb25FeGl0OiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQSBgPFRyYW5zaXRpb24+YCBjYWxsYmFjayBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgJ2V4aXQtYWN0aXZlJyBpcyBhcHBsaWVkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudClcbiAgICovXG4gIG9uRXhpdGluZzogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEEgYDxUcmFuc2l0aW9uPmAgY2FsbGJhY2sgZmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlICdleGl0JyBjbGFzc2VzXG4gICAqIGFyZSAqKnJlbW92ZWQqKiBhbmQgdGhlIGBleGl0LWRvbmVgIGNsYXNzIGlzIGFkZGVkIHRvIHRoZSBET00gbm9kZS5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpXG4gICAqL1xuICBvbkV4aXRlZDogUHJvcFR5cGVzLmZ1bmNcbn0pIDoge307O1xuLyoqXG4gKiBBIGBUcmFuc2l0aW9uYCBjb21wb25lbnQgdXNpbmcgQ1NTIHRyYW5zaXRpb25zIGFuZCBhbmltYXRpb25zLlxuICogSXQncyBpbnNwaXJlZCBieSB0aGUgZXhjZWxsZW50IFtuZy1hbmltYXRlXShodHRwOi8vd3d3Lm5nYW5pbWF0ZS5vcmcvKSBsaWJyYXJ5LlxuICpcbiAqIGBDU1NUcmFuc2l0aW9uYCBhcHBsaWVzIGEgcGFpciBvZiBjbGFzcyBuYW1lcyBkdXJpbmcgdGhlIGBhcHBlYXJgLCBgZW50ZXJgLFxuICogYW5kIGBleGl0YCBzdGFnZXMgb2YgdGhlIHRyYW5zaXRpb24uIFRoZSBmaXJzdCBjbGFzcyBpcyBhcHBsaWVkIGFuZCB0aGVuIGFcbiAqIHNlY29uZCBcImFjdGl2ZVwiIGNsYXNzIGluIG9yZGVyIHRvIGFjdGl2YXRlIHRoZSBjc3MgYW5pbWF0aW9uLiBBZnRlciB0aGUgYW5pbWF0aW9uLFxuICogbWF0Y2hpbmcgYGRvbmVgIGNsYXNzIG5hbWVzIGFyZSBhcHBsaWVkIHRvIHBlcnNpc3QgdGhlIGFuaW1hdGlvbiBzdGF0ZS5cbiAqXG4gKiBXaGVuIHRoZSBgaW5gIHByb3AgaXMgdG9nZ2xlZCB0byBgdHJ1ZWAgdGhlIENvbXBvbmVudCB3aWxsIGdldFxuICogdGhlIGBleGFtcGxlLWVudGVyYCBDU1MgY2xhc3MgYW5kIHRoZSBgZXhhbXBsZS1lbnRlci1hY3RpdmVgIENTUyBjbGFzc1xuICogYWRkZWQgaW4gdGhlIG5leHQgdGljay4gVGhpcyBpcyBhIGNvbnZlbnRpb24gYmFzZWQgb24gdGhlIGBjbGFzc05hbWVzYCBwcm9wLlxuICovXG5cbnZhciBDU1NUcmFuc2l0aW9uID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKENTU1RyYW5zaXRpb24sIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIENTU1RyYW5zaXRpb24oKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5vbkVudGVyID0gZnVuY3Rpb24gKG5vZGUsIGFwcGVhcmluZykge1xuICAgICAgdmFyIF90aGlzJGdldENsYXNzTmFtZXMgPSBfdGhpcy5nZXRDbGFzc05hbWVzKGFwcGVhcmluZyA/ICdhcHBlYXInIDogJ2VudGVyJyksXG4gICAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkZ2V0Q2xhc3NOYW1lcy5jbGFzc05hbWU7XG5cbiAgICAgIF90aGlzLnJlbW92ZUNsYXNzZXMobm9kZSwgJ2V4aXQnKTtcblxuICAgICAgYWRkQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRW50ZXIpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25FbnRlcihub2RlLCBhcHBlYXJpbmcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkVudGVyaW5nID0gZnVuY3Rpb24gKG5vZGUsIGFwcGVhcmluZykge1xuICAgICAgdmFyIF90aGlzJGdldENsYXNzTmFtZXMyID0gX3RoaXMuZ2V0Q2xhc3NOYW1lcyhhcHBlYXJpbmcgPyAnYXBwZWFyJyA6ICdlbnRlcicpLFxuICAgICAgICAgIGFjdGl2ZUNsYXNzTmFtZSA9IF90aGlzJGdldENsYXNzTmFtZXMyLmFjdGl2ZUNsYXNzTmFtZTtcblxuICAgICAgX3RoaXMucmVmbG93QW5kQWRkQ2xhc3Mobm9kZSwgYWN0aXZlQ2xhc3NOYW1lKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRW50ZXJpbmcpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25FbnRlcmluZyhub2RlLCBhcHBlYXJpbmcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkVudGVyZWQgPSBmdW5jdGlvbiAobm9kZSwgYXBwZWFyaW5nKSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0Q2xhc3NOYW1lczMgPSBfdGhpcy5nZXRDbGFzc05hbWVzKCdlbnRlcicpLFxuICAgICAgICAgIGRvbmVDbGFzc05hbWUgPSBfdGhpcyRnZXRDbGFzc05hbWVzMy5kb25lQ2xhc3NOYW1lO1xuXG4gICAgICBfdGhpcy5yZW1vdmVDbGFzc2VzKG5vZGUsIGFwcGVhcmluZyA/ICdhcHBlYXInIDogJ2VudGVyJyk7XG5cbiAgICAgIGFkZENsYXNzKG5vZGUsIGRvbmVDbGFzc05hbWUpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25FbnRlcmVkKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uRW50ZXJlZChub2RlLCBhcHBlYXJpbmcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkV4aXQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIF90aGlzJGdldENsYXNzTmFtZXM0ID0gX3RoaXMuZ2V0Q2xhc3NOYW1lcygnZXhpdCcpLFxuICAgICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJGdldENsYXNzTmFtZXM0LmNsYXNzTmFtZTtcblxuICAgICAgX3RoaXMucmVtb3ZlQ2xhc3Nlcyhub2RlLCAnYXBwZWFyJyk7XG5cbiAgICAgIF90aGlzLnJlbW92ZUNsYXNzZXMobm9kZSwgJ2VudGVyJyk7XG5cbiAgICAgIGFkZENsYXNzKG5vZGUsIGNsYXNzTmFtZSk7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkV4aXQpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25FeGl0KG5vZGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkV4aXRpbmcgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIF90aGlzJGdldENsYXNzTmFtZXM1ID0gX3RoaXMuZ2V0Q2xhc3NOYW1lcygnZXhpdCcpLFxuICAgICAgICAgIGFjdGl2ZUNsYXNzTmFtZSA9IF90aGlzJGdldENsYXNzTmFtZXM1LmFjdGl2ZUNsYXNzTmFtZTtcblxuICAgICAgX3RoaXMucmVmbG93QW5kQWRkQ2xhc3Mobm9kZSwgYWN0aXZlQ2xhc3NOYW1lKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRXhpdGluZykge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkV4aXRpbmcobm9kZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uRXhpdGVkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBfdGhpcyRnZXRDbGFzc05hbWVzNiA9IF90aGlzLmdldENsYXNzTmFtZXMoJ2V4aXQnKSxcbiAgICAgICAgICBkb25lQ2xhc3NOYW1lID0gX3RoaXMkZ2V0Q2xhc3NOYW1lczYuZG9uZUNsYXNzTmFtZTtcblxuICAgICAgX3RoaXMucmVtb3ZlQ2xhc3Nlcyhub2RlLCAnZXhpdCcpO1xuXG4gICAgICBhZGRDbGFzcyhub2RlLCBkb25lQ2xhc3NOYW1lKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRXhpdGVkKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uRXhpdGVkKG5vZGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5nZXRDbGFzc05hbWVzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHZhciBjbGFzc05hbWVzID0gX3RoaXMucHJvcHMuY2xhc3NOYW1lcztcbiAgICAgIHZhciBjbGFzc05hbWUgPSB0eXBlb2YgY2xhc3NOYW1lcyAhPT0gJ3N0cmluZycgPyBjbGFzc05hbWVzW3R5cGVdIDogY2xhc3NOYW1lcyArICctJyArIHR5cGU7XG4gICAgICB2YXIgYWN0aXZlQ2xhc3NOYW1lID0gdHlwZW9mIGNsYXNzTmFtZXMgIT09ICdzdHJpbmcnID8gY2xhc3NOYW1lc1t0eXBlICsgJ0FjdGl2ZSddIDogY2xhc3NOYW1lICsgJy1hY3RpdmUnO1xuICAgICAgdmFyIGRvbmVDbGFzc05hbWUgPSB0eXBlb2YgY2xhc3NOYW1lcyAhPT0gJ3N0cmluZycgPyBjbGFzc05hbWVzW3R5cGUgKyAnRG9uZSddIDogY2xhc3NOYW1lICsgJy1kb25lJztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICBhY3RpdmVDbGFzc05hbWU6IGFjdGl2ZUNsYXNzTmFtZSxcbiAgICAgICAgZG9uZUNsYXNzTmFtZTogZG9uZUNsYXNzTmFtZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENTU1RyYW5zaXRpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW1vdmVDbGFzc2VzID0gZnVuY3Rpb24gcmVtb3ZlQ2xhc3Nlcyhub2RlLCB0eXBlKSB7XG4gICAgdmFyIF90aGlzJGdldENsYXNzTmFtZXM3ID0gdGhpcy5nZXRDbGFzc05hbWVzKHR5cGUpLFxuICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRnZXRDbGFzc05hbWVzNy5jbGFzc05hbWUsXG4gICAgICAgIGFjdGl2ZUNsYXNzTmFtZSA9IF90aGlzJGdldENsYXNzTmFtZXM3LmFjdGl2ZUNsYXNzTmFtZSxcbiAgICAgICAgZG9uZUNsYXNzTmFtZSA9IF90aGlzJGdldENsYXNzTmFtZXM3LmRvbmVDbGFzc05hbWU7XG5cbiAgICBjbGFzc05hbWUgJiYgcmVtb3ZlQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTtcbiAgICBhY3RpdmVDbGFzc05hbWUgJiYgcmVtb3ZlQ2xhc3Mobm9kZSwgYWN0aXZlQ2xhc3NOYW1lKTtcbiAgICBkb25lQ2xhc3NOYW1lICYmIHJlbW92ZUNsYXNzKG5vZGUsIGRvbmVDbGFzc05hbWUpO1xuICB9O1xuXG4gIF9wcm90by5yZWZsb3dBbmRBZGRDbGFzcyA9IGZ1bmN0aW9uIHJlZmxvd0FuZEFkZENsYXNzKG5vZGUsIGNsYXNzTmFtZSkge1xuICAgIC8vIFRoaXMgaXMgZm9yIHRvIGZvcmNlIGEgcmVwYWludCxcbiAgICAvLyB3aGljaCBpcyBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gdHJhbnNpdGlvbiBzdHlsZXMgd2hlbiBhZGRpbmcgYSBjbGFzcyBuYW1lLlxuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgICAgbm9kZSAmJiBub2RlLnNjcm9sbFRvcDtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG5cbiAgICAgIGFkZENsYXNzKG5vZGUsIGNsYXNzTmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHByb3BzID0gX2V4dGVuZHMoe30sIHRoaXMucHJvcHMpO1xuXG4gICAgZGVsZXRlIHByb3BzLmNsYXNzTmFtZXM7XG4gICAgcmV0dXJuIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX1RyYW5zaXRpb24uZGVmYXVsdCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBvbkVudGVyOiB0aGlzLm9uRW50ZXIsXG4gICAgICBvbkVudGVyZWQ6IHRoaXMub25FbnRlcmVkLFxuICAgICAgb25FbnRlcmluZzogdGhpcy5vbkVudGVyaW5nLFxuICAgICAgb25FeGl0OiB0aGlzLm9uRXhpdCxcbiAgICAgIG9uRXhpdGluZzogdGhpcy5vbkV4aXRpbmcsXG4gICAgICBvbkV4aXRlZDogdGhpcy5vbkV4aXRlZFxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gQ1NTVHJhbnNpdGlvbjtcbn0oX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50KTtcblxuQ1NTVHJhbnNpdGlvbi5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBwcm9wVHlwZXMgOiB7fTtcbnZhciBfZGVmYXVsdCA9IENTU1RyYW5zaXRpb247XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19yZWFjdC10cmFuc2l0aW9uLWdyb3VwQDIuNS4yQHJlYWN0LXRyYW5zaXRpb24tZ3JvdXAvQ1NTVHJhbnNpdGlvbi5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFkZENsYXNzO1xuXG52YXIgX2hhc0NsYXNzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9oYXNDbGFzc1wiKSk7XG5cbmZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO2Vsc2UgaWYgKCEoMCwgX2hhc0NsYXNzLmRlZmF1bHQpKGVsZW1lbnQsIGNsYXNzTmFtZSkpIGlmICh0eXBlb2YgZWxlbWVudC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnICsgY2xhc3NOYW1lO2Vsc2UgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGVsZW1lbnQuY2xhc3NOYW1lICYmIGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWwgfHwgJycpICsgJyAnICsgY2xhc3NOYW1lKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX2RvbS1oZWxwZXJzQDMuNC4wQGRvbS1oZWxwZXJzL2NsYXNzL2FkZENsYXNzLmpzIiwiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBkZWZhdWx0OiBvYmpcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fQGJhYmVsX3J1bnRpbWVANy4yLjBAQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGhhc0NsYXNzO1xuXG5mdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSByZXR1cm4gISFjbGFzc05hbWUgJiYgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtlbHNlIHJldHVybiAoXCIgXCIgKyAoZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCB8fCBlbGVtZW50LmNsYXNzTmFtZSkgKyBcIiBcIikuaW5kZXhPZihcIiBcIiArIGNsYXNzTmFtZSArIFwiIFwiKSAhPT0gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19kb20taGVscGVyc0AzLjQuMEBkb20taGVscGVycy9jbGFzcy9oYXNDbGFzcy5qcyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gcmVwbGFjZUNsYXNzTmFtZShvcmlnQ2xhc3MsIGNsYXNzVG9SZW1vdmUpIHtcbiAgcmV0dXJuIG9yaWdDbGFzcy5yZXBsYWNlKG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBjbGFzc1RvUmVtb3ZlICsgJyg/OlxcXFxzfCQpJywgJ2cnKSwgJyQxJykucmVwbGFjZSgvXFxzKy9nLCAnICcpLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtlbHNlIGlmICh0eXBlb2YgZWxlbWVudC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSBlbGVtZW50LmNsYXNzTmFtZSA9IHJlcGxhY2VDbGFzc05hbWUoZWxlbWVudC5jbGFzc05hbWUsIGNsYXNzTmFtZSk7ZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCByZXBsYWNlQ2xhc3NOYW1lKGVsZW1lbnQuY2xhc3NOYW1lICYmIGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWwgfHwgJycsIGNsYXNzTmFtZSkpO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX2RvbS1oZWxwZXJzQDMuNC4wQGRvbS1oZWxwZXJzL2NsYXNzL3JlbW92ZUNsYXNzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKFwicmVhY3QtZG9tXCIpO1xuXG52YXIgX1RyYW5zaXRpb25Hcm91cCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vVHJhbnNpdGlvbkdyb3VwXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIHByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgaW46IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLmlzUmVxdWlyZWQsXG4gIGNoaWxkcmVuOiBmdW5jdGlvbiBjaGlsZHJlbihwcm9wcywgcHJvcE5hbWUpIHtcbiAgICBpZiAoX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4uY291bnQocHJvcHNbcHJvcE5hbWVdKSAhPT0gMikgcmV0dXJuIG5ldyBFcnJvcihcIlxcXCJcIiArIHByb3BOYW1lICsgXCJcXFwiIG11c3QgYmUgZXhhY3RseSB0d28gdHJhbnNpdGlvbiBjb21wb25lbnRzLlwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufSA6IHt9Oztcbi8qKlxuICogVGhlIGA8UmVwbGFjZVRyYW5zaXRpb24+YCBjb21wb25lbnQgaXMgYSBzcGVjaWFsaXplZCBgVHJhbnNpdGlvbmAgY29tcG9uZW50XG4gKiB0aGF0IGFuaW1hdGVzIGJldHdlZW4gdHdvIGNoaWxkcmVuLlxuICpcbiAqIGBgYGpzeFxuICogPFJlcGxhY2VUcmFuc2l0aW9uIGluPlxuICogICA8RmFkZT48ZGl2PkkgYXBwZWFyIGZpcnN0PC9kaXY+PC9GYWRlPlxuICogICA8RmFkZT48ZGl2PkkgcmVwbGFjZSB0aGUgYWJvdmU8L2Rpdj48L0ZhZGU+XG4gKiA8L1JlcGxhY2VUcmFuc2l0aW9uPlxuICogYGBgXG4gKi9cblxudmFyIFJlcGxhY2VUcmFuc2l0aW9uID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFJlcGxhY2VUcmFuc2l0aW9uLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSZXBsYWNlVHJhbnNpdGlvbigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBfYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KF9hcmdzKSkgfHwgdGhpcztcblxuICAgIF90aGlzLmhhbmRsZUVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZUxpZmVjeWNsZSgnb25FbnRlcicsIDAsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVFbnRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVMaWZlY3ljbGUoJ29uRW50ZXJpbmcnLCAwLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlRW50ZXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVMaWZlY3ljbGUoJ29uRW50ZXJlZCcsIDAsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVFeGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTVdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZUxpZmVjeWNsZSgnb25FeGl0JywgMSwgYXJncyk7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZUV4aXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMuaGFuZGxlTGlmZWN5Y2xlKCdvbkV4aXRpbmcnLCAxLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlRXhpdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43KSwgX2tleTcgPSAwOyBfa2V5NyA8IF9sZW43OyBfa2V5NysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTddID0gYXJndW1lbnRzW19rZXk3XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZUxpZmVjeWNsZSgnb25FeGl0ZWQnLCAxLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJlcGxhY2VUcmFuc2l0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaGFuZGxlTGlmZWN5Y2xlID0gZnVuY3Rpb24gaGFuZGxlTGlmZWN5Y2xlKGhhbmRsZXIsIGlkeCwgb3JpZ2luYWxBcmdzKSB7XG4gICAgdmFyIF9jaGlsZCRwcm9wcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG5cbiAgICB2YXIgY2hpbGQgPSBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKVtpZHhdO1xuXG4gICAgaWYgKGNoaWxkLnByb3BzW2hhbmRsZXJdKSAoX2NoaWxkJHByb3BzID0gY2hpbGQucHJvcHMpW2hhbmRsZXJdLmFwcGx5KF9jaGlsZCRwcm9wcywgb3JpZ2luYWxBcmdzKTtcbiAgICBpZiAodGhpcy5wcm9wc1toYW5kbGVyXSkgdGhpcy5wcm9wc1toYW5kbGVyXSgoMCwgX3JlYWN0RG9tLmZpbmRET01Ob2RlKSh0aGlzKSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBpblByb3AgPSBfdGhpcyRwcm9wcy5pbixcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJpblwiXSk7XG5cbiAgICB2YXIgX1JlYWN0JENoaWxkcmVuJHRvQXJyID0gX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbiksXG4gICAgICAgIGZpcnN0ID0gX1JlYWN0JENoaWxkcmVuJHRvQXJyWzBdLFxuICAgICAgICBzZWNvbmQgPSBfUmVhY3QkQ2hpbGRyZW4kdG9BcnJbMV07XG5cbiAgICBkZWxldGUgcHJvcHMub25FbnRlcjtcbiAgICBkZWxldGUgcHJvcHMub25FbnRlcmluZztcbiAgICBkZWxldGUgcHJvcHMub25FbnRlcmVkO1xuICAgIGRlbGV0ZSBwcm9wcy5vbkV4aXQ7XG4gICAgZGVsZXRlIHByb3BzLm9uRXhpdGluZztcbiAgICBkZWxldGUgcHJvcHMub25FeGl0ZWQ7XG4gICAgcmV0dXJuIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX1RyYW5zaXRpb25Hcm91cC5kZWZhdWx0LCBwcm9wcywgaW5Qcm9wID8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGZpcnN0LCB7XG4gICAgICBrZXk6ICdmaXJzdCcsXG4gICAgICBvbkVudGVyOiB0aGlzLmhhbmRsZUVudGVyLFxuICAgICAgb25FbnRlcmluZzogdGhpcy5oYW5kbGVFbnRlcmluZyxcbiAgICAgIG9uRW50ZXJlZDogdGhpcy5oYW5kbGVFbnRlcmVkXG4gICAgfSkgOiBfcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoc2Vjb25kLCB7XG4gICAgICBrZXk6ICdzZWNvbmQnLFxuICAgICAgb25FbnRlcjogdGhpcy5oYW5kbGVFeGl0LFxuICAgICAgb25FbnRlcmluZzogdGhpcy5oYW5kbGVFeGl0aW5nLFxuICAgICAgb25FbnRlcmVkOiB0aGlzLmhhbmRsZUV4aXRlZFxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gUmVwbGFjZVRyYW5zaXRpb247XG59KF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCk7XG5cblJlcGxhY2VUcmFuc2l0aW9uLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHByb3BUeXBlcyA6IHt9O1xudmFyIF9kZWZhdWx0ID0gUmVwbGFjZVRyYW5zaXRpb247XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19yZWFjdC10cmFuc2l0aW9uLWdyb3VwQDIuNS4yQHJlYWN0LXRyYW5zaXRpb24tZ3JvdXAvUmVwbGFjZVRyYW5zaXRpb24uanMiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZ2V0Q2hpbGRNYXBwaW5nID0gZ2V0Q2hpbGRNYXBwaW5nO1xuZXhwb3J0cy5tZXJnZUNoaWxkTWFwcGluZ3MgPSBtZXJnZUNoaWxkTWFwcGluZ3M7XG5leHBvcnRzLmdldEluaXRpYWxDaGlsZE1hcHBpbmcgPSBnZXRJbml0aWFsQ2hpbGRNYXBwaW5nO1xuZXhwb3J0cy5nZXROZXh0Q2hpbGRNYXBwaW5nID0gZ2V0TmV4dENoaWxkTWFwcGluZztcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxuLyoqXG4gKiBHaXZlbiBgdGhpcy5wcm9wcy5jaGlsZHJlbmAsIHJldHVybiBhbiBvYmplY3QgbWFwcGluZyBrZXkgdG8gY2hpbGQuXG4gKlxuICogQHBhcmFtIHsqfSBjaGlsZHJlbiBgdGhpcy5wcm9wcy5jaGlsZHJlbmBcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwcGluZyBvZiBrZXkgdG8gY2hpbGRcbiAqL1xuZnVuY3Rpb24gZ2V0Q2hpbGRNYXBwaW5nKGNoaWxkcmVuLCBtYXBGbikge1xuICB2YXIgbWFwcGVyID0gZnVuY3Rpb24gbWFwcGVyKGNoaWxkKSB7XG4gICAgcmV0dXJuIG1hcEZuICYmICgwLCBfcmVhY3QuaXNWYWxpZEVsZW1lbnQpKGNoaWxkKSA/IG1hcEZuKGNoaWxkKSA6IGNoaWxkO1xuICB9O1xuXG4gIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoY2hpbGRyZW4pIF9yZWFjdC5DaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIGM7XG4gIH0pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgLy8gcnVuIHRoZSBtYXAgZnVuY3Rpb24gaGVyZSBpbnN0ZWFkIHNvIHRoYXQgdGhlIGtleSBpcyB0aGUgY29tcHV0ZWQgb25lXG4gICAgcmVzdWx0W2NoaWxkLmtleV0gPSBtYXBwZXIoY2hpbGQpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogV2hlbiB5b3UncmUgYWRkaW5nIG9yIHJlbW92aW5nIGNoaWxkcmVuIHNvbWUgbWF5IGJlIGFkZGVkIG9yIHJlbW92ZWQgaW4gdGhlXG4gKiBzYW1lIHJlbmRlciBwYXNzLiBXZSB3YW50IHRvIHNob3cgKmJvdGgqIHNpbmNlIHdlIHdhbnQgdG8gc2ltdWx0YW5lb3VzbHlcbiAqIGFuaW1hdGUgZWxlbWVudHMgaW4gYW5kIG91dC4gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIHByZXZpb3VzIHNldCBvZiBrZXlzXG4gKiBhbmQgYSBuZXcgc2V0IG9mIGtleXMgYW5kIG1lcmdlcyB0aGVtIHdpdGggaXRzIGJlc3QgZ3Vlc3Mgb2YgdGhlIGNvcnJlY3RcbiAqIG9yZGVyaW5nLiBJbiB0aGUgZnV0dXJlIHdlIG1heSBleHBvc2Ugc29tZSBvZiB0aGUgdXRpbGl0aWVzIGluXG4gKiBSZWFjdE11bHRpQ2hpbGQgdG8gbWFrZSB0aGlzIGVhc3ksIGJ1dCBmb3Igbm93IFJlYWN0IGl0c2VsZiBkb2VzIG5vdFxuICogZGlyZWN0bHkgaGF2ZSB0aGlzIGNvbmNlcHQgb2YgdGhlIHVuaW9uIG9mIHByZXZDaGlsZHJlbiBhbmQgbmV4dENoaWxkcmVuXG4gKiBzbyB3ZSBpbXBsZW1lbnQgaXQgaGVyZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcHJldiBwcmV2IGNoaWxkcmVuIGFzIHJldHVybmVkIGZyb21cbiAqIGBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKClgLlxuICogQHBhcmFtIHtvYmplY3R9IG5leHQgbmV4dCBjaGlsZHJlbiBhcyByZXR1cm5lZCBmcm9tXG4gKiBgUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmdldENoaWxkTWFwcGluZygpYC5cbiAqIEByZXR1cm4ge29iamVjdH0gYSBrZXkgc2V0IHRoYXQgY29udGFpbnMgYWxsIGtleXMgaW4gYHByZXZgIGFuZCBhbGwga2V5c1xuICogaW4gYG5leHRgIGluIGEgcmVhc29uYWJsZSBvcmRlci5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlQ2hpbGRNYXBwaW5ncyhwcmV2LCBuZXh0KSB7XG4gIHByZXYgPSBwcmV2IHx8IHt9O1xuICBuZXh0ID0gbmV4dCB8fCB7fTtcblxuICBmdW5jdGlvbiBnZXRWYWx1ZUZvcktleShrZXkpIHtcbiAgICByZXR1cm4ga2V5IGluIG5leHQgPyBuZXh0W2tleV0gOiBwcmV2W2tleV07XG4gIH0gLy8gRm9yIGVhY2gga2V5IG9mIGBuZXh0YCwgdGhlIGxpc3Qgb2Yga2V5cyB0byBpbnNlcnQgYmVmb3JlIHRoYXQga2V5IGluXG4gIC8vIHRoZSBjb21iaW5lZCBsaXN0XG5cblxuICB2YXIgbmV4dEtleXNQZW5kaW5nID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIHBlbmRpbmdLZXlzID0gW107XG5cbiAgZm9yICh2YXIgcHJldktleSBpbiBwcmV2KSB7XG4gICAgaWYgKHByZXZLZXkgaW4gbmV4dCkge1xuICAgICAgaWYgKHBlbmRpbmdLZXlzLmxlbmd0aCkge1xuICAgICAgICBuZXh0S2V5c1BlbmRpbmdbcHJldktleV0gPSBwZW5kaW5nS2V5cztcbiAgICAgICAgcGVuZGluZ0tleXMgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZ0tleXMucHVzaChwcmV2S2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgaTtcbiAgdmFyIGNoaWxkTWFwcGluZyA9IHt9O1xuXG4gIGZvciAodmFyIG5leHRLZXkgaW4gbmV4dCkge1xuICAgIGlmIChuZXh0S2V5c1BlbmRpbmdbbmV4dEtleV0pIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXh0S2V5c1BlbmRpbmdbbmV4dEtleV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBlbmRpbmdOZXh0S2V5ID0gbmV4dEtleXNQZW5kaW5nW25leHRLZXldW2ldO1xuICAgICAgICBjaGlsZE1hcHBpbmdbbmV4dEtleXNQZW5kaW5nW25leHRLZXldW2ldXSA9IGdldFZhbHVlRm9yS2V5KHBlbmRpbmdOZXh0S2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGlsZE1hcHBpbmdbbmV4dEtleV0gPSBnZXRWYWx1ZUZvcktleShuZXh0S2V5KTtcbiAgfSAvLyBGaW5hbGx5LCBhZGQgdGhlIGtleXMgd2hpY2ggZGlkbid0IGFwcGVhciBiZWZvcmUgYW55IGtleSBpbiBgbmV4dGBcblxuXG4gIGZvciAoaSA9IDA7IGkgPCBwZW5kaW5nS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNoaWxkTWFwcGluZ1twZW5kaW5nS2V5c1tpXV0gPSBnZXRWYWx1ZUZvcktleShwZW5kaW5nS2V5c1tpXSk7XG4gIH1cblxuICByZXR1cm4gY2hpbGRNYXBwaW5nO1xufVxuXG5mdW5jdGlvbiBnZXRQcm9wKGNoaWxkLCBwcm9wLCBwcm9wcykge1xuICByZXR1cm4gcHJvcHNbcHJvcF0gIT0gbnVsbCA/IHByb3BzW3Byb3BdIDogY2hpbGQucHJvcHNbcHJvcF07XG59XG5cbmZ1bmN0aW9uIGdldEluaXRpYWxDaGlsZE1hcHBpbmcocHJvcHMsIG9uRXhpdGVkKSB7XG4gIHJldHVybiBnZXRDaGlsZE1hcHBpbmcocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiAoMCwgX3JlYWN0LmNsb25lRWxlbWVudCkoY2hpbGQsIHtcbiAgICAgIG9uRXhpdGVkOiBvbkV4aXRlZC5iaW5kKG51bGwsIGNoaWxkKSxcbiAgICAgIGluOiB0cnVlLFxuICAgICAgYXBwZWFyOiBnZXRQcm9wKGNoaWxkLCAnYXBwZWFyJywgcHJvcHMpLFxuICAgICAgZW50ZXI6IGdldFByb3AoY2hpbGQsICdlbnRlcicsIHByb3BzKSxcbiAgICAgIGV4aXQ6IGdldFByb3AoY2hpbGQsICdleGl0JywgcHJvcHMpXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0Q2hpbGRNYXBwaW5nKG5leHRQcm9wcywgcHJldkNoaWxkTWFwcGluZywgb25FeGl0ZWQpIHtcbiAgdmFyIG5leHRDaGlsZE1hcHBpbmcgPSBnZXRDaGlsZE1hcHBpbmcobmV4dFByb3BzLmNoaWxkcmVuKTtcbiAgdmFyIGNoaWxkcmVuID0gbWVyZ2VDaGlsZE1hcHBpbmdzKHByZXZDaGlsZE1hcHBpbmcsIG5leHRDaGlsZE1hcHBpbmcpO1xuICBPYmplY3Qua2V5cyhjaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5ba2V5XTtcbiAgICBpZiAoISgwLCBfcmVhY3QuaXNWYWxpZEVsZW1lbnQpKGNoaWxkKSkgcmV0dXJuO1xuICAgIHZhciBoYXNQcmV2ID0ga2V5IGluIHByZXZDaGlsZE1hcHBpbmc7XG4gICAgdmFyIGhhc05leHQgPSBrZXkgaW4gbmV4dENoaWxkTWFwcGluZztcbiAgICB2YXIgcHJldkNoaWxkID0gcHJldkNoaWxkTWFwcGluZ1trZXldO1xuICAgIHZhciBpc0xlYXZpbmcgPSAoMCwgX3JlYWN0LmlzVmFsaWRFbGVtZW50KShwcmV2Q2hpbGQpICYmICFwcmV2Q2hpbGQucHJvcHMuaW47IC8vIGl0ZW0gaXMgbmV3IChlbnRlcmluZylcblxuICAgIGlmIChoYXNOZXh0ICYmICghaGFzUHJldiB8fCBpc0xlYXZpbmcpKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnZW50ZXJpbmcnLCBrZXkpXG4gICAgICBjaGlsZHJlbltrZXldID0gKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKGNoaWxkLCB7XG4gICAgICAgIG9uRXhpdGVkOiBvbkV4aXRlZC5iaW5kKG51bGwsIGNoaWxkKSxcbiAgICAgICAgaW46IHRydWUsXG4gICAgICAgIGV4aXQ6IGdldFByb3AoY2hpbGQsICdleGl0JywgbmV4dFByb3BzKSxcbiAgICAgICAgZW50ZXI6IGdldFByb3AoY2hpbGQsICdlbnRlcicsIG5leHRQcm9wcylcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIWhhc05leHQgJiYgaGFzUHJldiAmJiAhaXNMZWF2aW5nKSB7XG4gICAgICAvLyBpdGVtIGlzIG9sZCAoZXhpdGluZylcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdsZWF2aW5nJywga2V5KVxuICAgICAgY2hpbGRyZW5ba2V5XSA9ICgwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShjaGlsZCwge1xuICAgICAgICBpbjogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaGFzTmV4dCAmJiBoYXNQcmV2ICYmICgwLCBfcmVhY3QuaXNWYWxpZEVsZW1lbnQpKHByZXZDaGlsZCkpIHtcbiAgICAgIC8vIGl0ZW0gaGFzbid0IGNoYW5nZWQgdHJhbnNpdGlvbiBzdGF0ZXNcbiAgICAgIC8vIGNvcHkgb3ZlciB0aGUgbGFzdCB0cmFuc2l0aW9uIHByb3BzO1xuICAgICAgLy8gY29uc29sZS5sb2coJ3VuY2hhbmdlZCcsIGtleSlcbiAgICAgIGNoaWxkcmVuW2tleV0gPSAoMCwgX3JlYWN0LmNsb25lRWxlbWVudCkoY2hpbGQsIHtcbiAgICAgICAgb25FeGl0ZWQ6IG9uRXhpdGVkLmJpbmQobnVsbCwgY2hpbGQpLFxuICAgICAgICBpbjogcHJldkNoaWxkLnByb3BzLmluLFxuICAgICAgICBleGl0OiBnZXRQcm9wKGNoaWxkLCAnZXhpdCcsIG5leHRQcm9wcyksXG4gICAgICAgIGVudGVyOiBnZXRQcm9wKGNoaWxkLCAnZW50ZXInLCBuZXh0UHJvcHMpXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19yZWFjdC10cmFuc2l0aW9uLWdyb3VwQDIuNS4yQHJlYWN0LXRyYW5zaXRpb24tZ3JvdXAvdXRpbHMvQ2hpbGRNYXBwaW5nLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAncmVhY3QtdHJhbnNpdGlvbi1ncm91cCc7XG5pbXBvcnQgeyBmdW5jLCBzdXBwb3J0LCBldmVudHMsIGRvbSwgZ3VpZCB9IGZyb20gJy4uL3V0aWwnO1xuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5jb25zdCB7IG9uLCBvZmYgfSA9IGV2ZW50cztcbmNvbnN0IHsgYWRkQ2xhc3MsIHJlbW92ZUNsYXNzIH0gPSBkb207XG5jb25zdCBwcmVmaXhlcyA9IFsnLXdlYmtpdC0nLCAnLW1vei0nLCAnLW8tJywgJ21zLScsICcnXTtcblxuZnVuY3Rpb24gZ2V0U3R5bGVQcm9wZXJ0eShub2RlLCBuYW1lKSB7XG4gICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBsZXQgcmV0ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXQgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByZWZpeGVzW2ldICsgbmFtZSk7XG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGVDaGlsZCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgbmFtZXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgICAgICAgb25BcHBlYXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkFwcGVhcmluZzogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uQXBwZWFyZWQ6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25FbnRlcmluZzogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uRW50ZXJlZDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uRXhpdDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uRXhpdGluZzogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uRXhpdGVkOiBQcm9wVHlwZXMuZnVuY1xuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBvbkFwcGVhcjogbm9vcCxcbiAgICAgICAgb25BcHBlYXJpbmc6IG5vb3AsXG4gICAgICAgIG9uQXBwZWFyZWQ6IG5vb3AsXG4gICAgICAgIG9uRW50ZXI6IG5vb3AsXG4gICAgICAgIG9uRW50ZXJpbmc6IG5vb3AsXG4gICAgICAgIG9uRW50ZXJlZDogbm9vcCxcbiAgICAgICAgb25FeGl0OiBub29wLFxuICAgICAgICBvbkV4aXRpbmc6IG5vb3AsXG4gICAgICAgIG9uRXhpdGVkOiBub29wXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgZnVuYy5iaW5kQ3R4KHRoaXMsIFtcbiAgICAgICAgICAgICdoYW5kbGVFbnRlcicsICdoYW5kbGVFbnRlcmluZycsICdoYW5kbGVFbnRlcmVkJyxcbiAgICAgICAgICAgICdoYW5kbGVFeGl0JywgJ2hhbmRsZUV4aXRpbmcnLCAnaGFuZGxlRXhpdGVkJyxcbiAgICAgICAgICAgICdhZGRFbmRMaXN0ZW5lcidcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuZW5kTGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgdHJhbnNpdGlvbmVuZDogW10sXG4gICAgICAgICAgICBhbmltYXRpb25lbmQ6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudGltZW91dE1hcCA9IHt9O1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmVuZExpc3RlbmVycykuZm9yRWFjaChldmVudE5hbWUgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbmRMaXN0ZW5lcnNbZXZlbnROYW1lXS5mb3JFYWNoKGxpc3RlbmVyID0+IHtcbiAgICAgICAgICAgICAgICBvZmYodGhpcy5ub2RlLCBldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbmRMaXN0ZW5lcnMgPSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uZW5kOiBbXSxcbiAgICAgICAgICAgIGFuaW1hdGlvbmVuZDogW11cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBnZW5lcmF0ZUVuZExpc3RlbmVyKG5vZGUsIGRvbmUsIGV2ZW50TmFtZSwgaWQpIHtcbiAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZW5kTGlzdGVuZXIoZSkge1xuXG4gICAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy50aW1lb3V0TWFwW2lkXSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dE1hcFtpZF0pO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMudGltZW91dE1hcFtpZF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIG9mZihub2RlLCBldmVudE5hbWUsIGVuZExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBfdGhpcy5lbmRMaXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGVuZExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICBpbmRleCA+IC0xICYmIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFkZEVuZExpc3RlbmVyKG5vZGUsIGRvbmUpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQudHJhbnNpdGlvbiB8fCBzdXBwb3J0LmFuaW1hdGlvbikge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBndWlkKCk7XG5cbiAgICAgICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgICAgICBpZiAoc3VwcG9ydC50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNpdGlvbkVuZExpc3RlbmVyID0gdGhpcy5nZW5lcmF0ZUVuZExpc3RlbmVyKG5vZGUsIGRvbmUsICd0cmFuc2l0aW9uZW5kJywgaWQpO1xuICAgICAgICAgICAgICAgIG9uKG5vZGUsICd0cmFuc2l0aW9uZW5kJywgdHJhbnNpdGlvbkVuZExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZExpc3RlbmVycy50cmFuc2l0aW9uZW5kLnB1c2godHJhbnNpdGlvbkVuZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdXBwb3J0LmFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbkVuZExpc3RlbmVyID0gdGhpcy5nZW5lcmF0ZUVuZExpc3RlbmVyKG5vZGUsIGRvbmUsICdhbmltYXRpb25lbmQnLCBpZCk7XG4gICAgICAgICAgICAgICAgb24obm9kZSwgJ2FuaW1hdGlvbmVuZCcsIGFuaW1hdGlvbkVuZExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZExpc3RlbmVycy5hbmltYXRpb25lbmQucHVzaChhbmltYXRpb25FbmRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb25EZWxheSA9IHBhcnNlRmxvYXQoZ2V0U3R5bGVQcm9wZXJ0eShub2RlLCAndHJhbnNpdGlvbi1kZWxheScpKSB8fCAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbiA9IHBhcnNlRmxvYXQoZ2V0U3R5bGVQcm9wZXJ0eShub2RlLCAndHJhbnNpdGlvbi1kdXJhdGlvbicpKSB8fCAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbkRlbGF5ID0gcGFyc2VGbG9hdChnZXRTdHlsZVByb3BlcnR5KG5vZGUsICdhbmltYXRpb24tZGVsYXknKSkgfHwgMDtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmltYXRpb25EdXJhdGlvbiA9IHBhcnNlRmxvYXQoZ2V0U3R5bGVQcm9wZXJ0eShub2RlLCAnYW5pbWF0aW9uLWR1cmF0aW9uJykpIHx8IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZSA9IE1hdGgubWF4KHRyYW5zaXRpb25EdXJhdGlvbiArIHRyYW5zaXRpb25EZWxheSwgYW5pbWF0aW9uRHVyYXRpb24gKyBhbmltYXRpb25EZWxheSk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0TWFwW2lkXSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lICogMTAwMCArIDIwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTUpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmVFbmR0TGlzdGVuZXIoKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbk9mZiAmJiB0aGlzLnRyYW5zaXRpb25PZmYoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25PZmYgJiYgdGhpcy5hbmltYXRpb25PZmYoKTtcbiAgICB9XG5cbiAgICByZW1vdmVDbGFzc05hbWVzKG5vZGUsIG5hbWVzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG5hbWVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhub2RlLCBuYW1lc1trZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaGFuZGxlRW50ZXIobm9kZSwgaXNBcHBlYXJpbmcpIHtcbiAgICAgICAgY29uc3QgeyBuYW1lcyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKG5hbWVzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzTmFtZXMobm9kZSwgbmFtZXMpO1xuICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gaXNBcHBlYXJpbmcgPyAnYXBwZWFyJyA6ICdlbnRlcic7XG4gICAgICAgICAgICBhZGRDbGFzcyhub2RlLCBuYW1lc1tjbGFzc05hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhvb2sgPSBpc0FwcGVhcmluZyA/IHRoaXMucHJvcHMub25BcHBlYXIgOiB0aGlzLnByb3BzLm9uRW50ZXI7XG4gICAgICAgIGhvb2sobm9kZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlRW50ZXJpbmcobm9kZSwgaXNBcHBlYXJpbmcpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWVzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKG5hbWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gaXNBcHBlYXJpbmcgPyAnYXBwZWFyQWN0aXZlJyA6ICdlbnRlckFjdGl2ZSc7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3Mobm9kZSwgbmFtZXNbY2xhc3NOYW1lXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGhvb2sgPSBpc0FwcGVhcmluZyA/IHRoaXMucHJvcHMub25BcHBlYXJpbmcgOiB0aGlzLnByb3BzLm9uRW50ZXJpbmc7XG4gICAgICAgICAgICBob29rKG5vZGUpO1xuICAgICAgICB9LCAxMCk7XG4gICAgfVxuXG4gICAgaGFuZGxlRW50ZXJlZChub2RlLCBpc0FwcGVhcmluZykge1xuICAgICAgICBjb25zdCB7IG5hbWVzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAobmFtZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBpc0FwcGVhcmluZyA/XG4gICAgICAgICAgICAgICAgW25hbWVzLmFwcGVhciwgbmFtZXMuYXBwZWFyQWN0aXZlXSA6XG4gICAgICAgICAgICAgICAgW25hbWVzLmVudGVyLCBuYW1lcy5lbnRlckFjdGl2ZV07XG4gICAgICAgICAgICBjbGFzc05hbWVzLmZvckVhY2goY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBob29rID0gaXNBcHBlYXJpbmcgPyB0aGlzLnByb3BzLm9uQXBwZWFyZWQgOiB0aGlzLnByb3BzLm9uRW50ZXJlZDtcbiAgICAgICAgaG9vayhub2RlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVFeGl0KG5vZGUpIHtcbiAgICAgICAgY29uc3QgeyBuYW1lcyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKG5hbWVzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzTmFtZXMobm9kZSwgbmFtZXMpO1xuICAgICAgICAgICAgYWRkQ2xhc3Mobm9kZSwgbmFtZXMubGVhdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vbkV4aXQobm9kZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlRXhpdGluZyhub2RlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lcyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChuYW1lcykge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKG5vZGUsIG5hbWVzLmxlYXZlQWN0aXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJvcHMub25FeGl0aW5nKG5vZGUpO1xuICAgICAgICB9LCAxMCk7XG4gICAgfVxuXG4gICAgaGFuZGxlRXhpdGVkKG5vZGUpIHtcbiAgICAgICAgY29uc3QgeyBuYW1lcyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKG5hbWVzKSB7XG4gICAgICAgICAgICBbbmFtZXMubGVhdmUsIG5hbWVzLmxlYXZlQWN0aXZlXS5mb3JFYWNoKGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vbkV4aXRlZChub2RlKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICAgIGNvbnN0IHsgbmFtZXMsXG4gICAgICAgICAgICBvbkFwcGVhciwgb25BcHBlYXJlZCwgb25BcHBlYXJpbmcsXG4gICAgICAgICAgICBvbkVudGVyLCBvbkVudGVyaW5nLCBvbkVudGVyZWQsXG4gICAgICAgICAgICBvbkV4aXQsIG9uRXhpdGluZywgb25FeGl0ZWQsXG4gICAgICAgICAgICAuLi5vdGhlcnNcbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPFRyYW5zaXRpb24gey4uLm90aGVyc31cbiAgICAgICAgICAgICAgICBvbkVudGVyPXt0aGlzLmhhbmRsZUVudGVyfVxuICAgICAgICAgICAgICAgIG9uRW50ZXJpbmc9e3RoaXMuaGFuZGxlRW50ZXJpbmd9XG4gICAgICAgICAgICAgICAgb25FbnRlcmVkPXt0aGlzLmhhbmRsZUVudGVyZWR9XG4gICAgICAgICAgICAgICAgb25FeGl0PXt0aGlzLmhhbmRsZUV4aXR9XG4gICAgICAgICAgICAgICAgb25FeGl0aW5nPXt0aGlzLmhhbmRsZUV4aXRpbmd9XG4gICAgICAgICAgICAgICAgb25FeGl0ZWQ9e3RoaXMuaGFuZGxlRXhpdGVkfVxuICAgICAgICAgICAgICAgIGFkZEVuZExpc3RlbmVyPXt0aGlzLmFkZEVuZExpc3RlbmVyfSAvPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hbmltYXRlL2NoaWxkLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgZnVuYywgZG9tIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgQW5pbWF0ZSBmcm9tICcuL2FuaW1hdGUnO1xuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5jb25zdCB7IGdldFN0eWxlIH0gPSBkb207XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV4cGFuZCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgYW5pbWF0aW9uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSksXG4gICAgICAgIGJlZm9yZUVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25FbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGFmdGVyRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBiZWZvcmVMZWF2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBhZnRlckxlYXZlOiBQcm9wVHlwZXMuZnVuY1xuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBiZWZvcmVFbnRlcjogbm9vcCxcbiAgICAgICAgb25FbnRlcjogbm9vcCxcbiAgICAgICAgYWZ0ZXJFbnRlcjogbm9vcCxcbiAgICAgICAgYmVmb3JlTGVhdmU6IG5vb3AsXG4gICAgICAgIG9uTGVhdmU6IG5vb3AsXG4gICAgICAgIGFmdGVyTGVhdmU6IG5vb3BcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICBmdW5jLmJpbmRDdHgodGhpcywgW1xuICAgICAgICAgICAgJ2JlZm9yZUVudGVyJywgJ29uRW50ZXInLCAnYWZ0ZXJFbnRlcicsXG4gICAgICAgICAgICAnYmVmb3JlTGVhdmUnLCAnb25MZWF2ZScsICdhZnRlckxlYXZlJ1xuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICBiZWZvcmVFbnRlcihub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmxlYXZpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJMZWF2ZShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FjaGVDdXJyZW50U3R5bGUobm9kZSk7XG4gICAgICAgIHRoaXMuY2FjaGVDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRTdHlsZVRvWmVybyhub2RlKTtcblxuICAgICAgICB0aGlzLnByb3BzLmJlZm9yZUVudGVyKG5vZGUpO1xuICAgIH1cblxuICAgIG9uRW50ZXIobm9kZSkge1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRTdHlsZVRvQ29tcHV0ZWRTdHlsZShub2RlKTtcblxuICAgICAgICB0aGlzLnByb3BzLm9uRW50ZXIobm9kZSk7XG4gICAgfVxuXG4gICAgYWZ0ZXJFbnRlcihub2RlKSB7XG4gICAgICAgIHRoaXMucmVzdG9yZUN1cnJlbnRTdHlsZShub2RlKTtcblxuICAgICAgICB0aGlzLnByb3BzLmFmdGVyRW50ZXIobm9kZSk7XG4gICAgfVxuXG4gICAgYmVmb3JlTGVhdmUobm9kZSkge1xuICAgICAgICB0aGlzLmxlYXZpbmcgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuY2FjaGVDdXJyZW50U3R5bGUobm9kZSk7XG4gICAgICAgIHRoaXMuY2FjaGVDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRTdHlsZVRvQ29tcHV0ZWRTdHlsZShub2RlKTtcblxuICAgICAgICB0aGlzLnByb3BzLmJlZm9yZUxlYXZlKG5vZGUpO1xuICAgIH1cblxuICAgIG9uTGVhdmUobm9kZSkge1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRTdHlsZVRvWmVybyhub2RlKTtcblxuICAgICAgICB0aGlzLnByb3BzLm9uTGVhdmUobm9kZSk7XG4gICAgfVxuXG4gICAgYWZ0ZXJMZWF2ZShub2RlKSB7XG4gICAgICAgIHRoaXMubGVhdmluZyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMucmVzdG9yZUN1cnJlbnRTdHlsZShub2RlKTtcblxuICAgICAgICB0aGlzLnByb3BzLmFmdGVyTGVhdmUobm9kZSk7XG4gICAgfVxuXG4gICAgY2FjaGVDdXJyZW50U3R5bGUobm9kZSkge1xuICAgICAgICB0aGlzLnN0eWxlQm9yZGVyVG9wV2lkdGggPSBub2RlLnN0eWxlLmJvcmRlclRvcFdpZHRoO1xuICAgICAgICB0aGlzLnN0eWxlUGFkZGluZ1RvcCA9IG5vZGUuc3R5bGUucGFkZGluZ1RvcDtcbiAgICAgICAgdGhpcy5zdHlsZUhlaWdodCA9IG5vZGUuc3R5bGUuaGVpZ2h0O1xuICAgICAgICB0aGlzLnN0eWxlUGFkZGluZ0JvdHRvbSA9IG5vZGUuc3R5bGUucGFkZGluZ0JvdHRvbTtcbiAgICAgICAgdGhpcy5zdHlsZUJvcmRlckJvdHRvbVdpZHRoID0gbm9kZS5zdHlsZS5ib3JkZXJCb3R0b21XaWR0aDtcbiAgICB9XG5cbiAgICBjYWNoZUNvbXB1dGVkU3R5bGUobm9kZSkge1xuICAgICAgICB0aGlzLmJvcmRlclRvcFdpZHRoID0gZ2V0U3R5bGUobm9kZSwgJ2JvcmRlclRvcFdpZHRoJyk7XG4gICAgICAgIHRoaXMucGFkZGluZ1RvcCA9IGdldFN0eWxlKG5vZGUsICdwYWRkaW5nVG9wJyk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gbm9kZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IGdldFN0eWxlKG5vZGUsICdwYWRkaW5nQm90dG9tJyk7XG4gICAgICAgIHRoaXMuYm9yZGVyQm90dG9tV2lkdGggPSBnZXRTdHlsZShub2RlLCAnYm9yZGVyQm90dG9tV2lkdGgnKTtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50U3R5bGVUb1plcm8obm9kZSkge1xuICAgICAgICBub2RlLnN0eWxlLmJvcmRlclRvcFdpZHRoID0gJzBweCc7XG4gICAgICAgIG5vZGUuc3R5bGUucGFkZGluZ1RvcCA9ICcwcHgnO1xuICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9ICcwcHgnO1xuICAgICAgICBub2RlLnN0eWxlLnBhZGRpbmdCb3R0b20gPSAnMHB4JztcbiAgICAgICAgbm9kZS5zdHlsZS5ib3JkZXJCb3R0b21XaWR0aCA9ICcwcHgnO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRTdHlsZVRvQ29tcHV0ZWRTdHlsZShub2RlKSB7XG4gICAgICAgIG5vZGUuc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBgJHt0aGlzLmJvcmRlclRvcFdpZHRofXB4YDtcbiAgICAgICAgbm9kZS5zdHlsZS5wYWRkaW5nVG9wID0gYCR7dGhpcy5wYWRkaW5nVG9wfXB4YDtcbiAgICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLmhlaWdodH1weGA7XG4gICAgICAgIG5vZGUuc3R5bGUucGFkZGluZ0JvdHRvbSA9IGAke3RoaXMucGFkZGluZ0JvdHRvbX1weGA7XG4gICAgICAgIG5vZGUuc3R5bGUuYm9yZGVyQm90dG9tV2lkdGggPSBgJHt0aGlzLmJvcmRlckJvdHRvbVdpZHRofXB4YDtcbiAgICB9XG5cbiAgICByZXN0b3JlQ3VycmVudFN0eWxlKG5vZGUpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5ib3JkZXJUb3BXaWR0aCA9IHRoaXMuc3R5bGVCb3JkZXJUb3BXaWR0aDtcbiAgICAgICAgbm9kZS5zdHlsZS5wYWRkaW5nVG9wID0gdGhpcy5zdHlsZVBhZGRpbmdUb3A7XG4gICAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gdGhpcy5zdHlsZUhlaWdodDtcbiAgICAgICAgbm9kZS5zdHlsZS5wYWRkaW5nQm90dG9tID0gdGhpcy5zdHlsZVBhZGRpbmdCb3R0b207XG4gICAgICAgIG5vZGUuc3R5bGUuYm9yZGVyQm90dG9tV2lkdGggPSB0aGlzLnN0eWxlQm9yZGVyQm90dG9tV2lkdGg7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbiwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBuZXdBbmltYXRpb24gPSBhbmltYXRpb24gfHwgJ2V4cGFuZCc7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxBbmltYXRlIHsuLi5vdGhlcnN9XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uPXtuZXdBbmltYXRpb259XG4gICAgICAgICAgICAgICAgYmVmb3JlRW50ZXI9e3RoaXMuYmVmb3JlRW50ZXJ9XG4gICAgICAgICAgICAgICAgb25FbnRlcj17dGhpcy5vbkVudGVyfVxuICAgICAgICAgICAgICAgIGFmdGVyRW50ZXI9e3RoaXMuYWZ0ZXJFbnRlcn1cbiAgICAgICAgICAgICAgICBiZWZvcmVMZWF2ZT17dGhpcy5iZWZvcmVMZWF2ZX1cbiAgICAgICAgICAgICAgICBvbkxlYXZlPXt0aGlzLm9uTGVhdmV9XG4gICAgICAgICAgICAgICAgYWZ0ZXJMZWF2ZT17dGhpcy5hZnRlckxlYXZlfSAvPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hbmltYXRlL2V4cGFuZC5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBDaGVja2FibGVJdGVtIGZyb20gJy4vY2hlY2thYmxlLWl0ZW0nO1xuXG4vKipcbiAqIE1lbnUuQ2hlY2tib3hJdGVtXG4gKiBAb3JkZXIgM1xuICogQGRlc2NyaXB0aW9uIOivpeWtkOe7hOS7tumAieS4reaDheWGteS4jeWPlyBkZWZhdWx0U2VsZWN0ZWRLZXlzL3NlbGVjdGVkS2V5cyDmjqfliLbvvIzor7foh6rooYzmjqfliLbpgInkuK3pgLvovpFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hlY2tib3hJdGVtIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgbWVudUNoaWxkVHlwZSA9ICdpdGVtJztcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbpgInkuK1cbiAgICAgICAgICovXG4gICAgICAgIGNoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5Y2K6YCJ5LitXG4gICAgICAgICAqL1xuICAgICAgICBpbmRldGVybWluYXRlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuemgeeUqFxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6YCJ5Lit5oiW5Y+W5raI6YCJ5Lit6Kem5Y+R55qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2hlY2tlZCDmmK/lkKbpgInkuK1cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOmAieS4reS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5biu5Yqp5paH5pysXG4gICAgICAgICAqL1xuICAgICAgICBoZWxwZXI6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICAvKipcbiAgICAgICAgICog5qCH562+5YaF5a65XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIGNoZWNrYm94RGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGNoZWNrZWQ6IGZhbHNlLFxuICAgICAgICBpbmRldGVybWluYXRlOiBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBvbkNoYW5nZTogKCkgPT4ge30sXG4gICAgICAgIGNoZWNrYm94RGlzYWJsZWQ6IGZhbHNlXG4gICAgfTtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBjaGVja2JveERpc2FibGVkLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiA8Q2hlY2thYmxlSXRlbSByb2xlPVwibWVudWl0ZW1jaGVja2JveFwiIGNoZWNrVHlwZT1cImNoZWNrYm94XCIgY2hlY2tEaXNhYmxlZD17Y2hlY2tib3hEaXNhYmxlZH0gey4uLm90aGVyc30gLz47XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21lbnUvdmlldy9jaGVja2JveC1pdGVtLmpzeCIsImltcG9ydCBSZWFjdCwge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IENvbmZpZ1Byb3ZpZGVyIGZyb20gJy4uL2NvbmZpZy1wcm92aWRlcic7XG5pbXBvcnQgeyBvYmogfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBDaGVja2JveCBmcm9tICcuL2NoZWNrYm94JztcblxuY29uc3QgeyBwaWNrT3RoZXJzIH0gPSBvYmo7XG5cbi8qKiBDaGVja2JveC5Hcm91cCAqL1xuY2xhc3MgQ2hlY2tib3hHcm91cCBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnnsbvlkI1cbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieWGheaVm+agt+W8j1xuICAgICAgICAgKi9cbiAgICAgICAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmlbTkvZPnpoHnlKhcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWPr+mAiemhueWIl+ihqCwg5pWw5o2u6aG55Y+v5Li6IFN0cmluZyDmiJbogIUgT2JqZWN0LCDlpoIgYFsnYXBwbGUnLCAncGVhcicsICdvcmFuZ2UnXWAg5oiW6ICFIGBbe3ZhbHVlOiAnYXBwbGUnLCBsYWJlbDogJ+iLueaenCcsfSwge3ZhbHVlOiAncGVhcicsIGxhYmVsOiAn5qKoJ30sIHt2YWx1ZTogJ29yYW5nZScsIGxhYmVsOiAn5qmZ5a2QJ31dYFxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YVNvdXJjZTogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmFueSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDooqvpgInkuK3nmoTlgLzliJfooahcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYXJyYXksIFByb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOm7mOiupOiiq+mAieS4reeahOWAvOWIl+ihqFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYXJyYXksIFByb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmAmui/h+WtkOWFg+e0oOaWueW8j+iuvue9ruWGhemDqCBjaGVja2JveFxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5lbGVtZW50KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmAieS4reWAvOaUueWPmOaXtueahOS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSDpgInkuK3pobnliJfooahcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSBEb20g5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWtkOmhueebrueahOaOkuWIl+aWueW8j1xuICAgICAgICAgKiAtIGhvejog5rC05bmz5o6S5YiXIChkZWZhdWx0KVxuICAgICAgICAgKiAtIHZlcjog5Z6C55u05o6S5YiXXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtRGlyZWN0aW9uOiBQcm9wVHlwZXMub25lT2YoW1xuICAgICAgICAgICAgJ2hveicsXG4gICAgICAgICAgICAndmVyJyxcbiAgICAgICAgXSksXG4gICAgfVxuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgZGF0YVNvdXJjZTogW10sXG4gICAgICAgIG9uQ2hhbmdlOiAoKSA9PiB7XG4gICAgICAgIH0sXG4gICAgICAgIHByZWZpeDogJ25leHQtJyxcbiAgICAgICAgaXRlbURpcmVjdGlvbjogJ2hveicsXG4gICAgfVxuXG4gICAgc3RhdGljIGNoaWxkQ29udGV4dFR5cGVzID0ge1xuICAgICAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIF9fZ3JvdXBfXzogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHNlbGVjdGVkVmFsdWU6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sXG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIGxldCB2YWx1ZSA9IFtdO1xuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBwcm9wcykge1xuICAgICAgICAgICAgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICgnZGVmYXVsdFZhbHVlJyBpbiBwcm9wcykge1xuICAgICAgICAgICAgdmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBbLi4udmFsdWVdLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSB0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX19ncm91cF9fOiB0cnVlLFxuICAgICAgICAgICAgb25DaGFuZ2U6IHRoaXMub25DaGFuZ2UsXG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlOiB0aGlzLnN0YXRlLnZhbHVlLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IHRoaXMucHJvcHMuZGlzYWJsZWRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIGxldCB7dmFsdWV9ID0gbmV4dFByb3BzO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uQ2hhbmdlKGN1cnJlbnRWYWx1ZSwgZSkge1xuICAgICAgICBjb25zdCB7dmFsdWV9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgaW5kZXggPSB2YWx1ZS5pbmRleE9mKGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIGNvbnN0IHZhbFRlbXAgPSBbLi4udmFsdWVdO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHZhbFRlbXAucHVzaChjdXJyZW50VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsVGVtcC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoJ3ZhbHVlJyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7dmFsdWU6IHZhbFRlbXB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHZhbFRlbXAsIGUpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBjbGFzc05hbWUsIHN0eWxlLCBwcmVmaXgsIGRpc2FibGVkLCBpdGVtRGlyZWN0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBvdGhlcnMgPSBwaWNrT3RoZXJzKENoZWNrYm94R3JvdXAucHJvcFR5cGVzLCB0aGlzLnByb3BzKTtcblxuICAgICAgICAvLyDlpoLmnpzlhoXltYzmoIfnrb7ot59kYXRhU291cmNl5ZCM5pe25a2Y5Zyo77yM5Lul5YaF5bWM5qCH562+5Li65Li7XG4gICAgICAgIGxldCBjaGlsZHJlbjtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5kYXRhU291cmNlLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgb3B0aW9uID0gaXRlbTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja2VkID0gdGhpcy5zdGF0ZS52YWx1ZSAmJiB0aGlzLnN0YXRlLnZhbHVlLmluZGV4T2Yob3B0aW9uLnZhbHVlKSA+IC0xO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94IGtleT17aW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17b3B0aW9uLnZhbHVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZCB8fCBvcHRpb24uZGlzYWJsZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD17b3B0aW9uLmxhYmVsfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNscyA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1jaGVja2JveC1ncm91cGBdOiB0cnVlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1jaGVja2JveC1ncm91cC0ke2l0ZW1EaXJlY3Rpb259YF06IHRydWUsXG4gICAgICAgICAgICBbY2xhc3NOYW1lXTogISFjbGFzc05hbWUsXG4gICAgICAgICAgICBkaXNhYmxlZFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gPHNwYW4gey4uLm90aGVyc30gY2xhc3NOYW1lPXtjbHN9IHN0eWxlPXtzdHlsZX0+e2NoaWxkcmVufTwvc3Bhbj47XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb25maWdQcm92aWRlci5jb25maWcoQ2hlY2tib3hHcm91cCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY2hlY2tib3gvY2hlY2tib3gtZ3JvdXAuanN4IiwiaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgQ29uZmlnUHJvdmlkZXIgZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCB7IG9iaiB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IFJhZGlvIGZyb20gJy4vcmFkaW8nO1xuXG5jb25zdCB7IHBpY2tPdGhlcnMgfSA9IG9iajtcblxuLyoqXG4gKiBSYWRpby5Hcm91cFxuICogQG9yZGVyIDJcbiAqL1xuY2xhc3MgUmFkaW9Hcm91cCBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5qC35byP57G75ZCN55qE5ZOB54mM5YmN57yAXG4gICAgICAgICAqL1xuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnnsbvlkI1cbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieWGheaVm+agt+W8j1xuICAgICAgICAgKi9cbiAgICAgICAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBuYW1lXG4gICAgICAgICAqL1xuICAgICAgICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICogcmFkaW8gZ3JvdXDnmoTpgInkuK3pobnnmoTlgLxcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuYm9vbF0pLFxuICAgICAgICAvKipcbiAgICAgICAgICogcmFkaW8gZ3JvdXDnmoTpu5jorqTlgLxcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLmJvb2xdKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmAieS4reWAvOaUueWPmOaXtueahOS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZy9OdW1iZXJ9IHZhbHVlIOmAieS4remhueeahOWAvFxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIERvbSDkuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOihqOekunJhZGlv6KKr56aB55SoXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlj6/ku6Xorr7nva7miJAgYnV0dG9uIOWxleekuuW9oueKtlxuICAgICAgICAgKiBAZW51bWRlc2Mg5oyJ6ZKu54q2XG4gICAgICAgICAqL1xuICAgICAgICBzaGFwZTogUHJvcFR5cGVzLm9uZU9mKFsnYnV0dG9uJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5LiOIGBzaGFwZWAg5bGe5oCn6YWN5aWX5L2/55So77yMc2hhcGXorr7kuLpidXR0b27ml7bmnInmlYhcbiAgICAgICAgICogQGVudW1kZXNjIOWkpywg5LitLCDlsI9cbiAgICAgICAgICovXG4gICAgICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ2xhcmdlJywgJ21lZGl1bScsICdzbWFsbCddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWPr+mAiemhueWIl+ihqCwg5pWw5o2u6aG55Y+v5Li6IFN0cmluZyDmiJbogIUgT2JqZWN0LCDlpoIgYFsnYXBwbGUnLCAncGVhcicsICdvcmFuZ2UnXWBcbiAgICAgICAgICovXG4gICAgICAgIGRhdGFTb3VyY2U6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5hbnkpLFxuICAgICAgICAvKipcbiAgICAgICAgICog6YCa6L+H5a2Q5YWD57Sg5pa55byP6K6+572u5YaF6YOocmFkaW9cbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuZWxlbWVudCksIFByb3BUeXBlcy5lbGVtZW50XSksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWtkOmhueebrueahOaOkuWIl+aWueW8j1xuICAgICAgICAgKiAtIGhvejog5rC05bmz5o6S5YiXIChkZWZhdWx0KVxuICAgICAgICAgKiAtIHZlcjog5Z6C55u05o6S5YiXXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtRGlyZWN0aW9uOiBQcm9wVHlwZXMub25lT2YoW1xuICAgICAgICAgICAgJ2hveicsXG4gICAgICAgICAgICAndmVyJyxcbiAgICAgICAgXSksXG4gICAgfVxuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgZGF0YVNvdXJjZTogW10sXG4gICAgICAgIHNpemU6ICdtZWRpdW0nLFxuICAgICAgICBvbkNoYW5nZTogKCkgPT4ge1xuICAgICAgICB9LFxuICAgICAgICBwcmVmaXg6ICduZXh0LScsXG4gICAgICAgIGl0ZW1EaXJlY3Rpb246ICdob3onLFxuICAgIH1cblxuICAgIHN0YXRpYyBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBfX2dyb3VwX186IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBpc0J1dHRvbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHNlbGVjdGVkVmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5ib29sXSksXG4gICAgICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbFxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgbGV0IHZhbHVlID0gJyc7XG4gICAgICAgIGlmICgndmFsdWUnIGluIHByb3BzKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKCdkZWZhdWx0VmFsdWUnIGluIHByb3BzKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0ge3ZhbHVlfTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfX2dyb3VwX186IHRydWUsXG4gICAgICAgICAgICBpc0J1dHRvbjogdGhpcy5wcm9wcy5zaGFwZSA9PT0gJ2J1dHRvbicsXG4gICAgICAgICAgICBvbkNoYW5nZTogdGhpcy5vbkNoYW5nZSxcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWU6IHRoaXMuc3RhdGUudmFsdWUsXG4gICAgICAgICAgICBkaXNhYmxlZDogdGhpcy5wcm9wcy5kaXNhYmxlZFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIGxldCB7dmFsdWV9ID0gbmV4dFByb3BzO1xuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uQ2hhbmdlKGN1cnJlbnRWYWx1ZSwgZSkge1xuICAgICAgICBpZiAoISgndmFsdWUnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHt2YWx1ZTogY3VycmVudFZhbHVlfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSAhPT0gdGhpcy5zdGF0ZS52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShjdXJyZW50VmFsdWUsIGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHJ0bCwgY2xhc3NOYW1lLCBzaGFwZSwgc2l6ZSwgc3R5bGUsIHByZWZpeCwgaXRlbURpcmVjdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gcGlja090aGVycyhPYmplY3Qua2V5cyhSYWRpb0dyb3VwLnByb3BUeXBlcyksIHRoaXMucHJvcHMpO1xuICAgICAgICBjb25zdCBkaXNhYmxlZCA9IHRoaXMucHJvcHMuZGlzYWJsZWQ7XG5cbiAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgb3RoZXJzLmRpciA9ICdydGwnO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNoaWxkcmVuO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmRhdGFTb3VyY2UubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBvcHRpb24gPSBpdGVtO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSB0aGlzLnN0YXRlLnZhbHVlID09PSBvcHRpb24udmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuICg8UmFkaW9cbiAgICAgICAgICAgICAgICAgICAga2V5PXtpbmRleH1cbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg9eygoaW5kZXggPT09IDAgJiYgIXRoaXMuc3RhdGUudmFsdWUpIHx8IGNoZWNrZWQpID8gMCA6IC0xfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17b3B0aW9uLnZhbHVlfVxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXtjaGVja2VkfVxuICAgICAgICAgICAgICAgICAgICBsYWJlbD17b3B0aW9uLmxhYmVsfVxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWQgfHwgb3B0aW9uLmRpc2FibGVkfVxuICAgICAgICAgICAgICAgIC8+KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNCdXR0b25TaGFwZSA9IHNoYXBlID09PSAnYnV0dG9uJztcblxuICAgICAgICBjb25zdCBjbHMgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9cmFkaW8tZ3JvdXBgXTogdHJ1ZSxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9cmFkaW8tZ3JvdXAtJHtpdGVtRGlyZWN0aW9ufWBdOiAhaXNCdXR0b25TaGFwZSxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9cmFkaW8tYnV0dG9uYF06IGlzQnV0dG9uU2hhcGUsXG4gICAgICAgICAgICBbYCR7cHJlZml4fXJhZGlvLWJ1dHRvbi0ke3NpemV9YF06IGlzQnV0dG9uU2hhcGUsXG4gICAgICAgICAgICBbY2xhc3NOYW1lXTogISFjbGFzc05hbWUsXG4gICAgICAgICAgICBkaXNhYmxlZFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gPGRpdiB7Li4ub3RoZXJzfSBhcmlhLWRpc2FibGVkPXtkaXNhYmxlZH0gcm9sZT1cInJhZGlvZ3JvdXBcIiBjbGFzc05hbWU9e2Nsc30gc3R5bGU9e3N0eWxlfT57Y2hpbGRyZW59PC9kaXY+O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlnUHJvdmlkZXIuY29uZmlnKFJhZGlvR3JvdXApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JhZGlvL3JhZGlvLWdyb3VwLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENoZWNrYWJsZUl0ZW0gZnJvbSAnLi9jaGVja2FibGUtaXRlbSc7XG5cbi8qKlxuICogTWVudS5SYWRpb0l0ZW1cbiAqIEBvcmRlciA0XG4gKiBAZGVzY3JpcHRpb24g6K+l5a2Q57uE5Lu26YCJ5Lit5oOF5Ya15LiN5Y+XIGRlZmF1bHRTZWxlY3RlZEtleXMvc2VsZWN0ZWRLZXlzIOaOp+WItu+8jOivt+iHquihjOaOp+WItumAieS4remAu+i+kVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRpb0l0ZW0gZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBtZW51Q2hpbGRUeXBlID0gJ2l0ZW0nO1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpumAieS4rVxuICAgICAgICAgKi9cbiAgICAgICAgY2hlY2tlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbnpoHnlKhcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmAieS4reaIluWPlua2iOmAieS4reinpuWPkeeahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNoZWNrZWQg5piv5ZCm6YCJ5LitXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDpgInkuK3kuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW4ruWKqeaWh+acrFxuICAgICAgICAgKi9cbiAgICAgICAgaGVscGVyOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOagh+etvuWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGNoZWNrZWQ6IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIG9uQ2hhbmdlOiAoKSA9PiB7fVxuICAgIH07XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiA8Q2hlY2thYmxlSXRlbSByb2xlPVwibWVudWl0ZW1yYWRpb1wiIGNoZWNrVHlwZT1cInJhZGlvXCIgey4uLnRoaXMucHJvcHN9IC8+O1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tZW51L3ZpZXcvcmFkaW8taXRlbS5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBjbG9uZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IEl0ZW0gZnJvbSAnLi9pdGVtJztcblxuLyoqXG4gKiBNZW51Lkdyb3VwXG4gKiBAb3JkZXIgNVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcm91cCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIG1lbnVDaGlsZFR5cGUgPSAnZ3JvdXAnO1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgcm9vdDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog5qCH562+5YaF5a65XG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoj5zljZXpoblcbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgcGFyZW50TW9kZTogUHJvcFR5cGVzLm9uZU9mKFsnaW5saW5lJywgJ3BvcHVwJ10pLFxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyByb290LCBjbGFzc05hbWUsIGxhYmVsLCBjaGlsZHJlbiwgcGFyZW50TW9kZSwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHByZWZpeCB9ID0gcm9vdC5wcm9wcztcblxuICAgICAgICBjb25zdCBuZXdDbGFzc05hbWUgPSBjeCh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fW1lbnUtZ3JvdXAtbGFiZWxgXTogdHJ1ZSxcbiAgICAgICAgICAgIFtjbGFzc05hbWVdOiAhIWNsYXNzTmFtZVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBuZXdDaGlsZHJlbiA9IGNoaWxkcmVuLm1hcChjaGlsZCA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNsYXNzTmFtZSB9ID0gY2hpbGQucHJvcHM7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGlsZENsYXNzTmFtZSA9IGN4KHtcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4fW1lbnUtZ3JvdXAtaXRlbWBdOiB0cnVlLFxuICAgICAgICAgICAgICAgIFtjbGFzc05hbWVdOiAhIWNsYXNzTmFtZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBjbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRNb2RlLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogbmV3Q2hpbGRDbGFzc05hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgPEl0ZW1cbiAgICAgICAgICAgICAgICBrZXk9XCJtZW51LWdyb3VwLWxhYmVsXCJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e25ld0NsYXNzTmFtZX1cbiAgICAgICAgICAgICAgICByZXBsYWNlQ2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgcm9vdD17cm9vdH1cbiAgICAgICAgICAgICAgICBwYXJlbnRNb2RlPXtwYXJlbnRNb2RlfVxuICAgICAgICAgICAgICAgIHsuLi5vdGhlcnN9PntsYWJlbH08L0l0ZW0+LFxuICAgICAgICAgICAgLi4ubmV3Q2hpbGRyZW5cbiAgICAgICAgXTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWVudS92aWV3L2dyb3VwLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuXG4vKipcbiAqIE1lbnUuRGl2aWRlclxuICogQG9yZGVyIDZcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGl2aWRlciBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIG1lbnVDaGlsZFR5cGUgPSAnZGl2aWRlcic7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICByb290OiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHJvb3QsIGNsYXNzTmFtZSwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHByZWZpeCB9ID0gcm9vdC5wcm9wcztcblxuICAgICAgICBjb25zdCBuZXdDbGFzc05hbWUgPSBjeCh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fW1lbnUtZGl2aWRlcmBdOiB0cnVlLFxuICAgICAgICAgICAgW2NsYXNzTmFtZV06ICEhY2xhc3NOYW1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8bGkgcm9sZT1cInNlcGFyYXRvclwiIGNsYXNzTmFtZT17bmV3Q2xhc3NOYW1lfSB7Li4ub3RoZXJzfT48L2xpPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tZW51L3ZpZXcvZGl2aWRlci5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcmVuZGVyLCB1bm1vdW50Q29tcG9uZW50QXROb2RlIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgT3ZlcmxheSBmcm9tICcuLi8uLi9vdmVybGF5JztcbmltcG9ydCB7IGZ1bmMgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCBDb25maWdQcm92aWRlciBmcm9tICcuLi8uLi9jb25maWctcHJvdmlkZXInO1xuaW1wb3J0IG1lbnUgZnJvbSAnLi9tZW51JztcblxuY29uc3QgeyBiaW5kQ3R4IH0gPSBmdW5jO1xuY29uc3QgeyBnZXRDb250ZXh0UHJvcHMgfSA9IENvbmZpZ1Byb3ZpZGVyO1xuY29uc3QgTWVudSA9IENvbmZpZ1Byb3ZpZGVyLmNvbmZpZyhtZW51KTtcblxubGV0IG1lbnVJbnN0YW5jZTtcblxuY2xhc3MgQ29udGV4dE1lbnUgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcG9wdXBDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHRhcmdldDogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgYWxpZ246IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIG9mZnNldDogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBvdmVybGF5UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIGFmdGVyQ2xvc2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBtb2RlOiBQcm9wVHlwZXMub25lT2YoWydpbmxpbmUnLCAncG9wdXAnXSksXG4gICAgICAgIG9uT3BlbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uSXRlbUNsaWNrOiBQcm9wVHlwZXMuZnVuY1xuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBwcmVmaXg6ICduZXh0LScsXG4gICAgICAgIGFsaWduOiAndGwgdGwnLFxuICAgICAgICBtb2RlOiAncG9wdXAnXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIGJpbmRDdHgodGhpcywgWydoYW5kbGVPdmVybGF5Q2xvc2UnLCAnaGFuZGxlT3ZlcmxheU9wZW4nLCAnaGFuZGxlSXRlbUNsaWNrJywgJ2dldE92ZXJsYXknXSk7XG4gICAgfVxuXG4gICAgZ2V0T3ZlcmxheShyZWYpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gcmVmO1xuICAgIH1cblxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBtZW51SW5zdGFuY2UgPSBudWxsO1xuICAgIH1cblxuICAgIGhhbmRsZU92ZXJsYXlDbG9zZSh0cmlnZ2VyVHlwZSwgZSwgLi4ub3RoZXJzKSB7XG4gICAgICAgIGNvbnN0IGNsaWNrZWRQb3B1cE1lbnUgPSB0cmlnZ2VyVHlwZSA9PT0gJ2RvY0NsaWNrJyAmJlxuICAgICAgICAgICAgdGhpcy5wb3B1cE5vZGVzLnNvbWUobm9kZSA9PiBub2RlLmNvbnRhaW5zKGUudGFyZ2V0KSk7XG4gICAgICAgIGlmICghY2xpY2tlZFBvcHVwTWVudSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgY29uc3QgeyBvdmVybGF5UHJvcHMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAob3ZlcmxheVByb3BzICYmIG92ZXJsYXlQcm9wcy5vblJlcXVlc3RDbG9zZSkge1xuICAgICAgICAgICAgICAgIG92ZXJsYXlQcm9wcy5vblJlcXVlc3RDbG9zZSh0cmlnZ2VyVHlwZSwgZSwgLi4ub3RoZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZU92ZXJsYXlPcGVuKCkge1xuICAgICAgICB0aGlzLnBvcHVwTm9kZXMgPSB0aGlzLm92ZXJsYXkuZ2V0SW5zdGFuY2UoKS5nZXRDb250ZW50KCkuZ2V0SW5zdGFuY2UoKS5wb3B1cE5vZGVzO1xuICAgICAgICBjb25zdCB7IG92ZXJsYXlQcm9wcyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKG92ZXJsYXlQcm9wcyAmJiBvdmVybGF5UHJvcHMub25PcGVuKSB7XG4gICAgICAgICAgICBvdmVybGF5UHJvcHMub25PcGVuKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGhhbmRsZUl0ZW1DbGljayguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcblxuICAgICAgICB0aGlzLnByb3BzLm9uSXRlbUNsaWNrICYmIHRoaXMucHJvcHMub25JdGVtQ2xpY2soLi4uYXJncyk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGNsYXNzTmFtZSwgcG9wdXBDbGFzc05hbWUsIHRhcmdldCwgYWxpZ24sIG9mZnNldCwgYWZ0ZXJDbG9zZSwgb3ZlcmxheVByb3BzID0ge30sIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgY29udGV4dFByb3BzID0gZ2V0Q29udGV4dFByb3BzKHRoaXMucHJvcHMpO1xuICAgICAgICBjb25zdCB7IHByZWZpeCB9ID0gY29udGV4dFByb3BzO1xuICAgICAgICBjb25zdCB7IHZpc2libGUgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgY29uc3QgbmV3T3ZlcmxheVByb3BzID0ge1xuICAgICAgICAgICAgLi4uY29udGV4dFByb3BzLFxuICAgICAgICAgICAgLi4ub3ZlcmxheVByb3BzLFxuICAgICAgICAgICAgdGFyZ2V0LCBhbGlnbiwgb2Zmc2V0LCBhZnRlckNsb3NlLCB2aXNpYmxlLFxuICAgICAgICAgICAgb25SZXF1ZXN0Q2xvc2U6IHRoaXMuaGFuZGxlT3ZlcmxheUNsb3NlLFxuICAgICAgICAgICAgb25PcGVuOiB0aGlzLmhhbmRsZU92ZXJsYXlPcGVuLFxuICAgICAgICAgICAgcmVmOiB0aGlzLmdldE92ZXJsYXlcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWVudVByb3BzID0ge1xuICAgICAgICAgICAgLi4uY29udGV4dFByb3BzLFxuICAgICAgICAgICAgdHJpZ2dlclR5cGU6ICdob3ZlcicsXG4gICAgICAgICAgICAuLi5vdGhlcnMsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGN4KHtcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4fWNvbnRleHRgXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBbY2xhc3NOYW1lXTogISFjbGFzc05hbWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcG9wdXBDbGFzc05hbWU6IGN4KHtcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4fWNvbnRleHRgXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBbcG9wdXBDbGFzc05hbWVdOiAhIXBvcHVwQ2xhc3NOYW1lXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9uSXRlbUNsaWNrOiB0aGlzLmhhbmRsZUl0ZW1DbGlja1xuICAgICAgICB9O1xuXG4gICAgICAgIG5ld092ZXJsYXlQcm9wcy5ydGwgPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPE92ZXJsYXkgey4uLm5ld092ZXJsYXlQcm9wc30+XG4gICAgICAgICAgICAgICAgPE1lbnUgey4uLm1lbnVQcm9wc30gLz5cbiAgICAgICAgICAgIDwvT3ZlcmxheT5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICog5Yib5bu65LiK5LiL5paH6I+c5Y2VXG4gKiBAZXhwb3J0TmFtZSBjcmVhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyDlsZ7mgKflr7nosaFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlKHByb3BzKSB7XG4gICAgaWYgKG1lbnVJbnN0YW5jZSkge1xuICAgICAgICBtZW51SW5zdGFuY2UuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgY29uc3QgeyBhZnRlckNsb3NlLCAuLi5vdGhlcnMgfSA9IHByb3BzO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcblxuICAgIGNvbnN0IGNsb3NlQ2hhaW4gPSAoKSA9PiB7XG4gICAgICAgIHVubW91bnRDb21wb25lbnRBdE5vZGUoZGl2KTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuXG4gICAgICAgIGFmdGVyQ2xvc2UgJiYgYWZ0ZXJDbG9zZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBuZXdDb250ZXh0ID0gQ29uZmlnUHJvdmlkZXIuZ2V0Q29udGV4dCgpO1xuXG4gICAgbGV0IG1lbnU7XG4gICAgcmVuZGVyKFxuICAgICAgICA8Q29uZmlnUHJvdmlkZXIgey4uLm5ld0NvbnRleHR9PlxuICAgICAgICAgICAgPENvbnRleHRNZW51IHJlZj17cmVmID0+IHtcbiAgICAgICAgICAgICAgICBtZW51ID0gcmVmO1xuICAgICAgICAgICAgfX0gYWZ0ZXJDbG9zZT17Y2xvc2VDaGFpbn0gey4uLm90aGVyc30gLz5cbiAgICAgICAgPC9Db25maWdQcm92aWRlcj5cbiAgICAgICAgLCBkaXZcbiAgICApO1xuXG4gICAgbWVudUluc3RhbmNlID0ge1xuICAgICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAobWVudSkge1xuICAgICAgICAgICAgICAgIG1lbnUuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gbWVudUluc3RhbmNlO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21lbnUvdmlldy9jcmVhdGUuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmZ1bmN0aW9uIG1hcEljb25TaXplKHNpemUpIHtcbiAgICByZXR1cm4gKHtcbiAgICAgICAgbGFyZ2U6ICdzbWFsbCcsXG4gICAgICAgIG1lZGl1bTogJ3hzJyxcbiAgICAgICAgc21hbGw6ICd4cycsXG4gICAgfSlbc2l6ZV07XG59XG5cbi8qKiBCdXR0b24gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1dHRvbiBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBydGw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5oyJ6ZKu55qE57G75Z6LXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiBQcm9wVHlwZXMub25lT2YoWydwcmltYXJ5JywgJ3NlY29uZGFyeScsICdub3JtYWwnXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmjInpkq7nmoTlsLrlr7hcbiAgICAgICAgICovXG4gICAgICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3NtYWxsJywgJ21lZGl1bScsICdsYXJnZSddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaMiemSruS4rSBJY29uIOeahOWwuuWvuO+8jOeUqOS6juabv+S7oyBJY29uIOeahOm7mOiupOWkp+Wwj1xuICAgICAgICAgKi9cbiAgICAgICAgaWNvblNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3h4cycsICd4cycsICdzbWFsbCcsICdtZWRpdW0nLCAnbGFyZ2UnLCAneGwnLCAneHhsJywgJ3h4eGwnXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvZMgY29tcG9uZW50ID0gJ2J1dHRvbicg5pe277yM6K6+572uIGJ1dHRvbiDmoIfnrb7nmoQgdHlwZSDlgLxcbiAgICAgICAgICovXG4gICAgICAgIGh0bWxUeXBlOiBQcm9wVHlwZXMub25lT2YoWydzdWJtaXQnLCAncmVzZXQnLCAnYnV0dG9uJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5qCH562+57G75Z6LXG4gICAgICAgICAqL1xuICAgICAgICBjb21wb25lbnQ6IFByb3BUeXBlcy5vbmVPZihbJ2J1dHRvbicsICdhJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5oyJ6ZKu55qE6L295YWl54q25oCBXG4gICAgICAgICAqL1xuICAgICAgICBsb2FkaW5nOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuS4uuW5veeBteaMiemSrlxuICAgICAgICAgKi9cbiAgICAgICAgZ2hvc3Q6IFByb3BUeXBlcy5vbmVPZihbdHJ1ZSwgZmFsc2UsICdsaWdodCcsICdkYXJrJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5Li65paH5pys5oyJ6ZKuXG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuS4uuitpuWRiuaMiemSrlxuICAgICAgICAgKi9cbiAgICAgICAgd2FybmluZzogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbnpoHnlKhcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeCueWHu+aMiemSrueahOWbnuiwg1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZSBFdmVudCBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIG9uTW91c2VVcDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBwcmVmaXg6ICduZXh0LScsXG4gICAgICAgIHR5cGU6ICdub3JtYWwnLFxuICAgICAgICBzaXplOiAnbWVkaXVtJyxcbiAgICAgICAgaHRtbFR5cGU6ICdidXR0b24nLFxuICAgICAgICBjb21wb25lbnQ6ICdidXR0b24nLFxuICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZ2hvc3Q6IGZhbHNlLFxuICAgICAgICB0ZXh0OiBmYWxzZSxcbiAgICAgICAgd2FybmluZzogZmFsc2UsXG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgb25DbGljazogKCkgPT4ge31cbiAgICB9O1xuXG4gICAgb25Nb3VzZVVwID0gKGUpID0+IHtcbiAgICAgICAgdGhpcy5idXR0b24uYmx1cigpO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uTW91c2VVcCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbk1vdXNlVXAoZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYnV0dG9uUmVmSGFuZGxlciA9IChidXR0b24pID0+IHtcbiAgICAgICAgdGhpcy5idXR0b24gPSBidXR0b247XG4gICAgfTtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIGNsYXNzTmFtZSwgdHlwZSwgc2l6ZSwgaHRtbFR5cGUsIGxvYWRpbmcsIHRleHQsIHdhcm5pbmcsIGdob3N0LCBjb21wb25lbnQsIGljb25TaXplLCBjaGlsZHJlbiwgcnRsLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGdob3N0VHlwZSA9IFsnbGlnaHQnLCAnZGFyayddLmluZGV4T2YoZ2hvc3QpID49IDAgPyBnaG9zdCA6ICdkYXJrJztcblxuICAgICAgICBjb25zdCBidG5DbHMgPSBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9YnRuYF06IHRydWUsXG4gICAgICAgICAgICBbYCR7cHJlZml4fSR7c2l6ZX1gXTogc2l6ZSxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9YnRuLSR7dHlwZX1gXTogdHlwZSAmJiAhZ2hvc3QsXG4gICAgICAgICAgICBbYCR7cHJlZml4fWJ0bi10ZXh0YF06IHRleHQsXG4gICAgICAgICAgICBbYCR7cHJlZml4fWJ0bi13YXJuaW5nYF06IHdhcm5pbmcsXG4gICAgICAgICAgICBbYCR7cHJlZml4fWJ0bi1sb2FkaW5nYF06IGxvYWRpbmcsXG4gICAgICAgICAgICBbYCR7cHJlZml4fWJ0bi1naG9zdGBdOiBnaG9zdCxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9YnRuLSR7Z2hvc3RUeXBlfWBdOiBnaG9zdCxcbiAgICAgICAgICAgIFtjbGFzc05hbWVdOiBjbGFzc05hbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgY291bnQgPSBDaGlsZHJlbi5jb3VudChjaGlsZHJlbik7XG4gICAgICAgIGNvbnN0IGNsb25lZENoaWxkcmVuID0gQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCAoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgJiYgdHlwZW9mIGNoaWxkLnR5cGUgPT09ICdmdW5jdGlvbicgJiYgY2hpbGQudHlwZS5fdHlwZU1hcmsgPT09ICdpY29uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGljb25DbHMgPSBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1idG4taWNvbmBdOiAhaWNvblNpemUsIC8vIOWmguaenOeUqOaIt+ayoeacieS8oCBpY29uU2l6Ze+8jOWImeS9v+eUqOivpeagt+W8j+agh+iusCBpY29uIOS4uiBidXR0b24g6aKE6K6+5bC65a+4XG4gICAgICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9aWNvbi1maXJzdGBdOiBjb3VudCA+IDEgJiYgaW5kZXggPT09IDAsXG4gICAgICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9aWNvbi1sYXN0YF06IGNvdW50ID4gMSAmJiBpbmRleCA9PT0gY291bnQgLSAxLFxuICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4fWljb24tYWxvbmVgXTogY291bnQgPT09IDEsXG4gICAgICAgICAgICAgICAgICAgIFtjaGlsZC5wcm9wcy5jbGFzc05hbWVdOiAhIWNoaWxkLnByb3BzLmNsYXNzTmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xzLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBpY29uU2l6ZSB8fCBtYXBJY29uU2l6ZShzaXplKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IFRhZ05hbWUgPSBjb21wb25lbnQ7XG4gICAgICAgIGNvbnN0IHRhZ0F0dHJzID0ge1xuICAgICAgICAgICAgLi4ub3RoZXJzLFxuICAgICAgICAgICAgdHlwZTogaHRtbFR5cGUsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGJ0bkNsc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChUYWdOYW1lID09PSAnYScpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0YWdBdHRycy50eXBlO1xuXG4gICAgICAgICAgICBpZiAodGFnQXR0cnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGFnQXR0cnMub25DbGljazsgLy8gYSDmoIfnrb7nmoQgb25DbGljayDmtY/op4jlmajpu5jorqTkuI3kvJrnpoHnlKhcbiAgICAgICAgICAgICAgICB0YWdBdHRycy5ocmVmICYmIGRlbGV0ZSB0YWdBdHRycy5ocmVmOyAvLyBhIOagh+etvuWcqOemgeeUqOeKtuaAgeS4i+aXoOi3s+i9rFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxUYWdOYW1lIHsuLi50YWdBdHRyc30gZGlyPXtydGwgPyAncnRsJyA6IHVuZGVmaW5lZH0gb25Nb3VzZVVwPXt0aGlzLm9uTW91c2VVcH0gcmVmPXt0aGlzLmJ1dHRvblJlZkhhbmRsZXJ9IHJvbGU9XCJidXR0b25cIj5cbiAgICAgICAgICAgICAgICB7Y2xvbmVkQ2hpbGRyZW59XG4gICAgICAgICAgICA8L1RhZ05hbWU+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2J1dHRvbi92aWV3L2J1dHRvbi5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBDb25maWdQcm92aWRlciBmcm9tICcuLi8uLi9jb25maWctcHJvdmlkZXInO1xuXG4vKipcbiAqIEJ1dHRvbi5Hcm91cFxuICovXG5jbGFzcyBCdXR0b25Hcm91cCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgcnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog57uf5LiA6K6+572uIEJ1dHRvbiDnu4Tku7bnmoTmjInpkq7lpKflsI9cbiAgICAgICAgICovXG4gICAgICAgIHNpemU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHByZWZpeDogJ25leHQtJyxcbiAgICAgICAgc2l6ZTogJ21lZGl1bScsXG4gICAgfTtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIGNsYXNzTmFtZSwgc2l6ZSwgY2hpbGRyZW4sIHJ0bCwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGNvbnN0IGdyb3VwQ2xzID0gY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fWJ0bi1ncm91cGBdOiB0cnVlLFxuICAgICAgICAgICAgW2NsYXNzTmFtZV06IGNsYXNzTmFtZVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBjbG9uZUNoaWxkcmVuID0gQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgICBvdGhlcnMuZGlyID0gJ3J0bCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiB7Li4ub3RoZXJzfSBjbGFzc05hbWU9e2dyb3VwQ2xzfT5cbiAgICAgICAgICAgICAgICB7Y2xvbmVDaGlsZHJlbn1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlnUHJvdmlkZXIuY29uZmlnKEJ1dHRvbkdyb3VwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9idXR0b24vdmlldy9ncm91cC5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFQgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBldmVudHMsIGRvbSB9IGZyb20gJy4uLy4uL3V0aWwnO1xuXG5jbGFzcyBSZXNpemUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHByZWZpeDogVC5zdHJpbmcsXG4gICAgICAgIG9uQ2hhbmdlOiBULmZ1bmMsXG4gICAgICAgIGRhdGFJbmRleDogVC5zdHJpbmdcbiAgICB9XG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgb25DaGFuZ2U6ICgpID0+IHt9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLmRlc3RvcnkoKTtcbiAgICB9XG4gICAgb25Nb3VzZURvd24gPSAoZSkgPT4ge1xuICAgICAgICB0aGlzLmxhc3RQYWdlWCA9IGUucGFnZVg7XG4gICAgICAgIGV2ZW50cy5vbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgICAgICBldmVudHMub24oZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXApO1xuICAgICAgICB0aGlzLnVuU2VsZWN0KCk7XG4gICAgfVxuICAgIG9uTW91c2VNb3ZlID0gKGUpID0+IHtcbiAgICAgICAgY29uc3QgcGFnZVggPSBlLnBhZ2VYO1xuICAgICAgICBjb25zdCBjaGFuZ2VkUGFnZVggPSBwYWdlWCAtIHRoaXMubGFzdFBhZ2VYO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHRoaXMucHJvcHMuZGF0YUluZGV4LCBjaGFuZ2VkUGFnZVgpO1xuICAgICAgICB0aGlzLmxhc3RQYWdlWCA9IHBhZ2VYO1xuICAgIH1cbiAgICBvbk1vdXNlVXAgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuZGVzdG9yeSgpO1xuICAgIH1cbiAgICBkZXN0b3J5KCkge1xuICAgICAgICBldmVudHMub2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICAgIGV2ZW50cy5vZmYoZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgfVxuICAgIHVuU2VsZWN0KCkge1xuICAgICAgICBkb20uc2V0U3R5bGUoZG9jdW1lbnQuYm9keSwge1xuICAgICAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICAgICAgY3Vyc29yOiAnZXctcmVzaXplJ1xuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUoJ3Vuc2VsZWN0YWJsZScsICdvbicpO1xuICAgIH1cbiAgICBzZWxlY3QoKSB7XG4gICAgICAgIGRvbS5zZXRTdHlsZShkb2N1bWVudC5ib2R5LCB7XG4gICAgICAgICAgICB1c2VyU2VsZWN0OiAnJyxcbiAgICAgICAgICAgIGN1cnNvcjogJydcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQXR0cmlidXRlKCd1bnNlbGVjdGFibGUnKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByZWZpeCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuIDxhIGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLXJlc2l6ZS1oYW5kbGVyYH0gb25Nb3VzZURvd249e3RoaXMub25Nb3VzZURvd259PjwvYT47XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZXNpemU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvYmFzZS9yZXNpemUuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3ByZWZlci1zdGF0ZWxlc3MtZnVuY3Rpb24gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdyYXBwZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3Qge2NvbEdyb3VwLCBjaGlsZHJlbiwgY29tcG9uZW50OiBUYWd9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuICg8VGFnIHJvbGU9XCJ0YWJsZVwiPlxuICAgICAgICAgICAge2NvbEdyb3VwfVxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L1RhZz4pO1xuICAgIH1cbn1cblxuV3JhcHBlci5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY29tcG9uZW50OiAndGFibGUnXG59O1xuXG5XcmFwcGVyLnByb3BUeXBlcyA9IHtcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmFueSxcbiAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgY29sR3JvdXA6IFByb3BUeXBlcy5hbnksXG4gICAgY29tcG9uZW50OiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvYmFzZS93cmFwcGVyLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG4vKipcbiAqIFRhYmxlLkNvbHVtbkdyb3VwXG4gKiBAb3JkZXIgMVxuICoqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sdW1uR3JvdXAgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOihqOWktOaYvuekuueahOWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgdGl0bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5lbGVtZW50LCBQcm9wVHlwZXMubm9kZSwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICB9XG5cbiAgICBzdGF0aWMgY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIHBhcmVudDogUHJvcFR5cGVzLmFueVxuICAgIH1cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHRpdGxlOiAnY29sdW1uLWdyb3VwJ1xuICAgIH1cblxuICAgIHN0YXRpYyBfdHlwZU1hcmsgPSAnY29sdW1uR3JvdXAnO1xuXG4gICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFyZW50OiB0aGlzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvY29sdW1uLWdyb3VwLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJvd0NvbXBvbmVudCBmcm9tICcuL3RyZWUvcm93JztcbmltcG9ydCBDZWxsQ29tcG9uZW50IGZyb20gJy4vdHJlZS9jZWxsJztcbmltcG9ydCB7c3RhdGljc30gZnJvbSAnLi91dGlsJztcblxuY29uc3Qgbm9vcCA9ICgpID0+IHsgfTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJlZShCYXNlQ29tcG9uZW50KSB7XG4gICAgY2xhc3MgVHJlZVRhYmxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAgICAgc3RhdGljIFRyZWVSb3cgPSBSb3dDb21wb25lbnQ7XG4gICAgICAgIHN0YXRpYyBUcmVlQ2VsbCA9IENlbGxDb21wb25lbnQ7XG4gICAgICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOm7mOiupOaDheWGteS4i+WxleW8gOeahOagkeW9ouihqOagvO+8jOS8oOWFpeS6huatpOWxnuaAp+S7o+ihqHRyZWXnmoTlsZXlvIDkuLrlj5fmjqfmk43kvZxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb3BlblJvd0tleXM6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog54K55Ye7dHJlZeWxleW8gOaIluiAheWFs+mXreeahOaXtuWAmeinpuWPkeeahOS6i+S7tlxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gb3BlblJvd0tleXMgdHJlZeaooeW8j+S4i+WxleW8gOeahGtleVxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGN1cnJlbnRSb3dLZXkg5b2T5YmN54K55Ye76KGM55qEa2V5XG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wZW5lZCDlvZPliY3ngrnlh7vmmK/lsZXlvIDov5jmmK/mlLbotbdcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdXJyZW50UmVjb3JkIOW9k+WJjeeCueWHu+ihjOeahOiusOW9lVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvblJvd09wZW46IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBkYXRhU291cmNl5b2T5Lit5pWw5o2u55qE5Li76ZSu77yM5aaC5p6c57uZ5a6a55qE5pWw5o2u5rqQ5Lit55qE5bGe5oCn5LiN5YyF5ZCr6K+l5Li76ZSu77yM5Lya6YCg5oiQ6YCJ5oup54q25oCB5YWo6YOo6YCJ5LitXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHByaW1hcnlLZXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOWcqHRyZWXmqKHlvI/kuIvnmoTnvKnov5vlsLrlr7jvvIwg5LuF5ZyoaXNUcmVl5Li6dHJ1ZeaXtuWAmeacieaViFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpbmRlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOW8gOWQr1RhYmxl55qEdHJlZeaooeW8jywg5o6l5pS255qE5pWw5o2u5qC85byP5Lit5YyF5ZCrY2hpbGRyZW7liJnmuLLmn5PmiJB0cmVlIHRhYmxlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlzVHJlZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgICAgICBsb2NhbGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgICAgICAuLi5CYXNlQ29tcG9uZW50LnByb3BUeXBlcyxcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgICAgICAuLi5CYXNlQ29tcG9uZW50LmRlZmF1bHRQcm9wcyxcbiAgICAgICAgICAgIHByaW1hcnlLZXk6ICdpZCcsXG4gICAgICAgICAgICBvblJvd09wZW46IG5vb3AsXG4gICAgICAgICAgICBjb21wb25lbnRzOiB7fSxcbiAgICAgICAgICAgIGluZGVudDogMTJcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgICAgIG9wZW5UcmVlUm93S2V5czogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICAgICAgaW5kZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAgICAgdHJlZVN0YXR1czogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICAgICAgb25UcmVlTm9kZUNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgICAgIGlzVHJlZTogUHJvcFR5cGVzLmJvb2xcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgICAgIG9wZW5Sb3dLZXlzOiBwcm9wcy5vcGVuUm93S2V5cyB8fCBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3BlblRyZWVSb3dLZXlzOiB0aGlzLnN0YXRlLm9wZW5Sb3dLZXlzLFxuICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5wcm9wcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgdHJlZVN0YXR1czogdGhpcy5nZXRUcmVlTm9kZVN0YXR1cyh0aGlzLmRzKSxcbiAgICAgICAgICAgICAgICBvblRyZWVOb2RlQ2xpY2s6IHRoaXMub25UcmVlTm9kZUNsaWNrLFxuICAgICAgICAgICAgICAgIGlzVHJlZTogdGhpcy5wcm9wcy5pc1RyZWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICAgICAgaWYgKCdvcGVuUm93S2V5cycgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvcGVuUm93S2V5cyB9ID0gbmV4dFByb3BzO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBvcGVuUm93S2V5c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplRGF0YVNvdXJjZShkYXRhU291cmNlKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBbXSxcbiAgICAgICAgICAgICAgICBsb29wID0gZnVuY3Rpb24gKGRhdGFTb3VyY2UsIGxldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uX19sZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AoaXRlbS5jaGlsZHJlbiwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxvb3AoZGF0YVNvdXJjZSwgMCk7XG4gICAgICAgICAgICB0aGlzLmRzID0gcmV0O1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFRyZWVOb2RlU3RhdHVzKGRhdGFTb3VyY2UgPSBbXSkge1xuICAgICAgICAgICAgY29uc3QgeyBvcGVuUm93S2V5cyB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgICAgICB7IHByaW1hcnlLZXkgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgcmV0ID0gW107XG5cbiAgICAgICAgICAgIG9wZW5Sb3dLZXlzLmZvckVhY2gob3BlbktleSA9PiB7XG4gICAgICAgICAgICAgICAgZGF0YVNvdXJjZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVtwcmltYXJ5S2V5XSA9PT0gb3BlbktleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChjaGlsZFtwcmltYXJ5S2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9uVHJlZU5vZGVDbGljayA9IChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJpbWFyeUtleSB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBpZCA9IHJlY29yZFtwcmltYXJ5S2V5XSxcbiAgICAgICAgICAgICAgICBkYXRhU291cmNlID0gdGhpcy5kcyxcbiAgICAgICAgICAgICAgICBvcGVuUm93S2V5cyA9IFsuLi50aGlzLnN0YXRlLm9wZW5Sb3dLZXlzXSxcbiAgICAgICAgICAgICAgICBpbmRleCA9IG9wZW5Sb3dLZXlzLmluZGV4T2YoaWQpLFxuICAgICAgICAgICAgICAgIGdldENoaWxkcmVuS2V5QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXQgPSBbaWRdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb29wID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChpdGVtW3ByaW1hcnlLZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb29wKGl0ZW0uY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBkYXRhU291cmNlLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVtwcmltYXJ5S2V5XSA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb29wKGl0ZW0uY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyDkuI3ku4XopoHliKDpmaTlvZPliY3nmoRvcGVuUm93S2V577yM6L+Y6ZyA6KaB5Yig6Zmk5YWz6IGU5a2Q6IqC54K555qEb3BlblJvd0tleVxuICAgICAgICAgICAgICAgIGNvbnN0IGlkcyA9IGdldENoaWxkcmVuS2V5QnlJZChpZCk7XG4gICAgICAgICAgICAgICAgaWRzLmZvckVhY2goaWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpID0gb3BlblJvd0tleXMuaW5kZXhPZihpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5Sb3dLZXlzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcGVuUm93S2V5cy5wdXNoKGlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEoJ29wZW5Sb3dLZXlzJyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBvcGVuUm93S2V5c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblJvd09wZW4ob3BlblJvd0tleXMsIGlkLCBpbmRleCA9PT0gLTEsIHJlY29yZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycywgcHJlZmVyLWNvbnN0ICovXG4gICAgICAgICAgICBsZXQgeyBjb21wb25lbnRzLCBpc1RyZWUsIGRhdGFTb3VyY2UsIGluZGVudCwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgICAgICBpZiAoaXNUcmVlKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cyA9IHsuLi5jb21wb25lbnRzfTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudHMuUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuUm93ID0gUm93Q29tcG9uZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudHMuQ2VsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLkNlbGwgPSBDZWxsQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UgPSB0aGlzLm5vcm1hbGl6ZURhdGFTb3VyY2UoZGF0YVNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDxCYXNlQ29tcG9uZW50IHsuLi5vdGhlcnN9IGRhdGFTb3VyY2U9e2RhdGFTb3VyY2V9IGNvbXBvbmVudHM9e2NvbXBvbmVudHN9IC8+KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWNzKFRyZWVUYWJsZSwgQmFzZUNvbXBvbmVudCk7XG4gICAgcmV0dXJuIFRyZWVUYWJsZTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS90cmVlLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgUm93IGZyb20gJy4uL3NlbGVjdGlvbi9yb3cnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmVlUm93IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAuLi5Sb3cucHJvcFR5cGVzXG4gICAgfVxuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgLi4uUm93LmRlZmF1bHRQcm9wc1xuICAgIH1cblxuICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIHRyZWVTdGF0dXM6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgb3BlblJvd0tleXM6IFByb3BUeXBlcy5hcnJheVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMqL1xuICAgICAgICBjb25zdCB7IGNsYXNzTmFtZSwgcmVjb3JkLCBwcmltYXJ5S2V5LCBwcmVmaXgsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyB0cmVlU3RhdHVzLCBvcGVuUm93S2V5cyB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBjb25zdCBjbHMgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgIGhpZGRlbjogISh0cmVlU3RhdHVzLmluZGV4T2YocmVjb3JkW3ByaW1hcnlLZXldKSA+IC0xKSAmJiByZWNvcmQuX19sZXZlbCAhPT0gMCxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9dGFibGUtcm93LWxldmVsLSR7cmVjb3JkLl9fbGV2ZWx9YF06IHRydWUsXG4gICAgICAgICAgICBvcGVuZWQ6IG9wZW5Sb3dLZXlzLmluZGV4T2YocmVjb3JkW3ByaW1hcnlLZXldKSA+IC0xLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICg8Um93IHsuLi5vdGhlcnN9IHJlY29yZD17cmVjb3JkfSBjbGFzc05hbWU9e2Nsc30gcHJpbWFyeUtleT17cHJpbWFyeUtleX0gcHJlZml4PXtwcmVmaXh9Lz4pO1xuICAgIH1cbn1cblxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvdHJlZS9yb3cuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgSWNvbiBmcm9tICcuLi8uLi9pY29uJztcbmltcG9ydCB7IEtFWUNPREUgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCBDZWxsQ29tcG9uZW50IGZyb20gJy4uL2Jhc2UvY2VsbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyZWVDZWxsIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBpbmRlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGxvY2FsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLi4uQ2VsbENvbXBvbmVudC5wcm9wVHlwZXNcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAuLi5DZWxsQ29tcG9uZW50LmRlZmF1bHRQcm9wcyxcbiAgICAgICAgY29tcG9uZW50OiAndGQnLFxuICAgICAgICBpbmRlbnQ6IDIwXG4gICAgfVxuXG4gICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgb3BlblRyZWVSb3dLZXlzOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIGluZGVudDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgb25UcmVlTm9kZUNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgaXNUcmVlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgcm93U2VsZWN0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIH1cblxuICAgIG9uVHJlZU5vZGVDbGljayA9IChyZWNvcmQsIGUpID0+IHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5jb250ZXh0Lm9uVHJlZU5vZGVDbGljayhyZWNvcmQpO1xuICAgIH1cblxuICAgIGV4cGFuZGVkS2V5ZG93biA9IChyZWNvcmQsIGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IEtFWUNPREUuRU5URVIpIHtcbiAgICAgICAgICAgIHRoaXMub25UcmVlTm9kZUNsaWNrKHJlY29yZCwgZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY29sSW5kZXgsIHJlY29yZCwgcHJlZml4LCBwcmltYXJ5S2V5LCBsb2NhbGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgb3BlblRyZWVSb3dLZXlzOiBvcGVuUm93S2V5cywgaW5kZW50LCBpc1RyZWUsIHJvd1NlbGVjdGlvbiB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBjb25zdCB0cmVlQXJyb3dOb2RlSW5kZXggPSByb3dTZWxlY3Rpb24gPyAxIDogMDtcbiAgICAgICAgbGV0IGZpcnN0Q2VsbFN0eWxlLCB0cmVlQXJyb3dOb2RlO1xuICAgICAgICBpZiAoY29sSW5kZXggPT09IHRyZWVBcnJvd05vZGVJbmRleCkge1xuICAgICAgICAgICAgbGV0IHRyZWVBcnJvd1R5cGU7XG4gICAgICAgICAgICBpZiAoaXNUcmVlKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RDZWxsU3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiBpbmRlbnQgKiAocmVjb3JkLl9fbGV2ZWwgKyAxKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJlZUFycm93Tm9kZSA9IDxJY29uIHNpemU9XCJ4c1wiIGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLXRyZWUtcGxhY2Vob2xkZXJgfSAvPjtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmNoaWxkcmVuICYmIHJlY29yZC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzRXhwYW5kZWQgPSBvcGVuUm93S2V5cy5pbmRleE9mKHJlY29yZFtwcmltYXJ5S2V5XSkgPiAtMTtcblxuICAgICAgICAgICAgICAgICAgICB0cmVlQXJyb3dUeXBlID0gaGFzRXhwYW5kZWQgPyAnYXJyb3ctZG93bicgOiAnYXJyb3ctcmlnaHQnO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyZWVBcnJvd05vZGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgKDxJY29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtdHJlZS1hcnJvd2B9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT17dHJlZUFycm93VHlwZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplPVwieHNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2UgPT4gdGhpcy5vblRyZWVOb2RlQ2xpY2socmVjb3JkLCBlKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbktleURvd249e2UgPT4gdGhpcy5leHBhbmRlZEtleWRvd24ocmVjb3JkLCBlKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJJbmRleD1cIjBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtZXhwYW5kZWQ9e2hhc0V4cGFuZGVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e2hhc0V4cGFuZGVkID8gbG9jYWxlLmV4cGFuZGVkIDogbG9jYWxlLmZvbGRlZH0vPik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoPENlbGxDb21wb25lbnQgey4uLnRoaXMucHJvcHN9IGlubmVyU3R5bGU9e2ZpcnN0Q2VsbFN0eWxlfT5cbiAgICAgICAgICAgIHt0cmVlQXJyb3dOb2RlfVxuICAgICAgICA8L0NlbGxDb21wb25lbnQ+KTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvdHJlZS9jZWxsLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBkb20gfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBIZWFkZXJDb21wb25lbnQgZnJvbSAnLi9maXhlZC9oZWFkZXInO1xuaW1wb3J0IEJvZHlDb21wb25lbnQgZnJvbSAnLi9maXhlZC9ib2R5JztcbmltcG9ydCBXcmFwcGVyQ29tcG9uZW50IGZyb20gJy4vZml4ZWQvd3JhcHBlcic7XG5pbXBvcnQge3N0YXRpY3N9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpeGVkKEJhc2VDb21wb25lbnQpIHtcbiAgICAvKiogVGFibGUgKi9cbiAgICBjbGFzcyBGaXhlZFRhYmxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAgICAgc3RhdGljIEZpeGVkSGVhZGVyID0gSGVhZGVyQ29tcG9uZW50O1xuICAgICAgICBzdGF0aWMgRml4ZWRCb2R5ID0gQm9keUNvbXBvbmVudDtcbiAgICAgICAgc3RhdGljIEZpeGVkV3JhcHBlciA9IFdyYXBwZXJDb21wb25lbnQ7XG4gICAgICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgKiDmmK/lkKblhbfmnInooajlpLRcbiAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGhhc0hlYWRlcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgKiDooajlpLTmmK/lkKblm7rlrprvvIzor6XlsZ7mgKfphY3lkIhtYXhCb2R5SGVpZ2h05L2/55So77yM5b2T5YaF5a655Yy65Z+f55qE6auY5bqm6LaF6L+HbWF4Qm9keUhlaWdodOeahOaXtuWAme+8jOWcqOWGheWuueWMuuWfn+S8muWHuueOsOa7muWKqOadoVxuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZml4ZWRIZWFkZXI6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDmnIDlpKflhoXlrrnljLrln5/nmoTpq5jluqYs5ZyoYGZpeGVkSGVhZGVyYOS4umB0cnVlYOeahOaXtuWAmSzotoXov4fov5nkuKrpq5jluqbkvJrlh7rnjrDmu5rliqjmnaFcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWF4Qm9keUhlaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgICAgICAgICAgLi4uQmFzZUNvbXBvbmVudC5wcm9wVHlwZXNcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgICAgICAuLi5CYXNlQ29tcG9uZW50LmRlZmF1bHRQcm9wcyxcbiAgICAgICAgICAgIGhhc0hlYWRlcjogdHJ1ZSxcbiAgICAgICAgICAgIGZpeGVkSGVhZGVyOiBmYWxzZSxcbiAgICAgICAgICAgIG1heEJvZHlIZWlnaHQ6IDIwMCxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IHt9LFxuICAgICAgICAgICAgcmVmczoge30sXG4gICAgICAgICAgICBwcmVmaXg6ICduZXh0LSdcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgICAgIGZpeGVkSGVhZGVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgICAgIG1heEJvZHlIZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgICAgICAgICAgIG9uQm9keVNjcm9sbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgICAgICBnZXROb2RlOiBQcm9wVHlwZXMuZnVuY1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaXhlZEhlYWRlcjogdGhpcy5wcm9wcy5maXhlZEhlYWRlcixcbiAgICAgICAgICAgICAgICBtYXhCb2R5SGVpZ2h0OiB0aGlzLnByb3BzLm1heEJvZHlIZWlnaHQsXG4gICAgICAgICAgICAgICAgb25Cb2R5U2Nyb2xsOiB0aGlzLm9uQm9keVNjcm9sbCxcbiAgICAgICAgICAgICAgICBnZXROb2RlOiB0aGlzLmdldE5vZGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0Rml4ZWRIZWFkZXJTaXplKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgICAgICB0aGlzLmFkanVzdEZpeGVkSGVhZGVyU2l6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRqdXN0Rml4ZWRIZWFkZXJTaXplKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoYXNIZWFkZXIsIGZpeGVkSGVhZGVyLCBtYXhCb2R5SGVpZ2h0IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKGhhc0hlYWRlciAmJiBmaXhlZEhlYWRlciAmJiAhdGhpcy5wcm9wcy5sb2NrVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvZHlOb2RlLnNjcm9sbEhlaWdodCA8PSBtYXhCb2R5SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5zZXRTdHlsZSh0aGlzLmhlYWRlck5vZGUsICdwYWRkaW5nUmlnaHQnLCAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb20uc2V0U3R5bGUodGhpcy5oZWFkZXJOb2RlLCAncGFkZGluZ1JpZ2h0JywgZG9tLnNjcm9sbGJhcigpLndpZHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZXROb2RlID0gKHR5cGUsIG5vZGUsIGxvY2tUeXBlKSA9PiB7XG4gICAgICAgICAgICBsb2NrVHlwZSA9IGxvY2tUeXBlID8gbG9ja1R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBsb2NrVHlwZS5zdWJzdHIoMSkgOiAnJztcbiAgICAgICAgICAgIHRoaXNbYCR7dHlwZX0ke2xvY2tUeXBlfU5vZGVgXSA9IG5vZGU7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2hlYWRlcicgJiYgIWxvY2tUeXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lckhlYWRlck5vZGUgPSB0aGlzLmhlYWRlck5vZGUucXVlcnlTZWxlY3RvcignZGl2Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvbkJvZHlTY3JvbGwgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvKHRoaXMuYm9keU5vZGUuc2Nyb2xsTGVmdCwgdGhpcy5ib2R5Tm9kZS5zY3JvbGxUb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgc2Nyb2xsVG8oeCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5uZXJIZWFkZXJOb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lckhlYWRlck5vZGUuc2Nyb2xsTGVmdCA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycywgcHJlZmVyLWNvbnN0ICovXG4gICAgICAgICAgICBsZXQgeyBjb21wb25lbnRzLCBjbGFzc05hbWUsIHByZWZpeCwgZml4ZWRIZWFkZXIsIG1heEJvZHlIZWlnaHQsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChmaXhlZEhlYWRlcikge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMgPSB7Li4uY29tcG9uZW50c307XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnRzLkhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLkhlYWRlciA9IEhlYWRlckNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnRzLkJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5Cb2R5ID0gQm9keUNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnRzLldyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5XcmFwcGVyID0gV3JhcHBlckNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9dGFibGUtZml4ZWRgXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgW2NsYXNzTmFtZV06IGNsYXNzTmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICg8QmFzZUNvbXBvbmVudCAgey4uLm90aGVyc30gY29tcG9uZW50cz17Y29tcG9uZW50c30gY2xhc3NOYW1lPXtjbGFzc05hbWV9IHByZWZpeD17cHJlZml4fSAvPik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljcyhGaXhlZFRhYmxlLCBCYXNlQ29tcG9uZW50KTtcbiAgICByZXR1cm4gRml4ZWRUYWJsZTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9maXhlZC5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENoZWNrYm94IGZyb20gJy4uL2NoZWNrYm94JztcbmltcG9ydCBSYWRpbyBmcm9tICcuLi9yYWRpbyc7XG5pbXBvcnQgeyBmdW5jLCBsb2cgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCB6aENOIGZyb20gJy4uL2xvY2FsZS96aC1jbic7XG5pbXBvcnQgU2VsZWN0aW9uUm93IGZyb20gJy4vc2VsZWN0aW9uL3Jvdyc7XG5pbXBvcnQgQ29sIGZyb20gJy4vY29sdW1uJztcbmltcG9ydCB7IHN0YXRpY3MgfSBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCB7IG1ha2VDaGFpbiB9ID0gZnVuYztcblxuY29uc3QgdW5pcXVlID0gKGFyciwga2V5ID0gJ3RoaXMnKSA9PiB7XG4gICAgY29uc3QgdGVtcCA9IHt9LCByZXQgPSBbXTtcbiAgICBhcnIuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBpZiAoa2V5ID09PSAndGhpcycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gaXRlbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gaXRlbVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGVtcFt2YWx1ZV0pIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgdGVtcFt2YWx1ZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNlbGVjdGlvbihCYXNlQ29tcG9uZW50KSB7XG4gICAgLyoqIFRhYmxlICovXG4gICAgY2xhc3MgU2VsZWN0aW9uVGFibGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgICAgICBzdGF0aWMgU2VsZWN0aW9uUm93ID0gU2VsZWN0aW9uUm93O1xuICAgICAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAqIOaYr+WQpuWQr+eUqOmAieaLqeaooeW8j1xuICAgICAgICAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBnZXRQcm9wcyBgRnVuY3Rpb24ocmVjb3JkLCBpbmRleCk9Pk9iamVjdGAg6I635Y+Wc2VsZWN0aW9u55qE6buY6K6k5bGe5oCnXG4gICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG9uQ2hhbmdlIGBGdW5jdGlvbihzZWxlY3RlZFJvd0tleXM6QXJyYXksIHJlY29yZHM6QXJyYXkpYCDpgInmi6nmlLnlj5jnmoTml7blgJnop6blj5HnmoTkuovku7bvvIwqKuazqOaEjzoqKiDlhbbkuK1yZWNvcmRz5Y+q5Lya5YyF5ZCr5b2T5YmNZGF0YVNvdXJjZeeahOaVsOaNru+8jOW+iOWPr+iDveS8muWwj+S6jnNlbGVjdGVkUm93S2V5c+eahOmVv+W6puOAglxuICAgICAgICAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvblNlbGVjdCBgRnVuY3Rpb24oc2VsZWN0ZWQ6Qm9vbGVhbiwgcmVjb3JkOk9iamVjdCwgcmVjb3JkczpBcnJheSlgIOeUqOaIt+aJi+WKqOmAieaLqS/lj5bmtojpgInmi6nmn5DooYznmoTlm57osINcbiAgICAgICAgICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb25TZWxlY3RBbGwgYEZ1bmN0aW9uKHNlbGVjdGVkOkJvb2xlYW4sIHJlY29yZHM6QXJyYXkpYCDnlKjmiLfmiYvliqjpgInmi6kv5Y+W5raI6YCJ5oup5omA5pyJ6KGM55qE5Zue6LCDXG4gICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHNlbGVjdGVkUm93S2V5cyDorr7nva7kuobmraTlsZ7mgKcs5bCGcm93U2VsZWN0aW9u5Y+Y5Li65Y+X5o6n54q25oCBLOaOpeaUtuWAvOS4uuivpeihjOaVsOaNrueahHByaW1hcnlLZXnnmoTlgLxcbiAgICAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IG1vZGUg6YCJ5oupc2VsZWN0aW9u55qE5qih5byPLCDlj6/pgInlgLzkuLpgc2luZ2xlYCwgYG11bHRpcGxlYO+8jOm7mOiupOS4umBtdWx0aXBsZWBcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICByb3dTZWxlY3Rpb246IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgICAgICBwcmltYXJ5S2V5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAgICAgZGF0YVNvdXJjZTogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICAgICAgZW50aXJlRGF0YVNvdXJjZTogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICAgICAgLi4uQmFzZUNvbXBvbmVudC5wcm9wVHlwZXMsXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAgICAgLi4uQmFzZUNvbXBvbmVudC5kZWZhdWx0UHJvcHMsXG4gICAgICAgICAgICBsb2NhbGU6IHpoQ04uVGFibGUsXG4gICAgICAgICAgICBwcmltYXJ5S2V5OiAnaWQnLFxuICAgICAgICAgICAgcHJlZml4OiAnbmV4dC0nXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICAgICAgbGlzdEhlYWRlcjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgICAgIHJvd1NlbGVjdGlvbjogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgICAgIHNlbGVjdGVkUm93S2V5czogUHJvcFR5cGVzLmFycmF5XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xuICAgICAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd0tleXM6IHByb3BzLnJvd1NlbGVjdGlvbiAmJiAnc2VsZWN0ZWRSb3dLZXlzJyBpbiBwcm9wcy5yb3dTZWxlY3Rpb24gPyAocHJvcHMucm93U2VsZWN0aW9uLnNlbGVjdGVkUm93S2V5cyB8fCBbXSkgOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcm93U2VsZWN0aW9uOiB0aGlzLnByb3BzLnJvd1NlbGVjdGlvbixcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd0tleXM6IHRoaXMuc3RhdGUuc2VsZWN0ZWRSb3dLZXlzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChuZXh0UHJvcHMucm93U2VsZWN0aW9uICYmICdzZWxlY3RlZFJvd0tleXMnIGluIG5leHRQcm9wcy5yb3dTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZFJvd0tleXMgPSBuZXh0UHJvcHMucm93U2VsZWN0aW9uLnNlbGVjdGVkUm93S2V5cyB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRSb3dLZXlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3QgeyBwcmVmaXgsIHJvd1NlbGVjdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChyb3dTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IENoaWxkcmVuLm1hcChjaGlsZHJlbiwgKGNoaWxkLCBpbmRleCkgPT4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogaW5kZXhcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4udW5zaGlmdCg8Q29sIGtleT1cInNlbGVjdGlvblwiIHRpdGxlPXt0aGlzLnJlbmRlclNlbGVjdGlvbkhlYWRlci5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgICAgICAgICBjZWxsPXt0aGlzLnJlbmRlclNlbGVjdGlvbkJvZHkuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICAgICAgd2lkdGg9ezUwfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1zZWxlY3Rpb25gfSBfX25vcm1hbGl6ZWQgLz4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlclNlbGVjdGlvbkhlYWRlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9uQ2hhbmdlID0gdGhpcy5zZWxlY3RBbGxSb3csIGF0dHJzID0ge30sXG4gICAgICAgICAgICAgICAgeyByb3dTZWxlY3Rpb24sIHByaW1hcnlLZXksIGRhdGFTb3VyY2UsIGxvY2FsZSB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICB7IHNlbGVjdGVkUm93S2V5cyB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgICAgICBtb2RlID0gcm93U2VsZWN0aW9uLm1vZGUgPyByb3dTZWxlY3Rpb24ubW9kZSA6ICdtdWx0aXBsZSc7XG5cbiAgICAgICAgICAgIGxldCBjaGVja2VkID0gISFzZWxlY3RlZFJvd0tleXMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGluZGV0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmxhdERhdGFTb3VyY2UoZGF0YVNvdXJjZSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChyZWNvcmQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcm93U2VsZWN0aW9uLmdldFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhKHJvd1NlbGVjdGlvbi5nZXRQcm9wcyhyZWNvcmQsIGluZGV4KSB8fCB7fSkuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5tYXAocmVjb3JkID0+IHJlY29yZFtwcmltYXJ5S2V5XSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZFJvd0tleXMuaW5kZXhPZihpZCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRldGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXR0cnMub25DbGljayA9IG1ha2VDaGFpbigoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9LCBhdHRycy5vbkNsaWNrKTtcblxuICAgICAgICAgICAgaWYgKGNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBpbmRldGVybWluYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9kZSA9PT0gJ211bHRpcGxlJyA/IDxDaGVja2JveCBpbmRldGVybWluYXRlPXtpbmRldGVybWluYXRlfSBhcmlhLWxhYmVsPXtsb2NhbGUuc2VsZWN0QWxsfSBjaGVja2VkPXtjaGVja2VkfSBvbkNoYW5nZT17b25DaGFuZ2V9IHsuLi5hdHRyc30gLz4gOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyU2VsZWN0aW9uQm9keSA9ICh2YWx1ZSwgaW5kZXgsIHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyByb3dTZWxlY3Rpb24sIHByaW1hcnlLZXkgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBjb25zdCB7IHNlbGVjdGVkUm93S2V5cyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGUgPSByb3dTZWxlY3Rpb24ubW9kZSA/IHJvd1NlbGVjdGlvbi5tb2RlIDogJ211bHRpcGxlJztcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSBzZWxlY3RlZFJvd0tleXMuaW5kZXhPZihyZWNvcmRbcHJpbWFyeUtleV0pID4gLTE7XG4gICAgICAgICAgICBjb25zdCBvbkNoYW5nZSA9IHRoaXMuc2VsZWN0T25lUm93LmJpbmQodGhpcywgaW5kZXgsIHJlY29yZCk7XG4gICAgICAgICAgICBjb25zdCBhdHRycyA9IHJvd1NlbGVjdGlvbi5nZXRQcm9wcyA/IChyb3dTZWxlY3Rpb24uZ2V0UHJvcHMocmVjb3JkLCBpbmRleCkgfHwge30pIDoge307XG5cbiAgICAgICAgICAgIGF0dHJzLm9uQ2xpY2sgPSBtYWtlQ2hhaW4oKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSwgYXR0cnMub25DbGljayk7XG4gICAgICAgICAgICByZXR1cm4gbW9kZSA9PT0gJ211bHRpcGxlJyA/IDxDaGVja2JveCBjaGVja2VkPXtjaGVja2VkfSBvbkNoYW5nZT17b25DaGFuZ2V9IHsuLi5hdHRyc30gLz4gOlxuICAgICAgICAgICAgICAgIDxSYWRpbyBjaGVja2VkPXtjaGVja2VkfSBvbkNoYW5nZT17b25DaGFuZ2V9IHsuLi5hdHRyc30gLz47XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3RBbGxSb3cgPSAoY2hlY2tlZCwgZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gWy4uLnRoaXMuc3RhdGUuc2VsZWN0ZWRSb3dLZXlzXSxcbiAgICAgICAgICAgICAgICB7IHJvd1NlbGVjdGlvbiwgcHJpbWFyeUtleSwgZGF0YVNvdXJjZSwgZW50aXJlRGF0YVNvdXJjZSB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICB7IHNlbGVjdGVkUm93S2V5cyB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgICAgICBnZXRQcm9wcyA9IHJvd1NlbGVjdGlvbi5nZXRQcm9wcztcbiAgICAgICAgICAgIGxldCBhdHRycyA9IHt9LCByZWNvcmRzID0gW107XG5cbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGVudGlyZURhdGFTb3VyY2UgPyBlbnRpcmVEYXRhU291cmNlIDogZGF0YVNvdXJjZTtcblxuICAgICAgICAgICAgdGhpcy5mbGF0RGF0YVNvdXJjZShzb3VyY2UpLmZvckVhY2goKHJlY29yZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IHJlY29yZFtwcmltYXJ5S2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0UHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMgPSBnZXRQcm9wcyhyZWNvcmQsIGluZGV4KSB8fCB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8g5Y+N6YCJ5ZKM5YWo6YCJ55qE5pe25YCZ5LiN6KaB5Lii5byD56aB55So6aG555qE6YCJ5Lit54q25oCBXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrZWQgJiYgKCFhdHRycy5kaXNhYmxlZCB8fCBzZWxlY3RlZFJvd0tleXMuaW5kZXhPZihpZCkgPiAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goaWQpO1xuICAgICAgICAgICAgICAgICAgICByZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHJzLmRpc2FibGVkICYmIHNlbGVjdGVkUm93S2V5cy5pbmRleE9mKGlkKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaSA9IHJldC5pbmRleE9mKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaSA+IC0xICYmIHJldC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlY29yZHMgPSB1bmlxdWUocmVjb3JkcywgcHJpbWFyeUtleSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJvd1NlbGVjdGlvbi5vblNlbGVjdEFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJvd1NlbGVjdGlvbi5vblNlbGVjdEFsbChjaGVja2VkLCByZWNvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlclNlbGVjdGlvbihyb3dTZWxlY3Rpb24sIHVuaXF1ZShyZXQpLCByZWNvcmRzKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3RPbmVSb3coaW5kZXgsIHJlY29yZCwgY2hlY2tlZCwgZSkge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGVkUm93S2V5cyA9IFsuLi50aGlzLnN0YXRlLnNlbGVjdGVkUm93S2V5c10sIGk7XG4gICAgICAgICAgICBjb25zdCB7IHByaW1hcnlLZXksIHJvd1NlbGVjdGlvbiwgZGF0YVNvdXJjZSB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBtb2RlID0gcm93U2VsZWN0aW9uLm1vZGUgPyByb3dTZWxlY3Rpb24ubW9kZSA6ICdtdWx0aXBsZScsXG4gICAgICAgICAgICAgICAgaWQgPSByZWNvcmRbcHJpbWFyeUtleV07XG4gICAgICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm5pbmcoYENhbid0IGdldCB2YWx1ZSBmcm9tIHJlY29yZCB1c2luZyBnaXZlbiAke3ByaW1hcnlLZXl9IGFzIHByaW1hcnlLZXkuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ211bHRpcGxlJykge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkUm93S2V5cy5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpID0gc2VsZWN0ZWRSb3dLZXlzLmluZGV4T2YoaWQpO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd0tleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkUm93S2V5cyA9IFtpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWNvcmRzID0gdW5pcXVlKGRhdGFTb3VyY2UuZmlsdGVyKGl0ZW0gPT4gc2VsZWN0ZWRSb3dLZXlzLmluZGV4T2YoaXRlbVtwcmltYXJ5S2V5XSkgPiAtMSksIHByaW1hcnlLZXkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByb3dTZWxlY3Rpb24ub25TZWxlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByb3dTZWxlY3Rpb24ub25TZWxlY3QoY2hlY2tlZCwgcmVjb3JkLCByZWNvcmRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyU2VsZWN0aW9uKHJvd1NlbGVjdGlvbiwgc2VsZWN0ZWRSb3dLZXlzLCByZWNvcmRzKTtcblxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0cmlnZ2VyU2VsZWN0aW9uKHJvd1NlbGVjdGlvbiwgc2VsZWN0ZWRSb3dLZXlzLCByZWNvcmRzKSB7XG4gICAgICAgICAgICBpZiAoISgnc2VsZWN0ZWRSb3dLZXlzJyBpbiByb3dTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkUm93S2V5c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiByb3dTZWxlY3Rpb24ub25DaGFuZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByb3dTZWxlY3Rpb24ub25DaGFuZ2Uoc2VsZWN0ZWRSb3dLZXlzLCByZWNvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZsYXREYXRhU291cmNlKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIGxldCByZXQgPSBkYXRhU291cmNlO1xuICAgICAgICAgICAgY29uc3QgeyBsaXN0SGVhZGVyIH0gPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgICAgICAgIGlmIChsaXN0SGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgeyBoYXNDaGlsZHJlblNlbGVjdGlvbiwgaGFzU2VsZWN0aW9uIH0gPSBsaXN0SGVhZGVyO1xuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBpdGVtLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzpnIDopoHmuLLmn5NzZWxlY3Rpb27miY3lsIbov5nmnaHorrDlvZXmj5LlhaXliLBkYXRhU291cmNlXG4gICAgICAgICAgICAgICAgICAgIC8vIOaIluiAheayoeacieWtqeWtkOiKgueCuVxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4gJiYgaGFzQ2hpbGRyZW5TZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyKCkge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWNvbnN0ICovXG4gICAgICAgICAgICBsZXQgeyByb3dTZWxlY3Rpb24sIGNvbXBvbmVudHMsIGNoaWxkcmVuLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgICAgIGlmIChyb3dTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMgPSB7IC4uLmNvbXBvbmVudHMgfTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLlJvdyA9IGNvbXBvbmVudHMuUm93IHx8IFNlbGVjdGlvblJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoPEJhc2VDb21wb25lbnQgey4uLm90aGVyc30gY29tcG9uZW50cz17Y29tcG9uZW50c30+XG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgPC9CYXNlQ29tcG9uZW50Pik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljcyhTZWxlY3Rpb25UYWJsZSwgQmFzZUNvbXBvbmVudCk7XG4gICAgcmV0dXJuIFNlbGVjdGlvblRhYmxlO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL3NlbGVjdGlvbi5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcbmltcG9ydCB7IEtFWUNPREUgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBSb3dDb21wb25lbnQgZnJvbSAnLi9leHBhbmRlZC9yb3cnO1xuaW1wb3J0IENvbCBmcm9tICcuL2NvbHVtbic7XG5pbXBvcnQgeyBzdGF0aWNzIH0gZnJvbSAnLi91dGlsJztcblxuY29uc3Qgbm9vcCA9ICgpID0+IHsgfTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kZWQoQmFzZUNvbXBvbmVudCkge1xuICAgIC8qKiBUYWJsZSAqL1xuICAgIGNsYXNzIEV4cGFuZGVkVGFibGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgICAgICBzdGF0aWMgRXhwYW5kZWRSb3cgPSBSb3dDb21wb25lbnQ7XG4gICAgICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOmineWklua4suafk+ihjOeahOa4suafk+WHveaVsFxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZCDor6XooYzmiYDlr7nlupTnmoTmlbDmja5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCDor6XooYzmiYDlr7nlupTnmoTluo/liJdcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBleHBhbmRlZFJvd1JlbmRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOmineWklua4suafk+ihjOeahOe8qei/m1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBleHBhbmRlZFJvd0luZGVudDogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDpu5jorqTmg4XlhrXkuIvlsZXlvIDnmoTmuLLmn5PooYzmiJbogIVUcmVlLCDkvKDlhaXmraTlsZ7mgKfkuLrlj5fmjqfnirbmgIFcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb3BlblJvd0tleXM6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5piv5ZCm5pi+56S654K55Ye75bGV5byA6aKd5aSW5riy5p+T6KGM55qEK+WPt+aMiemSrlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBoYXNFeHBhbmRlZFJvd0N0cmw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDorr7nva7pop3lpJbmuLLmn5PooYznmoTlsZ7mgKdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0RXhwYW5kZWRDb2xQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOWcqOmineWklua4suafk+ihjOaIluiAhVRyZWXlsZXlvIDmiJbogIXmlLbotbfnmoTml7blgJnop6blj5HnmoTkuovku7ZcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IG9wZW5Sb3dLZXlzIOWxleW8gOeahOa4suafk+ihjOeahGtleVxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGN1cnJlbnRSb3dLZXkg5b2T5YmN54K55Ye755qE5riy5p+T6KGM55qEa2V5XG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV4cGFuZGVkIOW9k+WJjeeCueWHu+aYr+WxleW8gOi/mOaYr+aUtui1t1xuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGN1cnJlbnRSZWNvcmQg5b2T5YmN54K55Ye76aKd5aSW5riy5p+T6KGM55qE6K6w5b2VXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9uUm93T3BlbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOeCueWHu+mineWklua4suafk+ihjOinpuWPkeeahOS6i+S7tlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZCDor6XooYzmiYDlr7nlupTnmoTmlbDmja5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCDor6XooYzmiYDlr7nlupTnmoTluo/liJdcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRE9N5LqL5Lu25a+56LGhXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9uRXhwYW5kZWRSb3dDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgICAgICBsb2NhbGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgICAgICAuLi5CYXNlQ29tcG9uZW50LnByb3BUeXBlc1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgICAgICAuLi5CYXNlQ29tcG9uZW50LmRlZmF1bHRQcm9wcyxcbiAgICAgICAgICAgIGdldEV4cGFuZGVkQ29sUHJvcHM6IG5vb3AsXG4gICAgICAgICAgICBvblJvd09wZW46IG5vb3AsXG4gICAgICAgICAgICBoYXNFeHBhbmRlZFJvd0N0cmw6IHRydWUsXG4gICAgICAgICAgICBjb21wb25lbnRzOiB7fSxcbiAgICAgICAgICAgIGV4cGFuZGVkUm93SW5kZW50OiBbMSwgMF0sXG4gICAgICAgICAgICBwcmVmaXg6ICduZXh0LSdcbiAgICAgICAgfTtcblxuICAgICAgICBzdGF0aWMgY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gICAgICAgICAgICBvcGVuUm93S2V5czogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICAgICAgZXhwYW5kZWRSb3dSZW5kZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAgICAgZXhwYW5kZWRSb3dJbmRlbnQ6IFByb3BUeXBlcy5hcnJheVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICBvcGVuUm93S2V5czogdGhpcy5wcm9wcy5vcGVuUm93S2V5cyB8fCBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3BlblJvd0tleXM6IHRoaXMuc3RhdGUub3BlblJvd0tleXMsXG4gICAgICAgICAgICAgICAgZXhwYW5kZWRSb3dSZW5kZXI6IHRoaXMucHJvcHMuZXhwYW5kZWRSb3dSZW5kZXIsXG4gICAgICAgICAgICAgICAgZXhwYW5kZWRSb3dJbmRlbnQ6IHRoaXMucHJvcHMuZXhwYW5kZWRSb3dJbmRlbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICAgICAgaWYgKCdvcGVuUm93S2V5cycgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvcGVuUm93S2V5cyB9ID0gbmV4dFByb3BzO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBvcGVuUm93S2V5c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwYW5kZWRLZXlkb3duID0gKHZhbHVlLCByZWNvcmQsIGluZGV4LCBlKSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBLRVlDT0RFLkVOVEVSKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkV4cGFuZGVkQ2xpY2sodmFsdWUsIHJlY29yZCwgaW5kZXgsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyRXhwYW5kZWRDZWxsID0gKHZhbHVlLCBpbmRleCwgcmVjb3JkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGdldEV4cGFuZGVkQ29sUHJvcHMsIHByZWZpeCwgbG9jYWxlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgY29uc3QgeyBvcGVuUm93S2V5cyB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgICAgICB7IHByaW1hcnlLZXkgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaGFzRXhwYW5kZWQgPSBvcGVuUm93S2V5cy5pbmRleE9mKHJlY29yZFtwcmltYXJ5S2V5XSkgPiAtMSxcbiAgICAgICAgICAgICAgICBzd2l0Y2hOb2RlID0gaGFzRXhwYW5kZWQgP1xuICAgICAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPVwibWludXNcIiBzaXplPVwieHNcIiAvPiA6IDxJY29uIHR5cGU9XCJhZGRcIiBzaXplPVwieHNcIiAvPixcblxuICAgICAgICAgICAgICAgIGF0dHJzID0gZ2V0RXhwYW5kZWRDb2xQcm9wcyhyZWNvcmQsIGluZGV4KSB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IGNscyA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9dGFibGUtZXhwYW5kZWQtY3RybGBdOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBhdHRycy5kaXNhYmxlZCxcbiAgICAgICAgICAgICAgICBbYXR0cnMuY2xhc3NOYW1lXTogYXR0cnMuY2xhc3NOYW1lXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFhdHRycy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIGF0dHJzLm9uQ2xpY2sgPSB0aGlzLm9uRXhwYW5kZWRDbGljay5iaW5kKHRoaXMsIHZhbHVlLCByZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPHNwYW4gey4uLmF0dHJzfVxuICAgICAgICAgICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg9XCIwXCJcbiAgICAgICAgICAgICAgICAgICAgb25LZXlEb3duPXt0aGlzLmV4cGFuZGVkS2V5ZG93bi5iaW5kKHRoaXMsIHZhbHVlLCByZWNvcmQsIGluZGV4KX1cbiAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD17aGFzRXhwYW5kZWQgPyBsb2NhbGUuZXhwYW5kZWQgOiBsb2NhbGUuZm9sZGVkfVxuICAgICAgICAgICAgICAgICAgICBhcmlhLWV4cGFuZGVkPXtoYXNFeHBhbmRlZH1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbHN9PlxuICAgICAgICAgICAgICAgICAgICB7c3dpdGNoTm9kZX1cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgb25FeHBhbmRlZENsaWNrKHZhbHVlLCByZWNvcmQsIGksIGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wZW5Sb3dLZXlzID0gWy4uLnRoaXMuc3RhdGUub3BlblJvd0tleXNdLFxuICAgICAgICAgICAgICAgIHsgcHJpbWFyeUtleSB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBpZCA9IHJlY29yZFtwcmltYXJ5S2V5XSxcbiAgICAgICAgICAgICAgICBpbmRleCA9IG9wZW5Sb3dLZXlzLmluZGV4T2YoaWQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBvcGVuUm93S2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcGVuUm93S2V5cy5wdXNoKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKCdvcGVuUm93S2V5cycgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlblJvd0tleXM6IG9wZW5Sb3dLZXlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uUm93T3BlbihvcGVuUm93S2V5cywgaWQsIGluZGV4ID09PSAtMSwgcmVjb3JkKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3QgdG9BcnJheUNoaWxkcmVuID0gQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCAoY2hpbGQsIGluZGV4KSA9PiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgICAgICAgICBrZXk6IGluZGV4XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBjb25zdCB7cHJlZml4fSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICB0b0FycmF5Q2hpbGRyZW4udW5zaGlmdCg8Q29sIHRpdGxlPVwiXCIga2V5PVwiZXhwYW5kZWRcIiBjZWxsPXt0aGlzLnJlbmRlckV4cGFuZGVkQ2VsbC5iaW5kKHRoaXMpfSB3aWR0aD17NTB9IGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLWV4cGFuZGVkYH0gX19ub3JtYWxpemVkLz4pO1xuICAgICAgICAgICAgcmV0dXJuIHRvQXJyYXlDaGlsZHJlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vcm1hbGl6ZURhdGFTb3VyY2UoZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgICAgICAgZHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtQ29weSA9IHsgLi4uaXRlbSB9O1xuICAgICAgICAgICAgICAgIGl0ZW1Db3B5Ll9fZXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKGl0ZW0sIGl0ZW1Db3B5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBwcmVmZXItY29uc3QgKi9cbiAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudHMsIG9wZW5Sb3dLZXlzLCBleHBhbmRlZFJvd1JlbmRlciwgaGFzRXhwYW5kZWRSb3dDdHJsLCBjaGlsZHJlbiwgZGF0YVNvdXJjZSwgZ2V0RXhwYW5kZWRDb2xQcm9wcywgZXhwYW5kZWRSb3dJbmRlbnQsIG9uUm93T3Blbiwgb25FeHBhbmRlZFJvd0NsaWNrLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAoZXhwYW5kZWRSb3dSZW5kZXIgJiYgIWNvbXBvbmVudHMuUm93KSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cyA9IHsuLi5jb21wb25lbnRzfTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLlJvdyA9IFJvd0NvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBkYXRhU291cmNlID0gdGhpcy5ub3JtYWxpemVEYXRhU291cmNlKGRhdGFTb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cGFuZGVkUm93UmVuZGVyICYmIGhhc0V4cGFuZGVkUm93Q3RybCkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5ub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoPEJhc2VDb21wb25lbnQgey4uLm90aGVyc30gZGF0YVNvdXJjZT17ZGF0YVNvdXJjZX0gIGNvbXBvbmVudHM9e2NvbXBvbmVudHN9PlxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgIDwvQmFzZUNvbXBvbmVudD4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpY3MoRXhwYW5kZWRUYWJsZSwgQmFzZUNvbXBvbmVudCk7XG4gICAgcmV0dXJuIEV4cGFuZGVkVGFibGU7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvZXhwYW5kZWQuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBkb20gfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBWaXJ0dWFsQm9keSBmcm9tICcuL3ZpcnR1YWwvYm9keSc7XG5pbXBvcnQgeyBzdGF0aWNzIH0gZnJvbSAnLi91dGlsJztcblxuY29uc3Qgbm9vcCA9ICgpID0+IHsgfTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZpcnR1YWwoQmFzZUNvbXBvbmVudCkge1xuICAgIGNsYXNzIFZpcnR1YWxUYWJsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgICAgIHN0YXRpYyBWaXJ0dWFsQm9keSA9IFZpcnR1YWxCb2R5O1xuICAgICAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDmmK/lkKblvIDlkK/omZrmi5/mu5rliqhcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdXNlVmlydHVhbDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOiuvue9ruihjOmrmFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByb3dIZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgICAgICAgICBtYXhCb2R5SGVpZ2h0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gICAgICAgICAgICBwcmltYXJ5S2V5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAgICAgZGF0YVNvdXJjZTogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDlnKjlhoXlrrnljLrln5/mu5rliqjnmoTml7blgJnop6blj5HnmoTlh73mlbBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb25Cb2R5U2Nyb2xsOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgICAgIC4uLkJhc2VDb21wb25lbnQucHJvcFR5cGVzLFxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgICAgIC4uLkJhc2VDb21wb25lbnQuZGVmYXVsdFByb3BzLFxuICAgICAgICAgICAgcHJpbWFyeUtleTogJ2lkJyxcbiAgICAgICAgICAgIHJvd0hlaWdodDogbm9vcCxcbiAgICAgICAgICAgIG1heEJvZHlIZWlnaHQ6IDIwMCxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IHt9LFxuICAgICAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgICAgICAgICAgb25Cb2R5U2Nyb2xsOiBub29wXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0aWMgY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gICAgICAgICAgICBvblZpcnR1YWxTY3JvbGw6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAgICAgYm9keUhlaWdodDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgICAgIGlubmVyVG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAgICAgZ2V0Qm9keU5vZGU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAgICAgZ2V0VGFibGVJbnN0YW5jZUZvclZpcnR1YWw6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAgICAgcm93U2VsZWN0aW9uOiBQcm9wVHlwZXMub2JqZWN0XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgIHJvd0hlaWdodDogdGhpcy5wcm9wcy5yb3dIZWlnaHQsXG4gICAgICAgICAgICBzY3JvbGxUb1JvdzogdGhpcy5wcm9wcy5zY3JvbGxUb1JvdyxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5wcm9wcy5tYXhCb2R5SGVpZ2h0XG4gICAgICAgIH1cblxuICAgICAgICBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9uVmlydHVhbFNjcm9sbDogdGhpcy5vblNjcm9sbCxcbiAgICAgICAgICAgICAgICBib2R5SGVpZ2h0OiB0aGlzLmNvbXB1dGVCb2R5SGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgaW5uZXJUb3A6IHRoaXMuY29tcHV0ZUlubmVyVG9wKCksXG4gICAgICAgICAgICAgICAgZ2V0Qm9keU5vZGU6IHRoaXMuZ2V0Qm9keU5vZGUsXG4gICAgICAgICAgICAgICAgZ2V0VGFibGVJbnN0YW5jZUZvclZpcnR1YWw6IHRoaXMuZ2V0VGFibGVJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICByb3dTZWxlY3Rpb246IHRoaXMucm93U2VsZWN0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICAgICAgY29uc3QgeyB1c2VWaXJ0dWFsLCBkYXRhU291cmNlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgICAgICB0aGlzLmhhc1ZpcnR1YWxEYXRhID0gIHVzZVZpcnR1YWwgJiYgZGF0YVNvdXJjZSAmJiBkYXRhU291cmNlLmxlbmd0aCA+IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnREaWRNb3VudCgpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzVmlydHVhbERhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RTY3JvbGxUb3AgPSB0aGlzLmJvZHlOb2RlLnNjcm9sbFRvcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hZGp1c3RTY3JvbGxUb3AoKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0U2l6ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZUNvbXB1dGVTaXplKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICAgICAgY29uc3QgeyB1c2VWaXJ0dWFsLCBkYXRhU291cmNlIH0gPSBuZXh0UHJvcHM7XG5cbiAgICAgICAgICAgIHRoaXMuaGFzVmlydHVhbERhdGEgPSAgdXNlVmlydHVhbCAmJiBkYXRhU291cmNlICYmIGRhdGFTb3VyY2UubGVuZ3RoID4gMDtcblxuICAgICAgICAgICAgaWYgKCdtYXhCb2R5SGVpZ2h0JyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5oZWlnaHQgIT09IG5leHRQcm9wcy5tYXhCb2R5SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBuZXh0UHJvcHMubWF4Qm9keUhlaWdodFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgnc2Nyb2xsVG9Sb3cnIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb1JvdzogbmV4dFByb3BzLnNjcm9sbFRvUm93XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnJvd0hlaWdodCAmJiAncm93SGVpZ2h0JyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3cgPSB0aGlzLmdldFJvd05vZGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByb3dDbGllbnRIZWlnaHQgPSByb3cgJiYgcm93LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAocm93Q2xpZW50SGVpZ2h0ICYmIHJvd0NsaWVudEhlaWdodCAhPT0gdGhpcy5zdGF0ZS5yb3dIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dIZWlnaHQ6IHJvd0NsaWVudEhlaWdodFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0U2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFNpemUoKTtcbiAgICAgICAgICAgIHRoaXMucmVDb21wdXRlU2l6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVDb21wdXRlU2l6ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcm93SGVpZ2h0IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByb3dIZWlnaHQgPT09ICdmdW5jdGlvbicgJiYgdGhpcy5oYXNWaXJ0dWFsRGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuZ2V0Um93Tm9kZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvd0NsaWVudEhlaWdodCA9IHJvdyAmJiByb3cuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChyb3dDbGllbnRIZWlnaHQgIT09IHRoaXMuc3RhdGUucm93SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93SGVpZ2h0OiByb3dDbGllbnRIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29tcHV0ZUJvZHlIZWlnaHQoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJvd0hlaWdodCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YVNvdXJjZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygcm93SGVpZ2h0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YVNvdXJjZS5sZW5ndGggKiByb3dIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wdXRlSW5uZXJUb3AoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJvd0hlaWdodCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygcm93SGVpZ2h0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuc3RhcnQgKiByb3dIZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0VmlzaWJsZVJhbmdlKEV4cGVjdFN0YXJ0KSB7XG4gICAgICAgICAgICBjb25zdCB7IGhlaWdodCwgcm93SGVpZ2h0IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gdGhpcy5wcm9wcy5kYXRhU291cmNlLmxlbmd0aDtcblxuICAgICAgICAgICAgbGV0IGVuZCwgdmlzaWJsZUNvdW50ID0gMDtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJvd0hlaWdodCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIHRyeSBnZXQgY2VsbCBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgZW5kID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmlzaWJsZUNvdW50ID0gcGFyc2VJbnQoaGVpZ2h0IC8gcm93SGVpZ2h0LCAxMCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBFeHBlY3RTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IEV4cGVjdFN0YXJ0IDwgbGVuID8gRXhwZWN0U3RhcnQgOiAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKCtzdGFydCArIDEgKyB2aXNpYmxlQ291bnQgKyAxMCwgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlQ291bnQgPSB2aXNpYmxlQ291bnQ7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkanVzdFNjcm9sbFRvcCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1ZpcnR1YWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Tm9kZS5zY3JvbGxUb3AgPSB0aGlzLmxhc3RTY3JvbGxUb3AgJSB0aGlzLnN0YXRlLnJvd0hlaWdodCArIHRoaXMuc3RhdGUucm93SGVpZ2h0ICogdGhpcy5zdGF0ZS5zY3JvbGxUb1JvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFkanVzdFNpemUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNWaXJ0dWFsRGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmJvZHlOb2RlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpcnR1YWxTY3JvbGxOb2RlID0gYm9keS5xdWVyeVNlbGVjdG9yKCdkaXYnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNsaWVudEhlaWdodCwgY2xpZW50V2lkdGggfSA9IGJvZHk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZUluYyA9IHRoaXMudGFibGVJbmM7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGVOb2RlID0gZmluZERPTU5vZGUodGFibGVJbmMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJlZml4IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlck5vZGUgPSB0YWJsZU5vZGUucXVlcnlTZWxlY3RvcihgLiR7cHJlZml4fXRhYmxlLWhlYWRlciB0YWJsZWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlckNsaWVudFdpZHRoID0gaGVhZGVyTm9kZSAmJiBoZWFkZXJOb2RlLmNsaWVudFdpZHRoO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNsaWVudFdpZHRoIDwgaGVhZGVyQ2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tLnNldFN0eWxlKHZpcnR1YWxTY3JvbGxOb2RlLCAnbWluLXdpZHRoJywgaGVhZGVyQ2xpZW50V2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWZ0Tm9kZSA9IHRoaXMuYm9keUxlZnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByaWdodE5vZGUgPSB0aGlzLmJvZHlSaWdodE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGxlZnROb2RlICYmIGRvbS5zZXRTdHlsZShsZWZ0Tm9kZSwgJ21heC1oZWlnaHQnLCBjbGllbnRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICByaWdodE5vZGUgJiYgZG9tLnNldFN0eWxlKHJpZ2h0Tm9kZSwgJ21heC1oZWlnaHQnLCBjbGllbnRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc1Njcm9sbGJhciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNTY3JvbGxiYXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIG9uU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8g6YG/5YWN5qiq5ZCR5rua5Yqo5bim5p2l55qE5oCn6IO96Zeu6aKYXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSB0aGlzLmJvZHlOb2RlLnNjcm9sbFRvcDtcbiAgICAgICAgICAgIGlmIChzY3JvbGxUb3AgPT09IHRoaXMubGFzdFNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5jb21wdXRlU2Nyb2xsVG9Sb3coc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgIGlmICghKCdzY3JvbGxUb1JvdycgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9Sb3c6IHN0YXJ0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQm9keVNjcm9sbChzdGFydCk7XG4gICAgICAgICAgICB0aGlzLmxhc3RTY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wdXRlU2Nyb2xsVG9Sb3cob2Zmc2V0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHJvd0hlaWdodCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gcGFyc2VJbnQob2Zmc2V0IC8gcm93SGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldEJvZHlOb2RlID0gKG5vZGUsIGxvY2tUeXBlKSA9PiB7XG4gICAgICAgICAgICBsb2NrVHlwZSA9IGxvY2tUeXBlID8gbG9ja1R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBsb2NrVHlwZS5zdWJzdHIoMSkgOiAnJztcbiAgICAgICAgICAgIHRoaXNbYGJvZHkke2xvY2tUeXBlfU5vZGVgXSA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRUYWJsZUluc3RhbmNlID0gKHR5cGUsIGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZSA/IHR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eXBlLnN1YnN0cigxKSA6ICcnO1xuICAgICAgICAgICAgdGhpc1tgdGFibGUke3R5cGV9SW5jYF0gPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFJvd05vZGUoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGluIGNhc2Ugb2YgZmluZGluZyBhbiB1bm1vdW50ZWQgY29tcG9uZW50IGR1ZSB0byBjYWNoZWQgZGF0YVxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gY2xlYXIgcmVmcyBvZiB0aGlzLnRhYmxlSW5jIHdoZW4gZGF0YVNvdXJjZSBDaGFuZ2VkXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRyeSBjYXRjaCBmb3IgdGVtcG9yYXJ5XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRET01Ob2RlKHRoaXMudGFibGVJbmMuZ2V0Um93UmVmKDApKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycywgcHJlZmVyLWNvbnN0ICovXG4gICAgICAgICAgICBsZXQgeyB1c2VWaXJ0dWFsLCBjb21wb25lbnRzLCBkYXRhU291cmNlLCBmaXhlZEhlYWRlciwgcm93SGVpZ2h0LCBzY3JvbGxUb1Jvdywgb25Cb2R5U2Nyb2xsLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgICAgIGNvbnN0IGVudGlyZURhdGFTb3VyY2UgPSBkYXRhU291cmNlO1xuXG4gICAgICAgICAgICB0aGlzLnJvd1NlbGVjdGlvbiA9IHRoaXMucHJvcHMucm93U2VsZWN0aW9uO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzVmlydHVhbERhdGEpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzID0geyAuLi5jb21wb25lbnRzIH07XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSB0aGlzLmdldFZpc2libGVSYW5nZSh0aGlzLnN0YXRlLnNjcm9sbFRvUm93KTtcbiAgICAgICAgICAgICAgICBkYXRhU291cmNlID0gZGF0YVNvdXJjZS5zbGljZShzdGFydCwgZW5kKTtcblxuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50cy5Cb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuQm9keSA9IFZpcnR1YWxCb2R5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaXhlZEhlYWRlciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoPEJhc2VDb21wb25lbnQgey4uLm90aGVyc30gZGF0YVNvdXJjZT17ZGF0YVNvdXJjZX0gZW50aXJlRGF0YVNvdXJjZT17ZW50aXJlRGF0YVNvdXJjZX0gY29tcG9uZW50cz17Y29tcG9uZW50c30gZml4ZWRIZWFkZXI9e2ZpeGVkSGVhZGVyfSAvPik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljcyhWaXJ0dWFsVGFibGUsIEJhc2VDb21wb25lbnQpO1xuICAgIHJldHVybiBWaXJ0dWFsVGFibGU7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvdmlydHVhbC5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSAgZnJvbSAgJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEJvZHlDb21wb25lbnQgZnJvbSAnLi4vYmFzZS9ib2R5JztcblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcHJlZmVyLXN0YXRlbGVzcy1mdW5jdGlvbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlydHVhbEJvZHkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY29sR3JvdXA6IFByb3BUeXBlcy5hbnlcbiAgICB9XG5cbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICBtYXhCb2R5SGVpZ2h0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gICAgICAgIG9uQm9keVNjcm9sbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uVmlydHVhbFNjcm9sbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uTG9ja0JvZHlTY3JvbGw6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBib2R5SGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBpbm5lclRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgZ2V0Tm9kZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGdldEJvZHlOb2RlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgZ2V0TG9ja05vZGU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBsb2NrVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsICdyaWdodCddKVxuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCBib2R5Tm9kZSA9IGZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgICAvLyAvLyBmb3IgZml4ZWRcbiAgICAgICAgdGhpcy5jb250ZXh0LmdldE5vZGUoJ2JvZHknLCBib2R5Tm9kZSk7XG4gICAgICAgIC8vIGZvciB2aXJ0dWFsXG4gICAgICAgIHRoaXMuY29udGV4dC5nZXRCb2R5Tm9kZShib2R5Tm9kZSwgdGhpcy5jb250ZXh0LmxvY2tUeXBlKTtcbiAgICAgICAgLy8gZm9yIGxvY2tcbiAgICAgICAgdGhpcy5jb250ZXh0LmdldExvY2tOb2RlKCdib2R5JywgYm9keU5vZGUsIHRoaXMuY29udGV4dC5sb2NrVHlwZSk7XG4gICAgfVxuXG4gICAgdGFibGVSZWYgPSAodGFibGUpID0+IHtcbiAgICAgICAgdGhpcy50YWJsZU5vZGUgPSB0YWJsZTtcbiAgICB9XG5cbiAgICB2aXJ0dWFsU2Nyb2xsUmVmID0gKHZpcnR1YWxTY3JvbGwpID0+IHtcbiAgICAgICAgdGhpcy52aXJ0dWFsU2Nyb2xsTm9kZSA9IHZpcnR1YWxTY3JvbGw7XG4gICAgfVxuXG4gICAgb25TY3JvbGwgPSAoKSA9PiB7XG4gICAgICAgIC8vIGZvciBmaXhlZFxuICAgICAgICB0aGlzLmNvbnRleHQub25Cb2R5U2Nyb2xsKCk7XG4gICAgICAgIC8vIGZvciBsb2NrXG4gICAgICAgIHRoaXMuY29udGV4dC5vbkxvY2tCb2R5U2Nyb2xsKCk7XG4gICAgICAgIC8vIGZvciB2aXJ0dWFsXG4gICAgICAgIHRoaXMuY29udGV4dC5vblZpcnR1YWxTY3JvbGwoKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBjbGFzc05hbWUsIGNvbEdyb3VwLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHttYXhCb2R5SGVpZ2h0LCBib2R5SGVpZ2h0LCBpbm5lclRvcH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiAoPGRpdiBzdHlsZT17e21heEhlaWdodDogbWF4Qm9keUhlaWdodH19IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBvblNjcm9sbD17dGhpcy5vblNjcm9sbH0+XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7aGVpZ2h0OiBib2R5SGVpZ2h0LCBvdmVyZmxvdzogJ2hpZGRlbicsIHBvc2l0aW9uOiAncmVsYXRpdmUnfX0gcmVmPXt0aGlzLnZpcnR1YWxTY3JvbGxSZWZ9PlxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3toZWlnaHQ6ICcxMDAlJywgcG9zaXRpb246ICdyZWxhdGl2ZScsIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVkoJHtpbm5lclRvcH1weClgfX0+XG4gICAgICAgICAgICAgICAgICAgIDx0YWJsZSByZWY9e3RoaXMudGFibGVSZWZ9PlxuICAgICAgICAgICAgICAgICAgICAgICAge2NvbEdyb3VwfVxuICAgICAgICAgICAgICAgICAgICAgICAgPEJvZHlDb21wb25lbnQgey4uLm90aGVyc30gcHJlZml4PXtwcmVmaXh9Lz5cbiAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj4pO1xuICAgIH1cbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL3ZpcnR1YWwvYm9keS5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmaW5kRE9NTm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgc2hhbGxvd0VsZW1lbnRFcXVhbHMgZnJvbSAnc2hhbGxvdy1lbGVtZW50LWVxdWFscyc7XG5pbXBvcnQgeyBkb20sIGxvZywgb2JqLCBldmVudHMgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBMb2NrUm93IGZyb20gJy4vbG9jay9yb3cnO1xuaW1wb3J0IExvY2tCb2R5IGZyb20gJy4vbG9jay9ib2R5JztcbmltcG9ydCBMb2NrSGVhZGVyIGZyb20gJy4vbG9jay9oZWFkZXInO1xuaW1wb3J0IExvY2tXcmFwcGVyIGZyb20gJy4vZml4ZWQvd3JhcHBlcic7XG5pbXBvcnQgeyBzdGF0aWNzIH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbG9jayhCYXNlQ29tcG9uZW50KSB7XG4gICAgLyoqIFRhYmxlICovXG4gICAgY2xhc3MgTG9ja1RhYmxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAgICAgc3RhdGljIExvY2tSb3cgPSBMb2NrUm93O1xuICAgICAgICBzdGF0aWMgTG9ja0JvZHkgPSBMb2NrQm9keTtcbiAgICAgICAgc3RhdGljIExvY2tIZWFkZXIgPSBMb2NrSGVhZGVyO1xuICAgICAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAgICAgc2Nyb2xsVG9Db2w6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOaMh+Wumua7muWKqOWIsOafkOS4gOihjO+8jOS7heWcqGB1c2VWaXJ0dWFsYOeahOaXtuWAmeeUn+aViFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzY3JvbGxUb1JvdzogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgICAgIC4uLkJhc2VDb21wb25lbnQucHJvcFR5cGVzXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAgICAgLi4uQmFzZUNvbXBvbmVudC5kZWZhdWx0UHJvcHNcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgICAgIGdldFRhYmxlSW5zdGFuY2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAgICAgZ2V0TG9ja05vZGU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAgICAgb25Mb2NrQm9keVNjcm9sbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgICAgICBvbkxvY2tCb2R5V2hlZWw6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAgICAgb25Sb3dNb3VzZUVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgICAgIG9uUm93TW91c2VMZWF2ZTogUHJvcFR5cGVzLmZ1bmNcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLmxvY2tMZWZ0Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIHRoaXMubG9ja1JpZ2h0Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ2V0VGFibGVJbnN0YW5jZTogdGhpcy5nZXRUYWJsZUluc3RhbmNlLFxuICAgICAgICAgICAgICAgIGdldExvY2tOb2RlOiB0aGlzLmdldE5vZGUsXG4gICAgICAgICAgICAgICAgb25Mb2NrQm9keVdoZWVsOiB0aGlzLm9uTG9ja0JvZHlXaGVlbCxcbiAgICAgICAgICAgICAgICBvbkxvY2tCb2R5U2Nyb2xsOiB0aGlzLm9uTG9ja0JvZHlTY3JvbGwsXG4gICAgICAgICAgICAgICAgb25Sb3dNb3VzZUVudGVyOiB0aGlzLm9uUm93TW91c2VFbnRlcixcbiAgICAgICAgICAgICAgICBvblJvd01vdXNlTGVhdmU6IHRoaXMub25Sb3dNb3VzZUxlYXZlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFNpemUgPSB0aGlzLmFkanVzdFNpemUuYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgdGhpcy5hZGp1c3RTaXplKCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbCgpO1xuXG4gICAgICAgICAgICBldmVudHMub24od2luZG93LCAncmVzaXplJywgdGhpcy5hZGp1c3RTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChuZXh0UHJvcHMucHVyZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRXF1YWwgPSBzaGFsbG93RWxlbWVudEVxdWFscyhuZXh0UHJvcHMsIHRoaXMucHJvcHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhKGlzRXF1YWwgJiYgb2JqLnNoYWxsb3dFcXVhbChuZXh0Q29udGV4dCwgdGhpcy5jb250ZXh0KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50V2lsbFVwZGF0ZSgpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzTG9jayA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RTaXplKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgICAgIGV2ZW50cy5vZmYod2luZG93LCAncmVzaXplJywgdGhpcy5hZGp1c3RTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuU3RhdGUocHJvcHMpIHtcbiAgICAgICAgICAgIGxldCB7IGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5ub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgICAgICAgICBjb25zdCBzcGxpdENoaWxkcmVuID0gdGhpcy5zcGxpdEZyb21Ob3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgICAgICAgICBjb25zdCB7IGxvY2tMZWZ0Q2hpbGRyZW4sIGxvY2tSaWdodENoaWxkcmVuIH0gPSBzcGxpdENoaWxkcmVuO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsb2NrTGVmdENoaWxkcmVuLFxuICAgICAgICAgICAgICAgIGxvY2tSaWdodENoaWxkcmVuLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiB0aGlzLm1lcmdlRnJvbVNwbGl0TG9ja0NoaWxkcmVuKHNwbGl0Q2hpbGRyZW4pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5bCGUmVhY3Tnu5PmnoTljJbmlbDmja7mj5Dlj5Zwcm9wc+i9rOaNouaIkOaVsOe7hFxuICAgICAgICBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IGlzTG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgZ2V0Q2hpbGRyZW4gPSAoY2hpbGRyZW4pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgICAgICAgICAgICBDaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB7IC4uLmNoaWxkLnByb3BzIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoW3RydWUsICdsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwcm9wcy5sb2NrKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNMb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgnd2lkdGgnIGluIHByb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cud2FybmluZyhgU2hvdWxkIGNvbmZpZyB3aWR0aCBmb3IgbG9jayBjb2x1bW4gbmFtZWQgWyAke3Byb3BzLmRhdGFJbmRleH0gXS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IGdldENoaWxkcmVuKGNoaWxkLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gZ2V0Q2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgICAgICAgICAgcmV0LmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIOS4uuiHquWumuS5ieeahOWIl+eJueauiuWkhOeQhlxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5fX25vcm1hbGl6ZWQgJiYgaXNMb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmxvY2sgPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGlsZC5fX25vcm1hbGl6ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9pc0xvY2sgPSBpc0xvY2s7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy/ku47mlbDnu4TkuK3liIbnprvlh7psb2Nr55qE5YiX5ZKM5q2j5bi455qE5YiXXG4gICAgICAgIHNwbGl0RnJvbU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5DaGlsZHJlbiA9IGRlZXBDb3B5KGNoaWxkcmVuKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2tMZWZ0Q2hpbGRyZW4gPSBkZWVwQ29weShjaGlsZHJlbik7XG4gICAgICAgICAgICBjb25zdCBsb2NrUmlnaHRDaGlsZHJlbiA9IGRlZXBDb3B5KGNoaWxkcmVuKTtcbiAgICAgICAgICAgIGNvbnN0IGxvb3AgPSAobG9ja0NoaWxkcmVuLCBjb25kaXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgICAgICAgICAgICBsb2NrQ2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBsb29wKGNoaWxkLmNoaWxkcmVuLCBjb25kaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JkZXIgPSBjb25kaXRpb24oY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldC5mb3JFYWNoKHJlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbG9ja0NoaWxkcmVuLmluZGV4T2YocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgbG9ja0NoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2tDaGlsZHJlbjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsb29wKGxvY2tMZWZ0Q2hpbGRyZW4sIChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5sb2NrID09PSB0cnVlIHx8IGNoaWxkLmxvY2sgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbG9vcChsb2NrUmlnaHRDaGlsZHJlbiwgKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmxvY2sgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb29wKG9yaWdpbkNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubG9jayAhPT0gdHJ1ZSAmJiBjaGlsZC5sb2NrICE9PSAnbGVmdCcgJiYgY2hpbGQubG9jayAhPT0gJ3JpZ2h0JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsb2NrTGVmdENoaWxkcmVuLFxuICAgICAgICAgICAgICAgIGxvY2tSaWdodENoaWxkcmVuLFxuICAgICAgICAgICAgICAgIG9yaWdpbkNoaWxkcmVuXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy/lsIblt6bkvqfnmoTplIHliJfmoJHlkozkuK3pl7TnmoTmma7pgJrmoJHlj4rlj7PkvqfnmoTplIHliJfmoJHov5vooYzlkIjlubZcbiAgICAgICAgbWVyZ2VGcm9tU3BsaXRMb2NrQ2hpbGRyZW4oc3BsaXRDaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3QgeyBsb2NrTGVmdENoaWxkcmVuLCBsb2NrUmlnaHRDaGlsZHJlbiB9ID0gc3BsaXRDaGlsZHJlbjtcbiAgICAgICAgICAgIGxldCB7IG9yaWdpbkNoaWxkcmVuIH0gPSBzcGxpdENoaWxkcmVuO1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkob3JpZ2luQ2hpbGRyZW4sIGxvY2tMZWZ0Q2hpbGRyZW4pO1xuICAgICAgICAgICAgb3JpZ2luQ2hpbGRyZW4gPSBvcmlnaW5DaGlsZHJlbi5jb25jYXQobG9ja1JpZ2h0Q2hpbGRyZW4pO1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbkNoaWxkcmVuO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0VGFibGVJbnN0YW5jZSA9ICh0eXBlLCBpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUgPyB0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zdWJzdHIoMSkgOiAnJztcbiAgICAgICAgICAgIHRoaXNbYHRhYmxlJHt0eXBlfUluY2BdID0gaW5zdGFuY2U7XG4gICAgICAgIH1cblxuICAgICAgICBnZXROb2RlID0gKHR5cGUsIG5vZGUsIGxvY2tUeXBlKSA9PiB7XG4gICAgICAgICAgICBsb2NrVHlwZSA9IGxvY2tUeXBlID8gbG9ja1R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBsb2NrVHlwZS5zdWJzdHIoMSkgOiAnJztcbiAgICAgICAgICAgIHRoaXNbYCR7dHlwZX0ke2xvY2tUeXBlfU5vZGVgXSA9IG5vZGU7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2hlYWRlcicgJiYgIXRoaXMuaW5uZXJIZWFkZXJOb2RlICYmICFsb2NrVHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJIZWFkZXJOb2RlID0gdGhpcy5oZWFkZXJOb2RlLnF1ZXJ5U2VsZWN0b3IoJ2RpdicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb25Sb3dNb3VzZUVudGVyID0gKHJlY29yZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTG9jaygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5nZXRSb3dOb2RlKGluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0Um93ID0gdGhpcy5nZXRSb3dOb2RlKGluZGV4LCAnbGVmdCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0Um93ID0gdGhpcy5nZXRSb3dOb2RlKGluZGV4LCAncmlnaHQnKTtcbiAgICAgICAgICAgICAgICBbcm93LCBsZWZ0Um93LCByaWdodFJvd10uZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgICAgICAgICByb3cgJiYgZG9tLmFkZENsYXNzKHJvdywgJ2hvdmVyZWQnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9uUm93TW91c2VMZWF2ZSA9IChyZWNvcmQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0xvY2soKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuZ2V0Um93Tm9kZShpbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdFJvdyA9IHRoaXMuZ2V0Um93Tm9kZShpbmRleCwgJ2xlZnQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodFJvdyA9IHRoaXMuZ2V0Um93Tm9kZShpbmRleCwgJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgW3JvdywgbGVmdFJvdywgcmlnaHRSb3ddLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcm93ICYmIGRvbS5yZW1vdmVDbGFzcyhyb3csICdob3ZlcmVkJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzY3JvbGwoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNjcm9sbFRvQ29sID0gMCwgc2Nyb2xsVG9Sb3cgPSAwIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKCFzY3JvbGxUb0NvbCAmJiAhc2Nyb2xsVG9Sb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb2xDZWxsTm9kZSA9IHRoaXMuZ2V0Q2VsbE5vZGUoMCwgc2Nyb2xsVG9Db2wpO1xuICAgICAgICAgICAgY29uc3Qgcm93Q2VsbE5vZGUgPSB0aGlzLmdldENlbGxOb2RlKHNjcm9sbFRvUm93LCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHlOb2RlT2Zmc2V0ID0gdGhpcy5ib2R5Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGlmIChjb2xDZWxsTm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxOb2Rlb2Zmc2V0ID0gY29sQ2VsbE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsTGVmdCA9IGNlbGxOb2Rlb2Zmc2V0LmxlZnQgLSBib2R5Tm9kZU9mZnNldC5sZWZ0O1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keU5vZGUuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm93Q2VsbE5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsTm9kZW9mZnNldCA9IHJvd0NlbGxOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IGNlbGxOb2Rlb2Zmc2V0LnRvcCAtIGJvZHlOb2RlT2Zmc2V0LnRvcDtcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHlOb2RlLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9uTG9ja0JvZHlXaGVlbCA9IChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB5ID0gZS5kZWx0YVk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0xvY2soKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2tSaWdodEJvZHkgPSB0aGlzLmJvZHlSaWdodE5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGxvY2tMZWZ0Qm9keSA9IHRoaXMuYm9keUxlZnROb2RlLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxOb2RlID0gdGhpcy5ib2R5Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgeyBzY3JvbGxUb3AsIGNsaWVudEhlaWdodCwgc2Nyb2xsSGVpZ2h0IH0gPSBzY3JvbGxOb2RlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxvY2tMZWZ0Qm9keSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NrTGVmdEJvZHkuc2Nyb2xsVG9wID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxvY2tSaWdodEJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9ja1JpZ2h0Qm9keS5zY3JvbGxUb3AgPSB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzY3JvbGxOb2RlLnNjcm9sbFRvcCA9IHNjcm9sbFRvcCArIHk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzY3JvbGxUb3A6IG5ld1Njcm9sbFRvcCB9ID0gc2Nyb2xsTm9kZTtcbiAgICAgICAgICAgICAgICBpZiAobmV3U2Nyb2xsVG9wICsgY2xpZW50SGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0ICYmIG5ld1Njcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb25Mb2NrQm9keVNjcm9sbCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTG9jaygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9ja1JpZ2h0Qm9keSA9IHRoaXMuYm9keVJpZ2h0Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgbG9ja0xlZnRCb2R5ID0gdGhpcy5ib2R5TGVmdE5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGxvY2tSaWdodFRhYmxlID0gdGhpcy5nZXRXcmFwcGVyTm9kZSgncmlnaHQnKSxcbiAgICAgICAgICAgICAgICAgICAgbG9ja0xlZnRUYWJsZSA9IHRoaXMuZ2V0V3JhcHBlck5vZGUoJ2xlZnQnKSxcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93Q2xhc3NOYW1lID0gJ3NoYWRvdyc7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gdGhpcy5ib2R5Tm9kZS5zY3JvbGxMZWZ0LCB5ID0gdGhpcy5ib2R5Tm9kZS5zY3JvbGxUb3A7XG5cbiAgICAgICAgICAgICAgICBpZiAobG9ja0xlZnRCb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2tMZWZ0Qm9keS5zY3JvbGxUb3AgPSB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobG9ja1JpZ2h0Qm9keSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NrUmlnaHRCb2R5LnNjcm9sbFRvcCA9IHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2tMZWZ0VGFibGUgJiYgZG9tLnJlbW92ZUNsYXNzKGxvY2tMZWZ0VGFibGUsIHNoYWRvd0NsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvY2tSaWdodFRhYmxlICYmIGRvbS5hZGRDbGFzcyhsb2NrUmlnaHRUYWJsZSwgc2hhZG93Q2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHggPT09ICh0aGlzLmJvZHlOb2RlLnNjcm9sbFdpZHRoIC0gdGhpcy5ib2R5Tm9kZS5jbGllbnRXaWR0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9ja0xlZnRUYWJsZSAmJiBkb20uYWRkQ2xhc3MobG9ja0xlZnRUYWJsZSwgc2hhZG93Q2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbG9ja1JpZ2h0VGFibGUgJiYgZG9tLnJlbW92ZUNsYXNzKGxvY2tSaWdodFRhYmxlLCBzaGFkb3dDbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2tMZWZ0VGFibGUgJiYgZG9tLmFkZENsYXNzKGxvY2tMZWZ0VGFibGUsIHNoYWRvd0NsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvY2tSaWdodFRhYmxlICYmIGRvbS5hZGRDbGFzcyhsb2NrUmlnaHRUYWJsZSwgc2hhZG93Q2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUYWJsZeWkhOeQhui/h+WQjuecn+WunueahGxvY2vnirbmgIFcbiAgICAgICAgaXNMb2NrKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9ja0xlZnRDaGlsZHJlbi5sZW5ndGggfHwgdGhpcy5sb2NrUmlnaHRDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDnlKjmiLforr7nva7nmoRsb2Nr54q25oCBXG4gICAgICAgIGlzT3JpZ2luTG9jaygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0xvY2s7XG4gICAgICAgIH1cblxuICAgICAgICBhZGp1c3RTaXplKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFkanVzdElmVGFibGVOb3ROZWVkTG9jaygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGp1c3RIZWFkZXJTaXplKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGp1c3RCb2R5U2l6ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRqdXN0Q2VsbFNpemUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTG9ja0JvZHlTY3JvbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFkanVzdElmVGFibGVOb3ROZWVkTG9jaygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzT3JpZ2luTG9jaygpICYmIHRoaXMudGFibGVJbmMucHJvcHMuZGF0YVNvdXJjZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25maWdXaWR0aHMgPSB0aGlzLnRhYmxlSW5jLmZsYXRDaGlsZHJlbi5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuZ2V0Q2VsbE5vZGUoMCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHJvdyAmJiByb3cuY2xpZW50V2lkdGgpIHx8IDA7XG4gICAgICAgICAgICAgICAgfSkucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gZmluZERPTU5vZGUodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBub2RlLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2tMZWZ0TGVuID0gdGhpcy5sb2NrTGVmdENoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NrUmlnaHRMZW4gPSB0aGlzLmxvY2tSaWdodENoaWxkcmVuLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmIChjb25maWdXaWR0aHMgPD0gd2lkdGggJiYgY29uZmlnV2lkdGhzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9ja0xlZnRMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25vdE5lZWRBZGp1c3RMb2NrTGVmdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2tSaWdodExlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbm90TmVlZEFkanVzdExvY2tSaWdodCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2tSaWdodExlbiB8fCBsb2NrTGVmdExlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX25vdE5lZWRBZGp1c3RMb2NrTGVmdCB8fCB0aGlzLl9ub3ROZWVkQWRqdXN0TG9ja1JpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25vdE5lZWRBZGp1c3RMb2NrTGVmdCA9IHRoaXMuX25vdE5lZWRBZGp1c3RMb2NrUmlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25vdE5lZWRBZGp1c3RMb2NrTGVmdCA9IHRoaXMuX25vdE5lZWRBZGp1c3RMb2NrUmlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRqdXN0Qm9keVNpemUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0xvY2soKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmJvZHlOb2RlLFxuICAgICAgICAgICAgICAgICAgICBsb2NrTGVmdEJvZHkgPSB0aGlzLmJvZHlMZWZ0Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgbG9ja1JpZ2h0Qm9keSA9IHRoaXMuYm9keVJpZ2h0Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgbG9ja1JpZ2h0Qm9keVdyYXBwZXIgPSB0aGlzLmdldFdyYXBwZXJOb2RlKCdyaWdodCcpLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXIgPSBkb20uc2Nyb2xsYmFyKCksXG4gICAgICAgICAgICAgICAgICAgIGJvZHlIZWlnaHQgPSBib2R5Lm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgaGFzSG96U2Nyb2xsID0gYm9keS5zY3JvbGxXaWR0aCA+IGJvZHkuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhhc1ZlclNjcm9sbCA9IGJvZHkuc2Nyb2xsSGVpZ2h0ID4gYm9keS5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaGFzVmVyU2Nyb2xsID8gc2Nyb2xsYmFyLndpZHRoIDogMCxcbiAgICAgICAgICAgICAgICAgICAgbG9ja0JvZHlIZWlnaHQgPSBib2R5SGVpZ2h0IC0gKGhhc0hvelNjcm9sbCA/IHNjcm9sbGJhci5oZWlnaHQgOiAwKTtcblxuICAgICAgICAgICAgICAgIGxvY2tMZWZ0Qm9keSAmJiBkb20uc2V0U3R5bGUobG9ja0xlZnRCb2R5LCAnbWF4LWhlaWdodCcsIGxvY2tCb2R5SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBsb2NrUmlnaHRCb2R5ICYmIGRvbS5zZXRTdHlsZShsb2NrUmlnaHRCb2R5LCAnbWF4LWhlaWdodCcsIGxvY2tCb2R5SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBsb2NrUmlnaHRCb2R5V3JhcHBlciAmJiBkb20uc2V0U3R5bGUobG9ja1JpZ2h0Qm9keVdyYXBwZXIsICdyaWdodCcsIHdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFkanVzdEhlYWRlclNpemUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0xvY2soKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFibGVJbmMuZ3JvdXBDaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gdGhpcy50YWJsZUluYy5ncm91cENoaWxkcmVuW2luZGV4XS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyUmlnaHRSb3cgPSB0aGlzLmdldEhlYWRlckNlbGxOb2RlKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyTGVmdFJvdyA9IHRoaXMuZ2V0SGVhZGVyQ2VsbE5vZGUoaW5kZXgsIDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyUmlnaHRMb2NrUm93ID0gdGhpcy5nZXRIZWFkZXJDZWxsTm9kZShpbmRleCwgMCwgJ3JpZ2h0JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJMZWZ0TG9ja1JvdyA9IHRoaXMuZ2V0SGVhZGVyQ2VsbE5vZGUoaW5kZXgsIDAsICdsZWZ0Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlclJpZ2h0Um93ICYmIGhlYWRlclJpZ2h0TG9ja1Jvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF4UmlnaHRSb3dIZWlnaHQgPSBoZWFkZXJSaWdodFJvdy5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5zZXRTdHlsZShoZWFkZXJSaWdodExvY2tSb3csICdoZWlnaHQnLCBtYXhSaWdodFJvd0hlaWdodCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFibGVSaWdodEluYy5hZmZpeFJlZiAmJiB0aGlzLnRhYmxlUmlnaHRJbmMuYWZmaXhSZWYuZ2V0SW5zdGFuY2UoKS51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyTGVmdFJvdyAmJiBoZWFkZXJMZWZ0TG9ja1Jvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF4TGVmdFJvd0hlaWdodCA9IGhlYWRlckxlZnRSb3cub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkb20uc2V0U3R5bGUoaGVhZGVyTGVmdExvY2tSb3csICdoZWlnaHQnLCBtYXhMZWZ0Um93SGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YWJsZUxlZnRJbmMuYWZmaXhSZWYgJiYgdGhpcy50YWJsZUxlZnRJbmMuYWZmaXhSZWYuZ2V0SW5zdGFuY2UoKS51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWRqdXN0Q2VsbFNpemUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0xvY2soKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFibGVJbmMucHJvcHMuZGF0YVNvdXJjZS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NrTGVmdFJvdyA9IHRoaXMuZ2V0Q2VsbE5vZGUoaW5kZXgsIDAsICdsZWZ0JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NrUmlnaHRSb3cgPSB0aGlzLmdldENlbGxOb2RlKGluZGV4LCAwLCAncmlnaHQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IHRoaXMuZ2V0Rmlyc3ROb3JtYWxDZWxsTm9kZShpbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dIZWlnaHQgPSByb3cgJiYgcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKHJvdykuaGVpZ2h0KSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbG9ja0xlZnRIZWlnaHQgPSAwLCBsb2NrUmlnaHRIZWlnaHQgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NrTGVmdFJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9ja0xlZnRIZWlnaHQgPSBsb2NrTGVmdFJvdy5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2tSaWdodFJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9ja1JpZ2h0SGVpZ2h0ID0gbG9ja1JpZ2h0Um93Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobG9ja0xlZnRSb3cgJiYgcm93SGVpZ2h0ICE9PSBsb2NrTGVmdEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnNldFN0eWxlKGxvY2tMZWZ0Um93LCAnaGVpZ2h0Jywgcm93SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobG9ja1JpZ2h0Um93ICYmIHJvd0hlaWdodCAhPT0gbG9ja1JpZ2h0SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb20uc2V0U3R5bGUobG9ja1JpZ2h0Um93LCAnaGVpZ2h0Jywgcm93SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2V0V3JhcHBlck5vZGUodHlwZSkge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUgPyB0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zdWJzdHIoMSkgOiAnJztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSBvZiBmaW5kaW5nIGFuIHVubW91bnRlZCBjb21wb25lbnQgZHVlIHRvIGNhY2hlZCBkYXRhXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBjbGVhciByZWZzIG9mIHRhYmxlIHdoZW4gZGF0YVNvdXJjZSBDaGFuZ2VkXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRyeSBjYXRjaCBmb3IgdGVtcG9yYXJ5XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRET01Ob2RlKHRoaXMucmVmc1tgbG9jayR7dHlwZX1gXSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2V0Rmlyc3ROb3JtYWxDZWxsTm9kZShpbmRleCkge1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgbGV0IHJvdztcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICByb3cgPSB0aGlzLmdldENlbGxOb2RlKGluZGV4LCBpKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IHdoaWxlICgoIXJvdyB8fCByb3cgJiYgcm93LnJvd1NwYW4gJiYgcm93LnJvd1NwYW4gPiAxKSAmJiB0aGlzLnRhYmxlSW5jLmZsYXRDaGlsZHJlbi5sZW5ndGggPiBpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFJvd05vZGUoaW5kZXgsIHR5cGUpIHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlID8gdHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR5cGUuc3Vic3RyKDEpIDogJyc7XG4gICAgICAgICAgICBjb25zdCB0YWJsZSA9IHRoaXNbYHRhYmxlJHt0eXBlfUluY2BdO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGluIGNhc2Ugb2YgZmluZGluZyBhbiB1bm1vdW50ZWQgY29tcG9uZW50IGR1ZSB0byBjYWNoZWQgZGF0YVxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gY2xlYXIgcmVmcyBvZiB0YWJsZSB3aGVuIGRhdGFTb3VyY2UgQ2hhbmdlZFxuICAgICAgICAgICAgICAgIC8vIHVzZSB0cnkgY2F0Y2ggZm9yIHRlbXBvcmFyeVxuICAgICAgICAgICAgICAgIHJldHVybiBmaW5kRE9NTm9kZSh0YWJsZS5nZXRSb3dSZWYoaW5kZXgpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZXRIZWFkZXJDZWxsTm9kZShpbmRleCwgaSwgdHlwZSkge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUgPyB0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zdWJzdHIoMSkgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gdGhpc1tgdGFibGUke3R5cGV9SW5jYF07XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSBvZiBmaW5kaW5nIGFuIHVubW91bnRlZCBjb21wb25lbnQgZHVlIHRvIGNhY2hlZCBkYXRhXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBjbGVhciByZWZzIG9mIHRhYmxlIHdoZW4gZGF0YVNvdXJjZSBDaGFuZ2VkXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRyeSBjYXRjaCBmb3IgdGVtcG9yYXJ5XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRET01Ob2RlKHRhYmxlLmdldEhlYWRlckNlbGxSZWYoaW5kZXgsIGkpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZXRDZWxsTm9kZShpbmRleCwgaSwgdHlwZSkge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUgPyB0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zdWJzdHIoMSkgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gdGhpc1tgdGFibGUke3R5cGV9SW5jYF07XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSBvZiBmaW5kaW5nIGFuIHVubW91bnRlZCBjb21wb25lbnQgZHVlIHRvIGNhY2hlZCBkYXRhXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBjbGVhciByZWZzIG9mIHRhYmxlIHdoZW4gZGF0YVNvdXJjZSBDaGFuZ2VkXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRyeSBjYXRjaCBmb3IgdGVtcG9yYXJ5XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRET01Ob2RlKHRhYmxlLmdldENlbGxSZWYoaW5kZXgsIGkpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycywgcHJlZmVyLWNvbnN0ICovXG4gICAgICAgICAgICBsZXQgeyBjaGlsZHJlbiwgcHJlZml4LCBjb21wb25lbnRzLCBjbGFzc05hbWUsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGxldCB7IGxvY2tMZWZ0Q2hpbGRyZW4sIGxvY2tSaWdodENoaWxkcmVuLCBjaGlsZHJlbjogbm9ybWFsaXplZENoaWxkcmVuIH0gPSB0aGlzLm5vcm1hbGl6ZUNoaWxkcmVuU3RhdGUodGhpcy5wcm9wcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbm90TmVlZEFkanVzdExvY2tMZWZ0KSB7XG4gICAgICAgICAgICAgICAgbG9ja0xlZnRDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX25vdE5lZWRBZGp1c3RMb2NrUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBsb2NrUmlnaHRDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2NrTGVmdENoaWxkcmVuID0gbG9ja0xlZnRDaGlsZHJlbjtcbiAgICAgICAgICAgIHRoaXMubG9ja1JpZ2h0Q2hpbGRyZW4gPSBsb2NrUmlnaHRDaGlsZHJlbjtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNPcmlnaW5Mb2NrKCkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzID0geyAuLi5jb21wb25lbnRzIH07XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5Cb2R5ID0gY29tcG9uZW50cy5Cb2R5IHx8IExvY2tCb2R5O1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuSGVhZGVyID0gY29tcG9uZW50cy5IZWFkZXIgfHwgTG9ja0hlYWRlcjtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLldyYXBwZXIgPSBjb21wb25lbnRzLldyYXBwZXIgfHwgTG9ja1dyYXBwZXI7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5Sb3cgPSBjb21wb25lbnRzLlJvdyB8fCBMb2NrUm93O1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4fXRhYmxlLWxvY2tgXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgW2NsYXNzTmFtZV06IGNsYXNzTmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIDxCYXNlQ29tcG9uZW50IHsuLi5vdGhlcnN9IGtleT1cImxvY2stbGVmdFwiIGNvbHVtbnM9e2xvY2tMZWZ0Q2hpbGRyZW59IGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLWxvY2stbGVmdGB9IHByZWZpeD17cHJlZml4fSBsb2NrVHlwZT1cImxlZnRcIiBjb21wb25lbnRzPXtjb21wb25lbnRzfSByZWY9XCJsb2NrTGVmdFwiIGxvYWRpbmc9e2ZhbHNlfSAvPixcbiAgICAgICAgICAgICAgICAgICAgPEJhc2VDb21wb25lbnQgey4uLm90aGVyc30ga2V5PVwibG9jay1yaWdodFwiIGNvbHVtbnM9e2xvY2tSaWdodENoaWxkcmVufSBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1sb2NrLXJpZ2h0YH0gcHJlZml4PXtwcmVmaXh9IGxvY2tUeXBlPVwicmlnaHRcIiBjb21wb25lbnRzPXtjb21wb25lbnRzfSByZWY9XCJsb2NrUmlnaHRcIiBsb2FkaW5nPXtmYWxzZX0gLz5cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHJldHVybiA8QmFzZUNvbXBvbmVudCB7Li4ub3RoZXJzfSBjb2x1bW5zPXtub3JtYWxpemVkQ2hpbGRyZW59IHByZWZpeD17cHJlZml4fSB3cmFwcGVyQ29udGVudD17Y29udGVudH0gY29tcG9uZW50cz17Y29tcG9uZW50c30gY2xhc3NOYW1lPXtjbGFzc05hbWV9IC8+O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICg8QmFzZUNvbXBvbmVudCB7Li4udGhpcy5wcm9wc30gLz4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpY3MoTG9ja1RhYmxlLCBCYXNlQ29tcG9uZW50KTtcbiAgICByZXR1cm4gTG9ja1RhYmxlO1xufVxuXG5cbmZ1bmN0aW9uIGRlZXBDb3B5KGFycikge1xuICAgIGxldCBjb3B5ID0gKGFycikgPT4ge1xuICAgICAgICByZXR1cm4gYXJyLm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW0gPSB7IC4uLml0ZW0gfTtcbiAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jaGlsZHJlbiA9IGNvcHkoaXRlbS5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3SXRlbTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gY29weShhcnIpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2xvY2suanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgRml4ZWRCb2R5IGZyb20gJy4uL2ZpeGVkL2JvZHknO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9wcmVmZXItc3RhdGVsZXNzLWZ1bmN0aW9uICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NrQm9keSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLi4uRml4ZWRCb2R5LnByb3BUeXBlc1xuICAgIH1cblxuICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIC4uLkZpeGVkQm9keS5jb250ZXh0VHlwZXMsXG4gICAgICAgIGdldExvY2tOb2RlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25Mb2NrQm9keVNjcm9sbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uTG9ja0JvZHlXaGVlbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGxvY2tUeXBlOiBQcm9wVHlwZXMub25lT2YoWydsZWZ0JywgJ3JpZ2h0J10pXG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5nZXRMb2NrTm9kZSgnYm9keScsIGZpbmRET01Ob2RlKHRoaXMpLCB0aGlzLmNvbnRleHQubG9ja1R5cGUpO1xuICAgIH1cblxuICAgIG9uQm9keVNjcm9sbCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5jb250ZXh0Lm9uTG9ja0JvZHlTY3JvbGwoKTtcbiAgICB9XG5cbiAgICBvbkJvZHlXaGVlbCA9IChlKSA9PiB7XG4gICAgICAgIHRoaXMuY29udGV4dC5vbkxvY2tCb2R5V2hlZWwoZSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gPEZpeGVkQm9keSB7Li4udGhpcy5wcm9wc30gb25TY3JvbGw9e3RoaXMub25Cb2R5U2Nyb2xsfSBvbldoZWVsPXt0aGlzLm9uQm9keVdoZWVsfSAvPjtcbiAgICB9XG59XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9sb2NrL2JvZHkuanN4IiwiaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBGaXhlZEhlYWRlciBmcm9tICcuLi9maXhlZC9oZWFkZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NrSGVhZGVyIGV4dGVuZHMgRml4ZWRIZWFkZXIge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC4uLkZpeGVkSGVhZGVyLnByb3BUeXBlc1xuICAgIH1cblxuICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIC4uLkZpeGVkSGVhZGVyLmNvbnRleHRUeXBlcyxcbiAgICAgICAgZ2V0TG9ja05vZGU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBsb2NrVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsICdyaWdodCddKVxuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCB7Z2V0Tm9kZSwgZ2V0TG9ja05vZGV9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBnZXROb2RlICYmIGdldE5vZGUoJ2hlYWRlcicsIGZpbmRET01Ob2RlKHRoaXMpLCB0aGlzLmNvbnRleHQubG9ja1R5cGUpO1xuICAgICAgICBnZXRMb2NrTm9kZSAmJiBnZXRMb2NrTm9kZSgnaGVhZGVyJywgZmluZERPTU5vZGUodGhpcyksIHRoaXMuY29udGV4dC5sb2NrVHlwZSk7XG4gICAgfVxufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvbG9jay9oZWFkZXIuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IExpc3RIZWFkZXIgZnJvbSAnLi9saXN0LWhlYWRlcic7XG5pbXBvcnQgTGlzdEZvb3RlciBmcm9tICcuL2xpc3QtZm9vdGVyJztcbmltcG9ydCBSb3dDb21wb25lbnQgZnJvbSAnLi9saXN0L3Jvdyc7XG5pbXBvcnQgQm9keUNvbXBvbmVudCBmcm9tICcuL2xpc3QvYm9keSc7XG5pbXBvcnQgSGVhZGVyQ29tcG9uZW50IGZyb20gJy4vZml4ZWQvaGVhZGVyJztcbmltcG9ydCBXcmFwcGVyQ29tcG9uZW50IGZyb20gJy4vZml4ZWQvd3JhcHBlcic7XG5pbXBvcnQgeyBzdGF0aWNzIH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdChCYXNlQ29tcG9uZW50KSB7XG4gICAgY2xhc3MgTGlzdFRhYmxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAgICAgc3RhdGljIExpc3RIZWFkZXIgPSBMaXN0SGVhZGVyO1xuICAgICAgICBzdGF0aWMgTGlzdEZvb3RlciA9IExpc3RGb290ZXI7XG4gICAgICAgIHN0YXRpYyBMaXN0Um93ID0gUm93Q29tcG9uZW50O1xuICAgICAgICBzdGF0aWMgTGlzdEJvZHkgPSBCb2R5Q29tcG9uZW50O1xuICAgICAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAgICAgLi4uQmFzZUNvbXBvbmVudC5wcm9wVHlwZXNcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAgICAgLi4uQmFzZUNvbXBvbmVudC5kZWZhdWx0UHJvcHNcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgICAgIGxpc3RIZWFkZXI6IFByb3BUeXBlcy5hbnksXG4gICAgICAgICAgICBsaXN0Rm9vdGVyOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICAgICAgcm93U2VsZWN0aW9uOiBQcm9wVHlwZXMub2JqZWN0XG4gICAgICAgIH1cblxuICAgICAgICBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxpc3RIZWFkZXI6IHRoaXMubGlzdEhlYWRlcixcbiAgICAgICAgICAgICAgICBsaXN0Rm9vdGVyOiB0aGlzLmxpc3RGb290ZXIsXG4gICAgICAgICAgICAgICAgcm93U2VsZWN0aW9uOiB0aGlzLnJvd1NlbGVjdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vcm1hbGl6ZURhdGFTb3VyY2UoZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICAgICAgICBjb25zdCBsb29wID0gZnVuY3Rpb24gKGRhdGFTb3VyY2UsIGxldmVsKSB7XG4gICAgICAgICAgICAgICAgZGF0YVNvdXJjZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLl9fbGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb29wKGl0ZW0uY2hpbGRyZW4sIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsb29wKGRhdGFTb3VyY2UsIDApO1xuICAgICAgICAgICAgdGhpcy5kcyA9IHJldDtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItY29uc3QgKi9cbiAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudHMsIGNoaWxkcmVuLCBjbGFzc05hbWUsIHByZWZpeCwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgbGV0IGlzTGlzdCA9IGZhbHNlLCByZXQgPSBbXTtcbiAgICAgICAgICAgIENoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZS5fdHlwZU1hcmsgPT09ICdsaXN0SGVhZGVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdEhlYWRlciA9IGNoaWxkLnByb3BzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTGlzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLnR5cGUuX3R5cGVNYXJrID09PSAnbGlzdEZvb3RlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RGb290ZXIgPSBjaGlsZC5wcm9wcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJvd1NlbGVjdGlvbiA9IHRoaXMucHJvcHMucm93U2VsZWN0aW9uO1xuICAgICAgICAgICAgaWYgKGlzTGlzdCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMgPSB7IC4uLmNvbXBvbmVudHMgfTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLlJvdyA9IGNvbXBvbmVudHMuUm93IHx8IFJvd0NvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLkJvZHkgPSBjb21wb25lbnRzLkJvZHkgfHwgQm9keUNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLkhlYWRlciA9IGNvbXBvbmVudHMuSGVhZGVyIHx8IEhlYWRlckNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLldyYXBwZXIgPSBjb21wb25lbnRzLldyYXBwZXIgfHwgV3JhcHBlckNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgW2Ake3ByZWZpeH10YWJsZS1ncm91cGBdOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBbY2xhc3NOYW1lXTogY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDxCYXNlQ29tcG9uZW50IHsuLi5vdGhlcnN9IGNvbXBvbmVudHM9e2NvbXBvbmVudHN9IGNoaWxkcmVuPXtyZXR9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBwcmVmaXg9e3ByZWZpeH0vPik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljcyhMaXN0VGFibGUsIEJhc2VDb21wb25lbnQpO1xuICAgIHJldHVybiBMaXN0VGFibGU7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvbGlzdC5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgbG9nIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgUm93IGZyb20gJy4uL2Jhc2Uvcm93JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JvdXBMaXN0Um93IGV4dGVuZHMgUm93IHtcblxuICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIGxpc3RIZWFkZXI6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIGxpc3RGb290ZXI6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIHJvd1NlbGVjdGlvbjogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgbm90UmVuZGVyQ2VsbEluZGV4OiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIGxvY2tUeXBlOiBQcm9wVHlwZXMub25lT2YoWydsZWZ0JywgJ3JpZ2h0J10pXG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyovXG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBjbGFzc05hbWUsIG9uQ2xpY2ssIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlLCBjb2x1bW5zLCBDZWxsLCByb3dJbmRleCwgcmVjb3JkLCBjaGlsZHJlbiwgcHJpbWFyeUtleSwgY29sR3JvdXAsIGNlbGxSZWYsIGdldENlbGxQcm9wcywgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBjbHMgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9dGFibGUtcm93YF06IHRydWUsXG4gICAgICAgICAgICBbY2xhc3NOYW1lXTogY2xhc3NOYW1lXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKDx0YWJsZSBjbGFzc05hbWU9e2Nsc30gcm9sZT1cInJvd1wiIHsuLi5vdGhlcnN9XG4gICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2t9IG9uTW91c2VFbnRlcj17dGhpcy5vbk1vdXNlRW50ZXJ9IG9uTW91c2VMZWF2ZT17dGhpcy5vbk1vdXNlTGVhdmV9PlxuICAgICAgICAgICAge2NvbEdyb3VwfVxuICAgICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgICAgIHt0aGlzLnJlbmRlckNvbnRlbnQoJ2hlYWRlcicpfVxuICAgICAgICAgICAgICAgIHt0aGlzLnJlbmRlckNoaWxkcmVuKCl9XG4gICAgICAgICAgICAgICAge3RoaXMucmVuZGVyQ29udGVudCgnZm9vdGVyJyl9XG4gICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICA8L3RhYmxlPik7XG4gICAgfVxuXG4gICAgaXNDaGlsZHJlblNlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5saXN0SGVhZGVyICYmIHRoaXMuY29udGV4dC5saXN0SGVhZGVyLmhhc0NoaWxkcmVuU2VsZWN0aW9uO1xuICAgIH1cblxuICAgIGlzU2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0Lmxpc3RIZWFkZXIgJiYgdGhpcy5jb250ZXh0Lmxpc3RIZWFkZXIuaGFzU2VsZWN0aW9uO1xuICAgIH1cblxuICAgIHJlbmRlckNoaWxkcmVuKCkge1xuICAgICAgICBjb25zdCB7IHJlY29yZCwgcHJpbWFyeUtleSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcmVjb3JkO1xuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbi5tYXAoKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxzID0gdGhpcy5yZW5kZXJDZWxscyhjaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDaGlsZHJlblNlbGVjdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGRbcHJpbWFyeUtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy53YXJuaW5nKCdyZWNvcmQuY2hpbGRyZW4gc2hvdWxkIGNvbnRhaW5zIHByaW1hcnlLZXkgd2hlbiBjaGlsZHJlblNlbGVjdGlvbiBpcyB0cnVlLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA8dHIga2V5PXtjaGlsZFtwcmltYXJ5S2V5XX0+e2NlbGxzfTwvdHI+O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnJvd1NlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjZWxscy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjZWxsc1swXSA9IFJlYWN0LmNsb25lRWxlbWVudChjZWxsc1swXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sU3BhbjogMixcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNlbGxzWzBdLnByb3BzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gPHRyIGtleT17aW5kZXh9PntjZWxsc308L3RyPjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZW5kZXJDb250ZW50KHR5cGUpIHtcbiAgICAgICAgY29uc3QgeyBjb2x1bW5zLCBwcmVmaXgsIHJlY29yZCwgcm93SW5kZXggfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGNhbWVUeXBlID0gdHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR5cGUuc3Vic3RyKDEpO1xuICAgICAgICBjb25zdCBsaXN0ID0gdGhpcy5jb250ZXh0W2BsaXN0JHtjYW1lVHlwZX1gXTtcbiAgICAgICAgbGV0IGxpc3ROb2RlO1xuICAgICAgICBpZiAobGlzdCkge1xuICAgICAgICAgICAgaWYgKFJlYWN0LmlzVmFsaWRFbGVtZW50KGxpc3QuY2VsbCkpIHtcbiAgICAgICAgICAgICAgICBsaXN0Tm9kZSA9IFJlYWN0LmNsb25lRWxlbWVudChsaXN0LmNlbGwsIHsgcmVjb3JkLCBpbmRleDogcm93SW5kZXggfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0LmNlbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsaXN0Tm9kZSA9IGxpc3QuY2VsbChyZWNvcmQsIHJvd0luZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaXN0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGxldCBjZWxscyA9IHRoaXMucmVuZGVyQ2VsbHMocmVjb3JkKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2hlYWRlcicgJiYgdGhpcy5jb250ZXh0LnJvd1NlbGVjdGlvbiAmJiB0aGlzLmlzU2VsZWN0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbHMgPSBjZWxscy5zbGljZSgwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY2VsbHMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjb2xTcGFuPXtjb2x1bW5zLmxlbmd0aCAtIDF9IGtleT1cImxpc3ROb2RlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1jZWxsLXdyYXBwZXJgfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2xpc3ROb2RlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdE5vZGUgPSAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHIgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtZ3JvdXAtJHt0eXBlfWB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjZWxsc31cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdE5vZGUgPSAoPHRyIGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLWdyb3VwLSR7dHlwZX1gfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjb2xTcGFuPXtjb2x1bW5zLmxlbmd0aH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1jZWxsLXdyYXBwZXJgfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2xpc3ROb2RlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdE5vZGU7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2xpc3Qvcm93LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgQm9keUNvbXBvbmVudCBmcm9tICcuLi9iYXNlL2JvZHknO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMaXN0Qm9keShwcm9wcykge1xuICAgIHJldHVybiA8Qm9keUNvbXBvbmVudCBjb21wb25lbnQ9XCJkaXZcIiB7Li4ucHJvcHN9Lz47XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvbGlzdC9ib2R5LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEhlYWRlciBmcm9tICcuL2ZpeGVkL2hlYWRlcic7XG5pbXBvcnQgU3RpY2t5SGVhZGVyIGZyb20gJy4vc3RpY2t5L2hlYWRlcic7XG5pbXBvcnQgeyBzdGF0aWNzIH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3RpY2t5KEJhc2VDb21wb25lbnQpIHtcbiAgICAvKiogVGFibGUgKi9cbiAgICBjbGFzcyBTdGlja3lUYWJsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgICAgIHN0YXRpYyBTdGlja3lIZWFkZXIgPSBTdGlja3lIZWFkZXI7XG4gICAgICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOihqOWktOaYr+WQpuaYr3N0aWNreVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzdGlja3lIZWFkZXI6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDot53nprvnqpflj6Ppobbpg6jovr7liLDmjIflrprlgY/np7vph4/lkI7op6blj5FcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb2Zmc2V0VG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBhZmZpeOe7hOS7tueahOeahOWxnuaAp1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZmZpeFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAgICAgY29tcG9uZW50czogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgICAgIC4uLkJhc2VDb21wb25lbnQucHJvcFR5cGVzXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAgICAgY29tcG9uZW50czoge30sXG4gICAgICAgICAgICAuLi5CYXNlQ29tcG9uZW50LmRlZmF1bHRQcm9wc1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGljIGNoaWxkQ29udGV4dFR5cGVzID0ge1xuICAgICAgICAgICAgSGVhZGVyOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICAgICAgb2Zmc2V0VG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAgICAgYWZmaXhQcm9wczogUHJvcFR5cGVzLm9iamVjdFxuICAgICAgICB9XG5cbiAgICAgICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBIZWFkZXI6ICh0aGlzLnByb3BzLmNvbXBvbmVudHMuSGVhZGVyIHx8IEhlYWRlciksXG4gICAgICAgICAgICAgICAgb2Zmc2V0VG9wOiB0aGlzLnByb3BzLm9mZnNldFRvcCxcbiAgICAgICAgICAgICAgICBhZmZpeFByb3BzOiB0aGlzLnByb3BzLmFmZml4UHJvcHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgICAgICAgICAgY29uc3QgeyBzdGlja3lIZWFkZXIsIG9mZnNldFRvcCwgYWZmaXhQcm9wcywgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50cywgbWF4Qm9keUhlaWdodCwgZml4ZWRIZWFkZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAoc3RpY2t5SGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cyA9IHsuLi5jb21wb25lbnRzfTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLkhlYWRlciA9IFN0aWNreUhlYWRlcjtcbiAgICAgICAgICAgICAgICBmaXhlZEhlYWRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWF4Qm9keUhlaWdodCA9IE1hdGgubWF4KG1heEJvZHlIZWlnaHQsIDEwMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiA8QmFzZUNvbXBvbmVudCB7Li4ub3RoZXJzfSBjb21wb25lbnRzPXtjb21wb25lbnRzfSBmaXhlZEhlYWRlcj17Zml4ZWRIZWFkZXJ9IG1heEJvZHlIZWlnaHQ9e21heEJvZHlIZWlnaHR9Lz47XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljcyhTdGlja3lUYWJsZSwgQmFzZUNvbXBvbmVudCk7XG4gICAgcmV0dXJuIFN0aWNreVRhYmxlO1xufVxuXG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9zdGlja3kuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBBZmZpeCBmcm9tICcuLi8uLi9hZmZpeCc7XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3ByZWZlci1zdGF0ZWxlc3MtZnVuY3Rpb24qL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RpY2tIZWFkZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB9XG4gICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgSGVhZGVyOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBvZmZzZXRUb3A6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGFmZml4UHJvcHM6IFByb3BUeXBlcy5vYmplY3RcbiAgICB9XG5cbiAgICBnZXRBZmZpeFJlZiA9IChyZWYpID0+IHtcbiAgICAgICAgdGhpcy5wcm9wcy5hZmZpeFJlZiAmJiB0aGlzLnByb3BzLmFmZml4UmVmKHJlZik7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByZWZpeCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBIZWFkZXIsIG9mZnNldFRvcCwgYWZmaXhQcm9wcyB9ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICAgIGNvbnN0IG5ld0FmZml4UHJvcHMgPSBhZmZpeFByb3BzIHx8IHt9O1xuICAgICAgICBjb25zdCB7IGNsYXNzTmFtZSwgLi4ub3RoZXJzIH0gPSBuZXdBZmZpeFByb3BzO1xuICAgICAgICBjb25zdCBjbHMgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9dGFibGUtYWZmaXhgXTogdHJ1ZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gKDxBZmZpeCByZWY9e3RoaXMuZ2V0QWZmaXhSZWZ9IHsuLi5vdGhlcnN9IGNsYXNzTmFtZT17Y2xzfSBvZmZzZXRUb3A9e29mZnNldFRvcH0+XG4gICAgICAgICAgICA8SGVhZGVyIHsuLi50aGlzLnByb3BzfS8+XG4gICAgICAgIDwvQWZmaXg+KTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvc3RpY2t5L2hlYWRlci5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgb2JqLCBldmVudHMsIGZ1bmMgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBDb25maWdQcm92aWRlciBmcm9tICcuLi9jb25maWctcHJvdmlkZXInO1xuaW1wb3J0IHsgZ2V0U2Nyb2xsLCBnZXRSZWN0LCBnZXROb2RlSGVpZ2h0IH0gZnJvbSAnLi91dGlsJztcblxuLyoqIEFmZml4ICovXG5jbGFzcyBBZmZpeCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572uIEFmZml4IOmcgOimgeebkeWQrOa7muWKqOS6i+S7tueahOWuueWZqOWFg+e0oFxuICAgICAgICAgKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IOebruagh+WuueWZqOWFg+e0oOeahOWunuS+i1xuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbmVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOi3neemu+eql+WPo+mhtumDqOi+vuWIsOaMh+WumuWBj+enu+mHj+WQjuinpuWPkVxuICAgICAgICAgKi9cbiAgICAgICAgb2Zmc2V0VG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Led56a756qX5Y+j5bqV6YOo6L6+5Yiw5Yi25a6a5YGP56e76YeP5ZCO6Kem5Y+RXG4gICAgICAgICAqL1xuICAgICAgICBvZmZzZXRCb3R0b206IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvZPlhYPntKDnmoTmoLflvI/lj5HnlJ/lm7rpkonmoLflvI/lj5jljJbml7bop6blj5HnmoTlm57osIPlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSDlhYPntKDmmK/lkKbooqvlm7rpkolcbiAgICAgICAgICovXG4gICAgICAgIG9uQWZmaXg6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5ZCv55So57ud5a+55biD5bGA5a6e546wIGFmZml4XG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0g5piv5ZCm5ZCv55So57ud5a+55biD5bGAXG4gICAgICAgICAqL1xuICAgICAgICB1c2VBYnNvbHV0ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55LFxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBwcmVmaXg6ICduZXh0LScsXG4gICAgICAgIGNvbnRhaW5lcjogKCkgPT4gd2luZG93LFxuICAgICAgICBvbkFmZml4OiBmdW5jLm5vb3AsXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHN0eWxlOiBudWxsLFxuICAgICAgICAgICAgY29udGFpbmVyU3R5bGU6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWZmaXhNb2RlID0gdGhpcy5fZ2V0QWZmaXhNb2RlKHByb3BzKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU5vZGVQb3NpdGlvbigpO1xuICAgICAgICAvLyB3YWl0IGZvciBwYXJlbnQgcmVuZGVyZWRcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zZXRFdmVudEhhbmRsZXJGb3JDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRIYW5kbGVyRm9yQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgX3NldEV2ZW50SGFuZGxlckZvckNvbnRhaW5lcihnZXRDb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRzLm9uKGNvbnRhaW5lciwgJ3Njcm9sbCcsIHRoaXMuX3VwZGF0ZU5vZGVQb3NpdGlvbiwgZmFsc2UpO1xuICAgICAgICBldmVudHMub24oY29udGFpbmVyLCAncmVzaXplJywgdGhpcy5fdXBkYXRlTm9kZVBvc2l0aW9uLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgX3JlbW92ZUV2ZW50SGFuZGxlckZvckNvbnRhaW5lcihnZXRDb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgIGV2ZW50cy5vZmYoY29udGFpbmVyLCAnc2Nyb2xsJywgdGhpcy5fdXBkYXRlTm9kZVBvc2l0aW9uKTtcbiAgICAgICAgICAgIGV2ZW50cy5vZmYoY29udGFpbmVyLCAncmVzaXplJywgdGhpcy5fdXBkYXRlTm9kZVBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZVBvc2l0aW9uID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl91cGRhdGVOb2RlUG9zaXRpb24oKTtcbiAgICB9XG5cbiAgICBfdXBkYXRlTm9kZVBvc2l0aW9uID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGNvbnRhaW5lciwgdXNlQWJzb2x1dGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGFmZml4Q29udGFpbmVyID0gY29udGFpbmVyKCk7XG5cbiAgICAgICAgaWYgKCFhZmZpeENvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNjcm9sbFRvcCA9IGdldFNjcm9sbChhZmZpeENvbnRhaW5lciwgdHJ1ZSk7ICAgIC8vIOWuueWZqOWcqOWeguebtOS9jee9ruS4iueahOa7muWKqCBvZmZzZXRcbiAgICAgICAgY29uc3QgYWZmaXhPZmZzZXQgPSB0aGlzLl9nZXRPZmZzZXQodGhpcy5hZmZpeE5vZGUsIGFmZml4Q29udGFpbmVyKTsgLy8g55uu5qCH6IqC54K55b2T5YmN55u45a+55LqO5a655Zmo55qEIG9mZnNldFxuICAgICAgICBjb25zdCBjb250YWluZXJIZWlnaHQgPSBnZXROb2RlSGVpZ2h0KGFmZml4Q29udGFpbmVyKTsgICAgICAgICAvLyDlrrnlmajnmoTpq5jluqZcbiAgICAgICAgY29uc3QgYWZmaXhIZWlnaHQgPSB0aGlzLmFmZml4Tm9kZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclJlY3QgPSBnZXRSZWN0KGFmZml4Q29udGFpbmVyKTtcblxuICAgICAgICBjb25zdCBhZmZpeENoaWxkSGVpZ2h0ID0gdGhpcy5hZmZpeENoaWxkTm9kZS5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgY29uc3QgYWZmaXhNb2RlID0gdGhpcy5hZmZpeE1vZGU7XG4gICAgICAgIGNvbnN0IGFmZml4U3R5bGUgPSB7XG4gICAgICAgICAgICB3aWR0aDogYWZmaXhPZmZzZXQud2lkdGgsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlID0ge1xuICAgICAgICAgICAgd2lkdGg6IGFmZml4T2Zmc2V0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBhZmZpeENoaWxkSGVpZ2h0LFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChhZmZpeE1vZGUudG9wICYmIGNvbnRhaW5lclNjcm9sbFRvcCA+IGFmZml4T2Zmc2V0LnRvcCAtIGFmZml4TW9kZS5vZmZzZXQpIHtcbiAgICAgICAgICAgIC8vIGFmZml4IHRvcFxuICAgICAgICAgICAgaWYgKHVzZUFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgYWZmaXhTdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICAgICAgYWZmaXhTdHlsZS50b3AgPSBjb250YWluZXJTY3JvbGxUb3AgLSAoYWZmaXhPZmZzZXQudG9wIC0gYWZmaXhNb2RlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyU3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZmZpeFN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgICAgICAgICAgICBhZmZpeFN0eWxlLnRvcCA9IGFmZml4TW9kZS5vZmZzZXQgKyBjb250YWluZXJSZWN0LnRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldEFmZml4U3R5bGUoYWZmaXhTdHlsZSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLl9zZXRDb250YWluZXJTdHlsZShjb250YWluZXJTdHlsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYWZmaXhNb2RlLmJvdHRvbSAmJiBjb250YWluZXJTY3JvbGxUb3AgPCBhZmZpeE9mZnNldC50b3AgKyBhZmZpeEhlaWdodCArIGFmZml4TW9kZS5vZmZzZXQgLSBjb250YWluZXJIZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIGFmZml4IGJvdHRvbVxuICAgICAgICAgICAgYWZmaXhTdHlsZS5oZWlnaHQgPSBhZmZpeEhlaWdodDtcbiAgICAgICAgICAgIGlmICh1c2VBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIGFmZml4U3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgICAgIGFmZml4U3R5bGUudG9wID0gY29udGFpbmVyU2Nyb2xsVG9wIC0gKGFmZml4T2Zmc2V0LnRvcCArIGFmZml4SGVpZ2h0ICsgYWZmaXhNb2RlLm9mZnNldCAtIGNvbnRhaW5lckhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyU3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZmZpeFN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgICAgICAgICAgICBhZmZpeFN0eWxlLmJvdHRvbSA9IGFmZml4TW9kZS5vZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXRBZmZpeFN0eWxlKGFmZml4U3R5bGUsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5fc2V0Q29udGFpbmVyU3R5bGUoY29udGFpbmVyU3R5bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0QWZmaXhTdHlsZShudWxsKTtcbiAgICAgICAgICAgIHRoaXMuX3NldENvbnRhaW5lclN0eWxlKG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIF9nZXRBZmZpeE1vZGUoKSB7XG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0VG9wLCBvZmZzZXRCb3R0b20gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGFmZml4TW9kZSA9IHtcbiAgICAgICAgICAgIHRvcDogZmFsc2UsXG4gICAgICAgICAgICBib3R0b206IGZhbHNlLFxuICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0VG9wICE9PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2Zmc2V0Qm90dG9tICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gc2V0IGRlZmF1bHRcbiAgICAgICAgICAgIGFmZml4TW9kZS50b3AgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvZmZzZXRUb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBhZmZpeE1vZGUudG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIGFmZml4TW9kZS5vZmZzZXQgPSBvZmZzZXRUb3A7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9mZnNldEJvdHRvbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGFmZml4TW9kZS5ib3R0b20gPSB0cnVlO1xuICAgICAgICAgICAgYWZmaXhNb2RlLm9mZnNldCA9IG9mZnNldEJvdHRvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhZmZpeE1vZGU7XG4gICAgfVxuXG4gICAgX3NldEFmZml4U3R5bGUoYWZmaXhTdHlsZSwgYWZmaXhlZCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChvYmouc2hhbGxvd0VxdWFsKGFmZml4U3R5bGUsIHRoaXMuc3RhdGUuc3R5bGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHN0eWxlOiBhZmZpeFN0eWxlLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB7IG9uQWZmaXggfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKGFmZml4ZWQpIHtcbiAgICAgICAgICAgIG9uQWZmaXgodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWFmZml4U3R5bGUpIHtcbiAgICAgICAgICAgIG9uQWZmaXgoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NldENvbnRhaW5lclN0eWxlKGNvbnRhaW5lclN0eWxlKSB7XG4gICAgICAgIGlmIChvYmouc2hhbGxvd0VxdWFsKGNvbnRhaW5lclN0eWxlLCB0aGlzLnN0YXRlLmNvbnRhaW5lclN0eWxlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBjb250YWluZXJTdHlsZSB9KTtcbiAgICB9XG5cbiAgICBfZ2V0T2Zmc2V0KGFmZml4Tm9kZSwgYWZmaXhDb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgYWZmaXhSZWN0ID0gYWZmaXhOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAgLy8gYWZmaXgg5YWD57SgIOebuOWvuea1j+iniOWZqOeql+WPo+eahOS9jee9rlxuICAgICAgICBjb25zdCBjb250YWluZXJSZWN0ID0gZ2V0UmVjdChhZmZpeENvbnRhaW5lcik7IC8vIGFmZml4IOWuueWZqCDnm7jlr7nmtY/op4jlmajnqpflj6PnmoTkvY3nva5cbiAgICAgICAgY29uc3QgY29udGFpbmVyU2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGFmZml4Q29udGFpbmVyLCB0cnVlKTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyU2Nyb2xsTGVmdCA9IGdldFNjcm9sbChhZmZpeENvbnRhaW5lciwgZmFsc2UpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IGFmZml4UmVjdC50b3AgLSBjb250YWluZXJSZWN0LnRvcCArIGNvbnRhaW5lclNjcm9sbFRvcCxcbiAgICAgICAgICAgIGxlZnQ6IGFmZml4UmVjdC5sZWZ0IC0gY29udGFpbmVyUmVjdC5sZWZ0ICsgY29udGFpbmVyU2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHdpZHRoOiBhZmZpeFJlY3Qud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGFmZml4UmVjdC5oZWlnaHQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgX2FmZml4Tm9kZVJlZkhhbmRsZXIgPSAocmVmKSA9PiB7XG4gICAgICAgIHRoaXMuYWZmaXhOb2RlID0gZmluZERPTU5vZGUocmVmKTtcbiAgICB9XG5cbiAgICBfYWZmaXhDaGlsZE5vZGVSZWZIYW5kbGVyID0gKHJlZikgPT4ge1xuICAgICAgICB0aGlzLmFmZml4Q2hpbGROb2RlID0gZmluZERPTU5vZGUocmVmKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBjbGFzc05hbWUsIHN0eWxlLCBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fWFmZml4YF06IHN0YXRlLnN0eWxlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1hZmZpeC10b3BgXTogIXN0YXRlLnN0eWxlICYmIHRoaXMuYWZmaXhNb2RlLnRvcCxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9YWZmaXgtYm90dG9tYF06ICFzdGF0ZS5zdHlsZSAmJiB0aGlzLmFmZml4TW9kZS5ib3R0b20sXG4gICAgICAgICAgICBbY2xhc3NOYW1lXTogY2xhc3NOYW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY29tYmluZWRTdHlsZSA9IHsgLi4uc3RhdGUuY29udGFpbmVyU3R5bGUsIC4uLnN0eWxlIH07XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgcmVmPXt0aGlzLl9hZmZpeE5vZGVSZWZIYW5kbGVyfSBzdHlsZT17Y29tYmluZWRTdHlsZX0+XG4gICAgICAgICAgICAgICAgPGRpdiByZWY9e3RoaXMuX2FmZml4Q2hpbGROb2RlUmVmSGFuZGxlcn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSBzdHlsZT17c3RhdGUuc3R5bGV9PlxuICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZ1Byb3ZpZGVyLmNvbmZpZyhBZmZpeCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYWZmaXgvaW5kZXguanN4IiwiZXhwb3J0IGZ1bmN0aW9uIGdldFNjcm9sbChub2RlLCBpc1ZlcnRpY2FsKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCB3aW5kb3dQcm9wID0gaXNWZXJ0aWNhbCA/ICdwYWdlWU9mZnNldCcgOiAncGFnZVhPZmZzZXQnO1xuICAgIGNvbnN0IGVsZW1lbnRQcm9wID0gaXNWZXJ0aWNhbCA/ICdzY3JvbGxUb3AnIDogJ3Njcm9sbExlZnQnO1xuICAgIHJldHVybiBub2RlID09PSB3aW5kb3cgPyBub2RlW3dpbmRvd1Byb3BdIDogbm9kZVtlbGVtZW50UHJvcF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWN0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAhPT0gd2luZG93ID8gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHsgdG9wOiAwLCBsZWZ0OiAwLCBib3R0b206IDAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVIZWlnaHQobm9kZSkge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IHdpbmRvdykge1xuICAgICAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS5jbGllbnRIZWlnaHQ7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYWZmaXgvdXRpbC5qcyIsImltcG9ydCAnLi4vaWNvbi9zdHlsZS5qcyc7XG5pbXBvcnQgJy4uL2NoZWNrYm94L3N0eWxlLmpzJztcbmltcG9ydCAnLi4vcmFkaW8vc3R5bGUuanMnO1xuaW1wb3J0ICcuLi9tZW51L3N0eWxlLmpzJztcbmltcG9ydCAnLi4vYnV0dG9uL3N0eWxlLmpzJztcbmltcG9ydCAnLi4vZHJvcGRvd24vc3R5bGUuanMnO1xuaW1wb3J0ICcuLi9sb2FkaW5nL3N0eWxlLmpzJztcbmltcG9ydCAnLi9tYWluLnNjc3MnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL3N0eWxlLmpzIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAwLjE4LjJAc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pY29uL21haW4uc2NzcyIsIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvdXJscy5qcyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYW5pbWF0ZS9tYWluLnNjc3MiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDAuMTguMkBzdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NoZWNrYm94L21haW4uc2NzcyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmFkaW8vbWFpbi5zY3NzIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAwLjE4LjJAc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tZW51L21haW4uc2NzcyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYnV0dG9uL21haW4uc2NzcyIsImltcG9ydCAnLi4vb3ZlcmxheS9zdHlsZS5qcyc7XG5pbXBvcnQgJy4vbWFpbi5zY3NzJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9kcm9wZG93bi9zdHlsZS5qcyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvb3ZlcmxheS9tYWluLnNjc3MiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDAuMTguMkBzdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Ryb3Bkb3duL21haW4uc2NzcyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbG9hZGluZy9tYWluLnNjc3MiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDAuMTguMkBzdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL21haW4uc2NzcyIsImltcG9ydCBDb25maWdQcm92aWRlciBmcm9tICcuLi9jb25maWctcHJvdmlkZXInO1xuaW1wb3J0IElucHV0IGZyb20gJy4vaW5wdXQnO1xuaW1wb3J0IFRleHRBcmVhIGZyb20gJy4vdGV4dGFyZWEnO1xuaW1wb3J0IEdyb3VwIGZyb20gJy4vZ3JvdXAnO1xuXG5JbnB1dC5UZXh0QXJlYSA9IENvbmZpZ1Byb3ZpZGVyLmNvbmZpZyhUZXh0QXJlYSwge2V4cG9ydE5hbWVzOiBbJ2dldElucHV0Tm9kZScsICdmb2N1cyddfSk7XG5JbnB1dC5Hcm91cCA9IEdyb3VwO1xuXG4vLyDnlKjmnaXoh6rliqjnlJ/miJDmlofmoaPnmoTlt6XlhbflupXlsYLkvp3otZbnmoQgcmVhY3QtZG9jZ2Vu77yM5peg5rOV6Kej5p6Q55Sf5oiQIEhPQyDnmoTmlrnms5XkuK3lrZjlnKjnrKzkuozkuKrlj4LmlbDnmoTmg4XlhrVcbi8vIOaJgOS7peS4jeiDveWcqCBpbnB1dC5qc3jvvI90ZXh0YXJlYS5qc3gg5Lit55Sf5oiQIEhPQ1xuZXhwb3J0IGRlZmF1bHQgQ29uZmlnUHJvdmlkZXIuY29uZmlnKElucHV0LCB7XG4gICAgZXhwb3J0TmFtZXM6IFsnZ2V0SW5wdXROb2RlJywgJ2ZvY3VzJ10sXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbnB1dC9pbmRleC5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IEFuaW1hdGUgZnJvbSAnLi4vYW5pbWF0ZSc7XG5pbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcbmltcG9ydCB7IG9iaiwgZnVuYywgc3VwcG9ydCwgS0VZQ09ERSB9IGZyb20gJy4uL3V0aWwnO1xuXG5jb25zdCB7IG5vb3AsIGJpbmRDdHggfSA9IGZ1bmM7XG5cbi8qKlxuICogVGFnXG4gKi9cbmNsYXNzIFRhZyBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOagh+etvuexu+WQjeWJjee8gCzmj5Dkvpvnu5nkuozmrKHlvIDlj5HogIXnlKhcbiAgICAgICAgICogQGRlZmF1bHQgbmV4dC1cbiAgICAgICAgICovXG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOagh+etvueahOexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnbm9ybWFsJywgJ3ByaW1hcnknXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmoIfnrb7nmoTlsLrlr7jvvIhsYXJnZSDlsLrlr7jkuLrlhbzlrrnooajljZXlnLrmma8gbGFyZ2UgPSBtZWRpdW3vvIlcbiAgICAgICAgICovXG4gICAgICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3NtYWxsJywgJ21lZGl1bScsICdsYXJnZSddKSxcblxuICAgICAgICBjbG9zYWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblvIDlkK/liqjmlYhcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGNsb3NlQXJlYTogUHJvcFR5cGVzLm9uZU9mKFsndGFnJywgJ3RhaWwnXSksXG4gICAgICAgIG9uQ2xvc2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBhZnRlckNsb3NlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOagh+etvuWHuueOsOWKqOeUu+e7k+adn+WQjuaJp+ihjOeahOWbnuiwg1xuICAgICAgICAgKi9cbiAgICAgICAgYWZ0ZXJBcHBlYXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeCueWHu+Wbnuiwg1xuICAgICAgICAgKi9cbiAgICAgICAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIF9zaGFwZTogUHJvcFR5cGVzLm9uZU9mKFsnZGVmYXVsdCcsICdjbG9zYWJsZScsICdjaGVja2FibGUnXSksXG4gICAgICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgcnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgICAgICB0eXBlOiAnbm9ybWFsJyxcbiAgICAgICAgc2l6ZTogJ21lZGl1bScsXG4gICAgICAgIGNsb3NlQXJlYTogJ3RhaWwnLFxuICAgICAgICBhbmltYXRpb246IGZhbHNlLFxuICAgICAgICBvbkNsb3NlOiBub29wLFxuICAgICAgICBhZnRlckNsb3NlOiBub29wLFxuICAgICAgICBhZnRlckFwcGVhcjogbm9vcCxcbiAgICAgICAgb25DbGljazogbm9vcCxcbiAgICAgICAgX3NoYXBlOiAnZGVmYXVsdCcsXG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgcnRsOiBmYWxzZSxcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgYmluZEN0eCh0aGlzLCBbXG4gICAgICAgICAgICAnaGFuZGxlQm9keUNsaWNrJyxcbiAgICAgICAgICAgICdoYW5kbGVUYWlsQ2xpY2snLFxuICAgICAgICAgICAgJ2hhbmRsZUFuaW1hdGlvbkluaXQnLFxuICAgICAgICAgICAgJ2hhbmRsZUFuaW1hdGlvbkVuZCcsXG4gICAgICAgICAgICAncmVuZGVyVGFpbE5vZGUnXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLl9fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBoYW5kbGVDbG9zZShmcm9tKSB7XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uLCBvbkNsb3NlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBoYXNBbmltYXRpb24gPSBzdXBwb3J0LmFuaW1hdGlvbiAmJiBhbmltYXRpb247XG5cbiAgICAgICAgLy8g5YWI5omn6KGM5Zue6LCDXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG9uQ2xvc2UoZnJvbSwgdGhpcy50YWdOb2RlKTtcblxuICAgICAgICAvLyDlpoLmnpzlm57osIPlh73mlbDov5Tlm54gZmFsc2XvvIzliJnpmLvmraLlhbPpl63ooYzkuLpcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UgJiYgIXRoaXMuX19kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzmsqHmnInliqjnlLvvvIzliJnnm7TmjqXmiafooYwgYWZ0ZXJDbG9zZVxuICAgICAgICAgICAgICAgICAgICAhaGFzQW5pbWF0aW9uICYmIHRoaXMucHJvcHMuYWZ0ZXJDbG9zZSh0aGlzLnRhZ05vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDmoIfnrb7kvZPngrnlh7tcbiAgICBoYW5kbGVCb2R5Q2xpY2soZSkge1xuICAgICAgICBjb25zdCB7IGNsb3NhYmxlLCBjbG9zZUFyZWEsIG9uQ2xpY2sgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKGNsb3NhYmxlICYmIGNsb3NlQXJlYSA9PT0gJ3RhZycpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xvc2UoJ3RhZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gb25DbGljayhlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uS2V5RG93biA9IGUgPT4ge1xuICAgICAgICAvLyDpkojlr7nml6Dpmpznoo3ljJbopoHmsYIg5re75Yqg6ZSu55uYU1BBQ0Xkuovku7ZcbiAgICAgICAgY29uc3QgeyBjbG9zYWJsZSwgY2xvc2VBcmVhLCBvbkNsaWNrLCBkaXNhYmxlZCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKGUua2V5Q29kZSAhPT0gS0VZQ09ERS5TUEFDRSB8fCBkaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGlmIChjbG9zYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDbG9zZShjbG9zZUFyZWEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHlwZW9mIG9uQ2xpY2sgPT09ICdmdW5jdGlvbicgJiYgb25DbGljayhlKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIGhhbmRsZVRhaWxDbGljayhlKSB7XG4gICAgICAgIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5oYW5kbGVDbG9zZSgndGFpbCcpO1xuICAgIH1cblxuICAgIGhhbmRsZUFuaW1hdGlvbkluaXQobm9kZSkge1xuICAgICAgICB0aGlzLnByb3BzLmFmdGVyQXBwZWFyKG5vZGUpO1xuICAgIH1cblxuICAgIGhhbmRsZUFuaW1hdGlvbkVuZChub2RlKSB7XG4gICAgICAgIHRoaXMucHJvcHMuYWZ0ZXJDbG9zZShub2RlKTtcbiAgICB9XG5cbiAgICByZW5kZXJBbmltYXRlZFRhZyhjaGlsZHJlbiwgYW5pbWF0aW9uTmFtZSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEFuaW1hdGVcbiAgICAgICAgICAgICAgICBhbmltYXRpb249e2FuaW1hdGlvbk5hbWV9XG4gICAgICAgICAgICAgICAgYWZ0ZXJBcHBlYXI9e3RoaXMuaGFuZGxlQW5pbWF0aW9uSW5pdH1cbiAgICAgICAgICAgICAgICBhZnRlckxlYXZlPXt0aGlzLmhhbmRsZUFuaW1hdGlvbkVuZH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICA8L0FuaW1hdGU+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyVGFpbE5vZGUoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBjbG9zYWJsZSB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBpZiAoIWNsb3NhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7cHJlZml4fXRhZy1jbG9zZS1idG5gfVxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlVGFpbENsaWNrfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9XCJjbG9zZVwiIC8+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICBfc2hhcGUsXG4gICAgICAgICAgICBjbG9zYWJsZSxcbiAgICAgICAgICAgIGNsb3NlQXJlYSxcbiAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICBydGxcbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgdmlzaWJsZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gb2JqLnBpY2tPdGhlcnMoVGFnLnByb3BUeXBlcywgdGhpcy5wcm9wcyk7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gY2xvc2FibGUgPyAnY2xvc2FibGUnIDogX3NoYXBlO1xuICAgICAgICBjb25zdCBib2R5Q2xhenogPSBjbGFzc05hbWVzKFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIGAke3ByZWZpeH10YWdgLFxuICAgICAgICAgICAgICAgIGAke3ByZWZpeH10YWctJHtzaGFwZX1gLFxuICAgICAgICAgICAgICAgIGAke3ByZWZpeH10YWctbGV2ZWwtJHt0eXBlfWAsXG4gICAgICAgICAgICAgICAgYCR7cHJlZml4fXRhZy0ke3NpemV9YFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4fXRhZy1jbG9zYWJsZWBdOiBjbG9zYWJsZSxcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4fXRhZy1ib2R5LXBvaW50ZXJgXTogY2xvc2FibGUgJiYgY2xvc2VBcmVhID09PSAndGFnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsYXNzTmFtZVxuICAgICAgICApO1xuICAgICAgICAvLyBjbG9zZSBidG5cbiAgICAgICAgY29uc3QgdGFpbE5vZGUgPSB0aGlzLnJlbmRlclRhaWxOb2RlKCk7XG4gICAgICAgIC8vIHRhZyBub2RlXG4gICAgICAgIGNvbnN0IHRhZ05vZGUgPSAhdmlzaWJsZSA/IG51bGwgOiAoXG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtib2R5Q2xhenp9XG4gICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVCb2R5Q2xpY2t9XG4gICAgICAgICAgICAgICAgb25LZXlEb3duPXt0aGlzLm9uS2V5RG93bn1cbiAgICAgICAgICAgICAgICB0YWJJbmRleD1cIjBcIlxuICAgICAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgIGFyaWEtZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICAgICAgICBkaXI9e3J0bCA/ICdydGwnIDogdW5kZWZpbmVkfVxuICAgICAgICAgICAgICAgIHJlZj17biA9PiAodGhpcy50YWdOb2RlID0gbil9XG4gICAgICAgICAgICAgICAgey4uLm90aGVyc31cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWctYm9keWB9PntjaGlsZHJlbn08L3NwYW4+XG4gICAgICAgICAgICAgICAge3RhaWxOb2RlfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGFuaW1hdGlvbiAmJiBzdXBwb3J0LmFuaW1hdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQW5pbWF0ZWRUYWcodGFnTm9kZSwgYCR7cHJlZml4fXRhZy16b29tYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDmnKrlvIDlkK/miJbkuI3mlK/mjIHliqjnlLtcbiAgICAgICAgcmV0dXJuIHRhZ05vZGU7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUYWc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFnL3RhZy5qc3giLCJpbXBvcnQgeyBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiB1dGlsIG1vZHVsZVxuICovXG5cblxuLyoqXG4gKiDmmK/lkKbmmK/ljZXpgInmqKHlvI9cbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlXG4gKiBAcmV0dXJuIHtib29sZWFufSBpcyBzaW5nbGUgbW9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTaW5nbGUobW9kZSkge1xuICAgIHJldHVybiAhbW9kZSB8fCBtb2RlID09PSAnc2luZ2xlJyB8fCBtb2RlID09PSAnY29tYm9ib3gnO1xufVxuXG4vKipcbiAqIOWcqCBTZWxlY3Qg5Lit77yM6K6k5Li6IG51bGwg5ZKMIHVuZGVmaW5lZCDpg73mmK/nqbrlgLxcbiAqIEBwYXJhbSB7Kn0gbiBhbnkgb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsKG4pIHtcbiAgICByZXR1cm4gbiA9PT0gbnVsbCB8fCBuID09PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICog5bCG5a2X56ym5Liy5Lit55qE5q2j5YiZ6KGo6L6+5byP5YWz6ZSu5a2X56ym5re75Yqg6L2s5LmJXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVGb3JSZWcoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG59XG5cbi8qKlxuICogZmlsdGVyIGJ5IGtleVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBmaWx0ZXIga2V5XG4gKiBAcGFyYW0ge29iamVjdH0gaXRlbSBpdGVtIG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gaXQncyBmaWx0ZXJlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyKGtleSwgaXRlbSkge1xuICAgIGNvbnN0IF9rZXkgPSBlc2NhcGVGb3JSZWcoYCR7a2V5fWApO1xuICAgIGNvbnN0IHJlZ0V4cCA9IG5ldyBSZWdFeHAoYCgke19rZXl9KWAsICdpZycpO1xuXG4gICAgcmV0dXJuIHJlZ0V4cC50ZXN0KGAke2l0ZW0udmFsdWV9YCkgfHwgcmVnRXhwLnRlc3QoYCR7aXRlbS5sYWJlbH1gKTtcbn1cblxuLyoqXG4gKiBsb29wIG1hcFxuICogQHBhcmFtIHtBcnJheX0gZGF0YVNvdXJjZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge0FycmF5fVxuICogLS0tLVxuICogQGNhbGxiYWNrIH5sb29wQ2FsbGJhY2tcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvb3BNYXAoZGF0YVNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBkYXRhU291cmNlLmZvckVhY2gob3B0aW9uID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbi5jaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBsb29wTWFwKG9wdGlvbi5jaGlsZHJlbiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgY2hpbGRyZW4ubGVuZ3RoICYmIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb24sIGNoaWxkcmVuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IGNhbGxiYWNrKG9wdGlvbik7XG4gICAgICAgICAgICB0bXAgJiYgcmVzdWx0LnB1c2godG1wKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBQYXJzZSBkYXRhU291cmNlIGZyb20gTWVudUl0ZW1cbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7QXJyYXk8RWxlbWVudD59IGNoaWxkcmVuXG4gKiBAcGFyYW0ge251bWJlcn0gW2RlZXA9MF0gcmVjdXJzaW9uIGRlZXAgbGV2ZWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRGF0YVNvdXJjZUZyb21DaGlsZHJlbihjaGlsZHJlbiwgZGVlcCA9IDApIHtcbiAgICBjb25zdCBzb3VyY2UgPSBbXTtcblxuICAgIENoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wczogY2hpbGRQcm9wcyB9ID0gY2hpbGQ7XG4gICAgICAgIGNvbnN0IGl0ZW0yID0geyBkZWVwIH07XG5cbiAgICAgICAgbGV0IGlzT3B0aW9uID0gZmFsc2U7XG4gICAgICAgIGxldCBpc09wdGlvbkdyb3VwID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGUuX3R5cGVNYXJrID09PSAnbmV4dF9zZWxlY3Rfb3B0aW9uJyB8fCB0eXBlID09PSAnb3B0aW9uJykge1xuICAgICAgICAgICAgaXNPcHRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlLl90eXBlTWFyayA9PT0gJ25leHRfc2VsZWN0X29wdGlvbl9ncm91cCcgfHwgdHlwZSA9PT0gJ29wdGdyb3VwJykge1xuICAgICAgICAgICAgaXNPcHRpb25Hcm91cCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzT3B0aW9uICYmICFpc09wdGlvbkdyb3VwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNPcHRpb24pIHsgLy8gb3B0aW9uXG4gICAgICAgICAgICAvLyBJZiBjaGlsZHJlbiBpcyBhIHN0cmluZywgaXQgY2FuIGJlIHVzZWQgYXMgdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IGlzU3RyQ2hpbGQgPSB0eXBlb2YgY2hpbGRQcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZyc7XG4gICAgICAgICAgICAvLyB2YWx1ZSA+IGtleSA+IHN0cmluZyBjaGlsZHJlbiA+IGluZGV4XG4gICAgICAgICAgICBpdGVtMi52YWx1ZSA9ICd2YWx1ZScgaW4gY2hpbGRQcm9wcyA/XG4gICAgICAgICAgICAgICAgY2hpbGRQcm9wcy52YWx1ZSA6ICdrZXknIGluIGNoaWxkUHJvcHMgP1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFByb3BzLmtleSA6IGlzU3RyQ2hpbGQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9wcy5jaGlsZHJlbiA6IGAke2luZGV4fWA7XG5cbiAgICAgICAgICAgIGl0ZW0yLmxhYmVsID0gY2hpbGRQcm9wcy5sYWJlbCB8fCBjaGlsZFByb3BzLmNoaWxkcmVuIHx8IGAke2l0ZW0yLnZhbHVlfWA7XG4gICAgICAgICAgICBpdGVtMi50aXRsZSA9IGNoaWxkUHJvcHMudGl0bGU7XG4gICAgICAgICAgICBjaGlsZFByb3BzLmRpc2FibGVkID09PSB0cnVlICYmIChpdGVtMi5kaXNhYmxlZCA9IHRydWUpO1xuICAgICAgICAgICAgLy8gWW91IGNhbiBwdXQgeW91ciBleHRyYSBkYXRhIGhlcmUsIGFuZCB1c2UgaXQgaW4gYGl0ZW1SZW5kZXJgIG9yIGBsYWJlbFJlbmRlcmBcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXRlbTIsIGNoaWxkUHJvcHNbJ2RhdGEtZXh0cmEnXSB8fCB7fSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPcHRpb25Hcm91cCAmJiBkZWVwIDwgMSkgeyAvLyBvcHRpb24gZ3JvdXBcbiAgICAgICAgICAgIGl0ZW0yLmxhYmVsID0gY2hpbGRQcm9wcy5sYWJlbCB8fCAnR3JvdXAnO1xuICAgICAgICAgICAgLy8gcGFyc2UgY2hpbGRyZW4gbm9kZXNcbiAgICAgICAgICAgIGl0ZW0yLmNoaWxkcmVuID0gcGFyc2VEYXRhU291cmNlRnJvbUNoaWxkcmVuKGNoaWxkUHJvcHMuY2hpbGRyZW4sIGRlZXAgKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNvdXJjZS5wdXNoKGl0ZW0yKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzb3VyY2U7XG59XG5cblxuLyoqXG4gKiBOb3JtYWxpemUgZGF0YVNvdXJjZVxuICogQHN0YXRpY1xuICogQHBhcmFtIHtBcnJheX0gZGF0YVNvdXJjZVxuICogQHBhcmFtIHtudW1iZXJ9IFtkZWVwPTBdIHJlY3Vyc2lvbiBkZWVwIGxldmVsXG4gKiAtLS0tXG4gKiB2YWx1ZSBwcmlvcml0eTogdmFsdWUgPiAnaW5kZXgnXG4gKiBsYWJlbCBwcmlvcml0eTogbGFiZWwgPiAndmFsdWUnID4gJ2luZGV4J1xuICogZGlzYWJsZWQ6IGRpc2FibGVkID09PSB0cnVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVEYXRhU291cmNlKGRhdGFTb3VyY2UsIGRlZXAgPSAwKSB7XG4gICAgY29uc3Qgc291cmNlID0gW107XG5cbiAgICBkYXRhU291cmNlLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgIC8vIGVuYWJsZSBhcnJheSBvZiBiYXNpYyB0eXBlXG4gICAgICAgIGlmICgvc3RyaW5nfGJvb2xlYW58bnVtYmVyLy50ZXN0KHR5cGVvZiBpdGVtKSkge1xuICAgICAgICAgICAgaXRlbSA9IHsgbGFiZWw6IGAke2l0ZW19YCwgdmFsdWU6IGl0ZW0gfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbHRlciBvZmYgYWRkb24gaXRlbVxuICAgICAgICBpZiAoaXRlbS5fX2lzQWRkb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGl0ZW0yID0geyBkZWVwIH07XG4gICAgICAgIC8vIGRlZXAgPCAxOiBvbmx5IDIgbGV2ZWwgYWxsb3dlZFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtLmNoaWxkcmVuKSAmJiBkZWVwIDwgMSkge1xuICAgICAgICAgICAgLy8gaGFuZGxlIGdyb3VwXG4gICAgICAgICAgICBpdGVtMi5sYWJlbCA9IGl0ZW0ubGFiZWwgfHwgaXRlbS52YWx1ZSB8fCBgR3JvdXAgJHtpbmRleH1gO1xuICAgICAgICAgICAgLy8gcGFyc2UgY2hpbGRyZW5cbiAgICAgICAgICAgIGl0ZW0yLmNoaWxkcmVuID0gbm9ybWFsaXplRGF0YVNvdXJjZShpdGVtLmNoaWxkcmVuLCBkZWVwICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBsYWJlbCwgdGl0bGUsIGRpc2FibGVkLCAuLi5vdGhlcnMgfSA9IGl0ZW07XG4gICAgICAgICAgICBpdGVtMi52YWx1ZSA9ICFpc051bGwodmFsdWUpID8gdmFsdWUgOiBgJHtpbmRleH1gO1xuICAgICAgICAgICAgaXRlbTIubGFiZWwgPSBsYWJlbCB8fCBgJHtpdGVtMi52YWx1ZX1gO1xuICAgICAgICAgICAgaXRlbTIudGl0bGUgPSB0aXRsZTtcbiAgICAgICAgICAgIGRpc2FibGVkID09PSB0cnVlICYmIChpdGVtMi5kaXNhYmxlZCA9IHRydWUpO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0ZW0yLCBvdGhlcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgc291cmNlLnB1c2goaXRlbTIpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNvdXJjZTtcbn1cblxuXG4vKipcbiAqIEdldCBmbGF0dGVuIGRhdGFTb3VyY2VcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBkYXRhU291cmNlIHN0cnVjdHVyZWQgZGF0YVNvdXJjZVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGluZ0RhdGFTb3VyY2UoZGF0YVNvdXJjZSkge1xuICAgIGNvbnN0IHNvdXJjZSA9IFtdO1xuXG4gICAgZGF0YVNvdXJjZS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0uY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBzb3VyY2UucHVzaCguLi5mbGF0dGluZ0RhdGFTb3VyY2UoaXRlbS5jaGlsZHJlbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzb3VyY2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJEYXRhU291cmNlKGRhdGFTb3VyY2UsIGtleSwgZmlsdGVyLCBhZGRvbktleSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhU291cmNlKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJyB8fCBrZXkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChkYXRhU291cmNlKTtcbiAgICB9XG5cblxuICAgIGxldCBhZGRLZXkgPSB0cnVlO1xuICAgIGNvbnN0IG1lbnVEYXRhU291cmNlID0gbG9vcE1hcChkYXRhU291cmNlLCBvcHRpb24gPT4ge1xuICAgICAgICBpZiAoa2V5ID09PSBgJHtvcHRpb24udmFsdWV9YCkge1xuICAgICAgICAgICAgYWRkS2V5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbHRlcihrZXksIG9wdGlvbikgJiYgIW9wdGlvbi5fX2lzQWRkb24gJiYgb3B0aW9uO1xuICAgIH0pO1xuXG4gICAgLy8gaWYga2V5IG5vdCBpbiBtZW51RGF0YVNvdXJjZSwgYWRkIGtleSB0byBkYXRhU291cmNlXG4gICAgaWYgKGFkZG9uS2V5ICYmIGtleSAmJiBhZGRLZXkpIHtcbiAgICAgICAgbWVudURhdGFTb3VyY2UudW5zaGlmdCh7XG4gICAgICAgICAgICB2YWx1ZToga2V5LFxuICAgICAgICAgICAgbGFiZWw6IGtleSxcbiAgICAgICAgICAgIHRpdGxlOiBrZXksXG4gICAgICAgICAgICBfX2lzQWRkb246IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbnVEYXRhU291cmNlO1xufVxuXG5mdW5jdGlvbiBnZXRLZXlJdGVtQnlWYWx1ZSh2YWx1ZSwgdmFsdWVNYXApIHtcbiAgICBsZXQgaXRlbTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG4gICAgICAgIGl0ZW0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtID0gdmFsdWVNYXBbYCR7dmFsdWV9YF0gfHwge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBsYWJlbDogdmFsdWUsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW07XG59XG5cbi8qKlxuICogY29tcHV0ZSB2YWx1ZURhdGFTb3VyY2UgYnkgbmV3IHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5L1N0cmluZ30gdmFsdWUg5pWw5o2uXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwVmFsdWVEUyAgIOS4iuS4qnZhbHVl55qE57yT5a2Y5pWw5o2uIHZhbHVlID0+IHt2YWx1ZSxsYWJlbH0g55qE5pig5bCE5YWz57O76KGoXG4gKiBAcGFyYW0geyp9IG1hcE1lbnVEUyAg6YCa6L+HIGRhdGFTb3VyY2Ug5bu656uLIHZhbHVlID0+IHt2YWx1ZSxsYWJlbH0g55qE5pig5bCE5YWz57O76KGoXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB2YWx1ZTogW3ZhbHVlXTsgdmFsdWVEUzogW3t2YWx1ZSxsYWJlbH1dOyBtYXBWYWx1ZURTOiB7dmFsdWU6IHt2YWx1ZSxsYWJlbH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZURhdGFTb3VyY2UodmFsdWUsIG1hcFZhbHVlRFMsIG1hcE1lbnVEUykge1xuICAgIGlmIChpc051bGwodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdWYWx1ZSA9IFtdO1xuICAgIGNvbnN0IG5ld1ZhbHVlRFMgPSBbXTtcbiAgICBjb25zdCBuZXdNYXBWYWx1ZURTID0ge307XG4gICAgY29uc3QgX25ld01hcERTID0gT2JqZWN0LmFzc2lnbih7fSwgbWFwVmFsdWVEUywgbWFwTWVudURTKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZ2V0S2V5SXRlbUJ5VmFsdWUodiwgX25ld01hcERTKTtcblxuICAgICAgICAgICAgbmV3VmFsdWVEUy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgbmV3TWFwVmFsdWVEU1tgJHtpdGVtLnZhbHVlfWBdID0gaXRlbTtcbiAgICAgICAgICAgIG5ld1ZhbHVlLnB1c2goaXRlbS52YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsIC8vIFt2YWx1ZV1cbiAgICAgICAgICAgIHZhbHVlRFM6IG5ld1ZhbHVlRFMsIC8vIFt7dmFsdWUsbGFiZWx9XVxuICAgICAgICAgICAgbWFwVmFsdWVEUzogbmV3TWFwVmFsdWVEUyAvLyB7dmFsdWU6IHt2YWx1ZSxsYWJlbH19XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIGNvbnN0IGl0ZW0gPSBnZXRLZXlJdGVtQnlWYWx1ZSh2YWx1ZSwgX25ld01hcERTKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGl0ZW0udmFsdWUsXG4gICAgICAgICAgICB2YWx1ZURTOiBpdGVtLFxuICAgICAgICAgICAgbWFwVmFsdWVEUzoge1xuICAgICAgICAgICAgICAgIFtgJHtpdGVtLnZhbHVlfWBdOiBpdGVtXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIEdldCBmbGF0dGVuIGRhdGFTb3VyY2VcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge2FueX0gdmFsdWUgc3RydWN0dXJlZCBkYXRhU291cmNlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWx1ZVRvU2VsZWN0S2V5KHZhbHVlKSB7XG4gICAgbGV0IHZhbDtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xuICAgICAgICB2YWwgPSB2YWx1ZS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3ZhbH1gO1xufVxuXG4vKipcbiAqIFVQIERvd24g5pS56L+b5Y+M5ZCR6ZO+6KGo5pa55rOVXG4gKi9cbi8vIGZ1bmN0aW9uIERvdWJsZUxpbmtMaXN0KGVsZW1lbnQpe1xuLy8gICAgIHRoaXMucHJldiA9IG51bGw7XG4vLyAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbi8vICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuLy8gfVxuLy9cbi8vIGV4cG9ydCBmdW5jdGlvbiBtYXBEb3VibGVMaW5rTGlzdChkYXRhU291cmNlKXtcbi8vXG4vLyAgICAgY29uc3QgbWFwRFMgPSB7fTtcbi8vICAgICBsZXQgZG91YmxlTGluayA9IG51bGw7XG4vL1xuLy8gICAgIGxldCBoZWFkID0gbnVsbDtcbi8vICAgICBsZXQgdGFpbCA9IG51bGw7XG4vL1xuLy8gICAgIGZ1bmN0aW9uICBhcHBlbmQoZWxlbWVudCkge1xuLy8gICAgICAgICBpZiAoIWRvdWJsZUxpbmspIHtcbi8vICAgICAgICAgICAgIGRvdWJsZUxpbmsgPSBuZXcgRG91YmxlTGlua0xpc3QoZWxlbWVudCk7XG4vLyAgICAgICAgICAgICBoZWFkID0gZG91YmxlTGluaztcbi8vICAgICAgICAgICAgIHRhaWwgPSBkb3VibGVMaW5rO1xuLy8gICAgICAgICAgICAgcmV0dXJuIGRvdWJsZUxpbms7XG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgRG91YmxlTGlua0xpc3QoZWxlbWVudCk7XG4vLyAgICAgICAgIHRhaWwubmV4dCA9IG5vZGU7XG4vLyAgICAgICAgIG5vZGUucHJldiA9IHRhaWw7XG4vLyAgICAgICAgIHRhaWwgPSBub2RlO1xuLy9cbi8vICAgICAgICAgcmV0dXJuIHRhaWw7XG4vLyAgICAgfVxuLy9cbi8vICAgICBkYXRhU291cmNlLmZvckVhY2goKGl0ZW0gPT4ge1xuLy8gICAgICAgICBpZiAoaXRlbS5kaXNhYmxlZCkge1xuLy8gICAgICAgICAgICAgcmV0dXJuO1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIG1hcERTW2Ake2l0ZW0udmFsdWV9YF0gPSBhcHBlbmQoaXRlbSk7XG4vLyAgICAgfSkpO1xuLy9cbi8vICAgICByZXR1cm4gbWFwRFM7XG4vLyB9XG4vL1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NlbGVjdC91dGlsLmpzIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBjaGFyc2V0IFxcXCJVVEYtOFxcXCI7XFxuLyoqXFxuICog5bC65a+4IOWfuuehgOWwuuWvuFxcbiAqIOWRveWQjeiDveWcqOivreS5ieeahOWJjeaPkOS4i+eugOWNleWwseWwvemHj+eugOWNlSwg6L+Z6YeM5Y+v5Lul5pivIHNpemUtMngsIHNwYWNlLTJ4LCBzaXplLWJhc2UgLi4uXFxuICog5LiN6L+H5Y+v5Lul5Zyo6K+t5LmJ55qE5YmN5o+Q5LiL5YGa55qE5pu057K+566A5LiA5LqbLCDkuo7mmK/nlKjkuoZzMiwgczHnrYlcXG4gKiDlj6/nlKjlj5jph486IGAkczEgLSAkczhgXFxuICogQGV4YW1wbGUgc2NzcyAtIOS9v+eUqFxcbiAqICAgLmVsZW1lbnQge1xcbiAqICAgICBwYWRkaW5nOiAkczEgIWRlZmF1bHQ7XFxuICogICB9XFxuICpcXG4gKiBAZXhhbXBsZSBjc3MgLSBDU1Mg6L6T5Ye6XFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6IDRweCAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKi9cXG4ubmV4dC1pbnB1dCB7XFxuICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgZGlzcGxheTogaW5saW5lLXRhYmxlO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBzZXBhcmF0ZTtcXG4gIGZvbnQtc2l6ZTogMDtcXG4gIHdpZHRoOiAyMDBweDtcXG4gIGJvcmRlci1zcGFjaW5nOiAwO1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgLjNzIGVhc2Utb3V0O1xcbiAgdHJhbnNpdGlvbjogYWxsIC4zcyBlYXNlLW91dDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNDNEM2Q0Y7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGOyB9XFxuICAubmV4dC1pbnB1dCAqLFxcbiAgLm5leHQtaW5wdXQgKjpiZWZvcmUsXFxuICAubmV4dC1pbnB1dCAqOmFmdGVyIHtcXG4gICAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH1cXG4gIC5uZXh0LWlucHV0IGlucHV0IHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAvKiByZW1vdmUgYXV0b0ZpbGwgeWVsbG93IGJhY2tncm91bmQgKi8gfVxcbiAgICAubmV4dC1pbnB1dCBpbnB1dFt0eXBlPVxcXCJyZXNldFxcXCJdLCAubmV4dC1pbnB1dCBpbnB1dFt0eXBlPVxcXCJzdWJtaXRcXFwiXSB7XFxuICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247XFxuICAgICAgY3Vyc29yOiBwb2ludGVyOyB9XFxuICAgIC5uZXh0LWlucHV0IGlucHV0OjotbW96LWZvY3VzLWlubmVyIHtcXG4gICAgICBib3JkZXI6IDA7XFxuICAgICAgcGFkZGluZzogMDsgfVxcbiAgICAubmV4dC1pbnB1dCBpbnB1dDotd2Via2l0LWF1dG9maWxsIHtcXG4gICAgICAtd2Via2l0LWJveC1zaGFkb3c6IDAgMCAwIDEwMDBweCAjRkZGRkZGIGluc2V0OyB9XFxuICAubmV4dC1pbnB1dCB0ZXh0YXJlYSB7XFxuICAgIHJlc2l6ZTogbm9uZTsgfVxcbiAgLm5leHQtaW5wdXQgaW5wdXQsXFxuICAubmV4dC1pbnB1dCB0ZXh0YXJlYSB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIG91dGxpbmU6IG5vbmU7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuICAgIC5uZXh0LWlucHV0IGlucHV0OjotbW96LXBsYWNlaG9sZGVyLFxcbiAgICAubmV4dC1pbnB1dCB0ZXh0YXJlYTo6LW1vei1wbGFjZWhvbGRlciB7XFxuICAgICAgY29sb3I6ICM5OTk5OTk7XFxuICAgICAgb3BhY2l0eTogMTsgfVxcbiAgICAubmV4dC1pbnB1dCBpbnB1dDotbXMtaW5wdXQtcGxhY2Vob2xkZXIsXFxuICAgIC5uZXh0LWlucHV0IHRleHRhcmVhOi1tcy1pbnB1dC1wbGFjZWhvbGRlciB7XFxuICAgICAgY29sb3I6ICM5OTk5OTk7IH1cXG4gICAgLm5leHQtaW5wdXQgaW5wdXQ6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXIsXFxuICAgIC5uZXh0LWlucHV0IHRleHRhcmVhOjotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVyIHtcXG4gICAgICBjb2xvcjogIzk5OTk5OTsgfVxcbiAgICAubmV4dC1pbnB1dCBpbnB1dDo6LW1zLWNsZWFyLFxcbiAgICAubmV4dC1pbnB1dCB0ZXh0YXJlYTo6LW1zLWNsZWFyIHtcXG4gICAgICBkaXNwbGF5OiBub25lOyB9XFxuICAubmV4dC1pbnB1dC5uZXh0LWlucHV0LXRleHRhcmVhIHtcXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgICBmb250LXNpemU6IDA7IH1cXG4gICAgLm5leHQtaW5wdXQubmV4dC1pbnB1dC10ZXh0YXJlYSB0ZXh0YXJlYSB7XFxuICAgICAgY29sb3I6ICMzMzMzMzM7XFxuICAgICAgcGFkZGluZzogNHB4IDhweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgYm9yZGVyLXJhZGl1czogM3B4OyB9XFxuICAgIC5uZXh0LWlucHV0Lm5leHQtaW5wdXQtdGV4dGFyZWEgLm5leHQtaW5wdXQtY29udHJvbCB7XFxuICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgd2lkdGg6IGF1dG87XFxuICAgICAgYm9yZGVyLXJhZGl1czogM3B4OyB9XFxuICAgIC5uZXh0LWlucHV0Lm5leHQtaW5wdXQtdGV4dGFyZWEgLm5leHQtaW5wdXQtbGVuIHtcXG4gICAgICBwYWRkaW5nOiAwIDhweCA0cHg7XFxuICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICAgICAgd2lkdGg6IGF1dG87IH1cXG4gIC5uZXh0LWlucHV0Lm5leHQtc21hbGwge1xcbiAgICBoZWlnaHQ6IDIwcHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDNweDsgfVxcbiAgICAubmV4dC1pbnB1dC5uZXh0LXNtYWxsIC5uZXh0LWlucHV0LWxhYmVsIHtcXG4gICAgICBwYWRkaW5nLWxlZnQ6IDhweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7IH1cXG4gICAgLm5leHQtaW5wdXQubmV4dC1zbWFsbCAubmV4dC1pbnB1dC1pbm5lciB7XFxuICAgICAgZm9udC1zaXplOiAxMnB4OyB9XFxuICAgIC5uZXh0LWlucHV0Lm5leHQtc21hbGwgLm5leHQtaW5wdXQtY29udHJvbCB7XFxuICAgICAgcGFkZGluZy1yaWdodDogNHB4OyB9XFxuICAgIC5uZXh0LWlucHV0Lm5leHQtc21hbGwgaW5wdXQge1xcbiAgICAgIGhlaWdodDogMThweDtcXG4gICAgICBsaW5lLWhlaWdodDogMThweCBcXFxcMDtcXG4gICAgICBwYWRkaW5nOiAwIDRweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7IH1cXG4gICAgICAubmV4dC1pbnB1dC5uZXh0LXNtYWxsIGlucHV0Ojotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVyIHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDsgfVxcbiAgICAgIC5uZXh0LWlucHV0Lm5leHQtc21hbGwgaW5wdXQ6Oi1tcy1pbnB1dC1wbGFjZWhvbGRlciB7XFxuICAgICAgICBmb250LXNpemU6IDEycHg7IH1cXG4gICAgICAubmV4dC1pbnB1dC5uZXh0LXNtYWxsIGlucHV0OjpwbGFjZWhvbGRlciB7XFxuICAgICAgICBmb250LXNpemU6IDEycHg7IH1cXG4gICAgLm5leHQtaW5wdXQubmV4dC1zbWFsbCAubmV4dC1pbnB1dC10ZXh0LWZpZWxkIHtcXG4gICAgICBwYWRkaW5nOiAwIDRweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgaGVpZ2h0OiAxOHB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiAxOHB4OyB9XFxuICAgIC5uZXh0LWlucHV0Lm5leHQtc21hbGwgLm5leHQtaWNvbjpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAubmV4dC1pbnB1dC5uZXh0LXNtYWxsIGlucHV0IHtcXG4gICAgICBib3JkZXItcmFkaXVzOiAzcHg7IH1cXG4gICAgLm5leHQtaW5wdXQubmV4dC1zbWFsbCAubmV4dC1pbnB1dC1jb250cm9sIHtcXG4gICAgICBib3JkZXItcmFkaXVzOiAwIDNweCAzcHggMDsgfVxcbiAgLm5leHQtaW5wdXQubmV4dC1tZWRpdW0ge1xcbiAgICBoZWlnaHQ6IDI4cHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDNweDsgfVxcbiAgICAubmV4dC1pbnB1dC5uZXh0LW1lZGl1bSAubmV4dC1pbnB1dC1sYWJlbCB7XFxuICAgICAgcGFkZGluZy1sZWZ0OiA4cHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4OyB9XFxuICAgIC5uZXh0LWlucHV0Lm5leHQtbWVkaXVtIC5uZXh0LWlucHV0LWlubmVyIHtcXG4gICAgICBmb250LXNpemU6IDEycHg7IH1cXG4gICAgLm5leHQtaW5wdXQubmV4dC1tZWRpdW0gLm5leHQtaW5wdXQtY29udHJvbCB7XFxuICAgICAgcGFkZGluZy1yaWdodDogOHB4OyB9XFxuICAgIC5uZXh0LWlucHV0Lm5leHQtbWVkaXVtIGlucHV0IHtcXG4gICAgICBoZWlnaHQ6IDI2cHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IDI2cHggXFxcXDA7XFxuICAgICAgcGFkZGluZzogMCA4cHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4OyB9XFxuICAgICAgLm5leHQtaW5wdXQubmV4dC1tZWRpdW0gaW5wdXQ6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXIge1xcbiAgICAgICAgZm9udC1zaXplOiAxMnB4OyB9XFxuICAgICAgLm5leHQtaW5wdXQubmV4dC1tZWRpdW0gaW5wdXQ6Oi1tcy1pbnB1dC1wbGFjZWhvbGRlciB7XFxuICAgICAgICBmb250LXNpemU6IDEycHg7IH1cXG4gICAgICAubmV4dC1pbnB1dC5uZXh0LW1lZGl1bSBpbnB1dDo6cGxhY2Vob2xkZXIge1xcbiAgICAgICAgZm9udC1zaXplOiAxMnB4OyB9XFxuICAgIC5uZXh0LWlucHV0Lm5leHQtbWVkaXVtIC5uZXh0LWlucHV0LXRleHQtZmllbGQge1xcbiAgICAgIHBhZGRpbmc6IDAgOHB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBoZWlnaHQ6IDI2cHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IDI2cHg7IH1cXG4gICAgLm5leHQtaW5wdXQubmV4dC1tZWRpdW0gLm5leHQtaWNvbjpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAubmV4dC1pbnB1dC5uZXh0LW1lZGl1bSBpbnB1dCB7XFxuICAgICAgYm9yZGVyLXJhZGl1czogM3B4OyB9XFxuICAgIC5uZXh0LWlucHV0Lm5leHQtbWVkaXVtIC5uZXh0LWlucHV0LWNvbnRyb2wge1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDAgM3B4IDNweCAwOyB9XFxuICAubmV4dC1pbnB1dC5uZXh0LWxhcmdlIHtcXG4gICAgaGVpZ2h0OiA0MHB4O1xcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7IH1cXG4gICAgLm5leHQtaW5wdXQubmV4dC1sYXJnZSAubmV4dC1pbnB1dC1sYWJlbCB7XFxuICAgICAgcGFkZGluZy1sZWZ0OiAxMnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTZweDsgfVxcbiAgICAubmV4dC1pbnB1dC5uZXh0LWxhcmdlIC5uZXh0LWlucHV0LWlubmVyIHtcXG4gICAgICBmb250LXNpemU6IDE2cHg7IH1cXG4gICAgLm5leHQtaW5wdXQubmV4dC1sYXJnZSAubmV4dC1pbnB1dC1jb250cm9sIHtcXG4gICAgICBwYWRkaW5nLXJpZ2h0OiA4cHg7IH1cXG4gICAgLm5leHQtaW5wdXQubmV4dC1sYXJnZSBpbnB1dCB7XFxuICAgICAgaGVpZ2h0OiAzOHB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiAzOHB4IFxcXFwwO1xcbiAgICAgIHBhZGRpbmc6IDAgMTJweDtcXG4gICAgICBmb250LXNpemU6IDE2cHg7IH1cXG4gICAgICAubmV4dC1pbnB1dC5uZXh0LWxhcmdlIGlucHV0Ojotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVyIHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDsgfVxcbiAgICAgIC5uZXh0LWlucHV0Lm5leHQtbGFyZ2UgaW5wdXQ6Oi1tcy1pbnB1dC1wbGFjZWhvbGRlciB7XFxuICAgICAgICBmb250LXNpemU6IDE2cHg7IH1cXG4gICAgICAubmV4dC1pbnB1dC5uZXh0LWxhcmdlIGlucHV0OjpwbGFjZWhvbGRlciB7XFxuICAgICAgICBmb250LXNpemU6IDE2cHg7IH1cXG4gICAgLm5leHQtaW5wdXQubmV4dC1sYXJnZSAubmV4dC1pbnB1dC10ZXh0LWZpZWxkIHtcXG4gICAgICBwYWRkaW5nOiAwIDEycHg7XFxuICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgIGhlaWdodDogMzhweDtcXG4gICAgICBsaW5lLWhlaWdodDogMzhweDsgfVxcbiAgICAubmV4dC1pbnB1dC5uZXh0LWxhcmdlIC5uZXh0LWljb246YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTZweDtcXG4gICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgLm5leHQtaW5wdXQubmV4dC1sYXJnZSBpbnB1dCB7XFxuICAgICAgYm9yZGVyLXJhZGl1czogM3B4OyB9XFxuICAgIC5uZXh0LWlucHV0Lm5leHQtbGFyZ2UgLm5leHQtaW5wdXQtY29udHJvbCB7XFxuICAgICAgYm9yZGVyLXJhZGl1czogMCAzcHggM3B4IDA7IH1cXG4gIC5uZXh0LWlucHV0LWhpbnQtd3JhcCB7XFxuICAgIGNvbG9yOiAjOTk5OTk5O1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG4gICAgLm5leHQtaW5wdXQtaGludC13cmFwIC5uZXh0LWlucHV0LWNsZWFyIHtcXG4gICAgICBvcGFjaXR5OiAwO1xcbiAgICAgIHotaW5kZXg6IDE7XFxuICAgICAgcG9zaXRpb246IGFic29sdXRlOyB9XFxuICAgIC5uZXh0LWlucHV0LWhpbnQtd3JhcCAubmV4dC1pbnB1dC1oaW50IHtcXG4gICAgICBvcGFjaXR5OiAxOyB9XFxuICAubmV4dC1pbnB1dCAubmV4dC1pY29uLWRlbGV0ZS1maWxsaW5nOmhvdmVyIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBjb2xvcjogIzY2NjY2NjsgfVxcbiAgLm5leHQtaW5wdXQ6aG92ZXIsIC5uZXh0LWlucHV0Lm5leHQtZm9jdXMge1xcbiAgICBib3JkZXItY29sb3I6ICNBMEEyQUQ7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkY7IH1cXG4gICAgLm5leHQtaW5wdXQ6aG92ZXIgLm5leHQtaW5wdXQtY2xlYXIsIC5uZXh0LWlucHV0Lm5leHQtZm9jdXMgLm5leHQtaW5wdXQtY2xlYXIge1xcbiAgICAgIG9wYWNpdHk6IDE7IH1cXG4gICAgICAubmV4dC1pbnB1dDpob3ZlciAubmV4dC1pbnB1dC1jbGVhciArIC5uZXh0LWlucHV0LWhpbnQsIC5uZXh0LWlucHV0Lm5leHQtZm9jdXMgLm5leHQtaW5wdXQtY2xlYXIgKyAubmV4dC1pbnB1dC1oaW50IHtcXG4gICAgICAgIG9wYWNpdHk6IDA7IH1cXG4gIC5uZXh0LWlucHV0IC5uZXh0LWlucHV0LWNsZWFyOmZvY3VzIHtcXG4gICAgb3BhY2l0eTogMTsgfVxcbiAgICAubmV4dC1pbnB1dCAubmV4dC1pbnB1dC1jbGVhcjpmb2N1cyArIC5uZXh0LWlucHV0LWhpbnQge1xcbiAgICAgIG9wYWNpdHk6IDA7IH1cXG4gIC5uZXh0LWlucHV0Lm5leHQtZm9jdXMge1xcbiAgICBib3JkZXItY29sb3I6ICM1NTg0RkY7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkY7IH1cXG4gIC5uZXh0LWlucHV0Lm5leHQtZXJyb3Ige1xcbiAgICBib3JkZXItY29sb3I6ICNGRjMwMDA7IH1cXG4gICAgLm5leHQtaW5wdXQubmV4dC1lcnJvci5uZXh0LWZvY3VzLCAubmV4dC1pbnB1dC5uZXh0LWVycm9yOmhvdmVyIHtcXG4gICAgICBib3JkZXItY29sb3I6ICNGRjMwMDA7IH1cXG4gIC5uZXh0LWlucHV0Lm5leHQtaGlkZGVuIHtcXG4gICAgZGlzcGxheTogbm9uZTsgfVxcbiAgLm5leHQtaW5wdXQubmV4dC1ub2JvcmRlciB7XFxuICAgIGJvcmRlcjogbm9uZTsgfVxcbiAgLm5leHQtaW5wdXQtY29udHJvbCAubmV4dC1pbnB1dC1sZW4ge1xcbiAgICBmb250LXNpemU6IDEycHg7XFxuICAgIGxpbmUtaGVpZ2h0OiAxMnB4O1xcbiAgICBjb2xvcjogIzk5OTk5OTtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgd2lkdGg6IDFweDtcXG4gICAgdmVydGljYWwtYWxpZ246IGJvdHRvbTsgfVxcbiAgICAubmV4dC1pbnB1dC1jb250cm9sIC5uZXh0LWlucHV0LWxlbi5uZXh0LWVycm9yIHtcXG4gICAgICBjb2xvcjogI0ZGMzAwMDsgfVxcbiAgLm5leHQtaW5wdXQtY29udHJvbCA+ICoge1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB3aWR0aDogMSU7XFxuICAgIHRvcDogMDsgfVxcbiAgLm5leHQtaW5wdXQtY29udHJvbCA+ICo6bm90KDpsYXN0LWNoaWxkKSB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDRweDsgfVxcbiAgLm5leHQtaW5wdXQtY29udHJvbCAubmV4dC1pY29uIHtcXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgLjNzIGVhc2Utb3V0O1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgLjNzIGVhc2Utb3V0O1xcbiAgICBjb2xvcjogIzk5OTk5OTsgfVxcbiAgLm5leHQtaW5wdXQtY29udHJvbCAubmV4dC1pY29uLXN1Y2Nlc3MtZmlsbGluZyB7XFxuICAgIGNvbG9yOiAjNDZCQzE1OyB9XFxuICAubmV4dC1pbnB1dC1jb250cm9sIC5uZXh0LWljb24tbG9hZGluZyB7XFxuICAgIGNvbG9yOiAjNDQ5NEY5OyB9XFxuICAubmV4dC1pbnB1dC1sYWJlbCB7XFxuICAgIGNvbG9yOiAjNjY2NjY2OyB9XFxuICAubmV4dC1pbnB1dC5uZXh0LWRpc2FibGVkIHtcXG4gICAgY29sb3I6ICNDQ0NDQ0M7XFxuICAgIGJvcmRlci1jb2xvcjogI0U2RTdFQjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjhGQTtcXG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjhGQTsgfVxcbiAgICAubmV4dC1pbnB1dC5uZXh0LWRpc2FibGVkOmhvdmVyIHtcXG4gICAgICBib3JkZXItY29sb3I6ICNFNkU3RUI7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjhGQTsgfVxcbiAgICAubmV4dC1pbnB1dC5uZXh0LWRpc2FibGVkIGlucHV0OjotbW96LXBsYWNlaG9sZGVyLCAubmV4dC1pbnB1dC5uZXh0LWRpc2FibGVkIHRleHRhcmVhOjotbW96LXBsYWNlaG9sZGVyIHtcXG4gICAgICBjb2xvcjogI0NDQ0NDQztcXG4gICAgICBvcGFjaXR5OiAxOyB9XFxuICAgIC5uZXh0LWlucHV0Lm5leHQtZGlzYWJsZWQgaW5wdXQ6LW1zLWlucHV0LXBsYWNlaG9sZGVyLCAubmV4dC1pbnB1dC5uZXh0LWRpc2FibGVkIHRleHRhcmVhOi1tcy1pbnB1dC1wbGFjZWhvbGRlciB7XFxuICAgICAgY29sb3I6ICNDQ0NDQ0M7IH1cXG4gICAgLm5leHQtaW5wdXQubmV4dC1kaXNhYmxlZCBpbnB1dDo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciwgLm5leHQtaW5wdXQubmV4dC1kaXNhYmxlZCB0ZXh0YXJlYTo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciB7XFxuICAgICAgY29sb3I6ICNDQ0NDQ0M7IH1cXG4gICAgLm5leHQtaW5wdXQubmV4dC1kaXNhYmxlZCAubmV4dC1pbnB1dC1sYWJlbCB7XFxuICAgICAgY29sb3I6ICNDQ0NDQ0M7IH1cXG4gICAgLm5leHQtaW5wdXQubmV4dC1kaXNhYmxlZCAubmV4dC1pbnB1dC1sZW4ge1xcbiAgICAgIGNvbG9yOiAjQ0NDQ0NDOyB9XFxuICAgIC5uZXh0LWlucHV0Lm5leHQtZGlzYWJsZWQgaW5wdXQsXFxuICAgIC5uZXh0LWlucHV0Lm5leHQtZGlzYWJsZWQgdGV4dGFyZWEge1xcbiAgICAgIGNvbG9yOiAjQ0NDQ0NDO1xcbiAgICAgIGJvcmRlci1jb2xvcjogI0U2RTdFQjtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGOEZBO1xcbiAgICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7IH1cXG4gICAgICAubmV4dC1pbnB1dC5uZXh0LWRpc2FibGVkIGlucHV0OmhvdmVyLFxcbiAgICAgIC5uZXh0LWlucHV0Lm5leHQtZGlzYWJsZWQgdGV4dGFyZWE6aG92ZXIge1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiAjRTZFN0VCO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjhGQTsgfVxcbiAgICAubmV4dC1pbnB1dC5uZXh0LWRpc2FibGVkIC5uZXh0LWlucHV0LWhpbnQtd3JhcCB7XFxuICAgICAgY29sb3I6ICNDQ0NDQ0M7IH1cXG4gICAgICAubmV4dC1pbnB1dC5uZXh0LWRpc2FibGVkIC5uZXh0LWlucHV0LWhpbnQtd3JhcCAubmV4dC1pbnB1dC1jbGVhciB7XFxuICAgICAgICBvcGFjaXR5OiAwOyB9XFxuICAgICAgLm5leHQtaW5wdXQubmV4dC1kaXNhYmxlZCAubmV4dC1pbnB1dC1oaW50LXdyYXAgLm5leHQtaW5wdXQtaGludCB7XFxuICAgICAgICBvcGFjaXR5OiAxOyB9XFxuICAgICAgLm5leHQtaW5wdXQubmV4dC1kaXNhYmxlZCAubmV4dC1pbnB1dC1oaW50LXdyYXAgLm5leHQtaWNvbi1kZWxldGUtZmlsbGluZzpob3ZlciB7XFxuICAgICAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgICAgICAgY29sb3I6ICNDQ0NDQ0M7IH1cXG4gICAgLm5leHQtaW5wdXQubmV4dC1kaXNhYmxlZCAubmV4dC1pY29uIHtcXG4gICAgICBjb2xvcjogI0NDQ0NDQzsgfVxcbiAgLm5leHQtaW5wdXQtaW5uZXIsIC5uZXh0LWlucHV0LWNvbnRyb2wsIC5uZXh0LWlucHV0LWxhYmVsIHtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgd2lkdGg6IDFweDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgbGluZS1oZWlnaHQ6IDE7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwOyB9XFxuICAubmV4dC1pbnB1dC1ncm91cCB7XFxuICAgIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtdGFibGU7XFxuICAgIGJvcmRlci1jb2xsYXBzZTogc2VwYXJhdGU7XFxuICAgIGJvcmRlci1zcGFjaW5nOiAwO1xcbiAgICBsaW5lLWhlaWdodDogMDtcXG4gICAgd2lkdGg6IDEwMCU7IH1cXG4gICAgLm5leHQtaW5wdXQtZ3JvdXAgKixcXG4gICAgLm5leHQtaW5wdXQtZ3JvdXAgKjpiZWZvcmUsXFxuICAgIC5uZXh0LWlucHV0LWdyb3VwICo6YWZ0ZXIge1xcbiAgICAgIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH1cXG4gICAgLm5leHQtaW5wdXQtZ3JvdXAtYXV0by13aWR0aCB7XFxuICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgYm9yZGVyLXJhZGl1czogMCAhaW1wb3J0YW50OyB9XFxuICAgIC5uZXh0LWlucHV0LWdyb3VwID4gLm5leHQtaW5wdXQ6Zmlyc3QtY2hpbGQubmV4dC1zbWFsbCB7XFxuICAgICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogM3B4ICFpbXBvcnRhbnQ7XFxuICAgICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogM3B4ICFpbXBvcnRhbnQ7IH1cXG4gICAgLm5leHQtaW5wdXQtZ3JvdXAgPiAubmV4dC1pbnB1dDpmaXJzdC1jaGlsZC5uZXh0LW1lZGl1bSB7XFxuICAgICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogM3B4ICFpbXBvcnRhbnQ7XFxuICAgICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogM3B4ICFpbXBvcnRhbnQ7IH1cXG4gICAgLm5leHQtaW5wdXQtZ3JvdXAgPiAubmV4dC1pbnB1dDpmaXJzdC1jaGlsZC5uZXh0LWxhcmdlIHtcXG4gICAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAzcHggIWltcG9ydGFudDtcXG4gICAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAzcHggIWltcG9ydGFudDsgfVxcbiAgICAubmV4dC1pbnB1dC1ncm91cCA+IC5uZXh0LWlucHV0Omxhc3QtY2hpbGQubmV4dC1zbWFsbCB7XFxuICAgICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDNweCAhaW1wb3J0YW50O1xcbiAgICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAzcHggIWltcG9ydGFudDsgfVxcbiAgICAubmV4dC1pbnB1dC1ncm91cCA+IC5uZXh0LWlucHV0Omxhc3QtY2hpbGQubmV4dC1tZWRpdW0ge1xcbiAgICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAzcHggIWltcG9ydGFudDtcXG4gICAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogM3B4ICFpbXBvcnRhbnQ7IH1cXG4gICAgLm5leHQtaW5wdXQtZ3JvdXAgPiAubmV4dC1pbnB1dDpsYXN0LWNoaWxkLm5leHQtbGFyZ2Uge1xcbiAgICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAzcHggIWltcG9ydGFudDtcXG4gICAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogM3B4ICFpbXBvcnRhbnQ7IH1cXG4gIC5uZXh0LWlucHV0LWdyb3VwLWFkZG9uIHtcXG4gICAgd2lkdGg6IDFweDtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gICAgLyogc3R5bGVsaW50LWRpc2FibGUgZGVjbGFyYXRpb24tbm8taW1wb3J0YW50ICovIH1cXG4gICAgLm5leHQtaW5wdXQtZ3JvdXAtYWRkb246Zmlyc3QtY2hpbGQge1xcbiAgICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwICFpbXBvcnRhbnQ7XFxuICAgICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDAgIWltcG9ydGFudDsgfVxcbiAgICAgIC5uZXh0LWlucHV0LWdyb3VwLWFkZG9uOmZpcnN0LWNoaWxkID4gKiB7XFxuICAgICAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMCAhaW1wb3J0YW50O1xcbiAgICAgICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDAgIWltcG9ydGFudDsgfVxcbiAgICAubmV4dC1pbnB1dC1ncm91cC1hZGRvbjpsYXN0LWNoaWxkIHtcXG4gICAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwICFpbXBvcnRhbnQ7XFxuICAgICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMCAhaW1wb3J0YW50OyB9XFxuICAgICAgLm5leHQtaW5wdXQtZ3JvdXAtYWRkb246bGFzdC1jaGlsZCA+ICoge1xcbiAgICAgICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMCAhaW1wb3J0YW50O1xcbiAgICAgICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMCAhaW1wb3J0YW50OyB9XFxuICAubmV4dC1pbnB1dC1ncm91cC10ZXh0IHtcXG4gICAgY29sb3I6ICM5OTk5OTk7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGMkYzRjc7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI0M0QzZDRjtcXG4gICAgcGFkZGluZzogMCA4cHg7IH1cXG4gICAgLm5leHQtaW5wdXQtZ3JvdXAtdGV4dDpmaXJzdC1jaGlsZCB7XFxuICAgICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAwOyB9XFxuICAgIC5uZXh0LWlucHV0LWdyb3VwLXRleHQ6bGFzdC1jaGlsZCB7XFxuICAgICAgYm9yZGVyLWxlZnQtd2lkdGg6IDA7IH1cXG4gICAgLm5leHQtaW5wdXQtZ3JvdXAtdGV4dC5uZXh0LWRpc2FibGVkIHtcXG4gICAgICBjb2xvcjogI0NDQ0NDQztcXG4gICAgICBib3JkZXItY29sb3I6ICNFNkU3RUI7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjhGQTtcXG4gICAgICBjdXJzb3I6IG5vdC1hbGxvd2VkOyB9XFxuICAgICAgLm5leHQtaW5wdXQtZ3JvdXAtdGV4dC5uZXh0LWRpc2FibGVkOmhvdmVyIHtcXG4gICAgICAgIGJvcmRlci1jb2xvcjogI0U2RTdFQjtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y4RkE7IH1cXG4gICAgLm5leHQtaW5wdXQtZ3JvdXAtdGV4dC5uZXh0LXNtYWxsIHtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgYm9yZGVyLXJhZGl1czogM3B4OyB9XFxuICAgIC5uZXh0LWlucHV0LWdyb3VwLXRleHQubmV4dC1tZWRpdW0ge1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBib3JkZXItcmFkaXVzOiAzcHg7IH1cXG4gICAgLm5leHQtaW5wdXQtZ3JvdXAtdGV4dC5uZXh0LWxhcmdlIHtcXG4gICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgYm9yZGVyLXJhZGl1czogM3B4OyB9XFxuXFxuLm5leHQtaW5wdXRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LXNtYWxsIC5uZXh0LWlucHV0LWxhYmVsIHtcXG4gIHBhZGRpbmctbGVmdDogMDtcXG4gIHBhZGRpbmctcmlnaHQ6IDhweDsgfVxcblxcbi5uZXh0LWlucHV0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1zbWFsbCAubmV4dC1pbnB1dC1jb250cm9sIHtcXG4gIHBhZGRpbmctcmlnaHQ6IDA7XFxuICBwYWRkaW5nLWxlZnQ6IDRweDsgfVxcblxcbi5uZXh0LWlucHV0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1tZWRpdW0gLm5leHQtaW5wdXQtbGFiZWwge1xcbiAgcGFkZGluZy1sZWZ0OiAwO1xcbiAgcGFkZGluZy1yaWdodDogOHB4OyB9XFxuXFxuLm5leHQtaW5wdXRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LW1lZGl1bSAubmV4dC1pbnB1dC1jb250cm9sIHtcXG4gIHBhZGRpbmctcmlnaHQ6IDA7XFxuICBwYWRkaW5nLWxlZnQ6IDhweDsgfVxcblxcbi5uZXh0LWlucHV0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1sYXJnZSAubmV4dC1pbnB1dC1sYWJlbCB7XFxuICBwYWRkaW5nLWxlZnQ6IDA7XFxuICBwYWRkaW5nLXJpZ2h0OiAxMnB4OyB9XFxuXFxuLm5leHQtaW5wdXRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LWxhcmdlIC5uZXh0LWlucHV0LWNvbnRyb2wge1xcbiAgcGFkZGluZy1yaWdodDogMDtcXG4gIHBhZGRpbmctbGVmdDogOHB4OyB9XFxuXFxuLm5leHQtaW5wdXRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LWlucHV0LXRleHRhcmVhIC5uZXh0LWlucHV0LWxlbiB7XFxuICB0ZXh0LWFsaWduOiBsZWZ0OyB9XFxuXFxuLm5leHQtaW5wdXRbZGlyPVxcXCJydGxcXFwiXSAubmV4dC1pbnB1dC1jb250cm9sID4gKjpub3QoOmxhc3QtY2hpbGQpIHtcXG4gIHBhZGRpbmctbGVmdDogNHB4O1xcbiAgcGFkZGluZy1yaWdodDogMDsgfVxcblxcbi5uZXh0LWlucHV0LWdyb3VwW2Rpcj1cXFwicnRsXFxcIl0gLm5leHQtaW5wdXQtZ3JvdXAtYWRkb24ge1xcbiAgLyogc3R5bGVsaW50LWRpc2FibGUgZGVjbGFyYXRpb24tbm8taW1wb3J0YW50ICovIH1cXG4gIC5uZXh0LWlucHV0LWdyb3VwW2Rpcj1cXFwicnRsXFxcIl0gLm5leHQtaW5wdXQtZ3JvdXAtYWRkb246Zmlyc3QtY2hpbGQge1xcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwICFpbXBvcnRhbnQ7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDAgIWltcG9ydGFudDsgfVxcbiAgICAubmV4dC1pbnB1dC1ncm91cFtkaXI9XFxcInJ0bFxcXCJdIC5uZXh0LWlucHV0LWdyb3VwLWFkZG9uOmZpcnN0LWNoaWxkLm5leHQtc21hbGwge1xcbiAgICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAzcHggIWltcG9ydGFudDtcXG4gICAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogM3B4ICFpbXBvcnRhbnQ7IH1cXG4gICAgLm5leHQtaW5wdXQtZ3JvdXBbZGlyPVxcXCJydGxcXFwiXSAubmV4dC1pbnB1dC1ncm91cC1hZGRvbjpmaXJzdC1jaGlsZC5uZXh0LW1lZGl1bSB7XFxuICAgICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDNweCAhaW1wb3J0YW50O1xcbiAgICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAzcHggIWltcG9ydGFudDsgfVxcbiAgICAubmV4dC1pbnB1dC1ncm91cFtkaXI9XFxcInJ0bFxcXCJdIC5uZXh0LWlucHV0LWdyb3VwLWFkZG9uOmZpcnN0LWNoaWxkLm5leHQtbGFyZ2Uge1xcbiAgICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAzcHggIWltcG9ydGFudDtcXG4gICAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogM3B4ICFpbXBvcnRhbnQ7IH1cXG4gIC5uZXh0LWlucHV0LWdyb3VwW2Rpcj1cXFwicnRsXFxcIl0gLm5leHQtaW5wdXQtZ3JvdXAtYWRkb246bGFzdC1jaGlsZCB7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwICFpbXBvcnRhbnQ7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAwICFpbXBvcnRhbnQ7IH1cXG4gICAgLm5leHQtaW5wdXQtZ3JvdXBbZGlyPVxcXCJydGxcXFwiXSAubmV4dC1pbnB1dC1ncm91cC1hZGRvbjpsYXN0LWNoaWxkLm5leHQtc21hbGwge1xcbiAgICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDNweCAhaW1wb3J0YW50O1xcbiAgICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDNweCAhaW1wb3J0YW50OyB9XFxuICAgIC5uZXh0LWlucHV0LWdyb3VwW2Rpcj1cXFwicnRsXFxcIl0gLm5leHQtaW5wdXQtZ3JvdXAtYWRkb246bGFzdC1jaGlsZC5uZXh0LW1lZGl1bSB7XFxuICAgICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogM3B4ICFpbXBvcnRhbnQ7XFxuICAgICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogM3B4ICFpbXBvcnRhbnQ7IH1cXG4gICAgLm5leHQtaW5wdXQtZ3JvdXBbZGlyPVxcXCJydGxcXFwiXSAubmV4dC1pbnB1dC1ncm91cC1hZGRvbjpsYXN0LWNoaWxkLm5leHQtbGFyZ2Uge1xcbiAgICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDNweCAhaW1wb3J0YW50O1xcbiAgICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDNweCAhaW1wb3J0YW50OyB9XFxuXFxuLm5leHQtaW5wdXQtZ3JvdXBbZGlyPVxcXCJydGxcXFwiXSAubmV4dC1pbnB1dC1ncm91cC10ZXh0OmZpcnN0LWNoaWxkIHtcXG4gIGJvcmRlci1yaWdodC13aWR0aDogMXB4O1xcbiAgYm9yZGVyLWxlZnQ6IDA7IH1cXG5cXG4ubmV4dC1pbnB1dC1ncm91cFtkaXI9XFxcInJ0bFxcXCJdIC5uZXh0LWlucHV0LWdyb3VwLXRleHQ6bGFzdC1jaGlsZCB7XFxuICBib3JkZXItbGVmdC13aWR0aDogMXB4O1xcbiAgYm9yZGVyLXJpZ2h0OiAwOyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyPz9yZWYtLTItMSEuL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliPz9yZWYtLTItMiEuL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYiEuL3NyYy9pbnB1dC9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDE4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGNoYXJzZXQgXFxcIlVURi04XFxcIjtcXG4vKipcXG4gKiDlsLrlr7gg5Z+656GA5bC65a+4XFxuICog5ZG95ZCN6IO95Zyo6K+t5LmJ55qE5YmN5o+Q5LiL566A5Y2V5bCx5bC96YeP566A5Y2VLCDov5nph4zlj6/ku6XmmK8gc2l6ZS0yeCwgc3BhY2UtMngsIHNpemUtYmFzZSAuLi5cXG4gKiDkuI3ov4flj6/ku6XlnKjor63kuYnnmoTliY3mj5DkuIvlgZrnmoTmm7Tnsr7nroDkuIDkupssIOS6juaYr+eUqOS6hnMyLCBzMeetiVxcbiAqIOWPr+eUqOWPmOmHjzogYCRzMSAtICRzOGBcXG4gKiBAZXhhbXBsZSBzY3NzIC0g5L2/55SoXFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6ICRzMSAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKlxcbiAqIEBleGFtcGxlIGNzcyAtIENTUyDovpPlh7pcXG4gKiAgIC5lbGVtZW50IHtcXG4gKiAgICAgcGFkZGluZzogNHB4ICFkZWZhdWx0O1xcbiAqICAgfVxcbiAqL1xcbkAtd2Via2l0LWtleWZyYW1lcyBmYWRlSW5SaWdodEZvclRhZyB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpIHRyYW5zbGF0ZVgoMjBweCk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpIHRyYW5zbGF0ZVgoMjBweCk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKSB0cmFuc2xhdGVYKDApO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKSB0cmFuc2xhdGVYKDApOyB9IH1cXG5Aa2V5ZnJhbWVzIGZhZGVJblJpZ2h0Rm9yVGFnIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZykgdHJhbnNsYXRlWCgyMHB4KTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZykgdHJhbnNsYXRlWCgyMHB4KTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpIHRyYW5zbGF0ZVgoMCk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpIHRyYW5zbGF0ZVgoMCk7IH0gfVxcblxcbi5uZXh0LXRhZyA+IC5uZXh0LXRhZy1ib2R5IHtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpczsgfVxcblxcbi5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtc2Vjb25kYXJ5IHtcXG4gIGNvbG9yOiAjMzMzMzMzO1xcbiAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuICAubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLWxldmVsLXNlY29uZGFyeTpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSk6aG92ZXIsIC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtc2Vjb25kYXJ5Om5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKS5ob3ZlciwgLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1zZWNvbmRhcnk6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOmZvY3VzIHtcXG4gICAgY29sb3I6ICM1NTg0RkY7IH1cXG5cXG4ubmV4dC10YWctZGVmYXVsdC5uZXh0LXRhZy1sZXZlbC1wcmltYXJ5LCAubmV4dC10YWctY2xvc2FibGUubmV4dC10YWctbGV2ZWwtcHJpbWFyeSB7XFxuICBjb2xvcjogIzY2NjY2NjtcXG4gIGJvcmRlci1jb2xvcjogI0VCRUNGMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNFQkVDRjA7IH1cXG4gIC5uZXh0LXRhZy1kZWZhdWx0Lm5leHQtdGFnLWxldmVsLXByaW1hcnk6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOmhvdmVyLCAubmV4dC10YWctY2xvc2FibGUubmV4dC10YWctbGV2ZWwtcHJpbWFyeTpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSk6aG92ZXIsIC5uZXh0LXRhZy1kZWZhdWx0Lm5leHQtdGFnLWxldmVsLXByaW1hcnk6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pLmhvdmVyLCAubmV4dC10YWctY2xvc2FibGUubmV4dC10YWctbGV2ZWwtcHJpbWFyeTpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSkuaG92ZXIsIC5uZXh0LXRhZy1kZWZhdWx0Lm5leHQtdGFnLWxldmVsLXByaW1hcnk6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOmZvY3VzLCAubmV4dC10YWctY2xvc2FibGUubmV4dC10YWctbGV2ZWwtcHJpbWFyeTpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSk6Zm9jdXMge1xcbiAgICBjb2xvcjogIzMzMzMzMztcXG4gICAgYm9yZGVyLWNvbG9yOiAjRTJFNEU4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRTJFNEU4OyB9XFxuICAgIC5uZXh0LXRhZy1kZWZhdWx0Lm5leHQtdGFnLWxldmVsLXByaW1hcnk6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOmhvdmVyID4gLm5leHQtdGFnLWNsb3NlLWJ0biwgLm5leHQtdGFnLWNsb3NhYmxlLm5leHQtdGFnLWxldmVsLXByaW1hcnk6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOmhvdmVyID4gLm5leHQtdGFnLWNsb3NlLWJ0biwgLm5leHQtdGFnLWRlZmF1bHQubmV4dC10YWctbGV2ZWwtcHJpbWFyeTpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSkuaG92ZXIgPiAubmV4dC10YWctY2xvc2UtYnRuLCAubmV4dC10YWctY2xvc2FibGUubmV4dC10YWctbGV2ZWwtcHJpbWFyeTpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSkuaG92ZXIgPiAubmV4dC10YWctY2xvc2UtYnRuLCAubmV4dC10YWctZGVmYXVsdC5uZXh0LXRhZy1sZXZlbC1wcmltYXJ5Om5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKTpmb2N1cyA+IC5uZXh0LXRhZy1jbG9zZS1idG4sIC5uZXh0LXRhZy1jbG9zYWJsZS5uZXh0LXRhZy1sZXZlbC1wcmltYXJ5Om5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKTpmb2N1cyA+IC5uZXh0LXRhZy1jbG9zZS1idG4ge1xcbiAgICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuICBbZGlzYWJsZWRdLm5leHQtdGFnLWRlZmF1bHQubmV4dC10YWctbGV2ZWwtcHJpbWFyeSwgW2Rpc2FibGVkXS5uZXh0LXRhZy1jbG9zYWJsZS5uZXh0LXRhZy1sZXZlbC1wcmltYXJ5LCAuZGlzYWJsZWQubmV4dC10YWctZGVmYXVsdC5uZXh0LXRhZy1sZXZlbC1wcmltYXJ5LCAuZGlzYWJsZWQubmV4dC10YWctY2xvc2FibGUubmV4dC10YWctbGV2ZWwtcHJpbWFyeSB7XFxuICAgIGNvbG9yOiAjQ0NDQ0NDO1xcbiAgICBib3JkZXItY29sb3I6ICNGN0Y4RkE7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y4RkE7IH1cXG4gICAgW2Rpc2FibGVkXS5uZXh0LXRhZy1kZWZhdWx0Lm5leHQtdGFnLWxldmVsLXByaW1hcnkgPiAubmV4dC10YWctY2xvc2UtYnRuLCBbZGlzYWJsZWRdLm5leHQtdGFnLWNsb3NhYmxlLm5leHQtdGFnLWxldmVsLXByaW1hcnkgPiAubmV4dC10YWctY2xvc2UtYnRuLCAuZGlzYWJsZWQubmV4dC10YWctZGVmYXVsdC5uZXh0LXRhZy1sZXZlbC1wcmltYXJ5ID4gLm5leHQtdGFnLWNsb3NlLWJ0biwgLmRpc2FibGVkLm5leHQtdGFnLWNsb3NhYmxlLm5leHQtdGFnLWxldmVsLXByaW1hcnkgPiAubmV4dC10YWctY2xvc2UtYnRuIHtcXG4gICAgICBjb2xvcjogI0NDQ0NDQzsgfVxcbiAgLm5leHQtdGFnLWRlZmF1bHQubmV4dC10YWctbGV2ZWwtcHJpbWFyeSA+IC5uZXh0LXRhZy1jbG9zZS1idG4sIC5uZXh0LXRhZy1jbG9zYWJsZS5uZXh0LXRhZy1sZXZlbC1wcmltYXJ5ID4gLm5leHQtdGFnLWNsb3NlLWJ0biB7XFxuICAgIGNvbG9yOiAjNjY2NjY2OyB9XFxuXFxuLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1wcmltYXJ5IHtcXG4gIGNvbG9yOiAjNjY2NjY2O1xcbiAgYm9yZGVyLWNvbG9yOiAjRUJFQ0YwO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI0VCRUNGMDsgfVxcbiAgLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1wcmltYXJ5Om5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKTpob3ZlciwgLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1wcmltYXJ5Om5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKS5ob3ZlciwgLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1wcmltYXJ5Om5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKTpmb2N1cyB7XFxuICAgIGNvbG9yOiAjMzMzMzMzO1xcbiAgICBib3JkZXItY29sb3I6ICNFMkU0RTg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNFMkU0RTg7IH1cXG4gICAgLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1wcmltYXJ5Om5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKTpob3ZlciA+IC5uZXh0LXRhZy1jbG9zZS1idG4sIC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtcHJpbWFyeTpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSkuaG92ZXIgPiAubmV4dC10YWctY2xvc2UtYnRuLCAubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLWxldmVsLXByaW1hcnk6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOmZvY3VzID4gLm5leHQtdGFnLWNsb3NlLWJ0biB7XFxuICAgICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gIFtkaXNhYmxlZF0ubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLWxldmVsLXByaW1hcnksIC5kaXNhYmxlZC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtcHJpbWFyeSB7XFxuICAgIGNvbG9yOiAjQ0NDQ0NDO1xcbiAgICBib3JkZXItY29sb3I6ICNGN0Y4RkE7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y4RkE7IH1cXG4gICAgW2Rpc2FibGVkXS5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtcHJpbWFyeSA+IC5uZXh0LXRhZy1jbG9zZS1idG4sIC5kaXNhYmxlZC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtcHJpbWFyeSA+IC5uZXh0LXRhZy1jbG9zZS1idG4ge1xcbiAgICAgIGNvbG9yOiAjQ0NDQ0NDOyB9XFxuICAubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLWxldmVsLXByaW1hcnkgPiAubmV4dC10YWctY2xvc2UtYnRuIHtcXG4gICAgY29sb3I6ICM2NjY2NjY7IH1cXG5cXG4ubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLWxldmVsLXByaW1hcnkuY2hlY2tlZCB7XFxuICBjb2xvcjogI0ZGRkZGRjtcXG4gIGJvcmRlci1jb2xvcjogIzU1ODRGRjtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM1NTg0RkY7IH1cXG4gIC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtcHJpbWFyeS5jaGVja2VkOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKTpob3ZlciwgLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1wcmltYXJ5LmNoZWNrZWQ6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pLmhvdmVyLCAubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLWxldmVsLXByaW1hcnkuY2hlY2tlZDpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSk6Zm9jdXMge1xcbiAgICBjb2xvcjogI0ZGRkZGRjtcXG4gICAgYm9yZGVyLWNvbG9yOiAjM0U3MUY3O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjM0U3MUY3OyB9XFxuICAgIC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtcHJpbWFyeS5jaGVja2VkOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKTpob3ZlciA+IC5uZXh0LXRhZy1jbG9zZS1idG4sIC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtcHJpbWFyeS5jaGVja2VkOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKS5ob3ZlciA+IC5uZXh0LXRhZy1jbG9zZS1idG4sIC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtcHJpbWFyeS5jaGVja2VkOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKTpmb2N1cyA+IC5uZXh0LXRhZy1jbG9zZS1idG4ge1xcbiAgICAgIGNvbG9yOiAjRkZGRkZGOyB9XFxuICAubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLWxldmVsLXByaW1hcnkuY2hlY2tlZCA+IC5uZXh0LXRhZy1jbG9zZS1idG4ge1xcbiAgICBjb2xvcjogI0ZGRkZGRjsgfVxcblxcbi5uZXh0LXRhZy1kZWZhdWx0Lm5leHQtdGFnLWxldmVsLW5vcm1hbCB7XFxuICBjb2xvcjogIzY2NjY2NjtcXG4gIGJvcmRlci1jb2xvcjogI0M0QzZDRjtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuICAubmV4dC10YWctZGVmYXVsdC5uZXh0LXRhZy1sZXZlbC1ub3JtYWw6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOmhvdmVyLCAubmV4dC10YWctZGVmYXVsdC5uZXh0LXRhZy1sZXZlbC1ub3JtYWw6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pLmhvdmVyLCAubmV4dC10YWctZGVmYXVsdC5uZXh0LXRhZy1sZXZlbC1ub3JtYWw6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOmZvY3VzIHtcXG4gICAgY29sb3I6ICMzMzMzMzM7XFxuICAgIGJvcmRlci1jb2xvcjogI0EwQTJBRDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gICAgLm5leHQtdGFnLWRlZmF1bHQubmV4dC10YWctbGV2ZWwtbm9ybWFsOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKTpob3ZlciA+IC5uZXh0LXRhZy1jbG9zZS1idG4sIC5uZXh0LXRhZy1kZWZhdWx0Lm5leHQtdGFnLWxldmVsLW5vcm1hbDpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSkuaG92ZXIgPiAubmV4dC10YWctY2xvc2UtYnRuLCAubmV4dC10YWctZGVmYXVsdC5uZXh0LXRhZy1sZXZlbC1ub3JtYWw6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOmZvY3VzID4gLm5leHQtdGFnLWNsb3NlLWJ0biB7XFxuICAgICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gIFtkaXNhYmxlZF0ubmV4dC10YWctZGVmYXVsdC5uZXh0LXRhZy1sZXZlbC1ub3JtYWwsIC5kaXNhYmxlZC5uZXh0LXRhZy1kZWZhdWx0Lm5leHQtdGFnLWxldmVsLW5vcm1hbCB7XFxuICAgIGNvbG9yOiAjQ0NDQ0NDO1xcbiAgICBib3JkZXItY29sb3I6ICNFNkU3RUI7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y4RkE7IH1cXG4gICAgW2Rpc2FibGVkXS5uZXh0LXRhZy1kZWZhdWx0Lm5leHQtdGFnLWxldmVsLW5vcm1hbCA+IC5uZXh0LXRhZy1jbG9zZS1idG4sIC5kaXNhYmxlZC5uZXh0LXRhZy1kZWZhdWx0Lm5leHQtdGFnLWxldmVsLW5vcm1hbCA+IC5uZXh0LXRhZy1jbG9zZS1idG4ge1xcbiAgICAgIGNvbG9yOiAjQ0NDQ0NDOyB9XFxuICAubmV4dC10YWctZGVmYXVsdC5uZXh0LXRhZy1sZXZlbC1ub3JtYWwgPiAubmV4dC10YWctY2xvc2UtYnRuIHtcXG4gICAgY29sb3I6ICM2NjY2NjY7IH1cXG5cXG4ubmV4dC10YWctY2xvc2FibGUubmV4dC10YWctbGV2ZWwtbm9ybWFsIHtcXG4gIGNvbG9yOiAjNjY2NjY2O1xcbiAgYm9yZGVyLWNvbG9yOiAjQzRDNkNGO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gIC5uZXh0LXRhZy1jbG9zYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWw6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOmhvdmVyLCAubmV4dC10YWctY2xvc2FibGUubmV4dC10YWctbGV2ZWwtbm9ybWFsOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKS5ob3ZlciwgLm5leHQtdGFnLWNsb3NhYmxlLm5leHQtdGFnLWxldmVsLW5vcm1hbDpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSk6Zm9jdXMge1xcbiAgICBjb2xvcjogIzMzMzMzMztcXG4gICAgYm9yZGVyLWNvbG9yOiAjQTBBMkFEO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbiAgICAubmV4dC10YWctY2xvc2FibGUubmV4dC10YWctbGV2ZWwtbm9ybWFsOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKTpob3ZlciA+IC5uZXh0LXRhZy1jbG9zZS1idG4sIC5uZXh0LXRhZy1jbG9zYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWw6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pLmhvdmVyID4gLm5leHQtdGFnLWNsb3NlLWJ0biwgLm5leHQtdGFnLWNsb3NhYmxlLm5leHQtdGFnLWxldmVsLW5vcm1hbDpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSk6Zm9jdXMgPiAubmV4dC10YWctY2xvc2UtYnRuIHtcXG4gICAgICBjb2xvcjogIzMzMzMzMzsgfVxcbiAgW2Rpc2FibGVkXS5uZXh0LXRhZy1jbG9zYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWwsIC5kaXNhYmxlZC5uZXh0LXRhZy1jbG9zYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWwge1xcbiAgICBjb2xvcjogI0NDQ0NDQztcXG4gICAgYm9yZGVyLWNvbG9yOiAjRTZFN0VCO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbiAgICBbZGlzYWJsZWRdLm5leHQtdGFnLWNsb3NhYmxlLm5leHQtdGFnLWxldmVsLW5vcm1hbCA+IC5uZXh0LXRhZy1jbG9zZS1idG4sIC5kaXNhYmxlZC5uZXh0LXRhZy1jbG9zYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWwgPiAubmV4dC10YWctY2xvc2UtYnRuIHtcXG4gICAgICBjb2xvcjogI0NDQ0NDQzsgfVxcbiAgLm5leHQtdGFnLWNsb3NhYmxlLm5leHQtdGFnLWxldmVsLW5vcm1hbCA+IC5uZXh0LXRhZy1jbG9zZS1idG4ge1xcbiAgICBjb2xvcjogIzY2NjY2NjsgfVxcblxcbi5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtbm9ybWFsLmNoZWNrZWQsIC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtc2Vjb25kYXJ5LmNoZWNrZWQge1xcbiAgY29sb3I6ICM1NTg0RkY7XFxuICBib3JkZXItY29sb3I6ICM1NTg0RkY7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbiAgLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWwuY2hlY2tlZDpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSk6aG92ZXIsIC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtc2Vjb25kYXJ5LmNoZWNrZWQ6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOmhvdmVyLCAubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLWxldmVsLW5vcm1hbC5jaGVja2VkOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKS5ob3ZlciwgLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1zZWNvbmRhcnkuY2hlY2tlZDpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSkuaG92ZXIsIC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtbm9ybWFsLmNoZWNrZWQ6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOmZvY3VzLCAubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLWxldmVsLXNlY29uZGFyeS5jaGVja2VkOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKTpmb2N1cyB7XFxuICAgIGNvbG9yOiAjM0U3MUY3O1xcbiAgICBib3JkZXItY29sb3I6ICMzRTcxRjc7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuXFxuLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1zZWNvbmRhcnkuY2hlY2tlZDpiZWZvcmUge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgY29udGVudDogXFxcIlxcXCI7XFxuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM1NTg0RkY7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXG4gICAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7IH1cXG5cXG4ubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLWxldmVsLXNlY29uZGFyeS5jaGVja2VkOmFmdGVyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGZvbnQtZmFtaWx5OiBOZXh0SWNvbjtcXG4gIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbiAgY29udGVudDogXFxcIlxcXFxFNjMyXFxcIjtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLjYpO1xcbiAgICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDAuNik7XFxuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC42KTtcXG4gIGNvbG9yOiAjRkZGRkZGOyB9XFxuXFxuLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1zZWNvbmRhcnkuY2hlY2tlZDpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSk6aG92ZXI6YmVmb3JlLCAubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLWxldmVsLXNlY29uZGFyeS5jaGVja2VkOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKS5ob3ZlcjpiZWZvcmUsIC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtc2Vjb25kYXJ5LmNoZWNrZWQ6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOmZvY3VzOmJlZm9yZSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjM0U3MUY3OyB9XFxuXFxuLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1zZWNvbmRhcnkuY2hlY2tlZDpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSk6aG92ZXI6YWZ0ZXIsIC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtc2Vjb25kYXJ5LmNoZWNrZWQ6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pLmhvdmVyOmFmdGVyLCAubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLWxldmVsLXNlY29uZGFyeS5jaGVja2VkOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKTpmb2N1czphZnRlciB7XFxuICBjb2xvcjogI0ZGRkZGRjsgfVxcblxcbltkaXNhYmxlZF0ubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLWxldmVsLXNlY29uZGFyeS5jaGVja2VkOmJlZm9yZSwgLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1zZWNvbmRhcnkuY2hlY2tlZDpkaXNhYmxlZDpiZWZvcmUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI0U2RTdFQjsgfVxcblxcbltkaXNhYmxlZF0ubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLWxldmVsLXNlY29uZGFyeS5jaGVja2VkOmFmdGVyLCAubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLWxldmVsLXNlY29uZGFyeS5jaGVja2VkOmRpc2FibGVkOmFmdGVyIHtcXG4gIGNvbG9yOiAjRkZGRkZGOyB9XFxuXFxuLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWwge1xcbiAgY29sb3I6ICM2NjY2NjY7XFxuICBib3JkZXItY29sb3I6ICNDNEM2Q0Y7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbiAgLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWw6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOmhvdmVyLCAubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLWxldmVsLW5vcm1hbDpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSkuaG92ZXIsIC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtbm9ybWFsOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKTpmb2N1cyB7XFxuICAgIGNvbG9yOiAjMzMzMzMzO1xcbiAgICBib3JkZXItY29sb3I6ICNDNEM2Q0Y7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuICBbZGlzYWJsZWRdLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWwsIC5kaXNhYmxlZC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtbm9ybWFsIHtcXG4gICAgY29sb3I6ICNDQ0NDQ0M7XFxuICAgIGJvcmRlci1jb2xvcjogI0U2RTdFQjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjhGQTsgfVxcblxcbi5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtbm9ybWFsLmNoZWNrZWQ6YmVmb3JlIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNTU4NEZGO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxuICAgICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpOyB9XFxuXFxuLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWwuY2hlY2tlZDphZnRlciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBmb250LWZhbWlseTogTmV4dEljb247XFxuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcRTYzMlxcXCI7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC42KTtcXG4gICAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgwLjYpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNik7XFxuICBjb2xvcjogI0ZGRkZGRjsgfVxcblxcbi5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtbm9ybWFsLmNoZWNrZWQ6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOmhvdmVyOmJlZm9yZSwgLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWwuY2hlY2tlZDpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSkuaG92ZXI6YmVmb3JlLCAubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLWxldmVsLW5vcm1hbC5jaGVja2VkOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKTpmb2N1czpiZWZvcmUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzNFNzFGNzsgfVxcblxcbi5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtbm9ybWFsLmNoZWNrZWQ6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOmhvdmVyOmFmdGVyLCAubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLWxldmVsLW5vcm1hbC5jaGVja2VkOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKS5ob3ZlcjphZnRlciwgLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWwuY2hlY2tlZDpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSk6Zm9jdXM6YWZ0ZXIge1xcbiAgY29sb3I6ICNGRkZGRkY7IH1cXG5cXG5bZGlzYWJsZWRdLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWwuY2hlY2tlZDpiZWZvcmUsIC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtbm9ybWFsLmNoZWNrZWQ6ZGlzYWJsZWQ6YmVmb3JlIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNFNkU3RUI7IH1cXG5cXG5bZGlzYWJsZWRdLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWwuY2hlY2tlZDphZnRlciwgLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWwuY2hlY2tlZDpkaXNhYmxlZDphZnRlciB7XFxuICBjb2xvcjogI0ZGRkZGRjsgfVxcblxcbi5uZXh0LXRhZy1jbG9zYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWw6YmVmb3JlIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjQzRDNkNGO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxuICAgICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpOyB9XFxuXFxuLm5leHQtdGFnLWNsb3NhYmxlLm5leHQtdGFnLWxldmVsLW5vcm1hbDphZnRlciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBmb250LWZhbWlseTogTmV4dEljb247XFxuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcRTYyNlxcXCI7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC42KTtcXG4gICAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgwLjYpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNik7XFxuICBjb2xvcjogI0ZGRkZGRjsgfVxcblxcbi5uZXh0LXRhZy1jbG9zYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWw6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOmhvdmVyOmJlZm9yZSwgLm5leHQtdGFnLWNsb3NhYmxlLm5leHQtdGFnLWxldmVsLW5vcm1hbDpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSkuaG92ZXI6YmVmb3JlLCAubmV4dC10YWctY2xvc2FibGUubmV4dC10YWctbGV2ZWwtbm9ybWFsOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKTpmb2N1czpiZWZvcmUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI0EwQTJBRDsgfVxcblxcbi5uZXh0LXRhZy1jbG9zYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWw6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOmhvdmVyOmFmdGVyLCAubmV4dC10YWctY2xvc2FibGUubmV4dC10YWctbGV2ZWwtbm9ybWFsOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKS5ob3ZlcjphZnRlciwgLm5leHQtdGFnLWNsb3NhYmxlLm5leHQtdGFnLWxldmVsLW5vcm1hbDpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSk6Zm9jdXM6YWZ0ZXIge1xcbiAgY29sb3I6ICNGRkZGRkY7IH1cXG5cXG5bZGlzYWJsZWRdLm5leHQtdGFnLWNsb3NhYmxlLm5leHQtdGFnLWxldmVsLW5vcm1hbDpiZWZvcmUsIC5uZXh0LXRhZy1jbG9zYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWw6ZGlzYWJsZWQ6YmVmb3JlIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNFNkU3RUI7IH1cXG5cXG5bZGlzYWJsZWRdLm5leHQtdGFnLWNsb3NhYmxlLm5leHQtdGFnLWxldmVsLW5vcm1hbDphZnRlciwgLm5leHQtdGFnLWNsb3NhYmxlLm5leHQtdGFnLWxldmVsLW5vcm1hbDpkaXNhYmxlZDphZnRlciB7XFxuICBjb2xvcjogI0ZGRkZGRjsgfVxcblxcbi5uZXh0LSB7XFxuICAvKiBBbmltYXRpb24gKi9cXG4gIC8qIC0tLS0tLS0tLS0tICovIH1cXG4gIC5uZXh0LXRhZy1ncm91cCAubmV4dC10YWctbWVkaXVtLFxcbiAgLm5leHQtdGFnLWdyb3VwIC5uZXh0LXRhZy1sYXJnZSB7XFxuICAgIG1hcmdpbi1yaWdodDogOHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiA4cHg7IH1cXG4gIC5uZXh0LXRhZy1ncm91cCAubmV4dC10YWctc21hbGwge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDRweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogNHB4OyB9XFxuICAubmV4dC10YWcge1xcbiAgICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICBtYXgtd2lkdGg6IDEwMCU7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgIGJvcmRlci13aWR0aDogMXB4O1xcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICAgIC13ZWJraXQtYm94LXNoYWRvdzogbm9uZTtcXG4gICAgICAgICAgICBib3gtc2hhZG93OiBub25lO1xcbiAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgICAvKiDlj6/phY3nva4/Pz8gKi9cXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgMC4ycyBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICAgIHRyYW5zaXRpb246IGFsbCAwLjJzIGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gICAgZm9udC1zaXplOiAwO1xcbiAgICBvdXRsaW5lOiAwOyB9XFxuICAgIC5uZXh0LXRhZyAqLFxcbiAgICAubmV4dC10YWcgKjpiZWZvcmUsXFxuICAgIC5uZXh0LXRhZyAqOmFmdGVyIHtcXG4gICAgICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XFxuICAgIC5uZXh0LXRhZyA+IC5uZXh0LXRhZy1ib2R5IHtcXG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgICBtYXgtd2lkdGg6IDEwMCU7XFxuICAgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgICAvKiDnlKjmiLfmiYvliqjkvKDnmoQgaWNvbiDnmoTlpKflsI/kuZ/kv53mjIHkuIDoh7TvvJ8gKi8gfVxcbiAgICAgIC5uZXh0LXRhZyA+IC5uZXh0LXRhZy1ib2R5ID4gYSB7XFxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICBjb2xvcjogaW5oZXJpdDsgfVxcbiAgICAgICAgLm5leHQtdGFnID4gLm5leHQtdGFnLWJvZHkgPiBhOmJlZm9yZSB7XFxuICAgICAgICAgIGNvbnRlbnQ6IFxcXCIgXFxcIjtcXG4gICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgICAgICAgdG9wOiAwO1xcbiAgICAgICAgICBsZWZ0OiAwO1xcbiAgICAgICAgICByaWdodDogMDtcXG4gICAgICAgICAgYm90dG9tOiAwOyB9XFxuICAgICAgLm5leHQtdGFnID4gLm5leHQtdGFnLWJvZHkgLm5leHQtaWNvbiB7XFxuICAgICAgICBsaW5lLWhlaWdodDogMTtcXG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IH1cXG4gICAgICAgIC5uZXh0LXRhZyA+IC5uZXh0LXRhZy1ib2R5IC5uZXh0LWljb246YmVmb3JlIHtcXG4gICAgICAgICAgZm9udC1zaXplOiBpbmhlcml0OyB9XFxuICAgIC5uZXh0LXRhZy5uZXh0LXRhZy1ib2R5LXBvaW50ZXIge1xcbiAgICAgIGN1cnNvcjogcG9pbnRlcjsgfVxcbiAgICAubmV4dC10YWdbZGlzYWJsZWRdLCAubmV4dC10YWcuZGlzYWJsZWQge1xcbiAgICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxuICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7IH1cXG4gIC5uZXh0LXRhZy1sYXJnZSB7XFxuICAgIGhlaWdodDogNDBweDtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgbGluZS1oZWlnaHQ6IDM4cHg7XFxuICAgIGZvbnQtc2l6ZTogMDsgfVxcbiAgICAubmV4dC10YWctbGFyZ2UgPiAubmV4dC10YWctYm9keSB7XFxuICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgIHBhZGRpbmc6IDAgMTZweDsgfVxcbiAgICAubmV4dC10YWctbGFyZ2UubmV4dC10YWctY2xvc2FibGUgPiAubmV4dC10YWctYm9keSB7XFxuICAgICAgcGFkZGluZzogMCAwIDAgMTZweDsgfVxcbiAgICAubmV4dC10YWctbGFyZ2VbZGlyPXJ0bF0ubmV4dC10YWctY2xvc2FibGUgPiAubmV4dC10YWctYm9keSB7XFxuICAgICAgcGFkZGluZzogMCAxNnB4IDAgMDsgfVxcbiAgICAubmV4dC10YWctbGFyZ2UgPiAubmV4dC10YWctY2xvc2UtYnRuIHtcXG4gICAgICBtYXJnaW4tbGVmdDogOXB4O1xcbiAgICAgIHBhZGRpbmctcmlnaHQ6IDE2cHg7IH1cXG4gICAgICAubmV4dC10YWctbGFyZ2UgPiAubmV4dC10YWctY2xvc2UtYnRuIC5uZXh0LWljb246YmVmb3JlIHtcXG4gICAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgLm5leHQtdGFnLWxhcmdlW2Rpcj1ydGxdID4gLm5leHQtdGFnLWNsb3NlLWJ0biB7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiA5cHg7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgICAgcGFkZGluZy1yaWdodDogMDtcXG4gICAgICBwYWRkaW5nLWxlZnQ6IDE2cHg7IH1cXG4gIC5uZXh0LXRhZy1tZWRpdW0ge1xcbiAgICBoZWlnaHQ6IDI4cHg7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIGxpbmUtaGVpZ2h0OiAyNnB4O1xcbiAgICBmb250LXNpemU6IDA7IH1cXG4gICAgLm5leHQtdGFnLW1lZGl1bSA+IC5uZXh0LXRhZy1ib2R5IHtcXG4gICAgICBmb250LXNpemU6IDE0cHg7XFxuICAgICAgcGFkZGluZzogMCAxMnB4OyB9XFxuICAgIC5uZXh0LXRhZy1tZWRpdW0ubmV4dC10YWctY2xvc2FibGUgPiAubmV4dC10YWctYm9keSB7XFxuICAgICAgcGFkZGluZzogMCAwIDAgMTJweDsgfVxcbiAgICAubmV4dC10YWctbWVkaXVtW2Rpcj1ydGxdLm5leHQtdGFnLWNsb3NhYmxlID4gLm5leHQtdGFnLWJvZHkge1xcbiAgICAgIHBhZGRpbmc6IDAgMTJweCAwIDA7IH1cXG4gICAgLm5leHQtdGFnLW1lZGl1bSA+IC5uZXh0LXRhZy1jbG9zZS1idG4ge1xcbiAgICAgIG1hcmdpbi1sZWZ0OiA2cHg7XFxuICAgICAgcGFkZGluZy1yaWdodDogMTJweDsgfVxcbiAgICAgIC5uZXh0LXRhZy1tZWRpdW0gPiAubmV4dC10YWctY2xvc2UtYnRuIC5uZXh0LWljb246YmVmb3JlIHtcXG4gICAgICAgIHdpZHRoOiA4cHg7XFxuICAgICAgICBmb250LXNpemU6IDhweDtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgICAgQG1lZGlhIGFsbCBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMCkgYW5kIChtaW4tcmVzb2x1dGlvbjogMC4wMDFkcGNtKSB7XFxuICAgICAgICAubmV4dC10YWctbWVkaXVtID4gLm5leHQtdGFnLWNsb3NlLWJ0biAubmV4dC1pY29uIHtcXG4gICAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuNSk7XFxuICAgICAgICAgICAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgwLjUpO1xcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC41KTtcXG4gICAgICAgICAgbWFyZ2luLWxlZnQ6IC00cHg7XFxuICAgICAgICAgIG1hcmdpbi1yaWdodDogLTRweDsgfVxcbiAgICAgICAgICAubmV4dC10YWctbWVkaXVtID4gLm5leHQtdGFnLWNsb3NlLWJ0biAubmV4dC1pY29uOmJlZm9yZSB7XFxuICAgICAgICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxNnB4OyB9IH1cXG4gICAgLm5leHQtdGFnLW1lZGl1bVtkaXI9cnRsXSA+IC5uZXh0LXRhZy1jbG9zZS1idG4ge1xcbiAgICAgIG1hcmdpbi1yaWdodDogNnB4O1xcbiAgICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICAgIHBhZGRpbmctcmlnaHQ6IDA7XFxuICAgICAgcGFkZGluZy1sZWZ0OiAxMnB4OyB9XFxuICAubmV4dC10YWctc21hbGwge1xcbiAgICBoZWlnaHQ6IDIwcHg7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIGxpbmUtaGVpZ2h0OiAxOHB4O1xcbiAgICBmb250LXNpemU6IDA7IH1cXG4gICAgLm5leHQtdGFnLXNtYWxsID4gLm5leHQtdGFnLWJvZHkge1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBwYWRkaW5nOiAwIDhweDsgfVxcbiAgICAubmV4dC10YWctc21hbGwubmV4dC10YWctY2xvc2FibGUgPiAubmV4dC10YWctYm9keSB7XFxuICAgICAgcGFkZGluZzogMCAwIDAgOHB4OyB9XFxuICAgIC5uZXh0LXRhZy1zbWFsbFtkaXI9cnRsXS5uZXh0LXRhZy1jbG9zYWJsZSA+IC5uZXh0LXRhZy1ib2R5IHtcXG4gICAgICBwYWRkaW5nOiAwIDhweCAwIDA7IH1cXG4gICAgLm5leHQtdGFnLXNtYWxsID4gLm5leHQtdGFnLWNsb3NlLWJ0biB7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gICAgICBwYWRkaW5nLXJpZ2h0OiA4cHg7IH1cXG4gICAgICAubmV4dC10YWctc21hbGwgPiAubmV4dC10YWctY2xvc2UtYnRuIC5uZXh0LWljb246YmVmb3JlIHtcXG4gICAgICAgIHdpZHRoOiA4cHg7XFxuICAgICAgICBmb250LXNpemU6IDhweDtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgICAgQG1lZGlhIGFsbCBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMCkgYW5kIChtaW4tcmVzb2x1dGlvbjogMC4wMDFkcGNtKSB7XFxuICAgICAgICAubmV4dC10YWctc21hbGwgPiAubmV4dC10YWctY2xvc2UtYnRuIC5uZXh0LWljb24ge1xcbiAgICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC41KTtcXG4gICAgICAgICAgICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDAuNSk7XFxuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjUpO1xcbiAgICAgICAgICBtYXJnaW4tbGVmdDogLTRweDtcXG4gICAgICAgICAgbWFyZ2luLXJpZ2h0OiAtNHB4OyB9XFxuICAgICAgICAgIC5uZXh0LXRhZy1zbWFsbCA+IC5uZXh0LXRhZy1jbG9zZS1idG4gLm5leHQtaWNvbjpiZWZvcmUge1xcbiAgICAgICAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTZweDsgfSB9XFxuICAgIC5uZXh0LXRhZy1zbWFsbFtkaXI9cnRsXSA+IC5uZXh0LXRhZy1jbG9zZS1idG4ge1xcbiAgICAgIG1hcmdpbi1yaWdodDogNHB4O1xcbiAgICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICAgIHBhZGRpbmctcmlnaHQ6IDA7XFxuICAgICAgcGFkZGluZy1sZWZ0OiA4cHg7IH1cXG4gIC5uZXh0LXRhZy1kZWZhdWx0IHtcXG4gICAgY3Vyc29yOiBkZWZhdWx0OyB9XFxuICAubmV4dC10YWctY2xvc2FibGUge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG4gICAgLm5leHQtdGFnLWNsb3NhYmxlID4gLm5leHQtdGFnLWNsb3NlLWJ0biB7XFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICBjdXJzb3I6IHBvaW50ZXI7IH1cXG4gICAgLm5leHQtdGFnLWNsb3NhYmxlLm5leHQtdGFnLWxldmVsLW5vcm1hbFtkaXNhYmxlZF0sIC5uZXh0LXRhZy1jbG9zYWJsZS5uZXh0LXRhZy1sZXZlbC1ub3JtYWwuZGlzYWJsZWQge1xcbiAgICAgIGNvbG9yOiAjQ0NDQ0NDO1xcbiAgICAgIGJvcmRlci1jb2xvcjogI0U2RTdFQjtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGOEZBOyB9XFxuICAubmV4dC10YWctY2hlY2thYmxlIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGJvcmRlci1yYWRpdXM6IDNweDsgfVxcbiAgICAubmV4dC10YWctY2hlY2thYmxlLmNoZWNrZWQ6YmVmb3JlIHtcXG4gICAgICAtd2Via2l0LWFuaW1hdGlvbjogZmFkZUluUmlnaHRGb3JUYWcgMC40cyBjdWJpYy1iZXppZXIoMC43OCwgMC4xNCwgMC4xNSwgMC44Nik7XFxuICAgICAgICAgICAgICBhbmltYXRpb246IGZhZGVJblJpZ2h0Rm9yVGFnIDAuNHMgY3ViaWMtYmV6aWVyKDAuNzgsIDAuMTQsIDAuMTUsIDAuODYpOyB9XFxuICAgIC5uZXh0LXRhZy1jaGVja2FibGUuY2hlY2tlZDphZnRlciB7XFxuICAgICAgLXdlYmtpdC1hbmltYXRpb246IHpvb21JbiAwLjRzIGN1YmljLWJlemllcigwLjc4LCAwLjE0LCAwLjE1LCAwLjg2KTtcXG4gICAgICAgICAgICAgIGFuaW1hdGlvbjogem9vbUluIDAuNHMgY3ViaWMtYmV6aWVyKDAuNzgsIDAuMTQsIDAuMTUsIDAuODYpOyB9XFxuICAgIC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctc21hbGw6bm90KC5uZXh0LXRhZy1sZXZlbC1wcmltYXJ5KTpiZWZvcmUge1xcbiAgICAgIHJpZ2h0OiAtMTBweDtcXG4gICAgICBib3R0b206IC0xMHB4O1xcbiAgICAgIHdpZHRoOiAyMHB4O1xcbiAgICAgIGhlaWdodDogMjBweDsgfVxcbiAgICAubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLXNtYWxsOm5vdCgubmV4dC10YWctbGV2ZWwtcHJpbWFyeSk6YWZ0ZXIge1xcbiAgICAgIGZvbnQtc2l6ZTogOHB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiA4cHg7XFxuICAgICAgcmlnaHQ6IDA7XFxuICAgICAgYm90dG9tOiAwOyB9XFxuICAgIC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbWVkaXVtOm5vdCgubmV4dC10YWctbGV2ZWwtcHJpbWFyeSk6YmVmb3JlIHtcXG4gICAgICByaWdodDogLTE0cHg7XFxuICAgICAgYm90dG9tOiAtMTRweDtcXG4gICAgICB3aWR0aDogMjhweDtcXG4gICAgICBoZWlnaHQ6IDI4cHg7IH1cXG4gICAgLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1tZWRpdW06bm90KC5uZXh0LXRhZy1sZXZlbC1wcmltYXJ5KTphZnRlciB7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiAxMnB4O1xcbiAgICAgIHJpZ2h0OiAwO1xcbiAgICAgIGJvdHRvbTogMDsgfVxcbiAgICAubmV4dC10YWctY2hlY2thYmxlLm5leHQtdGFnLWxhcmdlOm5vdCgubmV4dC10YWctbGV2ZWwtcHJpbWFyeSk6YmVmb3JlIHtcXG4gICAgICByaWdodDogLTE4cHg7XFxuICAgICAgYm90dG9tOiAtMThweDtcXG4gICAgICB3aWR0aDogMzZweDtcXG4gICAgICBoZWlnaHQ6IDM2cHg7IH1cXG4gICAgLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sYXJnZTpub3QoLm5leHQtdGFnLWxldmVsLXByaW1hcnkpOmFmdGVyIHtcXG4gICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IDE2cHg7XFxuICAgICAgcmlnaHQ6IDA7XFxuICAgICAgYm90dG9tOiAwOyB9XFxuICAgIC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtcHJpbWFyeVtkaXNhYmxlZF0sIC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtcHJpbWFyeS5kaXNhYmxlZCB7XFxuICAgICAgY29sb3I6ICNDQ0NDQ0M7XFxuICAgICAgLyogJHRhZy10ZXh0LWNvbG9yLWRpc2FibGVkOyAqL1xcbiAgICAgIGJvcmRlci1jb2xvcjogI0Y3RjhGQTtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGOEZBOyB9XFxuICAgIC5uZXh0LXRhZy1jaGVja2FibGUubmV4dC10YWctbGV2ZWwtc2Vjb25kYXJ5W2Rpc2FibGVkXSwgLm5leHQtdGFnLWNoZWNrYWJsZS5uZXh0LXRhZy1sZXZlbC1zZWNvbmRhcnkuZGlzYWJsZWQge1xcbiAgICAgIGNvbG9yOiAjQ0NDQ0NDO1xcbiAgICAgIGJvcmRlci1jb2xvcjogI0U2RTdFQjtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGOEZBOyB9XFxuICAubmV4dC10YWctem9vbS1lbnRlciwgLm5leHQtdGFnLXpvb20tYXBwZWFyIHtcXG4gICAgLXdlYmtpdC1hbmltYXRpb246IGZhZGVJbkxlZnQgMC40cyBjdWJpYy1iZXppZXIoMC43OCwgMC4xNCwgMC4xNSwgMC44Nik7XFxuICAgICAgICAgICAgYW5pbWF0aW9uOiBmYWRlSW5MZWZ0IDAuNHMgY3ViaWMtYmV6aWVyKDAuNzgsIDAuMTQsIDAuMTUsIDAuODYpO1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICAgICAgICAgICAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDsgfVxcbiAgLm5leHQtdGFnLXpvb20tbGVhdmUge1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbjogem9vbU91dCAuM3MgZWFzZS1pbjtcXG4gICAgICAgICAgICBhbmltYXRpb246IHpvb21PdXQgLjNzIGVhc2UtaW47XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gICAgICAgICAgICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoOyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyPz9yZWYtLTItMSEuL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliPz9yZWYtLTItMiEuL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYiEuL3NyYy90YWcvbWFpbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBjaGFyc2V0IFxcXCJVVEYtOFxcXCI7XFxuLyoqXFxuICog5bC65a+4IOWfuuehgOWwuuWvuFxcbiAqIOWRveWQjeiDveWcqOivreS5ieeahOWJjeaPkOS4i+eugOWNleWwseWwvemHj+eugOWNlSwg6L+Z6YeM5Y+v5Lul5pivIHNpemUtMngsIHNwYWNlLTJ4LCBzaXplLWJhc2UgLi4uXFxuICog5LiN6L+H5Y+v5Lul5Zyo6K+t5LmJ55qE5YmN5o+Q5LiL5YGa55qE5pu057K+566A5LiA5LqbLCDkuo7mmK/nlKjkuoZzMiwgczHnrYlcXG4gKiDlj6/nlKjlj5jph486IGAkczEgLSAkczhgXFxuICogQGV4YW1wbGUgc2NzcyAtIOS9v+eUqFxcbiAqICAgLmVsZW1lbnQge1xcbiAqICAgICBwYWRkaW5nOiAkczEgIWRlZmF1bHQ7XFxuICogICB9XFxuICpcXG4gKiBAZXhhbXBsZSBjc3MgLSBDU1Mg6L6T5Ye6XFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6IDRweCAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKi9cXG4ubmV4dC1zZWxlY3Qge1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgZm9udC1zaXplOiAwO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIC8qIFNlbGVjdCB0cmlnZ2VyICovXFxuICAvKiDlvLnlsYIgKi9cXG4gIC8qIOWFqOmAieaMiemSriAqL1xcbiAgLyogLS0tLS0tLS0tLS0tLS0gSUUgcG9seWZpbGwgLS0tLS0tLS0tLS0tLS0gKi9cXG4gIC8qIOagueaNruacgOaWsOeahOaVsOaNru+8jOWcqOS4reWbve+8jFBDIOerr+eahCBJRTkg5Lu96aKd5Li6IDIl77yMICovXFxuICAvKiDmiYDku6XkuI3lupTor6Xlm6DkuLogSUU5IOiAjOS4jeS9v+eUqCBmbGV477yM6ICM5piv5bqU6K+l5YGa6ZmN57qnIHBvbHlmaWxsICovXFxuICAvKiBAc2VlIGh0dHA6Ly9ncy5zdGF0Y291bnRlci5jb20vICovXFxuICAvKiBJRTEw44CBSUUxMSDomb3nhLbmlK/mjIEgZmxleO+8jOS9hui/mOaYr+S8muacieWQhOenjeWQhOagt+Wlh+Wlh+aAquaAqueahOmXrumimCAqLyB9XFxuICAubmV4dC1zZWxlY3QgKixcXG4gIC5uZXh0LXNlbGVjdCAqOmJlZm9yZSxcXG4gIC5uZXh0LXNlbGVjdCAqOmFmdGVyIHtcXG4gICAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH1cXG4gIC5uZXh0LXNlbGVjdC10cmlnZ2VyIHtcXG4gICAgbWluLXdpZHRoOiAxMDBweDtcXG4gICAgb3V0bGluZTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgLjNzIGVhc2U7XFxuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTsgfVxcbiAgICAubmV4dC1zZWxlY3QtdHJpZ2dlciAubmV4dC1pbnB1dC1sYWJlbCB7XFxuICAgICAgLXdlYmtpdC1ib3gtZmxleDogMDtcXG4gICAgICAgICAgLW1zLWZsZXg6IDAgMCBhdXRvO1xcbiAgICAgICAgICAgICAgZmxleDogMCAwIGF1dG87XFxuICAgICAgd2lkdGg6IGF1dG87IH1cXG4gICAgLm5leHQtc2VsZWN0LXRyaWdnZXIgLm5leHQtc2VsZWN0LXZhbHVlcyB7XFxuICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgLXdlYmtpdC1ib3gtZmxleDogMTtcXG4gICAgICAgICAgLW1zLWZsZXg6IDEgMSAwcHg7XFxuICAgICAgICAgICAgICBmbGV4OiAxIDEgMDtcXG4gICAgICBvdmVyZmxvdzogaGlkZGVuOyB9XFxuICAgICAgLm5leHQtc2VsZWN0LXRyaWdnZXIgLm5leHQtc2VsZWN0LXZhbHVlcyA+IGVtIHtcXG4gICAgICAgIGZvbnQtc3R5bGU6IGluaGVyaXQ7IH1cXG4gICAgICAubmV4dC1zZWxlY3QtdHJpZ2dlciAubmV4dC1zZWxlY3QtdmFsdWVzIGlucHV0IHtcXG4gICAgICAgIHBhZGRpbmctbGVmdDogMDtcXG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDA7IH1cXG4gICAgLm5leHQtc2VsZWN0LXRyaWdnZXIgLm5leHQtaW5wdXQtY29udHJvbCB7XFxuICAgICAgLXdlYmtpdC1ib3gtZmxleDogMDtcXG4gICAgICAgICAgLW1zLWZsZXg6IDAgMCBhdXRvO1xcbiAgICAgICAgICAgICAgZmxleDogMCAwIGF1dG87XFxuICAgICAgd2lkdGg6IGF1dG87IH1cXG4gICAgICAubmV4dC1zZWxlY3QtdHJpZ2dlciAubmV4dC1pbnB1dC1jb250cm9sID4gKiB7XFxuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgICB3aWR0aDogYXV0bzsgfVxcbiAgICAubmV4dC1zZWxlY3QtdHJpZ2dlciAubmV4dC1pbnB1dC5uZXh0LWRpc2FibGVkIGVtIHtcXG4gICAgICBjb2xvcjogI0NDQ0NDQzsgfVxcbiAgICAubmV4dC1zZWxlY3QtdHJpZ2dlciAubmV4dC1pbnB1dC5uZXh0LWRpc2FibGVkIC5uZXh0LXNlbGVjdC1hcnJvdyB7XFxuICAgICAgY3Vyc29yOiBub3QtYWxsb3dlZDsgfVxcbiAgICAubmV4dC1zZWxlY3QtdHJpZ2dlciAubmV4dC1zZWxlY3QtY2xlYXIge1xcbiAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gICAgLm5leHQtc2VsZWN0LXRyaWdnZXIubmV4dC1oYXMtY2xlYXI6aG92ZXIgLm5leHQtc2VsZWN0LWNsZWFyIHtcXG4gICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IH1cXG4gICAgLm5leHQtc2VsZWN0LXRyaWdnZXIubmV4dC1oYXMtY2xlYXI6aG92ZXIgLm5leHQtc2VsZWN0LWFycm93IHtcXG4gICAgICBkaXNwbGF5OiBub25lOyB9XFxuICAubmV4dC1zZWxlY3QgLm5leHQtc2VsZWN0LWlubmVyIHtcXG4gICAgZGlzcGxheTogLXdlYmtpdC1pbmxpbmUtYm94O1xcbiAgICBkaXNwbGF5OiAtbXMtaW5saW5lLWZsZXhib3g7XFxuICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xcbiAgICAtd2Via2l0LWJveC1hbGlnbjogY2VudGVyO1xcbiAgICAgICAgLW1zLWZsZXgtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgbWluLXdpZHRoOiAxMDBweDtcXG4gICAgb3V0bGluZTogMDtcXG4gICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gICAgLm5leHQtc2VsZWN0IC5uZXh0LXNlbGVjdC1pbm5lciAubmV4dC10YWcge1xcbiAgICAgIGxpbmUtaGVpZ2h0OiAxO1xcbiAgICAgIG1hcmdpbi1yaWdodDogNHB4O1xcbiAgICAgIG1hcmdpbi1ib3R0b206IDNweDtcXG4gICAgICBwYWRkaW5nLWxlZnQ6IDRweDtcXG4gICAgICBwYWRkaW5nLXJpZ2h0OiA0cHg7IH1cXG4gIC5uZXh0LXNlbGVjdC10cmlnZ2VyLXNlYXJjaCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgbWF4LXdpZHRoOiAxMDAlOyB9XFxuICAgIC5uZXh0LXNlbGVjdC10cmlnZ2VyLXNlYXJjaCA+IGlucHV0LCAubmV4dC1zZWxlY3QtdHJpZ2dlci1zZWFyY2ggPiBzcGFuIHtcXG4gICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgICBmb250LXNpemU6IGluaGVyaXQ7XFxuICAgICAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XFxuICAgICAgbGV0dGVyLXNwYWNpbmc6IGluaGVyaXQ7XFxuICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gICAgICBvdmVyZmxvdzogaGlkZGVuOyB9XFxuICAgIC5uZXh0LXNlbGVjdC10cmlnZ2VyLXNlYXJjaCBpbnB1dCB7XFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgIGhlaWdodDogMTAwJSAhaW1wb3J0YW50O1xcbiAgICAgIHotaW5kZXg6IDE7XFxuICAgICAgbGVmdDogMDtcXG4gICAgICBib3JkZXI6IDA7XFxuICAgICAgb3V0bGluZTogMDtcXG4gICAgICBtYXJnaW46IDA7XFxuICAgICAgcGFkZGluZzogMDtcXG4gICAgICBjdXJzb3I6IGluaGVyaXQ7IH1cXG4gICAgLm5leHQtc2VsZWN0LXRyaWdnZXItc2VhcmNoID4gc3BhbiB7XFxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXG4gICAgICB3aGl0ZS1zcGFjZTogcHJlO1xcbiAgICAgIG1heC13aWR0aDogMTAwJTtcXG4gICAgICAvKiDlnKggdGFibGUg5biD5bGA5Lit77yMMTAwJSDlubbmsqHmnInku4DkuYh455SoICovXFxuICAgICAgei1pbmRleDogLTE7IH1cXG4gIC5uZXh0LXNlbGVjdC1zaW5nbGUge1xcbiAgICAvKiDmkJzntKLmoYbmv4DmtLvml7bvvIzlsZXlvIDlkI7kuI3mmL7npLrlgLzvvIzlj6rmmL7npLrmkJzntKLmoYYgKi9cXG4gICAgLyog5pCc57Si5qGG5pyq5r+A5rS777yM5oiW6ICFbWVudeacquWxleW8gO+8jOWmguaenOacieWAvO+8jOWImeS4jeaYvuekuuaQnOe0oihwbGFjZWhvbGRlcikgKi8gfVxcbiAgICAubmV4dC1zZWxlY3Qtc2luZ2xlLm5leHQtbm8tc2VhcmNoIHtcXG4gICAgICBjdXJzb3I6IHBvaW50ZXI7IH1cXG4gICAgLm5leHQtc2VsZWN0LXNpbmdsZS5uZXh0LWhhcy1zZWFyY2gubmV4dC1hY3RpdmUgLm5leHQtc2VsZWN0LXZhbHVlcyA+IGVtIHtcXG4gICAgICBkaXNwbGF5OiBub25lOyB9XFxuICAgIC5uZXh0LXNlbGVjdC1zaW5nbGUubmV4dC1uby1zZWFyY2ggLm5leHQtc2VsZWN0LXZhbHVlcyA+IGVtICsgLm5leHQtc2VsZWN0LXRyaWdnZXItc2VhcmNoLCAubmV4dC1zZWxlY3Qtc2luZ2xlLm5leHQtaW5hY3RpdmUgLm5leHQtc2VsZWN0LXZhbHVlcyA+IGVtICsgLm5leHQtc2VsZWN0LXRyaWdnZXItc2VhcmNoIHtcXG4gICAgICB3aWR0aDogMXB4O1xcbiAgICAgIG9wYWNpdHk6IDA7XFxuICAgICAgZmlsdGVyOiBhbHBoYShvcGFjaXR5PTApO1xcbiAgICAgIC8qIGZvciBJRSA5ICovIH1cXG4gICAgLm5leHQtc2VsZWN0LXNpbmdsZS5uZXh0LW5vLXNlYXJjaCAubmV4dC1zZWxlY3QtdHJpZ2dlci1zZWFyY2ggaW5wdXQsIC5uZXh0LXNlbGVjdC1zaW5nbGUubmV4dC1pbmFjdGl2ZSAubmV4dC1zZWxlY3QtdHJpZ2dlci1zZWFyY2ggaW5wdXQge1xcbiAgICAgIGNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbiAgICAubmV4dC1zZWxlY3Qtc2luZ2xlIC5uZXh0LXNlbGVjdC12YWx1ZXMge1xcbiAgICAgIGRpc3BsYXk6IC13ZWJraXQtaW5saW5lLWJveDtcXG4gICAgICBkaXNwbGF5OiAtbXMtaW5saW5lLWZsZXhib3g7XFxuICAgICAgZGlzcGxheTogaW5saW5lLWZsZXg7XFxuICAgICAgLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgICAgLW1zLWZsZXgtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7IH1cXG4gICAgICAubmV4dC1zZWxlY3Qtc2luZ2xlIC5uZXh0LXNlbGVjdC12YWx1ZXMgPiBlbSB7XFxuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xcbiAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDsgfVxcbiAgLm5leHQtc2VsZWN0LW11bHRpcGxlLCAubmV4dC1zZWxlY3QtdGFnIHtcXG4gICAgLyog5aaC5p6c5pyJ5YC877yM5YiZ5pCc57Si5qGG5Y+Y5Li6MXB4ICovIH1cXG4gICAgLm5leHQtc2VsZWN0LW11bHRpcGxlIC5uZXh0LXNlbGVjdC12YWx1ZXMsIC5uZXh0LXNlbGVjdC10YWcgLm5leHQtc2VsZWN0LXZhbHVlcyB7XFxuICAgICAgLyogVGFnIOaciSAzcHgg55qEIG1hcmdpbi1ib3R0b23vvIzmiYDku6XljIXoo7kgVGFnIOeahOWuueWZqOimgeS9nOS4gOS4i+WkhOeQhiAqL1xcbiAgICAgIG1hcmdpbi1ib3R0b206IC0zcHg7XFxuICAgICAgaGVpZ2h0OiBhdXRvICFpbXBvcnRhbnQ7IH1cXG4gICAgLm5leHQtc2VsZWN0LW11bHRpcGxlIC5uZXh0LXNlbGVjdC10cmlnZ2VyLXNlYXJjaCwgLm5leHQtc2VsZWN0LXRhZyAubmV4dC1zZWxlY3QtdHJpZ2dlci1zZWFyY2gge1xcbiAgICAgIG1hcmdpbi1ib3R0b206IDNweDsgfVxcbiAgICAubmV4dC1zZWxlY3QtbXVsdGlwbGUgLm5leHQtdGFnICsgLm5leHQtc2VsZWN0LXRyaWdnZXItc2VhcmNoLCAubmV4dC1zZWxlY3QtdGFnIC5uZXh0LXRhZyArIC5uZXh0LXNlbGVjdC10cmlnZ2VyLXNlYXJjaCB7XFxuICAgICAgd2lkdGg6IGF1dG87XFxuICAgICAgbWluLXdpZHRoOiAxcHg7XFxuICAgICAgLyog5L+d55WZ5LiA5Liq5YWJ5qCH55qE5a695bqmICovIH1cXG4gICAgLm5leHQtc2VsZWN0LW11bHRpcGxlIC5uZXh0LWlucHV0LCAubmV4dC1zZWxlY3QtdGFnIC5uZXh0LWlucHV0IHtcXG4gICAgICBoZWlnaHQ6IGF1dG87XFxuICAgICAgLXdlYmtpdC1ib3gtYWxpZ246IHN0YXJ0O1xcbiAgICAgICAgICAtbXMtZmxleC1hbGlnbjogc3RhcnQ7XFxuICAgICAgICAgICAgICBhbGlnbi1pdGVtczogc3RhcnQ7IH1cXG4gICAgLm5leHQtc2VsZWN0LW11bHRpcGxlLm5leHQtc21hbGwgLm5leHQtc2VsZWN0LXZhbHVlcywgLm5leHQtc2VsZWN0LXRhZy5uZXh0LXNtYWxsIC5uZXh0LXNlbGVjdC12YWx1ZXMge1xcbiAgICAgIG1pbi1oZWlnaHQ6IDE4cHg7XFxuICAgICAgcGFkZGluZy10b3A6IDJweDtcXG4gICAgICBwYWRkaW5nLWJvdHRvbTogMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiAxNHB4OyB9XFxuICAgIC5uZXh0LXNlbGVjdC1tdWx0aXBsZS5uZXh0LXNtYWxsIC5uZXh0LXRhZywgLm5leHQtc2VsZWN0LXRhZy5uZXh0LXNtYWxsIC5uZXh0LXRhZyB7XFxuICAgICAgYm9yZGVyOiAwO1xcbiAgICAgIHBhZGRpbmctdG9wOiAwcHg7XFxuICAgICAgcGFkZGluZy1ib3R0b206IDBweDtcXG4gICAgICBoZWlnaHQ6IDE0cHg7IH1cXG4gICAgICAubmV4dC1zZWxlY3QtbXVsdGlwbGUubmV4dC1zbWFsbCAubmV4dC10YWcgLm5leHQtdGFnLWJvZHksIC5uZXh0LXNlbGVjdC1tdWx0aXBsZS5uZXh0LXNtYWxsIC5uZXh0LXRhZyAubmV4dC10YWctY2xvc2UtYnRuLCAubmV4dC1zZWxlY3QtdGFnLm5leHQtc21hbGwgLm5leHQtdGFnIC5uZXh0LXRhZy1ib2R5LCAubmV4dC1zZWxlY3QtdGFnLm5leHQtc21hbGwgLm5leHQtdGFnIC5uZXh0LXRhZy1jbG9zZS1idG4ge1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IDE0cHg7IH1cXG4gICAgICAubmV4dC1zZWxlY3QtbXVsdGlwbGUubmV4dC1zbWFsbCAubmV4dC10YWctYm9keSwgLm5leHQtc2VsZWN0LXRhZy5uZXh0LXNtYWxsIC5uZXh0LXRhZy1ib2R5IHtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxNHB4OyB9XFxuICAgIC5uZXh0LXNlbGVjdC1tdWx0aXBsZS5uZXh0LXNtYWxsIC5uZXh0LWlucHV0LWxhYmVsLCAubmV4dC1zZWxlY3QtbXVsdGlwbGUubmV4dC1zbWFsbCAubmV4dC1pbnB1dC1jb250cm9sLCAubmV4dC1zZWxlY3QtdGFnLm5leHQtc21hbGwgLm5leHQtaW5wdXQtbGFiZWwsIC5uZXh0LXNlbGVjdC10YWcubmV4dC1zbWFsbCAubmV4dC1pbnB1dC1jb250cm9sIHtcXG4gICAgICBsaW5lLWhlaWdodDogMThweDsgfVxcbiAgICAubmV4dC1zZWxlY3QtbXVsdGlwbGUubmV4dC1tZWRpdW0gLm5leHQtc2VsZWN0LXZhbHVlcywgLm5leHQtc2VsZWN0LXRhZy5uZXh0LW1lZGl1bSAubmV4dC1zZWxlY3QtdmFsdWVzIHtcXG4gICAgICBtaW4taGVpZ2h0OiAyNnB4O1xcbiAgICAgIHBhZGRpbmctdG9wOiAzcHg7XFxuICAgICAgcGFkZGluZy1ib3R0b206IDNweDtcXG4gICAgICBsaW5lLWhlaWdodDogMjBweDsgfVxcbiAgICAubmV4dC1zZWxlY3QtbXVsdGlwbGUubmV4dC1tZWRpdW0gLm5leHQtdGFnLCAubmV4dC1zZWxlY3QtdGFnLm5leHQtbWVkaXVtIC5uZXh0LXRhZyB7XFxuICAgICAgcGFkZGluZy10b3A6IDFweDtcXG4gICAgICBwYWRkaW5nLWJvdHRvbTogMXB4O1xcbiAgICAgIGhlaWdodDogMjBweDsgfVxcbiAgICAgIC5uZXh0LXNlbGVjdC1tdWx0aXBsZS5uZXh0LW1lZGl1bSAubmV4dC10YWcgLm5leHQtdGFnLWJvZHksIC5uZXh0LXNlbGVjdC1tdWx0aXBsZS5uZXh0LW1lZGl1bSAubmV4dC10YWcgLm5leHQtdGFnLWNsb3NlLWJ0biwgLm5leHQtc2VsZWN0LXRhZy5uZXh0LW1lZGl1bSAubmV4dC10YWcgLm5leHQtdGFnLWJvZHksIC5uZXh0LXNlbGVjdC10YWcubmV4dC1tZWRpdW0gLm5leHQtdGFnIC5uZXh0LXRhZy1jbG9zZS1idG4ge1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IDE4cHg7IH1cXG4gICAgLm5leHQtc2VsZWN0LW11bHRpcGxlLm5leHQtbWVkaXVtIC5uZXh0LWlucHV0LWxhYmVsLCAubmV4dC1zZWxlY3QtbXVsdGlwbGUubmV4dC1tZWRpdW0gLm5leHQtaW5wdXQtY29udHJvbCwgLm5leHQtc2VsZWN0LXRhZy5uZXh0LW1lZGl1bSAubmV4dC1pbnB1dC1sYWJlbCwgLm5leHQtc2VsZWN0LXRhZy5uZXh0LW1lZGl1bSAubmV4dC1pbnB1dC1jb250cm9sIHtcXG4gICAgICBsaW5lLWhlaWdodDogMjZweDsgfVxcbiAgICAubmV4dC1zZWxlY3QtbXVsdGlwbGUubmV4dC1sYXJnZSAubmV4dC1zZWxlY3QtdmFsdWVzLCAubmV4dC1zZWxlY3QtdGFnLm5leHQtbGFyZ2UgLm5leHQtc2VsZWN0LXZhbHVlcyB7XFxuICAgICAgbWluLWhlaWdodDogMzhweDtcXG4gICAgICBwYWRkaW5nLXRvcDogN3B4O1xcbiAgICAgIHBhZGRpbmctYm90dG9tOiA3cHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IDI0cHg7IH1cXG4gICAgLm5leHQtc2VsZWN0LW11bHRpcGxlLm5leHQtbGFyZ2UgLm5leHQtdGFnLCAubmV4dC1zZWxlY3QtdGFnLm5leHQtbGFyZ2UgLm5leHQtdGFnIHtcXG4gICAgICBwYWRkaW5nLXRvcDogM3B4O1xcbiAgICAgIHBhZGRpbmctYm90dG9tOiAzcHg7XFxuICAgICAgaGVpZ2h0OiAyNHB4OyB9XFxuICAgICAgLm5leHQtc2VsZWN0LW11bHRpcGxlLm5leHQtbGFyZ2UgLm5leHQtdGFnIC5uZXh0LXRhZy1ib2R5LCAubmV4dC1zZWxlY3QtbXVsdGlwbGUubmV4dC1sYXJnZSAubmV4dC10YWcgLm5leHQtdGFnLWNsb3NlLWJ0biwgLm5leHQtc2VsZWN0LXRhZy5uZXh0LWxhcmdlIC5uZXh0LXRhZyAubmV4dC10YWctYm9keSwgLm5leHQtc2VsZWN0LXRhZy5uZXh0LWxhcmdlIC5uZXh0LXRhZyAubmV4dC10YWctY2xvc2UtYnRuIHtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxOHB4OyB9XFxuICAgIC5uZXh0LXNlbGVjdC1tdWx0aXBsZS5uZXh0LWxhcmdlIC5uZXh0LWlucHV0LWxhYmVsLCAubmV4dC1zZWxlY3QtbXVsdGlwbGUubmV4dC1sYXJnZSAubmV4dC1pbnB1dC1jb250cm9sLCAubmV4dC1zZWxlY3QtdGFnLm5leHQtbGFyZ2UgLm5leHQtaW5wdXQtbGFiZWwsIC5uZXh0LXNlbGVjdC10YWcubmV4dC1sYXJnZSAubmV4dC1pbnB1dC1jb250cm9sIHtcXG4gICAgICBsaW5lLWhlaWdodDogMzhweDsgfVxcbiAgLm5leHQtc2VsZWN0Lm5leHQtbm8tc2VhcmNoIHtcXG4gICAgLyog5Zyo5pCc57Si5qGG5pyq5r+A5rS75pe277yM5bCGIGlucHV0IOeahCBjb2xvciDnva7kuLrpgI/mmI4gKi9cXG4gICAgLyogSVNTVUU6IOWcqCBmaXJlZm94IOS4re+8jHJlYWRvbmx5IOeahCBpbnB1dCDku43nhLbkvJrmmL7npLrlhYnmoIcgKi8gfVxcbiAgICAubmV4dC1zZWxlY3QubmV4dC1uby1zZWFyY2ggLm5leHQtc2VsZWN0LXRyaWdnZXItc2VhcmNoIGlucHV0IHtcXG4gICAgICBjb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gIC5uZXh0LXNlbGVjdC1hdXRvLWNvbXBsZXRlIHtcXG4gICAgd2lkdGg6IDE2MHB4OyB9XFxuICAgIC5uZXh0LXNlbGVjdC1hdXRvLWNvbXBsZXRlIC5uZXh0LWlucHV0IHtcXG4gICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAvKiB0YWJsZS1jZWxsIOS4iyBtYXJnaW4g5peg5pWIICovIH1cXG4gICAgICAubmV4dC1zZWxlY3QtYXV0by1jb21wbGV0ZSAubmV4dC1pbnB1dCAubmV4dC1pbnB1dC1oaW50LXdyYXAge1xcbiAgICAgICAgcGFkZGluZy1yaWdodDogMXB4OyB9XFxuICAgICAgLm5leHQtc2VsZWN0LWF1dG8tY29tcGxldGUgLm5leHQtaW5wdXQgLm5leHQtc2VsZWN0LWFycm93IHtcXG4gICAgICAgIHBhZGRpbmctbGVmdDogMDsgfVxcbiAgLm5leHQtc2VsZWN0Lm5leHQtYWN0aXZlIC5uZXh0LXNlbGVjdC1hcnJvdyB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG4gICAgICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7IH1cXG4gIC5uZXh0LXNlbGVjdC1hcnJvdyB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgd2lkdGg6IGF1dG8gIWltcG9ydGFudDtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcXG4gICAgdHJhbnNpdGlvbjogYWxsIC4zcyBlYXNlO1xcbiAgICAvKiB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgNDEuOCU7IC8vIGljb24g5Zu+5YOP5Lit5b+DICovIH1cXG4gIC5uZXh0LXNlbGVjdC1tZW51LXdyYXBwZXIge1xcbiAgICBtYXgtaGVpZ2h0OiAyNjBweDtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNEQ0RFRTM7XFxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiBub25lO1xcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IG5vbmU7IH1cXG4gICAgLm5leHQtc2VsZWN0LW1lbnUtd3JhcHBlciAubmV4dC1zZWxlY3QtbWVudSB7XFxuICAgICAgbWF4LWhlaWdodDogbm9uZTtcXG4gICAgICBib3JkZXI6IG5vbmU7IH1cXG4gIC5uZXh0LXNlbGVjdC1tZW51IHtcXG4gICAgbWF4LWhlaWdodDogMjYwcHg7XFxuICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICAvKiBhdXRvQ29tcGxldGUg5rKh5pyJ6YCJ6aG55pe2IG1lbnUg5LiN5pi+56S6ICovIH1cXG4gICAgLm5leHQtc2VsZWN0LW1lbnUgLm5leHQtc2VsZWN0LW1lbnUtZW1wdHktY29udGVudCB7XFxuICAgICAgcGFkZGluZy1sZWZ0OiA4cHg7XFxuICAgICAgcGFkZGluZy1yaWdodDogOHB4O1xcbiAgICAgIGNvbG9yOiAjOTk5OTk5OyB9XFxuICAgIC5uZXh0LXNlbGVjdC1tZW51Lm5leHQtc2VsZWN0LWF1dG8tY29tcGxldGUtbWVudS5uZXh0LXNlbGVjdC1tZW51LWVtcHR5IHtcXG4gICAgICBkaXNwbGF5OiBub25lOyB9XFxuICAgIC5uZXh0LXNlbGVjdC1tZW51IC5uZXh0LW1lbnUtaXRlbS10ZXh0IC5uZXh0LWljb24ge1xcbiAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IH1cXG4gIC5uZXh0LXNlbGVjdC1hbGwge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBsaW5lLWhlaWdodDogMjBweDtcXG4gICAgcGFkZGluZzogNHB4IDhweDtcXG4gICAgbWFyZ2luOiAwIDEycHggOHB4O1xcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI0RDREVFMzsgfVxcbiAgICAubmV4dC1zZWxlY3QtYWxsOmhvdmVyIHtcXG4gICAgICBjb2xvcjogIzNFNzFGNzsgfVxcbiAgLm5leHQtc2VsZWN0LWhpZ2hsaWdodCB7XFxuICAgIGNvbG9yOiAjNTU4NEZGO1xcbiAgICBmb250LXNpemU6IDEycHg7IH1cXG4gIC5uZXh0LXNlbGVjdC1pbi1pZS5uZXh0LXNlbGVjdC10cmlnZ2VyIC5uZXh0LXNlbGVjdC12YWx1ZXMge1xcbiAgICAvKiDlnKggdGFibGUg5biD5bGA5Lit77yMb3ZlcmZsb3c6IGhpZGRlbiDkvJrlr7zoh7TotJ/nmoQgbWFyZ2luIOWkseaViCAqL1xcbiAgICBvdmVyZmxvdzogdmlzaWJsZTsgfVxcbiAgLm5leHQtc2VsZWN0LWluLWllLm5leHQtc2VsZWN0LXRyaWdnZXIgLm5leHQtaW5wdXQtY29udHJvbCwgLm5leHQtc2VsZWN0LWluLWllLm5leHQtc2VsZWN0LXRyaWdnZXIgLm5leHQtaW5wdXQtbGFiZWwge1xcbiAgICB3aWR0aDogMXB4OyB9XFxuICAubmV4dC1zZWxlY3QtaW4taWUubmV4dC1zZWxlY3QtdHJpZ2dlciAubmV4dC1pbnB1dC1jb250cm9sID4gKiB7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxuICAgIHdpZHRoOiAxJTsgfVxcbiAgLm5leHQtc2VsZWN0LWluLWllLm5leHQtc2VsZWN0LXRyaWdnZXIgLm5leHQtc2VsZWN0LWFycm93IHtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDsgfVxcbiAgLm5leHQtc2VsZWN0LWluLWllLm5leHQtc2VsZWN0LXRyaWdnZXIgLm5leHQtc2VsZWN0LWNsZWFyIHtcXG4gICAgZGlzcGxheTogbm9uZTsgfVxcbiAgLm5leHQtc2VsZWN0LWluLWllLm5leHQtc2VsZWN0LXRyaWdnZXIubmV4dC1zZWxlY3QtbXVsdGlwbGUgLm5leHQtc2VsZWN0LWlubmVyLCAubmV4dC1zZWxlY3QtaW4taWUubmV4dC1zZWxlY3QtdHJpZ2dlci5uZXh0LXNlbGVjdC10YWcgLm5leHQtc2VsZWN0LWlubmVyIHtcXG4gICAgdmVydGljYWwtYWxpZ246IHRvcDsgfVxcbiAgLm5leHQtc2VsZWN0LWluLWllLm5leHQtc2VsZWN0LXRyaWdnZXIgLm5leHQtc2VsZWN0LWlubmVyIHtcXG4gICAgZGlzcGxheTogaW5saW5lLXRhYmxlOyB9XFxuICAubmV4dC1zZWxlY3QtaW4taWUubmV4dC1zZWxlY3QtdHJpZ2dlci5uZXh0LXNlbGVjdC1zaW5nbGUgLm5leHQtc2VsZWN0LXZhbHVlcyB7XFxuICAgIGRpc3BsYXk6IGlubGluZS10YWJsZTsgfVxcbiAgLm5leHQtc2VsZWN0LWluLWllLm5leHQtc2VsZWN0LXRyaWdnZXIubmV4dC1zZWxlY3Qtc2luZ2xlIC5uZXh0LWlucHV0Lm5leHQtc21hbGwgLm5leHQtc2VsZWN0LXZhbHVlcyB7XFxuICAgIGxpbmUtaGVpZ2h0OiAyMHB4OyB9XFxuICAubmV4dC1zZWxlY3QtaW4taWUubmV4dC1zZWxlY3QtdHJpZ2dlci5uZXh0LXNlbGVjdC1zaW5nbGUgLm5leHQtaW5wdXQubmV4dC1tZWRpdW0gLm5leHQtc2VsZWN0LXZhbHVlcyB7XFxuICAgIGxpbmUtaGVpZ2h0OiAyOHB4OyB9XFxuICAubmV4dC1zZWxlY3QtaW4taWUubmV4dC1zZWxlY3QtdHJpZ2dlci5uZXh0LXNlbGVjdC1zaW5nbGUgLm5leHQtaW5wdXQubmV4dC1sYXJnZSAubmV4dC1zZWxlY3QtdmFsdWVzIHtcXG4gICAgbGluZS1oZWlnaHQ6IDQwcHg7IH1cXG4gIC5uZXh0LXNlbGVjdC1pbi1pZS5uZXh0LXNlbGVjdC10cmlnZ2VyIC5uZXh0LXNlbGVjdC10cmlnZ2VyLXNlYXJjaCA+IHNwYW4ge1xcbiAgICBtYXgtd2lkdGg6IDEwMHB4OyB9XFxuICAubmV4dC1zZWxlY3QtaW4taWUubmV4dC1zZWxlY3QtdHJpZ2dlci5uZXh0LXNlbGVjdC1zaW5nbGUge1xcbiAgICAvKiDmkJzntKLmoYbmnKrmv4DmtLvvvIzmiJbogIVtZW515pyq5bGV5byA77yM5aaC5p6c5pyJ5YC877yM5YiZ5LiN5pi+56S65pCc57SiKHBsYWNlaG9sZGVyKSAqLyB9XFxuICAgIC5uZXh0LXNlbGVjdC1pbi1pZS5uZXh0LXNlbGVjdC10cmlnZ2VyLm5leHQtc2VsZWN0LXNpbmdsZS5uZXh0LXNlbGVjdC1pbi1pZS1maXh3aWR0aCAubmV4dC1zZWxlY3QtdmFsdWVzIHtcXG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG4gICAgICAubmV4dC1zZWxlY3QtaW4taWUubmV4dC1zZWxlY3QtdHJpZ2dlci5uZXh0LXNlbGVjdC1zaW5nbGUubmV4dC1zZWxlY3QtaW4taWUtZml4d2lkdGggLm5leHQtc2VsZWN0LXZhbHVlcyA+IGVtIHtcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxO1xcbiAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgICAgICBsZWZ0OiA0cHg7XFxuICAgICAgICByaWdodDogMDtcXG4gICAgICAgIHRvcDogMzAlOyB9XFxuICAgIC5uZXh0LXNlbGVjdC1pbi1pZS5uZXh0LXNlbGVjdC10cmlnZ2VyLm5leHQtc2VsZWN0LXNpbmdsZS5uZXh0LW5vLXNlYXJjaCAubmV4dC1zZWxlY3QtdmFsdWVzID4gZW0gKyAubmV4dC1zZWxlY3QtdHJpZ2dlci1zZWFyY2gsIC5uZXh0LXNlbGVjdC1pbi1pZS5uZXh0LXNlbGVjdC10cmlnZ2VyLm5leHQtc2VsZWN0LXNpbmdsZS5uZXh0LWluYWN0aXZlIC5uZXh0LXNlbGVjdC12YWx1ZXMgPiBlbSArIC5uZXh0LXNlbGVjdC10cmlnZ2VyLXNlYXJjaCB7XFxuICAgICAgZmlsdGVyOiBhbHBoYShvcGFjaXR5PTApO1xcbiAgICAgIC8qIGZvciBJRSA5ICovXFxuICAgICAgZm9udC1zaXplOiAwOyB9XFxuICAgIC5uZXh0LXNlbGVjdC1pbi1pZS5uZXh0LXNlbGVjdC10cmlnZ2VyLm5leHQtc2VsZWN0LXNpbmdsZS5uZXh0LW5vLXNlYXJjaCAubmV4dC1zZWxlY3QtdHJpZ2dlci1zZWFyY2ggaW5wdXQsIC5uZXh0LXNlbGVjdC1pbi1pZS5uZXh0LXNlbGVjdC10cmlnZ2VyLm5leHQtc2VsZWN0LXNpbmdsZS5uZXh0LWluYWN0aXZlIC5uZXh0LXNlbGVjdC10cmlnZ2VyLXNlYXJjaCBpbnB1dCB7XFxuICAgICAgY29sb3I6IGluaGVyaXQ7IH1cXG4gIC5uZXh0LXNlbGVjdC1pbi1pZS5uZXh0LXNlbGVjdC10cmlnZ2VyLm5leHQtbm8tc2VhcmNoIC5uZXh0LXNlbGVjdC10cmlnZ2VyLXNlYXJjaCBpbnB1dCB7XFxuICAgIGNvbG9yOiBpbmhlcml0OyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyPz9yZWYtLTItMSEuL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliPz9yZWYtLTItMiEuL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYiEuL3NyYy9zZWxlY3QvbWFpbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBjaGFyc2V0IFxcXCJVVEYtOFxcXCI7XFxuLyoqXFxuICog5bC65a+4IOWfuuehgOWwuuWvuFxcbiAqIOWRveWQjeiDveWcqOivreS5ieeahOWJjeaPkOS4i+eugOWNleWwseWwvemHj+eugOWNlSwg6L+Z6YeM5Y+v5Lul5pivIHNpemUtMngsIHNwYWNlLTJ4LCBzaXplLWJhc2UgLi4uXFxuICog5LiN6L+H5Y+v5Lul5Zyo6K+t5LmJ55qE5YmN5o+Q5LiL5YGa55qE5pu057K+566A5LiA5LqbLCDkuo7mmK/nlKjkuoZzMiwgczHnrYlcXG4gKiDlj6/nlKjlj5jph486IGAkczEgLSAkczhgXFxuICogQGV4YW1wbGUgc2NzcyAtIOS9v+eUqFxcbiAqICAgLmVsZW1lbnQge1xcbiAqICAgICBwYWRkaW5nOiAkczEgIWRlZmF1bHQ7XFxuICogICB9XFxuICpcXG4gKiBAZXhhbXBsZSBjc3MgLSBDU1Mg6L6T5Ye6XFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6IDRweCAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKi9cXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0gLm5leHQtcGFnaW5hdGlvbi10b3RhbCB7XFxuICBtYXJnaW4tcmlnaHQ6IDA7XFxuICBtYXJnaW4tbGVmdDogMTZweDsgfVxcblxcbi5uZXh0LXBhZ2luYXRpb25bZGlyPVxcXCJydGxcXFwiXSAubmV4dC1wYWdpbmF0aW9uLWp1bXAtZ28ge1xcbiAgbWFyZ2luLWxlZnQ6IDA7XFxuICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcblxcbi5uZXh0LXBhZ2luYXRpb25bZGlyPVxcXCJydGxcXFwiXSAubmV4dC1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3ItdGl0bGUge1xcbiAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgbWFyZ2luLWxlZnQ6IDRweDsgfVxcblxcbi5uZXh0LXBhZ2luYXRpb25bZGlyPVxcXCJydGxcXFwiXSAubmV4dC1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3ItYnRuLm5leHQtYnRuLXRleHQgKyAubmV4dC1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3ItYnRuIHtcXG4gIGJvcmRlci1sZWZ0OiBub25lO1xcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI0RDREVFMzsgfVxcblxcbi5uZXh0LXBhZ2luYXRpb25bZGlyPVxcXCJydGxcXFwiXSAubmV4dC1wYWdpbmF0aW9uLXBhZ2VzICsgLm5leHQtcGFnaW5hdGlvbi1zaXplLXNlbGVjdG9yLFxcbi5uZXh0LXBhZ2luYXRpb25bZGlyPVxcXCJydGxcXFwiXSAubmV4dC1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3IgKyAubmV4dC1wYWdpbmF0aW9uLXBhZ2VzIHtcXG4gIG1hcmdpbi1sZWZ0OiAwO1xcbiAgbWFyZ2luLXJpZ2h0OiA0MHB4OyB9XFxuXFxuLm5leHQtcGFnaW5hdGlvbltkaXI9XFxcInJ0bFxcXCJdLm5leHQtc3RhcnQgLm5leHQtcGFnaW5hdGlvbi1wYWdlcyB7XFxuICBmbG9hdDogbGVmdDsgfVxcblxcbi5uZXh0LXBhZ2luYXRpb25bZGlyPVxcXCJydGxcXFwiXS5uZXh0LXN0YXJ0IC5uZXh0LXBhZ2luYXRpb24tc2l6ZS1zZWxlY3RvciB7XFxuICBmbG9hdDogcmlnaHQ7IH1cXG5cXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1lbmQgLm5leHQtcGFnaW5hdGlvbi1wYWdlcyB7XFxuICBmbG9hdDogcmlnaHQ7IH1cXG5cXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1lbmQgLm5leHQtcGFnaW5hdGlvbi1zaXplLXNlbGVjdG9yIHtcXG4gIGZsb2F0OiBsZWZ0OyB9XFxuXFxuLm5leHQtcGFnaW5hdGlvbltkaXI9XFxcInJ0bFxcXCJdLm5leHQtc21hbGwgLm5leHQtcGFnaW5hdGlvbi1saXN0IHtcXG4gIG1hcmdpbjogMCA0cHg7IH1cXG5cXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1zbWFsbCAubmV4dC1wYWdpbmF0aW9uLXRvdGFsIHtcXG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgfVxcblxcbi5uZXh0LXBhZ2luYXRpb25bZGlyPVxcXCJydGxcXFwiXS5uZXh0LXNtYWxsIC5uZXh0LXBhZ2luYXRpb24taXRlbSB7XFxuICBwYWRkaW5nOiAwIDZweDsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbltkaXI9XFxcInJ0bFxcXCJdLm5leHQtc21hbGwgLm5leHQtcGFnaW5hdGlvbi1pdGVtICsgLm5leHQtcGFnaW5hdGlvbi1pdGVtIHtcXG4gICAgbWFyZ2luOiAwIDRweCAwIDA7IH1cXG5cXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1zbWFsbCAubmV4dC1wYWdpbmF0aW9uLWVsbGlwc2lzIHtcXG4gIGhlaWdodDogMjBweDtcXG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xcbiAgbWFyZ2luLWxlZnQ6IDhweDtcXG4gIG1hcmdpbi1yaWdodDogOHB4OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1zbWFsbCAubmV4dC1wYWdpbmF0aW9uLWVsbGlwc2lzOmJlZm9yZSB7XFxuICAgIHdpZHRoOiAxMnB4O1xcbiAgICBmb250LXNpemU6IDEycHg7XFxuICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuXFxuLm5leHQtcGFnaW5hdGlvbltkaXI9XFxcInJ0bFxcXCJdLm5leHQtc21hbGwgLm5leHQtcGFnaW5hdGlvbi1kaXNwbGF5IHtcXG4gIGZvbnQtc2l6ZTogMTJweDsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbltkaXI9XFxcInJ0bFxcXCJdLm5leHQtc21hbGwgLm5leHQtcGFnaW5hdGlvbi1kaXNwbGF5IGVtIHtcXG4gICAgZm9udC1zaXplOiAxMnB4OyB9XFxuXFxuLm5leHQtcGFnaW5hdGlvbltkaXI9XFxcInJ0bFxcXCJdLm5leHQtc21hbGwgLm5leHQtcGFnaW5hdGlvbi1qdW1wLXRleHQge1xcbiAgZm9udC1zaXplOiAxMnB4OyB9XFxuXFxuLm5leHQtcGFnaW5hdGlvbltkaXI9XFxcInJ0bFxcXCJdLm5leHQtc21hbGwgLm5leHQtcGFnaW5hdGlvbi1qdW1wLWlucHV0IHtcXG4gIHdpZHRoOiAyOHB4OyB9XFxuXFxuLm5leHQtcGFnaW5hdGlvbltkaXI9XFxcInJ0bFxcXCJdLm5leHQtc21hbGwgLm5leHQtcGFnaW5hdGlvbi1zaXplLXNlbGVjdG9yLXRpdGxlIHtcXG4gIGhlaWdodDogMjBweDtcXG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgfVxcblxcbi5uZXh0LXBhZ2luYXRpb25bZGlyPVxcXCJydGxcXFwiXS5uZXh0LXNtYWxsIC5uZXh0LXBhZ2luYXRpb24tc2l6ZS1zZWxlY3Rvci1idG4ge1xcbiAgcGFkZGluZzogMCA4cHg7IH1cXG5cXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1zbWFsbCAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1wcmV2Om5vdChbZGlzYWJsZWRdKSBpLFxcbi5uZXh0LXBhZ2luYXRpb25bZGlyPVxcXCJydGxcXFwiXS5uZXh0LXNtYWxsIC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LW5leHQ6bm90KFtkaXNhYmxlZF0pIGkge1xcbiAgY29sb3I6ICM2NjY2NjY7IH1cXG5cXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1zbWFsbCAubmV4dC1wYWdpbmF0aW9uLWl0ZW06aG92ZXIubmV4dC1wcmV2Om5vdChbZGlzYWJsZWRdKSBpLFxcbi5uZXh0LXBhZ2luYXRpb25bZGlyPVxcXCJydGxcXFwiXS5uZXh0LXNtYWxsIC5uZXh0LXBhZ2luYXRpb24taXRlbTpob3Zlci5uZXh0LW5leHQ6bm90KFtkaXNhYmxlZF0pIGkge1xcbiAgY29sb3I6ICMzMzMzMzM7IH1cXG5cXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1tZWRpdW0gLm5leHQtcGFnaW5hdGlvbi1saXN0IHtcXG4gIG1hcmdpbjogMCA0cHg7IH1cXG5cXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1tZWRpdW0gLm5leHQtcGFnaW5hdGlvbi10b3RhbCB7XFxuICBsaW5lLWhlaWdodDogMjhweDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IH1cXG5cXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1tZWRpdW0gLm5leHQtcGFnaW5hdGlvbi1pdGVtIHtcXG4gIHBhZGRpbmc6IDAgMTBweDsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbltkaXI9XFxcInJ0bFxcXCJdLm5leHQtbWVkaXVtIC5uZXh0LXBhZ2luYXRpb24taXRlbSArIC5uZXh0LXBhZ2luYXRpb24taXRlbSB7XFxuICAgIG1hcmdpbjogMCA0cHggMCAwOyB9XFxuXFxuLm5leHQtcGFnaW5hdGlvbltkaXI9XFxcInJ0bFxcXCJdLm5leHQtbWVkaXVtIC5uZXh0LXBhZ2luYXRpb24tZWxsaXBzaXMge1xcbiAgaGVpZ2h0OiAyOHB4O1xcbiAgbGluZS1oZWlnaHQ6IDI4cHg7XFxuICBtYXJnaW4tbGVmdDogOHB4O1xcbiAgbWFyZ2luLXJpZ2h0OiA4cHg7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb25bZGlyPVxcXCJydGxcXFwiXS5uZXh0LW1lZGl1bSAubmV4dC1wYWdpbmF0aW9uLWVsbGlwc2lzOmJlZm9yZSB7XFxuICAgIHdpZHRoOiAxMnB4O1xcbiAgICBmb250LXNpemU6IDEycHg7XFxuICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuXFxuLm5leHQtcGFnaW5hdGlvbltkaXI9XFxcInJ0bFxcXCJdLm5leHQtbWVkaXVtIC5uZXh0LXBhZ2luYXRpb24tZGlzcGxheSB7XFxuICBmb250LXNpemU6IDEycHg7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb25bZGlyPVxcXCJydGxcXFwiXS5uZXh0LW1lZGl1bSAubmV4dC1wYWdpbmF0aW9uLWRpc3BsYXkgZW0ge1xcbiAgICBmb250LXNpemU6IDEycHg7IH1cXG5cXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1tZWRpdW0gLm5leHQtcGFnaW5hdGlvbi1qdW1wLXRleHQge1xcbiAgZm9udC1zaXplOiAxMnB4OyB9XFxuXFxuLm5leHQtcGFnaW5hdGlvbltkaXI9XFxcInJ0bFxcXCJdLm5leHQtbWVkaXVtIC5uZXh0LXBhZ2luYXRpb24tanVtcC1pbnB1dCB7XFxuICB3aWR0aDogMzZweDsgfVxcblxcbi5uZXh0LXBhZ2luYXRpb25bZGlyPVxcXCJydGxcXFwiXS5uZXh0LW1lZGl1bSAubmV4dC1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3ItdGl0bGUge1xcbiAgaGVpZ2h0OiAyOHB4O1xcbiAgbGluZS1oZWlnaHQ6IDI4cHg7XFxuICBmb250LXNpemU6IDEycHg7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB9XFxuXFxuLm5leHQtcGFnaW5hdGlvbltkaXI9XFxcInJ0bFxcXCJdLm5leHQtbWVkaXVtIC5uZXh0LXBhZ2luYXRpb24tc2l6ZS1zZWxlY3Rvci1idG4ge1xcbiAgcGFkZGluZzogMCAxMnB4OyB9XFxuXFxuLm5leHQtcGFnaW5hdGlvbltkaXI9XFxcInJ0bFxcXCJdLm5leHQtbWVkaXVtIC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LXByZXY6bm90KFtkaXNhYmxlZF0pIGksXFxuLm5leHQtcGFnaW5hdGlvbltkaXI9XFxcInJ0bFxcXCJdLm5leHQtbWVkaXVtIC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LW5leHQ6bm90KFtkaXNhYmxlZF0pIGkge1xcbiAgY29sb3I6ICM2NjY2NjY7IH1cXG5cXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1tZWRpdW0gLm5leHQtcGFnaW5hdGlvbi1pdGVtOmhvdmVyLm5leHQtcHJldjpub3QoW2Rpc2FibGVkXSkgaSxcXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1tZWRpdW0gLm5leHQtcGFnaW5hdGlvbi1pdGVtOmhvdmVyLm5leHQtbmV4dDpub3QoW2Rpc2FibGVkXSkgaSB7XFxuICBjb2xvcjogIzMzMzMzMzsgfVxcblxcbi5uZXh0LXBhZ2luYXRpb25bZGlyPVxcXCJydGxcXFwiXS5uZXh0LWxhcmdlIC5uZXh0LXBhZ2luYXRpb24tbGlzdCB7XFxuICBtYXJnaW46IDAgOHB4OyB9XFxuXFxuLm5leHQtcGFnaW5hdGlvbltkaXI9XFxcInJ0bFxcXCJdLm5leHQtbGFyZ2UgLm5leHQtcGFnaW5hdGlvbi10b3RhbCB7XFxuICBsaW5lLWhlaWdodDogNDBweDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IH1cXG5cXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1sYXJnZSAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ge1xcbiAgcGFkZGluZzogMCAxNXB4OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1sYXJnZSAubmV4dC1wYWdpbmF0aW9uLWl0ZW0gKyAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ge1xcbiAgICBtYXJnaW46IDAgOHB4IDAgMDsgfVxcblxcbi5uZXh0LXBhZ2luYXRpb25bZGlyPVxcXCJydGxcXFwiXS5uZXh0LWxhcmdlIC5uZXh0LXBhZ2luYXRpb24tZWxsaXBzaXMge1xcbiAgaGVpZ2h0OiA0MHB4O1xcbiAgbGluZS1oZWlnaHQ6IDQwcHg7XFxuICBtYXJnaW4tbGVmdDogOHB4O1xcbiAgbWFyZ2luLXJpZ2h0OiA4cHg7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb25bZGlyPVxcXCJydGxcXFwiXS5uZXh0LWxhcmdlIC5uZXh0LXBhZ2luYXRpb24tZWxsaXBzaXM6YmVmb3JlIHtcXG4gICAgd2lkdGg6IDE2cHg7XFxuICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG5cXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1sYXJnZSAubmV4dC1wYWdpbmF0aW9uLWRpc3BsYXkge1xcbiAgZm9udC1zaXplOiAxNnB4OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1sYXJnZSAubmV4dC1wYWdpbmF0aW9uLWRpc3BsYXkgZW0ge1xcbiAgICBmb250LXNpemU6IDE2cHg7IH1cXG5cXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1sYXJnZSAubmV4dC1wYWdpbmF0aW9uLWp1bXAtdGV4dCB7XFxuICBmb250LXNpemU6IDE2cHg7IH1cXG5cXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1sYXJnZSAubmV4dC1wYWdpbmF0aW9uLWp1bXAtaW5wdXQge1xcbiAgd2lkdGg6IDQ4cHg7IH1cXG5cXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1sYXJnZSAubmV4dC1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3ItdGl0bGUge1xcbiAgaGVpZ2h0OiA0MHB4O1xcbiAgbGluZS1oZWlnaHQ6IDQwcHg7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB9XFxuXFxuLm5leHQtcGFnaW5hdGlvbltkaXI9XFxcInJ0bFxcXCJdLm5leHQtbGFyZ2UgLm5leHQtcGFnaW5hdGlvbi1zaXplLXNlbGVjdG9yLWJ0biB7XFxuICBwYWRkaW5nOiAwIDE2cHg7IH1cXG5cXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1sYXJnZSAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1wcmV2Om5vdChbZGlzYWJsZWRdKSBpLFxcbi5uZXh0LXBhZ2luYXRpb25bZGlyPVxcXCJydGxcXFwiXS5uZXh0LWxhcmdlIC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LW5leHQ6bm90KFtkaXNhYmxlZF0pIGkge1xcbiAgY29sb3I6ICM2NjY2NjY7IH1cXG5cXG4ubmV4dC1wYWdpbmF0aW9uW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1sYXJnZSAubmV4dC1wYWdpbmF0aW9uLWl0ZW06aG92ZXIubmV4dC1wcmV2Om5vdChbZGlzYWJsZWRdKSBpLFxcbi5uZXh0LXBhZ2luYXRpb25bZGlyPVxcXCJydGxcXFwiXS5uZXh0LWxhcmdlIC5uZXh0LXBhZ2luYXRpb24taXRlbTpob3Zlci5uZXh0LW5leHQ6bm90KFtkaXNhYmxlZF0pIGkge1xcbiAgY29sb3I6ICMzMzMzMzM7IH1cXG5cXG4ubmV4dC1wYWdpbmF0aW9uIHtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGZvbnQtc2l6ZTogMDsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbiAqLFxcbiAgLm5leHQtcGFnaW5hdGlvbiAqOmJlZm9yZSxcXG4gIC5uZXh0LXBhZ2luYXRpb24gKjphZnRlciB7XFxuICAgIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uOmFmdGVyIHtcXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICBmb250LXNpemU6IDA7XFxuICAgIGNvbnRlbnQ6ICcgJztcXG4gICAgY2xlYXI6IGJvdGg7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24tdG90YWwge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxNnB4OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLXBhZ2VzIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLWxpc3Qge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24gLm5leHQtcGFnaW5hdGlvbi1pdGVtIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9XFxuICAgIC5uZXh0LXBhZ2luYXRpb24gLm5leHQtcGFnaW5hdGlvbi1pdGVtLm5leHQtY3VycmVudCB7XFxuICAgICAgYm9yZGVyLWNvbG9yOiAjNTU4NEZGO1xcbiAgICAgIGJhY2tncm91bmQ6ICM1NTg0RkY7XFxuICAgICAgY29sb3I6ICNGRkZGRkY7IH1cXG4gICAgLm5leHQtcGFnaW5hdGlvbiAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1jdXJyZW50OmhvdmVyLCAubmV4dC1wYWdpbmF0aW9uIC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LWN1cnJlbnQ6Zm9jdXMge1xcbiAgICAgIGJvcmRlci1jb2xvcjogIzU1ODRGRjtcXG4gICAgICBiYWNrZ3JvdW5kOiAjNTU4NEZGO1xcbiAgICAgIGNvbG9yOiAjRkZGRkZGOyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLWVsbGlwc2lzIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICBjb2xvcjogIzk5OTk5OTtcXG4gICAgdmVydGljYWwtYWxpZ246IHRvcDsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi1kaXNwbGF5IHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICBtYXJnaW46IDAgMTZweDtcXG4gICAgY29sb3I6ICMzMzMzMzM7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IH1cXG4gICAgLm5leHQtcGFnaW5hdGlvbi1kaXNwbGF5IGVtIHtcXG4gICAgICBmb250LXN0eWxlOiBub3JtYWw7XFxuICAgICAgY29sb3I6ICM1NTg0RkY7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24tanVtcC10ZXh0IHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICBjb2xvcjogIzk5OTk5OTsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi1qdW1wLWlucHV0IHtcXG4gICAgbWFyZ2luOiAwIDRweDtcXG4gICAgdmVydGljYWwtYWxpZ246IHRvcDsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi1qdW1wLWdvIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gICAgdmVydGljYWwtYWxpZ246IHRvcDsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi1zaXplLXNlbGVjdG9yIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG4gICAgLm5leHQtcGFnaW5hdGlvbi1zaXplLXNlbGVjdG9yLXRpdGxlIHtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDRweDtcXG4gICAgICBjb2xvcjogIzk5OTk5OTsgfVxcbiAgICAubmV4dC1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3ItZmlsdGVyIHtcXG4gICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgfVxcbiAgICAubmV4dC1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3ItZHJvcGRvd24ge1xcbiAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxuICAgICAgbWluLXdpZHRoOiA2NHB4OyB9XFxuICAgIC5uZXh0LXBhZ2luYXRpb24tc2l6ZS1zZWxlY3Rvci1wb3B1cCB7XFxuICAgICAgbWluLXdpZHRoOiA2NHB4OyB9XFxuICAgIC5uZXh0LXBhZ2luYXRpb24tc2l6ZS1zZWxlY3Rvci1idG4ubmV4dC1idG4tdGV4dCB7XFxuICAgICAgaGVpZ2h0OiBpbml0aWFsO1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbml0aWFsO1xcbiAgICAgIGNvbG9yOiAjNjY2NjY2O1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDA7IH1cXG4gICAgICAubmV4dC1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3ItYnRuLm5leHQtYnRuLXRleHQubmV4dC1jdXJyZW50IHtcXG4gICAgICAgIGNvbG9yOiAjNTU4NEZGOyB9XFxuICAgICAgLm5leHQtcGFnaW5hdGlvbi1zaXplLXNlbGVjdG9yLWJ0bi5uZXh0LWJ0bi10ZXh0ICsgLm5leHQtcGFnaW5hdGlvbi1zaXplLXNlbGVjdG9yLWJ0biB7XFxuICAgICAgICBib3JkZXItbGVmdDogMXB4IHNvbGlkICNEQ0RFRTM7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24tcGFnZXMgKyAubmV4dC1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3IsXFxuICAubmV4dC1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3IgKyAubmV4dC1wYWdpbmF0aW9uLXBhZ2VzIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDQwcHg7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1oaWRlIHtcXG4gICAgZGlzcGxheTogbm9uZTsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LXN0YXJ0IC5uZXh0LXBhZ2luYXRpb24tcGFnZXMge1xcbiAgICBmbG9hdDogcmlnaHQ7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1zdGFydCAubmV4dC1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3Ige1xcbiAgICBmbG9hdDogbGVmdDsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LWVuZCAubmV4dC1wYWdpbmF0aW9uLXBhZ2VzIHtcXG4gICAgZmxvYXQ6IGxlZnQ7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1lbmQgLm5leHQtcGFnaW5hdGlvbi1zaXplLXNlbGVjdG9yIHtcXG4gICAgZmxvYXQ6IHJpZ2h0OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtc21hbGwgLm5leHQtcGFnaW5hdGlvbi1saXN0IHtcXG4gICAgbWFyZ2luOiAwIDRweDsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LXNtYWxsIC5uZXh0LXBhZ2luYXRpb24tdG90YWwge1xcbiAgICBsaW5lLWhlaWdodDogMjBweDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LXNtYWxsIC5uZXh0LXBhZ2luYXRpb24taXRlbSB7XFxuICAgIHBhZGRpbmc6IDAgNnB4OyB9XFxuICAgIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1zbWFsbCAubmV4dC1wYWdpbmF0aW9uLWl0ZW0gKyAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ge1xcbiAgICAgIG1hcmdpbjogMCAwIDAgNHB4OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtc21hbGwgLm5leHQtcGFnaW5hdGlvbi1lbGxpcHNpcyB7XFxuICAgIGhlaWdodDogMjBweDtcXG4gICAgbGluZS1oZWlnaHQ6IDIwcHg7XFxuICAgIG1hcmdpbi1sZWZ0OiA4cHg7XFxuICAgIG1hcmdpbi1yaWdodDogOHB4OyB9XFxuICAgIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1zbWFsbCAubmV4dC1wYWdpbmF0aW9uLWVsbGlwc2lzOmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtc21hbGwgLm5leHQtcGFnaW5hdGlvbi1kaXNwbGF5IHtcXG4gICAgZm9udC1zaXplOiAxMnB4OyB9XFxuICAgIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1zbWFsbCAubmV4dC1wYWdpbmF0aW9uLWRpc3BsYXkgZW0ge1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LXNtYWxsIC5uZXh0LXBhZ2luYXRpb24tanVtcC10ZXh0IHtcXG4gICAgZm9udC1zaXplOiAxMnB4OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtc21hbGwgLm5leHQtcGFnaW5hdGlvbi1qdW1wLWlucHV0IHtcXG4gICAgd2lkdGg6IDI4cHg7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1zbWFsbCAubmV4dC1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3ItdGl0bGUge1xcbiAgICBoZWlnaHQ6IDIwcHg7XFxuICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xcbiAgICBmb250LXNpemU6IDEycHg7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1zbWFsbCAubmV4dC1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3ItYnRuIHtcXG4gICAgcGFkZGluZzogMCA4cHg7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1zbWFsbCAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1wcmV2Om5vdChbZGlzYWJsZWRdKSBpLFxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LXNtYWxsIC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LW5leHQ6bm90KFtkaXNhYmxlZF0pIGkge1xcbiAgICBjb2xvcjogIzY2NjY2NjsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LXNtYWxsIC5uZXh0LXBhZ2luYXRpb24taXRlbTpob3Zlci5uZXh0LXByZXY6bm90KFtkaXNhYmxlZF0pIGksXFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtc21hbGwgLm5leHQtcGFnaW5hdGlvbi1pdGVtOmhvdmVyLm5leHQtbmV4dDpub3QoW2Rpc2FibGVkXSkgaSB7XFxuICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtc21hbGwubmV4dC1hcnJvdy1vbmx5IC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LXByZXYsIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1zbWFsbC5uZXh0LWFycm93LW9ubHkgLm5leHQtcGFnaW5hdGlvbi1pdGVtLm5leHQtbmV4dCB7XFxuICAgIHdpZHRoOiAyMHB4O1xcbiAgICBwYWRkaW5nOiAwOyB9XFxuICAgIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1zbWFsbC5uZXh0LWFycm93LW9ubHkgLm5leHQtcGFnaW5hdGlvbi1pdGVtLm5leHQtcHJldiAubmV4dC1pY29uLCAubmV4dC1wYWdpbmF0aW9uLm5leHQtc21hbGwubmV4dC1hcnJvdy1vbmx5IC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LW5leHQgLm5leHQtaWNvbiB7XFxuICAgICAgbWFyZ2luOiAwIGF1dG87IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1zbWFsbC5uZXh0LWFycm93LXByZXYtb25seSAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1wcmV2IHtcXG4gICAgd2lkdGg6IDIwcHg7XFxuICAgIHBhZGRpbmc6IDA7IH1cXG4gICAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LXNtYWxsLm5leHQtYXJyb3ctcHJldi1vbmx5IC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LXByZXYgLm5leHQtaWNvbiB7XFxuICAgICAgbWFyZ2luOiAwIGF1dG87IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1zbWFsbC5uZXh0LW5vLWJvcmRlciAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1wcmV2LCAubmV4dC1wYWdpbmF0aW9uLm5leHQtc21hbGwubmV4dC1uby1ib3JkZXIgLm5leHQtcGFnaW5hdGlvbi1pdGVtLm5leHQtbmV4dCB7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIC13ZWJraXQtYm94LXNoYWRvdzogbm9uZTtcXG4gICAgICAgICAgICBib3gtc2hhZG93OiBub25lOyB9XFxuICAgIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1zbWFsbC5uZXh0LW5vLWJvcmRlciAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1wcmV2IC5uZXh0LWljb24sIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1zbWFsbC5uZXh0LW5vLWJvcmRlciAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1uZXh0IC5uZXh0LWljb24ge1xcbiAgICAgIG1hcmdpbjogMDsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LXNtYWxsLm5leHQtbm8tYm9yZGVyIC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LXByZXY6bm90KFtkaXNhYmxlZF0pOmhvdmVyIGksXFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtc21hbGwubmV4dC1uby1ib3JkZXIgLm5leHQtcGFnaW5hdGlvbi1pdGVtLm5leHQtbmV4dDpub3QoW2Rpc2FibGVkXSk6aG92ZXIgaSB7XFxuICAgIGNvbG9yOiAjNTU4NEZGOyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtc21hbGwubmV4dC1uby1ib3JkZXIgLm5leHQtcGFnaW5hdGlvbi1kaXNwbGF5IHtcXG4gICAgbWFyZ2luOiAwIDhweDsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LXNtYWxsLm5leHQtbWluaSAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1wcmV2IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1zbWFsbC5uZXh0LW1pbmkgLm5leHQtcGFnaW5hdGlvbi1pdGVtLm5leHQtbmV4dCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA0cHg7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1tZWRpdW0gLm5leHQtcGFnaW5hdGlvbi1saXN0IHtcXG4gICAgbWFyZ2luOiAwIDRweDsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LW1lZGl1bSAubmV4dC1wYWdpbmF0aW9uLXRvdGFsIHtcXG4gICAgbGluZS1oZWlnaHQ6IDI4cHg7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1tZWRpdW0gLm5leHQtcGFnaW5hdGlvbi1pdGVtIHtcXG4gICAgcGFkZGluZzogMCAxMHB4OyB9XFxuICAgIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1tZWRpdW0gLm5leHQtcGFnaW5hdGlvbi1pdGVtICsgLm5leHQtcGFnaW5hdGlvbi1pdGVtIHtcXG4gICAgICBtYXJnaW46IDAgMCAwIDRweDsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LW1lZGl1bSAubmV4dC1wYWdpbmF0aW9uLWVsbGlwc2lzIHtcXG4gICAgaGVpZ2h0OiAyOHB4O1xcbiAgICBsaW5lLWhlaWdodDogMjhweDtcXG4gICAgbWFyZ2luLWxlZnQ6IDhweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiA4cHg7IH1cXG4gICAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LW1lZGl1bSAubmV4dC1wYWdpbmF0aW9uLWVsbGlwc2lzOmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbWVkaXVtIC5uZXh0LXBhZ2luYXRpb24tZGlzcGxheSB7XFxuICAgIGZvbnQtc2l6ZTogMTJweDsgfVxcbiAgICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbWVkaXVtIC5uZXh0LXBhZ2luYXRpb24tZGlzcGxheSBlbSB7XFxuICAgICAgZm9udC1zaXplOiAxMnB4OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbWVkaXVtIC5uZXh0LXBhZ2luYXRpb24tanVtcC10ZXh0IHtcXG4gICAgZm9udC1zaXplOiAxMnB4OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbWVkaXVtIC5uZXh0LXBhZ2luYXRpb24tanVtcC1pbnB1dCB7XFxuICAgIHdpZHRoOiAzNnB4OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbWVkaXVtIC5uZXh0LXBhZ2luYXRpb24tc2l6ZS1zZWxlY3Rvci10aXRsZSB7XFxuICAgIGhlaWdodDogMjhweDtcXG4gICAgbGluZS1oZWlnaHQ6IDI4cHg7XFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LW1lZGl1bSAubmV4dC1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3ItYnRuIHtcXG4gICAgcGFkZGluZzogMCAxMnB4OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbWVkaXVtIC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LXByZXY6bm90KFtkaXNhYmxlZF0pIGksXFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbWVkaXVtIC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LW5leHQ6bm90KFtkaXNhYmxlZF0pIGkge1xcbiAgICBjb2xvcjogIzY2NjY2NjsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LW1lZGl1bSAubmV4dC1wYWdpbmF0aW9uLWl0ZW06aG92ZXIubmV4dC1wcmV2Om5vdChbZGlzYWJsZWRdKSBpLFxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LW1lZGl1bSAubmV4dC1wYWdpbmF0aW9uLWl0ZW06aG92ZXIubmV4dC1uZXh0Om5vdChbZGlzYWJsZWRdKSBpIHtcXG4gICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1tZWRpdW0ubmV4dC1hcnJvdy1vbmx5IC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LXByZXYsIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1tZWRpdW0ubmV4dC1hcnJvdy1vbmx5IC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LW5leHQge1xcbiAgICB3aWR0aDogMjhweDtcXG4gICAgcGFkZGluZzogMDsgfVxcbiAgICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbWVkaXVtLm5leHQtYXJyb3ctb25seSAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1wcmV2IC5uZXh0LWljb24sIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1tZWRpdW0ubmV4dC1hcnJvdy1vbmx5IC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LW5leHQgLm5leHQtaWNvbiB7XFxuICAgICAgbWFyZ2luOiAwIGF1dG87IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1tZWRpdW0ubmV4dC1hcnJvdy1wcmV2LW9ubHkgLm5leHQtcGFnaW5hdGlvbi1pdGVtLm5leHQtcHJldiB7XFxuICAgIHdpZHRoOiAyOHB4O1xcbiAgICBwYWRkaW5nOiAwOyB9XFxuICAgIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1tZWRpdW0ubmV4dC1hcnJvdy1wcmV2LW9ubHkgLm5leHQtcGFnaW5hdGlvbi1pdGVtLm5leHQtcHJldiAubmV4dC1pY29uIHtcXG4gICAgICBtYXJnaW46IDAgYXV0bzsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LW1lZGl1bS5uZXh0LW5vLWJvcmRlciAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1wcmV2LCAubmV4dC1wYWdpbmF0aW9uLm5leHQtbWVkaXVtLm5leHQtbm8tYm9yZGVyIC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LW5leHQge1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IG5vbmU7XFxuICAgICAgICAgICAgYm94LXNoYWRvdzogbm9uZTsgfVxcbiAgICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbWVkaXVtLm5leHQtbm8tYm9yZGVyIC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LXByZXYgLm5leHQtaWNvbiwgLm5leHQtcGFnaW5hdGlvbi5uZXh0LW1lZGl1bS5uZXh0LW5vLWJvcmRlciAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1uZXh0IC5uZXh0LWljb24ge1xcbiAgICAgIG1hcmdpbjogMDsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LW1lZGl1bS5uZXh0LW5vLWJvcmRlciAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1wcmV2Om5vdChbZGlzYWJsZWRdKTpob3ZlciBpLFxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LW1lZGl1bS5uZXh0LW5vLWJvcmRlciAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1uZXh0Om5vdChbZGlzYWJsZWRdKTpob3ZlciBpIHtcXG4gICAgY29sb3I6ICM1NTg0RkY7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1tZWRpdW0ubmV4dC1uby1ib3JkZXIgLm5leHQtcGFnaW5hdGlvbi1kaXNwbGF5IHtcXG4gICAgbWFyZ2luOiAwIDEycHg7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1tZWRpdW0ubmV4dC1taW5pIC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LXByZXYge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LW1lZGl1bS5uZXh0LW1pbmkgLm5leHQtcGFnaW5hdGlvbi1pdGVtLm5leHQtbmV4dCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA0cHg7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1sYXJnZSAubmV4dC1wYWdpbmF0aW9uLWxpc3Qge1xcbiAgICBtYXJnaW46IDAgOHB4OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbGFyZ2UgLm5leHQtcGFnaW5hdGlvbi10b3RhbCB7XFxuICAgIGxpbmUtaGVpZ2h0OiA0MHB4O1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbGFyZ2UgLm5leHQtcGFnaW5hdGlvbi1pdGVtIHtcXG4gICAgcGFkZGluZzogMCAxNXB4OyB9XFxuICAgIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1sYXJnZSAubmV4dC1wYWdpbmF0aW9uLWl0ZW0gKyAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ge1xcbiAgICAgIG1hcmdpbjogMCAwIDAgOHB4OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbGFyZ2UgLm5leHQtcGFnaW5hdGlvbi1lbGxpcHNpcyB7XFxuICAgIGhlaWdodDogNDBweDtcXG4gICAgbGluZS1oZWlnaHQ6IDQwcHg7XFxuICAgIG1hcmdpbi1sZWZ0OiA4cHg7XFxuICAgIG1hcmdpbi1yaWdodDogOHB4OyB9XFxuICAgIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1sYXJnZSAubmV4dC1wYWdpbmF0aW9uLWVsbGlwc2lzOmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbGFyZ2UgLm5leHQtcGFnaW5hdGlvbi1kaXNwbGF5IHtcXG4gICAgZm9udC1zaXplOiAxNnB4OyB9XFxuICAgIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1sYXJnZSAubmV4dC1wYWdpbmF0aW9uLWRpc3BsYXkgZW0ge1xcbiAgICAgIGZvbnQtc2l6ZTogMTZweDsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LWxhcmdlIC5uZXh0LXBhZ2luYXRpb24tanVtcC10ZXh0IHtcXG4gICAgZm9udC1zaXplOiAxNnB4OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbGFyZ2UgLm5leHQtcGFnaW5hdGlvbi1qdW1wLWlucHV0IHtcXG4gICAgd2lkdGg6IDQ4cHg7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1sYXJnZSAubmV4dC1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3ItdGl0bGUge1xcbiAgICBoZWlnaHQ6IDQwcHg7XFxuICAgIGxpbmUtaGVpZ2h0OiA0MHB4O1xcbiAgICBmb250LXNpemU6IDE2cHg7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1sYXJnZSAubmV4dC1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3ItYnRuIHtcXG4gICAgcGFkZGluZzogMCAxNnB4OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbGFyZ2UgLm5leHQtcGFnaW5hdGlvbi1pdGVtLm5leHQtcHJldjpub3QoW2Rpc2FibGVkXSkgaSxcXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1sYXJnZSAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1uZXh0Om5vdChbZGlzYWJsZWRdKSBpIHtcXG4gICAgY29sb3I6ICM2NjY2NjY7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1sYXJnZSAubmV4dC1wYWdpbmF0aW9uLWl0ZW06aG92ZXIubmV4dC1wcmV2Om5vdChbZGlzYWJsZWRdKSBpLFxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LWxhcmdlIC5uZXh0LXBhZ2luYXRpb24taXRlbTpob3Zlci5uZXh0LW5leHQ6bm90KFtkaXNhYmxlZF0pIGkge1xcbiAgICBjb2xvcjogIzMzMzMzMzsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LWxhcmdlLm5leHQtYXJyb3ctb25seSAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1wcmV2LCAubmV4dC1wYWdpbmF0aW9uLm5leHQtbGFyZ2UubmV4dC1hcnJvdy1vbmx5IC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LW5leHQge1xcbiAgICB3aWR0aDogNDBweDtcXG4gICAgcGFkZGluZzogMDsgfVxcbiAgICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbGFyZ2UubmV4dC1hcnJvdy1vbmx5IC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LXByZXYgLm5leHQtaWNvbiwgLm5leHQtcGFnaW5hdGlvbi5uZXh0LWxhcmdlLm5leHQtYXJyb3ctb25seSAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1uZXh0IC5uZXh0LWljb24ge1xcbiAgICAgIG1hcmdpbjogMCBhdXRvOyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbGFyZ2UubmV4dC1hcnJvdy1wcmV2LW9ubHkgLm5leHQtcGFnaW5hdGlvbi1pdGVtLm5leHQtcHJldiB7XFxuICAgIHdpZHRoOiA0MHB4O1xcbiAgICBwYWRkaW5nOiAwOyB9XFxuICAgIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1sYXJnZS5uZXh0LWFycm93LXByZXYtb25seSAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1wcmV2IC5uZXh0LWljb24ge1xcbiAgICAgIG1hcmdpbjogMCBhdXRvOyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbGFyZ2UubmV4dC1uby1ib3JkZXIgLm5leHQtcGFnaW5hdGlvbi1pdGVtLm5leHQtcHJldiwgLm5leHQtcGFnaW5hdGlvbi5uZXh0LWxhcmdlLm5leHQtbm8tYm9yZGVyIC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LW5leHQge1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IG5vbmU7XFxuICAgICAgICAgICAgYm94LXNoYWRvdzogbm9uZTsgfVxcbiAgICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbGFyZ2UubmV4dC1uby1ib3JkZXIgLm5leHQtcGFnaW5hdGlvbi1pdGVtLm5leHQtcHJldiAubmV4dC1pY29uLCAubmV4dC1wYWdpbmF0aW9uLm5leHQtbGFyZ2UubmV4dC1uby1ib3JkZXIgLm5leHQtcGFnaW5hdGlvbi1pdGVtLm5leHQtbmV4dCAubmV4dC1pY29uIHtcXG4gICAgICBtYXJnaW46IDA7IH1cXG4gIC5uZXh0LXBhZ2luYXRpb24ubmV4dC1sYXJnZS5uZXh0LW5vLWJvcmRlciAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1wcmV2Om5vdChbZGlzYWJsZWRdKTpob3ZlciBpLFxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LWxhcmdlLm5leHQtbm8tYm9yZGVyIC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LW5leHQ6bm90KFtkaXNhYmxlZF0pOmhvdmVyIGkge1xcbiAgICBjb2xvcjogIzU1ODRGRjsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LWxhcmdlLm5leHQtbm8tYm9yZGVyIC5uZXh0LXBhZ2luYXRpb24tZGlzcGxheSB7XFxuICAgIG1hcmdpbjogMCAxNnB4OyB9XFxuICAubmV4dC1wYWdpbmF0aW9uLm5leHQtbGFyZ2UubmV4dC1taW5pIC5uZXh0LXBhZ2luYXRpb24taXRlbS5uZXh0LXByZXYge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDhweDsgfVxcbiAgLm5leHQtcGFnaW5hdGlvbi5uZXh0LWxhcmdlLm5leHQtbWluaSAubmV4dC1wYWdpbmF0aW9uLWl0ZW0ubmV4dC1uZXh0IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDhweDsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlcj8/cmVmLS0yLTEhLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYj8/cmVmLS0yLTIhLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIhLi9zcmMvcGFnaW5hdGlvbi9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDE4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnBhZ2UtZGVtbyB7XFxuICAgIG1hcmdpbi10b3A6MTBweDtcXG59XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyIS4vc2NyaXB0cy9zZXJ2ZXIvbG9hZGVycy9kZW1vL3NlbGVjdG9yLmpzIS4vZG9jcy90YWJsZS9kZW1vL3BhZ2luYXRpb24ubWRcbi8vIG1vZHVsZSBpZCA9IDE4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHtmdW5jfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCB6aENOIGZyb20gJy4uL2xvY2FsZS96aC1jbic7XG5cbmNsYXNzIEJhc2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW9k+WJjeWAvFxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIneWni+WMluWAvFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlj5HnlJ/mlLnlj5jnmoTml7blgJnop6blj5HnmoTlm57osINcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIOaVsOaNrlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIERPTeS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog6ZSu55uY5oyJ5LiL55qE5pe25YCZ6Kem5Y+R55qE5Zue6LCDXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRE9N5LqL5Lu25a+56LGhXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIOWPr+aJqeWxleeahOmZhOWKoOS/oeaBr++8mjxicj4gLSBvcHRzLm92ZXJNYXhMZW5ndGg6IHtCb29sZWFufSDlt7LotoXlh7rmnIDlpKfplb/luqY8YnI+IC0gb3B0cy5iZVRyaW1lZDoge0Jvb2xlYW59IOi+k+WFpeeahOepuuagvOiiq+a4heeQhlxuICAgICAgICAgKi9cbiAgICAgICAgb25LZXlEb3duOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOemgeeUqOeKtuaAgVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5pyA5aSn6ZW/5bqmXG4gICAgICAgICAqL1xuICAgICAgICBtYXhMZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblsZXnjrDmnIDlpKfplb/luqbmoLflvI9cbiAgICAgICAgICovXG4gICAgICAgIGhhc0xpbWl0SGludDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvZPorr7nva7kuoZtYXhMZW5ndGjml7bvvIzmmK/lkKbmiKrmlq3otoXlh7rlrZfnrKbkuLJcbiAgICAgICAgICovXG4gICAgICAgIGN1dFN0cmluZzogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlj6ror7tcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRPbmx5OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9uQ2hhbmdl6L+U5Zue5Lya6Ieq5Yqo5Y676Zmk5aS05bC+56m65a2X56ymXG4gICAgICAgICAqL1xuICAgICAgICB0cmltOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOi+k+WFpeaPkOekulxuICAgICAgICAgKi9cbiAgICAgICAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bnhKbngrnml7blgJnop6blj5HnmoTlm57osINcbiAgICAgICAgICovXG4gICAgICAgIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5aSx5Y6754Sm54K55pe25YCZ6Kem5Y+R55qE5Zue6LCDXG4gICAgICAgICAqL1xuICAgICAgICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ5a2X56ym5Liy6K6h566X6ZW/5bqm5pa55byPXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSDmlbDmja5cbiAgICAgICAgICogQHJldHVybnMge051bWJlcn0g6Ieq5a6a5LmJ6ZW/5bqmXG4gICAgICAgICAqL1xuICAgICAgICBnZXRWYWx1ZUxlbmd0aDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGlucHV0U3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYljbGFzc1xuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ5YaF6IGU5qC35byPXG4gICAgICAgICAqL1xuICAgICAgICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWOn+eUn3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGh0bWxUeXBlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICogbmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgc3RhdGU6IFByb3BUeXBlcy5vbmVPZihbJ2Vycm9yJywgJ2xvYWRpbmcnLCAnc3VjY2VzcyddKSxcbiAgICAgICAgbG9jYWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIHByZWZpeDogJ25leHQtJyxcbiAgICAgICAgbWF4TGVuZ3RoOiBudWxsLFxuICAgICAgICBoYXNMaW1pdEhpbnQ6IGZhbHNlLFxuICAgICAgICBjdXRTdHJpbmc6IHRydWUsXG4gICAgICAgIHJlYWRPbmx5OiBmYWxzZSxcbiAgICAgICAgdHJpbTogZmFsc2UsXG4gICAgICAgIG9uRm9jdXM6IGZ1bmMubm9vcCxcbiAgICAgICAgb25CbHVyOiBmdW5jLm5vb3AsXG4gICAgICAgIG9uQ2hhbmdlOiBmdW5jLm5vb3AsXG4gICAgICAgIG9uS2V5RG93bjogZnVuYy5ub29wLFxuICAgICAgICBnZXRWYWx1ZUxlbmd0aDogZnVuYy5ub29wLFxuICAgICAgICBsb2NhbGU6IHpoQ04uSW5wdXQsXG4gICAgfTtcblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIGlmICgndmFsdWUnIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHR5cGVvZiBuZXh0UHJvcHMudmFsdWUgPT09ICd1bmRlZmluZWQnID8gJycgOiBuZXh0UHJvcHMudmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWVIYWNrKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBvbkNoYW5nZShlKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnRyaW0pIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB0aGlzLmllSGFjayh2YWx1ZSk7XG5cbiAgICAgICAgLy8gbm90IGNvbnRyb2xsZWRcbiAgICAgICAgaWYgKCEoJ3ZhbHVlJyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTnVtYmVyKCcnKSA9IDBcbiAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMucHJvcHMuaHRtbFR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHZhbHVlLCBlKTtcbiAgICB9XG5cbiAgICBvbktleURvd24oZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICBjb25zdCB7IG1heExlbmd0aCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgbGVuID0gbWF4TGVuZ3RoID4gMCAmJiB2YWx1ZSA/IHRoaXMuZ2V0VmFsdWVMZW5ndGgodmFsdWUpIDogMDtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHt9O1xuXG4gICAgICAgIC8vIGhhcyBlbmFibGUgdHJpbSBhbmQgaGFzIGlucHV0IHdoaXRlc3BhY2VcbiAgICAgICAgaWYgKHRoaXMucHJvcHMudHJpbSAmJiBlLmtleUNvZGUgPT09IDMyKSB7XG4gICAgICAgICAgICBvcHRzLmJlVHJpbWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhcyBkZWZpbmVkIG1heExlbmd0aCBhbmQgaGFzIG92ZXIgbWF4IGxlbmd0aCBhbmQgaGFzIG5vdCBpbnB1dCBiYWNrc3BhY2UgYW5kIGRlbGV0ZVxuICAgICAgICBpZiAobWF4TGVuZ3RoID4gMCAmJiAobGVuID4gbWF4TGVuZ3RoICsgMSB8fFxuICAgICAgICAgICAgICAgICgobGVuID09PSBtYXhMZW5ndGggfHwgbGVuID09PSBtYXhMZW5ndGggKyAxKSAmJiBlLmtleUNvZGUgIT09IDggJiYgZS5rZXlDb2RlICE9PSA0NilcbiAgICAgICAgKSkge1xuICAgICAgICAgICAgb3B0cy5vdmVyTWF4TGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJvcHMub25LZXlEb3duKGUsIG9wdHMpO1xuICAgIH1cblxuICAgIG9uRm9jdXMoZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZvY3VzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3BzLm9uRm9jdXMoZSk7XG4gICAgfVxuXG4gICAgb25CbHVyKGUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBmb2N1czogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJvcHMub25CbHVyKGUpO1xuICAgIH1cblxuICAgIHJlbmRlckxlbmd0aCgpIHtcbiAgICAgICAgY29uc3QgeyBtYXhMZW5ndGgsIGhhc0xpbWl0SGludCwgcHJlZml4LCBydGwgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGxlbiA9IG1heExlbmd0aCA+IDAgJiYgdGhpcy5zdGF0ZS52YWx1ZSA/IHRoaXMuZ2V0VmFsdWVMZW5ndGgodGhpcy5zdGF0ZS52YWx1ZSkgOiAwO1xuXG4gICAgICAgIGNvbnN0IGNsYXNzZXNMZW5XcmFwID0gY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fWlucHV0LWxlbmBdOiB0cnVlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1lcnJvcmBdOiBsZW4gPiBtYXhMZW5ndGhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgY29udGVudCA9IHJ0bCA/IGAke21heExlbmd0aH0vJHtsZW59YCA6IGAke2xlbn0vJHttYXhMZW5ndGh9YDtcblxuICAgICAgICByZXR1cm4gbWF4TGVuZ3RoICYmIGhhc0xpbWl0SGludCA/IDxzcGFuIGNsYXNzTmFtZT17Y2xhc3Nlc0xlbldyYXB9Pntjb250ZW50fTwvc3Bhbj4gOiBudWxsO1xuICAgIH1cblxuICAgIHJlbmRlckNvbnRyb2woKSB7XG4gICAgICAgIGNvbnN0IGxlbldyYXAgPSB0aGlzLnJlbmRlckxlbmd0aCgpO1xuXG4gICAgICAgIHJldHVybiBsZW5XcmFwID8gPHNwYW4gY2xhc3NOYW1lPXtgJHt0aGlzLnByb3BzLnByZWZpeH1pbnB1dC1jb250cm9sYH0+XG4gICAgICAgICAgICB7bGVuV3JhcH1cbiAgICAgICAgPC9zcGFuPiA6IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0Q2xhc3MoKSB7XG4gICAgICAgIGNvbnN0IHsgZGlzYWJsZWQsIHN0YXRlLCBwcmVmaXggfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1pbnB1dGBdOiB0cnVlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1kaXNhYmxlZGBdOiAhIWRpc2FibGVkLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1lcnJvcmBdOiBzdGF0ZSA9PT0gJ2Vycm9yJyxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9Zm9jdXNgXTogdGhpcy5zdGF0ZS5mb2N1cyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0UHJvcHMoKSB7XG4gICAgICAgIGNvbnN0IHsgcGxhY2Vob2xkZXIsIGlucHV0U3R5bGUsIGRpc2FibGVkLCByZWFkT25seSwgY3V0U3RyaW5nLCBtYXhMZW5ndGggfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICAgICAgc3R5bGU6IGlucHV0U3R5bGUsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgcmVhZE9ubHksXG4gICAgICAgICAgICBtYXhMZW5ndGg6IGN1dFN0cmluZyA/IG1heExlbmd0aCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLnZhbHVlLFxuICAgICAgICAgICAgb25DaGFuZ2U6IHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG9uQmx1cjogdGhpcy5vbkJsdXIuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG9uRm9jdXM6IHRoaXMub25Gb2N1cy5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGZpeCBhY2Nlc3NpYmlsaXR577yaYXV0byBwcm9jZXNzIHN0YXR1cyBvZiBhcmlhIGRpc2FibGVkXG4gICAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICAgICAgcHJvcHNbJ2FyaWEtZGlzYWJsZWQnXSA9IGRpc2FibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH1cblxuICAgIHNhdmVSZWYgPSAoaW5wdXQpID0+IHtcbiAgICAgICAgdGhpcy5pbnB1dFJlZiA9IGlucHV0O1xuICAgIH07XG5cbiAgICBnZXRJbnB1dE5vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0UmVmO1xuICAgIH1cblxuICAgIGZvY3VzKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5pbnB1dFJlZi5mb2N1cygpO1xuICAgICAgICBpZiAodHlwZW9mIHN0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFJlZi5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFJlZi5zZWxlY3Rpb25FbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5wdXQvYmFzZS5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IENvbmZpZ1Byb3ZpZGVyIGZyb20gJy4uL2NvbmZpZy1wcm92aWRlcic7XG5cbi8qKlxuICogSW5wdXQuR3JvdXBcbiAqL1xuY2xhc3MgR3JvdXAgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmoLflvI/liY3nvIBcbiAgICAgICAgICovXG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICAvKipcbiAgICAgICAgICog6L6T5YWl5qGG5YmN6ZmE5Yqg5YaF5a65XG4gICAgICAgICAqL1xuICAgICAgICBhZGRvbkJlZm9yZTogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDovpPlhaXmoYbliY3pmYTliqDlhoXlrrljc3NcbiAgICAgICAgICovXG4gICAgICAgIGFkZG9uQmVmb3JlQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog6L6T5YWl5qGG5ZCO6ZmE5Yqg5YaF5a65XG4gICAgICAgICAqL1xuICAgICAgICBhZGRvbkFmdGVyOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOi+k+WFpeahhuWQjumineWklmNzc1xuICAgICAgICAgKi9cbiAgICAgICAgYWRkb25BZnRlckNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJ0bFxuICAgICAgICAgKi9cbiAgICAgICAgcnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgIH07XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHtjbGFzc05hbWUsIHN0eWxlLCBjaGlsZHJlbiwgcHJlZml4LCBhZGRvbkJlZm9yZSwgYWRkb25BZnRlciwgYWRkb25CZWZvcmVDbGFzc05hbWUsIGFkZG9uQWZ0ZXJDbGFzc05hbWUsIHJ0bCwgLi4ub3RoZXJzfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgY29uc3QgY2xzID0gY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fWlucHV0LWdyb3VwYF06IHRydWUsXG4gICAgICAgICAgICBbY2xhc3NOYW1lXTogISFjbGFzc05hbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgYWRkb25DbHMgPSBgJHtwcmVmaXh9aW5wdXQtZ3JvdXAtYWRkb25gO1xuICAgICAgICBjb25zdCBiZWZvcmVDbHMgPSBjbGFzc05hbWVzKGFkZG9uQ2xzLCB7XG4gICAgICAgICAgICBbYCR7cHJlZml4fWJlZm9yZWBdOiB0cnVlLFxuICAgICAgICAgICAgW2FkZG9uQmVmb3JlQ2xhc3NOYW1lXTogYWRkb25CZWZvcmVDbGFzc05hbWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhZnRlckNscyA9IGNsYXNzTmFtZXMoYWRkb25DbHMsIHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9YWZ0ZXJgXTogdHJ1ZSxcbiAgICAgICAgICAgIFthZGRvbkFmdGVyQ2xhc3NOYW1lXTogYWRkb25BZnRlckNsYXNzTmFtZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgYmVmb3JlID0gYWRkb25CZWZvcmUgPyAoXG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2JlZm9yZUNsc30+XG4gICAgICAgICAgICAgICAge2FkZG9uQmVmb3JlfVxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICApIDogbnVsbDtcblxuICAgICAgICBjb25zdCBhZnRlciA9IGFkZG9uQWZ0ZXIgPyAoXG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2FmdGVyQ2xzfT5cbiAgICAgICAgICAgICAgICB7YWRkb25BZnRlcn1cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgKSA6IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxzcGFuIHsuLi5vdGhlcnN9IGRpcj17cnRsID8gJ3J0bCcgOiB1bmRlZmluZWR9IGNsYXNzTmFtZT17Y2xzfSBzdHlsZT17c3R5bGV9PlxuICAgICAgICAgICAgICAgIHtiZWZvcmV9XG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgICAgIHthZnRlcn1cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZ1Byb3ZpZGVyLmNvbmZpZyhHcm91cCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5wdXQvZ3JvdXAuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgZnVuYywgZG9tLCBldmVudHMgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBNZW51IGZyb20gJy4uL21lbnUnO1xuaW1wb3J0IE92ZXJsYXkgZnJvbSAnLi4vb3ZlcmxheSc7XG5pbXBvcnQgemhDTiBmcm9tICcuLi9sb2NhbGUvemgtY24nO1xuaW1wb3J0IERhdGFTdG9yZSBmcm9tICcuL2RhdGEtc3RvcmUnO1xuaW1wb3J0IFZpcnR1YWxMaXN0IGZyb20gJy4uL3ZpcnR1YWwtbGlzdCc7XG5pbXBvcnQgeyBpc1NpbmdsZSwgZmlsdGVyLCBpc051bGwsIHZhbHVlVG9TZWxlY3RLZXkgfSBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCB7IFBvcHVwIH0gPSBPdmVybGF5O1xuY29uc3QgeyBJdGVtOiBNZW51SXRlbSwgR3JvdXA6IE1lbnVHcm91cCB9ID0gTWVudTtcbmNvbnN0IHsgbm9vcCwgYmluZEN0eCwgbWFrZUNoYWluIH0gPSBmdW5jO1xuXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpgInmi6nlmajlsLrlr7hcbiAgICAgICAgICovXG4gICAgICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3NtYWxsJywgJ21lZGl1bScsICdsYXJnZSddKSxcbiAgICAgICAgLy8g5b2T5YmN5YC877yM55So5LqO5Y+X5o6n5qih5byPXG4gICAgICAgIHZhbHVlOiBQcm9wVHlwZXMuYW55LCAvLyB0byBiZSBvdmVycmlkZVxuICAgICAgICAvLyDliJ3lp4vljJbnmoTpu5jorqTlgLxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMuYW55LCAvLyB0byBiZSBvdmVycmlkZVxuICAgICAgICAvKipcbiAgICAgICAgICog5rKh5pyJ5YC855qE5pe25YCZ55qE5Y2g5L2N56ymXG4gICAgICAgICAqL1xuICAgICAgICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS4i+aLieiPnOWNleaYr+WQpuS4jumAieaLqeWZqOWvuem9kFxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b1dpZHRoOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieWGheiBlCBsYWJlbFxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5pyJ5riF6Zmk5oyJ6ZKuXG4gICAgICAgICAqL1xuICAgICAgICBoYXNDbGVhcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmoKHpqoznirbmgIFcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRlOiBQcm9wVHlwZXMub25lT2YoWydlcnJvcicsICdsb2FkaW5nJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5Y+q6K+777yM5Y+q6K+75qih5byP5LiL5Y+v5Lul5bGV5byA5by55bGC5L2G5LiN6IO96YCJXG4gICAgICAgICAqL1xuICAgICAgICByZWFkT25seTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbnpoHnlKjpgInmi6nlmahcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW9k+WJjeW8ueWxguaYr+WQpuaYvuekulxuICAgICAgICAgKi9cbiAgICAgICAgdmlzaWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLliJ3lp4vljJbmmK/lkKbmmL7npLpcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRWaXNpYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguaYvuekuuaIlumakOiXj+aXtuinpuWPkeeahOWbnuiwg1xuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGUg5by55bGC5piv5ZCm5pi+56S6XG4gICAgICAgICAqL1xuICAgICAgICBvblZpc2libGVDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5oyC6L2955qE5a655Zmo6IqC54K5XG4gICAgICAgICAqL1xuICAgICAgICBwb3B1cENvbnRhaW5lcjogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICAgICAgICBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAgICAgUHJvcFR5cGVzLmZ1bmNcbiAgICAgICAgXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLnmoQgY2xhc3NOYW1lXG4gICAgICAgICAqL1xuICAgICAgICBwb3B1cENsYXNzTmFtZTogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxgueahOWGheiBlOagt+W8j1xuICAgICAgICAgKi9cbiAgICAgICAgcG9wdXBTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWIsOW8ueWxguS4iueahOWxnuaAp1xuICAgICAgICAgKi9cbiAgICAgICAgcG9wdXBQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieW8ueWxgueahOWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgcG9wdXBDb250ZW50OiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuS9v+eUqOacrOWcsOi/h+a7pO+8jOWcqOaVsOaNrua6kOS4uui/nOeoi+eahOaXtuWAmemcgOimgeWFs+mXreatpOmhuVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsdGVyTG9jYWw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5pys5Zyw6L+H5ruk5pa55rOV77yM6L+U5Zue5LiA5LiqIEJvb2xlYW4g5YC856Gu5a6a5piv5ZCm5L+d55WZXG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog6ZSu55uY5LiK5LiL6ZSu5YiH5o2i6I+c5Y2V6auY5Lqu6YCJ6aG555qE5Zue6LCDXG4gICAgICAgICAqL1xuICAgICAgICBvblRvZ2dsZUhpZ2hsaWdodEl0ZW06IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5byA5ZCv6Jma5ouf5rua5Yqo5qih5byPXG4gICAgICAgICAqL1xuICAgICAgICB1c2VWaXJ0dWFsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLy8g6Ieq5a6a5LmJ57G75ZCNXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gICAgICAgIGRhdGFTb3VyY2U6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgaXRlbVJlbmRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG1vZGU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIG5vdEZvdW5kQ29udGVudDogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIGxvY2FsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgcnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgICAgICBzaXplOiAnbWVkaXVtJyxcbiAgICAgICAgYXV0b1dpZHRoOiB0cnVlLFxuICAgICAgICBvbkNoYW5nZTogbm9vcCxcbiAgICAgICAgb25WaXNpYmxlQ2hhbmdlOiBub29wLFxuICAgICAgICBvblRvZ2dsZUhpZ2hsaWdodEl0ZW06IG5vb3AsXG4gICAgICAgIHBvcHVwUHJvcHM6IHt9LFxuICAgICAgICBmaWx0ZXJMb2NhbDogdHJ1ZSxcbiAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgIGl0ZW1SZW5kZXI6IChpdGVtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5sYWJlbCB8fCBpdGVtLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBsb2NhbGU6IHpoQ04uU2VsZWN0LFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5kYXRhU3RvcmUgPSBuZXcgRGF0YVN0b3JlKHtcbiAgICAgICAgICAgIGZpbHRlcjogcHJvcHMuZmlsdGVyLFxuICAgICAgICAgICAgZmlsdGVyTG9jYWw6IHByb3BzLmZpbHRlckxvY2FsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB2YWx1ZTogJ3ZhbHVlJyBpbiBwcm9wcyA/IHByb3BzLnZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgdmlzaWJsZTogJ3Zpc2libGUnIGluIHByb3BzID8gcHJvcHMudmlzaWJsZSA6IHByb3BzLmRlZmF1bHRWaXNpYmxlLFxuICAgICAgICAgICAgZGF0YVNvdXJjZTogW10sXG4gICAgICAgICAgICB3aWR0aDogMTAwLFxuICAgICAgICAgICAgLy8gY3VycmVudCBoaWdobGlnaHQga2V5XG4gICAgICAgICAgICBoaWdobGlnaHRLZXk6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBiaW5kQ3R4KHRoaXMsIFtcbiAgICAgICAgICAgICdoYW5kbGVNZW51Qm9keUNsaWNrJyxcbiAgICAgICAgICAgICdoYW5kbGVWaXNpYmxlQ2hhbmdlJyxcbiAgICAgICAgICAgICdmb2N1c0lucHV0JyxcbiAgICAgICAgICAgICdiZWZvcmVPcGVuJyxcbiAgICAgICAgICAgICdiZWZvcmVDbG9zZScsXG4gICAgICAgICAgICAnYWZ0ZXJDbG9zZScsXG4gICAgICAgICAgICAnaGFuZGxlUmVzaXplJyxcbiAgICAgICAgXSk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGRhdGFTb3VyY2U6IHRoaXMuc2V0RGF0YVNvdXJjZSh0aGlzLnByb3BzKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgLy8gb3ZlcmxheSDov5jmsqHmnInlrozmiJAgbW91bnTvvIzmiYDku6XpnIDopoHmu57lkI7lkIzmraXlrr3luqZcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnN5bmNXaWR0aCgpLCAwKTtcblxuICAgICAgICBldmVudHMub24od2luZG93LCAncmVzaXplJywgdGhpcy5oYW5kbGVSZXNpemUpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIGlmICgndmFsdWUnIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5leHRQcm9wcy52YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ3Zpc2libGUnIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgLy8gdGhpcy5zdGF0ZS52aXNpYmxlID0gbmV4dFByb3BzLnZpc2libGU7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiBuZXh0UHJvcHMudmlzaWJsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGFTdG9yZS5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIGZpbHRlcjogbmV4dFByb3BzLmZpbHRlcixcbiAgICAgICAgICAgIGZpbHRlckxvY2FsOiBuZXh0UHJvcHMuZmlsdGVyTG9jYWxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKChuZXh0UHJvcHMuY2hpbGRyZW4gIT09IHRoaXMucHJvcHMuY2hpbGRyZW4gfHwgbmV4dFByb3BzLmRhdGFTb3VyY2UgIT09IHRoaXMucHJvcHMuZGF0YVNvdXJjZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFTb3VyY2UgPSB0aGlzLnNldERhdGFTb3VyY2UobmV4dFByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICAgIGlmICgocHJldlByb3BzLmxhYmVsICE9PSB0aGlzLnByb3BzLmxhYmVsIHx8IHByZXZTdGF0ZS52YWx1ZSAhPT0gdGhpcy5zdGF0ZS52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3luY1dpZHRoKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgZXZlbnRzLm9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVvdXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBhbmQgc2V0IHdpZHRoIG9mIHBvcHVwIG1lbnVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3luY1dpZHRoKCkge1xuICAgICAgICBjb25zdCB3aWR0aCA9IGRvbS5nZXRTdHlsZSh0aGlzLnNlbGVjdERPTSwgJ3dpZHRoJyk7XG5cbiAgICAgICAgaWYgKHdpZHRoICYmICh0aGlzLndpZHRoICE9PSB3aWR0aCkpIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcblxuICAgICAgICAgICAgaWYgKHRoaXMucG9wdXBSZWYgJiYgdGhpcy5wcm9wcy5hdXRvV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBvdmVyeSDnmoQgbm9kZSDoioLngrnlj6/og73msqHmnInmjILovb3lrozmiJDvvIzmiYDku6Xov5nph4zpnIDopoHlvILmraVcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucG9wdXBSZWYgJiYgdGhpcy5wb3B1cFJlZi5nZXRJbnN0YW5jZSgpLm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5zZXRTdHlsZSh0aGlzLnBvcHVwUmVmLmdldEluc3RhbmNlKCkub3ZlcmxheS5nZXRJbnN0YW5jZSgpLmdldENvbnRlbnROb2RlKCksICd3aWR0aCcsIHRoaXMud2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVSZXNpemUoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVvdXQpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNXaWR0aCgpO1xuICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBzdHJ1Y3R1cmVkIGRhdGFTb3VyY2UsIGZvciBjYWNoZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtwcm9wcz10aGlzLnByb3BzXVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIHNldERhdGFTb3VyY2UocHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhU291cmNlLCBjaGlsZHJlbiB9ID0gcHJvcHM7XG5cbiAgICAgICAgLy8gY2hpbGRyZW4gaXMgaGlnaGVyIHByaW9yaXR5IHRoZW4gZGF0YVNvdXJjZVxuICAgICAgICBpZiAoQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU3RvcmUudXBkYXRlQnlEUyhjaGlsZHJlbiwgdHJ1ZSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGFTb3VyY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU3RvcmUudXBkYXRlQnlEUyhkYXRhU291cmNlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBwb3B1cCB2aXNpYmxlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmlzaWJsZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRyaWdnZXIgdHlwZVxuICAgICAqL1xuICAgIHNldFZpc2libGUodmlzaWJsZSwgdHlwZSkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5kaXNhYmxlZCB8fCB0aGlzLnN0YXRlLnZpc2libGUgPT09IHZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKCd2aXNpYmxlJyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgdmlzaWJsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3BzLm9uVmlzaWJsZUNoYW5nZSh2aXNpYmxlLCB0eXBlKTtcbiAgICB9XG5cbiAgICBzZXRGaXJzdEhpZ2h0TGlnaHRLZXlGb3JNZW51KCkge1xuICAgICAgICAvLyDorr7nva7pq5jkuq4gaXRlbSBrZXlcbiAgICAgICAgaWYgKHRoaXMuZGF0YVN0b3JlLmdldE1lbnVEUygpLmxlbmd0aCAmJiB0aGlzLmRhdGFTdG9yZS5nZXRFbmFibGVEUygpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0S2V5OiBgJHt0aGlzLmRhdGFTdG9yZS5nZXRFbmFibGVEUygpWzBdLnZhbHVlfWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlQ2hhbmdlKHZhbHVlLCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIOmdnuWPl+aOp+aooeW8j+a4heepuuWGhemDqOaVsOaNrlxuICAgICAgICBpZiAoISgndmFsdWUnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UodmFsdWUsIC4uLmFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBNZW51IGJvZHkgY2xpY2tcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIGNsaWNrIGV2ZW50XG4gICAgICovXG4gICAgaGFuZGxlTWVudUJvZHlDbGljayhlKSB7XG4gICAgICAgIHRoaXMuZm9jdXNJbnB1dChlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgaGlnaGxpZ2h0IE1lbnVJdGVtXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlyIC0xOiB1cCwgMTogZG93blxuICAgICAqL1xuICAgIHRvZ2dsZUhpZ2hsaWdodEl0ZW0oZGlyKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZpc2libGUodHJ1ZSwgJ2VudGVyJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYXhDb3VudCA9IHRoaXMuZGF0YVN0b3JlLmdldEVuYWJsZURTKCkubGVuZ3RoO1xuICAgICAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIGVuYWJsZWQgaXRlbVxuICAgICAgICBpZiAoIW1heENvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgeyBoaWdobGlnaHRLZXkgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGxldCBoaWdobGlnaHRJbmRleCA9IC0xO1xuXG4gICAgICAgIC8vIGZpbmQgcHJldmlvdXMgaGlnaGxpZ2h0IGluZGV4XG4gICAgICAgIGhpZ2hsaWdodEtleSAhPT0gbnVsbCAmJiB0aGlzLmRhdGFTdG9yZS5nZXRFbmFibGVEUygpLnNvbWUoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoYCR7aXRlbS52YWx1ZX1gID09PSBoaWdobGlnaHRLZXkpIHtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhpZ2hsaWdodEluZGV4ID4gLTE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRvZ2dsZSBoaWdobGlnaHQgaW5kZXhcbiAgICAgICAgaGlnaGxpZ2h0SW5kZXggKz0gZGlyO1xuICAgICAgICBpZiAoaGlnaGxpZ2h0SW5kZXggPCAwKSB7XG4gICAgICAgICAgICBoaWdobGlnaHRJbmRleCA9IG1heENvdW50IC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGlnaGxpZ2h0SW5kZXggPj0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgIGhpZ2hsaWdodEluZGV4ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBoaWdobGlnaHQga2V5XG4gICAgICAgIGNvbnN0IGhpZ2hsaWdodEl0ZW0gPSB0aGlzLmRhdGFTdG9yZS5nZXRFbmFibGVEUygpW2hpZ2hsaWdodEluZGV4XTtcbiAgICAgICAgaGlnaGxpZ2h0S2V5ID0gaGlnaGxpZ2h0SXRlbSA/IGAke2hpZ2hsaWdodEl0ZW0udmFsdWV9YCA6IG51bGw7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGhpZ2hsaWdodEtleSB9KTtcblxuICAgICAgICB0aGlzLnNjcm9sbE1lbnVJbnRvVmlldygpO1xuXG4gICAgICAgIHJldHVybiBoaWdobGlnaHRJdGVtO1xuICAgIH1cblxuICAgIC8vIHNjcm9sbCBpbnRvIGZvY3VzIGl0ZW1cbiAgICBzY3JvbGxNZW51SW50b1ZpZXcoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhpZ2hsaWdodFRpbWVyKTtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZW51Tm9kZSA9IGZpbmRET01Ob2RlKHRoaXMubWVudVJlZik7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbU5vZGUgPSBtZW51Tm9kZS5xdWVyeVNlbGVjdG9yKGAuJHtwcmVmaXh9c2VsZWN0LW1lbnUtaXRlbS4ke3ByZWZpeH1mb2N1c2VkYCk7XG4gICAgICAgICAgICAgICAgaXRlbU5vZGUgJiYgaXRlbU5vZGUuc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBJIGRvbid0IGNhcmUuLi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVuZGVyIHBvcHVwIG1lbnUgaGVhZGVyXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgcmVuZGVyTWVudUhlYWRlcigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaGFuZGxlU2VsZWN0KCkge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVuZGVyIHBvcHVwIGNoaWxkcmVuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgICAqL1xuICAgIHJlbmRlck1lbnUoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBtb2RlLCBhdXRvV2lkdGgsIGxvY2FsZSwgbm90Rm91bmRDb250ZW50LCB1c2VWaXJ0dWFsIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IGRhdGFTb3VyY2UsIGhpZ2hsaWdodEtleSB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgICBsZXQgc2VsZWN0ZWRLZXlzO1xuXG5cbiAgICAgICAgaWYgKGlzTnVsbCh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzZWxlY3RlZEtleXMgPSBbXTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1NpbmdsZShtb2RlKSkge1xuICAgICAgICAgICAgc2VsZWN0ZWRLZXlzID0gW3ZhbHVlVG9TZWxlY3RLZXkodmFsdWUpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGVkS2V5cyA9IFtdLmNvbmNhdCh2YWx1ZSkubWFwKG4gPT4gdmFsdWVUb1NlbGVjdEtleShuKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLnJlbmRlck1lbnVJdGVtKGRhdGFTb3VyY2UpO1xuXG5cbiAgICAgICAgY29uc3QgbWVudUNsYXNzTmFtZSA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1zZWxlY3QtbWVudWBdOiB0cnVlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1zZWxlY3QtbWVudS1lbXB0eWBdOiAhY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gPHNwYW4gY2xhc3NOYW1lPXtgJHtwcmVmaXh9c2VsZWN0LW1lbnUtZW1wdHktY29udGVudGB9Pntub3RGb3VuZENvbnRlbnQgfHwgbG9jYWxlLm5vdEZvdW5kQ29udGVudH08L3NwYW4+O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWVudVByb3BzID0ge1xuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBzdHlsZTogYXV0b1dpZHRoID8geyB3aWR0aDogdGhpcy53aWR0aCB9IDogeyBtaW5XaWR0aDogdGhpcy53aWR0aCB9LFxuICAgICAgICAgICAgc2VsZWN0ZWRLZXlzLFxuICAgICAgICAgICAgZm9jdXNlZEtleTogaGlnaGxpZ2h0S2V5LFxuICAgICAgICAgICAgZm9jdXNhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHNlbGVjdE1vZGU6IGlzU2luZ2xlKG1vZGUpID8gJ3NpbmdsZScgOiAnbXVsdGlwbGUnLFxuICAgICAgICAgICAgb25TZWxlY3Q6IHRoaXMuaGFuZGxlTWVudVNlbGVjdCxcbiAgICAgICAgICAgIG9uSXRlbUNsaWNrOiB0aGlzLmhhbmRsZUl0ZW1DbGljayxcbiAgICAgICAgICAgIGhlYWRlcjogdGhpcy5yZW5kZXJNZW51SGVhZGVyKCksXG4gICAgICAgICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZU1lbnVCb2R5Q2xpY2ssXG4gICAgICAgICAgICBvbk1vdXNlRG93bjogcHJldmVudERlZmF1bHQsXG4gICAgICAgICAgICBjbGFzc05hbWU6IG1lbnVDbGFzc05hbWVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdXNlVmlydHVhbCA/XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH1zZWxlY3QtbWVudS13cmFwcGVyYH0gc3R5bGU9e3twb3NpdGlvbjogJ3JlbGF0aXZlJ319PlxuICAgICAgICAgICAgICAgICAgICA8VmlydHVhbExpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zUmVuZGVyZXI9eyhpdGVtcywgcmVmKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICg8TWVudSByZWY9e2MgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYoYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVudVJlZiA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0gey4uLm1lbnVQcm9wc30+e2l0ZW1zfTwvTWVudT4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICAgICAgICAgIDwvVmlydHVhbExpc3Q+XG4gICAgICAgICAgICAgICAgPC9kaXY+IDpcbiAgICAgICAgICAgICAgICA8TWVudSB7Li4ubWVudVByb3BzfSAvPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbmRlciBtZW51IGl0ZW1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YVNvdXJjZVxuICAgICAqL1xuICAgIHJlbmRlck1lbnVJdGVtKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIGl0ZW1SZW5kZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIC8vIElmIGl0IGhhcy5cbiAgICAgICAgbGV0IHNlYXJjaEtleTtcbiAgICAgICAgaWYgKHRoaXMuaXNBdXRvQ29tcGxldGUpIHtcbiAgICAgICAgICAgIC8vIEluIEF1dG9Db21wbGV0ZSwgdmFsdWUgaXMgdGhlIHNlYXJjaEtleVxuICAgICAgICAgICAgc2VhcmNoS2V5ID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlYXJjaEtleSA9IHRoaXMuc3RhdGUuc2VhcmNoVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YVNvdXJjZS5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0uY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPE1lbnVHcm91cFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtpbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPXtpdGVtLmxhYmVsfT57dGhpcy5yZW5kZXJNZW51SXRlbShpdGVtLmNoaWxkcmVuKX1cbiAgICAgICAgICAgICAgICAgICAgPC9NZW51R3JvdXA+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbVByb3BzID0ge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGl0ZW0udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fXNlbGVjdC1tZW51LWl0ZW1gLFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogaXRlbS5kaXNhYmxlZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVByb3BzLnRpdGxlID0gaXRlbS50aXRsZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICA8TWVudUl0ZW0gey4uLml0ZW1Qcm9wc30+e2l0ZW1SZW5kZXIoaXRlbSwgc2VhcmNoS2V5KX1cbiAgICAgICAgICAgICAgICAgICAgPC9NZW51SXRlbT5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzYXZlU2VsZWN0UmVmID0gKHJlZikgPT4ge1xuICAgICAgICB0aGlzLnNlbGVjdERPTSA9IGZpbmRET01Ob2RlKHJlZik7XG4gICAgfTtcblxuICAgIHNhdmVJbnB1dFJlZiA9IChyZWYpID0+IHtcbiAgICAgICAgaWYgKHJlZiAmJiByZWYuZ2V0SW5zdGFuY2UoKSkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFJlZiA9IHJlZi5nZXRJbnN0YW5jZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOeCueWHuyBhcnJvdyDmiJYgbGFiZWwg55qE5pe25YCZ54Sm54K55YiH5YiwIGlucHV0IOS4rVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGZvY3VzSW5wdXQoKSB7XG4gICAgICAgIHRoaXMuaW5wdXRSZWYuZm9jdXMoKTtcbiAgICB9XG5cbiAgICBiZWZvcmVPcGVuKCkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBoaWdobGlnaHRLZXkgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm1vZGUgPT09ICdzaW5nbGUnICYmICF2YWx1ZSAmJiAhaGlnaGxpZ2h0S2V5KSB7XG4gICAgICAgICAgICB0aGlzLnNldEZpcnN0SGlnaHRMaWdodEtleUZvck1lbnUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN5bmNXaWR0aCgpO1xuICAgIH1cblxuICAgIGJlZm9yZUNsb3NlKCkge1xuXG4gICAgfVxuXG4gICAgYWZ0ZXJDbG9zZSgpIHtcblxuICAgIH1cblxuICAgIHNhdmVQb3B1cFJlZiA9IChyZWYpID0+IHtcbiAgICAgICAgdGhpcy5wb3B1cFJlZiA9IHJlZjtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMucG9wdXBQcm9wcyAmJiB0eXBlb2YgdGhpcy5wcm9wcy5wb3B1cFByb3BzLnJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5wb3B1cFByb3BzLnJlZihyZWYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBtb2RlLCBwb3B1cFByb3BzLCBwb3B1cENvbnRhaW5lciwgcG9wdXBDbGFzc05hbWUsIHBvcHVwU3R5bGUsIHBvcHVwQ29udGVudCwgYXV0b1dpZHRoLCBjYW5DbG9zZUJ5VHJpZ2dlciwgY2FjaGUgfSA9IHByb3BzO1xuXG4gICAgICAgIGNvbnN0IGNscyA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1zZWxlY3QtYXV0by1jb21wbGV0ZS1tZW51YF06ICFwb3B1cENvbnRlbnQgJiYgdGhpcy5pc0F1dG9Db21wbGV0ZSxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9c2VsZWN0LSR7bW9kZX0tbWVudWBdOiAhcG9wdXBDb250ZW50ICYmICEhbW9kZVxuICAgICAgICB9LCBwb3B1cENsYXNzTmFtZSB8fCBwb3B1cFByb3BzLmNsYXNzTmFtZSk7XG5cbiAgICAgICAgY29uc3QgX3Byb3BzID0ge1xuICAgICAgICAgICAgdHJpZ2dlclR5cGU6ICdjbGljaycsXG4gICAgICAgICAgICBhdXRvRm9jdXM6IGZhbHNlLFxuICAgICAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgLy8gUHV0IGBwb3B1cFByb3BzYCBpbnRvIGhlcmUgZm9yIGNvdmVyaW5nIGFib3ZlIHByb3BzLlxuICAgICAgICAgICAgLi4ucG9wdXBQcm9wcyxcbiAgICAgICAgICAgIC8vYmVmb3JlT3BlbiBub2RlIG5vdCBtb3VudCwgYWZ0ZXJPcGVuIHRvbyBzbG93LlxuICAgICAgICAgICAgLy8gZnJvbSBkaXNwbGF5Om5vbmUgdG8gYmxvY2ssIHdlIG1heSBuZWVkIHRvIHJlY29tcHV0ZSB3aWR0aFxuICAgICAgICAgICAgYmVmb3JlT3BlbjogbWFrZUNoYWluKHRoaXMuYmVmb3JlT3BlbiwgcG9wdXBQcm9wcy5iZWZvcmVPcGVuKSxcbiAgICAgICAgICAgIGJlZm9yZUNsb3NlOiBtYWtlQ2hhaW4odGhpcy5iZWZvcmVDbG9zZSwgcG9wdXBQcm9wcy5iZWZvcmVDbG9zZSksXG4gICAgICAgICAgICBhZnRlckNsb3NlOiBtYWtlQ2hhaW4odGhpcy5hZnRlckNsb3NlLCBwb3B1cFByb3BzLmFmdGVyQ2xvc2UpLFxuICAgICAgICAgICAgY2FuQ2xvc2VCeVRyaWdnZXI6IGNhbkNsb3NlQnlUcmlnZ2VyLFxuICAgICAgICAgICAgdmlzaWJsZTogdGhpcy5zdGF0ZS52aXNpYmxlLFxuICAgICAgICAgICAgb25WaXNpYmxlQ2hhbmdlOiB0aGlzLmhhbmRsZVZpc2libGVDaGFuZ2UsXG4gICAgICAgICAgICBzaG91bGRVcGRhdGVQb3NpdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcjogcG9wdXBDb250YWluZXIgfHwgcG9wdXBQcm9wcy5jb250YWluZXIsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNscyxcbiAgICAgICAgICAgIHN0eWxlOiBwb3B1cFN0eWxlIHx8IHBvcHVwUHJvcHMuc3R5bGVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gKDxQb3B1cCB7Li4uX3Byb3BzfSB0cmlnZ2VyPXt0aGlzLnJlbmRlclNlbGVjdCgpfSByZWY9e3RoaXMuc2F2ZVBvcHVwUmVmfT5cbiAgICAgICAgICAgIHtwb3B1cENvbnRlbnQgP1xuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9c2VsZWN0LXBvcHVwLXdyYXBgfSBzdHlsZT17YXV0b1dpZHRoID8geyB3aWR0aDogdGhpcy53aWR0aCB9IDoge319PlxuICAgICAgICAgICAgICAgICAgICB7cG9wdXBDb250ZW50fVxuICAgICAgICAgICAgICAgIDwvZGl2PiA6IHRoaXMucmVuZGVyTWVudSgpfVxuICAgICAgICA8L1BvcHVwPik7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NlbGVjdC9iYXNlLmpzeCIsImltcG9ydCAnLi4vaWNvbi9zdHlsZS5qcyc7XG5pbXBvcnQgJy4vbWFpbi5zY3NzJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbnB1dC9zdHlsZS5qcyIsInJlcXVpcmUoXCIhIXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyIS9Vc2Vycy96aGFvZ3VveWFuL2dpdGh1Yi9wdWIvc2NyaXB0cy9zZXJ2ZXIvbG9hZGVycy9kZW1vL3NlbGVjdG9yLmpzIS9Vc2Vycy96aGFvZ3VveWFuL2dpdGh1Yi9wdWIvZG9jcy90YWJsZS9kZW1vL3BhZ2luYXRpb24ubWRcIilcblxuXG5pbXBvcnQgVGFibGUgZnJvbSAnLi4vLi4vLi4vc3JjL3RhYmxlJztcbmltcG9ydCAnLi4vLi4vLi4vc3JjL3RhYmxlL3N0eWxlLmpzJztcblxuXG5pbXBvcnQgUGFnaW5hdGlvbiBmcm9tICcuLi8uLi8uLi9zcmMvcGFnaW5hdGlvbic7XG5pbXBvcnQgJy4uLy4uLy4uL3NyYy9wYWdpbmF0aW9uL3N0eWxlLmpzJztcblxuXG5jb25zdCBkYXRhU291cmNlID0gKGopID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgdGl0bGU6IHsgbmFtZTogYFF1b3RhdGlvbiBmb3IgMVBDUyBOYW5vICR7MyArIGl9LjAgY29udHJvbGxlciBjb21wYXRpYmxlYCB9LFxuICAgICAgICAgICAgICAgIGlkOiAxMDAzMDY2NjA5NDAgKyBpICsgaixcbiAgICAgICAgICAgICAgICB0aW1lOiAyMDAwICsgalxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIHJlbmRlciA9ICh2YWx1ZSwgaW5kZXgsIHJlY29yZCkgPT4ge1xuICAgICAgICByZXR1cm4gPGEgaHJlZj1cImphdmFzY3JpcHQ6O1wiPlJlbW92ZSh7cmVjb3JkLmlkfSk8L2E+O1xuICAgIH07XG5cbmNsYXNzIEFwcCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBkYXRhU291cmNlOiBkYXRhU291cmNlKDUpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgb25DaGFuZ2UgPSAoY3VycmVudFBhZ2UpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBsb2FkaW5nOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2U6IGRhdGFTb3VyY2UoY3VycmVudFBhZ2UgKiA1KSxcbiAgICAgICAgICAgICAgICBsb2FkaW5nOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIDIwMCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPFRhYmxlIGRhdGFTb3VyY2U9e3RoaXMuc3RhdGUuZGF0YVNvdXJjZX1cbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZz17dGhpcy5zdGF0ZS5sb2FkaW5nfT5cbiAgICAgICAgICAgICAgICAgICAgPFRhYmxlLkNvbHVtbiB0aXRsZT1cIklkMVwiIGRhdGFJbmRleD1cImlkXCIgd2lkdGg9ezE0MH0gLz5cbiAgICAgICAgICAgICAgICAgICAgPFRhYmxlLkNvbHVtbiB0aXRsZT1cIlRpbWVcIiBkYXRhSW5kZXg9XCJ0aW1lXCIgd2lkdGg9ezUwMH0gLz5cbiAgICAgICAgICAgICAgICAgICAgPFRhYmxlLkNvbHVtbiBjZWxsPXtyZW5kZXJ9IHdpZHRoPXsyMDB9IC8+XG4gICAgICAgICAgICAgICAgPC9UYWJsZT5cbiAgICAgICAgICAgICAgICA8UGFnaW5hdGlvbiBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZX0gY2xhc3NOYW1lPVwicGFnZS1kZW1vXCIgLz5cbiAgICAgICAgICAgIDwvZGl2Pik7XG4gICAgfVxufVxuUmVhY3RET00ucmVuZGVyKDxBcHAgLz4sIG1vdW50Tm9kZSk7XG5cblxuLy8gSE9UIFJFTE9BRCBDT0RFXG5jb25zdCBjb21wb25lbnREZXNjID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NvbXBvbmVudC1kZXNjJyk7XG5jb21wb25lbnREZXNjLmlubmVySFRNTCA9IGDkuI7liIbpobXnu5PlkIhgO1xuY29uc3QgY29tcG9uZW50Qm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjb21wb25lbnQtYm9keScpO1xuY29tcG9uZW50Qm9keS5pbm5lckhUTUwgPSBgPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLWpzeFwiPjxkaXYgY2xhc3M9XCJobGpzXCI+PHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj5pbXBvcnQ8L3NwYW4+IHsgVGFibGUsIFBhZ2luYXRpb24gfSA8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPmZyb208L3NwYW4+IDxzcGFuIGNsYXNzPVwiaGxqcy1zdHJpbmdcIj4nQGFsaWZkL25leHQnPC9zcGFuPjtcblxuPHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj5jb25zdDwvc3Bhbj4gZGF0YVNvdXJjZSA9IDxzcGFuIGNsYXNzPVwiaGxqcy1mdW5jdGlvblwiPig8c3BhbiBjbGFzcz1cImhsanMtcGFyYW1zXCI+ajwvc3Bhbj4pID0mZ3Q7PC9zcGFuPiB7XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaGxqcy1rZXl3b3JkXCI+Y29uc3Q8L3NwYW4+IHJlc3VsdCA9IFtdO1xuICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPmZvcjwvc3Bhbj4gKDxzcGFuIGNsYXNzPVwiaGxqcy1rZXl3b3JkXCI+bGV0PC9zcGFuPiBpID0gPHNwYW4gY2xhc3M9XCJobGpzLW51bWJlclwiPjA8L3NwYW4+OyBpICZsdDsgPHNwYW4gY2xhc3M9XCJobGpzLW51bWJlclwiPjU8L3NwYW4+OyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMtYXR0clwiPnRpdGxlPC9zcGFuPjogeyA8c3BhbiBjbGFzcz1cImhsanMtYXR0clwiPm5hbWU8L3NwYW4+OiA8c3BhbiBjbGFzcz1cImhsanMtc3RyaW5nXCI+e2JhY2txdW90ZX1RdW90YXRpb24gZm9yIDFQQ1MgTmFubyA8c3BhbiBjbGFzcz1cImhsanMtc3Vic3RcIj57ZG9sbGFyfXs8c3BhbiBjbGFzcz1cImhsanMtbnVtYmVyXCI+Mzwvc3Bhbj4gKyBpfTwvc3Bhbj4uMCBjb250cm9sbGVyIGNvbXBhdGlibGV7YmFja3F1b3RlfTwvc3Bhbj4gfSxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMtYXR0clwiPmlkPC9zcGFuPjogPHNwYW4gY2xhc3M9XCJobGpzLW51bWJlclwiPjEwMDMwNjY2MDk0MDwvc3Bhbj4gKyBpICsgaixcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMtYXR0clwiPnRpbWU8L3NwYW4+OiA8c3BhbiBjbGFzcz1cImhsanMtbnVtYmVyXCI+MjAwMDwvc3Bhbj4gKyBqXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPnJldHVybjwvc3Bhbj4gcmVzdWx0O1xuICAgIH0sXG4gICAgcmVuZGVyID0gPHNwYW4gY2xhc3M9XCJobGpzLWZ1bmN0aW9uXCI+KDxzcGFuIGNsYXNzPVwiaGxqcy1wYXJhbXNcIj52YWx1ZSwgaW5kZXgsIHJlY29yZDwvc3Bhbj4pID0mZ3Q7PC9zcGFuPiB7XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaGxqcy1rZXl3b3JkXCI+cmV0dXJuPC9zcGFuPiA8c3BhbiBjbGFzcz1cInhtbFwiPjxzcGFuIGNsYXNzPVwiaGxqcy10YWdcIj4mbHQ7PHNwYW4gY2xhc3M9XCJobGpzLW5hbWVcIj5hPC9zcGFuPiA8c3BhbiBjbGFzcz1cImhsanMtYXR0clwiPmhyZWY8L3NwYW4+PTxzcGFuIGNsYXNzPVwiaGxqcy1zdHJpbmdcIj5cImphdmFzY3JpcHQ6O1wiPC9zcGFuPiZndDs8L3NwYW4+UmVtb3ZlKHtyZWNvcmQuaWR9KTxzcGFuIGNsYXNzPVwiaGxqcy10YWdcIj4mbHQ7LzxzcGFuIGNsYXNzPVwiaGxqcy1uYW1lXCI+YTwvc3Bhbj4mZ3Q7PC9zcGFuPjwvc3Bhbj47XG4gICAgfTtcblxuPHNwYW4gY2xhc3M9XCJobGpzLWNsYXNzXCI+PHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj5jbGFzczwvc3Bhbj4gPHNwYW4gY2xhc3M9XCJobGpzLXRpdGxlXCI+QXBwPC9zcGFuPiA8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPmV4dGVuZHM8L3NwYW4+IDxzcGFuIGNsYXNzPVwiaGxqcy10aXRsZVwiPlJlYWN0PC9zcGFuPi48c3BhbiBjbGFzcz1cImhsanMtdGl0bGVcIj5Db21wb25lbnQ8L3NwYW4+IDwvc3Bhbj57XG5cbiAgICA8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPmNvbnN0cnVjdG9yPC9zcGFuPihwcm9wcykge1xuICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPnN1cGVyPC9zcGFuPihwcm9wcyk7XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaGxqcy1rZXl3b3JkXCI+dGhpczwvc3Bhbj4uc3RhdGUgPSB7XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMtYXR0clwiPmRhdGFTb3VyY2U8L3NwYW4+OiBkYXRhU291cmNlKDxzcGFuIGNsYXNzPVwiaGxqcy1udW1iZXJcIj41PC9zcGFuPilcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBvbkNoYW5nZSA9IDxzcGFuIGNsYXNzPVwiaGxqcy1mdW5jdGlvblwiPig8c3BhbiBjbGFzcz1cImhsanMtcGFyYW1zXCI+Y3VycmVudFBhZ2U8L3NwYW4+KSA9Jmd0Ozwvc3Bhbj4ge1xuICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPnRoaXM8L3NwYW4+LnNldFN0YXRlKHtcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaGxqcy1hdHRyXCI+bG9hZGluZzwvc3Bhbj46IDxzcGFuIGNsYXNzPVwiaGxqcy1saXRlcmFsXCI+dHJ1ZTwvc3Bhbj5cbiAgICAgICAgfSk7XG4gICAgICAgIHNldFRpbWVvdXQoPHNwYW4gY2xhc3M9XCJobGpzLWZ1bmN0aW9uXCI+PHNwYW4gY2xhc3M9XCJobGpzLXBhcmFtc1wiPigpPC9zcGFuPiA9Jmd0Ozwvc3Bhbj4ge1xuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj50aGlzPC9zcGFuPi5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJobGpzLWF0dHJcIj5kYXRhU291cmNlPC9zcGFuPjogZGF0YVNvdXJjZShjdXJyZW50UGFnZSAqIDxzcGFuIGNsYXNzPVwiaGxqcy1udW1iZXJcIj41PC9zcGFuPiksXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJobGpzLWF0dHJcIj5sb2FkaW5nPC9zcGFuPjogPHNwYW4gY2xhc3M9XCJobGpzLWxpdGVyYWxcIj5mYWxzZTwvc3Bhbj5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCA8c3BhbiBjbGFzcz1cImhsanMtbnVtYmVyXCI+MjAwPC9zcGFuPik7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj5yZXR1cm48L3NwYW4+IChcbiAgICAgICAgICAgICZsdDtkaXYmZ3Q7XG4gICAgICAgICAgICAgICAgJmx0O1RhYmxlIGRhdGFTb3VyY2U9e3RoaXMuc3RhdGUuZGF0YVNvdXJjZX1cbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZz17dGhpcy5zdGF0ZS5sb2FkaW5nfSZndDtcbiAgICAgICAgICAgICAgICAgICAgJmx0O1RhYmxlLkNvbHVtbiB0aXRsZT1cIklkMVwiIGRhdGFJbmRleD1cImlkXCIgd2lkdGg9ezE0MH0gLyZndDtcbiAgICAgICAgICAgICAgICAgICAgJmx0O1RhYmxlLkNvbHVtbiB0aXRsZT1cIlRpbWVcIiBkYXRhSW5kZXg9XCJ0aW1lXCIgd2lkdGg9ezUwMH0gLyZndDtcbiAgICAgICAgICAgICAgICAgICAgJmx0O1RhYmxlLkNvbHVtbiBjZWxsPXtyZW5kZXJ9IHdpZHRoPXsyMDB9IC8mZ3Q7XG4gICAgICAgICAgICAgICAgJmx0Oy9UYWJsZSZndDtcbiAgICAgICAgICAgICAgICAmbHQ7UGFnaW5hdGlvbiBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZX0gY2xhc3NOYW1lPVwicGFnZS1kZW1vXCIgLyZndDtcbiAgICAgICAgICAgICZsdDsvZGl2Jmd0Oyk7XG4gICAgfVxufVxuUmVhY3RET00ucmVuZGVyKCZsdDtBcHAgLyZndDssIG1vdW50Tm9kZSk7XG48L2Rpdj48L2NvZGU+PC9wcmU+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtY3NzXCI+PGRpdiBjbGFzcz1cImhsanNcIj48c3BhbiBjbGFzcz1cImhsanMtc2VsZWN0b3ItY2xhc3NcIj4ucGFnZS1kZW1vPC9zcGFuPiB7XG4gICAgPHNwYW4gY2xhc3M9XCJobGpzLWF0dHJpYnV0ZVwiPm1hcmdpbi10b3A8L3NwYW4+OjxzcGFuIGNsYXNzPVwiaGxqcy1udW1iZXJcIj4xMHB4PC9zcGFuPjtcbn1cbjwvZGl2PjwvY29kZT48L3ByZT5cbmAucmVwbGFjZSgve2JhY2txdW90ZX0vZywgJ2AnKS5yZXBsYWNlKC97ZG9sbGFyfS9nLCAnJCcpO1xuXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpO1xuXG4gIGNvbnN0IHJlbG9hZGluZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNuZXh0LWRlbW8tcmVsb2FkaW5nJyk7XG5cbiAgaWYgKCF3aW5kb3cuaGFzQWRkU3RhdHVzSGFuZGxlcikge1xuICAgIG1vZHVsZS5ob3QuYWRkU3RhdHVzSGFuZGxlcihzdGF0dXMgPT4ge1xuICAgICAgd2luZG93Lmhhc0FkZFN0YXR1c0hhbmRsZXIgPSB0cnVlO1xuICAgICAgaWYgKHN0YXR1cyA9PT0gJ2NoZWNrJykge1xuICAgICAgICByZWxvYWRpbmcuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gJ2lkbGUnKSB7XG4gICAgICAgIHJlbG9hZGluZy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZG9jcy90YWJsZS9kZW1vL3BhZ2luYXRpb24ubWQiLCJpbXBvcnQgUGFnaW5hdGlvbiBmcm9tICcuL3BhZ2luYXRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCBQYWdpbmF0aW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BhZ2luYXRpb24vaW5kZXguanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgQ29uZmlnUHJvdmlkZXIgZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCBJY29uIGZyb20gJy4uL2ljb24nO1xuaW1wb3J0IEJ1dHRvbiBmcm9tICcuLi9idXR0b24nO1xuaW1wb3J0IElucHV0IGZyb20gJy4uL2lucHV0JztcbmltcG9ydCBTZWxlY3QgZnJvbSAnLi4vc2VsZWN0JztcbmltcG9ydCB7IEtFWUNPREUgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCB6aENOIGZyb20gJy4uL2xvY2FsZS96aC1jbi5qcyc7XG5cbmNvbnN0IHsgT3B0aW9uIH0gPSBTZWxlY3Q7XG5jb25zdCBub29wID0gKCkgPT4ge307XG5cbi8qKlxuICogUGFnaW5hdGlvblxuICovXG5jbGFzcyBQYWdpbmF0aW9uIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHB1cmU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBydGw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnlm73pmYXljJbmlofmoYjlr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIGxvY2FsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIhumhtee7hOS7tuexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnbm9ybWFsJywgJ3NpbXBsZScsICdtaW5pJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5YmN6L+b5ZCO6YCA5oyJ6ZKu5qC35byPXG4gICAgICAgICAqL1xuICAgICAgICBzaGFwZTogUHJvcFR5cGVzLm9uZU9mKFsnbm9ybWFsJywgJ2Fycm93LW9ubHknLCAnYXJyb3ctcHJldi1vbmx5JywgJ25vLWJvcmRlciddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIhumhtee7hOS7tuWkp+Wwj1xuICAgICAgICAgKi9cbiAgICAgICAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsnc21hbGwnLCAnbWVkaXVtJywgJ2xhcmdlJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog77yI5Y+X5o6n77yJ5b2T5YmN6aG156CBXG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICog77yI6Z2e5Y+X5o6n77yJ5Yid5aeL6aG156CBXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0Q3VycmVudDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmhteeggeWPkeeUn+aUueWPmOaXtueahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY3VycmVudCDmlLnlj5jlkI7nmoTpobXnoIHmlbBcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGUg54K55Ye75LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmgLvorrDlvZXmlbBcbiAgICAgICAgICovXG4gICAgICAgIHRvdGFsOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICog5oC75pWw55qE5riy5p+T5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbCDmgLvmlbBcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gcmFuZ2Ug5b2T5YmN5pWw5o2u5Zyo5oC75pWw5Lit55qE5Yy66Ze0XG4gICAgICAgICAqL1xuICAgICAgICB0b3RhbFJlbmRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpobXnoIHmmL7npLrnmoTmlbDph4/vvIzmm7TlpJrnmoTkvb/nlKguLi7ku6Pmm79cbiAgICAgICAgICovXG4gICAgICAgIHBhZ2VTaG93Q291bnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuIDpobXkuK3nmoTorrDlvZXmlbBcbiAgICAgICAgICovXG4gICAgICAgIHBhZ2VTaXplOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICog5q+P6aG15pi+56S66YCJ5oup5Zmo57G75Z6LXG4gICAgICAgICAqL1xuICAgICAgICBwYWdlU2l6ZVNlbGVjdG9yOiBQcm9wVHlwZXMub25lT2YoW2ZhbHNlLCAnZmlsdGVyJywgJ2Ryb3Bkb3duJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5q+P6aG15pi+56S66YCJ5oup5Zmo5Y+v6YCJ5YC8XG4gICAgICAgICAqL1xuICAgICAgICBwYWdlU2l6ZUxpc3Q6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgICAgICAgICAgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlciksXG4gICAgICAgICAgICBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgICAgICAgICAgIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBQcm9wVHlwZXMubnVtYmVyXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnpobXnoIHmuLLmn5Plh73mlbDvvIzlh73mlbDkvZznlKjkuo7pobXnoIFidXR0b27ku6Xlj4rlvZPliY3pobUv5oC76aG15pWw55qE5pWw5a2X5riy5p+TXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCDliIbpobXnmoTpobXnoIHvvIzku44x5byA5aeLXG4gICAgICAgICAqIEByZXR1cm4ge1JlYWN0Tm9kZX0g6L+U5Zue5riy5p+T57uT5p6cXG4gICAgICAgICovXG4gICAgICAgIHBhZ2VOdW1iZXJSZW5kZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5q+P6aG15pi+56S66YCJ5oup5Zmo5Zyo57uE5Lu25Lit55qE5L2N572uXG4gICAgICAgICAqL1xuICAgICAgICBwYWdlU2l6ZVBvc2l0aW9uOiBQcm9wVHlwZXMub25lT2YoWydzdGFydCcsICdlbmQnXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlrZjlnKjmr4/pobXmmL7npLrpgInmi6nlmajml7bmmK/lkKbkvb/nlKjmta7liqjluIPlsYBcbiAgICAgICAgICovXG4gICAgICAgIHVzZUZsb2F0TGF5b3V0OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOavj+mhteaYvuekuuiusOW9leaVsOmHj+aUueWPmOaXtueahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcGFnZVNpemUg5pS55Y+Y5ZCO55qE5q+P6aG15pi+56S66K6w5b2V5pWwXG4gICAgICAgICAqL1xuICAgICAgICBvblBhZ2VTaXplQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW9k+WIhumhteaVsOS4ujHml7bvvIzmmK/lkKbpmpDol4/liIbpobXlmahcbiAgICAgICAgICovXG4gICAgICAgIGhpZGVPbmx5T25lUGFnZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0eXBlIOiuvue9ruS4uiBub3JtYWwg5pe277yM5Zyo6aG156CB5pWw6LaF6L+HNemhteWQju+8jOS8muaYvuekuui3s+i9rOi+k+WFpeahhuS4juaMiemSru+8jOW9k+iuvue9riBzaG93SnVtcCDkuLogZmFsc2Ug5pe277yM5LiN5YaN5pi+56S66K+l6Lez6L2s5Yy65Z+fXG4gICAgICAgICAqL1xuICAgICAgICBzaG93SnVtcDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7pobXnoIHmjInpkq7nmoTot7Povazpk77mjqXvvIzlroPnmoTlgLzkuLrkuIDkuKrljIXlkKsge3BhZ2V9IOeahOaooeeJiOWtl+espuS4su+8jOWmgu+8mmh0dHA6Ly94eHguY29tL3twYWdlfVxuICAgICAgICAgKi9cbiAgICAgICAgbGluazogUHJvcFR5cGVzLnN0cmluZ1xuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBwcmVmaXg6ICduZXh0LScsXG4gICAgICAgIHB1cmU6IGZhbHNlLFxuICAgICAgICBydGw6IGZhbHNlLFxuICAgICAgICBsb2NhbGU6IHpoQ04uUGFnaW5hdGlvbixcbiAgICAgICAgdHlwZTogJ25vcm1hbCcsXG4gICAgICAgIHNoYXBlOiAnbm9ybWFsJyxcbiAgICAgICAgc2l6ZTogJ21lZGl1bScsXG4gICAgICAgIGRlZmF1bHRDdXJyZW50OiAxLFxuICAgICAgICBvbkNoYW5nZTogbm9vcCxcbiAgICAgICAgcGFnZVNpemU6IDEwLFxuICAgICAgICBwYWdlU2l6ZVNlbGVjdG9yOiBmYWxzZSxcbiAgICAgICAgcGFnZVNpemVMaXN0OiBbNSwgMTAsIDIwXSxcbiAgICAgICAgcGFnZVNpemVQb3NpdGlvbjogJ3N0YXJ0JyxcbiAgICAgICAgb25QYWdlU2l6ZUNoYW5nZTogbm9vcCxcbiAgICAgICAgdXNlRmxvYXRMYXlvdXQ6IGZhbHNlLFxuICAgICAgICB0b3RhbDogMTAwLFxuICAgICAgICBwYWdlU2hvd0NvdW50OiA1LFxuICAgICAgICBoaWRlT25seU9uZVBhZ2U6IGZhbHNlLFxuICAgICAgICBzaG93SnVtcDogdHJ1ZSxcbiAgICAgICAgcGFnZU51bWJlclJlbmRlcjogaW5kZXggPT4gaW5kZXhcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQsIGRlZmF1bHRDdXJyZW50LCB0b3RhbCwgcGFnZVNpemUgfSA9IHByb3BzO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgY3VycmVudDogdGhpcy5jb3JyZWN0Q3VycmVudChjdXJyZW50IHx8IGRlZmF1bHRDdXJyZW50LCB0b3RhbCwgcGFnZVNpemUpLFxuICAgICAgICAgICAgY3VycmVudFBhZ2VTaXplOiBwYWdlU2l6ZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uSnVtcCA9IHRoaXMub25KdW1wLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50LCB0b3RhbCwgcGFnZVNpemUgfSA9IG5leHRQcm9wcztcblxuICAgICAgICBjb25zdCBzdCA9IHt9O1xuICAgICAgICBjb25zdCBuZXdDdXJyZW50ID0gdGhpcy5jb3JyZWN0Q3VycmVudChjdXJyZW50IHx8IHRoaXMuc3RhdGUuY3VycmVudCwgdG90YWwsIHBhZ2VTaXplKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuY3VycmVudCAhPT0gbmV3Q3VycmVudCkge1xuICAgICAgICAgICAgc3QuY3VycmVudCA9IG5ld0N1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuY3VycmVudFBhZ2VTaXplICE9PSBwYWdlU2l6ZSkge1xuICAgICAgICAgICAgc3QuY3VycmVudFBhZ2VTaXplID0gcGFnZVNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoc3QpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShzdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb3JyZWN0Q3VycmVudChjdXJyZW50UGFnZSwgdG90YWwsIGN1cnJlbnRQYWdlU2l6ZSkge1xuICAgICAgICBjb25zdCB0b3RhbFBhZ2UgPSB0aGlzLmdldFRvdGFsUGFnZSh0b3RhbCwgY3VycmVudFBhZ2VTaXplKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYWdlID4gdG90YWxQYWdlID8gdG90YWxQYWdlIDogY3VycmVudFBhZ2U7XG4gICAgfVxuXG4gICAgZ2V0VG90YWxQYWdlICh0b3RhbCwgY3VycmVudFBhZ2VTaXplKSB7XG4gICAgICAgIGNvbnN0IHRvdGFsUGFnZSA9IE1hdGguY2VpbCh0b3RhbCAvIGN1cnJlbnRQYWdlU2l6ZSk7XG4gICAgICAgIHJldHVybiB0b3RhbFBhZ2UgPD0gMCA/IDEgOiB0b3RhbFBhZ2U7XG4gICAgfVxuXG4gICAgb25KdW1wKGUpIHtcbiAgICAgICAgY29uc3QgeyB0b3RhbCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBjdXJyZW50LCBjdXJyZW50UGFnZVNpemUgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHRvdGFsUGFnZSA9IHRoaXMuZ2V0VG90YWxQYWdlKHRvdGFsLCBjdXJyZW50UGFnZVNpemUpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlSW50KHRoaXMuaW5wdXRWYWx1ZSwgMTApO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IHRvdGFsUGFnZSAmJiB2YWx1ZSAhPT0gY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5vblBhZ2VJdGVtQ2xpY2sodmFsdWUsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uUGFnZUl0ZW1DbGljayhwYWdlLCBlKSB7XG4gICAgICAgIGlmICghKCdjdXJyZW50JyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgY3VycmVudDogcGFnZVxuICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UocGFnZSwgZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UocGFnZSwgZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbklucHV0Q2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW5wdXRWYWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIG9uU2VsZWN0U2l6ZShwYWdlU2l6ZSkge1xuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlU2l6ZTogcGFnZVNpemVcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCB0b3RhbFBhZ2UgPSB0aGlzLmdldFRvdGFsUGFnZSh0aGlzLnByb3BzLnRvdGFsLCBwYWdlU2l6ZSk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmN1cnJlbnQgPiB0b3RhbFBhZ2UpIHtcbiAgICAgICAgICAgIG5ld1N0YXRlLmN1cnJlbnQgPSB0b3RhbFBhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vblBhZ2VTaXplQ2hhbmdlKHBhZ2VTaXplKTtcbiAgICB9XG5cbiAgICByZW5kZXJQYWdlVG90YWwoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB0b3RhbCwgdG90YWxSZW5kZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudFBhZ2VTaXplLCBjdXJyZW50IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCByYW5nZSA9IFsoY3VycmVudCAtIDEpICogY3VycmVudFBhZ2VTaXplICsgMSwgY3VycmVudCAqIGN1cnJlbnRQYWdlU2l6ZV07XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9cGFnaW5hdGlvbi10b3RhbGB9PlxuICAgICAgICAgICAgICAgIHt0b3RhbFJlbmRlcih0b3RhbCwgcmFuZ2UpfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyUGFnZUl0ZW0oaW5kZXgpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHNpemUsIGxpbmssIHBhZ2VOdW1iZXJSZW5kZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBjb25zdCBpc0N1cnJlbnQgPSBwYXJzZUludChpbmRleCwgMTApID09PSBjdXJyZW50O1xuICAgICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGN4KHtcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4fXBhZ2luYXRpb24taXRlbWBdOiB0cnVlLFxuICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9Y3VycmVudGBdOiBpc0N1cnJlbnRcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb25DbGljazogaXNDdXJyZW50ID8gbm9vcCA6IHRoaXMub25QYWdlSXRlbUNsaWNrLmJpbmQodGhpcywgaW5kZXgpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICBwcm9wcy5jb21wb25lbnQgPSAnYSc7XG4gICAgICAgICAgICBwcm9wcy5ocmVmID0gbGluay5yZXBsYWNlKCd7cGFnZX0nLCBpbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gPEJ1dHRvbiB7Li4ucHJvcHN9IGtleT17aW5kZXh9PntwYWdlTnVtYmVyUmVuZGVyKGluZGV4KX08L0J1dHRvbj47XG4gICAgfVxuXG4gICAgcmVuZGVyUGFnZUZpcnN0KGN1cnJlbnQpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHNpemUsIHNoYXBlLCBsb2NhbGUgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgY29uc3QgaXNGaXJzdCA9IGN1cnJlbnQgPD0gMTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgICAgICBkaXNhYmxlZDogaXNGaXJzdCxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGN4KHtcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4fXBhZ2luYXRpb24taXRlbWBdOiB0cnVlLFxuICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9cHJldmBdOiB0cnVlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMub25QYWdlSXRlbUNsaWNrLmJpbmQodGhpcywgY3VycmVudCAtIDEpXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaWNvbiA9IDxJY29uIHR5cGU9XCJhcnJvdy1sZWZ0XCIgLz47XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxCdXR0b24gey4uLnByb3BzfT5cbiAgICAgICAgICAgICAgICB7aWNvbn1cbiAgICAgICAgICAgICAgICB7c2hhcGUgPT09ICdhcnJvdy1vbmx5JyB8fFxuICAgICAgICAgICAgICAgICBzaGFwZSA9PT0gJ2Fycm93LXByZXYtb25seScgfHxcbiAgICAgICAgICAgICAgICAgc2hhcGUgPT09ICduby1ib3JkZXInID8gJycgOiBsb2NhbGUucHJldn1cbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJlbmRlclBhZ2VMYXN0KGN1cnJlbnQsIHRvdGFsUGFnZSkge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgc2l6ZSwgc2hhcGUsIGxvY2FsZSB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBjb25zdCBpc0xhc3QgPSBjdXJyZW50ID49IHRvdGFsUGFnZTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgICAgICBkaXNhYmxlZDogaXNMYXN0LFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY3goe1xuICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9cGFnaW5hdGlvbi1pdGVtYF06IHRydWUsXG4gICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1uZXh0YF06IHRydWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb25DbGljazogdGhpcy5vblBhZ2VJdGVtQ2xpY2suYmluZCh0aGlzLCBjdXJyZW50ICsgMSlcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBpY29uID0gPEljb24gdHlwZT1cImFycm93LXJpZ2h0XCIgLz47XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxCdXR0b24gey4uLnByb3BzfT5cbiAgICAgICAgICAgICAgICB7c2hhcGUgPT09ICdhcnJvdy1vbmx5JyB8fFxuICAgICAgICAgICAgICAgICBzaGFwZSA9PT0gJ25vLWJvcmRlcicgPyAnJyA6IGxvY2FsZS5uZXh0fVxuICAgICAgICAgICAgICAgIHtpY29ufVxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyUGFnZUVsbGlwc2lzKGlkeCkge1xuICAgICAgICBjb25zdCB7IHByZWZpeCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICByZXR1cm4gPEljb24gY2xhc3NOYW1lPXtgJHtwcmVmaXh9cGFnaW5hdGlvbi1lbGxpcHNpc2B9IHR5cGU9XCJlbGxpcHNpc1wiIGtleT17YGVsbGlwc2lzLSR7aWR4fWB9IC8+O1xuICAgIH1cblxuICAgIHJlbmRlclBhZ2VKdW1wKCkge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgc2l6ZSwgbG9jYWxlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0L2pzeC1rZXkgKi9cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YCR7cHJlZml4fXBhZ2luYXRpb24tanVtcC10ZXh0YH0+e2xvY2FsZS5nb1RvfTwvc3Bhbj4sXG4gICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake3ByZWZpeH1wYWdpbmF0aW9uLWp1bXAtaW5wdXRgfVxuICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICBzaXplPXtzaXplfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uSW5wdXRDaGFuZ2UuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICBvbktleURvd249eyhlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IEtFWUNPREUuRU5URVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25KdW1wKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfX0gLz4sXG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Ake3ByZWZpeH1wYWdpbmF0aW9uLWp1bXAtdGV4dGB9Pntsb2NhbGUucGFnZX08L3NwYW4+LFxuICAgICAgICAgICAgPEJ1dHRvbiBjbGFzc05hbWU9e2Ake3ByZWZpeH1wYWdpbmF0aW9uLWp1bXAtZ29gfSBzaXplPXtzaXplfSBvbkNsaWNrPXt0aGlzLm9uSnVtcH0+e2xvY2FsZS5nb308L0J1dHRvbj5cbiAgICAgICAgXTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC9qc3gta2V5ICovXG4gICAgfVxuXG4gICAgcmVuZGVyUGFnZURpc3BsYXkoY3VycmVudCwgdG90YWxQYWdlKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBwYWdlTnVtYmVyUmVuZGVyIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Ake3ByZWZpeH1wYWdpbmF0aW9uLWRpc3BsYXlgfT5cbiAgICAgICAgICAgICAgICA8ZW0+e3BhZ2VOdW1iZXJSZW5kZXIoY3VycmVudCl9PC9lbT4ve3BhZ2VOdW1iZXJSZW5kZXIodG90YWxQYWdlKX1cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXJQYWdlTGlzdChjdXJyZW50LCB0b3RhbFBhZ2UpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHBhZ2VTaG93Q291bnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHBhZ2VzID0gW107XG5cbiAgICAgICAgaWYgKHRvdGFsUGFnZSA8PSBwYWdlU2hvd0NvdW50KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0b3RhbFBhZ2U7IGkrKykge1xuICAgICAgICAgICAgICAgIHBhZ2VzLnB1c2godGhpcy5yZW5kZXJQYWdlSXRlbShpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyDpmaTljrvnrKzkuIDpobXvvIzmnIDlkI7kuIDpobXku6Xlj4rlvZPliY3pobXvvIzliankuIvnmoTpobXmlbBcbiAgICAgICAgICAgIGNvbnN0IG90aGVyc0NvdW50ID0gcGFnZVNob3dDb3VudCAtIDM7XG4gICAgICAgICAgICBjb25zdCBoYWxmQ291bnQgPSBwYXJzZUludChvdGhlcnNDb3VudCAvIDIsIDEwKTtcbiAgICAgICAgICAgIGxldCBzdGFydCwgZW5kO1xuXG4gICAgICAgICAgICBwYWdlcy5wdXNoKHRoaXMucmVuZGVyUGFnZUl0ZW0oMSkpO1xuXG4gICAgICAgICAgICBzdGFydCA9IGN1cnJlbnQgLSBoYWxmQ291bnQ7XG4gICAgICAgICAgICBlbmQgPSBjdXJyZW50ICsgaGFsZkNvdW50O1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDw9IDEpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IDI7XG4gICAgICAgICAgICAgICAgZW5kID0gc3RhcnQgKyBvdGhlcnNDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydCA+IDIpIHtcbiAgICAgICAgICAgICAgICBwYWdlcy5wdXNoKHRoaXMucmVuZGVyUGFnZUVsbGlwc2lzKDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPj0gdG90YWxQYWdlIC0gMSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IHRvdGFsUGFnZSAtIDE7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0b3RhbFBhZ2UgLSAxIC0gb3RoZXJzQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gc3RhcnQ7IGogPD0gZW5kOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwYWdlcy5wdXNoKHRoaXMucmVuZGVyUGFnZUl0ZW0oaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCA8IHRvdGFsUGFnZSAtIDEpIHtcbiAgICAgICAgICAgICAgICBwYWdlcy5wdXNoKHRoaXMucmVuZGVyUGFnZUVsbGlwc2lzKDIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFnZXMucHVzaCh0aGlzLnJlbmRlclBhZ2VJdGVtKHRvdGFsUGFnZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9cGFnaW5hdGlvbi1saXN0YH0+e3BhZ2VzfTwvZGl2PjtcbiAgICB9XG5cbiAgICByZW5kZXJQYWdlU2l6ZVNlbGVjdG9yKCkge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgcGFnZVNpemVTZWxlY3RvciwgbG9jYWxlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBwYWdlU2l6ZVNwYW4gPSA8c3BhbiBjbGFzc05hbWU9e2Ake3ByZWZpeH1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3ItdGl0bGVgfT57bG9jYWxlLnBhZ2VTaXplfTwvc3Bhbj47XG5cbiAgICAgICAgc3dpdGNoIChwYWdlU2l6ZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICBjYXNlICdmaWx0ZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9cGFnaW5hdGlvbi1zaXplLXNlbGVjdG9yYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICB7cGFnZVNpemVTcGFufVxuICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMucmVuZGVyUGFnZVNpemVGaWx0ZXIoKX1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgJ2Ryb3Bkb3duJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fXBhZ2luYXRpb24tc2l6ZS1zZWxlY3RvcmB9PlxuICAgICAgICAgICAgICAgICAgICAgICAge3BhZ2VTaXplU3Bhbn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnJlbmRlclBhZ2VTaXplRHJvcGRvd24oKX1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXJQYWdlU2l6ZUZpbHRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHNpemUsIHBhZ2VTaXplTGlzdCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBjdXJyZW50UGFnZVNpemUgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9cGFnaW5hdGlvbi1zaXplLXNlbGVjdG9yLWZpbHRlcmB9PlxuICAgICAgICAgICAgICAgIHtwYWdlU2l6ZUxpc3QubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYWdlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHtsYWJlbDogJycsIHZhbHVlOiA1fVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBpdGVtLmxhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVNpemUgPSBpdGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IHBhZ2VTaXplID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gY3goe1xuICAgICAgICAgICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3ItYnRuYF06IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4fWN1cnJlbnRgXTogcGFnZVNpemUgPT09IGN1cnJlbnRQYWdlU2l6ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBrZXk9e2luZGV4fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplPXtzaXplfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtwYWdlU2l6ZSAhPT0gY3VycmVudFBhZ2VTaXplID8gdGhpcy5vblNlbGVjdFNpemUuYmluZCh0aGlzLCBwYWdlU2l6ZSkgOiBudWxsfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bGFiZWx9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJlbmRlclBhZ2VTaXplRHJvcGRvd24oKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBzaXplLCBwYWdlU2l6ZUxpc3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudFBhZ2VTaXplIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8U2VsZWN0IGNsYXNzTmFtZT17YCR7cHJlZml4fXBhZ2luYXRpb24tc2l6ZS1zZWxlY3Rvci1kcm9wZG93bmB9XG4gICAgICAgICAgICAgICAgcG9wdXBDbGFzc05hbWU9e2Ake3ByZWZpeH1wYWdpbmF0aW9uLXNpemUtc2VsZWN0b3ItcG9wdXBgfVxuICAgICAgICAgICAgICAgIHBvcHVwQ29udGFpbmVyPXtub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIGF1dG9XaWR0aFxuICAgICAgICAgICAgICAgIHNpemU9e3NpemV9XG4gICAgICAgICAgICAgICAgdmFsdWU9e2N1cnJlbnRQYWdlU2l6ZX1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vblNlbGVjdFNpemUuYmluZCh0aGlzKX0+XG4gICAgICAgICAgICAgICAge3BhZ2VTaXplTGlzdC5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhZ2VTaXplO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8ge2xhYmVsOiAnJywgdmFsdWU6IDV9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGl0ZW0ubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlU2l6ZSA9IGl0ZW0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsID0gcGFnZVNpemUgPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA8T3B0aW9uIGtleT17aW5kZXh9IHZhbHVlPXtwYWdlU2l6ZX0+e2xhYmVsfTwvT3B0aW9uPjtcbiAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgIDwvU2VsZWN0PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgcHJlZml4LCBwdXJlLCBydGwsIHR5cGUsIHNpemUsIHNoYXBlLCBjbGFzc05hbWUsIHRvdGFsLCB0b3RhbFJlbmRlcixcbiAgICAgICAgICAgIHBhZ2VTaXplLCBwYWdlU2l6ZVNlbGVjdG9yLCBwYWdlU2l6ZUxpc3QsIHBhZ2VTaXplUG9zaXRpb24sIHVzZUZsb2F0TGF5b3V0LCBvblBhZ2VTaXplQ2hhbmdlLFxuICAgICAgICAgICAgaGlkZU9ubHlPbmVQYWdlLCBzaG93SnVtcCwgbG9jYWxlLCBjdXJyZW50LCBkZWZhdWx0Q3VycmVudCwgcGFnZVNob3dDb3VudCwgcGFnZU51bWJlclJlbmRlcixcbiAgICAgICAgICAgIGxpbmssIG9uQ2hhbmdlLCAuLi5vdGhlcnNcbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAgICAgY29uc3QgeyBjdXJyZW50OiBjdXJyZW50UGFnZSwgY3VycmVudFBhZ2VTaXplIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB0b3RhbFBhZ2UgPSB0aGlzLmdldFRvdGFsUGFnZSh0b3RhbCwgY3VycmVudFBhZ2VTaXplKTtcbiAgICAgICAgY29uc3QgcGFnZUZpcnN0ID0gdGhpcy5yZW5kZXJQYWdlRmlyc3QoY3VycmVudFBhZ2UpO1xuICAgICAgICBjb25zdCBwYWdlTGFzdCA9IHRoaXMucmVuZGVyUGFnZUxhc3QoY3VycmVudFBhZ2UsIHRvdGFsUGFnZSk7XG4gICAgICAgIGNvbnN0IHNpemVTZWxlY3RvciA9IHRoaXMucmVuZGVyUGFnZVNpemVTZWxlY3RvcigpO1xuICAgICAgICBjb25zdCBpc1N0YXJ0ID0gcGFnZVNpemVQb3NpdGlvbiA9PT0gJ3N0YXJ0JztcblxuICAgICAgICBjb25zdCBjbGFzc2VzID0gY3goe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1wYWdpbmF0aW9uYF06IHRydWUsXG4gICAgICAgICAgICBbYCR7cHJlZml4fSR7c2l6ZX1gXTogc2l6ZSxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9JHt0eXBlfWBdOiB0eXBlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH0ke3NoYXBlfWBdOiBzaGFwZSxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9c3RhcnRgXTogISFwYWdlU2l6ZVNlbGVjdG9yICYmIGlzU3RhcnQgJiYgdXNlRmxvYXRMYXlvdXQsXG4gICAgICAgICAgICBbYCR7cHJlZml4fWVuZGBdOiAhIXBhZ2VTaXplU2VsZWN0b3IgJiYgIWlzU3RhcnQgJiYgdXNlRmxvYXRMYXlvdXQsXG4gICAgICAgICAgICBbYCR7cHJlZml4fWhpZGVgXTogdG90YWxQYWdlIDw9IDEgJiYgaGlkZU9ubHlPbmVQYWdlLFxuICAgICAgICAgICAgW2NsYXNzTmFtZV06ICEhY2xhc3NOYW1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChydGwpIHtcbiAgICAgICAgICAgIG90aGVycy5kaXIgPSAncnRsJztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1aWxkQ29tcG9uZW50ID0gKC4uLmNvbXMpID0+IChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzfSB7Li4ub3RoZXJzfT5cbiAgICAgICAgICAgICAgICB7aXNTdGFydCAmJiBzaXplU2VsZWN0b3J9XG4gICAgICAgICAgICAgICAge3RvdGFsUmVuZGVyID8gdGhpcy5yZW5kZXJQYWdlVG90YWwoKSA6IG51bGx9XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH1wYWdpbmF0aW9uLXBhZ2VzYH0+XG4gICAgICAgICAgICAgICAgICAgIHtjb21zLm1hcCgoY29tLCBpbmRleCkgPT4gY29tICYmIFJlYWN0LmNsb25lRWxlbWVudChjb20sIHsga2V5OiBpbmRleCB9KSl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgeyFpc1N0YXJ0ICYmIHNpemVTZWxlY3Rvcn1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbWluaSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkQ29tcG9uZW50KHBhZ2VGaXJzdCwgcGFnZUxhc3QpO1xuICAgICAgICAgICAgY2FzZSAnc2ltcGxlJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VEaXNwbGF5ID0gdGhpcy5yZW5kZXJQYWdlRGlzcGxheShjdXJyZW50UGFnZSwgdG90YWxQYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRDb21wb25lbnQocGFnZUZpcnN0LCBwYWdlRGlzcGxheSwgcGFnZUxhc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbm9ybWFsJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VMaXN0ID0gdGhpcy5yZW5kZXJQYWdlTGlzdChjdXJyZW50UGFnZSwgdG90YWxQYWdlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlRGlzcGxheSA9IHNob3dKdW1wICYmIHRvdGFsID4gcGFnZVNpemUgKiBwYWdlU2hvd0NvdW50ID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJQYWdlRGlzcGxheShjdXJyZW50UGFnZSwgdG90YWxQYWdlKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFnZUp1bXAgPSBzaG93SnVtcCAmJiB0b3RhbCA+IHBhZ2VTaXplICogcGFnZVNob3dDb3VudCA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUGFnZUp1bXAoY3VycmVudFBhZ2UsIHRvdGFsUGFnZSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBidWlsZENvbXBvbmVudChwYWdlRmlyc3QsIHBhZ2VMaXN0LCBwYWdlTGFzdCwgcGFnZURpc3BsYXksIC4uLnBhZ2VKdW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZ1Byb3ZpZGVyLmNvbmZpZyhQYWdpbmF0aW9uKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wYWdpbmF0aW9uL3BhZ2luYXRpb24uanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBJY29uIGZyb20gJy4uL2ljb24nO1xuaW1wb3J0IHtvYmosIGZ1bmN9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IEJhc2UgZnJvbSAnLi9iYXNlJztcbmltcG9ydCBHcm91cCBmcm9tICcuL2dyb3VwJztcblxuLy8gcHJldmVudERlZmF1bHQgaGVyZSBjYW4gc3RvcCBvbkJsdXIgdG8ga2VlcCBmb2N1cyBzdGF0ZVxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbn1cblxuLyoqIElucHV0ICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC4uLkJhc2UucHJvcFR5cGVzLFxuICAgICAgICAvKipcbiAgICAgICAgICogbGFiZWxcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuWHuueOsGNsZWFy5oyJ6ZKuXG4gICAgICAgICAqL1xuICAgICAgICBoYXNDbGVhcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbmnInovrnmoYZcbiAgICAgICAgICovXG4gICAgICAgIGhhc0JvcmRlcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnirbmgIFcbiAgICAgICAgICogQGVudW1kZXNjIOmUmeivrywg5qCh6aqM5LitLCDmiJDlip9cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRlOiBQcm9wVHlwZXMub25lT2YoWydlcnJvcicsICdsb2FkaW5nJywgJ3N1Y2Nlc3MnXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlsLrlr7hcbiAgICAgICAgICogQGVudW1kZXNjIOWwjywg5LitLCDlpKdcbiAgICAgICAgICovXG4gICAgICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3NtYWxsJywgJ21lZGl1bScsICdsYXJnZSddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaMieS4i+Wbnui9pueahOWbnuiwg1xuICAgICAgICAgKi9cbiAgICAgICAgb25QcmVzc0VudGVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAgICAgICBvbkNsZWFyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWOn+eUn3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGh0bWxUeXBlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBodG1sU2l6ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOawtOWNsCAoSWNvbueahHR5cGXnsbvlnovvvIzlkoxoYXNDbGVhcuWNoOeUqOS4gOS4quWcsOaWuSlcbiAgICAgICAgICovXG4gICAgICAgIGhpbnQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmloflrZfliY3pmYTliqDlhoXlrrlcbiAgICAgICAgICovXG4gICAgICAgIGlubmVyQmVmb3JlOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaWh+Wtl+WQjumZhOWKoOWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgaW5uZXJBZnRlcjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDovpPlhaXmoYbliY3pmYTliqDlhoXlrrlcbiAgICAgICAgICovXG4gICAgICAgIGFkZG9uQmVmb3JlOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOi+k+WFpeahhuWQjumZhOWKoOWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkb25BZnRlcjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDovpPlhaXmoYbliY3pmYTliqDmloflrZdcbiAgICAgICAgICovXG4gICAgICAgIGFkZG9uVGV4dEJlZm9yZTogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDovpPlhaXmoYblkI7pmYTliqDmloflrZdcbiAgICAgICAgICovXG4gICAgICAgIGFkZG9uVGV4dEFmdGVyOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqICjljp/nlJ9pbnB1dOaUr+aMgSlcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Db21wbGV0ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWKqOiBmueEpijljp/nlJ9pbnB1dOaUr+aMgSlcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Gb2N1czogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGlucHV0UmVuZGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgZXh0cmE6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICBpbm5lckJlZm9yZUNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgaW5uZXJBZnRlckNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgLi4uQmFzZS5kZWZhdWx0UHJvcHMsXG4gICAgICAgIHNpemU6ICdtZWRpdW0nLFxuICAgICAgICBhdXRvQ29tcGxldGU6ICdvZmYnLFxuICAgICAgICBoYXNCb3JkZXI6IHRydWUsXG4gICAgICAgIG9uUHJlc3NFbnRlcjogZnVuYy5ub29wLFxuICAgICAgICBpbnB1dFJlbmRlcjogKGVsKSA9PiBlbCxcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgaWYgKCd2YWx1ZScgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB2YWx1ZTogdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICcnIDogdmFsdWUsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gYEVudGVyYCB3YXMgY29uc2lkZXJlZCB0byBiZSB0d28gY2hhcnMgaW4gY2hyb21lICwgYnV0IG9uZSBjaGFyIGluIGllLlxuICAgIC8vIHNvIHdlIG1ha2UgYWxsIGBFbnRlcmAgdG8gYmUgdHdvIGNoYXJzXG4gICAgZ2V0VmFsdWVMZW5ndGgodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbnYgPSBgJHt2YWx1ZX1gO1xuICAgICAgICBsZXQgc3RyTGVuID0gdGhpcy5wcm9wcy5nZXRWYWx1ZUxlbmd0aChudik7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyTGVuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgc3RyTGVuID0gbnYubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0ckxlbjtcbiAgICB9XG5cbiAgICByZW5kZXJDb250cm9sKCkge1xuICAgICAgICBjb25zdCB7aGFzQ2xlYXIsIHJlYWRPbmx5LCBzdGF0ZSwgcHJlZml4LCBoaW50LCBleHRyYSwgbG9jYWxlfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgY29uc3QgbGVuV3JhcCA9IHRoaXMucmVuZGVyTGVuZ3RoKCk7XG5cbiAgICAgICAgbGV0IHN0YXRlV3JhcCA9IG51bGw7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICBzdGF0ZVdyYXAgPSA8SWNvbiB0eXBlPVwic3VjY2Vzcy1maWxsaW5nXCIvPjtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgICAgICBzdGF0ZVdyYXAgPSA8SWNvbiB0eXBlPVwibG9hZGluZ1wiLz47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2xlYXJXcmFwID0gbnVsbDtcbiAgICAgICAgY29uc3Qgc2hvd0NsZWFyID0gaGFzQ2xlYXIgJiYgIXJlYWRPbmx5ICYmICEhKGAke3RoaXMuc3RhdGUudmFsdWV9YCk7XG5cbiAgICAgICAgaWYgKGhpbnQgfHwgc2hvd0NsZWFyKSB7XG4gICAgICAgICAgICBsZXQgaGludEljb24gPSBudWxsO1xuICAgICAgICAgICAgaWYgKGhpbnQpIHtcbiAgICAgICAgICAgICAgICBoaW50SWNvbiA9IDxJY29uIHR5cGU9e2hpbnR9IGNsYXNzTmFtZT17YCR7cHJlZml4fWlucHV0LWhpbnRgfS8+O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoaW50SWNvbiA9ICg8SWNvbiB0eXBlPVwiZGVsZXRlLWZpbGxpbmdcIiByb2xlPVwiYnV0dG9uXCIgdGFiSW5kZXg9XCIwXCIgY2xhc3NOYW1lPXtgJHtwcmVmaXh9aW5wdXQtaGludGB9IGFyaWEtbGFiZWw9e2xvY2FsZS5jbGVhcn1cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5vbkNsZWFyLmJpbmQodGhpcyl9XG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VEb3duPXtwcmV2ZW50RGVmYXVsdH1cbiAgICAgICAgICAgICAgICAgICAgb25LZXlEb3duPXt0aGlzLmhhbmRsZUtleURvd25Gcm9tQ2xlYXJ9IC8+KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xlYXJXcmFwID0gKDxzcGFuIGNsYXNzTmFtZT17YCR7cHJlZml4fWlucHV0LWhpbnQtd3JhcGB9PlxuICAgICAgICAgICAgICAgIHtoYXNDbGVhciAmJiBoaW50ID8gPEljb24gdHlwZT1cImRlbGV0ZS1maWxsaW5nXCIgcm9sZT1cImJ1dHRvblwiIHRhYkluZGV4PVwiMFwiIGNsYXNzTmFtZT17YCR7cHJlZml4fWlucHV0LWNsZWFyYH0gYXJpYS1sYWJlbD17bG9jYWxlLmNsZWFyfVxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xlYXIuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZURvd249e3ByZXZlbnREZWZhdWx0fVxuICAgICAgICAgICAgICAgICAgICBvbktleURvd249e3RoaXMuaGFuZGxlS2V5RG93bkZyb21DbGVhcn0gLz4gOiBudWxsfVxuICAgICAgICAgICAgICAgIHtoaW50SWNvbn1cbiAgICAgICAgICAgIDwvc3Bhbj4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgICAgIGNsZWFyV3JhcCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xlYXJXcmFwIHx8IGxlbldyYXAgfHwgc3RhdGVXcmFwIHx8IGV4dHJhID8gPHNwYW4gY2xhc3NOYW1lPXtgJHtwcmVmaXh9aW5wdXQtY29udHJvbGB9PlxuICAgICAgICAgICAge2NsZWFyV3JhcH17bGVuV3JhcH17c3RhdGVXcmFwfXtleHRyYX1cbiAgICAgICAgPC9zcGFuPiA6IG51bGw7XG4gICAgfVxuXG4gICAgcmVuZGVyTGFiZWwoKSB7XG4gICAgICAgIGNvbnN0IHtsYWJlbCwgcHJlZml4LCBpZH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gbGFiZWwgPyA8bGFiZWwgY2xhc3NOYW1lPXtgJHtwcmVmaXh9aW5wdXQtbGFiZWxgfSBodG1sRm9yPXtpZH0+XG4gICAgICAgICAgICB7bGFiZWx9XG4gICAgICAgIDwvbGFiZWw+IDogbnVsbDtcbiAgICB9XG5cbiAgICByZW5kZXJJbm5lcihpbm5lciwgY2xzKSB7XG4gICAgICAgIHJldHVybiBpbm5lciA/IDxzcGFuIGNsYXNzTmFtZT17Y2xzfT57aW5uZXJ9PC9zcGFuPiA6IG51bGw7XG4gICAgfVxuXG4gICAgaGFuZGxlS2V5RG93biA9IChlKSA9PiB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uUHJlc3NFbnRlcihlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub25LZXlEb3duKGUpO1xuICAgIH07XG5cbiAgICBoYW5kbGVLZXlEb3duRnJvbUNsZWFyID0gKGUpID0+IHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgIHRoaXMub25DbGVhcihlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBvbkNsZWFyKGUpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOmdnuWPl+aOp+aooeW8j+a4heepuuWGhemDqOaVsOaNrlxuICAgICAgICBpZiAoISgndmFsdWUnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogJydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoJycsIGUsICdjbGVhcicpO1xuICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7c2l6ZSwgaHRtbFR5cGUsIGh0bWxTaXplLCBhdXRvQ29tcGxldGUsIGF1dG9Gb2N1cywgZGlzYWJsZWQsIHN0eWxlLCBpbm5lckJlZm9yZSwgaW5uZXJBZnRlciwgaW5uZXJCZWZvcmVDbGFzc05hbWUsIGlubmVyQWZ0ZXJDbGFzc05hbWUsIGNsYXNzTmFtZSwgaGFzQm9yZGVyLCBwcmVmaXgsIGFkZG9uQmVmb3JlLCBhZGRvbkFmdGVyLCBhZGRvblRleHRCZWZvcmUsIGFkZG9uVGV4dEFmdGVyLCBpbnB1dFJlbmRlciwgcnRsfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgY29uc3QgaGFzQWRkb24gPSBhZGRvbkJlZm9yZSB8fCBhZGRvbkFmdGVyIHx8IGFkZG9uVGV4dEJlZm9yZSB8fCBhZGRvblRleHRBZnRlcjtcbiAgICAgICAgY29uc3QgY2xzID0gY2xhc3NOYW1lcyh0aGlzLmdldENsYXNzKCksIHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9JHtzaXplfWBdOiB0cnVlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1oaWRkZW5gXTogdGhpcy5wcm9wcy5odG1sVHlwZSA9PT0gJ2hpZGRlbicsXG4gICAgICAgICAgICBbYCR7cHJlZml4fW5vYm9yZGVyYF06ICFoYXNCb3JkZXIgfHwgdGhpcy5wcm9wcy5odG1sVHlwZSA9PT0gJ2ZpbGUnLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1pbnB1dC1ncm91cC1hdXRvLXdpZHRoYF06IGhhc0FkZG9uLFxuICAgICAgICAgICAgW2NsYXNzTmFtZV06ICEhY2xhc3NOYW1lICYmICFoYXNBZGRvblxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBpbm5lckNscyA9IGAke3ByZWZpeH1pbnB1dC1pbm5lcmA7XG4gICAgICAgIGNvbnN0IGlubmVyQmVmb3JlQ2xzID0gY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICBbaW5uZXJDbHNdOiB0cnVlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1iZWZvcmVgXTogdHJ1ZSxcbiAgICAgICAgICAgIFtpbm5lckJlZm9yZUNsYXNzTmFtZV06IGlubmVyQmVmb3JlQ2xhc3NOYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbm5lckFmdGVyQ2xzID0gY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICBbaW5uZXJDbHNdOiB0cnVlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1hZnRlcmBdOiB0cnVlLFxuICAgICAgICAgICAgW2lubmVyQWZ0ZXJDbGFzc05hbWVdOiBpbm5lckFmdGVyQ2xhc3NOYW1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICAvLyBjdXN0b20gZGF0YSBhdHRyaWJ1dGVzIGFyZSBhc3NpZ25lZCB0byB0aGUgdG9wIHBhcmVudCBub2RlXG4gICAgICAgIC8vIGRhdGEt57G76Ieq5a6a5LmJ5pWw5o2u5bGe5oCn5YiG6YWN5Yiw6aG25bGCbm9kZeiKgueCuVxuICAgICAgICBjb25zdCBkYXRhUHJvcHMgPSBvYmoucGlja0F0dHJzV2l0aCh0aGlzLnByb3BzLCAnZGF0YS0nKTtcbiAgICAgICAgLy8gQ3VzdG9tIHByb3BzIGFyZSB0cmFuc3BhcmVudGx5IHRyYW5zbWl0dGVkIHRvIHRoZSBjb3JlIGlucHV0IG5vZGUgYnkgZGVmYXVsdFxuICAgICAgICAvLyDoh6rlrprkuYnlsZ7mgKfpu5jorqTpgI/kvKDliLDmoLjlv4Nub2Rl6IqC54K577yaaW5wdXRcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gb2JqLnBpY2tPdGhlcnMoT2JqZWN0LmFzc2lnbih7fSwgZGF0YVByb3BzLCBJbnB1dC5wcm9wVHlwZXMpLCB0aGlzLnByb3BzKTtcblxuICAgICAgICBjb25zdCBpbnB1dEVsID0gKDxpbnB1dFxuICAgICAgICAgICAgey4uLm90aGVyc31cbiAgICAgICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgICAgIGhlaWdodD1cIjEwMCVcIlxuICAgICAgICAgICAgdHlwZT17aHRtbFR5cGV9XG4gICAgICAgICAgICBzaXplPXtodG1sU2l6ZX1cbiAgICAgICAgICAgIGF1dG9Gb2N1cz17YXV0b0ZvY3VzfVxuICAgICAgICAgICAgYXV0b0NvbXBsZXRlPXthdXRvQ29tcGxldGV9XG4gICAgICAgICAgICBvbktleURvd249e3RoaXMuaGFuZGxlS2V5RG93bn1cbiAgICAgICAgICAgIHJlZj17dGhpcy5zYXZlUmVmfVxuICAgICAgICAvPik7XG5cbiAgICAgICAgY29uc3QgaW5wdXRXcmFwID0gKDxzcGFuIHsuLi5kYXRhUHJvcHN9IGRpcj17cnRsID8gJ3J0bCcgOiB1bmRlZmluZWR9IGNsYXNzTmFtZT17Y2xzfSBzdHlsZT17aGFzQWRkb24gPyB1bmRlZmluZWQgOiBzdHlsZX0+XG4gICAgICAgICAgICB7dGhpcy5yZW5kZXJJbm5lcihpbm5lckJlZm9yZSwgaW5uZXJCZWZvcmVDbHMpfVxuICAgICAgICAgICAge3RoaXMucmVuZGVyTGFiZWwoKX1cbiAgICAgICAgICAgIHtpbnB1dFJlbmRlcihpbnB1dEVsKX1cbiAgICAgICAgICAgIHt0aGlzLnJlbmRlckNvbnRyb2woKX1cbiAgICAgICAgICAgIHt0aGlzLnJlbmRlcklubmVyKGlubmVyQWZ0ZXIsIGlubmVyQWZ0ZXJDbHMpfVxuICAgICAgICA8L3NwYW4+KTtcblxuICAgICAgICBjb25zdCBncm91cENscyA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1pbnB1dC1ncm91cC10ZXh0YF06IHRydWUsXG4gICAgICAgICAgICBbYCR7cHJlZml4fSR7c2l6ZX1gXTogISFzaXplLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1kaXNhYmxlZGBdOiBkaXNhYmxlZCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgYWRkb25CZWZvcmVDbHMgPSBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgIFtncm91cENsc106IGFkZG9uVGV4dEJlZm9yZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFkZG9uQWZ0ZXJDbHMgPSBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgIFtncm91cENsc106IGFkZG9uVGV4dEFmdGVyLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaGFzQWRkb24pIHtcbiAgICAgICAgICAgIHJldHVybiAoPEdyb3VwXG4gICAgICAgICAgICAgICAgey4uLmRhdGFQcm9wc31cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgICAgICAgICAgICBzdHlsZT17c3R5bGV9XG4gICAgICAgICAgICAgICAgYWRkb25CZWZvcmU9e2FkZG9uQmVmb3JlIHx8IGFkZG9uVGV4dEJlZm9yZX1cbiAgICAgICAgICAgICAgICBhZGRvbkJlZm9yZUNsYXNzTmFtZT17YWRkb25CZWZvcmVDbHN9XG4gICAgICAgICAgICAgICAgYWRkb25BZnRlcj17YWRkb25BZnRlciB8fCBhZGRvblRleHRBZnRlcn1cbiAgICAgICAgICAgICAgICBhZGRvbkFmdGVyQ2xhc3NOYW1lPXthZGRvbkFmdGVyQ2xzfT5cbiAgICAgICAgICAgICAgICB7aW5wdXRXcmFwfVxuICAgICAgICAgICAgPC9Hcm91cD4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlucHV0V3JhcDtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5wdXQvaW5wdXQuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHtvYmosIGVudn0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgQmFzZSBmcm9tICcuL2Jhc2UnO1xuXG5mdW5jdGlvbiBvbk5leHRGcmFtZShjYikge1xuICAgIGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGNiLCAxKTtcbn1cblxuZnVuY3Rpb24gY2xlYXJOZXh0RnJhbWVBY3Rpb24obmV4dEZyYW1lSWQpIHtcbiAgICBpZiAod2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShuZXh0RnJhbWVJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChuZXh0RnJhbWVJZCk7XG4gICAgfVxufVxuXG5jb25zdCBoaWRkZW5TdHlsZSA9IHtcbiAgICB2aXNpYmlsaXR5OiAnaGlkZGVuJyxcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB6SW5kZXg6ICctMTAwMCcsXG4gICAgdG9wOiAnLTEwMDBweCcsXG4gICAgb3ZlcmZsb3dZOiAnaGlkZGVuJyxcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxufTtcblxuLyoqXG4gKiBJbnB1dC5UZXh0QXJlYVxuICogQG9yZGVyIDJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dEFyZWEgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAuLi5CYXNlLnByb3BUeXBlcyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeKtuaAgVxuICAgICAgICAgKiBAZW51bWRlc2Mg6ZSZ6K+vXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0ZTogUHJvcFR5cGVzLm9uZU9mKFsnZXJyb3InXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rliqjpq5jluqYgdHJ1ZSAvIHttaW5Sb3dzOiAyLCBtYXhSb3dzOiA0fVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b0hlaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWkmuihjOaWh+acrOahhumrmOW6piA8YnIgLz4o5LiN6KaB55u05o6l55SoaGVpZ2h06K6+572u5aSa6KGM5paH5pys5qGG55qE6auY5bqmLCBpZTkgMTDkvJrmnInlhbzlrrnmgKfpl67popgpXG4gICAgICAgICAqL1xuICAgICAgICByb3dzOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAuLi5CYXNlLmRlZmF1bHRQcm9wcyxcbiAgICAgICAgcm93czogNCxcbiAgICAgICAgYXV0b0hlaWdodDogZmFsc2VcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgaWYgKCd2YWx1ZScgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB2YWx1ZTogdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICcnIDogdmFsdWUsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnN0IGF1dG9IZWlnaHQgPSB0aGlzLnByb3BzLmF1dG9IZWlnaHQ7XG4gICAgICAgIGlmIChhdXRvSGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGF1dG9IZWlnaHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3Qvbm8tZGlkLW1vdW50LXNldC1zdGF0ZSAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy5fZ2V0TWluTWF4SGVpZ2h0KGF1dG9IZWlnaHQsIHRoaXMuc3RhdGUudmFsdWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5fZ2V0SGVpZ2h0KHRoaXMuc3RhdGUudmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd1k6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgc3VwZXIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmF1dG9IZWlnaHQgJiYgdGhpcy5wcm9wcy52YWx1ZSAhPT0gbmV4dFByb3BzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemVUZXh0QXJlYShuZXh0UHJvcHMudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldE1pbk1heEhlaWdodCh7bWluUm93cywgbWF4Um93c30sIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzLmhlbHBSZWYpO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgncm93cycsIG1pblJvd3MpO1xuICAgICAgICBjb25zdCBtaW5IZWlnaHQgPSBub2RlLmNsaWVudEhlaWdodDtcblxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgncm93cycsIG1heFJvd3MpO1xuICAgICAgICBjb25zdCBtYXhIZWlnaHQgPSBub2RlLmNsaWVudEhlaWdodDtcblxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgncm93cycsICcxJyk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuX2dldEhlaWdodCh2YWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbkhlaWdodCxcbiAgICAgICAgICAgIG1heEhlaWdodCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIG92ZXJmbG93WTogaGVpZ2h0IDw9IG1heEhlaWdodCA/ICdoaWRkZW4nIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9nZXRIZWlnaHQodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMuaGVscFJlZik7XG4gICAgICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gbm9kZS5zY3JvbGxIZWlnaHQ7XG4gICAgfVxuXG4gICAgX3Jlc2l6ZVRleHRBcmVhID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLm5leHRGcmFtZUFjdGlvbklkKSB7XG4gICAgICAgICAgICBjbGVhck5leHRGcmFtZUFjdGlvbih0aGlzLm5leHRGcmFtZUFjdGlvbklkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHRGcmFtZUFjdGlvbklkID0gb25OZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5fZ2V0SGVpZ2h0KHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IG1heEhlaWdodCA9IHRoaXMuc3RhdGUubWF4SGVpZ2h0ID8gdGhpcy5zdGF0ZS5tYXhIZWlnaHQgOiBJbmZpbml0eTtcblxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLl9nZXRIZWlnaHQodmFsdWUpLFxuICAgICAgICAgICAgICAgIG92ZXJmbG93WTogaGVpZ2h0IDw9IG1heEhlaWdodCA/ICdoaWRkZW4nIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZUhhY2sodmFsdWUpIHtcbiAgICAgICAgLy8gRml4OiB0ZXh0YXJlYSBkaXQgbm90IHN1cHBvcnQgbWF4TGVuZ3RoIGluIGllOVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGVudi5pZVZlcnNpb24gJiYgdGhpcy5wcm9wcy5tYXhMZW5ndGggJiYgdGhpcy5wcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgY29uc3QgbWF4TGVuZ3RoID0gcGFyc2VJbnQodGhpcy5wcm9wcy5tYXhMZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gdGhpcy5nZXRWYWx1ZUxlbmd0aCh2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAobGVuID4gbWF4TGVuZ3RoICYmIHRoaXMucHJvcHMuY3V0U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXG4vZywgJ1xcblxcbicpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIG1heExlbmd0aCk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXG5cXG4vZywgJ1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9wcy5hdXRvSGVpZ2h0ICYmIHRoaXMuX3Jlc2l6ZVRleHRBcmVhKHZhbHVlKTtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gYEVudGVyYCB3YXMgY29uc2lkZXJlZCB0byBiZSB0d28gY2hhcnMgaW4gY2hyb21lICwgYnV0IG9uZSBjaGFyIGluIGllLlxuICAgIC8vIHNvIHdlIG1ha2UgYWxsIGBFbnRlcmAgdG8gYmUgdHdvIGNoYXJzXG4gICAgZ2V0VmFsdWVMZW5ndGgodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbnYgPSBgJHt2YWx1ZX1gO1xuICAgICAgICBsZXQgc3RyTGVuID0gdGhpcy5wcm9wcy5nZXRWYWx1ZUxlbmd0aChudik7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyTGVuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgc3RyTGVuID0gbnYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoZW52LmllVmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ckxlbiArIG52LnNwbGl0KCdcXG4nKS5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJMZW47XG4gICAgfVxuXG4gICAgc2F2ZVRleHRBcmVhUmVmKHRleHRBcmVhKSB7XG4gICAgICAgIHRoaXMuaW5wdXRSZWYgPSB0ZXh0QXJlYTtcbiAgICB9XG5cbiAgICBzYXZlSGVscFJlZihyZWYpIHtcbiAgICAgICAgdGhpcy5oZWxwUmVmID0gcmVmO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3Qge3Jvd3MsIHN0eWxlLCBjbGFzc05hbWUsIGF1dG9IZWlnaHQsIHByZWZpeCwgcnRsfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgY29uc3QgY2xzID0gY2xhc3NOYW1lcyh0aGlzLmdldENsYXNzKCksIHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9aW5wdXQtdGV4dGFyZWFgXTogdHJ1ZSxcbiAgICAgICAgICAgIFtjbGFzc05hbWVdOiAhIWNsYXNzTmFtZVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgLy8gY3VzdG9tIGRhdGEgYXR0cmlidXRlcyBhcmUgYXNzaWduZWQgdG8gdGhlIHRvcCBwYXJlbnQgbm9kZVxuICAgICAgICAvLyBkYXRhLeexu+iHquWumuS5ieaVsOaNruWxnuaAp+WIhumFjeWIsOmhtuWxgm5vZGXoioLngrlcbiAgICAgICAgY29uc3QgZGF0YVByb3BzID0gb2JqLnBpY2tBdHRyc1dpdGgodGhpcy5wcm9wcywgJ2RhdGEtJyk7XG4gICAgICAgIC8vIEN1c3RvbSBwcm9wcyBhcmUgdHJhbnNwYXJlbnRseSB0cmFuc21pdHRlZCB0byB0aGUgY29yZSBpbnB1dCBub2RlIGJ5IGRlZmF1bHRcbiAgICAgICAgLy8g6Ieq5a6a5LmJ5bGe5oCn6buY6K6k6YCP5Lyg5Yiw5qC45b+Dbm9kZeiKgueCue+8mmlucHV0XG4gICAgICAgIGNvbnN0IG90aGVycyA9IG9iai5waWNrT3RoZXJzKE9iamVjdC5hc3NpZ24oe30sIGRhdGFQcm9wcywgVGV4dEFyZWEucHJvcFR5cGVzKSwgdGhpcy5wcm9wcyk7XG5cbiAgICAgICAgY29uc3QgdGV4dGFyZVN0eWxlID0ge1xuICAgICAgICAgICAgLi4ucHJvcHMuc3R5bGUsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuc3RhdGUuaGVpZ2h0LFxuICAgICAgICAgICAgbWluSGVpZ2h0OiB0aGlzLnN0YXRlLm1pbkhlaWdodCxcbiAgICAgICAgICAgIG1heEhlaWdodDogdGhpcy5zdGF0ZS5tYXhIZWlnaHQsXG4gICAgICAgICAgICBvdmVyZmxvd1k6IHRoaXMuc3RhdGUub3ZlcmZsb3dZLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHdyYXBTdHlsZSA9IGF1dG9IZWlnaHQgPyB7XG4gICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICB9IDogc3R5bGU7XG5cbiAgICAgICAgcmV0dXJuICg8c3BhbiBjbGFzc05hbWU9e2Nsc30gc3R5bGU9e3dyYXBTdHlsZX0gZGlyPXtydGwgPyAncnRsJyA6IHVuZGVmaW5lZH0gey4uLmRhdGFQcm9wc30+XG4gICAgICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICAgICAgICB7Li4ub3RoZXJzfVxuICAgICAgICAgICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgICAgICAgICBkYXRhLXJlYWxcbiAgICAgICAgICAgICAgICByb3dzPXtyb3dzfVxuICAgICAgICAgICAgICAgIHN0eWxlPXt0ZXh0YXJlU3R5bGV9XG4gICAgICAgICAgICAgICAgcmVmPXt0aGlzLnNhdmVSZWYuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICBvbktleURvd249e3RoaXMub25LZXlEb3duLmJpbmQodGhpcyl9Lz5cbiAgICAgICAgICAgIHthdXRvSGVpZ2h0ID8gPHRleHRhcmVhIGRhdGEtZmFrZSByZWY9e3RoaXMuc2F2ZUhlbHBSZWYuYmluZCh0aGlzKX0gc3R5bGU9e3suLi5wcm9wcy5zdHlsZSwgLi4uaGlkZGVuU3R5bGV9fVxuICAgICAgICAgICAgICAgIHJvd3M9XCIxXCIvPiA6IG51bGx9XG4gICAgICAgICAgICB7dGhpcy5yZW5kZXJDb250cm9sKCl9XG4gICAgICAgIDwvc3Bhbj4pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbnB1dC90ZXh0YXJlYS5qc3giLCJpbXBvcnQgQ29uZmlnUHJvdmlkZXIgZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCBTZWxlY3QgZnJvbSAnLi9zZWxlY3QnO1xuaW1wb3J0IEF1dG9Db21wbGV0ZSBmcm9tICcuL2F1dG8tY29tcGxldGUnO1xuaW1wb3J0IE9wdGlvbiBmcm9tICcuL29wdGlvbic7XG5pbXBvcnQgT3B0aW9uR3JvdXAgZnJvbSAnLi9vcHRpb24tZ3JvdXAnO1xuXG5TZWxlY3QuQXV0b0NvbXBsZXRlID0gQ29uZmlnUHJvdmlkZXIuY29uZmlnKEF1dG9Db21wbGV0ZSwge1xuICAgIGNvbXBvbmVudE5hbWU6ICdTZWxlY3QnXG59KTtcblxuU2VsZWN0Lk9wdGlvbiA9IE9wdGlvbjtcblNlbGVjdC5PcHRpb25Hcm91cCA9IE9wdGlvbkdyb3VwO1xuXG4vLyBjb21wYXRpYmxlIHdpdGggMC54IHZlcnNpb25cbmZ1bmN0aW9uIHRyYW5zZm9ybShwcm9wcywgZGVwcmVjYXRlZCkge1xuICAgIGNvbnN0IHsgc2hhcGUsIGNvbnRhaW5lciwgbXVsdGlwbGUsIGZpbHRlckJ5LCBvdmVybGF5LCBzYWZlTm9kZSwgbm9Gb3VuZENvbnRlbnQsIC4uLm90aGVycyB9ID0gcHJvcHM7XG5cbiAgICBjb25zdCBuZXdwcm9wcyA9IG90aGVycztcbiAgICBpZiAoc2hhcGUgPT09ICdhcnJvdy1vbmx5Jykge1xuICAgICAgICBkZXByZWNhdGVkKCdzaGFwZT1hcnJvdy1vbmx5JywgJ2hhc0JvcmRlcj1mYWxzZScsICdTZWxlY3QnKTtcbiAgICAgICAgbmV3cHJvcHMuaGFzQm9yZGVyID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgZGVwcmVjYXRlZCgnY29udGFpbmVyJywgJ3BvcHVwQ29udGFpbmVyJywgJ1NlbGVjdCcpO1xuICAgICAgICBuZXdwcm9wcy5wb3B1cENvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgIGRlcHJlY2F0ZWQoJ211bHRpcGxlJywgJ21vZGU9bXVsdGlwbGUnLCAnU2VsZWN0Jyk7XG4gICAgICAgIG5ld3Byb3BzLm1vZGUgPSAnbXVsdGlwbGUnO1xuICAgIH1cbiAgICBpZiAoZmlsdGVyQnkpIHtcbiAgICAgICAgZGVwcmVjYXRlZCgnZmlsdGVyQnknLCAnZmlsdGVyJywgJ1NlbGVjdCcpO1xuICAgICAgICBuZXdwcm9wcy5maWx0ZXIgPSBmaWx0ZXJCeTtcbiAgICB9XG4gICAgaWYgKG92ZXJsYXkpIHtcbiAgICAgICAgZGVwcmVjYXRlZCgnb3ZlcmxheScsICdwb3B1cENvbnRlbnQnLCAnU2VsZWN0Jyk7XG4gICAgICAgIG5ld3Byb3BzLnBvcHVwQ29udGVudCA9IG92ZXJsYXk7XG4gICAgICAgIG5ld3Byb3BzLmF1dG9XaWR0aCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChub0ZvdW5kQ29udGVudCkge1xuICAgICAgICBkZXByZWNhdGVkKCdub0ZvdW5kQ29udGVudCcsICdub3RGb3VuZENvbnRlbnQnLCAnU2VsZWN0Jyk7XG4gICAgICAgIG5ld3Byb3BzLm5vdEZvdW5kQ29udGVudCA9IG5vRm91bmRDb250ZW50O1xuICAgIH1cblxuICAgIGlmIChzYWZlTm9kZSkge1xuICAgICAgICBkZXByZWNhdGVkKCdzYWZlTm9kZScsICdwb3B1cFByb3BzPXtzYWZlTm9kZX0nLCAnU2VsZWN0Jyk7XG4gICAgICAgIG5ld3Byb3BzLnBvcHVwUHJvcHMgPSB7XG4gICAgICAgICAgICBzYWZlTm9kZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBuZXdwcm9wcztcbn1cblxuLy8gY29tcGF0aWJsZSB3aXRoIDAueCB2ZXJzaW9uOiBTZWxlY3QuQ29tYm9ib3hcblNlbGVjdC5Db21ib2JveCA9IENvbmZpZ1Byb3ZpZGVyLmNvbmZpZyhTZWxlY3QsIHtcbiAgICB0cmFuc2Zvcm06IChwcm9wcywgZGVwcmVjYXRlZCkgPT4ge1xuICAgICAgICBkZXByZWNhdGVkKCdTZWxlY3QuQ29tYm9ib3gnLCAnPFNlbGVjdCBzaG93U2VhcmNoPXt0cnVlfS8+JywgJ1NlbGVjdCcpO1xuXG4gICAgICAgIGNvbnN0IG5ld3Byb3BzID0gdHJhbnNmb3JtKHByb3BzLCBkZXByZWNhdGVkKTtcbiAgICAgICAgaWYgKHByb3BzLm9uSW5wdXRVcGRhdGUpIHtcbiAgICAgICAgICAgIG5ld3Byb3BzLm9uU2VhcmNoID0gcHJvcHMub25JbnB1dFVwZGF0ZTtcbiAgICAgICAgICAgIG5ld3Byb3BzLnNob3dTZWFyY2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdwcm9wcztcbiAgICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlnUHJvdmlkZXIuY29uZmlnKFNlbGVjdCwge1xuICAgIHRyYW5zZm9ybVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2VsZWN0L2luZGV4LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBmdW5jLCBvYmosIEtFWUNPREUsIGVudiB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IFRhZyBmcm9tICcuLi90YWcnO1xuaW1wb3J0IElucHV0IGZyb20gJy4uL2lucHV0JztcbmltcG9ydCBJY29uIGZyb20gJy4uL2ljb24nO1xuaW1wb3J0IEJhc2UgZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7IGlzTnVsbCwgZ2V0VmFsdWVEYXRhU291cmNlLCB2YWx1ZVRvU2VsZWN0S2V5IH0gZnJvbSAnLi91dGlsJztcblxuY29uc3QgeyBiaW5kQ3R4LCBub29wIH0gPSBmdW5jO1xuY29uc3QgaXNJRTkgPSBlbnYuaWVWZXJzaW9uID09PSA5O1xuXG5cbi8qKlxuICog5peg6Zqc56KN5YyW5rOo5oSP5LqL6aG5OlxuICogMS4gU2VsZWN0IOaXoOaQnOe0ouaDheWGteS4i++8jOS4jeW6lOivpeiuqSBJbnB1dCDlj69mb2N1c++8jOatpOaXtuWkluWxgndyYXDlv4Xpobvlj69mb2N1c++8jOW5tuS4lOmcgOimgeebuOW6lGZvY3Vz5LqL5Lu26K6p5aSW6L655qGG5Y+R55Sf5Y+Y5YyWXG4gKi9cblxuLy8g6Ieq5a6a5LmJ5by55bGC77yaMS4g5LiN6ZyA6KaB5YWz5b+DTWVudeeahOeCueWHu+S6i+S7tiAyLiDkuI3pnIDopoHlhbPlv4NkYXRhU291cmNl5Y+Y5YyWXG5cbi8qKlxuICogU2VsZWN0XG4gKi9cbmNsYXNzIFNlbGVjdCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC4uLkJhc2UucHJvcFR5cGVzLFxuICAgICAgICAvKipcbiAgICAgICAgICog6YCJ5oup5Zmo5qih5byPXG4gICAgICAgICAqL1xuICAgICAgICBtb2RlOiBQcm9wVHlwZXMub25lT2YoWydzaW5nbGUnLCAnbXVsdGlwbGUnLCAndGFnJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5b2T5YmN5YC877yM55So5LqO5Y+X5o6n5qih5byPXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIneWni+eahOm7mOiupOWAvFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2VsZWN05Y+R55Sf5pS55Y+Y5pe26Kem5Y+R55qE5Zue6LCDXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUg6YCJ5Lit55qE5YC8XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25UeXBlIOinpuWPkeeahOaWueW8jywgJ2l0ZW1DbGljaycsICdlbnRlcicsICd0YWcnXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gaXRlbSDpgInkuK3nmoTlgLznmoTlr7nosaHmlbDmja4gKHVzZURldGFpbFZhbHVlPWZhbHNl5pyJ5pWIKVxuICAgICAgICAgKi9cbiAgICAgICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5Lyg5YWl55qE5pWw5o2u5rqQ77yM5Y+v5Lul5Yqo5oCB5riy5p+T5a2Q6aG577yM6K+m6KeBIFtkYXRhU291cmNl55qE5L2/55SoXSgjZGF0YVNvdXJjZeeahOS9v+eUqClcbiAgICAgICAgICovXG4gICAgICAgIGRhdGFTb3VyY2U6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgICAgICAgICAgUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgICAgICAgICBsYWJlbDogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5hcnJheVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgICAgIFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgICAgICBQcm9wVHlwZXMuc3RyaW5nXG4gICAgICAgIF0pKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuaciei+ueahhlxuICAgICAgICAgKi9cbiAgICAgICAgaGFzQm9yZGVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuacieS4i+aLieeureWktFxuICAgICAgICAgKi9cbiAgICAgICAgaGFzQXJyb3c6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5bGV5byA5ZCO5piv5ZCm6IO95pCc57Si77yIdGFnIOaooeW8j+S4i+WbuuWumuS4unRydWXvvIlcbiAgICAgICAgICovXG4gICAgICAgIHNob3dTZWFyY2g6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5b2T5pCc57Si5qGG5YC85Y+Y5YyW5pe25Zue6LCDXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSDmlbDmja5cbiAgICAgICAgICovXG4gICAgICAgIG9uU2VhcmNoOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW9k+aQnOe0ouahhuWAvOiiq+a4heepuuaXtuWAmeeahOWbnuiwg1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uVHlwZSDop6blj5HnmoTmlrnlvI8sICdzZWxlY3QnKOmAieaLqea4heepuiksICdwb3B1cENsb3NlJyjlvLnnqpflhbPpl63muIXnqbopXG4gICAgICAgICAqL1xuICAgICAgICBvblNlYXJjaENsZWFyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWkmumAieaooeW8j+S4i+aYr+WQpuacieWFqOmAieWKn+iDvVxuICAgICAgICAgKi9cbiAgICAgICAgaGFzU2VsZWN0QWxsOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgICAgICAgIFByb3BUeXBlcy5ib29sLFxuICAgICAgICAgICAgUHJvcFR5cGVzLnN0cmluZ1xuICAgICAgICBdKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWhq+WFheWIsOmAieaLqeahhumHjOeahOWAvOeahCBrZXlcYlxiXG4gICAgICAgICAqL1xuICAgICAgICBmaWxsUHJvcHM6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBvbkNoYW5nZSDov5Tlm57nmoQgdmFsdWUg5L2/55SoIGRhdGFTb3VyY2Ug55qE5a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICB1c2VEZXRhaWxWYWx1ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkYXRhU291cmNlIOWPmOWMlueahOaXtuaYr+WQpuS/neeVmeW3sumAieeahOWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgY2FjaGVWYWx1ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuLLmn5MgU2VsZWN0IOWxleeOsOWGheWuueeahOaWueazlVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSDmuLLmn5PoioLngrnnmoRpdGVtXG4gICAgICAgICAqIEByZXR1cm4ge1JlYWN0Tm9kZX0g5bGV546w5YaF5a65XG4gICAgICAgICAqIEBkZWZhdWx0IGl0ZW0gPT4gaXRlbS5sYWJlbCBcXHxcXHwgaXRlbS52YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWVSZW5kZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5riy5p+TIE1lbnVJdGVtIOWGheWuueeahOaWueazlVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSDmuLLmn5PoioLngrnnmoRpdGVtXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hWYWx1ZSDmkJzntKLlhbPplK7lrZfvvIjlpoLmnpzlvIDlkK/mkJzntKLvvIlcbiAgICAgICAgICogQHJldHVybiB7UmVhY3ROb2RlfSBpdGVtIG5vZGVcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1SZW5kZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5YaF5a655Li656m655qE5paH5qGIXG4gICAgICAgICAqL1xuICAgICAgICBub3RGb3VuZENvbnRlbnQ6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWPl+aOp+aQnOe0ouWAvO+8jOS4gOiIrOS4jemcgOimgeiuvue9rlxuICAgICAgICAgKiBAdHlwZSB7W3R5cGVdfVxuICAgICAgICAgKi9cbiAgICAgICAgc2VhcmNoVmFsdWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpgInmi6nlkI7mmK/lkKbnq4vljbPpmpDol4/oj5zljZUgKG1vZGU9bXVsdGlwbGUvdGFnIOaooeW8j+eUn+aViClcbiAgICAgICAgICovXG4gICAgICAgIGhpZGRlblNlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRhZyDliKDpmaTlm57osINcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0g5riy5p+T6IqC54K555qEaXRlbVxuICAgICAgICAgKi9cbiAgICAgICAgb25SZW1vdmU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog54Sm54K55LqL5Lu2XG4gICAgICAgICAqL1xuICAgICAgICBvbkZvY3VzOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWkseWOu+eEpueCueS6i+S7tlxuICAgICAgICAgKi9cbiAgICAgICAgb25CbHVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25LZXlEb3duOiBQcm9wVHlwZXMuZnVuYyxcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgLi4uQmFzZS5kZWZhdWx0UHJvcHMsXG4gICAgICAgIG1vZGU6ICdzaW5nbGUnLFxuICAgICAgICBzaG93U2VhcmNoOiBmYWxzZSxcbiAgICAgICAgY2FjaGVWYWx1ZTogdHJ1ZSxcbiAgICAgICAgb25TZWFyY2g6IG5vb3AsXG4gICAgICAgIG9uU2VhcmNoQ2xlYXI6IG5vb3AsXG4gICAgICAgIGhhc0Fycm93OiB0cnVlLFxuICAgICAgICBvblJlbW92ZTogbm9vcCxcbiAgICAgICAgdmFsdWVSZW5kZXI6IChpdGVtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5sYWJlbCB8fCBpdGVtLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBvbktleURvd246IG5vb3AsXG4gICAgICAgIG9uRm9jdXM6IG5vb3AsXG4gICAgICAgIG9uQmx1cjogbm9vcCxcbiAgICB9O1xuXG4gICAgc3RhdGljIGRpc3BsYXlOYW1lID0gJ1NlbGVjdCc7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgLy8gQGV4dGVuZCBCYXNlIHN0YXRlXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5zdGF0ZSwge1xuICAgICAgICAgICAgLy8gc2VhcmNoIGtleXdvcmRcbiAgICAgICAgICAgIHNlYXJjaFZhbHVlOiAnc2VhcmNoVmFsdWUnIGluIHByb3BzID8gcHJvcHMuc2VhcmNoVmFsdWUgOiAnJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRm9yIGNhY2hlIGNob29zZW4gdmFsdWVcbiAgICAgICAgdGhpcy52YWx1ZURhdGFTb3VyY2UgPSB7XG4gICAgICAgICAgICB2YWx1ZURTOiBbXSwgICAgLy8gW3t2YWx1ZSxsYWJlbH1dXG4gICAgICAgICAgICBtYXBWYWx1ZURTOiB7fSAgLy8ge3ZhbHVlOiB7dmFsdWUsbGFiZWx9fVxuICAgICAgICB9O1xuXG4gICAgICAgIGJpbmRDdHgodGhpcywgW1xuICAgICAgICAgICAgJ2hhbmRsZU1lbnVTZWxlY3QnLFxuICAgICAgICAgICAgJ2hhbmRsZUl0ZW1DbGljaycsXG4gICAgICAgICAgICAnaGFuZGxlU2VhcmNoJyxcbiAgICAgICAgICAgICdoYW5kbGVTZWFyY2hLZXlEb3duJyxcbiAgICAgICAgICAgICdoYW5kbGVTZWxlY3RBbGwnLFxuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgIHRoaXMuZGF0YVN0b3JlLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAga2V5OiB0aGlzLnN0YXRlLnNlYXJjaFZhbHVlLFxuICAgICAgICAgICAgYWRkb25LZXk6IHRoaXMucHJvcHMubW9kZSA9PT0gJ3RhZycgLy8gdGFnIOaooeW8j+aJi+WKqOi+k+WFpeeahOaVsOaNrlxuICAgICAgICB9KTtcblxuICAgICAgICBzdXBlci5jb21wb25lbnRXaWxsTW91bnQoKTtcblxuICAgICAgICAvLyDmoLnmja52YWx1ZeWSjOiuoeeul+WQjueahGRhdGFTb3VyY2XvvIzmm7TmlrB2YWx1ZeWvueW6lOeahOivpue7huaVsOaNrnZhbHVlRGF0YVNvdXJjZVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc3RhdGUudmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlRGF0YVNvdXJjZSA9IGdldFZhbHVlRGF0YVNvdXJjZSh0aGlzLnN0YXRlLnZhbHVlLCB0aGlzLnZhbHVlRGF0YVNvdXJjZS5tYXBWYWx1ZURTLCB0aGlzLmRhdGFTdG9yZS5nZXRNYXBEUygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgICAgdGhpcy5pZTlIYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBpZiAoJ3NlYXJjaFZhbHVlJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVN0b3JlLnNldE9wdGlvbnMoeyBrZXk6IG5leHRQcm9wcy5zZWFyY2hWYWx1ZSB9KTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHNlYXJjaFZhbHVlOiB0eXBlb2YgbmV4dFByb3BzLnNlYXJjaFZhbHVlID09PSAndW5kZWZpbmVkJyA/ICcnIDogbmV4dFByb3BzLnNlYXJjaFZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9wcy5tb2RlICE9PSBuZXh0UHJvcHMubW9kZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhU3RvcmUuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgYWRkb25LZXk6IG5leHRQcm9wcy5tb2RlID09PSAndGFnJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcyk7XG5cbiAgICAgICAgaWYgKCd2YWx1ZScgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgICAgICAvLyB1bmRlciBjb250cm9sbFxuICAgICAgICAgICAgdGhpcy52YWx1ZURhdGFTb3VyY2UgPSBnZXRWYWx1ZURhdGFTb3VyY2UobmV4dFByb3BzLnZhbHVlLCB0aGlzLnZhbHVlRGF0YVNvdXJjZS5tYXBWYWx1ZURTLCB0aGlzLmRhdGFTdG9yZS5nZXRNYXBEUygpKTtcbiAgICAgICAgfSBlbHNlIGlmICgnZGVmYXVsdFZhbHVlJyBpbiBuZXh0UHJvcHMgJiYgKG5leHRQcm9wcy5jaGlsZHJlbiAhPT0gdGhpcy5wcm9wcy5jaGlsZHJlbiB8fCBuZXh0UHJvcHMuZGF0YVNvdXJjZSAhPT0gdGhpcy5wcm9wcy5kYXRhU291cmNlKSkge1xuICAgICAgICAgICAgLy9oYXMgZGVmYXVsdFZhbHVlIGFuZCBkYXRhU291cmNlIGNoYW5nZWRcbiAgICAgICAgICAgIHRoaXMudmFsdWVEYXRhU291cmNlID0gZ2V0VmFsdWVEYXRhU291cmNlKG5leHRQcm9wcy5kZWZhdWx0VmFsdWUsIHRoaXMudmFsdWVEYXRhU291cmNlLm1hcFZhbHVlRFMsIHRoaXMuZGF0YVN0b3JlLmdldE1hcERTKCkpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgICB0aGlzLmllOUhhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5jb21wb25lbnREaWRNb3VudCgpO1xuICAgIH1cblxuICAgIC8vIGllOSDkuIsgdGFibGUtY2VsbCDluIPlsYDkuI3mlK/mjIHlrr3luqbotoXlh7rpmpDol49cbiAgICBpZTlIYWNrKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLnNlbGVjdERPTS5jdXJyZW50U3R5bGUud2lkdGg7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBmaXhXaWR0aDogd2lkdGggIT09ICdhdXRvJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICAvLyDpmo/nnYDovpPlhaXoh6rliqjkvLjlsZVcbiAgICAgICAgaWYgKC90YWd8bXVsdGlwbGUvLnRlc3QocHJvcHMubW9kZSkgJiYgcHJldlN0YXRlLnNlYXJjaFZhbHVlICE9PSB0aGlzLnN0YXRlLnNlYXJjaFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnN5bmNXaWR0aCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1c2VEZXRhaWxWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgeyBwb3B1cENvbnRlbnQsIHVzZURldGFpbFZhbHVlLCBkYXRhU291cmNlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gdXNlRGV0YWlsVmFsdWUgfHwgKHBvcHVwQ29udGVudCAmJiAhZGF0YVNvdXJjZSk7XG4gICAgfVxuXG4gICAgaGFzU2VhcmNoKCkge1xuICAgICAgICBjb25zdCB7IHNob3dTZWFyY2gsIG1vZGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiBzaG93U2VhcmNoIHx8IG1vZGUgPT09ICd0YWcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lbnUuSXRlbSBvblNlbGVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7QXJyYXk8c3RyaW5nPn0ga2V5c1xuICAgICAqL1xuICAgIGhhbmRsZU1lbnVTZWxlY3Qoa2V5cykge1xuICAgICAgICBjb25zdCB7IG1vZGUsIHJlYWRPbmx5LCBkaXNhYmxlZCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBpZiAocmVhZE9ubHkgfHwgZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzU2luZ2xlID0gbW9kZSA9PT0gJ3NpbmdsZSc7XG5cbiAgICAgICAgaWYgKGlzU2luZ2xlKSB7IC8vIOWNlemAiVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2luZ2xlU2VsZWN0KGtleXNbMF0sICdpdGVtQ2xpY2snKTtcbiAgICAgICAgfSBlbHNlIHsgLy8g5q2j5bi45aSa6YCJXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVNdWx0aXBsZVNlbGVjdChrZXlzLCAnaXRlbUNsaWNrJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVJdGVtQ2xpY2soKSB7XG4gICAgICAgIHRoaXMuZm9jdXNJbnB1dCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWNlemAieaooeW8j1xuICAgICAqL1xuICAgIGhhbmRsZVNpbmdsZVNlbGVjdChrZXksIHRyaWdnZXJUeXBlKSB7XG4gICAgICAgIGNvbnN0IHsgY2FjaGVWYWx1ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgLy8gZ2V0IGRhdGEgb25seSBmcm9tIGRhdGFTdG9yZSB3aGlsZSBjYWNoZVZhbHVlPWZhbHNlXG4gICAgICAgIGNvbnN0IGl0ZW1PYmogPSBnZXRWYWx1ZURhdGFTb3VyY2Uoa2V5LCBjYWNoZVZhbHVlID8gdGhpcy52YWx1ZURhdGFTb3VyY2UubWFwVmFsdWVEUyA6IHt9LCB0aGlzLmRhdGFTdG9yZS5nZXRNYXBEUygpKTtcbiAgICAgICAgdGhpcy52YWx1ZURhdGFTb3VyY2UgPSBpdGVtT2JqO1xuXG4gICAgICAgIHRoaXMuc2V0VmlzaWJsZShmYWxzZSwgdHJpZ2dlclR5cGUpO1xuXG4gICAgICAgIGlmICh0aGlzLnVzZURldGFpbFZhbHVlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUNoYW5nZShpdGVtT2JqLnZhbHVlRFMsIHRyaWdnZXJUeXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hhbmdlKGl0ZW1PYmoudmFsdWUsIHRyaWdnZXJUeXBlLCBpdGVtT2JqLnZhbHVlRFMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBoaWdobGlnaHRLZXk6IGtleVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyDmuIXnqbrmkJzntKJcbiAgICAgICAgaWYgKCEoJ3NlYXJjaFZhbHVlJyBpbiB0aGlzLnByb3BzKSAmJiB0aGlzLnN0YXRlLnNlYXJjaFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNlYXJjaENsZWFyKHRyaWdnZXJUeXBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWkmumAieaooeW8jyBtdWx0aXBsZS90YWdcbiAgICAgKi9cbiAgICBoYW5kbGVNdWx0aXBsZVNlbGVjdChrZXlzLCB0cmlnZ2VyVHlwZSkge1xuICAgICAgICBjb25zdCBpdGVtT2JqID0gZ2V0VmFsdWVEYXRhU291cmNlKGtleXMsIHRoaXMudmFsdWVEYXRhU291cmNlLm1hcFZhbHVlRFMsIHRoaXMuZGF0YVN0b3JlLmdldE1hcERTKCkpO1xuXG4gICAgICAgIGNvbnN0IHsgY2FjaGVWYWx1ZSwgbW9kZSwgaGlkZGVuU2VsZWN0ZWQgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgLy8g6Z2e5Y+X5o6n5pu05paw57yT5a2YbWFwXG4gICAgICAgIGlmIChjYWNoZVZhbHVlIHx8IG1vZGUgPT09ICd0YWcnKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlRGF0YVNvdXJjZSA9IGl0ZW1PYmo7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGlkZGVuU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmlzaWJsZShmYWxzZSwgdHJpZ2dlclR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudXNlRGV0YWlsVmFsdWUoKSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UoaXRlbU9iai52YWx1ZURTLCB0cmlnZ2VyVHlwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZShpdGVtT2JqLnZhbHVlLCB0cmlnZ2VyVHlwZSwgaXRlbU9iai52YWx1ZURTKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOa4heepuuaQnOe0olxuICAgICAgICBpZiAoISgnc2VhcmNoVmFsdWUnIGluIHRoaXMucHJvcHMpICYmIHRoaXMuc3RhdGUuc2VhcmNoVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIOWboOS4uiBTZWFyY2hWYWx1ZSDooqsgY2xlYXIg5ZCO5Lya6YeN5paw5riy5p+TIE1lbnXvvIzmiYDku6XlnKggT3ZlcmxheSDmo4DmtYsgc2FmZU5vZGUg55qE5pe25YCZIGUudGFyZ2V0IOWPr+iDveS8muaJvuS4jeWIsOWvvOiHtOW8ueeql+WFs+mXrVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTZWFyY2hDbGVhcih0cmlnZ2VyVHlwZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVNlYXJjaFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNlYXJjaFZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBmaWx0ZXJMb2NhbCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBpZiAoZmlsdGVyTG9jYWwpIHtcbiAgICAgICAgICAgIGlmICghKCdzZWFyY2hWYWx1ZScgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoVmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhU291cmNlOiB0aGlzLmRhdGFTdG9yZS51cGRhdGVCeUtleSh2YWx1ZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZpcnN0SGlnaHRMaWdodEtleUZvck1lbnUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKCdzZWFyY2hWYWx1ZScgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHNlYXJjaFZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHNlYXJjaCBpbnB1dCBjaGFuZ2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIGNoYW5nZSBFdmVudFxuICAgICAqL1xuICAgIGhhbmRsZVNlYXJjaCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmhhbmRsZVNlYXJjaFZhbHVlKHZhbHVlKTtcblxuICAgICAgICAvLyBpbnB1dGluZyBzaG91bGQgdHJpZ2dlciBwb3B1cCBvcGVuXG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS52aXNpYmxlICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZpc2libGUodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3BzLm9uU2VhcmNoKHZhbHVlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVTZWFyY2hDbGVhcih0cmlnZ2VyVHlwZSkge1xuICAgICAgICB0aGlzLmhhbmRsZVNlYXJjaFZhbHVlKCcnKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vblNlYXJjaENsZWFyKHRyaWdnZXJUeXBlKTtcbiAgICB9XG5cbiAgICAvLyDmkJzntKLmoYYga2V5RG93biDkuovku7ZcbiAgICBoYW5kbGVTZWFyY2hLZXlEb3duKGUpIHtcbiAgICAgICAgY29uc3QgeyBwb3B1cENvbnRlbnQsIG9uS2V5RG93biwgc2hvd1NlYXJjaCwgbW9kZSwgaGFzQ2xlYXIsIG9uVG9nZ2xlSGlnaGxpZ2h0SXRlbSB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBpZiAocG9wdXBDb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gb25LZXlEb3duKGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJveHkgPSAnc2VhcmNoJztcbiAgICAgICAgY29uc3QgaGFzU2VhcmNoID0gdGhpcy5oYXNTZWFyY2goKTtcblxuICAgICAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgICAgICAgY2FzZSBLRVlDT0RFLlVQOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBvblRvZ2dsZUhpZ2hsaWdodEl0ZW0odGhpcy50b2dnbGVIaWdobGlnaHRJdGVtKC0xLCBlKSwgJ3VwJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtFWUNPREUuRE9XTjpcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgb25Ub2dnbGVIaWdobGlnaHRJdGVtKHRoaXMudG9nZ2xlSGlnaGxpZ2h0SXRlbSgxLCBlKSwgJ2Rvd24nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS0VZQ09ERS5FTlRFUjpcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaG9vc2VIaWdobGlnaHRJdGVtKHByb3h5LCBlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS0VZQ09ERS5FU0M6XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUudmlzaWJsZSAmJiB0aGlzLnNldFZpc2libGUoZmFsc2UsICdrZXlEb3duJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtFWUNPREUuU1BBQ0U6XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAhaGFzU2VhcmNoICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS0VZQ09ERS5CQUNLU1BBQ0U6XG4gICAgICAgICAgICAgICAgaWYgKChtb2RlID09PSAnbXVsdGlwbGUnICYmIHNob3dTZWFyY2gpIHx8IG1vZGUgPT09ICd0YWcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWcqOWkmumAieW5tuS4lOacieaQnOe0oueahOaDheWGteS4i++8jOWIoOmZpOacgOWQjuS4gOS4qiB0YWdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEZWxldGVUYWcoZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnc2luZ2xlJyAmJiBoYXNDbGVhciAmJiAhdGhpcy5zdGF0ZS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWNlemAieOAgemdnuWxleW8gOOAgeW5tuS4lOWPr+a4hemZpOeahOaDheWGte+8jOWFgeiuuOaMieWIoOmZpOmUrua4hemZpFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNsZWFyKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBvbktleURvd24oZSk7XG4gICAgfVxuXG4gICAgLy8g5Zue6L2mIOmAieaLqemrmOS6rueahCBpdGVtXG4gICAgY2hvb3NlSGlnaGxpZ2h0SXRlbShwcm94eSwgZSkge1xuICAgICAgICBjb25zdCBwcmV2VmlzaWJsZSA9IHRoaXMuc3RhdGUudmlzaWJsZTtcbiAgICAgICAgaWYgKCFwcmV2VmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBoaWdobGlnaHRLZXkgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgLy8g5rKh5pyJ6auY5Lqu6YCJ6aG5IOaIluiAhSDmsqHmnInlj6/pgInoj5zljZVcbiAgICAgICAgaWYgKGhpZ2hsaWdodEtleSA9PT0gbnVsbCB8fCAhdGhpcy5kYXRhU3RvcmUuZ2V0TWVudURTKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IG1vZGUgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKG1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNpbmdsZVNlbGVjdChoaWdobGlnaHRLZXksICdlbnRlcicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlIHx8IFtdO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IHZhbHVlLm1hcCh2ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVUb1NlbGVjdEtleSh2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBrZXlzLm1hcCh2ID0+IGAke3Z9YCkuaW5kZXhPZihoaWdobGlnaHRLZXkpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHsgLy8g5Y+N6YCJXG4gICAgICAgICAgICAgICAga2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8g5Yu+6YCJXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGhpZ2hsaWdodEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU11bHRpcGxlU2VsZWN0KGtleXMsICdlbnRlcicpO1xuICAgICAgICAgICAgLy8g6Zi75q2i5LqL5Lu25YaS5rOh5Yiw5pyA5aSW5bGC77yM6K6pUG9wdXAg55uR5ZCs5Yiw6Kem5Y+R5by55bGC5YWz6ZetXG4gICAgICAgICAgICBlICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgVGFnIGNsb3NlIGV2ZW50XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBpdGVtXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gZmFsc2UgIHJldHVybiBmYWxzZSB0byBwcmV2ZW50IGF1dG8gY2xvc2VcbiAgICAgKiAtLS0tXG4gICAgICogSXQgTVVTVCBiZSBtdWx0aXBsZSBtb2RlLCBuZWVkbid0IGFkZGl0aW9uYWwganVkZ2VtZW50XG4gICAgICovXG4gICAgaGFuZGxlVGFnQ2xvc2UoaXRlbSkge1xuXG4gICAgICAgIGlmICh0aGlzLnVzZURldGFpbFZhbHVlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZS5maWx0ZXIodiA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWUgIT09IHYudmFsdWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UodmFsdWUsICd0YWcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgY3VycmVudCBpdGVtLCBhbmQgdGhlbiBjYWxsIGhhbmRsZU1lbnVTZWxlY3RcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZS5maWx0ZXIodiA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWUgIT09IHY7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5oYW5kbGVNdWx0aXBsZVNlbGVjdCh2YWx1ZSwgJ3RhZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vblJlbW92ZShpdGVtKTtcblxuICAgICAgICAvLyBwcmV2ZW50IHRhZyBjbG9zZVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIEJBQ0tTUEFDRSBrZXkgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIGtleURvd24gZXZlbnRcbiAgICAgKiAtLS1cbiAgICAgKiBJdCBNVVNUIGJlIG11bHRpcGxlIG1vZGVcbiAgICAgKi9cbiAgICBoYW5kbGVEZWxldGVUYWcoZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICAgIGNvbnN0IHNlYXJjaFZhbHVlID0gdGhpcy5zdGF0ZS5zZWFyY2hWYWx1ZTtcblxuICAgICAgICBpZiAoc2VhcmNoVmFsdWUgfHwgIXZhbHVlIHx8ICF2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBjb25zdCBuZXh0VmFsdWVzID0gdmFsdWUuc2xpY2UoMCwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIC8vIOaJi+WKqOiwg+eUqCBoYW5kbGVNZW51U2VsZWN0IOaXtuebtOaOpeS8oOWFpeWOn+eUn+eahCB2YWx1Ze+8jOWPr+S7peWHj+WwkSB0b1N0cmluZyDnmoTmk43kvZxcblxuICAgICAgICBpZiAodGhpcy51c2VEZXRhaWxWYWx1ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZShuZXh0VmFsdWVzLCAndGFnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU11bHRpcGxlU2VsZWN0KG5leHRWYWx1ZXMsICd0YWcnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBTZWxlY3RBbGwgc3BhbiBjbGljayBldmVudFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgY2xpY2sgZXZlbnRcbiAgICAgKi9cbiAgICBoYW5kbGVTZWxlY3RBbGwoZSkge1xuICAgICAgICBlICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgbmV4dFZhbHVlcyA9IHRoaXMuZGF0YVN0b3JlLmdldEVuYWJsZURTKCkubWFwKGl0ZW0gPT4gaXRlbS52YWx1ZSk7XG4gICAgICAgIC8vIOebtOaOpeS8oCB2YWx1ZXPvvIzlh4/lsJEgdG9TdHJpbmcg5pON5L2cXG4gICAgICAgIHRoaXMuaGFuZGxlTXVsdGlwbGVTZWxlY3QobmV4dFZhbHVlcywgJ3NlbGVjdEFsbCcpO1xuICAgIH1cblxuICAgIGhhbmRsZVZpc2libGVDaGFuZ2UodmlzaWJsZSwgdHlwZSkge1xuICAgICAgICB0aGlzLnNldFZpc2libGUodmlzaWJsZSwgdHlwZSk7XG4gICAgfVxuXG4gICAgYWZ0ZXJDbG9zZSgpIHtcbiAgICAgICAgLy8g5YWz6Zet55qE5pe25YCZ5riF56m65pCc57Si5YC8XG4gICAgICAgIGlmICh0aGlzLmhhc1NlYXJjaCgpKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNlYXJjaENsZWFyKCdwb3B1cENsb3NlJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlpoLmnpznlKjmiLfmmK/oh6rlrprkuYnnmoTlvLnlsYLvvIzliJnnm7TmjqXku6UgdmFsdWUg5Li65YeG77yM5LiN5YaN5qCh6aqMIGRhdGFTb3VyY2VcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICAgKi9cbiAgICByZW5kZXJWYWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IHsgbW9kZSwgc2l6ZSwgdmFsdWVSZW5kZXIsIGZpbGxQcm9wcywgZGlzYWJsZWQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG5cbiAgICAgICAgaWYgKGlzTnVsbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGRldGFpbCB2YWx1ZVxuICAgICAgICBpZiAoIXRoaXMudXNlRGV0YWlsVmFsdWUoKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlRGF0YVNvdXJjZS52YWx1ZURTO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJldHZhbHVlID0gZmlsbFByb3BzID8gdmFsdWVbZmlsbFByb3BzXSA6IHZhbHVlUmVuZGVyKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcmV0dmFsdWUgPT09ICdudW1iZXInID8gcmV0dmFsdWUudG9TdHJpbmcoKSA6IHJldHZhbHVlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKHYgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbE5vZGUgPSBmaWxsUHJvcHMgPyB2W2ZpbGxQcm9wc10gOiB2YWx1ZVJlbmRlcih2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICA8VGFnIGtleT17di52YWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZCB8fCB2LmRpc2FibGVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInByaW1hcnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZT17c2l6ZSA9PT0gJ2xhcmdlJyA/ICdtZWRpdW0nIDogJ3NtYWxsJ31cbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbj17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXt0aGlzLmhhbmRsZVRhZ0Nsb3NlLmJpbmQodGhpcywgdil9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zYWJsZT57bGFiZWxOb2RlfTwvVGFnPlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAxLiBmaXggZmxhc2ggd2hpbGUgY2xpY2sgPGxhYmVsLz5cbiAgICAgKiAyLiBmaXggb25CbHVyIHdoaWxlIGhhcyBjbGVhclxuICAgICAqL1xuICAgIGhhbmRsZVdyYXBDbGljayA9IChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5mb2N1c0lucHV0KCk7XG4gICAgfVxuXG4gICAgaGFuZGxlQXJyb3dDbGljayA9IChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5mb2N1c0lucHV0KCk7XG4gICAgICAgIHRoaXMuc2V0VmlzaWJsZSghdGhpcy5zdGF0ZS52aXNpYmxlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDbGVhciA9IGUgPT4ge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIHRoaXMuaGFuZGxlQ2hhbmdlKHVuZGVmaW5lZCwgJ2NsZWFyJyk7XG4gICAgfVxuXG4gICAgaGFzQ2xlYXIoKSB7XG4gICAgICAgIGNvbnN0IHsgaGFzQ2xlYXIsIHJlYWRPbmx5LCBkaXNhYmxlZCwgbW9kZSwgc2hvd1NlYXJjaCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgdmlzaWJsZSB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiBoYXNDbGVhciAmJiAhcmVhZE9ubHkgJiYgIWRpc2FibGVkICYmIG1vZGUgPT09ICdzaW5nbGUnICYmICEoc2hvd1NlYXJjaCAmJiB2aXNpYmxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZW5kZXIgYXJyb3dcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2xpY2tIYW5kbGVyXVxuICAgICAqL1xuICAgIHJlbmRlckV4dHJhTm9kZSgpIHtcbiAgICAgICAgY29uc3QgeyBoYXNBcnJvdywgaGFzQ2xlYXIsIHByZWZpeCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBjb25zdCByZXQgPSBbXTtcblxuICAgICAgICBpZiAoaGFzQXJyb3cpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKDxzcGFuIGtleT1cImFycm93XCIgb25DbGljaz17dGhpcy5oYW5kbGVBcnJvd0NsaWNrfSBjbGFzc05hbWU9e2Ake3ByZWZpeH1zZWxlY3QtYXJyb3dgfT48SWNvblxuICAgICAgICAgICAgICAgIHR5cGU9XCJhcnJvdy1kb3duXCIgLz48L3NwYW4+KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOS4jeiDveS9v+eUqCB0aGlzLmhhc0NsZWFyKCkg5pa55rOV5Yik5pat77yM6KaB5L+d6K+BIGNsZWFyIOaMiemSriBkb20g57uT5p6E5LiA55u05a2Y5Zyo77yM6Ziy5q2i5YW25LiN6IO95oiQ5Li65by55bGC55qE5a6J5YWo6IqC54K577yM5a+86Ie05by55bGC5rKh5pyJ5b+F6KaB55qE5pi+56S65oiW6ZqQ6JePXG4gICAgICAgIGlmIChoYXNDbGVhcikge1xuICAgICAgICAgICAgcmV0LnB1c2goPHNwYW4ga2V5PVwiY2xlYXJcIiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsZWFyfSBjbGFzc05hbWU9e2Ake3ByZWZpeH1zZWxlY3QtY2xlYXJgfT48SWNvblxuICAgICAgICAgICAgICAgIHR5cGU9XCJkZWxldGUtZmlsbGluZ1wiIC8+PC9zcGFuPik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOmAieaLqeWZqFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgICAqL1xuICAgIHJlbmRlclNlbGVjdCgpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHNob3dTZWFyY2gsIHBsYWNlaG9sZGVyLCBtb2RlLCBzaXplLCBjbGFzc05hbWUsIHN0eWxlLCByZWFkT25seSwgZGlzYWJsZWQsIGhhc0JvcmRlciwgbGFiZWwsIGxvY2FsZSwgc3RhdGUsIG9uQmx1ciwgb25Gb2N1cywgcnRsIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBvdGhlcnMgPSBvYmoucGlja090aGVycyhTZWxlY3QucHJvcFR5cGVzLCB0aGlzLnByb3BzKTtcbiAgICAgICAgY29uc3Qgb3RoZXJzRGF0YSA9IG9iai5waWNrQXR0cnNXaXRoKG90aGVycywgJ2RhdGEtJyk7XG5cbiAgICAgICAgY29uc3QgdmlzaWJsZSA9IHRoaXMuc3RhdGUudmlzaWJsZTtcbiAgICAgICAgY29uc3QgaXNTaW5nbGUgPSBtb2RlID09PSAnc2luZ2xlJztcbiAgICAgICAgY29uc3QgaGFzU2VhcmNoID0gdGhpcy5oYXNTZWFyY2goKTtcbiAgICAgICAgY29uc3QgdmFsdWVOb2RlcyA9IHRoaXMucmVuZGVyVmFsdWVzKCk7XG5cbiAgICAgICAgLy8gY29tcGF0aWJsZSB3aXRoIHNlbGVjdFBsYWNlSG9sZGVyLiBUT0RPOiByZW1vdmVkIGluIDIuMCB2ZXJzaW9uXG4gICAgICAgIGxldCBfcGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlciB8fCBsb2NhbGUuc2VsZWN0UGxhY2Vob2xkZXIgfHwgbG9jYWxlLnNlbGVjdFBsYWNlSG9sZGVyO1xuICAgICAgICBpZiAodmFsdWVOb2RlcyAmJiB2YWx1ZU5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgX3BsYWNlaG9sZGVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOW8ueeql+WxleW8gOaXtuWwhuW9k+WJjeeahOWAvOS9nOS4uiBwbGFjZWhvbGRlcu+8jOi/meS4quWKn+iDveeahOWJjeaPkOaYryB2YWx1ZU5vZGUg5b+F6aG75piv5LiA5Liq5a2X56ym5LiyXG4gICAgICAgIGlmIChzaG93U2VhcmNoICYmIHZpc2libGUgJiYgaXNTaW5nbGUgJiYgdHlwZW9mIHZhbHVlTm9kZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBfcGxhY2Vob2xkZXIgPSB2YWx1ZU5vZGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5LiL5ouJ566t5aS0XG4gICAgICAgIGNvbnN0IGV4dHJhID0gdGhpcy5yZW5kZXJFeHRyYU5vZGUoKTtcblxuICAgICAgICBjb25zdCB0cmlnZ2VyQ2xhenogPSBjbGFzc05hbWVzKFtcbiAgICAgICAgICAgIGAke3ByZWZpeH1zZWxlY3RgLFxuICAgICAgICAgICAgYCR7cHJlZml4fXNlbGVjdC10cmlnZ2VyYCxcbiAgICAgICAgICAgIGAke3ByZWZpeH1zZWxlY3QtJHttb2RlfWAsXG4gICAgICAgICAgICBgJHtwcmVmaXh9JHtzaXplfWAsXG4gICAgICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIF0sIHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9YWN0aXZlYF06IHZpc2libGUsICAgICAgIC8vIOeUqOS6juiuvue9riBzZWFyY2hJbnB1dCDmoLflvI9cbiAgICAgICAgICAgIFtgJHtwcmVmaXh9aW5hY3RpdmVgXTogIXZpc2libGUsICAgIC8vIOeUqOS6juiuvue9riBzZWFyY2hJbnB1dCDmoLflvI9cbiAgICAgICAgICAgIFtgJHtwcmVmaXh9bm8tc2VhcmNoYF06ICFoYXNTZWFyY2gsIC8vIOeUqOS6juWIpOaWreaYr+WQpuWwhiBzZWFyY2hJbnB1dCDorr7nva7kuLogMXB4ICsg6YCP5piOXG4gICAgICAgICAgICBbYCR7cHJlZml4fWhhcy1zZWFyY2hgXTogaGFzU2VhcmNoLCAvLyDnlKjkuo7ljZXpgInml7blsZXlvIDlkI7liKTmlq3mmK/lkKbpmpDol4/lgLxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9c2VsZWN0LWluLWllYF06IGlzSUU5LFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1zZWxlY3QtaW4taWUtZml4d2lkdGhgXTogdGhpcy5zdGF0ZS5maXhXaWR0aCxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9aGFzLWNsZWFyYF06IHRoaXMuaGFzQ2xlYXIoKVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB2YWx1ZXRleHQgPSB0aGlzLnZhbHVlRGF0YVNvdXJjZS52YWx1ZURTID8gdGhpcy52YWx1ZURhdGFTb3VyY2UudmFsdWVEUy5sYWJlbCA6ICcnO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8c3BhbiB7Li4ub3RoZXJzRGF0YX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3RyaWdnZXJDbGF6en1cbiAgICAgICAgICAgICAgICBzdHlsZT17c3R5bGV9XG4gICAgICAgICAgICAgICAgZGlyPXtydGwgPyAncnRsJyA6IHVuZGVmaW5lZH1cbiAgICAgICAgICAgICAgICByZWY9e3RoaXMuc2F2ZVNlbGVjdFJlZn1cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZVdyYXBDbGlja31cbiAgICAgICAgICAgICAgICBvbk1vdXNlRG93bj17dGhpcy5oYW5kbGVXcmFwQ2xpY2t9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgICAgIGFyaWEtdmFsdWV0ZXh0PXt2YWx1ZXRleHR9XG4gICAgICAgICAgICAgICAgICAgIHsuLi5vYmoucGlja090aGVycyhvdGhlcnNEYXRhLCBvdGhlcnMpfVxuICAgICAgICAgICAgICAgICAgICByb2xlPVwiY29tYm9ib3hcIlxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleD17MH1cbiAgICAgICAgICAgICAgICAgICAgYXJpYS1leHBhbmRlZD17dGhpcy5zdGF0ZS52aXNpYmxlfVxuICAgICAgICAgICAgICAgICAgICBhcmlhLWRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGU9e3N0YXRlfVxuICAgICAgICAgICAgICAgICAgICBsYWJlbD17bGFiZWx9XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhPXtleHRyYX1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3RoaXMuc3RhdGUuc2VhcmNoVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIHNpemU9e3NpemV9XG4gICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5PXshdGhpcy5oYXNTZWFyY2goKSB8fCByZWFkT25seX1cbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj17X3BsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgICAgICBoYXNCb3JkZXI9e2hhc0JvcmRlcn1cbiAgICAgICAgICAgICAgICAgICAgaGFzQ2xlYXI9e2ZhbHNlfVxuICAgICAgICAgICAgICAgICAgICBodG1sU2l6ZT1cIjFcIlxuICAgICAgICAgICAgICAgICAgICBpbnB1dFJlbmRlcj17KGlucHV0RWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlclNlYXJjaElucHV0KHZhbHVlTm9kZXMsIF9wbGFjZWhvbGRlciwgaW5wdXRFbCk7XG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmhhbmRsZVNlYXJjaH1cbiAgICAgICAgICAgICAgICAgICAgb25LZXlEb3duPXt0aGlzLmhhbmRsZVNlYXJjaEtleURvd259XG4gICAgICAgICAgICAgICAgICAgIG9uRm9jdXM9e29uRm9jdXN9XG4gICAgICAgICAgICAgICAgICAgIG9uQmx1cj17b25CbHVyfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake3ByZWZpeH1zZWxlY3QtaW5uZXJgfVxuICAgICAgICAgICAgICAgICAgICByZWY9e3RoaXMuc2F2ZUlucHV0UmVmfSAvPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJlbmRlclNlYXJjaElucHV0KHZhbHVlTm9kZXMsIHBsYWNlaG9sZGVyLCBpbnB1dEVsKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBtb2RlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBpc1NpbmdsZSA9IG1vZGUgPT09ICdzaW5nbGUnO1xuXG4gICAgICAgIGNvbnN0IG1pcnJvclRleHQgPSB0aGlzLnN0YXRlLnNlYXJjaFZhbHVlO1xuXG4gICAgICAgIGNvbnN0IGNscyA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1zZWxlY3QtdmFsdWVzYF06IHRydWUsXG4gICAgICAgICAgICBbYCR7cHJlZml4fWlucHV0LXRleHQtZmllbGRgXTogdHJ1ZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuICg8c3BhbiBjbGFzc05hbWU9e2Nsc30+XG4gICAgICAgICAgICB7aXNTaW5nbGUgJiYgdmFsdWVOb2RlcyA/IDxlbT57dmFsdWVOb2Rlc308L2VtPiA6IHZhbHVlTm9kZXN9XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Ake3ByZWZpeH1zZWxlY3QtdHJpZ2dlci1zZWFyY2hgfT5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0RWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgPHNwYW4gYXJpYS1oaWRkZW4gPnttaXJyb3JUZXh0IHx8IHBsYWNlaG9sZGVyfSZuYnNwOzwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9zcGFuPik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5riy5p+T5by55bGC55qEIGhlYWRlciDlhoXlrrlcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICAgKi9cbiAgICByZW5kZXJNZW51SGVhZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgaGFzU2VsZWN0QWxsLCBtb2RlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGNvbnN0IHNvdXJjZUNvdW50ID0gdGhpcy5kYXRhU3RvcmUuZ2V0RW5hYmxlRFMoKS5sZW5ndGg7XG4gICAgICAgIC8vIOWkmumAieaooeW8j+S4i+aJjeacieWFqOmAiVxuICAgICAgICBpZiAoIWhhc1NlbGVjdEFsbCB8fCBtb2RlID09PSAnc2luZ2xlJyB8fCAhc291cmNlQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGV4dCA9IHR5cGVvZiBoYXNTZWxlY3RBbGwgPT09ICdib29sZWFuJyA/ICdTZWxlY3QgQWxsJyA6IGhhc1NlbGVjdEFsbDtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBrZXk9XCJhbGxcIiBvbkNsaWNrPXt0aGlzLmhhbmRsZVNlbGVjdEFsbH0gY2xhc3NOYW1lPXtgJHtwcmVmaXh9c2VsZWN0LWFsbGB9PlxuICAgICAgICAgICAgICAgIDxzcGFuID57dGV4dH08L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgbW9kZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7IC4uLnRoaXMucHJvcHMgfTtcblxuICAgICAgICAvLyDmkJzntKLnmoTml7blgJnkuI3lhYHorrjlm57ovabop6blj5HlhbPpl61cbiAgICAgICAgaWYgKHRoaXMuaGFzU2VhcmNoKCkpIHtcbiAgICAgICAgICAgIHByb3BzLmNhbkNsb3NlQnlUcmlnZ2VyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICBwcm9wcy5jYWNoZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnJlbmRlcihwcm9wcyk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2VsZWN0L3NlbGVjdC5qc3giLCJpbXBvcnQgQ29uZmlnUHJvdmlkZXIgZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCB7IGxvZyB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IFRhZyBmcm9tICcuL3RhZyc7XG5pbXBvcnQgR3JvdXAgZnJvbSAnLi90YWctZ3JvdXAnO1xuaW1wb3J0IFNlbGVjdGFibGUgZnJvbSAnLi9zZWxlY3RhYmxlJztcbmltcG9ydCBDbG9zYWJsZSBmcm9tICcuL2Nsb3NlYWJsZSc7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBDb25maWdUYWcgPSBDb25maWdQcm92aWRlci5jb25maWcoVGFnLCB7XG4gICAgdHJhbnNmcm9tOiAocHJvcHMsIGRlcHJlY2F0ZWQpID0+IHtcbiAgICAgICAgY29uc3Qge3NoYXBlLCB0eXBlfSA9IHByb3BzO1xuICAgICAgICBpZiAoc2hhcGUgPT09ICdzZWxlY3RhYmxlJykge1xuICAgICAgICAgICAgZGVwcmVjYXRlZCgnc2hhcGU9c2VsZWN0YWJsZScsICdUYWcuU2VsZWN0YWJsZScsICdUYWcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZSA9PT0gJ2RlbGV0YWJsZScpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZWQoJ3NoYXBlPWRlbGV0YWJsZScsICdUYWcuQ2xvc2VhYmxlJywgJ1RhZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlID09PSAnbGluaycpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZWQoJ3NoYXBlPWxpbmsnLCAnPFRhZz48YSBocmVmPVwieFwiPng8L2E+PC9UYWc+JywgJ1RhZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlID09PSAncmVhZG9ubHknIHx8IHNoYXBlID09PSAnaW50ZXJhY3RpdmUnKSB7XG4gICAgICAgICAgICBsb2cud2FybmluZyhgV2FybmluZzogWyBzaGFwZT0ke3NoYXBlfSBdIGlzIGRlcHJlY2F0ZWQgYXQgWyBUYWcgXWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdzZWNvbmRhcnknKSB7XG4gICAgICAgICAgICBsb2cud2FybmluZygnV2FybmluZzogWyB0eXBlPXNlY29uZGFyeSBdIGlzIGRlcHJlY2F0ZWQgYXQgWyBUYWcgXScpO1xuICAgICAgICB9XG5cbiAgICAgICAgWydjb3VudCcsICdtYXJrZWQnLCAndmFsdWUnLCAnb25DaGFuZ2UnXS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm5pbmcoYFdhcm5pbmc6IFsgJHtrZXl9IF0gaXMgZGVwcmVjYXRlZCBhdCBbIFRhZyBdYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICgnc2VsZWN0ZWQnICBpbiBwcm9wcyB8fCAnZGVmYXVsdFNlbGVjdGVkJyBpbiBwcm9wcykge1xuICAgICAgICAgICAgbG9nLndhcm5pbmcoJ1dhcm5pbmc6IFsgc2VsZWN0ZWR8ZGVmYXVsdFNlbGVjdGVkICBdIGlzIGRlcHJlY2F0ZWQgYXQgWyBUYWcgXSwgdXNlIFsgY2hlY2tlZHxkZWZhdWx0Q2hlY2tlZCBdIGF0IFsgVGFnLlNlbGVjdGFibGUgXSBpbnN0ZWFkIG9mIGl0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2Nsb3NlZCcgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGxvZy53YXJuaW5nKCdXYXJuaW5nOiBbIGNsb3NlZCAgXSBpcyBkZXByZWNhdGVkIGF0IFsgVGFnIF0sIHVzZSBbIG9uQ2xvc2UgXSBhdCBbIFRhZy5DbG9zZWFibGUgXSBpbnN0ZWFkIG9mIGl0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ29uU2VsZWN0JyBpbiBwcm9wcykge1xuICAgICAgICAgICAgZGVwcmVjYXRlZCgnb25TZWxlY3QnLCAnPFRhZy5TZWxlY3RhYmxlIG9uQ2hhbmdlLz4nLCAnVGFnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2FmdGVyQ2xvc2UnIGluIHByb3BzKSB7XG4gICAgICAgICAgICBsb2cud2FybmluZygnV2FybmluZzogWyBhZnRlckNsb3NlICBdIGlzIGRlcHJlY2F0ZWQgYXQgWyBUYWcgXSwgdXNlIFsgYWZ0ZXJDbG9zZSBdIGF0IFsgVGFnLkNsb3NlYWJsZSBdIGluc3RlYWQgb2YgaXQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9LFxufSk7XG5cblxuQ29uZmlnVGFnLkdyb3VwID0gQ29uZmlnUHJvdmlkZXIuY29uZmlnKEdyb3VwKTtcblxuQ29uZmlnVGFnLlNlbGVjdGFibGUgPSBDb25maWdQcm92aWRlci5jb25maWcoU2VsZWN0YWJsZSk7XG5cbi8vIOacieeahOWcsOaWueWPq+WBmiBDbG9zZWFibGUg5pyJ55qE5Zyw5pa555SoQ2xvc2VhYmxlLCDkuLrkuobkv53mjIHlhbzlrrkg5paH5qGj57G75Ye6546wIENsb3NlYWJsZSwgQ2xvc2VhYmxl5Y+v5Lul57un57ut55SoXG5Db25maWdUYWcuQ2xvc2FibGUgPSBDb25maWdQcm92aWRlci5jb25maWcoQ2xvc2FibGUpO1xuQ29uZmlnVGFnLkNsb3NlYWJsZSA9IENvbmZpZ1RhZy5DbG9zYWJsZTtcblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlnVGFnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhZy9pbmRleC5qc3giLCJpbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcblxuY2xhc3MgR3JvdXAgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHByZWZpeDogJ25leHQtJyxcbiAgICAgICAgcnRsOiBmYWxzZSxcbiAgICB9O1xuXG4gICAgcmVuZGVyKCkge1xuXG4gICAgICAgIGNvbnN0IHtjbGFzc05hbWUsIHByZWZpeCwgY2hpbGRyZW4sIHJ0bCwgLi4ub3RoZXJzfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGNsYXp6ID0gY2xhc3NOYW1lcyhgJHtwcmVmaXggfHwgJ25leHQtJ310YWctZ3JvdXBgLCBjbGFzc05hbWUpO1xuXG4gICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT17Y2xhenp9IGRpcj17cnRsID8gJ3J0bCcgOiB1bmRlZmluZWR9IHsuLi5vdGhlcnN9PntjaGlsZHJlbn08L2Rpdj47XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBHcm91cDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWcvdGFnLWdyb3VwLmpzeCIsImltcG9ydCBSZWFjdCwge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHtvYmosIGZ1bmN9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IFRhZyBmcm9tICcuL3RhZyc7XG5cbmNvbnN0IHtub29wLCBiaW5kQ3R4fSA9IGZ1bmM7XG5cbi8qKlxuICogVGFnLlNlbGVjdGFibGVcbiAqL1xuY2xhc3MgU2VsZWN0YWJsZSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOagh+etvuaYr+WQpuiiq+mAieS4re+8jOWPl+aOp+eUqOazlVxuICAgICAgICAgKiB0YWcgY2hlY2tlZCBvciBub3QsIGEgY29udHJvbGxlZCB3YXlcbiAgICAgICAgICovXG4gICAgICAgIGNoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5qCH562+5piv5ZCm6buY6K6k6KKr6YCJ5Lit77yM6Z2e5Y+X5o6n55So5rOVXG4gICAgICAgICAqIHRhZyBjaGVja2VkIG9yIG5vdCBieSBkZWZhdWx0LCBhIHVuY29udHJvbGxlZCB3YXlcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRDaGVja2VkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmAieS4reeKtuaAgeWPmOWMluaXtuinpuWPkeeahOS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNoZWNrZWQg5piv5ZCm6YCJ5LitXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRG9tIOS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5qCH562+5piv5ZCm6KKr56aB55SoXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLmFueSxcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgb25DaGFuZ2U6IG5vb3BcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjaGVja2VkOiAnY2hlY2tlZCcgaW4gcHJvcHMgPyBwcm9wcy5jaGVja2VkIDogKHByb3BzLmRlZmF1bHRDaGVja2VkIHx8IGZhbHNlKVxuICAgICAgICB9O1xuXG4gICAgICAgIGJpbmRDdHgodGhpcywgW1xuICAgICAgICAgICAgJ2hhbmRsZUNsaWNrJ1xuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDbGljayhlKSB7XG4gICAgICAgIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBJRTkg5LiN5pSv5oyBIHBvaW50ZXItZXZlbnRz77yM6L+Y5piv5Y+v6IO95Lya6Kem5Y+RIGNsaWNrIOS6i+S7tlxuICAgICAgICBpZiAodGhpcy5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZShwcmV2U3RhdGUgPT4gKHtcbiAgICAgICAgICAgIGNoZWNrZWQ6ICFwcmV2U3RhdGUuY2hlY2tlZFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSghdGhpcy5wcm9wcy5jaGVja2VkLCBlKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGF0dHJGaWx0ZXJUYXJnZXQgPSBbXG4gICAgICAgICAgICAnY2hlY2tlZCcsICdkZWZhdWx0Q2hlY2tlZCcsICdvbkNoYW5nZScsICdjbGFzc05hbWUnLFxuICAgICAgICAgICAgLy8g6Ziy5q2i6L+Z5Lqb6aKd5aSW55qE5Y+C5pWw5b2x5ZONIHRhZyDnmoTnsbvlnotcbiAgICAgICAgICAgICdfc2hhcGUnLCAnY2xvc2FibGUnXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3Qgb3RoZXJzID0gb2JqLnBpY2tPdGhlcnMoYXR0ckZpbHRlclRhcmdldCwgdGhpcy5wcm9wcyk7XG4gICAgICAgIGNvbnN0IGlzQ2hlY2tlZCA9ICdjaGVja2VkJyBpbiB0aGlzLnByb3BzID8gdGhpcy5wcm9wcy5jaGVja2VkIDogdGhpcy5zdGF0ZS5jaGVja2VkO1xuICAgICAgICBjb25zdCBjbGF6eiA9IGNsYXNzTmFtZXModGhpcy5wcm9wcy5jbGFzc05hbWUsIHtcbiAgICAgICAgICAgIGNoZWNrZWQ6IGlzQ2hlY2tlZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIDxUYWcgey4uLm90aGVyc30gcm9sZT1cImNoZWNrYm94XCIgX3NoYXBlPVwiY2hlY2thYmxlXCIgYXJpYS1jaGVja2VkPXtpc0NoZWNrZWR9IGNsYXNzTmFtZT17Y2xhenp9IG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9IC8+O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0YWJsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWcvc2VsZWN0YWJsZS5qc3giLCJpbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgVGFnIGZyb20gJy4vdGFnJztcblxuLyoqXG4gKiBUYWcuQ2xvc2VhYmxlXG4gKi9cbmNsYXNzIENsb3NlYWJsZSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjbG9zZWFibGUg5qCH562+55qEIG9uQ2xvc2Ug5ZON5bqU5Yy65Z+fLCB0YWc6IOagh+etvuS9kywgdGFpbCjpu5jorqQpOiDlhbPpl63mjInpkq5cbiAgICAgICAgICovXG4gICAgICAgIGNsb3NlQXJlYTogUHJvcFR5cGVzLm9uZU9mKFsndGFnJywgJ3RhaWwnXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDngrnlh7vlhbPpl63mjInpkq7ml7bnmoTlm57osINcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGZyb20g5LqL5Lu25p2l5rqQLCB0YWc6IOagh+etvuS9k+eCueWHuywgdGFpbDog5YWz6Zet5oyJ6ZKu54K55Ye7XG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVl5YiZ5YWz6ZetLCBmYWxzZemYu+atouWFs+mXrVxuICAgICAgICAgKi9cbiAgICAgICAgb25DbG9zZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmoIfnrb7lhbPpl63lkI7miafooYznmoTlm57osINcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyQ2xvc2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog54K55Ye75Zue6LCDXG4gICAgICAgICAqL1xuICAgICAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgdHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnbm9ybWFsJywgJ3ByaW1hcnknXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmoIfnrb7nmoTlsLrlr7jvvIhsYXJnZSDlsLrlr7jkuLrlhbzlrrnooajljZXlnLrmma8gbGFyZ2UgPSBtZWRpdW3vvIlcbiAgICAgICAgICovXG4gICAgICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3NtYWxsJywgJ21lZGl1bScsICdsYXJnZSddKSxcbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gICAgICAgIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgdHlwZTogJ25vcm1hbCcsXG4gICAgfTtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZGlzYWJsZWQsIGNsYXNzTmFtZSxcbiAgICAgICAgICAgIGNsb3NlQXJlYSwgb25DbG9zZSxcbiAgICAgICAgICAgIGFmdGVyQ2xvc2UsIG9uQ2xpY2ssXG4gICAgICAgICAgICB0eXBlLCBzaXplLCBjaGlsZHJlbixcbiAgICAgICAgICAgIHJ0bFxuICAgICAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICByZXR1cm4gKDxUYWdcbiAgICAgICAgICAgIHJ0bD17cnRsfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgICAgICAgICBjbG9zZUFyZWE9e2Nsb3NlQXJlYX1cbiAgICAgICAgICAgIG9uQ2xvc2U9e29uQ2xvc2V9XG4gICAgICAgICAgICBhZnRlckNsb3NlPXthZnRlckNsb3NlfVxuICAgICAgICAgICAgb25DbGljaz17b25DbGlja31cbiAgICAgICAgICAgIHR5cGU9e3R5cGV9XG4gICAgICAgICAgICBzaXplPXtzaXplfVxuICAgICAgICAgICAgY2xvc2FibGU+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvVGFnPik7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDbG9zZWFibGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFnL2Nsb3NlYWJsZS5qc3giLCJpbXBvcnQge1xuICAgIGZpbHRlcixcbiAgICBwYXJzZURhdGFTb3VyY2VGcm9tQ2hpbGRyZW4sXG4gICAgbm9ybWFsaXplRGF0YVNvdXJjZSxcbiAgICBmbGF0dGluZ0RhdGFTb3VyY2UsXG4gICAgZmlsdGVyRGF0YVNvdXJjZSxcbn0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBtYW5hZ2UgZGF0YVNvdXJjZSBmb3IgbWVudSBsaXN0XG4gKi9cbmNsYXNzIERhdGFTdG9yZSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICBrZXk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFkZG9uS2V5OiBmYWxzZSxcbiAgICAgICAgICAgIGZpbHRlckxvY2FsOiB0cnVlLFxuICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG9yaWdpbiBkYXRhXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IFtdO1xuICAgICAgICAvLyBjdXJyZW50IGRhdGEgZm9yIG1lbnUgZGlzcGxheVxuICAgICAgICB0aGlzLm1lbnVEYXRhU291cmNlID0gW107XG4gICAgICAgIC8vIGtleT0+dmFsdWUgbWFwIGZvciBtZW51RGF0YVNvdXJjZVxuICAgICAgICB0aGlzLm1hcERhdGFTb3VyY2UgPSB7fTtcbiAgICAgICAgLy8gY3VycmVudCBkYXRhIGNhbiBiZSBzZWxlY3QgKG5vdCBkaXNhYmxlZCkgb24gbWVudVxuICAgICAgICB0aGlzLmVuYWJsZWREYXRhU291cmNlID0gW107XG4gICAgfVxuXG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB1cGRhdGVCeURTKGRhdGFTb3VyY2UsIGlzQ2hpbGRyZW4gPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2UgPSBpc0NoaWxkcmVuID8gcGFyc2VEYXRhU291cmNlRnJvbUNoaWxkcmVuKGRhdGFTb3VyY2UpIDogbm9ybWFsaXplRGF0YVNvdXJjZShkYXRhU291cmNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQWxsKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlQnlLZXkoa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT09IHRoaXMub3B0aW9ucy5rZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1lbnVEUygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLmtleSA9IGtleTtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQWxsKCk7XG4gICAgfVxuXG4gICAgZ2V0T3JpZ2luRFMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2U7XG4gICAgfVxuXG4gICAgZ2V0TWVudURTKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZW51RGF0YVNvdXJjZTtcbiAgICB9XG5cbiAgICBnZXRGbGF0dGVuRFMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYXR0ZW5EYXRhU291cmNlO1xuICAgIH1cblxuICAgIGdldEVuYWJsZURTKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmFibGVkRGF0YVNvdXJjZTtcbiAgICB9XG5cbiAgICBnZXRNYXBEUygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwRGF0YVNvdXJjZTtcbiAgICB9XG5cbiAgICB1cGRhdGVBbGwoKSB7XG4gICAgICAgIGNvbnN0IHtrZXksIGZpbHRlciwgZmlsdGVyTG9jYWx9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB0aGlzLm1lbnVEYXRhU291cmNlID0gZmlsdGVyRGF0YVNvdXJjZSh0aGlzLmRhdGFTb3VyY2UsIGZpbHRlckxvY2FsID8ga2V5IDogJycsIGZpbHRlciwgdGhpcy5vcHRpb25zLmFkZG9uS2V5KTtcblxuICAgICAgICB0aGlzLmZsYXR0ZW5EYXRhU291cmNlID0gZmxhdHRpbmdEYXRhU291cmNlKHRoaXMubWVudURhdGFTb3VyY2UpO1xuXG4gICAgICAgIHRoaXMubWFwRGF0YVNvdXJjZSA9IHt9O1xuICAgICAgICB0aGlzLmZsYXR0ZW5EYXRhU291cmNlLmZvckVhY2goKGl0ZW0gPT4ge1xuICAgICAgICAgICAgdGhpcy5tYXBEYXRhU291cmNlW2Ake2l0ZW0udmFsdWV9YF0gPSBpdGVtO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgdGhpcy5lbmFibGVkRGF0YVNvdXJjZSA9IHRoaXMuZmxhdHRlbkRhdGFTb3VyY2UuZmlsdGVyKGl0ZW0gPT4gIWl0ZW0uZGlzYWJsZWQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLm1lbnVEYXRhU291cmNlO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0YVN0b3JlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NlbGVjdC9kYXRhLXN0b3JlLmpzIiwiaW1wb3J0IENvbmZpZ1Byb3ZpZGVyIGZyb20gJy4uL2NvbmZpZy1wcm92aWRlcic7XG5pbXBvcnQgVmlydHVhbExpc3QgZnJvbSAnLi92aXJ0dWFsLWxpc3QnO1xuXG5leHBvcnQgZGVmYXVsdCBDb25maWdQcm92aWRlci5jb25maWcoVmlydHVhbExpc3QpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3ZpcnR1YWwtbGlzdC9pbmRleC5qc3giLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBmaW5kRE9NTm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBldmVudHMgfSBmcm9tICcuLi91dGlsJztcblxuY29uc3QgTk9PUCA9ICgpID0+IHt9O1xuY29uc3QgTUFYX1NZTkNfVVBEQVRFUyA9IDEwMDtcblxuY29uc3QgaXNFcXVhbFN1YnNldCA9IChhLCBiKSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYikge1xuICAgICAgICBpZiAoYVtrZXldICE9PSBiW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqIFZpcnR1YWxMaXN0ICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaXJ0dWFsTGlzdCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGRpc3BsYXlOYW1lID0gJ1ZpcnR1YWxMaXN0JztcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4suafk+eahOWtkOiKgueCuVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmnIDlsI/liqDovb3mlbDph49cbiAgICAgICAgICovXG4gICAgICAgIG1pblNpemU6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuIDlsY/mlbDph49cbiAgICAgICAgICovXG4gICAgICAgIHBhZ2VTaXplOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICog54i25riy5p+T5Ye95pWw77yM6buY6K6k5Li6IChpdGVtcywgcmVmKSA9PiA8dWwgcmVmPXtyZWZ9PntpdGVtc308L3VsPlxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXNSZW5kZXJlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnvJPlhrLljLrpq5jluqZcbiAgICAgICAgICovXG4gICAgICAgIHRocmVzaG9sZDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPlml0ZW3pq5jluqbnmoTlh73mlbBcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1TaXplR2V0dGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9rui3s+i9rOS9jee9ru+8jOmcgOimgeiuvue9riBpdGVtU2l6ZUdldHRlciDmiY3og73nlJ/mlYgsIOS4jeiuvue9ruiupOS4uuWFg+e0oOetiemrmOW5tuWPluesrOS4gOS4quWFg+e0oOmrmOW6puS9nOS4uum7mOiupOmrmFxuICAgICAgICAgKi9cbiAgICAgICAganVtcEluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmdcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgICAgICBpdGVtc1JlbmRlcmVyOiAoaXRlbXMsIHJlZikgPT4gPHVsIHJlZj17cmVmfT57aXRlbXN9PC91bD4sXG4gICAgICAgIG1pblNpemU6IDEsXG4gICAgICAgIHBhZ2VTaXplOiAxMCxcbiAgICAgICAganVtcEluZGV4OiAwLFxuICAgICAgICB0aHJlc2hvbGQ6IDEwMFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIGNvbnN0IHsganVtcEluZGV4IH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgeyBmcm9tLCBzaXplIH0gPSB0aGlzLmNvbnN0cmFpbihqdW1wSW5kZXgsIDAsIHByb3BzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHsgZnJvbSwgc2l6ZX07XG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5zY3JvbGxUbyA9IHRoaXMuc2Nyb2xsVG8uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYWNoZWRTY3JvbGwgPSBudWxsO1xuICAgICAgICB0aGlzLnVuc3RhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlQ291bnRlciA9IDA7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHsganVtcEluZGV4IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRnJhbWVBbmRDbGVhckNhY2hlID0gdGhpcy51cGRhdGVGcmFtZUFuZENsZWFyQ2FjaGUuYmluZCh0aGlzKTtcblxuICAgICAgICBldmVudHMub24od2luZG93LCAncmVzaXplJywgdGhpcy51cGRhdGVGcmFtZUFuZENsZWFyQ2FjaGUpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRnJhbWUodGhpcy5zY3JvbGxUby5iaW5kKHRoaXMsIGp1bXBJbmRleCkpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dCkge1xuICAgICAgICBjb25zdCB7ZnJvbSwgc2l6ZX0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIGNvbnN0IG9sZEluZGV4ID0gdGhpcy5wcm9wcy5qdW1wSW5kZXg7XG4gICAgICAgIGNvbnN0IG5ld0luZGV4ID0gbmV4dC5qdW1wSW5kZXg7XG5cbiAgICAgICAgaWYgKG9sZEluZGV4ICE9PSBuZXdJbmRleCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGcmFtZSh0aGlzLnNjcm9sbFRvLmJpbmQodGhpcywgbmV3SW5kZXgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWF5YmVTZXRTdGF0ZSh0aGlzLmNvbnN0cmFpbihmcm9tLCBzaXplLCBuZXh0KSwgTk9PUCk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuXG4gICAgICAgIC8vIElmIHRoZSBsaXN0IGhhcyByZWFjaGVkIGFuIHVuc3RhYmxlIHN0YXRlLCBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AuXG4gICAgICAgIGlmICh0aGlzLnVuc3RhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKyt0aGlzLnVwZGF0ZUNvdW50ZXIgPiBNQVhfU1lOQ19VUERBVEVTKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3RhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy51cGRhdGVDb3VudGVyVGltZW91dElkKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvdW50ZXJUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNvdW50ZXIgPSAwO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnVwZGF0ZUNvdW50ZXJUaW1lb3V0SWQ7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlRnJhbWUoKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgZXZlbnRzLm9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLnVwZGF0ZUZyYW1lQW5kQ2xlYXJDYWNoZSk7XG5cbiAgICAgICAgZXZlbnRzLm9mZih0aGlzLnNjcm9sbFBhcmVudCwgJ3Njcm9sbCcsIHRoaXMudXBkYXRlRnJhbWVBbmRDbGVhckNhY2hlKTtcbiAgICAgICAgZXZlbnRzLm9mZih0aGlzLnNjcm9sbFBhcmVudCwgJ21vdXNld2hlZWwnLCBOT09QKTtcbiAgICB9XG5cbiAgICBtYXliZVNldFN0YXRlKGIsIGNiKSB7XG5cbiAgICAgICAgaWYgKGlzRXF1YWxTdWJzZXQodGhpcy5zdGF0ZSwgYikpIHtcbiAgICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZShiLCBjYik7XG4gICAgfVxuXG4gICAgZ2V0T2Zmc2V0KGVsKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSBlbC5jbGllbnRMZWZ0IHx8IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG9mZnNldCArPSBlbC5vZmZzZXRUb3AgfHwgMDtcbiAgICAgICAgICAgIGVsID0gZWwub2Zmc2V0UGFyZW50O1xuICAgICAgICB9IHdoaWxlIChlbCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgZ2V0RWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsIHx8IHRoaXMuaXRlbXMgfHwge307XG4gICAgfVxuXG4gICAgZ2V0U2Nyb2xsUGFyZW50KCkge1xuICAgICAgICBsZXQgZWwgPSB0aGlzLmdldEVsKCk7XG4gICAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcblxuICAgICAgICBzd2l0Y2ggKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5vdmVyZmxvd1kpIHtcbiAgICAgICAgICAgIGNhc2UgJ2F1dG8nOiBjYXNlICdzY3JvbGwnOiBjYXNlICdvdmVybGF5JzogY2FzZSAndmlzaWJsZSc6IHJldHVybiBlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuXG4gICAgZ2V0U2Nyb2xsKCkge1xuICAgICAgICAvLyBDYWNoZSBzY3JvbGwgcG9zaXRpb24gYXMgdGhpcyBjYXVzZXMgYSBmb3JjZWQgc3luY2hyb25vdXMgbGF5b3V0LlxuICAgICAgICAvLyBpZiAodHlwZW9mIHRoaXMuY2FjaGVkU2Nyb2xsID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyAgICAgcmV0dXJuIHRoaXMuY2FjaGVkU2Nyb2xsO1xuICAgICAgICAvLyB9XG4gICAgICAgIGNvbnN0IHtzY3JvbGxQYXJlbnR9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2Nyb2xsS2V5ID0gJ3Njcm9sbFRvcCc7XG4gICAgICAgIGNvbnN0IGFjdHVhbCA9IHNjcm9sbFBhcmVudCA9PT0gd2luZG93ID9cbiAgICAgICAgLy8gRmlyZWZveCBhbHdheXMgcmV0dXJucyBkb2N1bWVudC5ib2R5W3Njcm9sbEtleV0gYXMgMCBhbmQgQ2hyb21lL1NhZmFyaVxuICAgICAgICAvLyBhbHdheXMgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtzY3JvbGxLZXldIGFzIDAsIHNvIHRha2VcbiAgICAgICAgLy8gd2hpY2hldmVyIGhhcyBhIHZhbHVlLlxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keVtzY3JvbGxLZXldIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtzY3JvbGxLZXldIDpcbiAgICAgICAgICAgIHNjcm9sbFBhcmVudFtzY3JvbGxLZXldO1xuICAgICAgICBjb25zdCBtYXggPSB0aGlzLmdldFNjcm9sbFNpemUoKSAtIHRoaXMuZ2V0Vmlld3BvcnRTaXplKCk7XG5cbiAgICAgICAgY29uc3Qgc2Nyb2xsID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYWN0dWFsLCBtYXgpKTtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLmdldEVsKCk7XG4gICAgICAgIHRoaXMuY2FjaGVkU2Nyb2xsID0gdGhpcy5nZXRPZmZzZXQoc2Nyb2xsUGFyZW50KSArIHNjcm9sbCAtIHRoaXMuZ2V0T2Zmc2V0KGVsKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRTY3JvbGw7XG4gICAgfVxuXG4gICAgc2V0U2Nyb2xsKG9mZnNldCkge1xuICAgICAgICBjb25zdCB7c2Nyb2xsUGFyZW50fSA9IHRoaXM7XG4gICAgICAgIG9mZnNldCArPSB0aGlzLmdldE9mZnNldCh0aGlzLmdldEVsKCkpO1xuICAgICAgICBpZiAoc2Nyb2xsUGFyZW50ID09PSB3aW5kb3cpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuc2Nyb2xsVG8oMCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldCAtPSB0aGlzLmdldE9mZnNldCh0aGlzLnNjcm9sbFBhcmVudCk7XG4gICAgICAgIHNjcm9sbFBhcmVudC5zY3JvbGxUb3AgPSBvZmZzZXQ7XG4gICAgfVxuXG4gICAgZ2V0Vmlld3BvcnRTaXplKCkge1xuICAgICAgICBjb25zdCB7c2Nyb2xsUGFyZW50fSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBzY3JvbGxQYXJlbnQgPT09IHdpbmRvdyA/XG4gICAgICAgICAgICB3aW5kb3cuaW5uZXJIZWlnaHQgOlxuICAgICAgICAgICAgc2Nyb2xsUGFyZW50LmNsaWVudEhlaWdodDtcbiAgICB9XG5cbiAgICBnZXRTY3JvbGxTaXplKCkge1xuICAgICAgICBjb25zdCB7c2Nyb2xsUGFyZW50fSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHtib2R5LCBkb2N1bWVudEVsZW1lbnR9ID0gZG9jdW1lbnQ7XG4gICAgICAgIGNvbnN0IGtleSA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICByZXR1cm4gc2Nyb2xsUGFyZW50ID09PSB3aW5kb3cgP1xuICAgICAgICAgICAgTWF0aC5tYXgoYm9keVtrZXldLCBkb2N1bWVudEVsZW1lbnRba2V5XSkgOlxuICAgICAgICAgICAgc2Nyb2xsUGFyZW50W2tleV07XG4gICAgfVxuXG4gICAgZ2V0U3RhcnRBbmRFbmQodGhyZXNob2xkID0gdGhpcy5wcm9wcy50aHJlc2hvbGQpIHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsID0gdGhpcy5nZXRTY3JvbGwoKTtcblxuICAgICAgICBjb25zdCB0cnVlU2Nyb2xsID0gc2Nyb2xsO1xuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIHRydWVTY3JvbGwgLSB0aHJlc2hvbGQpO1xuICAgICAgICBjb25zdCBlbmQgPSB0cnVlU2Nyb2xsICsgdGhpcy5nZXRWaWV3cG9ydFNpemUoKSArIHRocmVzaG9sZDtcblxuICAgICAgICByZXR1cm4ge3N0YXJ0LCBlbmR9O1xuICAgIH1cblxuICAgIC8vIENhbGxlZCBieSAnc2Nyb2xsJyBhbmQgJ3Jlc2l6ZScgZXZlbnRzLCBjbGVhcnMgc2Nyb2xsIHBvc2l0aW9uIGNhY2hlLlxuICAgIHVwZGF0ZUZyYW1lQW5kQ2xlYXJDYWNoZShjYikge1xuICAgICAgICB0aGlzLmNhY2hlZFNjcm9sbCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUZyYW1lKGNiKTtcbiAgICB9XG5cbiAgICB1cGRhdGVGcmFtZShjYikge1xuICAgICAgICB0aGlzLnVwZGF0ZVNjcm9sbFBhcmVudCgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiID0gTk9PUDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVZhcmlhYmxlRnJhbWUoY2IpO1xuXG4gICAgfVxuXG4gICAgdXBkYXRlU2Nyb2xsUGFyZW50KCkge1xuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5zY3JvbGxQYXJlbnQ7XG4gICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50ID0gdGhpcy5nZXRTY3JvbGxQYXJlbnQoKTtcblxuICAgICAgICBpZiAocHJldiA9PT0gdGhpcy5zY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgZXZlbnRzLm9mZihwcmV2LCAnc2Nyb2xsJywgdGhpcy51cGRhdGVGcmFtZUFuZENsZWFyQ2FjaGUpO1xuICAgICAgICAgICAgZXZlbnRzLm9mZihwcmV2LCAnbW91c2V3aGVlbCcsIE5PT1ApO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnRzLm9uKHRoaXMuc2Nyb2xsUGFyZW50LCAnc2Nyb2xsJywgdGhpcy51cGRhdGVGcmFtZUFuZENsZWFyQ2FjaGUpO1xuICAgICAgICBldmVudHMub24odGhpcy5zY3JvbGxQYXJlbnQsICdtb3VzZXdoZWVsJywgTk9PUCk7XG5cbiAgICAgICAgLy8gWW91IGhhdmUgdG8gYXR0YWNoIG1vdXNld2hlZWwgbGlzdGVuZXIgdG8gdGhlIHNjcm9sbGFibGUgZWxlbWVudC5cbiAgICAgICAgLy8gSnVzdCBhbiBlbXB0eSBsaXN0ZW5lci4gQWZ0ZXIgdGhhdCBvbnNjcm9sbCBldmVudHMgd2lsbCBiZSBmaXJlZCBzeW5jaHJvbm91c2x5LlxuICAgIH1cblxuICAgIHVwZGF0ZVZhcmlhYmxlRnJhbWUoY2IpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLml0ZW1TaXplR2V0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlU2l6ZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtzdGFydCwgZW5kfSA9IHRoaXMuZ2V0U3RhcnRBbmRFbmQoKTtcbiAgICAgICAgY29uc3Qge3BhZ2VTaXplLCBjaGlsZHJlbn0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGxldCBzcGFjZSA9IDA7XG4gICAgICAgIGxldCBmcm9tID0gMDtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBjb25zdCBtYXhGcm9tID0gbGVuZ3RoIC0gMTtcblxuICAgICAgICB3aGlsZSAoZnJvbSA8IG1heEZyb20pIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1TaXplID0gdGhpcy5nZXRTaXplT2YoZnJvbSk7XG4gICAgICAgICAgICBpZiAoaXRlbVNpemUgPT09IG51bGwgfHwgaXRlbVNpemUgPT09IHVuZGVmaW5lZCB8fCBzcGFjZSArIGl0ZW1TaXplID4gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwYWNlICs9IGl0ZW1TaXplO1xuICAgICAgICAgICAgKytmcm9tO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWF4U2l6ZSA9IGxlbmd0aCAtIGZyb207XG5cbiAgICAgICAgd2hpbGUgKHNpemUgPCBtYXhTaXplICYmIHNwYWNlIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtU2l6ZSA9IHRoaXMuZ2V0U2l6ZU9mKGZyb20gKyBzaXplKTtcbiAgICAgICAgICAgIGlmIChpdGVtU2l6ZSA9PT0gbnVsbCB8fCBpdGVtU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWluKHNpemUgKyBwYWdlU2l6ZSwgbWF4U2l6ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcGFjZSArPSBpdGVtU2l6ZTtcbiAgICAgICAgICAgICsrc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWF5YmVTZXRTdGF0ZSh7ZnJvbSwgc2l6ZX0sIGNiKTtcbiAgICB9XG5cbiAgICBnZXRTcGFjZUJlZm9yZShpbmRleCwgY2FjaGUgPSB7fSkge1xuXG4gICAgICAgIGlmICghaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWNoZVtpbmRleF0gIT09IG51bGwgJiYgY2FjaGVbaW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZVtpbmRleF0gfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgc3BhY2UgdG8gaW5kZXggdGhlcmUgaXMgYSBjYWNoZWQgdmFsdWUgZm9yLlxuICAgICAgICBsZXQgZnJvbSA9IGluZGV4O1xuICAgICAgICB3aGlsZSAoZnJvbSA+IDAgJiYgKGNhY2hlW2Zyb21dID09PSBudWxsIHx8IGNhY2hlW2Zyb21dID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBmcm9tLS07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5hbGx5LCBhY2N1bXVsYXRlIHNpemVzIG9mIGl0ZW1zIGZyb20gLSBpbmRleC5cbiAgICAgICAgbGV0IHNwYWNlID0gY2FjaGVbZnJvbV0gfHwgMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCBpbmRleDsgKytpKSB7XG4gICAgICAgICAgICBjYWNoZVtpXSA9IHNwYWNlO1xuICAgICAgICAgICAgY29uc3QgaXRlbVNpemUgPSB0aGlzLmdldFNpemVPZihpKTtcbiAgICAgICAgICAgIGlmIChpdGVtU2l6ZSA9PT0gbnVsbCB8fCBpdGVtU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcGFjZSArPSBpdGVtU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhY2hlW2luZGV4XSA9IHNwYWNlO1xuXG4gICAgICAgIHJldHVybiBjYWNoZVtpbmRleF0gfHwgMDtcbiAgICB9XG5cbiAgICBjYWNoZVNpemVzKCkge1xuICAgICAgICBjb25zdCB7Y2FjaGV9ID0gdGhpcztcbiAgICAgICAgY29uc3Qge2Zyb219ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgcHJvcHMgPSB7fSB9ID0gdGhpcy5pdGVtcztcbiAgICAgICAgY29uc3QgaXRlbUVscyA9IGNoaWxkcmVuIHx8IHByb3BzLmNoaWxkcmVuIHx8IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGl0ZW1FbHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB1bFJlZiA9ICBmaW5kRE9NTm9kZSh0aGlzLml0ZW1zKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHVsUmVmLmNoaWxkcmVuW2ldLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIGlmIChoZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVbZnJvbSArIGldID0gaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0U2l6ZU9mKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHsgY2FjaGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgaXRlbVNpemVHZXR0ZXIsIGp1bXBJbmRleCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICAvLyBUcnkgdGhlIGNhY2hlLlxuICAgICAgICBpZiAoaW5kZXggaW4gY2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW1TaXplR2V0dGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbVNpemVHZXR0ZXIoaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gT2JqZWN0LnZhbHVlcyh0aGlzLmNhY2hlKS5wb3AoKTtcbiAgICAgICAgaWYgKCF0aGlzLmRlZmF1bHRJdGVtSGVpZ2h0ICYmIGp1bXBJbmRleCA+IC0xICYmIGhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0SXRlbUhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRJdGVtSGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0SXRlbUhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0cmFpbihmcm9tLCBzaXplLCB7Y2hpbGRyZW4sIG1pblNpemV9KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgc2l6ZSA9IE1hdGgubWF4KHNpemUsIG1pblNpemUpO1xuICAgICAgICBpZiAoc2l6ZSA+IGxlbmd0aCkge1xuICAgICAgICAgICAgc2l6ZSA9IGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBmcm9tID0gZnJvbSA/IE1hdGgubWF4KE1hdGgubWluKGZyb20sIGxlbmd0aCAtIHNpemUpLCAwKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuIHtmcm9tLCBzaXplfTtcbiAgICB9XG5cbiAgICBzY3JvbGxUbyhpbmRleCkge1xuICAgICAgICB0aGlzLnNldFNjcm9sbCh0aGlzLmdldFNwYWNlQmVmb3JlKGluZGV4KSk7XG4gICAgfVxuXG4gICAgcmVuZGVyTWVudUl0ZW1zKCkge1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuLCBpdGVtc1JlbmRlcmVyIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7ZnJvbSwgc2l6ZX0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCBpdGVtcyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGNoaWxkcmVuW2Zyb20gKyBpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbXNSZW5kZXJlcihpdGVtcywgYyA9PiB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zID0gYztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4gPSBbXSwgcHJlZml4LCBjbGFzc05hbWUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgY29uc3Qge2Zyb219ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLnJlbmRlck1lbnVJdGVtcygpO1xuXG4gICAgICAgIGNvbnN0IHN0eWxlID0ge3Bvc2l0aW9uOiAncmVsYXRpdmUnfTtcbiAgICAgICAgY29uc3QgY2FjaGUgPSB7fTtcblxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTcGFjZUJlZm9yZShsZW5ndGgsIGNhY2hlKTtcblxuICAgICAgICBpZiAoc2l6ZSkge1xuICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmdldFNwYWNlQmVmb3JlKGZyb20sIGNhY2hlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgwcHgsICR7b2Zmc2V0fXB4KWA7XG4gICAgICAgIGNvbnN0IGxpc3RTdHlsZSA9IHtcbiAgICAgICAgICAgIG1zVHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgICAgICBXZWJraXRUcmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgICAgICAgIHRyYW5zZm9ybVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGNscyA9ICBjeCh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fXZpcnR1YWwtbGlzdC13cmFwcGVyYF06IHRydWUsXG4gICAgICAgICAgICBbY2xhc3NOYW1lXTogISFjbGFzc05hbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbHN9IHN0eWxlPXtzdHlsZX0gcmVmPXtcbiAgICAgICAgICAgICAgICBjID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbCA9IGM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17bGlzdFN0eWxlfT57aXRlbXN9PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdmlydHVhbC1saXN0L3ZpcnR1YWwtbGlzdC5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBmdW5jLCBvYmosIEtFWUNPREUgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBJbnB1dCBmcm9tICcuLi9pbnB1dCc7XG5pbXBvcnQgQmFzZSBmcm9tICcuL2Jhc2UnO1xuXG5jb25zdCB7IGJpbmRDdHgsIG5vb3AgfSA9IGZ1bmM7XG5cbi8qKlxuICogU2VsZWN0LkF1dG9Db21wbGV0ZVxuICovXG5jbGFzcyBBdXRvQ29tcGxldGUgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAuLi5CYXNlLnByb3BUeXBlcyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW9k+WJjeWAvO+8jOeUqOS6juWPl+aOp+aooeW8j1xuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIneWni+WMlueahOm7mOiupOWAvFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWxlY3Tlj5HnlJ/mlLnlj5jml7bop6blj5HnmoTlm57osINcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSDpgInkuK3nmoTlgLxcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvblR5cGUg6Kem5Y+R55qE5pa55byPLCAnaXRlbUNsaWNrJywgJ2VudGVyJywgJ2NoYW5nZSdcbiAgICAgICAgICogQHBhcmFtIHsqfSBpdGVtIOmAieS4reeahOWAvOeahOWvueixoeaVsOaNrlxuICAgICAgICAgKi9cbiAgICAgICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5Lyg5YWl55qE5pWw5o2u5rqQ77yM5Y+v5Lul5Yqo5oCB5riy5p+T5a2Q6aG5XG4gICAgICAgICAqL1xuICAgICAgICBkYXRhU291cmNlOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgICAgICAgIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgICAgICAgICAgbGFiZWw6IFByb3BUeXBlcy5hbnksXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuYXJyYXlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgUHJvcFR5cGVzLnN0cmluZ1xuICAgICAgICBdKSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDloavlhYXliLDpgInmi6nmoYbph4znmoTlgLznmoQga2V5XGJcYu+8jOm7mOiupOaYryB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsbFByb3BzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog5riy5p+TIE1lbnVJdGVtIOWGheWuueeahOaWueazlVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSDmuLLmn5PoioLngrnnmoQgaXRlbVxuICAgICAgICAgKiBAcmV0dXJuIHtSZWFjdE5vZGV9IGl0ZW0gbm9kZVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbVJlbmRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8vIGlucHV0IGtleWRvd25cbiAgICAgICAgb25LZXlEb3duOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLy8g5piv5ZCm5bCG5b2T5YmN6auY5Lqu55qE6YCJ6aG55L2c5Li6IHBsYWNlaG9sZGVyXG4gICAgICAgIGhpZ2hsaWdodEhvbGRlcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAuLi5CYXNlLmRlZmF1bHRQcm9wcyxcbiAgICAgICAgb25LZXlEb3duOiBub29wLFxuICAgICAgICBmaWxsUHJvcHM6ICd2YWx1ZScsXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLmlzQXV0b0NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0lucHV0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgYmluZEN0eCh0aGlzLCBbXG4gICAgICAgICAgICAnaGFuZGxlVHJpZ2dlcktleURvd24nLFxuICAgICAgICAgICAgJ2hhbmRsZU1lbnVTZWxlY3QnLFxuICAgICAgICAgICAgJ2hhbmRsZUl0ZW1DbGljaydcbiAgICAgICAgXSk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICB0aGlzLmRhdGFTdG9yZS5zZXRPcHRpb25zKHsga2V5OiB0aGlzLnN0YXRlLnZhbHVlIH0pO1xuXG4gICAgICAgIHN1cGVyLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIGlmICgndmFsdWUnIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgdGhpcy5kYXRhU3RvcmUuc2V0T3B0aW9ucyh7IGtleTogbmV4dFByb3BzLnZhbHVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpO1xuXG4gICAgICAgIC8vIHJlbW90ZSBkYXRhU291cmNlIGFuZCBmb2N1c2VkXG4gICAgICAgIC8vIOWboOS4umF1dG9Db21wbGV0ZeayoeacieS4i+aLieaVsOaNruS4jeWxleekuu+8jOaQnOe0ouW5tuS4lOacieaVsOaNruS6humcgOimgeiHquWKqOWxleekuuS4i+aLiVxuICAgICAgICBpZiAoIW5leHRQcm9wcy5maWx0ZXJMb2NhbCAmJiB0aGlzLmlzSW5wdXRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQ29udHJvbFBvcHVwKG5leHRQcm9wcywgJ3VwZGF0ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuZXh0UHJvcHMuZmlsdGVyTG9jYWwgJiYgIW5leHRQcm9wcy5wb3B1cENvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Rmlyc3RIaWdodExpZ2h0S2V5Rm9yTWVudSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ2xlYXIoKSkge1xuICAgICAgICAgICAgY29uc3QgaW5wdXROb2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5pbnB1dFJlZik7XG4gICAgICAgICAgICBpZiAoaW5wdXROb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhck5vZGUgPSBpbnB1dE5vZGUucXVlcnlTZWxlY3RvcihgLiR7dGhpcy5wcm9wcy5wcmVmaXh9aW5wdXQtY29udHJvbGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2hvdWxkQ29udHJvbFBvcHVwKHByb3BzID0gdGhpcy5wcm9wcywgdHlwZSkge1xuICAgICAgICBjb25zdCBoYXNQb3B1cCA9IHByb3BzLnBvcHVwQ29udGVudCB8fCB0aGlzLmRhdGFTdG9yZS5nZXRNZW51RFMoKS5sZW5ndGg7XG4gICAgICAgIGlmIChoYXNQb3B1cCkge1xuICAgICAgICAgICAgdGhpcy5zZXRWaXNpYmxlKHRydWUsIHR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRWaXNpYmxlKGZhbHNlLCB0eXBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgaGFuZGxlTWVudVNlbGVjdChrZXlzKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbMF07XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnZhbHVlID09PSBrZXlzWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRWaXNpYmxlKGZhbHNlLCAnaXRlbUNsaWNrJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYXBEUyA9IHRoaXMuZGF0YVN0b3JlLmdldE1hcERTKCk7XG5cbiAgICAgICAgaWYgKGtleSBpbiBtYXBEUykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IG1hcERTW2tleV07XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNlbGVjdEV2ZW50KGtleSwgaXRlbSwgJ2l0ZW1DbGljaycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlSXRlbUNsaWNrKCkge1xuICAgICAgICB0aGlzLnNldFZpc2libGUoZmFsc2UsICdpdGVtQ2xpY2snKTtcbiAgICB9XG5cbiAgICBoYW5kbGVTZWxlY3RFdmVudChrZXksIGl0ZW0sIHRyaWdnZXJUeXBlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXRlbSAmJiBpdGVtW3RoaXMucHJvcHMuZmlsbFByb3BzXSB8fCBrZXk7XG5cbiAgICAgICAgaWYgKHRyaWdnZXJUeXBlID09PSAnaXRlbUNsaWNrJyB8fCB0cmlnZ2VyVHlwZSA9PT0gJ2VudGVyJykge1xuICAgICAgICAgICAgLy8g54K55Ye7IGl0ZW0g55qE5pe25YCZ5LiN5Lya6Kem5Y+R5YWz6Zet77yM6ZyA6KaB5omL5Yqo5YWz6Zet77yM5YW25a6D57G75Z6L5q+U5aaCIGtleURvd24g562J6YO95Lya5pyJ5YW25a6D5LqL5Lu25Y+l5p+E5aSE55CGXG4gICAgICAgICAgICB0aGlzLnNldFZpc2libGUoZmFsc2UsIHRyaWdnZXJUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGFuZGxlQ2hhbmdlKHZhbHVlLCB0cmlnZ2VyVHlwZSwgaXRlbSk7XG4gICAgfVxuXG4gICAgaGFuZGxlQ2hhbmdlID0gKHZhbHVlLCBwcm94eSwgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCB7IGRpc2FibGVkLCByZWFkT25seSwgZmlsdGVyTG9jYWwgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKGRpc2FibGVkIHx8IHJlYWRPbmx5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhY3Rpb25UeXBlID0gdHlwZW9mIHByb3h5ID09PSAnc3RyaW5nJyA/IHByb3h5IDogJ2NoYW5nZSc7XG5cbiAgICAgICAgdGhpcy5pc0lucHV0aW5nID0gYWN0aW9uVHlwZSA9PT0gJ2NoYW5nZSc7XG5cbiAgICAgICAgaWYgKGZpbHRlckxvY2FsKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhU291cmNlOiB0aGlzLmRhdGFTdG9yZS51cGRhdGVCeUtleSh2YWx1ZSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLnNob3VsZENvbnRyb2xQb3B1cCh0aGlzLnByb3BzLCBhY3Rpb25UeXBlKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Rmlyc3RIaWdodExpZ2h0S2V5Rm9yTWVudSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g6Z2e5Y+X5o6n5qih5byP5riF56m65YaF6YOo5pWw5o2uXG4gICAgICAgIGlmICghKCd2YWx1ZScgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHZhbHVlLCBhY3Rpb25UeXBlLCBpdGVtKTtcblxuICAgICAgICBpZiAoYWN0aW9uVHlwZSA9PT0gJ2l0ZW1DbGljaycgfHwgYWN0aW9uVHlwZSA9PT0gJ2VudGVyJykge1xuICAgICAgICAgICAgLy8g54K55Ye7IGl0ZW0g55qE5pe25YCZ5LiN5Lya6Kem5Y+R5YWz6Zet77yM6ZyA6KaB5omL5Yqo5YWz6Zet77yM5YW25a6D57G75Z6L5q+U5aaCIGtleURvd24g562J6YO95Lya5pyJ5YW25a6D5LqL5Lu25Y+l5p+E5aSE55CGXG4gICAgICAgICAgICB0aGlzLnNldFZpc2libGUoZmFsc2UsIGFjdGlvblR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlVmlzaWJsZUNoYW5nZSh2aXNpYmxlLCB0eXBlKSB7XG4gICAgICAgIGlmICghKCd2aXNpYmxlJyBpbiB0aGlzLnByb3BzKSAmJiB2aXNpYmxlICYmICF0aGlzLnByb3BzLnBvcHVwQ29udGVudCAmJiAhdGhpcy5kYXRhU3RvcmUuZ2V0TWVudURTKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFZpc2libGUodmlzaWJsZSwgdHlwZSk7XG4gICAgfVxuXG4gICAgYmVmb3JlQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuaXNJbnB1dGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0cmlnZ2VyIGtleWRvd24gZXZlbnRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICovXG4gICAgaGFuZGxlVHJpZ2dlcktleURvd24oZSkge1xuXG4gICAgICAgIGNvbnN0IHsgcG9wdXBDb250ZW50LCBvblRvZ2dsZUhpZ2hsaWdodEl0ZW0sIG9uS2V5RG93biB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKHBvcHVwQ29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG9uS2V5RG93bihlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIEtFWUNPREUuVVA6XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIG9uVG9nZ2xlSGlnaGxpZ2h0SXRlbSh0aGlzLnRvZ2dsZUhpZ2hsaWdodEl0ZW0oLTEsIGUpLCAndXAnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS0VZQ09ERS5ET1dOOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBvblRvZ2dsZUhpZ2hsaWdodEl0ZW0odGhpcy50b2dnbGVIaWdobGlnaHRJdGVtKDEsIGUpLCAnZG93bicpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLRVlDT0RFLkVOVEVSOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNob29zZUhpZ2hsaWdodEl0ZW0oZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtFWUNPREUuU1BBQ0U6XG4gICAgICAgICAgICAgICAgLy8g6Ziy5q2iIFBvcHVwIOebkeWQrOWIsCBzcGFjZSBrZXkg6Kem5Y+RIG9uVmlzaWJsZUNoYW5nZVxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtFWUNPREUuRVNDOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnZpc2libGUgJiYgdGhpcy5zZXRWaXNpYmxlKGZhbHNlLCAnZXNjJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgb25LZXlEb3duKGUpO1xuICAgIH1cblxuICAgIC8vIOWbnui9piDpgInmi6npq5jkuq7nmoQgaXRlbVxuICAgIGNob29zZUhpZ2hsaWdodEl0ZW0oKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGhpZ2hsaWdodEtleSB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgaGlnaGxpZ2h0SXRlbSA9IHRoaXMuZGF0YVN0b3JlLmdldEVuYWJsZURTKCkuZmluZChpdGVtID0+IHtcbiAgICAgICAgICAgIHJldHVybiBoaWdobGlnaHRLZXkgPT09IGAke2l0ZW0udmFsdWV9YDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGhpZ2hsaWdodEl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0RXZlbnQoaGlnaGxpZ2h0S2V5LCBoaWdobGlnaHRJdGVtLCAnZW50ZXInKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhc0NsZWFyKCkge1xuICAgICAgICBjb25zdCB7IGhhc0NsZWFyLCByZWFkT25seSwgZGlzYWJsZWQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIGhhc0NsZWFyICYmICFyZWFkT25seSAmJiAhZGlzYWJsZWQ7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiDpgInmi6nlmahcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICAgKi9cbiAgICByZW5kZXJTZWxlY3QocHJvcHMgPSB0aGlzLnByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgcGxhY2Vob2xkZXIsIHNpemUsIHByZWZpeCwgY2xhc3NOYW1lLCBzdHlsZSwgbGFiZWwsIHJlYWRPbmx5LCBkaXNhYmxlZCwgaGlnaGxpZ2h0SG9sZGVyLCBsb2NhbGUsIGhhc0NsZWFyLCBzdGF0ZSwgcnRsIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gb2JqLnBpY2tPdGhlcnMoQXV0b0NvbXBsZXRlLnByb3BUeXBlcywgcHJvcHMpO1xuICAgICAgICBjb25zdCBvdGhlcnNEYXRhID0gb2JqLnBpY2tBdHRyc1dpdGgob3RoZXJzLCAnZGF0YS0nKTtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICAgIGNvbnN0IHZpc2libGUgPSB0aGlzLnN0YXRlLnZpc2libGU7XG5cbiAgICAgICAgLy8gLy8g5LiL5ouJ566t5aS0XG4gICAgICAgIC8vIGNvbnN0IGFycm93Tm9kZSA9IHRoaXMucmVuZGVyQXJyb3dOb2RlKHByb3BzLCAoKSA9PiB7XG4gICAgICAgIC8vICAgICB0aGlzLmZvY3VzSW5wdXQoKTtcbiAgICAgICAgLy8gICAgIHRoaXMuc2V0VmlzaWJsZSghdGhpcy5zdGF0ZS52aXNpYmxlKTtcbiAgICAgICAgLy8gfSk7XG5cbiAgICAgICAgLy8gdHJpZ2dlciBjbGFzc05hbWVcbiAgICAgICAgY29uc3QgdHJpZ2dlckNsYXp6ID0gY2xhc3NOYW1lcyhbXG4gICAgICAgICAgICBgJHtwcmVmaXh9c2VsZWN0YCxcbiAgICAgICAgICAgIGAke3ByZWZpeH1zZWxlY3QtYXV0by1jb21wbGV0ZWAsXG4gICAgICAgICAgICBgJHtwcmVmaXh9c2l6ZS0ke3NpemV9YCxcbiAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgXSwge1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1hY3RpdmVgXTogdmlzaWJsZSxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9ZGlzYWJsZWRgXTogZGlzYWJsZWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaGlnaGxpZ2h0S2V5IGludG8gcGxhY2Vob2xkZXJcbiAgICAgICAgLy8gY29tcGF0aWJsZSB3aXRoIHNlbGVjdFBsYWNlSG9sZGVyLiBUT0RPOiByZW1vdmVkIGluIDIuMCB2ZXJzaW9uXG4gICAgICAgIGxldCBfcGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlciB8fCBsb2NhbGUuYXV0b0NvbXBsZXRlUGxhY2Vob2xkZXIgfHwgbG9jYWxlLmF1dG9Db21wbGV0ZVBsYWNlSG9sZGVyO1xuICAgICAgICBpZiAoaGlnaGxpZ2h0SG9sZGVyICYmIHZpc2libGUpIHtcbiAgICAgICAgICAgIF9wbGFjZWhvbGRlciA9IHRoaXMuc3RhdGUuaGlnaGxpZ2h0S2V5IHx8IF9wbGFjZWhvbGRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElucHV0IHByb3BzXG4gICAgICAgIGNvbnN0IF9pbnB1dFByb3BzID0ge1xuICAgICAgICAgICAgLi4ub2JqLnBpY2tPdGhlcnMob3RoZXJzRGF0YSwgb3RoZXJzKSxcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIHJlZjogdGhpcy5zYXZlSW5wdXRSZWYsXG4gICAgICAgICAgICBoYXNDbGVhcjogaGFzQ2xlYXIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUgfHwgJycsXG4gICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICByZWFkT25seSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBfcGxhY2Vob2xkZXIsXG4gICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgIC8vIGV4dHJhOiBhcnJvd05vZGUsXG4gICAgICAgICAgICBvbkNoYW5nZTogdGhpcy5oYW5kbGVDaGFuZ2UsXG4gICAgICAgICAgICBvbktleURvd246IHRoaXMuaGFuZGxlVHJpZ2dlcktleURvd25cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPHNwYW4gey4uLm90aGVyc0RhdGF9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXt0cmlnZ2VyQ2xhenp9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3N0eWxlfVxuICAgICAgICAgICAgICAgIGRpcj17cnRsID8gJ3J0bCcgOiB1bmRlZmluZWR9XG4gICAgICAgICAgICAgICAgcmVmPXt0aGlzLnNhdmVTZWxlY3RSZWZ9XG4gICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5mb2N1c0lucHV0fT5cbiAgICAgICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICAgICAgey4uLl9pbnB1dFByb3BzfVxuICAgICAgICAgICAgICAgICAgICByb2xlPVwiY29tYm9ib3hcIlxuICAgICAgICAgICAgICAgICAgICBhcmlhLWF1dG9jb21wbGV0ZT1cImxpc3RcIlxuICAgICAgICAgICAgICAgICAgICBhcmlhLWRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICAgICAgICAgICAgYXJpYS1leHBhbmRlZD17dGhpcy5zdGF0ZS52aXNpYmxlfSAvPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ2xlYXIoKSkge1xuICAgICAgICAgICAgLy8gY2xlYXIg5oyJ6ZKu54K55Ye75ZCO77yM5Lya5ZyoIGRvbSDnu5PmnoTkuK3ooqvliKDpmaTmjonvvIzpnIDopoHlsIblhbbpop3lpJborr7nva7kuLrlronlhajoioLngrnvvIzpmLLmraLop6blj5HlvLnlsYLnmoTmmL7npLrmiJbpmpDol49cbiAgICAgICAgICAgIGNvbnN0IHNhZmVOb2RlID0gdGhpcy5wcm9wcy5wb3B1cFByb3BzLnNhZmVOb2RlIHx8IFtdO1xuICAgICAgICAgICAgY29uc3Qgc2FmZU5vZGVzID0gQXJyYXkuaXNBcnJheShzYWZlTm9kZSkgPyBzYWZlTm9kZSA6IFtzYWZlTm9kZV07XG4gICAgICAgICAgICBzYWZlTm9kZXMucHVzaCgoKSA9PiB0aGlzLmNsZWFyTm9kZSk7XG4gICAgICAgICAgICB0aGlzLnByb3BzLnBvcHVwUHJvcHMuc2FmZU5vZGUgPSBzYWZlTm9kZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIucmVuZGVyKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHsgY2FuQ2xvc2VCeVRyaWdnZXI6IGZhbHNlIH0pKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEF1dG9Db21wbGV0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZWxlY3QvYXV0by1jb21wbGV0ZS5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cblxuXG4vKipcbiAqIFNlbGVjdC5PcHRpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3B0aW9uIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog6YCJ6aG55YC8XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogUHJvcFR5cGVzLmFueS5pc1JlcXVpcmVkLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm56aB55SoXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55XG4gICAgfVxuXG4gICAgc3RhdGljIF90eXBlTWFyayA9ICduZXh0X3NlbGVjdF9vcHRpb24nO1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2VsZWN0L29wdGlvbi5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cblxuXG4vKipcbiAqIFNlbGVjdC5PcHRpb25Hcm91cFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcHRpb25Hcm91cCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruWIhue7hOeahOaWh+ahiFxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmFueVxuICAgIH07XG5cbiAgICBzdGF0aWMgX3R5cGVNYXJrID0gJ25leHRfc2VsZWN0X29wdGlvbl9ncm91cCc7XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZWxlY3Qvb3B0aW9uLWdyb3VwLmpzeCIsImltcG9ydCAnLi4vYnV0dG9uL3N0eWxlLmpzJztcbmltcG9ydCAnLi4vaW5wdXQvc3R5bGUuanMnO1xuaW1wb3J0ICcuLi9zZWxlY3Qvc3R5bGUuanMnO1xuaW1wb3J0ICcuL21haW4uc2Nzcyc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcGFnaW5hdGlvbi9zdHlsZS5qcyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5wdXQvbWFpbi5zY3NzIiwiaW1wb3J0ICcuLi9pY29uL3N0eWxlLmpzJztcbmltcG9ydCAnLi4vdGFnL3N0eWxlLmpzJztcbmltcG9ydCAnLi4vb3ZlcmxheS9zdHlsZS5qcyc7XG5pbXBvcnQgJy4uL21lbnUvc3R5bGUuanMnO1xuaW1wb3J0ICcuLi9pbnB1dC9zdHlsZS5qcyc7XG5pbXBvcnQgJy4vbWFpbi5zY3NzJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZWxlY3Qvc3R5bGUuanMiLCJpbXBvcnQgJy4uL2ljb24vc3R5bGUuanMnO1xuaW1wb3J0ICcuLi9hbmltYXRlL3N0eWxlLmpzJztcbmltcG9ydCAnLi9tYWluLnNjc3MnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhZy9zdHlsZS5qcyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFnL21haW4uc2NzcyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2VsZWN0L21haW4uc2NzcyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcGFnaW5hdGlvbi9tYWluLnNjc3MiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9zY3JpcHRzL3NlcnZlci9sb2FkZXJzL2RlbW8vc2VsZWN0b3IuanMhLi9wYWdpbmF0aW9uLm1kXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL3NjcmlwdHMvc2VydmVyL2xvYWRlcnMvZGVtby9zZWxlY3Rvci5qcyEuL3BhZ2luYXRpb24ubWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vc2NyaXB0cy9zZXJ2ZXIvbG9hZGVycy9kZW1vL3NlbGVjdG9yLmpzIS4vcGFnaW5hdGlvbi5tZFwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAwLjE4LjJAc3R5bGUtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlciEuL3NjcmlwdHMvc2VydmVyL2xvYWRlcnMvZGVtby9zZWxlY3Rvci5qcyEuL2RvY3MvdGFibGUvZGVtby9wYWdpbmF0aW9uLm1kXG4vLyBtb2R1bGUgaWQgPSAzMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==