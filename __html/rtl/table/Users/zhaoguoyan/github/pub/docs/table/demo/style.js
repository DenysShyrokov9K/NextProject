webpackJsonp([3],[
/* 0 */
/***/ (function(module, exports) {

module.exports = window.React;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;

  var isValidElement = function isValidElement(object) {
    return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(80)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(83)();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.KEYCODE = exports.guid = exports.focus = exports.support = exports.str = exports.obj = exports.log = exports.func = exports.events = exports.env = exports.dom = undefined;

var _dom2 = __webpack_require__(40);

var _dom = _interopRequireWildcard(_dom2);

var _env2 = __webpack_require__(42);

var _env = _interopRequireWildcard(_env2);

var _events2 = __webpack_require__(86);

var _events = _interopRequireWildcard(_events2);

var _func2 = __webpack_require__(87);

var _func = _interopRequireWildcard(_func2);

var _log2 = __webpack_require__(88);

var _log = _interopRequireWildcard(_log2);

var _object2 = __webpack_require__(13);

var _object = _interopRequireWildcard(_object2);

var _string2 = __webpack_require__(41);

var _string = _interopRequireWildcard(_string2);

var _support2 = __webpack_require__(89);

var _support = _interopRequireWildcard(_support2);

var _focus2 = __webpack_require__(90);

var _focus = _interopRequireWildcard(_focus2);

var _guid2 = __webpack_require__(91);

var _guid3 = _interopRequireDefault(_guid2);

var _keycode = __webpack_require__(43);

var _keycode2 = _interopRequireDefault(_keycode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var dom = exports.dom = _dom;
var env = exports.env = _env;
var events = exports.events = _events;
var func = exports.func = _func;
var log = exports.log = _log;
var obj = exports.obj = _object;
var str = exports.str = _string;
var support = exports.support = _support;
var focus = exports.focus = _focus;
var guid = exports.guid = _guid3.default;
var KEYCODE = exports.KEYCODE = _keycode2.default;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg === 'undefined' ? 'undefined' : _typeof(arg);

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if ("function" === 'function' && _typeof(__webpack_require__(73)) === 'object' && __webpack_require__(73)) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
})();

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = window.ReactDOM;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _getContextProps = __webpack_require__(39);

var _getContextProps2 = _interopRequireDefault(_getContextProps);

var _config = __webpack_require__(84);

var _consumer = __webpack_require__(92);

var _consumer2 = _interopRequireDefault(_consumer);

var _cache = __webpack_require__(93);

var _cache2 = _interopRequireDefault(_cache);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var childContextCache = new _cache2.default();

/**
 * ConfigProvider
 * @propsExtends false
 */
var ConfigProvider = (_temp = _class = function (_Component) {
    _inherits(ConfigProvider, _Component);

    /**
     * 传入组件的 props 和 displayName，得到和 childContext 计算过的包含有 preifx/locale/pure 的对象，一般用于通过静态方法生成脱离组件树的组件
     * @param {Object} props 组件的 props
     * @param {String} displayName 组件的 displayName
     * @returns {Object} 新的 context props
     */
    function ConfigProvider() {
        _classCallCheck(this, ConfigProvider);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args)));

        childContextCache.add(_this, _extends({}, childContextCache.get(_this, {}), _this.getChildContext()));
        return _this;
    }

    /**
     * 传入组件，生成受 ConfigProvider 控制的 HOC 组件
     * @param {Component} Component 组件类
     * @param {Object} options 可选项
     * @returns {Component} HOC
     */


    ConfigProvider.prototype.getChildContext = function getChildContext() {
        var _props = this.props,
            prefix = _props.prefix,
            locale = _props.locale,
            pure = _props.pure,
            warning = _props.warning,
            rtl = _props.rtl;


        return {
            nextPrefix: prefix,
            nextLocale: locale,
            nextPure: pure,
            nextRtl: rtl,
            nextWarning: warning
        };
    };

    ConfigProvider.prototype.componentWillMount = function componentWillMount() {
        this.setMomentLocale(this.props.locale);
    };

    ConfigProvider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (this.props.locale !== nextProps.locale) {
            this.setMomentLocale(nextProps.locale);
        }
    };

    ConfigProvider.prototype.componentDidUpdate = function componentDidUpdate() {
        childContextCache.add(this, _extends({}, childContextCache.get(this, {}), this.getChildContext()));
    };

    ConfigProvider.prototype.componentWillUnmount = function componentWillUnmount() {
        childContextCache.remove(this);
    };

    ConfigProvider.prototype.setMomentLocale = function setMomentLocale(locale) {
        var moment = void 0;
        try {
            moment = __webpack_require__(94);
        } catch (e) {
            // ignore
        }

        if (moment && locale) {
            moment.locale(locale.momentLocale);
        }
    };

    ConfigProvider.prototype.render = function render() {
        return _react.Children.only(this.props.children);
    };

    return ConfigProvider;
}(_react.Component), _class.propTypes = {
    /**
     * 样式类名的品牌前缀
     */
    prefix: _propTypes2.default.string,
    /**
     * 国际化文案对象，属性为组件的 displayName
     */
    locale: _propTypes2.default.object,
    /**
     * 是否开启 Pure Render 模式，会提高性能，但是也会带来副作用
     */
    pure: _propTypes2.default.bool,
    /**
     * 是否在开发模式下显示组件属性被废弃的 warning 提示
     */
    warning: _propTypes2.default.bool,
    /**
     * 是否开启 rtl 模式
     */
    rtl: _propTypes2.default.bool,
    /**
     * 组件树
     */
    children: _propTypes2.default.element
}, _class.defaultProps = {
    warning: true
}, _class.childContextTypes = {
    nextPrefix: _propTypes2.default.string,
    nextLocale: _propTypes2.default.object,
    nextPure: _propTypes2.default.bool,
    nextRtl: _propTypes2.default.bool,
    nextWarning: _propTypes2.default.bool
}, _class.config = function (Component, options) {
    return (0, _config.config)(Component, options);
}, _class.getContextProps = function (props, displayName) {
    return (0, _getContextProps2.default)(props, childContextCache.root() || {}, displayName);
}, _class.initLocales = _config.initLocales, _class.setLanguage = _config.setLanguage, _class.setLocale = _config.setLocale, _class.setDirection = _config.setDirection, _class.getLanguage = _config.getLanguage, _class.getLocale = _config.getLocale, _class.getDirection = _config.getDirection, _class.Consumer = _consumer2.default, _class.getContext = function () {
    var _ref = childContextCache.root() || {},
        nextPrefix = _ref.nextPrefix,
        nextLocale = _ref.nextLocale,
        nextPure = _ref.nextPure,
        nextRtl = _ref.nextRtl,
        nextWarning = _ref.nextWarning;

    return {
        prefix: nextPrefix,
        locale: nextLocale,
        pure: nextPure,
        rtl: nextRtl,
        warning: nextWarning
    };
}, _temp);
ConfigProvider.displayName = 'ConfigProvider';
exports.default = ConfigProvider;
module.exports = exports['default'];

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			memo[selector] = fn.call(this, selector);
		}

		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(143);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var blackList = ['defaultProps', 'propTypes', 'contextTypes', 'childContextTypes', 'displayName'];

var statics = exports.statics = function statics(Target, Component) {
    Object.keys(Component).forEach(function (property) {
        if (blackList.indexOf(property) === -1) {
            Target[property] = Component[property];
        }
    });
};

var fetchDataByPath = exports.fetchDataByPath = function fetchDataByPath(object, path) {
    if (!object || !path) {
        return false;
    }
    path = path.toString();
    var field = path.split('.');
    var val = void 0,
        key = void 0;
    if (field.length) {
        key = field[0];
        // lists[1].name
        if (key.indexOf('[') >= 0) {
            key = key.match(/(.*)\[(.*)\]/);
            if (key) {
                val = object[key[1]][key[2]];
            }
        } else {
            val = object[field[0]];
        }
        if (val) {
            for (var colIndex = 1; colIndex < field.length; colIndex++) {
                val = val[field[colIndex]];
                if (typeof val === 'undefined') {
                    break;
                }
            }
        }
    }
    return val;
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Icon
 */
var Icon = (_temp = _class = function (_Component) {
    _inherits(Icon, _Component);

    function Icon() {
        _classCallCheck(this, Icon);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    Icon.prototype.render = function render() {
        var _cx;

        /* eslint-disable no-unused-vars*/
        var _props = this.props,
            prefix = _props.prefix,
            type = _props.type,
            size = _props.size,
            className = _props.className,
            rtl = _props.rtl,
            other = _objectWithoutProperties(_props, ['prefix', 'type', 'size', 'className', 'rtl']);

        var classes = (0, _classnames2.default)((_cx = {}, _cx[prefix + 'icon'] = true, _cx[prefix + 'icon-' + type] = !!type, _cx['' + prefix + size] = !!size, _cx[className] = !!className, _cx));

        if (rtl && ['arrow-left', 'arrow-right', 'arrow-double-left', 'arrow-double-right', 'switch', 'sorting', 'descending', 'ascending'].indexOf(type) !== -1) {
            other.dir = 'rtl';
        }

        return _react2.default.createElement('i', _extends({}, other, { className: classes }));
    };

    return Icon;
}(_react.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    rtl: _propTypes2.default.bool,
    /**
     * 指定显示哪种图标
     */
    type: _propTypes2.default.string,
    /**
     * 指定图标大小
     */
    size: _propTypes2.default.oneOf(['xxs', 'xs', 'small', 'medium', 'large', 'xl', 'xxl', 'xxxl']),
    className: _propTypes2.default.string
}, _class.defaultProps = {
    prefix: 'next-',
    size: 'medium'
}, _class._typeMark = 'icon', _temp);
Icon.displayName = 'Icon';
exports.default = _configProvider2.default.config(Icon);
module.exports = exports['default'];

/***/ }),
/* 10 */,
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(142);

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(144);

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.typeOf = typeOf;
exports.isArrayLike = isArrayLike;
exports.isPromise = isPromise;
exports.isPlainObject = isPlainObject;
exports.shallowEqual = shallowEqual;
exports.each = each;
exports.pickOthers = pickOthers;
exports.pickAttrsWith = pickAttrsWith;
/**
 * 获取对象的类型
 * @param  {*} obj
 * @return {String}
 *
 * @example
 * typeOf([]) === 'Array'
 * typeOf() === 'Undefined'
 * typeOf(1) === 'Number'
 */
function typeOf(obj) {
    return Object.prototype.toString.call(obj).replace(/\[object\s|]/g, '');
}

/**
 * 判断是否是数组或类数组对象
 * @param  {*}  obj
 * @return {Boolean}
 *
 * @example
 * isArrayLike([]) === true
 * isArrayLike(arguments) === true
 * isArrayLike(this.props.children) === true
 */
function isArrayLike(obj) {
    var length = !!obj && 'length' in obj && obj.length;
    var type = typeOf(obj);

    return type === 'Array' || length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj;
}

/**
 * 判断对象是否是一个promise，即是否可以用.then
 * @param  {*}  obj
 * @return {Boolean}
 */
function isPromise(obj) {
    return !!obj && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}

/**
 * 是否是一个纯净的对象
 * @param  {*}  obj
 * @return {Boolean}
 * @reference https://github.com/jonschlinkert/is-plain-object
 */
function isPlainObject(obj) {
    if (typeOf(obj) !== 'Object') {
        return false;
    }

    var ctor = obj.constructor;

    if (typeof ctor !== 'function') {
        return false;
    }

    var prot = ctor.prototype;

    if (typeOf(prot) !== 'Object') {
        return false;
    }

    if (!prot.hasOwnProperty('isPrototypeOf')) {
        return false;
    }

    return true;
}

/**
 * 对象浅比较
 * @param  {Object} objA
 * @param  {Object} objB
 * @param  {Function}  [compare] 手动调用方法比较
 * @return {Boolean}      对象浅比较是否相等
 *
 * @example
 * object.shallowEqual({a: 100}, {a: 100}); // true
 */
function shallowEqual(objA, objB, compare) {
    if (objA === objB) {
        return true;
    }

    // 其中一个不是object，则不相等
    if (!objA || !objB || (typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) + (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'objectobject') {
        return false;
    }

    var keyA = Object.keys(objA);
    var keyB = Object.keys(objB);
    var len = keyA.length;

    // key 数量不一致则不相等
    if (len !== keyB.length) {
        return false;
    }

    var hasCallback = typeof compare === 'function';

    for (var i = 0; i < len; i++) {
        var key = keyA[i];

        if (!Object.prototype.hasOwnProperty.call(objB, key)) {
            return false;
        }

        var valA = objA[key];
        var valB = objB[key];

        var ret = hasCallback ? compare(valA, valB, key) : void 0;

        if (ret === false || ret === void 0 && valA !== valB) {
            return false;
        }
    }

    return true;
}

/**
 * 遍历对象或数组，或者类数组，例如React中的children对象、arguments等
 * @param  {Object|Array}   obj
 * @param  {Function} callback fn(n, i) or fn(val, key)
 * @param  {Number}   [direction = 1] 是否倒序遍历，只对数组有效
 * @return {Object|Array}
 *
 * @example
 * // 遍历数组
 * object.each([100, 200, 300], (n, i) => console.log(n, i));
 * // 遍历json对象
 * object.each({a: 100, b: 200}, (value, key) => console.log(key, value));
 * // 遍历React子节点
 * object.each(this.props.children, (child, index) => console.log(child));
 * // 遍历arguments
 * object.each(arguments, (arg, i) => console.log(arg));
 */
function each(obj, callback, direction) {
    var reversed = direction === -1;
    var length = obj.length;
    var value = void 0,
        i = reversed ? length - 1 : 0;

    if (isArrayLike(obj)) {
        for (; i < length && i >= 0; reversed ? i-- : i++) {
            value = callback.call(obj[i], obj[i], i);

            if (value === false) {
                break;
            }
        }
    } else {
        for (i in obj) {
            /* istanbul ignore else */
            if (obj.hasOwnProperty(i)) {
                value = callback.call(obj[i], obj[i], i);

                if (value === false) {
                    break;
                }
            }
        }
    }

    return obj;
}

// @private 判断key是否在数组或对象中
var _isInObj = function _isInObj(key, obj, isArray) {
    return isArray ? obj.indexOf(key) > -1 : key in obj;
};

/**
 * 过滤出其它属性
 * @param  {Object|Array} holdProps 过滤的参照对象，最终的结果只保留不在参照对象中的key
 * @param  {Object} props     被过滤的对象
 * @return {Object}           others
 *
 * @example
 * object.pickOthers(FooComponent.propTypes, this.props);
 * object.pickOthers(['className', 'onChange'], this.props);
 */
function pickOthers(holdProps, props) {
    var others = {};
    var isArray = typeOf(holdProps) === 'Array';

    for (var key in props) {
        if (!_isInObj(key, holdProps, isArray)) {
            others[key] = props[key];
        }
    }

    return others;
}

/**
 * 过滤出带prefix的属性
 * @param  {Object} holdProps 过滤的参照对象，最终的结果只保留不在参照对象中的key
 * @param  {string} prefix    包含的字符串
 * @return {Object}           others
 *
 * @example
 * object.pickAttrsWith(FooComponent.propTypes, 'data-');
 */
function pickAttrsWith(holdProps, prefix) {
    var others = {};

    for (var key in holdProps) {
        if (key.match(prefix)) {
            others[key] = holdProps[key];
        }
    }

    return others;
}

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var bindCtx = _util.func.bindCtx;
var pickOthers = _util.obj.pickOthers;
var Item = (_temp = _class = function (_Component) {
    _inherits(Item, _Component);

    function Item(props) {
        _classCallCheck(this, Item);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        bindCtx(_this, ['handleClick', 'handleKeyDown']);
        return _this;
    }

    Item.prototype.componentDidMount = function componentDidMount() {
        this.itemNode = (0, _reactDom.findDOMNode)(this);

        var _props = this.props,
            parentMode = _props.parentMode,
            root = _props.root;

        if (parentMode === 'popup') {
            this.menuNode = this.itemNode.parentNode;
        } else {
            this.menuNode = (0, _reactDom.findDOMNode)(root);
            var _root$props = root.props,
                prefix = _root$props.prefix,
                header = _root$props.header,
                footer = _root$props.footer;

            if (header || footer) {
                this.menuNode = this.menuNode.querySelector('.' + prefix + 'menu-content');
            }
        }

        this.setFocus();
    };

    Item.prototype.componentDidUpdate = function componentDidUpdate() {
        this.setFocus();
    };

    Item.prototype.focusable = function focusable() {
        var _props2 = this.props,
            root = _props2.root,
            type = _props2.type,
            disabled = _props2.disabled;
        var focusable = root.props.focusable;

        return focusable && (type === 'submenu' || !disabled);
    };

    Item.prototype.getFocused = function getFocused() {
        var _props3 = this.props,
            _key = _props3._key,
            root = _props3.root;
        var focusedKey = root.state.focusedKey;

        return focusedKey === _key;
    };

    Item.prototype.setFocus = function setFocus() {
        var focused = this.getFocused();
        if (focused) {
            if (this.focusable()) {
                this.itemNode.focus({ preventScroll: true });
            }
            if (this.menuNode && this.menuNode.scrollHeight > this.menuNode.clientHeight) {
                var scrollBottom = this.menuNode.clientHeight + this.menuNode.scrollTop;
                var itemBottom = this.itemNode.offsetTop + this.itemNode.offsetHeight;
                if (itemBottom > scrollBottom) {
                    this.menuNode.scrollTop = itemBottom - this.menuNode.clientHeight;
                } else if (this.itemNode.offsetTop < this.menuNode.scrollTop) {
                    this.menuNode.scrollTop = this.itemNode.offsetTop;
                }
            }
        }
    };

    Item.prototype.handleClick = function handleClick(e) {
        e.stopPropagation();

        var _props4 = this.props,
            _key = _props4._key,
            root = _props4.root,
            disabled = _props4.disabled;


        if (!disabled) {
            root.handleItemClick(_key, this, e);

            this.props.onClick && this.props.onClick(e);
        } else {
            e.preventDefault();
        }
    };

    Item.prototype.handleKeyDown = function handleKeyDown(e) {
        var _props5 = this.props,
            _key = _props5._key,
            root = _props5.root,
            type = _props5.type;

        if (this.focusable()) {
            root.handleItemKeyDown(_key, type, this, e);
        }

        this.props.onKeyDown && this.props.onKeyDown(e);
    };

    Item.prototype.getTitle = function getTitle(children) {
        var labelString = '';

        var loop = function loop(children) {
            _react.Children.forEach(children, function (child) {
                if ((0, _react.isValidElement)(child) && child.props.children) {
                    loop(child.props.children);
                } else if (typeof child === 'string') {
                    labelString += child;
                }
            });
        };

        loop(children);

        return labelString;
    };

    Item.prototype.render = function render() {
        var _cx;

        var _props6 = this.props,
            level = _props6.level,
            root = _props6.root,
            replaceClassName = _props6.replaceClassName,
            groupIndent = _props6.groupIndent,
            component = _props6.component,
            disabled = _props6.disabled,
            className = _props6.className,
            children = _props6.children,
            needIndent = _props6.needIndent,
            parentMode = _props6.parentMode,
            _key = _props6._key;

        var others = pickOthers(Object.keys(Item.propTypes), this.props);

        var _root$props2 = root.props,
            prefix = _root$props2.prefix,
            focusable = _root$props2.focusable,
            inlineIndent = _root$props2.inlineIndent,
            itemClassName = _root$props2.itemClassName,
            rtl = _root$props2.rtl;

        var focused = this.getFocused();

        var newClassName = replaceClassName ? className : (0, _classnames2.default)((_cx = {}, _cx[prefix + 'menu-item'] = true, _cx[prefix + 'disabled'] = disabled, _cx[prefix + 'focused'] = !focusable && focused, _cx[itemClassName] = !!itemClassName, _cx[className] = !!className, _cx));
        if (disabled) {
            others['aria-disabled'] = true;
        }

        others.tabIndex = root.tabbableKey === _key ? '0' : '-1';

        if (parentMode === 'inline' && level > 1 && inlineIndent > 0 && needIndent) {
            var _extends2;

            others.style = _extends({}, others.style || {}, (_extends2 = {}, _extends2[rtl ? 'paddingRight' : 'paddingLeft'] = level * inlineIndent - (groupIndent || 0) * 0.4 * inlineIndent + 'px', _extends2));
        }
        var TagName = component;

        return _react2.default.createElement(
            TagName,
            _extends({ role: 'menuitem',
                title: this.getTitle(children)
            }, others, {
                className: newClassName,
                onClick: this.handleClick,
                onKeyDown: this.handleKeyDown }),
            _react2.default.createElement(
                'div',
                { className: prefix + 'menu-item-inner' },
                children
            )
        );
    };

    return Item;
}(_react.Component), _class.propTypes = {
    _key: _propTypes2.default.string,
    level: _propTypes2.default.number,
    groupIndent: _propTypes2.default.number,
    root: _propTypes2.default.object,
    parent: _propTypes2.default.object,
    parentMode: _propTypes2.default.oneOf(['inline', 'popup']),
    type: _propTypes2.default.oneOf(['submenu', 'item']),
    component: _propTypes2.default.string,
    disabled: _propTypes2.default.bool,
    className: _propTypes2.default.string,
    onClick: _propTypes2.default.func,
    onKeyDown: _propTypes2.default.func,
    needIndent: _propTypes2.default.bool,
    replaceClassName: _propTypes2.default.bool
}, _class.defaultProps = {
    component: 'li',
    groupIndent: 0,
    replaceClassName: false,
    needIndent: true
}, _temp);
Item.displayName = 'Item';
exports.default = Item;
module.exports = exports['default'];

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _overlay = __webpack_require__(45);

var _overlay2 = _interopRequireDefault(_overlay);

var _gateway = __webpack_require__(46);

var _gateway2 = _interopRequireDefault(_gateway);

var _position = __webpack_require__(47);

var _position2 = _interopRequireDefault(_position);

var _popup = __webpack_require__(99);

var _popup2 = _interopRequireDefault(_popup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_overlay2.default.Gateway = _gateway2.default;
_overlay2.default.Position = _position2.default;
_overlay2.default.Popup = _configProvider2.default.config(_popup2.default, {
    exportNames: ['overlay']
});

exports.default = _configProvider2.default.config(_overlay2.default, {
    exportNames: ['getContent', 'getContentNode']
});
module.exports = exports['default'];

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _row = __webpack_require__(17);

var _row2 = _interopRequireDefault(_row);

var _cell = __webpack_require__(18);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};

var Body = (_temp2 = _class = function (_React$Component) {
    _inherits(Body, _React$Component);

    function Body() {
        var _temp, _this, _ret;

        _classCallCheck(this, Body);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.getRowRef = function (i, row) {
            _this.props.rowRef(i, row);
        }, _this.onRowClick = function (record, index, e) {
            _this.props.onRowClick(record, index, e);
        }, _this.onRowMouseEnter = function (record, index, e) {
            _this.props.onRowMouseEnter(record, index, e);
        }, _this.onRowMouseLeave = function (record, index, e) {
            _this.props.onRowMouseLeave(record, index, e);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Body.prototype.render = function render() {
        var _this2 = this;

        /*eslint-disable no-unused-vars */
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            children = _props.children,
            Tag = _props.component,
            colGroup = _props.colGroup,
            loading = _props.loading,
            emptyContent = _props.emptyContent,
            components = _props.components,
            getCellProps = _props.getCellProps,
            primaryKey = _props.primaryKey,
            getRowProps = _props.getRowProps,
            dataSource = _props.dataSource,
            cellRef = _props.cellRef,
            columns = _props.columns,
            rowRef = _props.rowRef,
            onRowClick = _props.onRowClick,
            onRowMouseEnter = _props.onRowMouseEnter,
            onRowMouseLeave = _props.onRowMouseLeave,
            locale = _props.locale,
            pure = _props.pure,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'children', 'component', 'colGroup', 'loading', 'emptyContent', 'components', 'getCellProps', 'primaryKey', 'getRowProps', 'dataSource', 'cellRef', 'columns', 'rowRef', 'onRowClick', 'onRowMouseEnter', 'onRowMouseLeave', 'locale', 'pure']);

        var _components$Row = components.Row,
            Row = _components$Row === undefined ? _row2.default : _components$Row,
            _components$Cell = components.Cell,
            Cell = _components$Cell === undefined ? _cell2.default : _components$Cell;

        var empty = loading ? _react2.default.createElement(
            'span',
            null,
            '\xA0'
        ) : emptyContent || locale.empty;
        var rows = _react2.default.createElement(
            'tr',
            null,
            _react2.default.createElement(
                'td',
                { colSpan: columns.length },
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'table-empty' },
                    empty
                )
            )
        );
        if (Tag === 'div') {
            rows = _react2.default.createElement(
                'table',
                { role: 'table' },
                _react2.default.createElement(
                    'tbody',
                    null,
                    rows
                )
            );
        }
        if (dataSource.length) {
            rows = dataSource.map(function (record, index) {
                var _classnames;

                var rowProps = getRowProps(record, index) || {};
                var rowClass = rowProps.className;
                var className = (0, _classnames3.default)((_classnames = {
                    first: index === 0,
                    last: index === dataSource.length - 1
                }, _classnames[rowClass] = rowClass, _classnames));
                var expanded = record.__expanded ? 'expanded' : '';
                return _react2.default.createElement(Row, _extends({ key: '' + (record[primaryKey] || index) + expanded
                }, rowProps, {
                    ref: _this2.getRowRef.bind(_this2, index),
                    colGroup: colGroup,
                    columns: columns,
                    primaryKey: primaryKey,
                    record: record,
                    rowIndex: index,
                    prefix: prefix,
                    pure: pure,
                    cellRef: cellRef,
                    getCellProps: getCellProps,
                    className: className,
                    Cell: Cell,
                    onClick: _this2.onRowClick,
                    locale: locale,
                    onMouseEnter: _this2.onRowMouseEnter,
                    onMouseLeave: _this2.onRowMouseLeave
                }));
            });
        }
        return _react2.default.createElement(
            Tag,
            _extends({ className: className }, others),
            rows,
            children
        );
    };

    return Body;
}(_react2.default.Component), _class.propTypes = {
    loading: _propTypes2.default.bool,
    emptyContent: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    components: _propTypes2.default.object,
    getCellProps: _propTypes2.default.func,
    cellRef: _propTypes2.default.func,
    primaryKey: _propTypes2.default.string,
    getRowProps: _propTypes2.default.func,
    rowRef: _propTypes2.default.func,
    dataSource: _propTypes2.default.array,
    children: _propTypes2.default.any,
    className: _propTypes2.default.string,
    component: _propTypes2.default.string,
    colGroup: _propTypes2.default.object,
    columns: _propTypes2.default.array,
    onRowClick: _propTypes2.default.func,
    onRowMouseEnter: _propTypes2.default.func,
    onRowMouseLeave: _propTypes2.default.func,
    locale: _propTypes2.default.object
}, _class.defaultProps = {
    loading: false,
    prefix: 'next-',
    components: {},
    getCellProps: noop,
    cellRef: noop,
    primaryKey: 'id',
    getRowProps: noop,
    rowRef: noop,
    dataSource: [],
    component: 'tbody',
    columns: []
}, _temp2);
Body.displayName = 'Body';
exports.default = Body;
module.exports = exports['default'];

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames3 = __webpack_require__(3);

var _classnames4 = _interopRequireDefault(_classnames3);

var _util = __webpack_require__(2);

var _util2 = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};

var Row = (_temp2 = _class = function (_React$Component) {
    _inherits(Row, _React$Component);

    function Row() {
        var _temp, _this, _ret;

        _classCallCheck(this, Row);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onClick = function (e) {
            var _this$props = _this.props,
                record = _this$props.record,
                rowIndex = _this$props.rowIndex;

            _this.props.onClick(record, rowIndex, e);
        }, _this.onMouseEnter = function (e) {
            var _this$props2 = _this.props,
                record = _this$props2.record,
                rowIndex = _this$props2.rowIndex;

            _this.onRowHover(record, rowIndex, true, e);
        }, _this.onMouseLeave = function (e) {
            var _this$props3 = _this.props,
                record = _this$props3.record,
                rowIndex = _this$props3.rowIndex;

            _this.onRowHover(record, rowIndex, false, e);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Row.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
        if (nextProps.pure) {
            var isEqual = _util.obj.shallowEqual(this.props, nextProps);
            return !isEqual;
        }

        return true;
    };

    Row.prototype.onRowHover = function onRowHover(record, index, isEnter, e) {
        var _props = this.props,
            onMouseEnter = _props.onMouseEnter,
            onMouseLeave = _props.onMouseLeave,
            currentRow = (0, _reactDom.findDOMNode)(this);

        if (isEnter) {
            onMouseEnter(record, index, e);
            currentRow && _util.dom.addClass(currentRow, 'hovered');
        } else {
            onMouseLeave(record, index, e);
            currentRow && _util.dom.removeClass(currentRow, 'hovered');
        }
    };

    Row.prototype.renderCells = function renderCells(record) {
        var _this2 = this;

        var _props2 = this.props,
            Cell = _props2.Cell,
            columns = _props2.columns,
            getCellProps = _props2.getCellProps,
            cellRef = _props2.cellRef,
            prefix = _props2.prefix,
            rowIndex = _props2.rowIndex,
            primaryKey = _props2.primaryKey,
            pure = _props2.pure,
            locale = _props2.locale;
        var lockType = this.context.lockType;

        return columns.map(function (child, colIndex) {
            var _classnames;

            var dataIndex = child.dataIndex,
                align = child.align,
                width = child.width,
                others = _objectWithoutProperties(child, ['dataIndex', 'align', 'width']);

            var value = (0, _util2.fetchDataByPath)(record, dataIndex);
            var attrs = getCellProps(rowIndex, colIndex, dataIndex, record) || {};

            if (_this2.context.notRenderCellIndex) {
                var matchCellIndex = _this2.context.notRenderCellIndex.map(function (cellIndex) {
                    return cellIndex.toString();
                }).indexOf([rowIndex, colIndex].toString());
                if (matchCellIndex > -1) {
                    _this2.context.notRenderCellIndex.splice(matchCellIndex, 1);
                    return null;
                }
            }
            if (attrs.colSpan && attrs.colSpan > 1 || attrs.rowSpan && attrs.rowSpan > 1) {
                _this2._getNotRenderCellIndex(colIndex, rowIndex, attrs.colSpan || 1, attrs.rowSpan || 1);
            }

            var className = (0, _classnames4.default)((_classnames = {
                first: lockType !== 'right' && colIndex === 0,
                last: lockType !== 'left' && (colIndex === columns.length - 1 || colIndex + attrs.colSpan === columns.length) }, _classnames[child.className] = child.className, _classnames));

            return _react2.default.createElement(Cell, _extends({ key: colIndex
            }, others, attrs, {
                ref: function ref(cell) {
                    return cellRef(rowIndex, colIndex, cell);
                },
                prefix: prefix,
                pure: pure,
                primaryKey: primaryKey,
                record: record,
                className: className,
                value: value,
                colIndex: colIndex,
                rowIndex: rowIndex,
                align: align,
                locale: locale,
                width: width
            }));
        });
    };

    Row.prototype._getNotRenderCellIndex = function _getNotRenderCellIndex(colIndex, rowIndex, colSpan, rowSpan) {
        var maxColIndex = colSpan;
        var maxRowIndex = rowSpan;
        var notRenderCellIndex = [];
        for (var i = 0; i < maxColIndex; i++) {
            for (var j = 0; j < maxRowIndex; j++) {
                notRenderCellIndex.push([rowIndex + j, colIndex + i]);
            }
        }
        [].push.apply(this.context.notRenderCellIndex, notRenderCellIndex);
    };

    Row.prototype.render = function render() {
        var _classnames2;

        /* eslint-disable no-unused-vars*/
        var _props3 = this.props,
            prefix = _props3.prefix,
            className = _props3.className,
            onClick = _props3.onClick,
            onMouseEnter = _props3.onMouseEnter,
            onMouseLeave = _props3.onMouseLeave,
            columns = _props3.columns,
            Cell = _props3.Cell,
            getCellProps = _props3.getCellProps,
            rowIndex = _props3.rowIndex,
            record = _props3.record,
            children = _props3.children,
            primaryKey = _props3.primaryKey,
            cellRef = _props3.cellRef,
            colGroup = _props3.colGroup,
            pure = _props3.pure,
            others = _objectWithoutProperties(_props3, ['prefix', 'className', 'onClick', 'onMouseEnter', 'onMouseLeave', 'columns', 'Cell', 'getCellProps', 'rowIndex', 'record', 'children', 'primaryKey', 'cellRef', 'colGroup', 'pure']);

        var cls = (0, _classnames4.default)((_classnames2 = {}, _classnames2[prefix + 'table-row'] = true, _classnames2[className] = className, _classnames2));
        return _react2.default.createElement(
            'tr',
            _extends({ className: cls, role: 'row' }, others, {
                onClick: this.onClick, onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave }),
            this.renderCells(record),
            children
        );
    };

    return Row;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    primaryKey: _propTypes2.default.string,
    className: _propTypes2.default.string,
    columns: _propTypes2.default.array,
    record: _propTypes2.default.any,
    Cell: _propTypes2.default.func,
    rowIndex: _propTypes2.default.number,
    getCellProps: _propTypes2.default.func,
    onClick: _propTypes2.default.func,
    onMouseEnter: _propTypes2.default.func,
    onMouseLeave: _propTypes2.default.func,
    children: _propTypes2.default.any,
    cellRef: _propTypes2.default.func,
    colGroup: _propTypes2.default.object,
    locale: _propTypes2.default.object
}, _class.defaultProps = {
    prefix: 'next-',
    primaryKey: 'id',
    columns: [],
    record: {},
    getCellProps: noop,
    onClick: noop,
    onMouseEnter: noop,
    onMouseLeave: noop,
    cellRef: noop,
    colGroup: {}
}, _class.contextTypes = {
    notRenderCellIndex: _propTypes2.default.array,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}, _temp2);
Row.displayName = 'Row';
exports.default = Row;
module.exports = exports['default'];

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var Cell = (_temp = _class = function (_React$Component) {
    _inherits(Cell, _React$Component);

    function Cell() {
        _classCallCheck(this, Cell);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    Cell.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
        if (nextProps.pure) {
            var isEqual = _util.obj.shallowEqual(this.props, nextProps);
            return !isEqual;
        }
        return true;
    };

    Cell.prototype.render = function render() {
        var _classnames;

        /* eslint-disable no-unused-vars */
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            cell = _props.cell,
            value = _props.value,
            resizable = _props.resizable,
            colIndex = _props.colIndex,
            rowIndex = _props.rowIndex,
            record = _props.record,
            context = _props.context,
            align = _props.align,
            _props$style = _props.style,
            style = _props$style === undefined ? {} : _props$style,
            Tag = _props.component,
            children = _props.children,
            title = _props.title,
            width = _props.width,
            innerStyle = _props.innerStyle,
            primaryKey = _props.primaryKey,
            __normalized = _props.__normalized,
            filterMode = _props.filterMode,
            filters = _props.filters,
            sortable = _props.sortable,
            lock = _props.lock,
            pure = _props.pure,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'cell', 'value', 'resizable', 'colIndex', 'rowIndex', 'record', 'context', 'align', 'style', 'component', 'children', 'title', 'width', 'innerStyle', 'primaryKey', '__normalized', 'filterMode', 'filters', 'sortable', 'lock', 'pure']);

        var tagStyle = _extends({}, style);
        var cellProps = { value: value, index: rowIndex, record: record, context: context };
        var content = cell;
        if (_react2.default.isValidElement(content)) {
            content = _react2.default.cloneElement(content, cellProps);
        } else if (typeof content === 'function') {
            content = content(value, rowIndex, record, context);
        }
        if (align) {
            tagStyle.textAlign = align;
        }
        var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-cell'] = true, _classnames[className] = className, _classnames));

        return _react2.default.createElement(
            Tag,
            _extends({}, others, { className: cls, style: tagStyle, role: 'gridcell' }),
            _react2.default.createElement(
                'div',
                { className: prefix + 'table-cell-wrapper', style: innerStyle },
                content,
                children
            )
        );
    };

    return Cell;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    primaryKey: _propTypes2.default.string,
    className: _propTypes2.default.string,
    record: _propTypes2.default.any,
    value: _propTypes2.default.any,
    colIndex: _propTypes2.default.number,
    rowIndex: _propTypes2.default.number,
    title: _propTypes2.default.any,
    width: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    context: _propTypes2.default.any,
    cell: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.node, _propTypes2.default.func]),
    align: _propTypes2.default.oneOf(['left', 'center', 'right']),
    component: _propTypes2.default.oneOf(['td', 'th', 'div']),
    children: _propTypes2.default.any,
    style: _propTypes2.default.object,
    innerStyle: _propTypes2.default.object,
    filterMode: _propTypes2.default.oneOf(['single', 'multiple']),
    filters: _propTypes2.default.array,
    sortable: _propTypes2.default.bool,
    lock: _propTypes2.default.any,
    type: _propTypes2.default.oneOf(['header', 'body']),
    resizable: _propTypes2.default.bool,
    __normalized: _propTypes2.default.bool
}, _class.defaultProps = {
    component: 'td',
    type: 'body',
    cell: function cell(value) {
        return value;
    },
    prefix: 'next-'
}, _temp);
Cell.displayName = 'Cell';
exports.default = Cell;
module.exports = exports['default'];

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _header = __webpack_require__(48);

var _header2 = _interopRequireDefault(_header);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var FixedHeader = (_temp = _class = function (_React$Component) {
    _inherits(FixedHeader, _React$Component);

    function FixedHeader() {
        _classCallCheck(this, FixedHeader);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    FixedHeader.prototype.componentDidMount = function componentDidMount() {
        this.context.getNode('header', (0, _reactDom.findDOMNode)(this));
    };

    FixedHeader.prototype.render = function render() {
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            colGroup = _props.colGroup,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'colGroup']);

        return _react2.default.createElement(
            'div',
            { className: className },
            _react2.default.createElement(
                'div',
                { className: prefix + 'table-header-inner' },
                _react2.default.createElement(
                    'table',
                    null,
                    colGroup,
                    _react2.default.createElement(_header2.default, _extends({}, others, { prefix: prefix }))
                )
            )
        );
    };

    return FixedHeader;
}(_react2.default.Component), _class.propTypes = {
    children: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    className: _propTypes2.default.string,
    colGroup: _propTypes2.default.any
}, _class.contextTypes = {
    getNode: _propTypes2.default.func,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}, _temp);
FixedHeader.displayName = 'FixedHeader';
exports.default = FixedHeader;
module.exports = exports['default'];

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = findNode;

var _reactDom = __webpack_require__(4);

function findNode(target, param) {
    if (!target) {
        return null;
    }

    if (typeof target === 'string') {
        return document.getElementById(target);
    }

    if (typeof target === 'function') {
        target = target(param);
    }

    if (!target) {
        return null;
    }

    try {
        return (0, _reactDom.findDOMNode)(target);
    } catch (err) {
        return target;
    }
}
module.exports = exports['default'];

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

var _item = __webpack_require__(14);

var _item2 = _interopRequireDefault(_item);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var bindCtx = _util.func.bindCtx;
var pickOthers = _util.obj.pickOthers;

/**
 * Menu.Item
 * @order 0
 */

var SelectableItem = (_temp = _class = function (_Component) {
    _inherits(SelectableItem, _Component);

    function SelectableItem(props) {
        _classCallCheck(this, SelectableItem);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        bindCtx(_this, ['handleKeyDown', 'handleClick']);
        return _this;
    }

    SelectableItem.prototype.getSelected = function getSelected() {
        var _props = this.props,
            _key = _props._key,
            root = _props.root,
            selected = _props.selected;
        var selectMode = root.props.selectMode;
        var selectedKeys = root.state.selectedKeys;

        return selected || !!selectMode && selectedKeys.indexOf(_key) > -1;
    };

    SelectableItem.prototype.handleSelect = function handleSelect(e) {
        var _props2 = this.props,
            _key = _props2._key,
            root = _props2.root,
            onSelect = _props2.onSelect;

        if (onSelect) {
            onSelect(!this.getSelected(), this, e);
        } else {
            root.handleSelect(_key, !this.getSelected(), this);
        }
    };

    SelectableItem.prototype.handleKeyDown = function handleKeyDown(e) {
        if (e.keyCode === _util.KEYCODE.SPACE) {
            this.handleSelect(e);
        }

        this.props.onKeyDown && this.props.onKeyDown(e);
    };

    SelectableItem.prototype.handleClick = function handleClick(e) {
        this.handleSelect(e);

        this.props.onClick && this.props.onClick(e);
    };

    SelectableItem.prototype.renderSelectedIcon = function renderSelectedIcon(selected) {
        var _props3 = this.props,
            root = _props3.root,
            inlineIndent = _props3.inlineIndent,
            needIndent = _props3.needIndent,
            hasSelectedIcon = _props3.hasSelectedIcon;
        var _root$props = root.props,
            prefix = _root$props.prefix,
            rootSelectedIcon = _root$props.hasSelectedIcon;


        return ('hasSelectedIcon' in this.props ? hasSelectedIcon : rootSelectedIcon) && selected ? _react2.default.createElement(_icon2.default, { style: needIndent && inlineIndent > 0 ? { left: inlineIndent + 'px' } : null, className: prefix + 'menu-icon-selected', type: 'select' }) : null;
    };

    SelectableItem.prototype.render = function render() {
        var _cx;

        var _props4 = this.props,
            _key = _props4._key,
            root = _props4.root,
            className = _props4.className,
            disabled = _props4.disabled,
            helper = _props4.helper,
            children = _props4.children,
            needIndent = _props4.needIndent;
        var prefix = root.props.prefix;

        var others = pickOthers(Object.keys(SelectableItem.propTypes), this.props);
        var selected = this.getSelected();

        var newProps = _extends({
            _key: _key,
            root: root,
            disabled: disabled,
            type: 'item',
            className: (0, _classnames2.default)((_cx = {}, _cx[prefix + 'selected'] = selected, _cx[className] = !!className, _cx)),
            onKeyDown: this.handleKeyDown,
            onClick: !disabled ? this.handleClick : this.props.onClick,
            needIndent: needIndent,
            'aria-selected': selected
        }, others);

        return _react2.default.createElement(
            _item2.default,
            newProps,
            this.renderSelectedIcon(selected),
            _react2.default.createElement(
                'span',
                { className: prefix + 'menu-item-text' },
                children
            ),
            helper ? _react2.default.createElement(
                'div',
                { className: prefix + 'menu-item-helper' },
                helper
            ) : null
        );
    };

    return SelectableItem;
}(_react.Component), _class.menuChildType = 'item', _class.propTypes = {
    _key: _propTypes2.default.string,
    root: _propTypes2.default.object,
    selected: _propTypes2.default.bool,
    onSelect: _propTypes2.default.func,
    inlineIndent: _propTypes2.default.number,
    /**
     * 是否禁用
     */
    disabled: _propTypes2.default.bool,
    /**
     * 帮助文本
     */
    helper: _propTypes2.default.node,
    /**
     * 菜单项标签内容
     */
    children: _propTypes2.default.node,
    className: _propTypes2.default.string,
    onKeyDown: _propTypes2.default.func,
    onClick: _propTypes2.default.func,
    needIndent: _propTypes2.default.bool,
    hasSelectedIcon: _propTypes2.default.bool
}, _class.defaultProps = {
    disabled: false,
    needIndent: true
}, _temp);
SelectableItem.displayName = 'SelectableItem';
exports.default = SelectableItem;
module.exports = exports['default'];

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Table.Column
 * @order 0
 **/
var Column = (_temp = _class = function (_React$Component) {
  _inherits(Column, _React$Component);

  function Column() {
    _classCallCheck(this, Column);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Column.prototype.render = function render() {
    return null;
  };

  return Column;
}(_react2.default.Component), _class.propTypes = {
  /**
   * 指定列对应的字段，支持`a.b`形式的快速取值
   */
  dataIndex: _propTypes2.default.string,
  /**
   * 行渲染的逻辑
   * value, rowIndex, record, context四个属性只可读不可被更改
   * Function(value, index, record) => Element
   */
  cell: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.node, _propTypes2.default.func]),
  /**
   * 表头显示的内容
   * value, rowIndex, record, context四个属性只可读不可被更改
   */
  title: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.node, _propTypes2.default.func]),
  /**
   * 是否支持排序
   */
  sortable: _propTypes2.default.bool,
  /**
   * 列宽，注意在锁列的情况下一定需要配置宽度
   */
  width: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
  /**
   * 单元格的对齐方式
   */
  align: _propTypes2.default.oneOf(['left', 'center', 'right']),
  /**
   * 生成标题过滤的菜单, 格式为`[{label:'xxx', value:'xxx'}]`
   */
  filters: _propTypes2.default.arrayOf(_propTypes2.default.shape({
    label: _propTypes2.default.string,
    value: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.string])
  })),
  /**
   * 过滤的模式是单选还是多选
   */
  filterMode: _propTypes2.default.oneOf(['single', 'multiple']),
  /**
   * 是否支持锁列,可选值为`left`,`right`, `true`
   */
  lock: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.string]),
  /**
   * 是否支持列宽调整, 当该值设为true，table的布局方式会修改为fixed.
   */
  resizable: _propTypes2.default.bool
}, _class.contextTypes = {
  parent: _propTypes2.default.any
}, _class.defaultProps = {
  cell: function cell(value) {
    return value;
  },
  filterMode: 'multiple',
  resizable: false
}, _class._typeMark = 'column', _temp);
Column.displayName = 'Column';
exports.default = Column;
module.exports = exports['default'];

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var FixedWrapper = (_temp = _class = function (_React$Component) {
    _inherits(FixedWrapper, _React$Component);

    function FixedWrapper() {
        _classCallCheck(this, FixedWrapper);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    FixedWrapper.prototype.render = function render() {
        var _props = this.props,
            children = _props.children,
            wrapperContent = _props.wrapperContent,
            prefix = _props.prefix;

        return _react2.default.createElement(
            'div',
            { className: prefix + 'table-inner' },
            children,
            wrapperContent
        );
    };

    return FixedWrapper;
}(_react2.default.Component), _class.propTypes = {
    children: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    colGroup: _propTypes2.default.any,
    wrapperContent: _propTypes2.default.any
}, _temp);
FixedWrapper.displayName = 'FixedWrapper';
exports.default = FixedWrapper;
module.exports = exports['default'];

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n.next-icon[dir=\"rtl\"]::before {\n  -webkit-transform: rotateY(180deg);\n          transform: rotateY(180deg); }\n\n@font-face {\n  font-family: NextIcon;\n  src: url(\"//at.alicdn.com/t/font_515771_emcns5054x3whfr.eot\");\n  src: url(\"//at.alicdn.com/t/font_515771_emcns5054x3whfr.eot?#iefix\") format(\"embedded-opentype\"), url(\"//at.alicdn.com/t/font_515771_emcns5054x3whfr.woff\") format(\"woff\"), url(\"//at.alicdn.com/t/font_515771_emcns5054x3whfr.ttf\") format(\"truetype\"), url(\"//at.alicdn.com/t/font_515771_emcns5054x3whfr.svg#NextIcon\") format(\"svg\"); }\n\n.next-icon {\n  display: inline-block;\n  font-family: NextIcon;\n  font-style: normal;\n  font-weight: normal;\n  text-transform: none;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale; }\n  .next-icon:before {\n    display: inline-block;\n    vertical-align: middle;\n    text-align: center; }\n  .next-icon-smile:before {\n    content: \"\\E65F\"; }\n  .next-icon-cry:before {\n    content: \"\\E65D\"; }\n  .next-icon-success:before {\n    content: \"\\E60A\"; }\n  .next-icon-warning:before {\n    content: \"\\E60B\"; }\n  .next-icon-prompt:before {\n    content: \"\\E60C\"; }\n  .next-icon-error:before {\n    content: \"\\E60D\"; }\n  .next-icon-help:before {\n    content: \"\\E673\"; }\n  .next-icon-clock:before {\n    content: \"\\E621\"; }\n  .next-icon-success-filling:before {\n    content: \"\\E63A\"; }\n  .next-icon-delete-filling:before {\n    content: \"\\E623\"; }\n  .next-icon-favorites-filling:before {\n    content: \"\\E60E\"; }\n  .next-icon-add:before {\n    content: \"\\E655\"; }\n  .next-icon-minus:before {\n    content: \"\\E601\"; }\n  .next-icon-arrow-up:before {\n    content: \"\\E625\"; }\n  .next-icon-arrow-down:before {\n    content: \"\\E63D\"; }\n  .next-icon-arrow-left:before {\n    content: \"\\E61D\"; }\n  .next-icon-arrow-right:before {\n    content: \"\\E619\"; }\n  .next-icon-arrow-double-left:before {\n    content: \"\\E659\"; }\n  .next-icon-arrow-double-right:before {\n    content: \"\\E65E\"; }\n  .next-icon-switch:before {\n    content: \"\\E6B3\"; }\n  .next-icon-sorting:before {\n    content: \"\\E634\"; }\n  .next-icon-descending:before {\n    content: \"\\E61F\"; }\n  .next-icon-ascending:before {\n    content: \"\\E61E\"; }\n  .next-icon-select:before {\n    content: \"\\E632\"; }\n  .next-icon-semi-select:before {\n    content: \"\\E633\"; }\n  .next-icon-search:before {\n    content: \"\\E656\"; }\n  .next-icon-close:before {\n    content: \"\\E626\"; }\n  .next-icon-ellipsis:before {\n    content: \"\\E654\"; }\n  .next-icon-picture:before {\n    content: \"\\E631\"; }\n  .next-icon-calendar:before {\n    content: \"\\E607\"; }\n  .next-icon-ashbin:before {\n    content: \"\\E639\"; }\n  .next-icon-upload:before {\n    content: \"\\E7EE\"; }\n  .next-icon-download:before {\n    content: \"\\E628\"; }\n  .next-icon-set:before {\n    content: \"\\E683\"; }\n  .next-icon-edit:before {\n    content: \"\\E63B\"; }\n  .next-icon-refresh:before {\n    content: \"\\E677\"; }\n  .next-icon-filter:before {\n    content: \"\\E627\"; }\n  .next-icon-attachment:before {\n    content: \"\\E665\"; }\n  .next-icon-account:before {\n    content: \"\\E608\"; }\n  .next-icon-email:before {\n    content: \"\\E605\"; }\n  .next-icon-atm:before {\n    content: \"\\E606\"; }\n  .next-icon-loading:before {\n    content: \"\\E646\";\n    -webkit-animation: loadingCircle 1s infinite linear;\n            animation: loadingCircle 1s infinite linear; }\n\n@-webkit-keyframes loadingCircle {\n  0% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n\n@keyframes loadingCircle {\n  0% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n\n.next-icon.next-xxs:before {\n  width: 8px;\n  font-size: 8px;\n  line-height: inherit; }\n\n@media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n  .next-icon.next-xxs {\n    -webkit-transform: scale(0.5);\n        -ms-transform: scale(0.5);\n            transform: scale(0.5);\n    margin-left: -4px;\n    margin-right: -4px; }\n    .next-icon.next-xxs:before {\n      width: 16px;\n      font-size: 16px; } }\n\n.next-icon.next-xs:before {\n  width: 12px;\n  font-size: 12px;\n  line-height: inherit; }\n\n.next-icon.next-small:before {\n  width: 16px;\n  font-size: 16px;\n  line-height: inherit; }\n\n.next-icon.next-medium:before {\n  width: 20px;\n  font-size: 20px;\n  line-height: inherit; }\n\n.next-icon.next-large:before {\n  width: 24px;\n  font-size: 24px;\n  line-height: inherit; }\n\n.next-icon.next-xl:before {\n  width: 32px;\n  font-size: 32px;\n  line-height: inherit; }\n\n.next-icon.next-xxl:before {\n  width: 48px;\n  font-size: 48px;\n  line-height: inherit; }\n\n.next-icon.next-xxxl:before {\n  width: 64px;\n  font-size: 64px;\n  line-height: inherit; }\n", ""]);

// exports


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@-webkit-keyframes fadeIn {\n  0% {\n    opacity: 0; }\n  100% {\n    opacity: 1; } }\n\n@keyframes fadeIn {\n  0% {\n    opacity: 0; }\n  100% {\n    opacity: 1; } }\n\n@-webkit-keyframes fadeInDown {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateY(-100px);\n    -ms-transform: translateY(-100px);\n    transform: translateY(-100px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); } }\n\n@keyframes fadeInDown {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateY(-100px);\n    -ms-transform: translateY(-100px);\n    transform: translateY(-100px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); } }\n\n@-webkit-keyframes fadeInLeft {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateX(-20px);\n    -ms-transform: translateX(-20px);\n    transform: translateX(-20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); } }\n\n@keyframes fadeInLeft {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateX(-20px);\n    -ms-transform: translateX(-20px);\n    transform: translateX(-20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); } }\n\n@-webkit-keyframes fadeInRight {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateX(20px);\n    -ms-transform: translateX(20px);\n    transform: translateX(20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); } }\n\n@keyframes fadeInRight {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateX(20px);\n    -ms-transform: translateX(20px);\n    transform: translateX(20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); } }\n\n@-webkit-keyframes fadeInUp {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateY(20px);\n    -ms-transform: translateY(20px);\n    transform: translateY(20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); } }\n\n@keyframes fadeInUp {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateY(20px);\n    -ms-transform: translateY(20px);\n    transform: translateY(20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); } }\n\n@-webkit-keyframes fadeOut {\n  0% {\n    opacity: 1; }\n  100% {\n    opacity: 0; } }\n\n@keyframes fadeOut {\n  0% {\n    opacity: 1; }\n  100% {\n    opacity: 0; } }\n\n@-webkit-keyframes fadeOutDown {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateY(20px);\n    -ms-transform: translateY(20px);\n    transform: translateY(20px); } }\n\n@keyframes fadeOutDown {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateY(20px);\n    -ms-transform: translateY(20px);\n    transform: translateY(20px); } }\n\n@-webkit-keyframes fadeOutLeft {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateX(-20px);\n    -ms-transform: translateX(-20px);\n    transform: translateX(-20px); } }\n\n@keyframes fadeOutLeft {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateX(-20px);\n    -ms-transform: translateX(-20px);\n    transform: translateX(-20px); } }\n\n@-webkit-keyframes fadeOutRight {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateX(20px);\n    -ms-transform: translateX(20px);\n    transform: translateX(20px); } }\n\n@keyframes fadeOutRight {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateX(20px);\n    -ms-transform: translateX(20px);\n    transform: translateX(20px); } }\n\n@-webkit-keyframes fadeOutUp {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateY(-100px);\n    -ms-transform: translateY(-100px);\n    transform: translateY(-100px); } }\n\n@keyframes fadeOutUp {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateY(-100px);\n    -ms-transform: translateY(-100px);\n    transform: translateY(-100px); } }\n\n@-webkit-keyframes zoomIn {\n  0% {\n    opacity: 0;\n    -webkit-transform: scale3d(0.3, 0.3, 0.3);\n    -ms-transform: scale3d(0.3, 0.3, 0.3);\n    transform: scale3d(0.3, 0.3, 0.3); }\n  50% {\n    opacity: 1; } }\n\n@keyframes zoomIn {\n  0% {\n    opacity: 0;\n    -webkit-transform: scale3d(0.3, 0.3, 0.3);\n    -ms-transform: scale3d(0.3, 0.3, 0.3);\n    transform: scale3d(0.3, 0.3, 0.3); }\n  50% {\n    opacity: 1; } }\n\n@-webkit-keyframes zoomOut {\n  0% {\n    opacity: 1; }\n  50% {\n    opacity: 0;\n    -webkit-transform: scale3d(0.3, 0.3, 0.3);\n    -ms-transform: scale3d(0.3, 0.3, 0.3);\n    transform: scale3d(0.3, 0.3, 0.3); }\n  100% {\n    opacity: 0; } }\n\n@keyframes zoomOut {\n  0% {\n    opacity: 1; }\n  50% {\n    opacity: 0;\n    -webkit-transform: scale3d(0.3, 0.3, 0.3);\n    -ms-transform: scale3d(0.3, 0.3, 0.3);\n    transform: scale3d(0.3, 0.3, 0.3); }\n  100% {\n    opacity: 0; } }\n\n@-webkit-keyframes expandInDown {\n  0% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; }\n  100% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; } }\n\n@keyframes expandInDown {\n  0% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; }\n  100% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; } }\n\n@-webkit-keyframes expandInUp {\n  0% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; }\n  100% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; } }\n\n@keyframes expandInUp {\n  0% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; }\n  100% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; } }\n\n@-webkit-keyframes expandInWithFade {\n  0% {\n    opacity: 0; }\n  40% {\n    opacity: .1; }\n  50% {\n    opacity: .9; }\n  100% {\n    opacity: 1; } }\n\n@keyframes expandInWithFade {\n  0% {\n    opacity: 0; }\n  40% {\n    opacity: .1; }\n  50% {\n    opacity: .9; }\n  100% {\n    opacity: 1; } }\n\n@-webkit-keyframes expandOutUp {\n  0% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; }\n  100% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; } }\n\n@keyframes expandOutUp {\n  0% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; }\n  100% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; } }\n\n@-webkit-keyframes expandOutDown {\n  0% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; }\n  100% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; } }\n\n@keyframes expandOutDown {\n  0% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; }\n  100% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; } }\n\n@-webkit-keyframes expandOutWithFade {\n  0% {\n    opacity: 1; }\n  70% {\n    opacity: 0; }\n  100% {\n    opacity: 0; } }\n\n@keyframes expandOutWithFade {\n  0% {\n    opacity: 1; }\n  70% {\n    opacity: 0; }\n  100% {\n    opacity: 0; } }\n\n@-webkit-keyframes pulse {\n  from {\n    -webkit-transform: scale(1);\n    -ms-transform: scale(1);\n    transform: scale(1); }\n  20% {\n    -webkit-transform: scale(1.2);\n    -ms-transform: scale(1.2);\n    transform: scale(1.2); }\n  to {\n    -webkit-transform: scale(1);\n    -ms-transform: scale(1);\n    transform: scale(1); } }\n\n@keyframes pulse {\n  from {\n    -webkit-transform: scale(1);\n    -ms-transform: scale(1);\n    transform: scale(1); }\n  20% {\n    -webkit-transform: scale(1.2);\n    -ms-transform: scale(1.2);\n    transform: scale(1.2); }\n  to {\n    -webkit-transform: scale(1);\n    -ms-transform: scale(1);\n    transform: scale(1); } }\n\n.fadeIn {\n  -webkit-animation-name: fadeIn;\n  animation-name: fadeIn;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeInDown {\n  -webkit-animation-name: fadeInDown;\n  animation-name: fadeInDown;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeInLeft {\n  -webkit-animation-name: fadeInLeft;\n  animation-name: fadeInLeft;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeInRight {\n  -webkit-animation-name: fadeInRight;\n  animation-name: fadeInRight;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeInUp {\n  -webkit-animation-name: fadeInUp;\n  animation-name: fadeInUp;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeOut {\n  -webkit-animation-name: fadeOut;\n  animation-name: fadeOut;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeOutDown {\n  -webkit-animation-name: fadeOutDown;\n  animation-name: fadeOutDown;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeOutLeft {\n  -webkit-animation-name: fadeOutLeft;\n  animation-name: fadeOutLeft;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeOutRight {\n  -webkit-animation-name: fadeOutRight;\n  animation-name: fadeOutRight;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeOutUp {\n  -webkit-animation-name: fadeOutUp;\n  animation-name: fadeOutUp;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.2s;\n  animation-duration: 0.2s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.zoomIn {\n  -webkit-animation-name: zoomIn;\n  animation-name: zoomIn;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.zoomOut {\n  -webkit-animation-name: zoomOut;\n  animation-name: zoomOut;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.expandInDown {\n  -webkit-animation-name: expandInDown;\n  animation-name: expandInDown;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.expandOutUp {\n  -webkit-animation-name: expandOutUp;\n  animation-name: expandOutUp;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.15s;\n  animation-duration: 0.15s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.expandInUp {\n  -webkit-animation-name: expandInUp;\n  animation-name: expandInUp;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.expandOutDown {\n  -webkit-animation-name: expandOutDown;\n  animation-name: expandOutDown;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.15s;\n  animation-duration: 0.15s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.pulse {\n  -webkit-animation-name: pulse;\n  animation-name: pulse;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.expand-enter {\n  overflow: hidden; }\n\n.expand-enter-active {\n  -webkit-transition: all .3s ease-out;\n  transition: all .3s ease-out; }\n  .expand-enter-active > * {\n    -webkit-animation-name: expandInWithFade;\n    animation-name: expandInWithFade;\n    -webkit-animation-iteration-count: 1;\n    animation-iteration-count: 1;\n    -webkit-animation-duration: 0.2s;\n    animation-duration: 0.2s;\n    -webkit-animation-delay: 0s;\n    animation-delay: 0s;\n    -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n    animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n    -webkit-animation-fill-mode: \"forwards\";\n    animation-fill-mode: \"forwards\";\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden; }\n\n.expand-leave {\n  overflow: hidden; }\n\n.expand-leave-active {\n  -webkit-transition: all .2s ease-out;\n  transition: all .2s ease-out; }\n  .expand-leave-active > * {\n    -webkit-animation-name: expandOutWithFade;\n    animation-name: expandOutWithFade;\n    -webkit-animation-iteration-count: 1;\n    animation-iteration-count: 1;\n    -webkit-animation-duration: 0.2s;\n    animation-duration: 0.2s;\n    -webkit-animation-delay: 0s;\n    animation-delay: 0s;\n    -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n    animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n    -webkit-animation-fill-mode: \"forwards\";\n    animation-fill-mode: \"forwards\";\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden; }\n", ""]);

// exports


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n/* stylelint-disable max-nesting-depth */\n.next-checkbox-wrapper {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box; }\n  .next-checkbox-wrapper *,\n  .next-checkbox-wrapper *:before,\n  .next-checkbox-wrapper *:after {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box; }\n  .next-checkbox-wrapper .next-checkbox {\n    display: inline-block;\n    position: relative;\n    line-height: 1;\n    vertical-align: middle; }\n  .next-checkbox-wrapper input[type=\"checkbox\"] {\n    opacity: 0;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 16px;\n    height: 16px;\n    margin: 0; }\n  .next-checkbox-wrapper .next-checkbox-inner {\n    display: block;\n    width: 16px;\n    height: 16px;\n    background: #FFFFFF;\n    border-radius: 3px;\n    border: 1px solid #C4C6CF;\n    -webkit-transition: ease all .3s 0s;\n    transition: ease all .3s 0s;\n    text-align: left;\n    /* 防止继承父级 */\n    -webkit-box-shadow: none;\n            box-shadow: none;\n    /* box-sizing: content-box; */ }\n    .next-checkbox-wrapper .next-checkbox-inner > .next-icon {\n      -webkit-transform: scale(0);\n          -ms-transform: scale(0);\n              transform: scale(0);\n      position: absolute;\n      top: 0;\n      opacity: 0;\n      line-height: 16px;\n      -webkit-transition: all 0.3s cubic-bezier(0.78, 0.14, 0.15, 0.86);\n      transition: all 0.3s cubic-bezier(0.78, 0.14, 0.15, 0.86);\n      color: #FFFFFF;\n      left: 4px;\n      margin-left: 0; }\n      .next-checkbox-wrapper .next-checkbox-inner > .next-icon:before {\n        width: 8px;\n        font-size: 8px;\n        line-height: inherit; }\n      @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n        .next-checkbox-wrapper .next-checkbox-inner > .next-icon {\n          -webkit-transform: scale(0.5);\n              -ms-transform: scale(0.5);\n                  transform: scale(0.5);\n          margin-left: -4px;\n          margin-right: -4px; }\n          .next-checkbox-wrapper .next-checkbox-inner > .next-icon:before {\n            width: 16px;\n            font-size: 16px; } }\n    .next-checkbox-wrapper .next-checkbox-inner > .next-icon::before {\n      vertical-align: top;\n      margin-top: 0; }\n  .next-checkbox-wrapper.checked .next-checkbox-inner {\n    border-color: transparent;\n    background-color: #5584FF; }\n    .next-checkbox-wrapper.checked .next-checkbox-inner:hover, .next-checkbox-wrapper.checked .next-checkbox-inner.hovered {\n      border-color: transparent; }\n    .next-checkbox-wrapper.checked .next-checkbox-inner > .next-icon {\n      opacity: 1;\n      -webkit-transform: scale(1);\n          -ms-transform: scale(1);\n              transform: scale(1);\n      margin-left: 0;\n      /* font-size < 12px的时候进行覆盖。 */ }\n      .next-checkbox-wrapper.checked .next-checkbox-inner > .next-icon:before {\n        width: 8px;\n        font-size: 8px;\n        line-height: inherit; }\n      @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n        .next-checkbox-wrapper.checked .next-checkbox-inner > .next-icon {\n          -webkit-transform: scale(0.5);\n              -ms-transform: scale(0.5);\n                  transform: scale(0.5);\n          margin-left: -4px;\n          margin-right: -4px; }\n          .next-checkbox-wrapper.checked .next-checkbox-inner > .next-icon:before {\n            width: 16px;\n            font-size: 16px; } }\n  .next-checkbox-wrapper.indeterminate .next-checkbox-inner {\n    border-color: transparent;\n    background-color: #5584FF; }\n    .next-checkbox-wrapper.indeterminate .next-checkbox-inner:hover, .next-checkbox-wrapper.indeterminate .next-checkbox-inner.hovered {\n      border-color: transparent; }\n    .next-checkbox-wrapper.indeterminate .next-checkbox-inner > .next-icon {\n      opacity: 1;\n      -webkit-transform: scale3d(1, 1, 1);\n              transform: scale3d(1, 1, 1);\n      margin-left: 0;\n      /* font-size < 12px的时候进行覆盖。 */ }\n      .next-checkbox-wrapper.indeterminate .next-checkbox-inner > .next-icon:before {\n        width: 8px;\n        font-size: 8px;\n        line-height: inherit; }\n      @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n        .next-checkbox-wrapper.indeterminate .next-checkbox-inner > .next-icon {\n          -webkit-transform: scale(0.5);\n              -ms-transform: scale(0.5);\n                  transform: scale(0.5);\n          margin-left: -4px;\n          margin-right: -4px; }\n          .next-checkbox-wrapper.indeterminate .next-checkbox-inner > .next-icon:before {\n            width: 16px;\n            font-size: 16px; } }\n  .next-checkbox-wrapper.disabled input[type=\"checkbox\"] {\n    cursor: not-allowed; }\n  .next-checkbox-wrapper.disabled .next-checkbox-inner {\n    border-color: #E6E7EB;\n    background: #F7F8FA; }\n  .next-checkbox-wrapper.disabled.checked .next-checkbox-inner:hover, .next-checkbox-wrapper.disabled.checked .next-checkbox-inner.hovered, .next-checkbox-wrapper.disabled.indeterminate .next-checkbox-inner:hover, .next-checkbox-wrapper.disabled.indeterminate .next-checkbox-inner.hovered {\n    border-color: #E6E7EB; }\n  .next-checkbox-wrapper.disabled.checked .next-checkbox-inner > .next-icon, .next-checkbox-wrapper.disabled.indeterminate .next-checkbox-inner > .next-icon {\n    color: #CCCCCC;\n    opacity: 1; }\n  .next-checkbox-wrapper:not(.disabled):hover .next-checkbox-inner, .next-checkbox-wrapper.hovered .next-checkbox-inner, .next-checkbox-wrapper.focused .next-checkbox-inner {\n    border-color: #5584FF;\n    background-color: #DEE8FF; }\n  .next-checkbox-wrapper.indeterminate:not(.disabled):hover .next-checkbox-inner, .next-checkbox-wrapper.indeterminate:not(.disabled).hovered .next-checkbox-inner, .next-checkbox-wrapper.indeterminate.focused .next-checkbox-inner, .next-checkbox-wrapper.checked:not(.disabled):hover .next-checkbox-inner, .next-checkbox-wrapper.checked:not(.disabled).hovered .next-checkbox-inner, .next-checkbox-wrapper.checked.focused .next-checkbox-inner {\n    border-color: transparent;\n    background-color: #3E71F7; }\n    .next-checkbox-wrapper.indeterminate:not(.disabled):hover .next-checkbox-inner > .next-icon, .next-checkbox-wrapper.indeterminate:not(.disabled).hovered .next-checkbox-inner > .next-icon, .next-checkbox-wrapper.indeterminate.focused .next-checkbox-inner > .next-icon, .next-checkbox-wrapper.checked:not(.disabled):hover .next-checkbox-inner > .next-icon, .next-checkbox-wrapper.checked:not(.disabled).hovered .next-checkbox-inner > .next-icon, .next-checkbox-wrapper.checked.focused .next-checkbox-inner > .next-icon {\n      color: #FFFFFF;\n      opacity: 1; }\n\n.next-checkbox-group .next-checkbox-wrapper {\n  margin-left: 8px; }\n  .next-checkbox-group .next-checkbox-wrapper:first-child {\n    margin-left: 0; }\n\n.next-checkbox-group-ver .next-checkbox-wrapper {\n  display: block;\n  margin-left: 0;\n  margin-bottom: 8px; }\n\n.next-checkbox-label {\n  font-size: 12px;\n  vertical-align: middle;\n  margin: 0;\n  margin-left: 4px;\n  line-height: 1; }\n", ""]);

// exports


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n.next-radio-button-large[dir='rtl'] > label:first-child {\n  margin-left: -1px;\n  border-top-right-radius: 3px;\n  border-bottom-right-radius: 3px;\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0; }\n\n.next-radio-button-large[dir='rtl'] > label:last-child {\n  margin-left: 0;\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  border-top-left-radius: 3px;\n  border-bottom-left-radius: 3px; }\n\n.next-radio-button-large[dir='rtl'] .next-radio-label {\n  height: 38px;\n  line-height: 38px;\n  font-size: 16px; }\n\n.next-radio-button-medium[dir='rtl'] > label:first-child {\n  margin-left: -1px;\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  border-top-right-radius: 3px;\n  border-bottom-right-radius: 3px; }\n\n.next-radio-button-medium[dir='rtl'] > label:last-child {\n  margin-left: 0;\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  border-top-left-radius: 3px;\n  border-bottom-left-radius: 3px; }\n\n.next-radio-button-small[dir='rtl'] > label:first-child {\n  margin-left: -1px;\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  border-top-right-radius: 3px;\n  border-bottom-right-radius: 3px; }\n\n.next-radio-button-small[dir='rtl'] > label:last-child {\n  margin-left: 0;\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  border-top-left-radius: 3px;\n  border-bottom-left-radius: 3px; }\n\n.next-radio-wrapper[dir='rtl'] .next-radio-label {\n  margin-left: 0;\n  margin-right: 4px; }\n\n.next-radio-group[dir='rtl'] .next-radio-label {\n  margin-right: 4px;\n  margin-left: 16px; }\n\n.next-radio-button[dir='rtl'] > label .next-radio-label {\n  margin: 0; }\n\n.next-radio-wrapper {\n  outline: 0; }\n  .next-radio-wrapper .next-radio {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box;\n    display: inline-block;\n    vertical-align: middle;\n    position: relative;\n    line-height: 1; }\n    .next-radio-wrapper .next-radio *,\n    .next-radio-wrapper .next-radio *:before,\n    .next-radio-wrapper .next-radio *:after {\n      -webkit-box-sizing: border-box;\n              box-sizing: border-box; }\n    .next-radio-wrapper .next-radio input[type=\"radio\"] {\n      opacity: 0;\n      position: absolute;\n      vertical-align: middle;\n      top: 0;\n      left: 0;\n      width: 16px;\n      height: 16px;\n      margin: 0; }\n  .next-radio-wrapper .next-radio-inner {\n    /* 动画待定 */\n    /* &.mouseDown { */\n    /*     transform: scale3d(.7, .7, .7); */\n    /*     transition: transform .2s linear; */\n    /* } */\n    /* &.mouseUp { */\n    /*     transform: scale3d(1, 1, 1); */\n    /*     transition: transform .2s linear; */\n    /* } */\n    display: block;\n    width: 16px;\n    height: 16px;\n    background: #FFFFFF;\n    border-radius: 50%;\n    border: 1px solid #C4C6CF;\n    -webkit-transition: ease all .36s 0s;\n    transition: ease all .36s 0s;\n    -webkit-box-shadow: none;\n            box-shadow: none; }\n    .next-radio-wrapper .next-radio-inner:after {\n      -webkit-transform: scale(0);\n          -ms-transform: scale(0);\n              transform: scale(0);\n      position: absolute;\n      border-radius: 50%;\n      top: 50%;\n      margin-top: -2px;\n      left: 50%;\n      margin-left: -2px;\n      background: #FFFFFF;\n      content: ' ';\n      -webkit-transition: all 0.3s cubic-bezier(0.78, 0.14, 0.15, 0.86);\n      transition: all 0.3s cubic-bezier(0.78, 0.14, 0.15, 0.86); }\n  .next-radio-wrapper.checked .next-radio-inner {\n    border-color: #5584FF;\n    background: #5584FF; }\n    .next-radio-wrapper.checked .next-radio-inner:after {\n      width: 4px;\n      height: 4px;\n      font-weight: bold;\n      background: #FFFFFF;\n      -webkit-transform: scale(1);\n          -ms-transform: scale(1);\n              transform: scale(1); }\n  .next-radio-wrapper.checked:hover .next-radio-inner, .next-radio-wrapper.checked.hovered .next-radio-inner {\n    border-color: transparent; }\n  .next-radio-wrapper.disabled input[type=\"radio\"] {\n    cursor: not-allowed; }\n  .next-radio-wrapper.disabled .next-radio-inner {\n    border-color: #E6E7EB;\n    background: #F7F8FA; }\n    .next-radio-wrapper.disabled .next-radio-inner:hover, .next-radio-wrapper.disabled .next-radio-inner.hovered {\n      border-color: #E6E7EB; }\n  .next-radio-wrapper.disabled.checked .next-radio-inner:after {\n    background: #CCCCCC; }\n  .next-radio-wrapper:not(.disabled):hover .next-radio-inner, .next-radio-wrapper:not(.disabled).hovered .next-radio-inner, .next-radio-wrapper:not(.disabled):focus .next-radio-inner, .next-radio-wrapper:not(.disabled).focused .next-radio-inner {\n    border-color: #5584FF;\n    background-color: #DEE8FF; }\n  .next-radio-wrapper.checked:not(.disabled):hover .next-radio-inner, .next-radio-wrapper.checked:not(.disabled).hovered .next-radio-inner, .next-radio-wrapper.checked:not(.disabled):focus .next-radio-inner, .next-radio-wrapper.checked.focused .next-radio-inner {\n    border-color: transparent;\n    background: #3E71F7; }\n    .next-radio-wrapper.checked:not(.disabled):hover .next-radio-inner:after, .next-radio-wrapper.checked:not(.disabled).hovered .next-radio-inner:after, .next-radio-wrapper.checked:not(.disabled):focus .next-radio-inner:after, .next-radio-wrapper.checked.focused .next-radio-inner:after {\n      background: #FFFFFF; }\n\n.next-radio-button .next-radio {\n  width: 0;\n  height: 0; }\n\n.next-radio-button input[type=\"radio\"] {\n  width: 0;\n  height: 0; }\n\n.next-radio-button > label {\n  display: inline-block;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  position: relative;\n  z-index: 1;\n  margin: 0 0 0 -1px;\n  border: 1px solid #C4C6CF;\n  background-color: #FFFFFF;\n  -webkit-transition: ease all .3s 0s;\n  transition: ease all .3s 0s; }\n  .next-radio-button > label .next-radio-label {\n    display: block;\n    color: #333333;\n    margin: 0;\n    -webkit-transition: ease all .3s 0s;\n    transition: ease all .3s 0s; }\n  .next-radio-button > label:hover, .next-radio-button > label:focus, .next-radio-button > label.hovered {\n    z-index: 10;\n    border-color: #A0A2AD;\n    background-color: #F2F3F7; }\n    .next-radio-button > label:hover .next-radio-label, .next-radio-button > label:focus .next-radio-label, .next-radio-button > label.hovered .next-radio-label {\n      color: #333333; }\n  .next-radio-button > label.checked {\n    z-index: 10;\n    border-color: #5584FF;\n    background-color: #FFFFFF; }\n    .next-radio-button > label.checked .next-radio-label {\n      color: #5584FF; }\n  .next-radio-button > label.disabled {\n    z-index: 0;\n    cursor: not-allowed;\n    border-color: #E6E7EB;\n    background-color: #F7F8FA; }\n    .next-radio-button > label.disabled .next-radio-label {\n      color: #CCCCCC; }\n  .next-radio-button > label.checked.disabled {\n    z-index: 0;\n    border-color: #E6E7EB;\n    background-color: #F2F3F7; }\n    .next-radio-button > label.checked.disabled .next-radio-label {\n      color: #CCCCCC; }\n\n.next-radio-button-large > label {\n  padding: 0 8px;\n  height: 40px;\n  line-height: 40px; }\n  .next-radio-button-large > label:first-child {\n    margin-left: 0;\n    border-top-left-radius: 3px;\n    border-bottom-left-radius: 3px; }\n  .next-radio-button-large > label:last-child {\n    border-top-right-radius: 3px;\n    border-bottom-right-radius: 3px; }\n\n.next-radio-button-large .next-radio-label {\n  height: 38px;\n  line-height: 38px;\n  font-size: 16px; }\n\n.next-radio-button-medium > label {\n  padding: 0 8px;\n  height: 28px;\n  line-height: 28px; }\n  .next-radio-button-medium > label:first-child {\n    margin-left: 0;\n    border-top-left-radius: 3px;\n    border-bottom-left-radius: 3px; }\n  .next-radio-button-medium > label:last-child {\n    border-top-right-radius: 3px;\n    border-bottom-right-radius: 3px; }\n\n.next-radio-button-medium .next-radio-label {\n  height: 26px;\n  line-height: 26px;\n  font-size: 12px; }\n\n.next-radio-button-small > label {\n  padding: 0 8px;\n  height: 20px;\n  line-height: 20px; }\n  .next-radio-button-small > label:first-child {\n    margin-left: 0;\n    border-top-left-radius: 3px;\n    border-bottom-left-radius: 3px; }\n  .next-radio-button-small > label:last-child {\n    border-top-right-radius: 3px;\n    border-bottom-right-radius: 3px; }\n\n.next-radio-button-small .next-radio-label {\n  height: 18px;\n  line-height: 18px;\n  font-size: 12px; }\n\n.next-radio-single-input input[type=\"radio\"] {\n  opacity: 0;\n  position: absolute;\n  top: 0;\n  left: 0;\n  margin: 0; }\n\n.next-radio-group {\n  display: inline-block; }\n  .next-radio-group .next-radio-label {\n    color: #333333;\n    margin-right: 16px; }\n  .next-radio-group.disabled .next-radio-label {\n    color: #CCCCCC; }\n\n.next-radio-group-ver .next-radio-wrapper {\n  display: block;\n  margin-bottom: 8px; }\n\n.next-radio-label {\n  margin: 0;\n  margin-left: 4px;\n  font-size: 12px;\n  vertical-align: middle;\n  line-height: 1; }\n\n@-moz-document url-prefix() {\n  .next-radio {\n    margin-top: -1px; }\n  @supports ((-webkit-animation: calc(0s)) or (animation: calc(0s))) {\n    /* firefox 57+ */\n    .next-radio {\n      margin-top: -3px; } } }\n", ""]);

// exports


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n.next-menu[dir=\"rtl\"] .next-menu-item-helper {\n  float: left; }\n\n.next-menu[dir=\"rtl\"] .next-menu-item .next-checkbox,\n.next-menu[dir=\"rtl\"] .next-menu-item .next-radio {\n  margin-left: 4px;\n  margin-right: 0; }\n\n.next-menu[dir=\"rtl\"] .next-menu-hoz-right {\n  float: right; }\n\n.next-menu[dir=\"rtl\"] .next-menu-icon-arrow.next-icon {\n  left: 10px;\n  right: auto; }\n\n.next-menu[dir=\"rtl\"] .next-menu-hoz-icon-arrow.next-icon {\n  left: 6px;\n  right: auto; }\n\n.next-menu[dir=\"rtl\"] .next-menu-icon-selected.next-icon {\n  margin-left: 0;\n  margin-right: -16px; }\n  .next-menu[dir=\"rtl\"] .next-menu-icon-selected.next-icon:before {\n    width: 12px;\n    font-size: 12px;\n    line-height: inherit; }\n\n.next-menu[dir=\"rtl\"] .next-menu-icon-arrow.next-icon {\n  left: 10px;\n  right: auto; }\n\n.next-menu {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  position: relative;\n  min-width: 100px;\n  padding: 8px 0;\n  margin: 0;\n  list-style: none;\n  border: 1px solid #DCDEE3;\n  border-radius: 3px;\n  -webkit-box-shadow: none;\n          box-shadow: none;\n  background: #FFFFFF;\n  line-height: 32px;\n  font-size: 12px;\n  /* &-popup-content.next-hide { */\n  /*     display: none; */\n  /* } */ }\n  .next-menu *,\n  .next-menu *:before,\n  .next-menu *:after {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box; }\n  .next-menu:focus,\n  .next-menu *:focus {\n    outline: 0; }\n  .next-menu-content {\n    position: relative;\n    padding: 0;\n    margin: 0;\n    list-style: none; }\n  .next-menu-sub-menu {\n    padding: 0;\n    margin: 0;\n    list-style: none; }\n    .next-menu-sub-menu.next-expand-enter {\n      overflow: hidden; }\n    .next-menu-sub-menu.next-expand-enter-active {\n      -webkit-transition: height .3s ease-out;\n      transition: height .3s ease-out; }\n    .next-menu-sub-menu.next-expand-leave {\n      overflow: hidden; }\n    .next-menu-sub-menu.next-expand-leave-active {\n      -webkit-transition: height .3s ease-out;\n      transition: height .3s ease-out; }\n  .next-menu-item {\n    position: relative;\n    padding: 0 20px;\n    -webkit-transition: background .2s ease;\n    transition: background .2s ease;\n    color: #333333;\n    cursor: pointer; }\n    .next-menu-item-helper {\n      float: right;\n      color: #999999;\n      font-style: normal;\n      font-size: 12px; }\n    .next-menu-item .next-checkbox,\n    .next-menu-item .next-radio {\n      margin-right: 4px; }\n    .next-menu-item.next-selected {\n      color: #333333;\n      background-color: #FFFFFF; }\n      .next-menu-item.next-selected .next-menu-icon-arrow {\n        color: #666666; }\n      .next-menu-item.next-selected .next-menu-icon-selected {\n        color: #5584FF; }\n    .next-menu-item.next-disabled,\n    .next-menu-item.next-disabled .next-menu-item-text > a {\n      color: #CCCCCC;\n      background-color: #FFFFFF;\n      cursor: not-allowed; }\n      .next-menu-item.next-disabled .next-menu-icon-arrow,\n      .next-menu-item.next-disabled .next-menu-item-text > a .next-menu-icon-arrow {\n        color: #CCCCCC; }\n      .next-menu-item.next-disabled .next-menu-icon-selected,\n      .next-menu-item.next-disabled .next-menu-item-text > a .next-menu-icon-selected {\n        color: #CCCCCC; }\n    .next-menu-item:not(.next-disabled):hover, .next-menu-item:not(.next-disabled).next-selected:hover, .next-menu-item:not(.next-disabled).next-selected.next-focused:hover, .next-menu-item:not(.next-disabled).next-selected:focus:hover, .next-menu-item:not(.next-disabled).next-focused, .next-menu-item:not(.next-disabled):focus, .next-menu-item:not(.next-disabled).next-selected.next-focused, .next-menu-item:not(.next-disabled).next-selected:focus {\n      color: #333333;\n      background-color: #F2F3F7; }\n      .next-menu-item:not(.next-disabled):hover .next-menu-icon-arrow, .next-menu-item:not(.next-disabled).next-selected:hover .next-menu-icon-arrow, .next-menu-item:not(.next-disabled).next-selected.next-focused:hover .next-menu-icon-arrow, .next-menu-item:not(.next-disabled).next-selected:focus:hover .next-menu-icon-arrow, .next-menu-item:not(.next-disabled).next-focused .next-menu-icon-arrow, .next-menu-item:not(.next-disabled):focus .next-menu-icon-arrow, .next-menu-item:not(.next-disabled).next-selected.next-focused .next-menu-icon-arrow, .next-menu-item:not(.next-disabled).next-selected:focus .next-menu-icon-arrow {\n        color: #333333; }\n      .next-menu-item:not(.next-disabled):hover .next-menu-icon-selected, .next-menu-item:not(.next-disabled).next-selected:hover .next-menu-icon-selected, .next-menu-item:not(.next-disabled).next-selected.next-focused:hover .next-menu-icon-selected, .next-menu-item:not(.next-disabled).next-selected:focus:hover .next-menu-icon-selected, .next-menu-item:not(.next-disabled).next-focused .next-menu-icon-selected, .next-menu-item:not(.next-disabled):focus .next-menu-icon-selected, .next-menu-item:not(.next-disabled).next-selected.next-focused .next-menu-icon-selected, .next-menu-item:not(.next-disabled).next-selected:focus .next-menu-icon-selected {\n        color: #5584FF; }\n  .next-menu-item-inner {\n    height: 32px;\n    font-size: 12px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    word-wrap: normal; }\n  .next-menu-item-text {\n    vertical-align: middle; }\n    .next-menu-item-text > a {\n      display: inline-block;\n      text-decoration: none;\n      color: #333333; }\n      .next-menu-item-text > a::before {\n        position: absolute;\n        background-color: transparent;\n        top: 0;\n        left: 0;\n        bottom: 0;\n        right: 0;\n        content: ''; }\n  .next-menu.next-hoz {\n    padding: 0; }\n    .next-menu.next-hoz > .next-menu-item,\n    .next-menu.next-hoz .next-menu-content > .next-menu-item {\n      display: inline-block;\n      vertical-align: top; }\n    .next-menu.next-hoz .next-menu-header,\n    .next-menu.next-hoz .next-menu-content,\n    .next-menu.next-hoz .next-menu-footer {\n      display: inline-block; }\n  .next-menu-hoz-right {\n    float: right; }\n  .next-menu-group-label {\n    padding: 0 12px;\n    color: #999999; }\n  .next-menu-divider {\n    margin: 8px 12px;\n    border-bottom: 1px solid #E6E7EB; }\n  .next-menu .next-menu-icon-selected.next-icon {\n    position: absolute;\n    top: 0;\n    margin-left: -16px; }\n    .next-menu .next-menu-icon-selected.next-icon:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-menu .next-menu-icon-arrow.next-icon {\n    position: absolute;\n    top: 0;\n    right: 10px;\n    color: #666666;\n    -webkit-transition: all ease .3s;\n    transition: all ease .3s; }\n    .next-menu .next-menu-icon-arrow.next-icon:before {\n      width: 8px;\n      font-size: 8px;\n      line-height: inherit; }\n    @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n      .next-menu .next-menu-icon-arrow.next-icon {\n        -webkit-transform: scale(0.5);\n            -ms-transform: scale(0.5);\n                transform: scale(0.5);\n        margin-left: -4px;\n        margin-right: -4px; }\n        .next-menu .next-menu-icon-arrow.next-icon:before {\n          width: 16px;\n          font-size: 16px; } }\n  .next-menu .next-menu-icon-arrow-down.next-open {\n    -webkit-transform: rotate(180deg);\n        -ms-transform: rotate(180deg);\n            transform: rotate(180deg); }\n    .next-menu .next-menu-icon-arrow-down.next-open:before {\n      width: 8px;\n      font-size: 8px;\n      line-height: inherit; }\n    @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n      .next-menu .next-menu-icon-arrow-down.next-open {\n        -webkit-transform: scale(0.5) rotate(180deg);\n            -ms-transform: scale(0.5) rotate(180deg);\n                transform: scale(0.5) rotate(180deg);\n        margin-left: -4px;\n        margin-right: -4px; }\n        .next-menu .next-menu-icon-arrow-down.next-open:before {\n          width: 16px;\n          font-size: 16px; } }\n  .next-menu .next-menu-icon-arrow-right.next-open {\n    -webkit-transform: rotate(-90deg);\n        -ms-transform: rotate(-90deg);\n            transform: rotate(-90deg); }\n    .next-menu .next-menu-icon-arrow-right.next-open:before {\n      width: 8px;\n      font-size: 8px;\n      line-height: inherit; }\n    @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n      .next-menu .next-menu-icon-arrow-right.next-open {\n        -webkit-transform: scale(0.5) rotate(-90deg);\n            -ms-transform: scale(0.5) rotate(-90deg);\n                transform: scale(0.5) rotate(-90deg);\n        margin-left: -4px;\n        margin-right: -4px; }\n        .next-menu .next-menu-icon-arrow-right.next-open:before {\n          width: 16px;\n          font-size: 16px; } }\n  .next-menu .next-menu-hoz-icon-arrow.next-icon {\n    position: absolute;\n    top: 0;\n    right: 6px;\n    color: #666666;\n    -webkit-transition: all ease .3s;\n    transition: all ease .3s; }\n    .next-menu .next-menu-hoz-icon-arrow.next-icon:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-menu .next-menu-hoz-icon-arrow.next-open {\n    -webkit-transform: rotate(180deg);\n        -ms-transform: rotate(180deg);\n            transform: rotate(180deg); }\n    .next-menu .next-menu-hoz-icon-arrow.next-open:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-menu.next-context {\n    line-height: 24px; }\n    .next-menu.next-context .next-menu-item-inner {\n      height: 24px; }\n", ""]);

// exports


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n.next-btn {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box; }\n  .next-btn *,\n  .next-btn *:before,\n  .next-btn *:after {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box; }\n  .next-btn::-moz-focus-inner {\n    border: 0;\n    padding: 0; }\n  .next-btn, .next-btn:active, .next-btn:focus, .next-btn:hover {\n    outline: 0; }\n\n@-webkit-keyframes loadingCircle {\n  0% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n\n@keyframes loadingCircle {\n  0% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n\n.next-btn {\n  /* 尺寸维度 */\n  /* ---------------------------------------- */\n  /* 普通按钮 */\n  /* 普通态禁用样式 */\n  /* 警告按钮 */\n  /* 文本按钮 */\n  /* loading */\n  /* ---------------------------------------- */\n  /* 幽灵按钮 */\n  /* 组合 */\n  /* ---------------------------------------- */ }\n  .next-btn {\n    position: relative;\n    display: inline-block;\n    -webkit-box-shadow: none;\n            box-shadow: none;\n    text-decoration: none;\n    text-align: center;\n    text-transform: none;\n    white-space: nowrap;\n    vertical-align: middle;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n    -webkit-transition: all .3s ease-out;\n    transition: all .3s ease-out;\n    cursor: pointer; }\n    .next-btn:after {\n      text-align: center;\n      position: absolute;\n      opacity: 0;\n      visibility: hidden;\n      -webkit-transition: opacity .5s ease;\n      transition: opacity .5s ease; }\n    .next-btn .next-icon.next-xs:before {\n      vertical-align: baseline; }\n    .next-btn.hover, .next-btn:hover {\n      -webkit-box-shadow: none;\n              box-shadow: none; }\n  .next-btn.next-small {\n    border-radius: 3px;\n    padding: 0 8px;\n    height: 20px;\n    line-height: 18px;\n    font-size: 12px;\n    border-width: 1px; }\n    .next-btn.next-small > .next-btn-icon.next-icon-first {\n      margin-left: 0;\n      margin-right: 4px; }\n      .next-btn.next-small > .next-btn-icon.next-icon-first:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n    .next-btn.next-small > .next-btn-icon.next-icon-last {\n      margin-left: 4px;\n      margin-right: 0; }\n      .next-btn.next-small > .next-btn-icon.next-icon-last:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n    .next-btn.next-small > .next-btn-icon.next-icon-alone:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n    .next-btn.next-small.next-btn-loading {\n      padding-left: 24px; }\n      .next-btn.next-small.next-btn-loading:after {\n        width: 12px;\n        height: 12px;\n        font-size: 12px;\n        line-height: 12px;\n        left: 8px;\n        top: 50%;\n        text-align: center;\n        margin-top: -6px;\n        margin-right: 4px; }\n      .next-btn.next-small.next-btn-loading > .next-icon {\n        display: none; }\n  .next-btn.next-medium {\n    border-radius: 3px;\n    padding: 0 12px;\n    height: 28px;\n    line-height: 26px;\n    font-size: 12px;\n    border-width: 1px; }\n    .next-btn.next-medium > .next-btn-icon.next-icon-first {\n      margin-left: 0;\n      margin-right: 4px; }\n      .next-btn.next-medium > .next-btn-icon.next-icon-first:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n    .next-btn.next-medium > .next-btn-icon.next-icon-last {\n      margin-left: 4px;\n      margin-right: 0; }\n      .next-btn.next-medium > .next-btn-icon.next-icon-last:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n    .next-btn.next-medium > .next-btn-icon.next-icon-alone:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n    .next-btn.next-medium.next-btn-loading {\n      padding-left: 28px; }\n      .next-btn.next-medium.next-btn-loading:after {\n        width: 12px;\n        height: 12px;\n        font-size: 12px;\n        line-height: 12px;\n        left: 12px;\n        top: 50%;\n        text-align: center;\n        margin-top: -6px;\n        margin-right: 4px; }\n      .next-btn.next-medium.next-btn-loading > .next-icon {\n        display: none; }\n  .next-btn.next-large {\n    border-radius: 3px;\n    padding: 0 16px;\n    height: 40px;\n    line-height: 38px;\n    font-size: 16px;\n    border-width: 1px; }\n    .next-btn.next-large > .next-btn-icon.next-icon-first {\n      margin-left: 0;\n      margin-right: 4px; }\n      .next-btn.next-large > .next-btn-icon.next-icon-first:before {\n        width: 16px;\n        font-size: 16px;\n        line-height: inherit; }\n    .next-btn.next-large > .next-btn-icon.next-icon-last {\n      margin-left: 4px;\n      margin-right: 0; }\n      .next-btn.next-large > .next-btn-icon.next-icon-last:before {\n        width: 16px;\n        font-size: 16px;\n        line-height: inherit; }\n    .next-btn.next-large > .next-btn-icon.next-icon-alone:before {\n      width: 16px;\n      font-size: 16px;\n      line-height: inherit; }\n    .next-btn.next-large.next-btn-loading {\n      padding-left: 36px; }\n      .next-btn.next-large.next-btn-loading:after {\n        width: 16px;\n        height: 16px;\n        font-size: 16px;\n        line-height: 16px;\n        left: 16px;\n        top: 50%;\n        text-align: center;\n        margin-top: -8px;\n        margin-right: 4px; }\n      .next-btn.next-large.next-btn-loading > .next-icon {\n        display: none; }\n  .next-btn.next-btn-normal {\n    border-style: solid;\n    background-color: #FFFFFF;\n    border-color: #C4C6CF; }\n    .next-btn.next-btn-normal, .next-btn.next-btn-normal:link, .next-btn.next-btn-normal:visited, .next-btn.next-btn-normal.visited {\n      color: #333333; }\n    .next-btn.next-btn-normal:focus, .next-btn.next-btn-normal:hover, .next-btn.next-btn-normal.hover, .next-btn.next-btn-normal:active, .next-btn.next-btn-normal.active {\n      color: #333333;\n      background-color: #F2F3F7;\n      border-color: #A0A2AD;\n      text-decoration: none; }\n  .next-btn.next-btn-primary {\n    border-style: solid;\n    background-color: #5584FF;\n    border-color: transparent; }\n    .next-btn.next-btn-primary, .next-btn.next-btn-primary:link, .next-btn.next-btn-primary:visited, .next-btn.next-btn-primary.visited {\n      color: #FFFFFF; }\n    .next-btn.next-btn-primary:focus, .next-btn.next-btn-primary:hover, .next-btn.next-btn-primary.hover, .next-btn.next-btn-primary:active, .next-btn.next-btn-primary.active {\n      color: #FFFFFF;\n      background-color: #3E71F7;\n      border-color: transparent;\n      text-decoration: none; }\n  .next-btn.next-btn-secondary {\n    border-style: solid;\n    background-color: #FFFFFF;\n    border-color: #5584FF; }\n    .next-btn.next-btn-secondary, .next-btn.next-btn-secondary:link, .next-btn.next-btn-secondary:visited, .next-btn.next-btn-secondary.visited {\n      color: #5584FF; }\n    .next-btn.next-btn-secondary:focus, .next-btn.next-btn-secondary:hover, .next-btn.next-btn-secondary.hover, .next-btn.next-btn-secondary:active, .next-btn.next-btn-secondary.active {\n      color: #FFFFFF;\n      background-color: #3E71F7;\n      border-color: #3E71F7;\n      text-decoration: none; }\n  .next-btn.disabled, .next-btn[disabled] {\n    cursor: not-allowed;\n    background-color: #F7F8FA;\n    border-color: #E6E7EB; }\n    .next-btn.disabled, .next-btn.disabled:link, .next-btn.disabled:visited, .next-btn.disabled.visited, .next-btn[disabled], .next-btn[disabled]:link, .next-btn[disabled]:visited, .next-btn[disabled].visited {\n      color: #CCCCCC; }\n    .next-btn.disabled:focus, .next-btn.disabled:hover, .next-btn.disabled.hover, .next-btn.disabled:active, .next-btn.disabled.active, .next-btn[disabled]:focus, .next-btn[disabled]:hover, .next-btn[disabled].hover, .next-btn[disabled]:active, .next-btn[disabled].active {\n      color: #CCCCCC;\n      background-color: #F7F8FA;\n      border-color: #E6E7EB;\n      text-decoration: none; }\n  .next-btn-warning {\n    border-style: solid; }\n    .next-btn-warning.next-btn-primary {\n      background-color: #FF3000;\n      border-color: #FF3000; }\n      .next-btn-warning.next-btn-primary, .next-btn-warning.next-btn-primary:link, .next-btn-warning.next-btn-primary:visited, .next-btn-warning.next-btn-primary.visited {\n        color: #FFFFFF; }\n      .next-btn-warning.next-btn-primary:focus, .next-btn-warning.next-btn-primary:hover, .next-btn-warning.next-btn-primary.hover, .next-btn-warning.next-btn-primary:active, .next-btn-warning.next-btn-primary.active {\n        color: #FFFFFF;\n        background-color: #E72B00;\n        border-color: #E72B00;\n        text-decoration: none; }\n      .next-btn-warning.next-btn-primary.disabled, .next-btn-warning.next-btn-primary[disabled] {\n        background-color: #F7F8FA;\n        border-color: #DCDEE3; }\n        .next-btn-warning.next-btn-primary.disabled, .next-btn-warning.next-btn-primary.disabled:link, .next-btn-warning.next-btn-primary.disabled:visited, .next-btn-warning.next-btn-primary.disabled.visited, .next-btn-warning.next-btn-primary[disabled], .next-btn-warning.next-btn-primary[disabled]:link, .next-btn-warning.next-btn-primary[disabled]:visited, .next-btn-warning.next-btn-primary[disabled].visited {\n          color: #CCCCCC; }\n        .next-btn-warning.next-btn-primary.disabled:focus, .next-btn-warning.next-btn-primary.disabled:hover, .next-btn-warning.next-btn-primary.disabled.hover, .next-btn-warning.next-btn-primary.disabled:active, .next-btn-warning.next-btn-primary.disabled.active, .next-btn-warning.next-btn-primary[disabled]:focus, .next-btn-warning.next-btn-primary[disabled]:hover, .next-btn-warning.next-btn-primary[disabled].hover, .next-btn-warning.next-btn-primary[disabled]:active, .next-btn-warning.next-btn-primary[disabled].active {\n          color: #CCCCCC;\n          background-color: #F7F8FA;\n          border-color: #DCDEE3;\n          text-decoration: none; }\n    .next-btn-warning.next-btn-normal {\n      background-color: #FFFFFF;\n      border-color: #FF3000; }\n      .next-btn-warning.next-btn-normal, .next-btn-warning.next-btn-normal:link, .next-btn-warning.next-btn-normal:visited, .next-btn-warning.next-btn-normal.visited {\n        color: #FF3000; }\n      .next-btn-warning.next-btn-normal:focus, .next-btn-warning.next-btn-normal:hover, .next-btn-warning.next-btn-normal.hover, .next-btn-warning.next-btn-normal:active, .next-btn-warning.next-btn-normal.active {\n        color: #FFFFFF;\n        background-color: #E72B00;\n        border-color: #E72B00;\n        text-decoration: none; }\n      .next-btn-warning.next-btn-normal.disabled, .next-btn-warning.next-btn-normal[disabled] {\n        background-color: #F7F8FA;\n        border-color: #E6E7EB; }\n        .next-btn-warning.next-btn-normal.disabled, .next-btn-warning.next-btn-normal.disabled:link, .next-btn-warning.next-btn-normal.disabled:visited, .next-btn-warning.next-btn-normal.disabled.visited, .next-btn-warning.next-btn-normal[disabled], .next-btn-warning.next-btn-normal[disabled]:link, .next-btn-warning.next-btn-normal[disabled]:visited, .next-btn-warning.next-btn-normal[disabled].visited {\n          color: #CCCCCC; }\n        .next-btn-warning.next-btn-normal.disabled:focus, .next-btn-warning.next-btn-normal.disabled:hover, .next-btn-warning.next-btn-normal.disabled.hover, .next-btn-warning.next-btn-normal.disabled:active, .next-btn-warning.next-btn-normal.disabled.active, .next-btn-warning.next-btn-normal[disabled]:focus, .next-btn-warning.next-btn-normal[disabled]:hover, .next-btn-warning.next-btn-normal[disabled].hover, .next-btn-warning.next-btn-normal[disabled]:active, .next-btn-warning.next-btn-normal[disabled].active {\n          color: #CCCCCC;\n          background-color: #F7F8FA;\n          border-color: #E6E7EB;\n          text-decoration: none; }\n  .next-btn-text {\n    -webkit-box-shadow: none;\n            box-shadow: none;\n    border-radius: 0; }\n    .next-btn-text.hover, .next-btn-text:hover {\n      -webkit-box-shadow: none;\n              box-shadow: none; }\n    .next-btn-text.next-btn-primary {\n      background-color: transparent;\n      border-color: transparent; }\n      .next-btn-text.next-btn-primary, .next-btn-text.next-btn-primary:link, .next-btn-text.next-btn-primary:visited, .next-btn-text.next-btn-primary.visited {\n        color: #5584FF; }\n      .next-btn-text.next-btn-primary:focus, .next-btn-text.next-btn-primary:hover, .next-btn-text.next-btn-primary.hover, .next-btn-text.next-btn-primary:active, .next-btn-text.next-btn-primary.active {\n        color: #3E71F7;\n        background-color: transparent;\n        border-color: transparent;\n        text-decoration: none; }\n    .next-btn-text.next-btn-secondary {\n      background-color: transparent;\n      border-color: transparent; }\n      .next-btn-text.next-btn-secondary, .next-btn-text.next-btn-secondary:link, .next-btn-text.next-btn-secondary:visited, .next-btn-text.next-btn-secondary.visited {\n        color: #666666; }\n      .next-btn-text.next-btn-secondary:focus, .next-btn-text.next-btn-secondary:hover, .next-btn-text.next-btn-secondary.hover, .next-btn-text.next-btn-secondary:active, .next-btn-text.next-btn-secondary.active {\n        color: #5584FF;\n        background-color: transparent;\n        border-color: transparent;\n        text-decoration: none; }\n    .next-btn-text.next-btn-normal {\n      background-color: transparent;\n      border-color: transparent; }\n      .next-btn-text.next-btn-normal, .next-btn-text.next-btn-normal:link, .next-btn-text.next-btn-normal:visited, .next-btn-text.next-btn-normal.visited {\n        color: #333333; }\n      .next-btn-text.next-btn-normal:focus, .next-btn-text.next-btn-normal:hover, .next-btn-text.next-btn-normal.hover, .next-btn-text.next-btn-normal:active, .next-btn-text.next-btn-normal.active {\n        color: #5584FF;\n        background-color: transparent;\n        border-color: transparent;\n        text-decoration: none; }\n    .next-btn-text.next-large {\n      border-radius: 0;\n      padding: 0 0;\n      height: 24px;\n      line-height: 24px;\n      font-size: 14px;\n      border-width: 0; }\n      .next-btn-text.next-large > .next-btn-icon.next-icon-first {\n        margin-left: 0;\n        margin-right: 4px; }\n        .next-btn-text.next-large > .next-btn-icon.next-icon-first:before {\n          width: 16px;\n          font-size: 16px;\n          line-height: inherit; }\n      .next-btn-text.next-large > .next-btn-icon.next-icon-last {\n        margin-left: 4px;\n        margin-right: 0; }\n        .next-btn-text.next-large > .next-btn-icon.next-icon-last:before {\n          width: 16px;\n          font-size: 16px;\n          line-height: inherit; }\n      .next-btn-text.next-large > .next-btn-icon.next-icon-alone:before {\n        width: 16px;\n        font-size: 16px;\n        line-height: inherit; }\n      .next-btn-text.next-large.next-btn-loading {\n        padding-left: 20px; }\n        .next-btn-text.next-large.next-btn-loading:after {\n          width: 16px;\n          height: 16px;\n          font-size: 16px;\n          line-height: 16px;\n          left: 0;\n          top: 50%;\n          text-align: center;\n          margin-top: -8px;\n          margin-right: 4px; }\n        .next-btn-text.next-large.next-btn-loading > .next-icon {\n          display: none; }\n    .next-btn-text.next-medium {\n      border-radius: 0;\n      padding: 0 0;\n      height: 20px;\n      line-height: 20px;\n      font-size: 12px;\n      border-width: 0; }\n      .next-btn-text.next-medium > .next-btn-icon.next-icon-first {\n        margin-left: 0;\n        margin-right: 4px; }\n        .next-btn-text.next-medium > .next-btn-icon.next-icon-first:before {\n          width: 12px;\n          font-size: 12px;\n          line-height: inherit; }\n      .next-btn-text.next-medium > .next-btn-icon.next-icon-last {\n        margin-left: 4px;\n        margin-right: 0; }\n        .next-btn-text.next-medium > .next-btn-icon.next-icon-last:before {\n          width: 12px;\n          font-size: 12px;\n          line-height: inherit; }\n      .next-btn-text.next-medium > .next-btn-icon.next-icon-alone:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n      .next-btn-text.next-medium.next-btn-loading {\n        padding-left: 16px; }\n        .next-btn-text.next-medium.next-btn-loading:after {\n          width: 12px;\n          height: 12px;\n          font-size: 12px;\n          line-height: 12px;\n          left: 0;\n          top: 50%;\n          text-align: center;\n          margin-top: -6px;\n          margin-right: 4px; }\n        .next-btn-text.next-medium.next-btn-loading > .next-icon {\n          display: none; }\n    .next-btn-text.next-small {\n      border-radius: 0;\n      padding: 0 0;\n      height: 16px;\n      line-height: 16px;\n      font-size: 12px;\n      border-width: 0; }\n      .next-btn-text.next-small > .next-btn-icon.next-icon-first {\n        margin-left: 0;\n        margin-right: 4px; }\n        .next-btn-text.next-small > .next-btn-icon.next-icon-first:before {\n          width: 12px;\n          font-size: 12px;\n          line-height: inherit; }\n      .next-btn-text.next-small > .next-btn-icon.next-icon-last {\n        margin-left: 4px;\n        margin-right: 0; }\n        .next-btn-text.next-small > .next-btn-icon.next-icon-last:before {\n          width: 12px;\n          font-size: 12px;\n          line-height: inherit; }\n      .next-btn-text.next-small > .next-btn-icon.next-icon-alone:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n      .next-btn-text.next-small.next-btn-loading {\n        padding-left: 16px; }\n        .next-btn-text.next-small.next-btn-loading:after {\n          width: 12px;\n          height: 12px;\n          font-size: 12px;\n          line-height: 12px;\n          left: 0;\n          top: 50%;\n          text-align: center;\n          margin-top: -6px;\n          margin-right: 4px; }\n        .next-btn-text.next-small.next-btn-loading > .next-icon {\n          display: none; }\n    .next-btn-text.disabled, .next-btn-text[disabled] {\n      background-color: transparent;\n      border-color: transparent; }\n      .next-btn-text.disabled, .next-btn-text.disabled:link, .next-btn-text.disabled:visited, .next-btn-text.disabled.visited, .next-btn-text[disabled], .next-btn-text[disabled]:link, .next-btn-text[disabled]:visited, .next-btn-text[disabled].visited {\n        color: #CCCCCC; }\n      .next-btn-text.disabled:focus, .next-btn-text.disabled:hover, .next-btn-text.disabled.hover, .next-btn-text.disabled:active, .next-btn-text.disabled.active, .next-btn-text[disabled]:focus, .next-btn-text[disabled]:hover, .next-btn-text[disabled].hover, .next-btn-text[disabled]:active, .next-btn-text[disabled].active {\n        color: #CCCCCC;\n        background-color: transparent;\n        border-color: transparent;\n        text-decoration: none; }\n    .next-btn-text.next-btn-loading {\n      background-color: transparent;\n      border-color: transparent; }\n      .next-btn-text.next-btn-loading, .next-btn-text.next-btn-loading:link, .next-btn-text.next-btn-loading:visited, .next-btn-text.next-btn-loading.visited {\n        color: #333333; }\n      .next-btn-text.next-btn-loading:focus, .next-btn-text.next-btn-loading:hover, .next-btn-text.next-btn-loading.hover, .next-btn-text.next-btn-loading:active, .next-btn-text.next-btn-loading.active {\n        color: #333333;\n        background-color: transparent;\n        border-color: transparent;\n        text-decoration: none; }\n  .next-btn-loading {\n    pointer-events: none; }\n    .next-btn-loading:after {\n      font-family: NextIcon;\n      content: \"\\E646\";\n      opacity: 1;\n      visibility: visible;\n      -webkit-animation: loadingCircle 2s infinite linear;\n              animation: loadingCircle 2s infinite linear; }\n  .next-btn-ghost {\n    -webkit-box-shadow: none;\n            box-shadow: none;\n    border-style: solid; }\n    .next-btn-ghost.next-btn-dark {\n      background-color: transparent;\n      border-color: #FFFFFF; }\n      .next-btn-ghost.next-btn-dark, .next-btn-ghost.next-btn-dark:link, .next-btn-ghost.next-btn-dark:visited, .next-btn-ghost.next-btn-dark.visited {\n        color: #FFFFFF; }\n      .next-btn-ghost.next-btn-dark:focus, .next-btn-ghost.next-btn-dark:hover, .next-btn-ghost.next-btn-dark.hover, .next-btn-ghost.next-btn-dark:active, .next-btn-ghost.next-btn-dark.active {\n        color: #FFFFFF;\n        background-color: rgba(255, 255, 255, 0.8);\n        border-color: #FFFFFF;\n        text-decoration: none; }\n      .next-btn-ghost.next-btn-dark.disabled, .next-btn-ghost.next-btn-dark[disabled] {\n        background-color: transparent;\n        border-color: rgba(255, 255, 255, 0.4); }\n        .next-btn-ghost.next-btn-dark.disabled, .next-btn-ghost.next-btn-dark.disabled:link, .next-btn-ghost.next-btn-dark.disabled:visited, .next-btn-ghost.next-btn-dark.disabled.visited, .next-btn-ghost.next-btn-dark[disabled], .next-btn-ghost.next-btn-dark[disabled]:link, .next-btn-ghost.next-btn-dark[disabled]:visited, .next-btn-ghost.next-btn-dark[disabled].visited {\n          color: rgba(255, 255, 255, 0.4); }\n        .next-btn-ghost.next-btn-dark.disabled:focus, .next-btn-ghost.next-btn-dark.disabled:hover, .next-btn-ghost.next-btn-dark.disabled.hover, .next-btn-ghost.next-btn-dark.disabled:active, .next-btn-ghost.next-btn-dark.disabled.active, .next-btn-ghost.next-btn-dark[disabled]:focus, .next-btn-ghost.next-btn-dark[disabled]:hover, .next-btn-ghost.next-btn-dark[disabled].hover, .next-btn-ghost.next-btn-dark[disabled]:active, .next-btn-ghost.next-btn-dark[disabled].active {\n          color: rgba(255, 255, 255, 0.4);\n          background-color: transparent;\n          border-color: rgba(255, 255, 255, 0.4);\n          text-decoration: none; }\n    .next-btn-ghost.next-btn-light {\n      background-color: transparent;\n      border-color: #333333; }\n      .next-btn-ghost.next-btn-light, .next-btn-ghost.next-btn-light:link, .next-btn-ghost.next-btn-light:visited, .next-btn-ghost.next-btn-light.visited {\n        color: #333333; }\n      .next-btn-ghost.next-btn-light:focus, .next-btn-ghost.next-btn-light:hover, .next-btn-ghost.next-btn-light.hover, .next-btn-ghost.next-btn-light:active, .next-btn-ghost.next-btn-light.active {\n        color: #999999;\n        background-color: rgba(0, 0, 0, 0.92);\n        border-color: #333333;\n        text-decoration: none; }\n      .next-btn-ghost.next-btn-light.disabled, .next-btn-ghost.next-btn-light[disabled] {\n        background-color: transparent;\n        border-color: rgba(0, 0, 0, 0.1); }\n        .next-btn-ghost.next-btn-light.disabled, .next-btn-ghost.next-btn-light.disabled:link, .next-btn-ghost.next-btn-light.disabled:visited, .next-btn-ghost.next-btn-light.disabled.visited, .next-btn-ghost.next-btn-light[disabled], .next-btn-ghost.next-btn-light[disabled]:link, .next-btn-ghost.next-btn-light[disabled]:visited, .next-btn-ghost.next-btn-light[disabled].visited {\n          color: rgba(0, 0, 0, 0.1); }\n        .next-btn-ghost.next-btn-light.disabled:focus, .next-btn-ghost.next-btn-light.disabled:hover, .next-btn-ghost.next-btn-light.disabled.hover, .next-btn-ghost.next-btn-light.disabled:active, .next-btn-ghost.next-btn-light.disabled.active, .next-btn-ghost.next-btn-light[disabled]:focus, .next-btn-ghost.next-btn-light[disabled]:hover, .next-btn-ghost.next-btn-light[disabled].hover, .next-btn-ghost.next-btn-light[disabled]:active, .next-btn-ghost.next-btn-light[disabled].active {\n          color: rgba(0, 0, 0, 0.1);\n          background-color: transparent;\n          border-color: rgba(0, 0, 0, 0.1);\n          text-decoration: none; }\n  .next-btn-group {\n    position: relative;\n    display: inline-block;\n    vertical-align: middle; }\n    .next-btn-group > .next-btn {\n      position: relative;\n      float: left;\n      -webkit-box-shadow: none;\n              box-shadow: none; }\n      .next-btn-group > .next-btn:hover, .next-btn-group > .next-btn:focus, .next-btn-group > .next-btn:active, .next-btn-group > .next-btn.active {\n        z-index: 1; }\n      .next-btn-group > .next-btn.disabled, .next-btn-group > .next-btn[disabled] {\n        z-index: 0; }\n    .next-btn-group .next-btn.next-btn {\n      margin: 0 0 0 -1px; }\n    .next-btn-group .next-btn:not(:first-child):not(:last-child) {\n      border-radius: 0; }\n    .next-btn-group > .next-btn:first-child {\n      margin: 0; }\n    .next-btn-group > .next-btn:first-child:not(:last-child) {\n      border-bottom-right-radius: 0;\n      border-top-right-radius: 0; }\n    .next-btn-group > .next-btn:last-child:not(:first-child) {\n      border-bottom-left-radius: 0;\n      border-top-left-radius: 0; }\n    .next-btn-group > .next-btn-primary:not(:first-child) {\n      border-left-color: rgba(255, 255, 255, 0.2); }\n      .next-btn-group > .next-btn-primary:not(:first-child):hover {\n        border-left-color: transparent; }\n      .next-btn-group > .next-btn-primary:not(:first-child).disabled, .next-btn-group > .next-btn-primary:not(:first-child)[disabled] {\n        border-left-color: #E6E7EB; }\n\n/* 组合 */\n/* ---------------------------------------- */\n.next-btn-group[dir=\"rtl\"] > .next-btn {\n  float: right; }\n\n.next-btn-group[dir=\"rtl\"] .next-btn.next-btn {\n  margin: 0 -1px 0 0; }\n\n.next-btn-group[dir=\"rtl\"] > .next-btn:first-child:not(:last-child) {\n  border-bottom-left-radius: 0;\n  border-top-left-radius: 0; }\n\n.next-btn-group[dir=\"rtl\"] > .next-btn:last-child:not(:first-child) {\n  border-bottom-right-radius: 0;\n  border-top-right-radius: 0; }\n\n.next-btn-group[dir=\"rtl\"] > .next-btn-primary:not(:first-child) {\n  border-right-color: rgba(255, 255, 255, 0.2); }\n  .next-btn-group[dir=\"rtl\"] > .next-btn-primary:not(:first-child):hover {\n    border-right-color: transparent; }\n  .next-btn-group[dir=\"rtl\"] > .next-btn-primary:not(:first-child).disabled, .next-btn-group[dir=\"rtl\"] > .next-btn-primary:not(:first-child)[disabled] {\n    border-right-color: #E6E7EB; }\n\n/* 尺寸维度 */\n/* ---------------------------------------- */\n.next-btn.next-small[dir=\"rtl\"] {\n  border-radius: 3px; }\n  .next-btn.next-small[dir=\"rtl\"] > .next-btn-icon.next-icon-first {\n    margin-left: 4px;\n    margin-right: 0; }\n    .next-btn.next-small[dir=\"rtl\"] > .next-btn-icon.next-icon-first:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn.next-small[dir=\"rtl\"] > .next-btn-icon.next-icon-last {\n    margin-left: 0;\n    margin-right: 4px; }\n    .next-btn.next-small[dir=\"rtl\"] > .next-btn-icon.next-icon-last:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn.next-small[dir=\"rtl\"].next-btn-loading {\n    padding-left: 8px;\n    padding-right: 24px; }\n    .next-btn.next-small[dir=\"rtl\"].next-btn-loading:after {\n      right: 8px;\n      top: 50%;\n      margin-right: 0;\n      margin-left: 4px; }\n\n.next-btn.next-medium[dir=\"rtl\"] {\n  border-radius: 3px; }\n  .next-btn.next-medium[dir=\"rtl\"] > .next-btn-icon.next-icon-first {\n    margin-left: 4px;\n    margin-right: 0; }\n    .next-btn.next-medium[dir=\"rtl\"] > .next-btn-icon.next-icon-first:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn.next-medium[dir=\"rtl\"] > .next-btn-icon.next-icon-last {\n    margin-left: 0;\n    margin-right: 4px; }\n    .next-btn.next-medium[dir=\"rtl\"] > .next-btn-icon.next-icon-last:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn.next-medium[dir=\"rtl\"].next-btn-loading {\n    padding-left: 12px;\n    padding-right: 28px; }\n    .next-btn.next-medium[dir=\"rtl\"].next-btn-loading:after {\n      right: 12px;\n      top: 50%;\n      margin-right: 0;\n      margin-left: 4px; }\n\n.next-btn.next-large[dir=\"rtl\"] {\n  border-radius: 3px; }\n  .next-btn.next-large[dir=\"rtl\"] > .next-btn-icon.next-icon-first {\n    margin-left: 4px;\n    margin-right: 0; }\n    .next-btn.next-large[dir=\"rtl\"] > .next-btn-icon.next-icon-first:before {\n      width: 16px;\n      font-size: 16px;\n      line-height: inherit; }\n  .next-btn.next-large[dir=\"rtl\"] > .next-btn-icon.next-icon-last {\n    margin-left: 0;\n    margin-right: 4px; }\n    .next-btn.next-large[dir=\"rtl\"] > .next-btn-icon.next-icon-last:before {\n      width: 16px;\n      font-size: 16px;\n      line-height: inherit; }\n  .next-btn.next-large[dir=\"rtl\"].next-btn-loading {\n    padding-left: 16px;\n    padding-right: 36px; }\n    .next-btn.next-large[dir=\"rtl\"].next-btn-loading:after {\n      right: 16px;\n      top: 50%;\n      margin-right: 0;\n      margin-left: 4px; }\n\n/* 文本按钮 */\n.next-btn-text[dir=\"rtl\"].next-large {\n  border-radius: 0; }\n  .next-btn-text[dir=\"rtl\"].next-large > .next-btn-icon.next-icon-first {\n    margin-left: 4px;\n    margin-right: 0; }\n    .next-btn-text[dir=\"rtl\"].next-large > .next-btn-icon.next-icon-first:before {\n      width: 16px;\n      font-size: 16px;\n      line-height: inherit; }\n  .next-btn-text[dir=\"rtl\"].next-large > .next-btn-icon.next-icon-last {\n    margin-left: 0;\n    margin-right: 4px; }\n    .next-btn-text[dir=\"rtl\"].next-large > .next-btn-icon.next-icon-last:before {\n      width: 16px;\n      font-size: 16px;\n      line-height: inherit; }\n  .next-btn-text[dir=\"rtl\"].next-large.next-btn-loading {\n    padding-left: 0;\n    padding-right: 20px; }\n    .next-btn-text[dir=\"rtl\"].next-large.next-btn-loading:after {\n      right: 0;\n      top: 50%;\n      margin-right: 0;\n      margin-left: 4px; }\n\n.next-btn-text[dir=\"rtl\"].next-medium {\n  border-radius: 0; }\n  .next-btn-text[dir=\"rtl\"].next-medium > .next-btn-icon.next-icon-first {\n    margin-left: 4px;\n    margin-right: 0; }\n    .next-btn-text[dir=\"rtl\"].next-medium > .next-btn-icon.next-icon-first:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn-text[dir=\"rtl\"].next-medium > .next-btn-icon.next-icon-last {\n    margin-left: 0;\n    margin-right: 4px; }\n    .next-btn-text[dir=\"rtl\"].next-medium > .next-btn-icon.next-icon-last:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn-text[dir=\"rtl\"].next-medium.next-btn-loading {\n    padding-left: 0;\n    padding-right: 16px; }\n    .next-btn-text[dir=\"rtl\"].next-medium.next-btn-loading:after {\n      right: 0;\n      top: 50%;\n      margin-right: 0;\n      margin-left: 4px; }\n\n.next-btn-text[dir=\"rtl\"].next-small {\n  border-radius: 0; }\n  .next-btn-text[dir=\"rtl\"].next-small > .next-btn-icon.next-icon-first {\n    margin-left: 4px;\n    margin-right: 0; }\n    .next-btn-text[dir=\"rtl\"].next-small > .next-btn-icon.next-icon-first:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn-text[dir=\"rtl\"].next-small > .next-btn-icon.next-icon-last {\n    margin-left: 0;\n    margin-right: 4px; }\n    .next-btn-text[dir=\"rtl\"].next-small > .next-btn-icon.next-icon-last:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn-text[dir=\"rtl\"].next-small.next-btn-loading {\n    padding-left: 0;\n    padding-right: 16px; }\n    .next-btn-text[dir=\"rtl\"].next-small.next-btn-loading:after {\n      right: 0;\n      top: 50%;\n      margin-right: 0;\n      margin-left: 4px; }\n", ""]);

// exports


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n.next-overlay-wrapper .next-overlay-inner {\n  z-index: 1001; }\n\n.next-overlay-wrapper .next-overlay-backdrop {\n  position: fixed;\n  z-index: 1001;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: #000000;\n  -webkit-transition: opacity .3s;\n  transition: opacity .3s;\n  opacity: 0; }\n\n.next-overlay-wrapper.opened .next-overlay-backdrop {\n  opacity: 0.2; }\n", ""]);

// exports


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "", ""]);

// exports


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n/* put your code here */\n.next-loading {\n  position: relative;\n  display: inline-block;\n  /* 遮罩层 */\n  /* for IE9,10 */\n  /* text on the right side of */\n  /* 动效 */ }\n  .next-loading.next-open {\n    pointer-events: none; }\n  .next-loading .next-loading-component {\n    opacity: .7;\n    -webkit-filter: blur(1px);\n    filter: blur(1px);\n    -webkit-filter: \"progid:DXImageTransform.Microsoft.Blur(PixelRadius=1, MakeShadow=false)\";\n            filter: \"progid:DXImageTransform.Microsoft.Blur(PixelRadius=1, MakeShadow=false)\";\n    /* IE6~IE9 */\n    position: relative;\n    pointer-events: none; }\n  .next-loading-masker {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    z-index: 99;\n    opacity: .2;\n    background: #FFF; }\n  .next-loading-tip {\n    display: block;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    z-index: 4;\n    -webkit-transform: translate(-50%, -50%);\n        -ms-transform: translate(-50%, -50%);\n            transform: translate(-50%, -50%);\n    text-align: center; }\n  .next-loading-tip-placeholder {\n    display: none; }\n  .next-loading-right-tip .next-loading-indicator {\n    display: inline-block; }\n  .next-loading-right-tip .next-loading-tip-content {\n    position: absolute;\n    display: block;\n    top: 50%;\n    right: 0;\n    -webkit-transform: translate(0, -50%);\n        -ms-transform: translate(0, -50%);\n            transform: translate(0, -50%); }\n  .next-loading-right-tip .next-loading-tip-placeholder {\n    display: inline-block;\n    visibility: hidden;\n    margin-left: 1em; }\n  .next-loading-fusion-reactor {\n    display: inline-block;\n    width: 48px;\n    height: 48px;\n    position: relative;\n    margin: 0;\n    -webkit-animation-duration: 5.6s;\n    animation-duration: 5.6s;\n    -webkit-animation-iteration-count: infinite;\n    animation-iteration-count: infinite;\n    -webkit-animation-timing-function: linear;\n    animation-timing-function: linear;\n    -webkit-animation-name: nextVectorRoute;\n    animation-name: nextVectorRoute; }\n    .next-loading-fusion-reactor .next-loading-dot {\n      position: absolute;\n      margin: auto;\n      width: 12px;\n      height: 12px;\n      border-radius: 50%;\n      background: #5584FF;\n      -webkit-animation-timing-function: ease-in-out;\n      animation-timing-function: ease-in-out;\n      -webkit-animation-iteration-count: infinite;\n      animation-iteration-count: infinite;\n      -webkit-animation-duration: 1.4s;\n      animation-duration: 1.4s; }\n      .next-loading-fusion-reactor .next-loading-dot:nth-child(1) {\n        top: 0;\n        bottom: 0;\n        left: 0;\n        -webkit-animation-name: nextVectorDotsX;\n        animation-name: nextVectorDotsX; }\n      .next-loading-fusion-reactor .next-loading-dot:nth-child(2) {\n        left: 0;\n        right: 0;\n        top: 0;\n        opacity: .8;\n        -webkit-animation-name: nextVectorDotsY;\n        animation-name: nextVectorDotsY; }\n      .next-loading-fusion-reactor .next-loading-dot:nth-child(3) {\n        top: 0;\n        bottom: 0;\n        right: 0;\n        opacity: .6;\n        -webkit-animation-name: nextVectorDotsXR;\n        animation-name: nextVectorDotsXR; }\n      .next-loading-fusion-reactor .next-loading-dot:nth-child(4) {\n        left: 0;\n        right: 0;\n        bottom: 0;\n        opacity: .2;\n        -webkit-animation-name: nextVectorDotsYR;\n        animation-name: nextVectorDotsYR; }\n  .next-loading-medium-fusion-reactor {\n    width: 32px;\n    height: 32px; }\n    .next-loading-medium-fusion-reactor .next-loading-dot {\n      width: 8px;\n      height: 8px; }\n      .next-loading-medium-fusion-reactor .next-loading-dot:nth-child(1) {\n        -webkit-animation-name: nextVectorDotsX-medium;\n        animation-name: nextVectorDotsX-medium; }\n      .next-loading-medium-fusion-reactor .next-loading-dot:nth-child(2) {\n        -webkit-animation-name: nextVectorDotsY-medium;\n        animation-name: nextVectorDotsY-medium; }\n      .next-loading-medium-fusion-reactor .next-loading-dot:nth-child(3) {\n        -webkit-animation-name: nextVectorDotsXR-medium;\n        animation-name: nextVectorDotsXR-medium; }\n      .next-loading-medium-fusion-reactor .next-loading-dot:nth-child(4) {\n        -webkit-animation-name: nextVectorDotsYR-medium;\n        animation-name: nextVectorDotsYR-medium; }\n\n@-webkit-keyframes nextVectorRoute {\n  0% {\n    -webkit-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    transform: rotate(0deg); }\n  5% {\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    transform: rotate(90deg); }\n  25% {\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    transform: rotate(90deg); }\n  30% {\n    -webkit-transform: rotate(180deg);\n    -ms-transform: rotate(180deg);\n    transform: rotate(180deg); }\n  50% {\n    -webkit-transform: rotate(180deg);\n    -ms-transform: rotate(180deg);\n    transform: rotate(180deg); }\n  55% {\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    transform: rotate(270deg); }\n  75% {\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    transform: rotate(270deg); }\n  80% {\n    -webkit-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    transform: rotate(360deg); }\n  100% {\n    -webkit-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    transform: rotate(360deg); } }\n\n@keyframes nextVectorRoute {\n  0% {\n    -webkit-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    transform: rotate(0deg); }\n  5% {\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    transform: rotate(90deg); }\n  25% {\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    transform: rotate(90deg); }\n  30% {\n    -webkit-transform: rotate(180deg);\n    -ms-transform: rotate(180deg);\n    transform: rotate(180deg); }\n  50% {\n    -webkit-transform: rotate(180deg);\n    -ms-transform: rotate(180deg);\n    transform: rotate(180deg); }\n  55% {\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    transform: rotate(270deg); }\n  75% {\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    transform: rotate(270deg); }\n  80% {\n    -webkit-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    transform: rotate(360deg); }\n  100% {\n    -webkit-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    transform: rotate(360deg); } }\n\n/* 20% 的时间在旋转 */\n@-webkit-keyframes nextVectorDotsYR {\n  25% {\n    bottom: 0; }\n  45%,\n  50% {\n    bottom: 16.8px;\n    height: 14.4px;\n    width: 14.4px; }\n  90% {\n    bottom: 0;\n    height: 12px;\n    width: 12px; } }\n\n@keyframes nextVectorDotsYR {\n  25% {\n    bottom: 0; }\n  45%,\n  50% {\n    bottom: 16.8px;\n    height: 14.4px;\n    width: 14.4px; }\n  90% {\n    bottom: 0;\n    height: 12px;\n    width: 12px; } }\n\n@-webkit-keyframes nextVectorDotsY {\n  25% {\n    top: 0; }\n  45%,\n  50% {\n    top: 16.8px;\n    height: 14.4px;\n    width: 14.4px; }\n  90% {\n    top: 0;\n    height: 12px;\n    width: 12px; } }\n\n@keyframes nextVectorDotsY {\n  25% {\n    top: 0; }\n  45%,\n  50% {\n    top: 16.8px;\n    height: 14.4px;\n    width: 14.4px; }\n  90% {\n    top: 0;\n    height: 12px;\n    width: 12px; } }\n\n@-webkit-keyframes nextVectorDotsX {\n  25% {\n    left: 0; }\n  45%,\n  50% {\n    left: 16.8px;\n    width: 14.4px;\n    height: 14.4px; }\n  90% {\n    left: 0;\n    height: 12px;\n    width: 12px; } }\n\n@keyframes nextVectorDotsX {\n  25% {\n    left: 0; }\n  45%,\n  50% {\n    left: 16.8px;\n    width: 14.4px;\n    height: 14.4px; }\n  90% {\n    left: 0;\n    height: 12px;\n    width: 12px; } }\n\n@-webkit-keyframes nextVectorDotsXR {\n  25% {\n    right: 0; }\n  45%,\n  50% {\n    right: 16.8px;\n    width: 14.4px;\n    height: 14.4px; }\n  90% {\n    right: 0;\n    height: 12px;\n    width: 12px; } }\n\n@keyframes nextVectorDotsXR {\n  25% {\n    right: 0; }\n  45%,\n  50% {\n    right: 16.8px;\n    width: 14.4px;\n    height: 14.4px; }\n  90% {\n    right: 0;\n    height: 12px;\n    width: 12px; } }\n\n@-webkit-keyframes nextVectorDotsYR-medium {\n  25% {\n    bottom: 0; }\n  45%,\n  50% {\n    bottom: 11.2px;\n    height: 9.6px;\n    width: 9.6px; }\n  90% {\n    bottom: 0;\n    height: 8px;\n    width: 8px; } }\n\n@keyframes nextVectorDotsYR-medium {\n  25% {\n    bottom: 0; }\n  45%,\n  50% {\n    bottom: 11.2px;\n    height: 9.6px;\n    width: 9.6px; }\n  90% {\n    bottom: 0;\n    height: 8px;\n    width: 8px; } }\n\n@-webkit-keyframes nextVectorDotsY-medium {\n  25% {\n    top: 0; }\n  45%,\n  50% {\n    top: 11.2px;\n    height: 9.6px;\n    width: 9.6px; }\n  90% {\n    top: 0;\n    height: 8px;\n    width: 8px; } }\n\n@keyframes nextVectorDotsY-medium {\n  25% {\n    top: 0; }\n  45%,\n  50% {\n    top: 11.2px;\n    height: 9.6px;\n    width: 9.6px; }\n  90% {\n    top: 0;\n    height: 8px;\n    width: 8px; } }\n\n@-webkit-keyframes nextVectorDotsX-medium {\n  25% {\n    left: 0; }\n  45%,\n  50% {\n    left: 11.2px;\n    width: 9.6px;\n    height: 9.6px; }\n  90% {\n    left: 0;\n    height: 8px;\n    width: 8px; } }\n\n@keyframes nextVectorDotsX-medium {\n  25% {\n    left: 0; }\n  45%,\n  50% {\n    left: 11.2px;\n    width: 9.6px;\n    height: 9.6px; }\n  90% {\n    left: 0;\n    height: 8px;\n    width: 8px; } }\n\n@-webkit-keyframes nextVectorDotsXR-medium {\n  25% {\n    right: 0; }\n  45%,\n  50% {\n    right: 11.2px;\n    width: 9.6px;\n    height: 9.6px; }\n  90% {\n    right: 0;\n    height: 8px;\n    width: 8px; } }\n\n@keyframes nextVectorDotsXR-medium {\n  25% {\n    right: 0; }\n  45%,\n  50% {\n    right: 11.2px;\n    width: 9.6px;\n    height: 9.6px; }\n  90% {\n    right: 0;\n    height: 8px;\n    width: 8px; } }\n", ""]);

// exports


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n/* put your code here */\n.next-table {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  position: relative; }\n  .next-table *,\n  .next-table *:before,\n  .next-table *:after {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box; }\n  .next-table table {\n    border-collapse: collapse;\n    border-spacing: 0;\n    width: 100%;\n    background: #FFFFFF; }\n    .next-table table tr:first-child td {\n      border-top-width: 0; }\n  .next-table th {\n    padding: 0;\n    background: #EBECF0;\n    color: #333333;\n    text-align: left;\n    font-weight: normal;\n    border: 1px solid #DCDEE3; }\n    .next-table th .next-table-cell-wrapper {\n      padding: 12px 16px;\n      overflow: hidden;\n      text-overflow: ellipsis;\n      word-break: break-all; }\n  .next-table-affix {\n    z-index: 1; }\n  .next-table-header-resizable {\n    position: relative; }\n    .next-table-header-resizable .next-table-resize-handler {\n      position: absolute;\n      right: 0;\n      top: 0;\n      bottom: 0;\n      width: 3px;\n      background: transparent;\n      cursor: ew-resize; }\n  .next-table td {\n    padding: 0;\n    border: 1px solid #DCDEE3; }\n    .next-table td .next-table-cell-wrapper {\n      padding: 12px 16px;\n      overflow: hidden;\n      text-overflow: ellipsis;\n      word-break: break-all; }\n      .next-table td .next-table-cell-wrapper .next-icon-arrow-down.next-table-tree-arrow,\n      .next-table td .next-table-cell-wrapper .next-icon-arrow-right.next-table-tree-arrow,\n      .next-table td .next-table-cell-wrapper .next-table-tree-placeholder {\n        margin-right: 3px;\n        float: left; }\n      .next-table td .next-table-cell-wrapper .next-icon-arrow-down.next-table-tree-arrow:before,\n      .next-table td .next-table-cell-wrapper .next-icon-arrow-right.next-table-tree-arrow:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n  .next-table .next-table-expanded .next-table-cell-wrapper,\n  .next-table .next-table-selection .next-table-cell-wrapper {\n    overflow: visible; }\n  .next-table.no-header table tr:first-child td {\n    border-top-width: 1px; }\n  .next-table.only-bottom-border {\n    border-width: 0; }\n    .next-table.only-bottom-border th {\n      border-width: 0 0 1px 0; }\n    .next-table.only-bottom-border td {\n      border-width: 0 0 1px 0; }\n    .next-table.only-bottom-border .next-table-expanded-row th {\n      border-width: 0 0 1px 0; }\n    .next-table.only-bottom-border .next-table-expanded-row td {\n      border-width: 0 0 1px 0; }\n  .next-table-loading {\n    display: block; }\n  .next-table.zebra tr:nth-child(odd) td {\n    background: #FFFFFF; }\n  .next-table.zebra tr:nth-child(even) td {\n    background: #F7F8FA; }\n  .next-table.zebra .next-table-row.hovered td {\n    background: #F2F3F7;\n    color: #333333; }\n  .next-table.zebra .next-table-row.selected td {\n    background: #F2F3F7;\n    color: #333333; }\n  .next-table-empty {\n    color: #A0A2AD;\n    padding: 32px 0;\n    text-align: center; }\n  .next-table-expanded-row td {\n    border-width: 0; }\n    .next-table-expanded-row td:first-child {\n      border-left-width: 1px; }\n    .next-table-expanded-row td:last-child {\n      border-right-width: 1px; }\n  .next-table-expanded-row:last-child td {\n    border-bottom-width: 1px; }\n  .next-table-expanded-row .next-table .last td {\n    border-bottom-width: 0; }\n  .next-table-filter-footer {\n    margin: 10px 10px 0; }\n    .next-table-filter-footer button {\n      margin-right: 5px; }\n  .next-table-row {\n    -webkit-transition: all ease .3s;\n    transition: all ease .3s;\n    background: #FFFFFF;\n    color: #333333; }\n    .next-table-row.hidden {\n      display: none; }\n    .next-table-row.hovered {\n      background: #F2F3F7;\n      color: #333333; }\n    .next-table-row.selected {\n      background: #F2F3F7;\n      color: #333333; }\n  .next-table-tree-placeholder {\n    display: inline-block;\n    width: 12px; }\n\n.last .next-table-expanded-row td {\n  border-bottom-width: 1px; }\n\n.next-table-body,\n.next-table-header {\n  overflow: auto;\n  font-size: 12px; }\n\n.next-table-body {\n  font-size: 12px; }\n\n.next-table-fixed {\n  border: 1px solid #DCDEE3; }\n  .next-table-fixed table {\n    table-layout: fixed; }\n  .next-table-fixed .next-table-header {\n    background: #EBECF0; }\n  .next-table-fixed table tr td:first-child,\n  .next-table-fixed table tr th:first-child {\n    border-left-width: 0; }\n  .next-table-fixed .next-table-header th {\n    border-top-width: 0; }\n  .next-table-fixed .next-table-header tr th:last-child {\n    border-right-width: 0; }\n  .next-table-fixed .next-table-body td {\n    border-top-width: 0; }\n  .next-table-fixed .next-table-body tr:last-child td {\n    border-bottom-width: 0; }\n  .next-table-fixed .next-table-body tr td:last-child {\n    border-right-width: 0; }\n  .next-table-fixed.next-table-group table tr td:first-child,\n  .next-table-fixed.next-table-group table tr th:first-child {\n    border-left-width: 1px; }\n  .next-table-fixed.next-table-group .next-table-header th {\n    border-top-width: 1px; }\n  .next-table-fixed.next-table-group .next-table-header tr th:last-child {\n    border-right-width: 1px; }\n  .next-table-fixed.next-table-group .next-table-body td {\n    border-top-width: 1px; }\n  .next-table-fixed.next-table-group .next-table-body tr:last-child td {\n    border-bottom-width: 1px; }\n  .next-table-fixed.next-table-group .next-table-body tr td:last-child {\n    border-right-width: 1px; }\n\n.next-table-lock .next-table-body {\n  overflow-x: auto;\n  overflow-y: visible; }\n\n.next-table-group {\n  border-width: 0; }\n  .next-table-group .next-table-body {\n    margin-top: 8px; }\n    .next-table-group .next-table-body table {\n      margin-bottom: 8px; }\n      .next-table-group .next-table-body table tr:first-child td {\n        border-top-width: 1px; }\n  .next-table-group .next-table-group-header td {\n    background: #EBECF0;\n    color: #333333; }\n  .next-table-group .next-table-group-footer td {\n    background: #EBECF0;\n    color: #333333; }\n  .next-table-group .next-table-row.hovered,\n  .next-table-group .next-table-row.selected {\n    background: #FFFFFF;\n    color: #333333; }\n\n.next-table-lock {\n  position: relative; }\n  .next-table-lock table {\n    table-layout: fixed; }\n\n.next-table-header-inner {\n  overflow: hidden; }\n\n.next-table-lock-left,\n.next-table-lock-right {\n  position: absolute;\n  left: 0;\n  top: 0;\n  z-index: 1;\n  border: 0; }\n  .next-table-lock-left table,\n  .next-table-lock-right table {\n    width: auto; }\n  .next-table-lock-left .next-table-body,\n  .next-table-lock-right .next-table-body {\n    overflow: hidden; }\n\n.next-table-lock-right {\n  right: 0;\n  left: auto; }\n  .next-table-lock-right table tr td:first-child,\n  .next-table-lock-right table tr th:first-child {\n    border-left-width: 1px; }\n  .next-table-lock-right.shadow {\n    -webkit-box-shadow: -2px 0 3px rgba(0, 0, 0, 0.12);\n            box-shadow: -2px 0 3px rgba(0, 0, 0, 0.12); }\n\n.next-table-lock-left.shadow {\n  -webkit-box-shadow: 2px 0 3px rgba(0, 0, 0, 0.12);\n          box-shadow: 2px 0 3px rgba(0, 0, 0, 0.12); }\n\n.next-table-filter {\n  line-height: 1; }\n\n.next-table-sort {\n  position: relative;\n  width: 16px;\n  height: 15px;\n  display: inline-block;\n  vertical-align: middle;\n  line-height: 1; }\n  .next-table-sort .next-icon {\n    position: absolute;\n    left: 0;\n    color: #333333; }\n    .next-table-sort .next-icon:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-table-sort .current .next-icon {\n    color: #5584FF; }\n  .next-table-sort .next-icon-ascending {\n    left: 4px; }\n\n.next-table-filter {\n  margin-left: 5px;\n  cursor: pointer;\n  width: 20px;\n  display: inline-block; }\n  .next-table-filter .next-icon {\n    color: #333333; }\n    .next-table-filter .next-icon:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n\n.next-table-expanded-ctrl.disabled {\n  color: #999999; }\n\n.next-table-expanded-ctrl .next-icon:before {\n  width: 12px;\n  font-size: 12px;\n  line-height: inherit; }\n", ""]);

// exports


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = {
    momentLocale: 'zh-cn',
    Timeline: {
        expand: '展开',
        fold: '收起'
    },
    Card: {
        expand: '展开',
        fold: '收起'
    },
    Calendar: {
        today: '今天',
        now: '此刻',
        ok: '确定',
        clear: '清除',
        month: '月',
        year: '年',
        prevYear: '上一年',
        nextYear: '下一年',
        prevMonth: '上个月',
        nextMonth: '下个月',
        prevDecade: '上十年',
        nextDecade: '后十年'
    },
    DatePicker: {
        placeholder: '请选择日期',
        datetimePlaceholder: '请选择日期和时间',
        monthPlaceholder: '请选择月',
        yearPlaceholder: '请选择年',
        now: '此刻',
        selectTime: '选择时间',
        selectDate: '选择日期',
        ok: '确定',
        clear: '清除',
        startPlaceholder: '起始日期',
        endPlaceholder: '结束日期',
        hour: '时',
        minute: '分',
        second: '秒'
    },
    Dialog: {
        ok: '确认',
        cancel: '取消'
    },
    Pagination: {
        prev: '上一页',
        next: '下一页',
        goTo: '到第',
        page: '页',
        go: '确定',
        pageSize: '每页显示：'
    },
    Input: {
        clear: '清除'
    },
    Select: {
        selectPlaceholder: '请选择',
        autoCompletePlaceholder: '请输入',
        notFoundContent: '无选项'
    },
    Table: {
        empty: '没有数据',
        ok: '确认',
        reset: '重置',
        asc: '升序',
        desc: '降序',
        expanded: '已展开',
        folded: '已折叠',
        filter: '筛选',
        selectAll: '全选'
    },
    TimePicker: {
        placeholder: '请选择时间',
        clear: '清除',
        hour: '时',
        minute: '分',
        second: '秒'
    },
    Transfer: {
        items: '项',
        item: '项',
        moveAll: '移动全部',
        searchPlaceholder: '请输入'
    },
    Upload: {
        card: {
            cancel: '取消',
            addPhoto: '上传图片'
        },
        drag: {
            text: '点击或者拖动文件到虚线框内上传',
            hint: '支持 docx, xls, PDF, rar, zip, PNG, JPG 等类型的文件'
        }
    },
    Search: {
        buttonText: '搜索'
    }
};
module.exports = exports['default'];

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(12);

__webpack_require__(150);

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _checkbox = __webpack_require__(59);

var _checkbox2 = _interopRequireDefault(_checkbox);

var _checkboxGroup = __webpack_require__(112);

var _checkboxGroup2 = _interopRequireDefault(_checkboxGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_checkbox2.default.Group = _checkboxGroup2.default;

exports.default = _checkbox2.default;
module.exports = exports['default'];

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(11);

__webpack_require__(12);

__webpack_require__(145);

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = getContextProps;
function getContextProps(props, context, displayName) {
    var prefix = props.prefix,
        locale = props.locale,
        pure = props.pure,
        rtl = props.rtl;
    var nextPrefix = context.nextPrefix,
        nextLocale = context.nextLocale,
        nextPure = context.nextPure,
        nextWarning = context.nextWarning,
        nextRtl = context.nextRtl;


    var newPrefix = prefix || nextPrefix;

    var localeFromContext = void 0;
    if (nextLocale) {
        localeFromContext = nextLocale[displayName];
        if (localeFromContext) {
            localeFromContext.momentLocale = nextLocale.momentLocale;
        }
    }
    var newLocale = void 0;
    if (locale) {
        newLocale = _extends({}, localeFromContext || {}, locale);
    } else if (localeFromContext) {
        newLocale = localeFromContext;
    }

    var newPure = typeof pure === 'boolean' ? pure : nextPure;
    var newRtl = typeof rtl === 'boolean' ? rtl : nextRtl;

    return {
        prefix: newPrefix,
        locale: newLocale,
        pure: newPure,
        rtl: newRtl,
        warning: nextWarning
    };
}
module.exports = exports['default'];

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.matches = exports.hasDOM = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.hasClass = hasClass;
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.toggleClass = toggleClass;
exports.getStyle = getStyle;
exports.setStyle = setStyle;
exports.scrollbar = scrollbar;
exports.getOffset = getOffset;

var _string = __webpack_require__(41);

var _object = __webpack_require__(13);

/**
 * 是否能使用 DOM 方法
 * @type {Boolean}
 */
var hasDOM = exports.hasDOM = typeof window !== 'undefined' && !!window.document && !!document.createElement;

/**
 * 节点是否包含指定 className
 * @param  {Element}  node
 * @param  {String}  className
 * @return {Boolean}
 *
 * @example
 * dom.hasClass(document.body, 'foo');
 */
function hasClass(node, className) {
    /* istanbul ignore if */
    if (!hasDOM || !node) {
        return false;
    }

    if (node.classList) {
        return node.classList.contains(className);
    } else {
        return node.className.indexOf(className) > -1;
    }
}

/**
 * 添加 className
 * @param {Element} node
 * @param {String} className
 *
 * @example
 * dom.addClass(document.body, 'foo');
 */
function addClass(node, className, _force) {
    /* istanbul ignore if */
    if (!hasDOM || !node) {
        return;
    }

    if (node.classList) {
        node.classList.add(className);
    } else if (_force === true || !hasClass(node, className)) {
        node.className += ' ' + className;
    }
}

/**
 * 移除 className
 * @param  {Element} node
 * @param  {String} className
 *
 * @example
 * dom.removeClass(document.body, 'foo');
 */
function removeClass(node, className, _force) {
    /* istanbul ignore if */
    if (!hasDOM || !node) {
        return;
    }

    if (node.classList) {
        node.classList.remove(className);
    } else if (_force === true || hasClass(node, className)) {
        node.className = node.className.replace(className, '').replace(/\s+/g, ' ').trim();
    }
}

/**
 * 切换 className
 * @param  {Element} node
 * @param  {String} className
 * @return {Boolean}           执行后节点上是否还有此 className
 *
 * @example
 * dom.toggleClass(document.body, 'foo');
 */
function toggleClass(node, className) {
    /* istanbul ignore if */
    if (!hasDOM || !node) {
        return false;
    }

    if (node.classList) {
        return node.classList.toggle(className);
    } else {
        var flag = hasClass(node, className);
        flag ? removeClass(node, className, true) : addClass(node, className, true);

        return !flag;
    }
}

/**
 * 元素是否匹配 CSS 选择器
 * @param  {Element} node       DOM 节点
 * @param  {String}  selector   CSS 选择器
 * @return {Boolean}
 *
 * @example
 * dom.matches(mountNode, '.container'); // boolean
 */
var matches = exports.matches = function () {
    var matchesFn = null;
    /* istanbul ignore else */
    if (hasDOM) {
        var _body = document.body || document.head;
        matchesFn = _body.matches ? 'matches' : _body.webkitMatchesSelector ? 'webkitMatchesSelector' : _body.msMatchesSelector ? 'msMatchesSelector' : _body.mozMatchesSelector ? 'mozMatchesSelector' : null;
    }

    return function (node, selector) {
        if (!hasDOM || !node) {
            return false;
        }

        return matchesFn ? node[matchesFn](selector) : false;
    };
}();

/**
 * 获取元素计算后的样式
 * @private
 * @param  {Element} node
 * @return {Object}
 */
function _getComputedStyle(node) {
    return node && node.nodeType === 1 ? window.getComputedStyle(node, null) : {};
}

var PIXEL_PATTERN = /margin|padding|width|height|max|min|offset|size/i;
var removePixel = { left: 1, top: 1, right: 1, bottom: 1 };

/**
 * 校验并修正元素的样式属性值
 * @private
 * @param  {Element} node
 * @param  {String} type
 * @param  {Number} value
 */
function _getStyleValue(node, type, value) {
    type = type.toLowerCase();

    if (value === 'auto') {
        if (type === 'height') {
            return node.offsetHeight || 0;
        }
        if (type === 'width') {
            return node.offsetWidth || 0;
        }
    }

    if (!(type in removePixel)) {
        // 属性值是否需要去掉 px 单位，这里假定此类的属性值都是 px 为单位的
        removePixel[type] = PIXEL_PATTERN.test(type);
    }

    return removePixel[type] ? parseFloat(value) || 0 : value;
}

var floatMap = { cssFloat: 1, styleFloat: 1, float: 1 };

/**
 * 获取元素计算后的样式
 * @param  {Element} node DOM 节点
 * @param  {String} name 属性名
 * @return {Number|Object}
 */
function getStyle(node, name) {
    /* istanbul ignore if */
    if (!hasDOM || !node) {
        return null;
    }

    var style = _getComputedStyle(node);

    // 如果不指定属性名，则返回全部值
    if (arguments.length === 1) {
        return style;
    }

    name = floatMap[name] ? 'cssFloat' in node.style ? 'cssFloat' : 'styleFloat' : name;

    return _getStyleValue(node, name, style.getPropertyValue((0, _string.hyphenate)(name)) || node.style[(0, _string.camelcase)(name)]);
}

/**
 * 设置元素的样式
 * @param {Element} node  DOM 节点
 * @param {Object|String} name  属性名，或者是一个对象，包含多个属性
 * @param {Number|String} value 属性值
 *
 * @example
 * // 设置单个属性值
 * dom.setStyle(mountNode, 'width', 100);
 * // 设置多条属性值
 * dom.setStyle(mountNode, {
 *     width: 100,
 *     height: 200
 * });
 */
function setStyle(node, name, value) {
    /* istanbul ignore if */
    if (!hasDOM || !node) {
        return false;
    }

    // 批量设置多个值
    if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object' && arguments.length === 2) {
        (0, _object.each)(name, function (val, key) {
            return setStyle(node, key, val);
        });
    } else {
        name = floatMap[name] ? 'cssFloat' in node.style ? 'cssFloat' : 'styleFloat' : name;
        if (typeof value === 'number' && PIXEL_PATTERN.test(name)) {
            value = value + 'px';
        }
        node.style[(0, _string.camelcase)(name)] = value; // IE8 support
    }
}

/**
 * 获取默认的滚动条大小
 * @return {Object} width, height
 */
function scrollbar() {
    var scrollDiv = document.createElement('div');

    setStyle(scrollDiv, {
        position: 'absolute',
        width: '100px',
        height: '100px',
        overflow: 'scroll',
        top: '-9999px'
    });
    document.body.appendChild(scrollDiv);
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    var scrollbarHeight = scrollDiv.offsetHeight - scrollDiv.clientHeight;
    document.body.removeChild(scrollDiv);

    return {
        width: scrollbarWidth,
        height: scrollbarHeight
    };
}

/**
 * 获取元素距离视口顶部和左边的偏移距离
 * @return {Object} top, left
 */
function getOffset(node) {
    var rect = node.getBoundingClientRect();
    var win = node.ownerDocument.defaultView;
    return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
    };
}

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.camelcase = camelcase;
exports.hyphenate = hyphenate;
/**
 * 将字符串转化为驼峰式写法
 * @param  {String} str 例：-webkit-transition
 * @return {String}     例：WebkitTransition
 */
function camelcase(str) {
    if (!/-/.test(str)) {
        return str || '';
    }
    return str.toLowerCase().replace(/-([a-z])/g, function ($0, $1) {
        return $1.toUpperCase();
    });
}

/**
 * 将驼峰式字符串转化为连字符写法
 * @param  {String} str 例：WebkitTransition
 * @return {String}     例：-webkit-transition
 */
function hyphenate(str) {
    return str.replace(/([A-Z])/g, function ($0) {
        return '-' + $0.toLowerCase();
    });
}

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

exports.__esModule = true;
/**
 * IE浏览器的渲染引擎版本号
 * 注意：此属性与浏览器版本号不同，IE的渲染引擎版本号是可以通过HTML header或手动设置去更改的
 * @type {Number} 6 ~ 10
 */
var ieVersion = exports.ieVersion = typeof document !== 'undefined' ? document.documentMode : undefined;

/**
 * 判断是否是生产环境
 * @type {Boolean}
 */
var isProduction = exports.isProduction = function isProduction() {
    var PRODUCTION_ENV = 'production';
    var result = false;
    try {
        if (process.env.NODE_ENV === PRODUCTION_ENV) {
            result = true;
        }
    } catch (err) {
        //
    }

    if (!result) {
        try {
            if (window.process.env.NODE_ENV === PRODUCTION_ENV) {
                result = true;
            }
        } catch (err) {
            //
        }
    }

    return result;
};

exports.default = {
    ieVersion: ieVersion,
    isProduction: isProduction
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    ESC: 27,
    SPACE: 32,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,

    // version 0.x
    ESCAPE: 27,
    LEFT_ARROW: 37,
    UP_ARROW: 38,
    RIGHT_ARROW: 39,
    DOWN_ARROW: 40,

    // MacOS
    CONTROL: 17,
    OPTION: 18,
    CMD: 91,
    COMMAND: 91,
    DELETE: 8
};
module.exports = exports["default"];

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var styleEqual = __webpack_require__(96);
var hasOwnProperty = Object.prototype.hasOwnProperty;

function type(a) {
  return Array.isArray(a) ? 'array' : typeof a === 'undefined' ? 'undefined' : _typeof(a);
}

function elementEquals(a, b) {
  var typeOfA = type(a);
  var typeOfB = type(b);

  if (typeOfA !== typeOfB) return false;

  switch (typeOfA) {
    case 'array':
      if (a.length !== b.length) return false;
      for (var i = 0; i < a.length; i++) {
        if (!elementEquals(a[i], b[i])) return false;
      }
      return true;
    case 'object':
      if (!a || !b) return a === b;
      if (a.type !== b.type) return false;
      if (a.key !== b.key) return false;
      if (a.ref !== b.ref) return false;
      return shallowElementEquals(a.props, b.props);
      break;
    default:
      return a === b;
  }
}

function shallowElementEquals(a, b) {
  var aCount = 0;
  var bCount = 0;

  for (var key in a) {
    if (hasOwnProperty.call(a, key)) {
      if (key === 'style') {
        // NOTE(lmr): kind of risky, but i'm assuming that a `style` prop is a React Native style,
        // and using the `styleEqual` algorithm here.
        if (!styleEqual(a[key], b[key])) return false;
      } else if (key === 'children') {
        // will compare children later
      } else {
        if (a[key] !== b[key]) return false;
      }
      aCount++;
    }
  }

  for (var key in b) {
    if (hasOwnProperty.call(b, key)) {
      bCount++;
    }
  }

  if (aCount !== bCount) return false;

  // compare children last...
  return elementEquals(a.children, b.children);
}

module.exports = shallowElementEquals;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _util = __webpack_require__(2);

var _manager = __webpack_require__(97);

var _manager2 = _interopRequireDefault(_manager);

var _gateway = __webpack_require__(46);

var _gateway2 = _interopRequireDefault(_gateway);

var _position = __webpack_require__(47);

var _position2 = _interopRequireDefault(_position);

var _findNode = __webpack_require__(21);

var _findNode2 = _interopRequireDefault(_findNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var saveLastFocusNode = _util.focus.saveLastFocusNode,
    getFocusNodeList = _util.focus.getFocusNodeList,
    backLastFocusNode = _util.focus.backLastFocusNode;
var makeChain = _util.func.makeChain,
    noop = _util.func.noop,
    bindCtx = _util.func.bindCtx;


var isScrollDisplay = function isScrollDisplay(element) {
    try {
        var scrollbarStyle = window.getComputedStyle(element, '::-webkit-scrollbar');
        return !scrollbarStyle || scrollbarStyle.getPropertyValue('display') !== 'none';
    } catch (e) {
        // ignore error for firefox
    }

    return true;
};
var hasScroll = function hasScroll() {
    var doc = document.documentElement;
    return doc.scrollHeight > doc.clientHeight && _util.dom.scrollbar().width > 0 && isScrollDisplay(document.documentElement) && isScrollDisplay(document.body);
};
var prefixes = ['-webkit-', '-moz-', '-o-', 'ms-', ''];
var getStyleProperty = function getStyleProperty(node, name) {
    var style = window.getComputedStyle(node);
    var ret = '';
    for (var i = 0; i < prefixes.length; i++) {
        ret = style.getPropertyValue(prefixes[i] + name);
        if (ret) {
            break;
        }
    }
    return ret;
};

var modals = [];
var bodyOverflowY = void 0,
    bodyPaddingRight = void 0;

/**
 * Overlay
 * */
var Overlay = (_temp = _class = function (_Component) {
    _inherits(Overlay, _Component);

    function Overlay(props) {
        _classCallCheck(this, Overlay);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        _this.saveContentRef = function (ref) {
            _this.contentRef = ref;
        };

        _this.saveGatewayRef = function (ref) {
            _this.gatewayRef = ref;
        };

        _this.state = {
            visible: props.visible,
            status: 'none',
            animation: _this.getAnimation(props)
        };

        _this.lastAlign = props.align;

        bindCtx(_this, ['handlePosition', 'handleAnimateEnd', 'handleDocumentKeyDown', 'handleDocumentClick', 'handleMaskClick', 'beforeOpen', 'beforeClose']);

        _this.timeoutMap = {};
        return _this;
    }

    Overlay.prototype.componentWillMount = function componentWillMount() {
        if (this.props.visible) {
            this.beforeOpen();
            this.props.beforeOpen();

            if (this.state.animation && _util.support.animation) {
                this.enter();
            }
        }
    };

    Overlay.prototype.componentDidMount = function componentDidMount() {
        this.componentDidUpdate({ visible: false });
        this.addDocumentEvents();

        _manager2.default.addOverlay(this);

        if (this.state.visible) {
            this._isMounted = true;
        }
    };

    Overlay.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (!this._isMounted && nextProps.visible) {
            this._isMounted = true;
        }

        var willOpen = !this.props.visible && nextProps.visible;
        var willClose = this.props.visible && !nextProps.visible;
        if (willOpen) {
            this.beforeOpen();
            nextProps.beforeOpen();
        } else if (willClose) {
            this.beforeClose();
            nextProps.beforeClose();
        }

        if (nextProps.animation || nextProps.animation === false) {
            this.setState({
                animation: nextProps.animation
            });
        }

        if (nextProps.animation !== false && _util.support.animation) {
            if (willOpen) {
                this.enter();
            } else if (willClose) {
                this.leave();
            }
        } else {
            this.setState({
                visible: nextProps.visible
            });
        }
    };

    Overlay.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
        var _this2 = this;

        var open = !prevProps.visible && this.props.visible;
        var close = prevProps.visible && !this.props.visible;
        if (this.state.animation && _util.support.animation) {
            if (open || close) {
                this.addAnimationEvents();
            }
        } else {
            var wrapperNode = this.getWrapperNode();
            if (open) {
                setTimeout(function () {
                    _this2.props.onOpen();
                    _this2.props.afterOpen();
                    _util.dom.addClass(wrapperNode, 'opened');
                    _manager2.default.addOverlay(_this2);
                });
            } else if (close) {
                this.props.onClose();
                this.props.afterClose();
                _util.dom.removeClass(wrapperNode, 'opened');
                _manager2.default.removeOverlay(this);
            }
            this.setFocusNode();
        }
    };

    Overlay.prototype.componentWillUnmount = function componentWillUnmount() {
        this._isDestroyed = true;
        this._isMounted = false;
        _manager2.default.removeOverlay(this);
        this.removeDocumentEvents();
        if (this.focusTimeout) {
            clearTimeout(this.focusTimeout);
        }
        if (this._animation) {
            this._animation.off();
            this._animation = null;
        }
        this.beforeClose();
    };

    Overlay.prototype.getAnimation = function getAnimation(props) {
        if (props.animation === false) {
            return false;
        }

        if (props.animation) {
            return props.animation;
        }

        return this.getAnimationByAlign(props.align);
    };

    Overlay.prototype.getAnimationByAlign = function getAnimationByAlign(align) {
        switch (align[0]) {
            case 't':
                return {
                    in: 'expandInDown',
                    out: 'expandOutUp'
                };
            case 'b':
                return {
                    in: 'expandInUp',
                    out: 'expandOutDown'
                };
            default:
                return {
                    in: 'expandInDown',
                    out: 'expandOutUp'
                };
        }
    };

    Overlay.prototype.addAnimationEvents = function addAnimationEvents() {
        var _this3 = this;

        setTimeout(function () {
            var node = _this3.getContentNode();
            if (node) {
                var id = (0, _util.guid)();

                _this3._animation = _util.events.on(node, _util.support.animation.end, _this3.handleAnimateEnd.bind(_this3, id));

                var animationDelay = parseFloat(getStyleProperty(node, 'animation-delay')) || 0;
                var animationDuration = parseFloat(getStyleProperty(node, 'animation-duration')) || 0;
                var time = animationDelay + animationDuration;
                if (time) {
                    _this3.timeoutMap[id] = setTimeout(function () {
                        _this3.handleAnimateEnd(id);
                    }, time * 1000 + 200);
                }
            }
        });
    };

    Overlay.prototype.handlePosition = function handlePosition(config) {
        var align = config.align.join(' ');

        if (!('animation' in this.props) && this.props.needAdjust && this.lastAlign !== align) {
            this.setState({
                animation: this.getAnimationByAlign(align)
            });
        }

        this.lastAlign = align;
    };

    Overlay.prototype.handleAnimateEnd = function handleAnimateEnd(id) {
        if (this.timeoutMap[id]) {
            clearTimeout(this.timeoutMap[id]);
        }
        delete this.timeoutMap[id];

        if (this._animation) {
            this._animation.off();
            this._animation = null;
        }

        if (!this._isMounted) {
            return;
        }

        if (this.state.status === 'leaving') {
            this.setState({
                visible: false,
                status: 'none'
            });

            this.onLeaved();
        } else if (this.state.status === 'entering') {
            this.setState({
                status: 'none'
            });

            this.onEntered();
        }
    };

    Overlay.prototype.enter = function enter() {
        var _this4 = this;

        this.setState({
            visible: true,
            status: 'entering'
        }, function () {
            // NOTE: setState callback (second argument) now fires immediately after componentDidMount / componentDidUpdate instead of after all components have rendered.
            setTimeout(function () {
                if (!_this4._isDestroyed) {
                    _this4.onEntering();
                }
            });
        });
    };

    Overlay.prototype.leave = function leave() {
        this.setState({
            status: 'leaving'
        });

        this.onLeaving();
    };

    Overlay.prototype.onEntering = function onEntering() {
        var wrapperNode = this.getWrapperNode();
        _util.dom.addClass(wrapperNode, 'opened');
        this.props.onOpen();
    };

    Overlay.prototype.onLeaving = function onLeaving() {
        var wrapperNode = this.getWrapperNode();
        _util.dom.removeClass(wrapperNode, 'opened');
        this.props.onClose();
    };

    Overlay.prototype.onEntered = function onEntered() {
        _manager2.default.addOverlay(this);
        this.setFocusNode();
        this.props.afterOpen();
    };

    Overlay.prototype.onLeaved = function onLeaved() {
        _manager2.default.removeOverlay(this);
        this.setFocusNode();
        this.props.afterClose();
    };

    Overlay.prototype.beforeOpen = function beforeOpen() {
        if (this.props.disableScroll) {
            if (modals.length === 0) {
                var style = {
                    overflowY: 'hidden'
                };
                var body = document.body;
                bodyOverflowY = body.style.overflowY;
                if (hasScroll()) {
                    bodyPaddingRight = body.style.paddingRight;
                    style.paddingRight = _util.dom.getStyle(body, 'paddingRight') + _util.dom.scrollbar().width + 'px';
                }

                _util.dom.setStyle(body, style);
            }
            modals.push(this);
        }
    };

    Overlay.prototype.beforeClose = function beforeClose() {
        if (this.props.disableScroll) {
            var index = modals.indexOf(this);
            if (index > -1) {
                if (modals.length === 1) {
                    var style = {
                        overflowY: bodyOverflowY
                    };
                    if (hasScroll()) {
                        style.paddingRight = bodyPaddingRight;
                    }

                    _util.dom.setStyle(document.body, style);

                    bodyOverflowY = undefined;
                    bodyPaddingRight = undefined;
                }

                modals.splice(index, 1);
            }
        }
    };

    Overlay.prototype.setFocusNode = function setFocusNode() {
        var _this5 = this;

        if (!this.props.autoFocus) {
            return;
        }

        if (this.state.visible && !this._hasFocused) {
            saveLastFocusNode();
            // 这个时候很可能上一个弹层的关闭事件还未触发，导致焦点已经回到触发的元素
            // 这里延时处理一下，延时的时间为 document.click 捕获触发的延时时间
            this.focusTimeout = setTimeout(function () {
                var node = _this5.getContentNode();
                if (node) {
                    var focusNodeList = getFocusNodeList(node);
                    if (focusNodeList.length) {
                        focusNodeList[0].focus();
                    }
                    _this5._hasFocused = true;
                }
            }, 100);
        } else if (!this.state.visible && this._hasFocused) {
            backLastFocusNode();
            this._hasFocused = false;
        }
    };

    Overlay.prototype.getContent = function getContent() {
        return this.contentRef;
    };

    Overlay.prototype.getContentNode = function getContentNode() {
        return (0, _reactDom.findDOMNode)(this.contentRef);
    };

    Overlay.prototype.getWrapperNode = function getWrapperNode() {
        return this.gatewayRef ? this.gatewayRef.getChildNode() : null;
    };

    Overlay.prototype.addDocumentEvents = function addDocumentEvents() {
        if (this.props.canCloseByEsc) {
            this._keydownEvents = _util.events.on(document, 'keydown', this.handleDocumentKeyDown);
        }
        if (this.props.canCloseByOutSideClick) {
            this._clickEvents = _util.events.on(document, 'click', this.handleDocumentClick);
        }
    };

    Overlay.prototype.removeDocumentEvents = function removeDocumentEvents() {
        if (this._keydownEvents) {
            this._keydownEvents.off();
            this._keydownEvents = null;
        }
        if (this._clickEvents) {
            this._clickEvents.off();
            this._clickEvents = null;
        }
    };

    Overlay.prototype.handleDocumentKeyDown = function handleDocumentKeyDown(e) {
        if (this.state.visible && e.keyCode === _util.KEYCODE.ESC && _manager2.default.isCurrentOverlay(this)) {
            this.props.onRequestClose('keyboard', e);
        }
    };

    Overlay.prototype.handleDocumentClick = function handleDocumentClick(e) {
        var _this6 = this;

        if (this.state.visible) {
            var safeNode = this.props.safeNode;

            var safeNodes = Array.isArray(safeNode) ? [].concat(safeNode) : [safeNode];
            safeNodes.unshift(function () {
                return _this6.getWrapperNode();
            });

            for (var i = 0; i < safeNodes.length; i++) {
                var node = (0, _findNode2.default)(safeNodes[i], this.props);
                // HACK: 如果触发点击的节点是弹层内部的节点，并且在被点击后立即销毁，那么此时无法使用 node.contains(e.target)
                // 来判断此时点击的节点是否是弹层内部的节点，额外判断
                if (node && (node === e.target || node.contains(e.target) || e.target !== document && !document.documentElement.contains(e.target))) {
                    return;
                }
            }

            this.props.onRequestClose('docClick', e);
        }
    };

    Overlay.prototype.handleMaskClick = function handleMaskClick(e) {
        if (this.props.canCloseByMask) {
            this.props.onRequestClose('maskClick', e);
        }
    };

    // 兼容过去的用法: this.popupRef.getInstance().overlay.getInstance().getContentNode()
    Overlay.prototype.getInstance = function getInstance() {
        return this;
    };

    Overlay.prototype.render = function render() {
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            style = _props.style,
            propChildren = _props.children,
            target = _props.target,
            align = _props.align,
            offset = _props.offset,
            container = _props.container,
            hasMask = _props.hasMask,
            needAdjust = _props.needAdjust,
            beforePosition = _props.beforePosition,
            onPosition = _props.onPosition,
            wrapperStyle = _props.wrapperStyle,
            rtl = _props.rtl,
            propShouldUpdatePosition = _props.shouldUpdatePosition,
            cache = _props.cache,
            wrapperClassName = _props.wrapperClassName,
            onMaskMouseEnter = _props.onMaskMouseEnter,
            onMaskMouseLeave = _props.onMaskMouseLeave;
        var _state = this.state,
            stateVisible = _state.visible,
            status = _state.status,
            animation = _state.animation;


        var children = stateVisible || cache && this._isMounted ? propChildren : null;
        if (children) {
            var _classnames;

            var child = _react.Children.only(children);
            var childClazz = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'overlay-inner'] = true, _classnames[animation.in] = status === 'entering', _classnames[animation.out] = status === 'leaving', _classnames[child.props.className] = !!child.props.className, _classnames[className] = !!className, _classnames));
            if (typeof child.ref === 'string') {
                throw new Error('Can not set ref by string in Overlay, use function instead.');
            }

            children = _react2.default.cloneElement(child, {
                className: childClazz,
                style: _extends({}, child.props.style, style),
                ref: makeChain(this.saveContentRef, child.ref),
                'aria-hidden': !stateVisible && cache && this._isMounted
            });

            if (align) {
                var shouldUpdatePosition = status === 'leaving' ? false : propShouldUpdatePosition;
                children = _react2.default.createElement(_position2.default, {
                    children: children, target: target, align: align, offset: offset, needAdjust: needAdjust,
                    beforePosition: beforePosition,
                    onPosition: makeChain(this.handlePosition, onPosition),
                    shouldUpdatePosition: shouldUpdatePosition, rtl: rtl
                });
            }

            var wrapperClazz = (0, _classnames3.default)([prefix + 'overlay-wrapper', wrapperClassName]);
            var newWrapperStyle = _extends({}, {
                display: stateVisible ? '' : 'none'
            }, wrapperStyle);

            children = _react2.default.createElement(
                'div',
                { className: wrapperClazz, style: newWrapperStyle, dir: rtl ? 'rtl' : undefined },
                hasMask ? _react2.default.createElement('div', { className: prefix + 'overlay-backdrop',
                    onClick: this.handleMaskClick,
                    onMouseEnter: onMaskMouseEnter,
                    onMouseLeave: onMaskMouseLeave,
                    dir: rtl ? 'rtl' : undefined }) : null,
                children
            );
        }

        return _react2.default.createElement(_gateway2.default, _extends({ container: container, target: target, children: children }, { ref: this.saveGatewayRef }));
    };

    return Overlay;
}(_react.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    rtl: _propTypes2.default.bool,
    className: _propTypes2.default.string,
    style: _propTypes2.default.object,
    /**
     * 弹层内容
     */
    children: _propTypes2.default.any,
    /**
     * 是否显示弹层
     */
    visible: _propTypes2.default.bool,
    /**
     * 弹层请求关闭时触发事件的回调函数
     * @param {String} type 弹层关闭的来源
     * @param {Object} e DOM 事件
     */
    onRequestClose: _propTypes2.default.func,
    /**
     * 弹层定位的参照元素
     */
    target: _propTypes2.default.any,
    /**
     * 弹层相对于参照元素的定位, 详见开发指南的[定位部分](#定位)
     */
    align: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.bool]),
    /**
     * 弹层相对于参照元素定位的微调
     */
    offset: _propTypes2.default.array,
    /**
     * 渲染组件的容器，如果是函数需要返回 ref，如果是字符串则是该 DOM 的 id，也可以直接传入 DOM 节点
     */
    container: _propTypes2.default.any,
    /**
     * 是否显示遮罩
     */
    hasMask: _propTypes2.default.bool,
    /**
     * 是否支持 esc 按键关闭弹层
     */
    canCloseByEsc: _propTypes2.default.bool,
    /**
     * 点击弹层外的区域是否关闭弹层，不显示遮罩时生效
     */
    canCloseByOutSideClick: _propTypes2.default.bool,
    /**
     * 点击遮罩区域是否关闭弹层，显示遮罩时生效
     */
    canCloseByMask: _propTypes2.default.bool,
    /**
     * 弹层打开前触发事件的回调函数
     */
    beforeOpen: _propTypes2.default.func,
    /**
     * 弹层打开时触发事件的回调函数
     */
    onOpen: _propTypes2.default.func,
    /**
     * 弹层打开后触发事件的回调函数, 如果有动画，则在动画结束后触发
     */
    afterOpen: _propTypes2.default.func,
    /**
     * 弹层关闭前触发事件的回调函数
     */
    beforeClose: _propTypes2.default.func,
    /**
     * 弹层关闭时触发事件的回调函数
     */
    onClose: _propTypes2.default.func,
    /**
     * 弹层关闭后触发事件的回调函数, 如果有动画，则在动画结束后触发
     */
    afterClose: _propTypes2.default.func,
    /**
     * 弹层定位完成前触发的事件
     */
    beforePosition: _propTypes2.default.func,
    /**
     * 弹层定位完成时触发的事件
     * @param {Object} config 定位的参数
     * @param {Array} config.align 对齐方式，如 ['cc', 'cc']（如果开启 needAdjust，可能和预先设置的 align 不同）
     * @param {Number} config.top 距离视口顶部距离
     * @param {Number} config.left 距离视口左侧距离
     * @param {Object} node 定位参照的容器节点
     */
    onPosition: _propTypes2.default.func,
    /**
     * 是否在每次弹层重新渲染后强制更新定位信息，一般用于弹层内容区域大小发生变化时，仍需保持原来的定位方式
     */
    shouldUpdatePosition: _propTypes2.default.bool,
    /**
     * 弹层打开时是否让其中的元素自动获取焦点
     */
    autoFocus: _propTypes2.default.bool,
    /**
     * 当弹层由于页面滚动等情况不在可视区域时，是否自动调整定位以出现在可视区域
     */
    needAdjust: _propTypes2.default.bool,
    /**
     * 是否禁用页面滚动
     */
    disableScroll: _propTypes2.default.bool,
    /**
     * 隐藏时是否保留子节点
     */
    cache: _propTypes2.default.bool,
    /**
     * 安全节点，当点击 document 的时候，如果包含该节点则不会关闭弹层，如果是函数需要返回 ref，如果是字符串则是该 DOM 的 id，也可以直接传入 DOM 节点，或者以上值组成的数组
     */
    safeNode: _propTypes2.default.any,
    /**
     * 弹层的根节点的样式类
     */
    wrapperClassName: _propTypes2.default.string,
    /**
     * 弹层的根节点的内联样式
     */
    wrapperStyle: _propTypes2.default.object,
    /**
     * 配置动画的播放方式，支持 { in: 'enter-class', out: 'leave-class' } 的对象参数，如果设置为 false，则不播放动画
     * @default { in: 'expandInDown', out: 'expandOutUp' }
     */
    animation: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.bool]),
    onMaskMouseEnter: _propTypes2.default.func,
    onMaskMouseLeave: _propTypes2.default.func
}, _class.defaultProps = {
    prefix: 'next-',
    pure: false,
    visible: false,
    onRequestClose: noop,
    target: _position2.default.VIEWPORT,
    align: 'tl bl',
    offset: [0, 0],
    hasMask: false,
    canCloseByEsc: true,
    canCloseByOutSideClick: true,
    canCloseByMask: true,
    beforeOpen: noop,
    onOpen: noop,
    afterOpen: noop,
    beforeClose: noop,
    onClose: noop,
    afterClose: noop,
    beforePosition: noop,
    onPosition: noop,
    onMaskMouseEnter: noop,
    onMaskMouseLeave: noop,
    shouldUpdatePosition: false,
    autoFocus: false,
    needAdjust: true,
    disableScroll: false,
    cache: false
}, _temp);
Overlay.displayName = 'Overlay';
exports.default = Overlay;
module.exports = exports['default'];

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

var _findNode = __webpack_require__(21);

var _findNode2 = _interopRequireDefault(_findNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var makeChain = _util.func.makeChain;
var Gateway = (_temp2 = _class = function (_Component) {
    _inherits(Gateway, _Component);

    function Gateway() {
        var _temp, _this, _ret;

        _classCallCheck(this, Gateway);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.saveChildRef = function (ref) {
            _this.child = ref;
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Gateway.prototype.componentDidMount = function componentDidMount() {
        this.containerNode = this.getContainerNode(this.props);
        this.forceUpdate();
    };

    Gateway.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        this.containerNode = this.getContainerNode(nextProps);
    };

    Gateway.prototype.getContainerNode = function getContainerNode(props) {
        var targetNode = (0, _findNode2.default)(props.target);
        return (0, _findNode2.default)(props.container, targetNode);
    };

    Gateway.prototype.getChildNode = function getChildNode() {
        return (0, _reactDom.findDOMNode)(this.child);
    };

    Gateway.prototype.render = function render() {
        if (!this.containerNode) {
            return null;
        }

        var children = this.props.children;

        var child = children ? _react.Children.only(children) : null;
        if (!child) {
            return null;
        }

        if (typeof child.ref === 'string') {
            throw new Error('Can not set ref by string in Gateway, use function instead.');
        }
        child = _react2.default.cloneElement(child, {
            ref: makeChain(this.saveChildRef, child.ref)
        });

        return (0, _reactDom.createPortal)(child, this.containerNode);
    };

    return Gateway;
}(_react.Component), _class.propTypes = {
    children: _propTypes2.default.node,
    container: _propTypes2.default.any,
    target: _propTypes2.default.any
}, _class.defaultProps = {
    container: function container() {
        return document.body;
    }
}, _temp2);
Gateway.displayName = 'Gateway';
exports.default = Gateway;
module.exports = exports['default'];

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

var _position = __webpack_require__(98);

var _position2 = _interopRequireDefault(_position);

var _findNode = __webpack_require__(21);

var _findNode2 = _interopRequireDefault(_findNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = _util.func.noop,
    bindCtx = _util.func.bindCtx;
var getStyle = _util.dom.getStyle;

var place = _position2.default.place;

var Position = (_temp = _class = function (_Component) {
    _inherits(Position, _Component);

    function Position(props) {
        _classCallCheck(this, Position);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        bindCtx(_this, ['handleResize']);
        return _this;
    }

    Position.prototype.componentDidMount = function componentDidMount() {
        this.setPosition();

        if (this.props.needListenResize) {
            _util.events.on(window, 'resize', this.handleResize);
        }
    };

    Position.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if ('align' in nextProps && nextProps.align !== this.props.align || nextProps.shouldUpdatePosition) {
            this.shouldUpdatePosition = true;
        }
    };

    Position.prototype.componentDidUpdate = function componentDidUpdate() {
        if (this.shouldUpdatePosition) {
            this.setPosition();
            this.shouldUpdatePosition = false;
        }
    };

    Position.prototype.componentWillUnmount = function componentWillUnmount() {
        if (this.props.needListenResize) {
            _util.events.off(window, 'resize', this.handleResize);
        }

        clearTimeout(this.resizeTimeout);
    };

    Position.prototype.setPosition = function setPosition() {
        var _props = this.props,
            align = _props.align,
            offset = _props.offset,
            beforePosition = _props.beforePosition,
            onPosition = _props.onPosition,
            needAdjust = _props.needAdjust,
            rtl = _props.rtl;


        beforePosition();

        var contentNode = this.getContentNode();
        var targetNode = this.getTargetNode();
        if (contentNode && targetNode) {
            var resultAlign = place({
                pinElement: contentNode,
                baseElement: targetNode,
                align: align,
                offset: offset,
                needAdjust: needAdjust,
                isRtl: rtl
            });
            var top = getStyle(contentNode, 'top');
            var left = getStyle(contentNode, 'left');

            onPosition({
                align: resultAlign.split(' '),
                top: top,
                left: left
            }, contentNode);
        }
    };

    Position.prototype.getContentNode = function getContentNode() {
        return (0, _reactDom.findDOMNode)(this);
    };

    Position.prototype.getTargetNode = function getTargetNode() {
        var target = this.props.target;


        return target === _position2.default.VIEWPORT ? _position2.default.VIEWPORT : (0, _findNode2.default)(target, this.props);
    };

    Position.prototype.handleResize = function handleResize() {
        var _this2 = this;

        clearTimeout(this.resizeTimeout);

        this.resizeTimeout = setTimeout(function () {
            _this2.setPosition();
        }, 200);
    };

    Position.prototype.render = function render() {
        return _react.Children.only(this.props.children);
    };

    return Position;
}(_react.Component), _class.VIEWPORT = _position2.default.VIEWPORT, _class.propTypes = {
    children: _propTypes2.default.node,
    target: _propTypes2.default.any,
    align: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.bool]),
    offset: _propTypes2.default.array,
    beforePosition: _propTypes2.default.func,
    onPosition: _propTypes2.default.func,
    needAdjust: _propTypes2.default.bool,
    needListenResize: _propTypes2.default.bool,
    shouldUpdatePosition: _propTypes2.default.bool,
    rtl: _propTypes2.default.bool
}, _class.defaultProps = {
    align: 'tl bl',
    offset: [0, 0],
    beforePosition: noop,
    onPosition: noop,
    needAdjust: true,
    needListenResize: true,
    shouldUpdatePosition: false,
    rtl: false
}, _temp);
Position.displayName = 'Position';
exports.default = Position;
module.exports = exports['default'];

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _filter = __webpack_require__(49);

var _filter2 = _interopRequireDefault(_filter);

var _sort = __webpack_require__(63);

var _sort2 = _interopRequireDefault(_sort);

var _cell = __webpack_require__(18);

var _cell2 = _interopRequireDefault(_cell);

var _resize = __webpack_require__(120);

var _resize2 = _interopRequireDefault(_resize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};
var Header = (_temp2 = _class = function (_React$Component) {
    _inherits(Header, _React$Component);

    function Header() {
        var _temp, _this, _ret;

        _classCallCheck(this, Header);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.getCellRef = function (i, j, cell) {
            _this.props.headerCellRef(i, j, cell);
        }, _this.onSort = function (dataIndex, order, sort) {
            _this.props.onSort(dataIndex, order, sort);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Header.prototype.render = function render() {
        var _this2 = this;

        /*eslint-disable no-unused-vars */
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            children = _props.children,
            Tag = _props.component,
            colGroup = _props.colGroup,
            columns = _props.columns,
            locale = _props.locale,
            filterParams = _props.filterParams,
            onFilter = _props.onFilter,
            components = _props.components,
            affixRef = _props.affixRef,
            headerCellRef = _props.headerCellRef,
            onSort = _props.onSort,
            sort = _props.sort,
            onResizeChange = _props.onResizeChange,
            pure = _props.pure,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'children', 'component', 'colGroup', 'columns', 'locale', 'filterParams', 'onFilter', 'components', 'affixRef', 'headerCellRef', 'onSort', 'sort', 'onResizeChange', 'pure']);

        var _components$Cell = components.Cell,
            Cell = _components$Cell === undefined ? _cell2.default : _components$Cell,
            _components$Filter = components.Filter,
            Filter = _components$Filter === undefined ? _filter2.default : _components$Filter,
            _components$Sort = components.Sort,
            Sort = _components$Sort === undefined ? _sort2.default : _components$Sort,
            _components$Resize = components.Resize,
            Resize = _components$Resize === undefined ? _resize2.default : _components$Resize;

        var rowSpan = columns.length;

        var header = columns.map(function (cols, index) {
            var col = cols.map(function (col, j) {
                var _classnames;

                /* eslint-disable no-unused-vars, prefer-const */
                var title = col.title,
                    colSpan = col.colSpan,
                    sortable = col.sortable,
                    resizable = col.resizable,
                    dataIndex = col.dataIndex,
                    filters = col.filters,
                    filterMode = col.filterMode,
                    width = col.width,
                    align = col.align,
                    className = col.className,
                    __normalized = col.__normalized,
                    lock = col.lock,
                    others = _objectWithoutProperties(col, ['title', 'colSpan', 'sortable', 'resizable', 'dataIndex', 'filters', 'filterMode', 'width', 'align', 'className', '__normalized', 'lock']);

                className = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-header-node'] = true, _classnames[prefix + 'table-header-resizable'] = resizable, _classnames[className] = className, _classnames));
                var attrs = {},
                    sortElement = void 0,
                    filterElement = void 0,
                    resizeElement = void 0;
                if (col.children && col.children.length) {
                    attrs.colSpan = colSpan;
                } else {
                    if (sortable) {
                        sortElement = _react2.default.createElement(Sort, { prefix: prefix,
                            dataIndex: dataIndex,
                            onSort: _this2.onSort,
                            sort: sort,
                            locale: locale });
                    }
                    if (resizable) {
                        resizeElement = _react2.default.createElement(Resize, { prefix: prefix, dataIndex: dataIndex, onChange: onResizeChange });
                    }

                    if (filters) {
                        filterElement = filters.length ? _react2.default.createElement(Filter, { dataIndex: dataIndex,
                            filters: filters,
                            prefix: prefix,
                            locale: locale,
                            filterParams: filterParams,
                            filterMode: filterMode,
                            onFilter: onFilter }) : null;
                    }
                    attrs.rowSpan = rowSpan - index;
                }
                return _react2.default.createElement(
                    Cell,
                    _extends({}, others, attrs, {
                        key: j,
                        prefix: prefix,
                        pure: pure,
                        cell: title,
                        component: 'th',
                        align: align,
                        className: className,
                        ref: _this2.getCellRef.bind(_this2, index, j),
                        type: 'header' }),
                    sortElement,
                    filterElement,
                    resizeElement
                );
            });
            return _react2.default.createElement(
                'tr',
                { key: index },
                col
            );
        });

        return _react2.default.createElement(
            Tag,
            _extends({ className: className }, others),
            header,
            children
        );
    };

    return Header;
}(_react2.default.Component), _class.propTypes = {
    children: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    className: _propTypes2.default.string,
    component: _propTypes2.default.string,
    columns: _propTypes2.default.array,
    colGroup: _propTypes2.default.object,
    headerCellRef: _propTypes2.default.func,
    locale: _propTypes2.default.object,
    filterParams: _propTypes2.default.object,
    onFilter: _propTypes2.default.func,
    components: _propTypes2.default.object,
    sort: _propTypes2.default.object,
    onSort: _propTypes2.default.func,
    onResizeChange: _propTypes2.default.func
}, _class.defaultProps = {
    component: 'thead',
    columns: [],
    headerCellRef: noop,
    onFilter: noop,
    components: {},
    onSort: noop,
    onResizeChange: noop
}, _temp2);
Header.displayName = 'Header';
exports.default = Header;
module.exports = exports['default'];

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp, _initialiseProps;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _dropdown = __webpack_require__(100);

var _dropdown2 = _interopRequireDefault(_dropdown);

var _menu = __webpack_require__(76);

var _menu2 = _interopRequireDefault(_menu);

var _button = __webpack_require__(71);

var _button2 = _interopRequireDefault(_button);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

// 共享状态的组件需要变成非受控组件
var Filter = (_temp = _class = function (_React$Component) {
    _inherits(Filter, _React$Component);

    function Filter(props) {
        _classCallCheck(this, Filter);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

        _initialiseProps.call(_this);

        var filterParams = props.filterParams || {};
        var filterConfig = filterParams[props.dataIndex] || {};
        _this.state = {
            visible: filterConfig.visible || false,
            selectedKeys: filterConfig.selectedKeys || []
        };
        _this._selectedKeys = [].concat(_this.state.selectedKeys);
        return _this;
    }

    Filter.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (nextProps.hasOwnProperty('filterParams') && typeof nextProps.filterParams !== 'undefined') {
            var dataIndex = nextProps.dataIndex || this.props.dataIndex;
            var filterParams = nextProps.filterParams || {};
            var filterConfig = filterParams[dataIndex] || {};
            var selectedKeys = filterConfig.selectedKeys || [];
            this.setState({
                selectedKeys: selectedKeys
            });
            this._selectedKeys = [].concat(selectedKeys);
        }
    };

    Filter.prototype.render = function render() {
        var _props = this.props,
            filters = _props.filters,
            prefix = _props.prefix,
            locale = _props.locale,
            filterMode = _props.filterMode;
        var _state = this.state,
            visible = _state.visible,
            selectedKeys = _state.selectedKeys;


        function renderMenuItem(item) {
            return _react2.default.createElement(
                _menu2.default.Item,
                { key: item.value },
                item.label
            );
        }

        function renderSubMenu(parent, children) {
            return _react2.default.createElement(
                _menu2.default.SubMenu,
                { label: parent.label, key: parent.value, selectable: false },
                renderMenuContent(children)
            );
        }

        function renderMenuContent(list) {
            return list.map(function (item) {
                if (item.children) {
                    return renderSubMenu(item, item.children);
                } else {
                    return renderMenuItem(item);
                }
            });
        }

        var content = renderMenuContent(filters),
            footer = _react2.default.createElement(
            'div',
            { className: prefix + 'table-filter-footer' },
            _react2.default.createElement(
                _button2.default,
                { type: 'primary', onClick: this.onFilterConfirm },
                locale.ok
            ),
            _react2.default.createElement(
                _button2.default,
                { onClick: this.onFilterClear },
                locale.reset
            )
        );

        return _react2.default.createElement(
            _dropdown2.default,
            { trigger: _react2.default.createElement(
                    'span',
                    { role: 'button',
                        'aria-label': locale.filter,
                        onKeyDown: this.filterKeydown,
                        tabIndex: '0',
                        className: prefix + 'table-filter' },
                    _react2.default.createElement(_icon2.default, { type: 'filter', size: 'small' })
                ),
                triggerType: 'click',
                visible: visible,
                autoFocus: true,
                container: function container(node) {
                    return node.parentNode;
                },
                onVisibleChange: this.onFilterVisible },
            _react2.default.createElement(
                _menu2.default,
                { footer: footer,
                    selectedKeys: selectedKeys,
                    selectMode: filterMode,
                    onSelect: this.onFilterSelect },
                content
            )
        );
    };

    return Filter;
}(_react2.default.Component), _class.propTypes = {
    dataIndex: _propTypes2.default.string,
    filters: _propTypes2.default.array,
    filterMode: _propTypes2.default.string,
    filterParams: _propTypes2.default.object,
    locale: _propTypes2.default.object,
    onFilter: _propTypes2.default.func,
    prefix: _propTypes2.default.string
}, _class.defaultProps = {
    onFilter: function onFilter() {}
}, _initialiseProps = function _initialiseProps() {
    var _this2 = this;

    this.filterKeydown = function (e) {
        e.preventDefault();
        e.stopPropagation();

        if (e.keyCode === _util.KEYCODE.ENTER) {
            _this2.setState({
                visible: !_this2.state.visible
            });
        }
    };

    this.onFilterVisible = function (visible) {
        _this2.setState({
            visible: visible
        });

        if (!visible) {
            var selectedKeys = [].concat(_this2._selectedKeys);

            _this2.setState({
                selectedKeys: selectedKeys
            });
        }
    };

    this.onFilterSelect = function (selectedKeys) {
        _this2.setState({
            visible: true,
            selectedKeys: selectedKeys
        });
    };

    this.onFilterConfirm = function () {
        var selectedKeys = _this2.state.selectedKeys;
        var filterParams = {},
            dataIndex = _this2.props.dataIndex;

        filterParams[dataIndex] = {
            visible: false,
            selectedKeys: selectedKeys
        };
        _this2._selectedKeys = [].concat(selectedKeys);
        _this2.setState({
            visible: false
        });
        // 兼容之前的格式
        _this2.props.onFilter(filterParams);
    };

    this.onFilterClear = function () {
        var filterParams = {},
            dataIndex = _this2.props.dataIndex;

        filterParams[dataIndex] = {
            visible: false,
            selectedKeys: []
        };
        _this2._selectedKeys = [];
        _this2.setState({
            selectedKeys: [],
            visible: false
        });
        // 兼容之前的格式
        _this2.props.onFilter(filterParams);
    };
}, _temp);
Filter.displayName = 'Filter';
exports.default = Filter;
module.exports = exports['default'];

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var bindCtx = _util.func.bindCtx;
var pickOthers = _util.obj.pickOthers;

var noop = function noop() {};

/**
 * Menu
 */
var Menu = (_temp = _class = function (_Component) {
    _inherits(Menu, _Component);

    function Menu(props) {
        _classCallCheck(this, Menu);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        var _this$props = _this.props,
            children = _this$props.children,
            selectedKeys = _this$props.selectedKeys,
            defaultSelectedKeys = _this$props.defaultSelectedKeys,
            focusedKey = _this$props.focusedKey,
            focusable = _this$props.focusable,
            autoFocus = _this$props.autoFocus;


        _this.newChildren = _this.getNewChildren(children);

        if (focusable) {
            _this.tabbableKey = _this.getFirstAvaliablelChildKey('0');
        }
        _this.state = {
            openKeys: _this.getInitOpenKeys(props),
            selectedKeys: _this.normalizeToArray(selectedKeys || defaultSelectedKeys),
            focusedKey: 'focusedKey' in _this.props ? focusedKey : focusable && autoFocus ? _this.tabbableKey : null
        };

        bindCtx(_this, ['handleOpen', 'handleSelect', 'handleItemClick', 'handleItemKeyDown', 'onBlur']);

        _this.popupNodes = [];
        return _this;
    }

    Menu.prototype.componentDidMount = function componentDidMount() {
        this.menuNode = (0, _reactDom.findDOMNode)(this);
    };

    Menu.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var state = {};

        if ('openKeys' in nextProps) {
            state.openKeys = this.normalizeToArray(nextProps.openKeys);
        }
        if ('selectedKeys' in nextProps) {
            state.selectedKeys = this.normalizeToArray(nextProps.selectedKeys);
        }
        if ('focusedKey' in nextProps) {
            state.focusedKey = nextProps.focusedKey;
        }

        if (Object.keys(state).length) {
            this.setState(state);
        }
    };

    Menu.prototype.componentWillUpdate = function componentWillUpdate(nextProps) {
        this.newChildren = this.getNewChildren(nextProps.children);
        if (this.props.focusable) {
            if (this.tabbableKey in this.k2n) {
                if (this.state.focusedKey) {
                    this.tabbableKey = this.state.focusedKey;
                }
            } else {
                this.tabbableKey = this.getFirstAvaliablelChildKey('0');
            }
        }
    };

    Menu.prototype.onBlur = function onBlur(e) {
        this.setState({
            focusedKey: ''
        });

        this.props.onBlur && this.props.onBlur(e);
    };

    Menu.prototype.getInitOpenKeys = function getInitOpenKeys(props) {
        var _this2 = this;

        var initOpenKeys = void 0;

        var openKeys = props.openKeys,
            defaultOpenKeys = props.defaultOpenKeys,
            defaultOpenAll = props.defaultOpenAll,
            mode = props.mode,
            openMode = props.openMode;

        if (openKeys) {
            initOpenKeys = openKeys;
        } else if (defaultOpenAll && mode === 'inline' && openMode === 'multiple') {
            initOpenKeys = Object.keys(this.k2n).filter(function (key) {
                return _this2.k2n[key].type === 'submenu';
            });
        } else {
            initOpenKeys = defaultOpenKeys;
        }

        return this.normalizeToArray(initOpenKeys);
    };

    Menu.prototype.getNewChildren = function getNewChildren(children) {
        var _this3 = this;

        this.k2n = {};
        this.p2n = {};
        var loop = function loop(children, posPrefix) {
            var indexWrapper = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { index: 0 };

            return _react.Children.map(children, function (child) {
                if (child && typeof child.type === 'function' && 'menuChildType' in child.type) {
                    var newChild = void 0;

                    var pos = void 0;
                    var props = { root: _this3 };

                    if (['item', 'submenu', 'group'].indexOf(child.type.menuChildType) > -1) {
                        pos = posPrefix + '-' + indexWrapper.index++;
                        var key = typeof child.key === 'string' ? child.key : pos;
                        var level = pos.split('-').length - 1;
                        _this3.k2n[key] = _this3.p2n[pos] = {
                            key: key,
                            pos: pos,
                            type: child.type.menuChildType,
                            disabled: child.props.disabled,
                            label: child.props.label || child.props.children
                        };

                        props._key = key;
                        props.level = level;
                        props.groupIndent = child.type.menuChildType === 'group' ? 1 : 0;
                    }

                    switch (child.type.menuChildType) {
                        case 'submenu':
                            newChild = (0, _react.cloneElement)(child, props, loop(child.props.children, pos));
                            break;
                        case 'group':
                            newChild = (0, _react.cloneElement)(child, props, loop(child.props.children, posPrefix, indexWrapper));
                            break;
                        case 'item':
                        case 'divider':
                            newChild = (0, _react.cloneElement)(child, props);
                            break;
                        default:
                            newChild = child;
                            break;
                    }

                    return newChild;
                }

                return child;
            });
        };

        return loop(children, '0');
    };

    Menu.prototype.normalizeToArray = function normalizeToArray(items) {
        if (items) {
            if (Array.isArray(items)) {
                return items;
            }
            return [items];
        }

        return [];
    };

    Menu.prototype.isSibling = function isSibling(currentPos, targetPos) {
        var currentNums = currentPos.split('-').slice(0, -1);
        var targetNums = targetPos.split('-').slice(0, -1);

        return currentNums.length === targetNums.length && currentNums.every(function (num, index) {
            return num === targetNums[index];
        });
    };

    Menu.prototype.isAncestor = function isAncestor(currentPos, targetPos) {
        var currentNums = currentPos.split('-');
        var targetNums = targetPos.split('-');

        return currentNums.length > targetNums.length && targetNums.every(function (num, index) {
            return num === currentNums[index];
        });
    };

    Menu.prototype.handleOpen = function handleOpen(key, open, triggerType, e) {
        var _this4 = this;

        var newOpenKeys = void 0;

        var _props = this.props,
            mode = _props.mode,
            openMode = _props.openMode;
        var openKeys = this.state.openKeys;

        var index = openKeys.indexOf(key);
        if (open && index === -1) {
            if (mode === 'inline') {
                if (openMode === 'single') {
                    newOpenKeys = openKeys.filter(function (k) {
                        return !_this4.isSibling(_this4.k2n[key].pos, _this4.k2n[k].pos);
                    });
                    newOpenKeys.push(key);
                } else {
                    newOpenKeys = openKeys.concat(key);
                }
            } else {
                newOpenKeys = openKeys.filter(function (k) {
                    return _this4.isAncestor(_this4.k2n[key].pos, _this4.k2n[k].pos);
                });
                newOpenKeys.push(key);
            }
        } else if (!open && index > -1) {
            if (mode === 'inline') {
                newOpenKeys = [].concat(openKeys.slice(0, index), openKeys.slice(index + 1));
            } else if (triggerType === 'docClick') {
                if (!this.popupNodes.concat(this.menuNode).some(function (node) {
                    return node.contains(e.target);
                })) {
                    newOpenKeys = [];
                }
            } else {
                newOpenKeys = openKeys.filter(function (k) {
                    return k !== key && !_this4.isAncestor(_this4.k2n[k].pos, _this4.k2n[key].pos);
                });
            }
        }

        if (newOpenKeys) {
            if (!('openKeys' in this.props)) {
                this.setState({
                    openKeys: newOpenKeys
                });
            }

            this.props.onOpen(newOpenKeys, {
                key: key,
                open: open
            });
        }
    };

    Menu.prototype.getPath = function getPath(key) {
        var keyPath = [];
        var labelPath = [];

        var pos = this.k2n[key].pos;
        var nums = pos.split('-');
        for (var i = 1; i < nums.length - 1; i++) {
            var parentNums = nums.slice(0, i + 1);
            var parentPos = parentNums.join('-');
            var parent = this.p2n[parentPos];
            keyPath.push(parent.key);
            labelPath.push(parent.label);
        }

        return {
            keyPath: keyPath,
            labelPath: labelPath
        };
    };

    Menu.prototype.handleSelect = function handleSelect(key, select, menuItem) {
        var pos = this.k2n[key].pos;
        var level = pos.split('-').length - 1;
        if (this.props.shallowSelect && level > 1) {
            return;
        }

        var newSelectedKeys = void 0;

        var selectMode = this.props.selectMode;
        var selectedKeys = this.state.selectedKeys;

        var index = selectedKeys.indexOf(key);
        if (select && index === -1) {
            if (selectMode === 'single') {
                newSelectedKeys = [key];
            } else if (selectMode === 'multiple') {
                newSelectedKeys = selectedKeys.concat(key);
            }
        } else if (!select && index > -1 && selectMode === 'multiple') {
            newSelectedKeys = [].concat(selectedKeys.slice(0, index), selectedKeys.slice(index + 1));
        }

        if (newSelectedKeys) {
            if (!('selectedKeys' in this.props)) {
                this.setState({
                    selectedKeys: newSelectedKeys
                });
            }

            this.props.onSelect(newSelectedKeys, menuItem, _extends({
                key: key,
                select: select,
                label: this.k2n[key].label
            }, this.getPath(key)));
        }
    };

    Menu.prototype.handleItemClick = function handleItemClick(key, item, e) {
        var _this5 = this;

        if (this.props.focusable) {
            if (!('focusedKey' in this.props)) {
                this.setState({
                    focusedKey: key
                });
            }

            this.props.onItemFocus(key, item, e);
        }

        if (item.props.type === 'item') {
            if (item.props.parentMode === 'popup' && this.state.openKeys.length) {
                if (!('openKeys' in this.props)) {
                    this.setState({
                        openKeys: []
                    });
                }

                this.props.onOpen([], {
                    key: this.state.openKeys.sort(function (prevKey, nextKey) {
                        return _this5.k2n[nextKey].pos.split('-').length - _this5.k2n[prevKey].pos.split('-').length;
                    })[0],
                    open: false
                });
            }

            this.props.onItemClick(key, item, e);
        }
    };

    Menu.prototype.isAvailablePos = function isAvailablePos(refPos, targetPos) {
        var _p2n$targetPos = this.p2n[targetPos],
            type = _p2n$targetPos.type,
            disabled = _p2n$targetPos.disabled;


        return this.isSibling(refPos, targetPos) && (type === 'item' && !disabled || type === 'submenu');
    };

    Menu.prototype.getAvailableKey = function getAvailableKey(pos, prev) {
        var _this6 = this;

        var ps = Object.keys(this.p2n).filter(function (p) {
            return _this6.isAvailablePos(pos, p);
        });
        if (ps.length > 1) {
            var index = ps.indexOf(pos);
            var targetIndex = void 0;
            if (prev) {
                targetIndex = index === 0 ? ps.length - 1 : index - 1;
            } else {
                targetIndex = index === ps.length - 1 ? 0 : index + 1;
            }

            return this.p2n[ps[targetIndex]].key;
        }

        return null;
    };

    Menu.prototype.getFirstAvaliablelChildKey = function getFirstAvaliablelChildKey(parentPos) {
        var _this7 = this;

        var pos = Object.keys(this.p2n).find(function (p) {
            return _this7.isAvailablePos(parentPos + '-0', p);
        });
        return pos ? this.p2n[pos].key : null;
    };

    Menu.prototype.getParentKey = function getParentKey(pos) {
        return this.p2n[pos.slice(0, pos.length - 2)].key;
    };

    Menu.prototype.handleItemKeyDown = function handleItemKeyDown(key, type, item, e) {
        if ([_util.KEYCODE.UP, _util.KEYCODE.DOWN, _util.KEYCODE.RIGHT, _util.KEYCODE.LEFT, _util.KEYCODE.ENTER, _util.KEYCODE.ESC, _util.KEYCODE.SPACE].indexOf(e.keyCode) > -1) {
            e.preventDefault();
            e.stopPropagation();
        }

        var focusedKey = this.state.focusedKey;

        var direction = this.props.direction;

        var pos = this.k2n[key].pos;
        var level = pos.split('-').length - 1;
        switch (e.keyCode) {
            case _util.KEYCODE.UP:
                {
                    var avaliableKey = this.getAvailableKey(pos, true);
                    if (avaliableKey) {
                        focusedKey = avaliableKey;
                    }
                    break;
                }
            case _util.KEYCODE.DOWN:
                {
                    var _avaliableKey = void 0;
                    if (direction === 'hoz' && level === 1 && type === 'submenu') {
                        this.handleOpen(key, true);
                        _avaliableKey = this.getFirstAvaliablelChildKey(pos);
                    } else {
                        _avaliableKey = this.getAvailableKey(pos, false);
                    }
                    if (_avaliableKey) {
                        focusedKey = _avaliableKey;
                    }
                    break;
                }
            case _util.KEYCODE.RIGHT:
                {
                    var _avaliableKey2 = void 0;
                    if (direction === 'hoz' && level === 1) {
                        _avaliableKey2 = this.getAvailableKey(pos, false);
                    } else if (type === 'submenu') {
                        this.handleOpen(key, true);
                        _avaliableKey2 = this.getFirstAvaliablelChildKey(pos);
                    }
                    if (_avaliableKey2) {
                        focusedKey = _avaliableKey2;
                    }
                    break;
                }
            case _util.KEYCODE.ENTER:
                {
                    if (type === 'submenu') {
                        this.handleOpen(key, true);
                        var _avaliableKey3 = this.getFirstAvaliablelChildKey(pos);
                        if (_avaliableKey3) {
                            focusedKey = _avaliableKey3;
                        }
                    }
                    break;
                }
            case _util.KEYCODE.LEFT:
                {
                    if (direction === 'hoz' && level === 1) {
                        var _avaliableKey4 = this.getAvailableKey(pos, true);
                        if (_avaliableKey4) {
                            focusedKey = _avaliableKey4;
                        }
                    } else if (level > 1) {
                        var parentKey = this.getParentKey(pos);
                        this.handleOpen(parentKey, false);
                        focusedKey = parentKey;
                    }
                    break;
                }
            case _util.KEYCODE.ESC:
                if (level > 1) {
                    var _parentKey = this.getParentKey(pos);
                    this.handleOpen(_parentKey, false);
                    focusedKey = _parentKey;
                }
                break;

            case _util.KEYCODE.TAB:
                focusedKey = null;
                break;
            default:
                break;
        }

        if (focusedKey !== this.state.focusedKey) {
            if (!('focusedKey' in this.props)) {
                this.setState({
                    focusedKey: focusedKey
                });
            }

            this.props.onItemKeyDown(focusedKey, item, e);
            this.props.onItemFocus(focusedKey, e);
        }
    };

    Menu.prototype.render = function render() {
        var _cx;

        var _props2 = this.props,
            prefix = _props2.prefix,
            className = _props2.className,
            direction = _props2.direction,
            hozAlign = _props2.hozAlign,
            header = _props2.header,
            footer = _props2.footer,
            selectMode = _props2.selectMode,
            rtl = _props2.rtl;

        var others = pickOthers(Object.keys(Menu.propTypes), this.props);

        var newClassName = (0, _classnames2.default)((_cx = {}, _cx[prefix + 'menu'] = true, _cx[prefix + 'ver'] = direction === 'ver', _cx[prefix + 'hoz'] = direction === 'hoz', _cx[className] = !!className, _cx));

        var role = direction === 'hoz' ? 'menubar' : 'menu';
        var headerElement = header ? _react2.default.createElement(
            'li',
            { className: prefix + 'menu-header' },
            header
        ) : null;
        var itemsElement = header || footer ? _react2.default.createElement(
            'ul',
            { className: prefix + 'menu-content' },
            this.newChildren
        ) : this.newChildren;
        var footerElement = footer ? _react2.default.createElement(
            'li',
            { className: prefix + 'menu-footer' },
            footer
        ) : null;
        var shouldWrapItemsAndFooter = hozAlign === 'right' && !!header;

        if (rtl) {
            others.dir = 'rtl';
        }

        return _react2.default.createElement(
            'ul',
            _extends({ role: role, onBlur: this.onBlur, className: newClassName, onKeyDown: this.handleEnter, 'aria-multiselectable': selectMode === 'multiple' }, others),
            headerElement,
            shouldWrapItemsAndFooter ? _react2.default.createElement(
                'div',
                { className: prefix + 'menu-hoz-right' },
                itemsElement,
                footerElement
            ) : null,
            !shouldWrapItemsAndFooter ? itemsElement : null,
            !shouldWrapItemsAndFooter ? footerElement : null
        );
    };

    return Menu;
}(_react.Component), _class.isNextMenu = true, _class.propTypes = {
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    rtl: _propTypes2.default.bool,
    className: _propTypes2.default.string,
    /**
     * 菜单项和子菜单
     */
    children: _propTypes2.default.node,
    /**
     * 点击菜单项触发的回调函数
     * @param {String} key 点击的菜单项的 key 值
     * @param {Object} item 点击的菜单项对象
     * @param {Object} event 点击的事件对象
     */
    onItemClick: _propTypes2.default.func,
    /**
     * 当前打开的子菜单的 key 值
     */
    openKeys: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),
    /**
     * 初始打开的子菜单的 key 值
     */
    defaultOpenKeys: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),
    /**
     * 初始展开所有的子菜单，只在 mode 设置为 'inline' 以及 openMode 设置为 'multiple' 下生效，优先级高于 defaultOpenKeys
     */
    defaultOpenAll: _propTypes2.default.bool,
    /**
     * 打开或关闭子菜单触发的回调函数
     * @param {String} key 打开的所有子菜单的 key 值
     * @param {Object} extra 额外参数
     * @param {String} extra.key 当前操作子菜单的 key 值
     * @param {Boolean} extra.open 是否是打开
     */
    onOpen: _propTypes2.default.func,
    /**
     * 子菜单打开的模式
     */
    mode: _propTypes2.default.oneOf(['inline', 'popup']),
    /**
     * 子菜单打开的触发行为
     */
    triggerType: _propTypes2.default.oneOf(['click', 'hover']),
    /**
     * 展开内连子菜单的模式，同时可以展开一个子菜单还是多个子菜单，该属性仅在 mode 为 inline 时生效
     */
    openMode: _propTypes2.default.oneOf(['single', 'multiple']),
    /**
     * 内连子菜单缩进距离
     */
    inlineIndent: _propTypes2.default.number,
    inlineArrowDirection: _propTypes2.default.oneOf(['down', 'right']),
    /**
     * 是否自动让弹层的宽度和菜单项保持一致，如果弹层的宽度比菜单项小则和菜单项保持一致，如果宽度大于菜单项则不做处理
     */
    popupAutoWidth: _propTypes2.default.bool,
    /**
     * 弹层的对齐方式
     */
    popupAlign: _propTypes2.default.oneOf(['follow', 'outside']),
    /**
     * 弹层自定义 props
     */
    popupProps: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    /**
     * 弹出子菜单自定义 className
     */
    popupClassName: _propTypes2.default.string,
    /**
     * 弹出子菜单自定义 style
     */
    popupStyle: _propTypes2.default.object,
    /**
     * 当前选中菜单项的 key 值
     */
    selectedKeys: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),
    /**
     * 初始选中菜单项的 key 值
     */
    defaultSelectedKeys: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),
    /**
     * 选中或取消选中菜单项触发的回调函数
     * @param {Array} selectedKeys 选中的所有菜单项的值
     * @param {Object} item 选中或取消选中的菜单项
     * @param {Object} extra 额外参数
     * @param {Boolean} extra.select 是否是选中
     * @param {Array} extra.key 菜单项的 key
     * @param {Object} extra.label 菜单项的文本
     * @param {Array} extra.keyPath 菜单项 key 的路径
     */
    onSelect: _propTypes2.default.func,
    /**
     * 选中模式，单选还是多选，默认无值，不可选
     */
    selectMode: _propTypes2.default.oneOf(['single', 'multiple']),
    /**
     * 是否只能选择第一层菜单项（不能选择子菜单中的菜单项）
     */
    shallowSelect: _propTypes2.default.bool,
    /**
     * 是否显示选中图标，如果设置为 false 需配合配置平台设置选中时的背景色以示区分
     */
    hasSelectedIcon: _propTypes2.default.bool,
    labelToggleChecked: _propTypes2.default.bool,
    /**
     * 菜单第一层展示方向
     */
    direction: _propTypes2.default.oneOf(['ver', 'hoz']),
    /**
     * 横向菜单条 item 和 footer 的对齐方向，在 direction 设置为 'hoz' 并且 header 存在时生效
     */
    hozAlign: _propTypes2.default.oneOf(['left', 'right']),
    /**
     * 自定义菜单头部
     */
    header: _propTypes2.default.node,
    /**
     * 自定义菜单尾部
     */
    footer: _propTypes2.default.node,
    /**
     * 是否自动获得焦点
     */
    autoFocus: _propTypes2.default.bool,
    /**
     * 当前获得焦点的子菜单或菜单项 key 值
     */
    focusedKey: _propTypes2.default.string,
    focusable: _propTypes2.default.bool,
    onItemFocus: _propTypes2.default.func,
    onBlur: _propTypes2.default.func,
    onItemKeyDown: _propTypes2.default.func,
    expandAnimation: _propTypes2.default.bool,
    itemClassName: _propTypes2.default.string
}, _class.defaultProps = {
    prefix: 'next-',
    pure: false,
    defaultOpenKeys: [],
    defaultOpenAll: false,
    onOpen: noop,
    mode: 'inline',
    triggerType: 'click',
    openMode: 'multiple',
    inlineIndent: 20,
    inlineArrowDirection: 'down',
    popupAutoWidth: false,
    popupAlign: 'follow',
    popupProps: {},
    defaultSelectedKeys: [],
    onSelect: noop,
    shallowSelect: false,
    hasSelectedIcon: true,
    labelToggleChecked: true,
    direction: 'ver',
    hozAlign: 'left',
    autoFocus: false,
    focusable: true,
    onItemFocus: noop,
    onItemKeyDown: noop,
    onItemClick: noop,
    expandAnimation: true
}, _temp);
Menu.displayName = 'Menu';
exports.default = Menu;
module.exports = exports['default'];

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactTransitionGroup = __webpack_require__(52);

var _child = __webpack_require__(109);

var _child2 = _interopRequireDefault(_child);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};
var FirstChild = function FirstChild(props) {
    var childrenArray = _react2.default.Children.toArray(props.children);
    return childrenArray[0] || null;
};

/**
 * Animate
 */
var Animate = (_temp = _class = function (_Component) {
    _inherits(Animate, _Component);

    function Animate() {
        _classCallCheck(this, Animate);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    Animate.prototype.normalizeNames = function normalizeNames(names) {
        if (typeof names === 'string') {
            return {
                appear: names + '-appear',
                appearActive: names + '-appear-active',
                enter: names + '-enter',
                enterActive: names + '-enter-active',
                leave: names + '-leave',
                leaveActive: names + '-leave-active'
            };
        }
        if ((typeof names === 'undefined' ? 'undefined' : _typeof(names)) === 'object') {
            return {
                appear: names.appear,
                appearActive: names.appear + '-active',
                enter: '' + names.enter,
                enterActive: names.enter + '-active',
                leave: '' + names.leave,
                leaveActive: names.leave + '-active'
            };
        }
    };

    Animate.prototype.render = function render() {
        var _this2 = this;

        /* eslint-disable no-unused-vars */
        var _props = this.props,
            animation = _props.animation,
            children = _props.children,
            animationAppear = _props.animationAppear,
            singleMode = _props.singleMode,
            component = _props.component,
            beforeAppear = _props.beforeAppear,
            onAppear = _props.onAppear,
            afterAppear = _props.afterAppear,
            beforeEnter = _props.beforeEnter,
            onEnter = _props.onEnter,
            afterEnter = _props.afterEnter,
            beforeLeave = _props.beforeLeave,
            onLeave = _props.onLeave,
            afterLeave = _props.afterLeave,
            others = _objectWithoutProperties(_props, ['animation', 'children', 'animationAppear', 'singleMode', 'component', 'beforeAppear', 'onAppear', 'afterAppear', 'beforeEnter', 'onEnter', 'afterEnter', 'beforeLeave', 'onLeave', 'afterLeave']);
        /* eslint-enable no-unused-vars */

        var animateChildren = _react.Children.map(children, function (child) {
            return _react2.default.createElement(
                _child2.default,
                { key: child.key,
                    names: _this2.normalizeNames(animation),
                    onAppear: beforeAppear,
                    onAppearing: onAppear,
                    onAppeared: afterAppear,
                    onEnter: beforeEnter,
                    onEntering: onEnter,
                    onEntered: afterEnter,
                    onExit: beforeLeave,
                    onExiting: onLeave,
                    onExited: afterLeave },
                child
            );
        });

        return _react2.default.createElement(
            _reactTransitionGroup.TransitionGroup,
            _extends({ appear: animationAppear, component: singleMode ? FirstChild : component }, others),
            animateChildren
        );
    };

    return Animate;
}(_react.Component), _class.propTypes = {
    /**
     * 动画 className
     */
    animation: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),
    /**
     * 子元素第一次挂载时是否执行动画
     */
    animationAppear: _propTypes2.default.bool,
    /**
     * 包裹子元素的标签
     */
    component: _propTypes2.default.any,
    /**
     * 是否只有单个子元素，如果有多个子元素，请设置为 false
     */
    singleMode: _propTypes2.default.bool,
    /**
     * 子元素
     */
    children: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.arrayOf(_propTypes2.default.element)]),
    /**
     * 执行第一次挂载动画前触发的回调函数
     */
    beforeAppear: _propTypes2.default.func,
    /**
     * 执行第一次挂载动画，添加 xxx-appear-active 类名后触发的回调函数
     *  @param {HTMLElement} node 执行动画的 dom 元素
     */
    onAppear: _propTypes2.default.func,
    /**
     * 执行完第一次挂载动画后触发的函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    afterAppear: _propTypes2.default.func,
    /**
     * 执行进场动画前触发的回调函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    beforeEnter: _propTypes2.default.func,
    /**
     * 执行进场动画，添加 xxx-enter-active 类名后触发的回调函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    onEnter: _propTypes2.default.func,
    /**
     * 执行完进场动画后触发的回调函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    afterEnter: _propTypes2.default.func,
    /**
     * 执行离场动画前触发的回调函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    beforeLeave: _propTypes2.default.func,
    /**
     * 执行离场动画，添加 xxx-leave-active 类名后触发的回调函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    onLeave: _propTypes2.default.func,
    /**
     * 执行完离场动画后触发的回调函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    afterLeave: _propTypes2.default.func
}, _class.defaultProps = {
    animationAppear: true,
    component: 'div',
    singleMode: true,
    beforeAppear: noop,
    onAppear: noop,
    afterAppear: noop,
    beforeEnter: noop,
    onEnter: noop,
    afterEnter: noop,
    beforeLeave: noop,
    onLeave: noop,
    afterLeave: noop
}, _temp);
Animate.displayName = 'Animate';
exports.default = Animate;
module.exports = exports['default'];

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _CSSTransition = _interopRequireDefault(__webpack_require__(102));

var _ReplaceTransition = _interopRequireDefault(__webpack_require__(107));

var _TransitionGroup = _interopRequireDefault(__webpack_require__(56));

var _Transition = _interopRequireDefault(__webpack_require__(53));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

module.exports = {
  Transition: _Transition.default,
  TransitionGroup: _TransitionGroup.default,
  ReplaceTransition: _ReplaceTransition.default,
  CSSTransition: _CSSTransition.default
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

exports.__esModule = true;
exports.default = exports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = void 0;

var PropTypes = _interopRequireWildcard(__webpack_require__(1));

var _react = _interopRequireDefault(__webpack_require__(0));

var _reactDom = _interopRequireDefault(__webpack_require__(4));

var _reactLifecyclesCompat = __webpack_require__(54);

var _PropTypes = __webpack_require__(55);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }newObj.default = obj;return newObj;
  }
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];
  }return target;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;
  _defaults(subClass, superClass);
}

var UNMOUNTED = 'unmounted';
exports.UNMOUNTED = UNMOUNTED;
var EXITED = 'exited';
exports.EXITED = EXITED;
var ENTERING = 'entering';
exports.ENTERING = ENTERING;
var ENTERED = 'entered';
exports.ENTERED = ENTERED;
var EXITING = 'exiting';
/**
 * The Transition component lets you describe a transition from one component
 * state to another _over time_ with a simple declarative API. Most commonly
 * it's used to animate the mounting and unmounting of a component, but can also
 * be used to describe in-place transition states as well.
 *
 * By default the `Transition` component does not alter the behavior of the
 * component it renders, it only tracks "enter" and "exit" states for the components.
 * It's up to you to give meaning and effect to those states. For example we can
 * add styles to a component when it enters or exits:
 *
 * ```jsx
 * import Transition from 'react-transition-group/Transition';
 *
 * const duration = 300;
 *
 * const defaultStyle = {
 *   transition: `opacity ${duration}ms ease-in-out`,
 *   opacity: 0,
 * }
 *
 * const transitionStyles = {
 *   entering: { opacity: 0 },
 *   entered:  { opacity: 1 },
 * };
 *
 * const Fade = ({ in: inProp }) => (
 *   <Transition in={inProp} timeout={duration}>
 *     {(state) => (
 *       <div style={{
 *         ...defaultStyle,
 *         ...transitionStyles[state]
 *       }}>
 *         I'm a fade Transition!
 *       </div>
 *     )}
 *   </Transition>
 * );
 * ```
 *
 * As noted the `Transition` component doesn't _do_ anything by itself to its child component.
 * What it does do is track transition states over time so you can update the
 * component (such as by adding styles or classes) when it changes states.
 *
 * There are 4 main states a Transition can be in:
 *  - `'entering'`
 *  - `'entered'`
 *  - `'exiting'`
 *  - `'exited'`
 *
 * Transition state is toggled via the `in` prop. When `true` the component begins the
 * "Enter" stage. During this stage, the component will shift from its current transition state,
 * to `'entering'` for the duration of the transition and then to the `'entered'` stage once
 * it's complete. Let's take the following example:
 *
 * ```jsx
 * state = { in: false };
 *
 * toggleEnterState = () => {
 *   this.setState({ in: true });
 * }
 *
 * render() {
 *   return (
 *     <div>
 *       <Transition in={this.state.in} timeout={500} />
 *       <button onClick={this.toggleEnterState}>Click to Enter</button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the button is clicked the component will shift to the `'entering'` state and
 * stay there for 500ms (the value of `timeout`) before it finally switches to `'entered'`.
 *
 * When `in` is `false` the same thing happens except the state moves from `'exiting'` to `'exited'`.
 *
 * ## Timing
 *
 * Timing is often the trickiest part of animation, mistakes can result in slight delays
 * that are hard to pin down. A common example is when you want to add an exit transition,
 * you should set the desired final styles when the state is `'exiting'`. That's when the
 * transition to those styles will start and, if you matched the `timeout` prop with the
 * CSS Transition duration, it will end exactly when the state changes to `'exited'`.
 *
 * > **Note**: For simpler transitions the `Transition` component might be enough, but
 * > take into account that it's platform-agnostic, while the `CSSTransition` component
 * > [forces reflows](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
 * > in order to make more complex transitions more predictable. For example, even though
 * > classes `example-enter` and `example-enter-active` are applied immediately one after
 * > another, you can still transition from one to the other because of the forced reflow
 * > (read [this issue](https://github.com/reactjs/react-transition-group/issues/159#issuecomment-322761171)
 * > for more info). Take this into account when choosing between `Transition` and
 * > `CSSTransition`.
 */

exports.EXITING = EXITING;

var Transition =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Transition, _React$Component);

  function Transition(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context.transitionGroup; // In the context of a TransitionGroup all enters are really appears

    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;

    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }

    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }

  var _proto = Transition.prototype;

  _proto.getChildContext = function getChildContext() {
    return {
      transitionGroup: null // allows for nested Transitions

    };
  };

  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;

    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }

    return null;
  }; // getSnapshotBeforeUpdate(prevProps) {
  //   let nextStatus = null
  //   if (prevProps !== this.props) {
  //     const { status } = this.state
  //     if (this.props.in) {
  //       if (status !== ENTERING && status !== ENTERED) {
  //         nextStatus = ENTERING
  //       }
  //     } else {
  //       if (status === ENTERING || status === ENTERED) {
  //         nextStatus = EXITING
  //       }
  //     }
  //   }
  //   return { nextStatus }
  // }


  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;

    if (prevProps !== this.props) {
      var status = this.state.status;

      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }

    this.updateStatus(false, nextStatus);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };

  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;

    if (timeout != null && typeof timeout !== 'number') {
      exit = timeout.exit;
      enter = timeout.enter;
      appear = timeout.appear;
    }

    return {
      exit: exit,
      enter: enter,
      appear: appear
    };
  };

  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }

    if (nextStatus !== null) {
      // nextStatus will always be ENTERING or EXITING.
      this.cancelNextCallback();

      var node = _reactDom.default.findDOMNode(this);

      if (nextStatus === ENTERING) {
        this.performEnter(node, mounting);
      } else {
        this.performExit(node);
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };

  _proto.performEnter = function performEnter(node, mounting) {
    var _this2 = this;

    var enter = this.props.enter;
    var appearing = this.context.transitionGroup ? this.context.transitionGroup.isMounting : mounting;
    var timeouts = this.getTimeouts(); // no enter animation skip right to ENTERED
    // if we are mounting and running this it means appear _must_ be set

    if (!mounting && !enter) {
      this.safeSetState({
        status: ENTERED
      }, function () {
        _this2.props.onEntered(node);
      });
      return;
    }

    this.props.onEnter(node, appearing);
    this.safeSetState({
      status: ENTERING
    }, function () {
      _this2.props.onEntering(node, appearing); // FIXME: appear timeout?


      _this2.onTransitionEnd(node, timeouts.enter, function () {
        _this2.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(node, appearing);
        });
      });
    });
  };

  _proto.performExit = function performExit(node) {
    var _this3 = this;

    var exit = this.props.exit;
    var timeouts = this.getTimeouts(); // no exit animation skip right to EXITED

    if (!exit) {
      this.safeSetState({
        status: EXITED
      }, function () {
        _this3.props.onExited(node);
      });
      return;
    }

    this.props.onExit(node);
    this.safeSetState({
      status: EXITING
    }, function () {
      _this3.props.onExiting(node);

      _this3.onTransitionEnd(node, timeouts.exit, function () {
        _this3.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(node);
        });
      });
    });
  };

  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };

  _proto.safeSetState = function safeSetState(nextState, callback) {
    // This shouldn't be necessary, but there are weird race conditions with
    // setState callbacks and unmounting in testing, so always make sure that
    // we can cancel any pending setState callbacks after we unmount.
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };

  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;

    var active = true;

    this.nextCallback = function (event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };

    this.nextCallback.cancel = function () {
      active = false;
    };

    return this.nextCallback;
  };

  _proto.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {
    this.setNextCallback(handler);

    if (node) {
      if (this.props.addEndListener) {
        this.props.addEndListener(node, this.nextCallback);
      }

      if (timeout != null) {
        setTimeout(this.nextCallback, timeout);
      }
    } else {
      setTimeout(this.nextCallback, 0);
    }
  };

  _proto.render = function render() {
    var status = this.state.status;

    if (status === UNMOUNTED) {
      return null;
    }

    var _this$props = this.props,
        children = _this$props.children,
        childProps = _objectWithoutPropertiesLoose(_this$props, ["children"]); // filter props for Transtition


    delete childProps.in;
    delete childProps.mountOnEnter;
    delete childProps.unmountOnExit;
    delete childProps.appear;
    delete childProps.enter;
    delete childProps.exit;
    delete childProps.timeout;
    delete childProps.addEndListener;
    delete childProps.onEnter;
    delete childProps.onEntering;
    delete childProps.onEntered;
    delete childProps.onExit;
    delete childProps.onExiting;
    delete childProps.onExited;

    if (typeof children === 'function') {
      return children(status, childProps);
    }

    var child = _react.default.Children.only(children);

    return _react.default.cloneElement(child, childProps);
  };

  return Transition;
}(_react.default.Component);

Transition.contextTypes = {
  transitionGroup: PropTypes.object
};
Transition.childContextTypes = {
  transitionGroup: function transitionGroup() {}
};
Transition.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * A `function` child can be used instead of a React element.
   * This function is called with the current transition status
   * ('entering', 'entered', 'exiting', 'exited', 'unmounted'), which can be used
   * to apply context specific props to a component.
   *
   * ```jsx
   * <Transition timeout={150}>
   *   {(status) => (
   *     <MyComponent className={`fade fade-${status}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,

  /**
   * Show the component; triggers the enter or exit states
   */
  in: PropTypes.bool,

  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: PropTypes.bool,

  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: PropTypes.bool,

  /**
   * Normally a component is not transitioned if it is shown when the `<Transition>` component mounts.
   * If you want to transition on the first mount set `appear` to `true`, and the
   * component will transition in as soon as the `<Transition>` mounts.
   *
   * > Note: there are no specific "appear" states. `appear` only adds an additional `enter` transition.
   */
  appear: PropTypes.bool,

  /**
   * Enable or disable enter transitions.
   */
  enter: PropTypes.bool,

  /**
   * Enable or disable exit transitions.
   */
  exit: PropTypes.bool,

  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided
   *
   * You may specify a single timeout for all transitions like: `timeout={500}`,
   * or individually like:
   *
   * ```jsx
   * timeout={{
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * @type {number | { enter?: number, exit?: number }}
   */
  timeout: function timeout(props) {
    var pt = process.env.NODE_ENV !== "production" ? _PropTypes.timeoutsShape : {};;
    if (!props.addEndListener) pt = pt.isRequired;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return pt.apply(void 0, [props].concat(args));
  },

  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. **Note:** Timeouts are still used as a fallback if provided.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: PropTypes.func,

  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: PropTypes.func,

  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,

  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: PropTypes.func,

  /**
   * Callback fired before the "exiting" status is applied.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: PropTypes.func,

  /**
   * Callback fired after the "exiting" status is applied.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: PropTypes.func,

  /**
   * Callback fired after the "exited" status is applied.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: PropTypes.func // Name the function so it is clearer in the documentation

} : {};

function noop() {}

Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = 0;
Transition.EXITED = 1;
Transition.ENTERING = 2;
Transition.ENTERED = 3;
Transition.EXITING = 4;

var _default = (0, _reactLifecyclesCompat.polyfill)(Transition);

exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function componentWillMount() {
  // Call this.constructor.gDSFP to support sub-classes.
  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
  if (state !== null && state !== undefined) {
    this.setState(state);
  }
}

function componentWillReceiveProps(nextProps) {
  // Call this.constructor.gDSFP to support sub-classes.
  // Use the setState() updater to ensure state isn't stale in certain edge cases.
  function updater(prevState) {
    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
    return state !== null && state !== undefined ? state : null;
  }
  // Binding "this" is important for shallow renderer support.
  this.setState(updater.bind(this));
}

function componentWillUpdate(nextProps, nextState) {
  try {
    var prevProps = this.props;
    var prevState = this.state;
    this.props = nextProps;
    this.state = nextState;
    this.__reactInternalSnapshotFlag = true;
    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(prevProps, prevState);
  } finally {
    this.props = prevProps;
    this.state = prevState;
  }
}

// React may warn about cWM/cWRP/cWU methods being deprecated.
// Add a flag to suppress these warnings for this special case.
componentWillMount.__suppressDeprecationWarning = true;
componentWillReceiveProps.__suppressDeprecationWarning = true;
componentWillUpdate.__suppressDeprecationWarning = true;

function polyfill(Component) {
  var prototype = Component.prototype;

  if (!prototype || !prototype.isReactComponent) {
    throw new Error('Can only polyfill class components');
  }

  if (typeof Component.getDerivedStateFromProps !== 'function' && typeof prototype.getSnapshotBeforeUpdate !== 'function') {
    return Component;
  }

  // If new component APIs are defined, "unsafe" lifecycles won't be called.
  // Error if any of these lifecycles are present,
  // Because they would work differently between older and newer (16.3+) versions of React.
  var foundWillMountName = null;
  var foundWillReceivePropsName = null;
  var foundWillUpdateName = null;
  if (typeof prototype.componentWillMount === 'function') {
    foundWillMountName = 'componentWillMount';
  } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {
    foundWillMountName = 'UNSAFE_componentWillMount';
  }
  if (typeof prototype.componentWillReceiveProps === 'function') {
    foundWillReceivePropsName = 'componentWillReceiveProps';
  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {
    foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
  }
  if (typeof prototype.componentWillUpdate === 'function') {
    foundWillUpdateName = 'componentWillUpdate';
  } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {
    foundWillUpdateName = 'UNSAFE_componentWillUpdate';
  }
  if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
    var componentName = Component.displayName || Component.name;
    var newApiName = typeof Component.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';

    throw Error('Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' + componentName + ' uses ' + newApiName + ' but also contains the following legacy lifecycles:' + (foundWillMountName !== null ? '\n  ' + foundWillMountName : '') + (foundWillReceivePropsName !== null ? '\n  ' + foundWillReceivePropsName : '') + (foundWillUpdateName !== null ? '\n  ' + foundWillUpdateName : '') + '\n\nThe above lifecycles should be removed. Learn more about this warning here:\n' + 'https://fb.me/react-async-component-lifecycle-hooks');
  }

  // React <= 16.2 does not support static getDerivedStateFromProps.
  // As a workaround, use cWM and cWRP to invoke the new static lifecycle.
  // Newer versions of React will ignore these lifecycles if gDSFP exists.
  if (typeof Component.getDerivedStateFromProps === 'function') {
    prototype.componentWillMount = componentWillMount;
    prototype.componentWillReceiveProps = componentWillReceiveProps;
  }

  // React <= 16.2 does not support getSnapshotBeforeUpdate.
  // As a workaround, use cWU to invoke the new lifecycle.
  // Newer versions of React will ignore that lifecycle if gSBU exists.
  if (typeof prototype.getSnapshotBeforeUpdate === 'function') {
    if (typeof prototype.componentDidUpdate !== 'function') {
      throw new Error('Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype');
    }

    prototype.componentWillUpdate = componentWillUpdate;

    var componentDidUpdate = prototype.componentDidUpdate;

    prototype.componentDidUpdate = function componentDidUpdatePolyfill(prevProps, prevState, maybeSnapshot) {
      // 16.3+ will not execute our will-update method;
      // It will pass a snapshot value to did-update though.
      // Older versions will require our polyfilled will-update value.
      // We need to handle both cases, but can't just check for the presence of "maybeSnapshot",
      // Because for <= 15.x versions this might be a "prevContext" object.
      // We also can't just check "__reactInternalSnapshot",
      // Because get-snapshot might return a falsy value.
      // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.
      var snapshot = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : maybeSnapshot;

      componentDidUpdate.call(this, prevProps, prevState, snapshot);
    };
  }

  return Component;
}

exports.polyfill = polyfill;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.transitionTimeout = transitionTimeout;
exports.classNamesShape = exports.timeoutsShape = void 0;

var _propTypes = _interopRequireDefault(__webpack_require__(1));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function transitionTimeout(transitionType) {
  var timeoutPropName = 'transition' + transitionType + 'Timeout';
  var enabledPropName = 'transition' + transitionType;
  return function (props) {
    // If the transition is enabled
    if (props[enabledPropName]) {
      // If no timeout duration is provided
      if (props[timeoutPropName] == null) {
        return new Error(timeoutPropName + ' wasn\'t supplied to CSSTransitionGroup: ' + 'this can cause unreliable animations and won\'t be supported in ' + 'a future version of React. See ' + 'https://fb.me/react-animation-transition-group-timeout for more ' + 'information.'); // If the duration isn't a number
      } else if (typeof props[timeoutPropName] !== 'number') {
        return new Error(timeoutPropName + ' must be a number (in milliseconds)');
      }
    }

    return null;
  };
}

var timeoutsShape = _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.shape({
  enter: _propTypes.default.number,
  exit: _propTypes.default.number
}).isRequired]);

exports.timeoutsShape = timeoutsShape;

var classNamesShape = _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.shape({
  enter: _propTypes.default.string,
  exit: _propTypes.default.string,
  active: _propTypes.default.string
}), _propTypes.default.shape({
  enter: _propTypes.default.string,
  enterDone: _propTypes.default.string,
  enterActive: _propTypes.default.string,
  exit: _propTypes.default.string,
  exitDone: _propTypes.default.string,
  exitActive: _propTypes.default.string
})]);

exports.classNamesShape = classNamesShape;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

exports.__esModule = true;
exports.default = void 0;

var _propTypes = _interopRequireDefault(__webpack_require__(1));

var _react = _interopRequireDefault(__webpack_require__(0));

var _reactLifecyclesCompat = __webpack_require__(54);

var _ChildMapping = __webpack_require__(108);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];
  }return target;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;
  _defaults(subClass, superClass);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return self;
}

var values = Object.values || function (obj) {
  return Object.keys(obj).map(function (k) {
    return obj[k];
  });
};

var propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: _propTypes.default.any,

  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   */
  children: _propTypes.default.node,

  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: _propTypes.default.bool,

  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: _propTypes.default.bool,

  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: _propTypes.default.bool,

  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: _propTypes.default.func
} : {};;
var defaultProps = {
  component: 'div',
  childFactory: function childFactory(child) {
    return child;
  }
  /**
   * The `<TransitionGroup>` component manages a set of transition components
   * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
   * components, `<TransitionGroup>` is a state machine for managing the mounting
   * and unmounting of components over time.
   *
   * Consider the example below. As items are removed or added to the TodoList the
   * `in` prop is toggled automatically by the `<TransitionGroup>`.
   *
   * Note that `<TransitionGroup>`  does not define any animation behavior!
   * Exactly _how_ a list item animates is up to the individual transition
   * component. This means you can mix and match animations across different list
   * items.
   */

};

var TransitionGroup =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(TransitionGroup, _React$Component);

  function TransitionGroup(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;

    var handleExited = _this.handleExited.bind(_assertThisInitialized(_assertThisInitialized(_this))); // Initial children should all be entering, dependent on appear


    _this.state = {
      handleExited: handleExited,
      firstRender: true
    };
    return _this;
  }

  var _proto = TransitionGroup.prototype;

  _proto.getChildContext = function getChildContext() {
    return {
      transitionGroup: {
        isMounting: !this.appeared
      }
    };
  };

  _proto.componentDidMount = function componentDidMount() {
    this.appeared = true;
    this.mounted = true;
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };

  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children,
        handleExited = _ref.handleExited,
        firstRender = _ref.firstRender;
    return {
      children: firstRender ? (0, _ChildMapping.getInitialChildMapping)(nextProps, handleExited) : (0, _ChildMapping.getNextChildMapping)(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };

  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = (0, _ChildMapping.getChildMapping)(this.props.children);
    if (child.key in currentChildMapping) return;

    if (child.props.onExited) {
      child.props.onExited(node);
    }

    if (this.mounted) {
      this.setState(function (state) {
        var children = _extends({}, state.children);

        delete children[child.key];
        return {
          children: children
        };
      });
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        Component = _this$props.component,
        childFactory = _this$props.childFactory,
        props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);

    var children = values(this.state.children).map(childFactory);
    delete props.appear;
    delete props.enter;
    delete props.exit;

    if (Component === null) {
      return children;
    }

    return _react.default.createElement(Component, props, children);
  };

  return TransitionGroup;
}(_react.default.Component);

TransitionGroup.childContextTypes = {
  transitionGroup: _propTypes.default.object.isRequired
};
TransitionGroup.propTypes = process.env.NODE_ENV !== "production" ? propTypes : {};
TransitionGroup.defaultProps = defaultProps;

var _default = (0, _reactLifecyclesCompat.polyfill)(TransitionGroup);

exports.default = _default;
module.exports = exports["default"];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _overlay = __webpack_require__(15);

var _overlay2 = _interopRequireDefault(_overlay);

var _util = __webpack_require__(2);

var _item = __webpack_require__(14);

var _item2 = _interopRequireDefault(_item);

var _selectableItem = __webpack_require__(22);

var _selectableItem2 = _interopRequireDefault(_selectableItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var bindCtx = _util.func.bindCtx;
var setStyle = _util.dom.setStyle;

var Popup = _overlay2.default.Popup;

/**
 * Menu.PopupItem
 * @order 2
 */
var PopupItem = (_temp = _class = function (_Component) {
    _inherits(PopupItem, _Component);

    function PopupItem(props) {
        _classCallCheck(this, PopupItem);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        bindCtx(_this, ['handleOpen', 'handlePopupOpen', 'handlePopupClose', 'getPopup']);
        return _this;
    }

    PopupItem.prototype.getPopup = function getPopup(ref) {
        this.popup = ref;
    };

    PopupItem.prototype.getOpen = function getOpen() {
        var _props = this.props,
            _key = _props._key,
            root = _props.root;
        var openKeys = root.state.openKeys;


        return openKeys.indexOf(_key) > -1;
    };

    PopupItem.prototype.getPopupProps = function getPopupProps() {
        var popupProps = this.props.root.props.popupProps;

        if (typeof popupProps === 'function') {
            popupProps = popupProps(this.props);
        }
        return popupProps;
    };

    PopupItem.prototype.handleOpen = function handleOpen(open, triggerType, e) {
        var _props2 = this.props,
            _key = _props2._key,
            root = _props2.root;

        root.handleOpen(_key, open, triggerType, e);

        var popupProps = this.popupProps;
        popupProps.onVisibleChange && popupProps.onVisibleChange(open, triggerType, e);
    };

    PopupItem.prototype.handlePopupOpen = function handlePopupOpen() {
        var _props3 = this.props,
            root = _props3.root,
            level = _props3.level,
            align = _props3.align,
            autoWidth = _props3.autoWidth;
        var _root$props = root.props,
            rootPopupAutoWidth = _root$props.popupAutoWidth,
            rootPopupAlign = _root$props.popupAlign,
            direction = _root$props.direction;

        var popupAlign = align || rootPopupAlign;
        var popupAutoWidth = 'autoWidth' in this.props ? autoWidth : rootPopupAutoWidth;
        var itemNode = (0, _reactDom.findDOMNode)(this);
        var menuNode = itemNode.parentNode;
        this.popupNode = this.popup.getInstance().overlay.getInstance().getContentNode();
        root.popupNodes.push(this.popupNode);

        if (popupAutoWidth) {
            var targetNode = direction === 'hoz' && level === 1 ? itemNode : menuNode;

            if (targetNode.offsetWidth > this.popupNode.offsetWidth) {
                setStyle(this.popupNode, 'width', targetNode.offsetWidth + 'px');
            }
        }
        if (popupAlign === 'outside' && !(direction === 'hoz' && level === 1)) {
            setStyle(this.popupNode, 'height', menuNode.offsetHeight + 'px');
            setStyle(this.popupNode, 'overflow-y', 'scroll');
        }
        // removeClass(this.popupNode, `${prefix}hide`);

        var popupProps = this.popupProps;
        popupProps.onOpen && popupProps.onOpen();
    };

    PopupItem.prototype.handlePopupClose = function handlePopupClose() {
        var root = this.props.root;

        var popupNodes = root.popupNodes;
        var index = popupNodes.indexOf(this.popupNode);
        index > -1 && popupNodes.splice(index, 1);

        var popupProps = this.popupProps;
        popupProps.onClose && popupProps.onClose();
    };

    PopupItem.prototype.renderItem = function renderItem(selectable, children, others) {
        var _props4 = this.props,
            _key = _props4._key,
            root = _props4.root,
            level = _props4.level,
            label = _props4.label,
            className = _props4.className;
        var prefix = root.props.prefix;

        var NewItem = selectable ? _selectableItem2.default : _item2.default;
        var open = this.getOpen();

        var itemProps = {
            'aria-haspopup': true,
            'aria-expanded': open,
            _key: _key,
            root: root,
            level: level,
            type: 'submenu'
        };
        if (open) {
            var _cx;

            itemProps.className = (0, _classnames2.default)((_cx = {}, _cx[prefix + 'opened'] = true, _cx[className] = !!className, _cx));
        } else {
            itemProps.className = className;
        }

        return _react2.default.createElement(
            NewItem,
            _extends({}, itemProps, others),
            _react2.default.createElement(
                'span',
                { className: prefix + 'menu-item-text' },
                label
            ),
            children
        );
    };

    PopupItem.prototype.renderPopup = function renderPopup(trigger, triggerType, positionProps, children) {
        var _this2 = this;

        var _props5 = this.props,
            root = _props5.root,
            level = _props5.level,
            selectable = _props5.selectable;
        var direction = root.props.direction;

        this.popupProps = this.getPopupProps();
        var open = this.getOpen();

        if (direction === 'hoz' && level === 1 && selectable) {
            positionProps.target = function () {
                return (0, _reactDom.findDOMNode)(_this2);
            };
        }

        return _react2.default.createElement(
            Popup,
            _extends({ ref: this.getPopup
            }, positionProps, this.popupProps, {
                canCloseByEsc: false,
                trigger: trigger,
                triggerType: triggerType,
                visible: open,
                onVisibleChange: this.handleOpen,
                onOpen: this.handlePopupOpen,
                onClose: this.handlePopupClose }),
            children
        );
    };

    PopupItem.prototype.render = function render() {
        var _this3 = this;

        var _props6 = this.props,
            root = _props6.root,
            level = _props6.level,
            hasSubMenu = _props6.hasSubMenu,
            selectableFromProps = _props6.selectable,
            children = _props6.children,
            triggerType = _props6.triggerType,
            align = _props6.align,
            rtl = _props6.rtl;

        var others = _util.obj.pickOthers(Object.keys(PopupItem.propTypes), this.props);
        var _root$props2 = root.props,
            prefix = _root$props2.prefix,
            selectMode = _root$props2.selectMode,
            direction = _root$props2.direction,
            rootPopupAlign = _root$props2.popupAlign,
            rootTriggerType = _root$props2.triggerType;

        var popupAlign = align || rootPopupAlign;
        var newTriggerType = triggerType || (hasSubMenu ? rootTriggerType : 'hover');
        var newChildren = Array.isArray(children) ? children[0] : children;
        // let newChildren = Array.isArray(children) ? children[0] : children;
        // newChildren = cloneElement(newChildren, {
        //     className: cx({
        //         [`${prefix}menu-popup-content`]: true,
        //         [newChildren.props.className]: !!newChildren.props.className,
        //         [`${prefix}hide`]: popupAutoWidth || popupAlign === 'outside'
        //     })
        // });
        var selectable = selectMode && selectableFromProps;
        var triggerIsIcon = selectable && newTriggerType === 'click';
        var open = this.getOpen();

        var positionProps = {};
        var arrowProps = void 0;

        if (direction === 'hoz' && level === 1) {
            var _cx2;

            positionProps.align = 'tl bl';
            positionProps.offset = [0, 0];

            arrowProps = {
                type: 'arrow-down',
                className: (0, _classnames2.default)((_cx2 = {}, _cx2[prefix + 'menu-hoz-icon-arrow'] = true, _cx2[prefix + 'open'] = open, _cx2))
            };
        } else {
            if (popupAlign === 'outside') {
                positionProps.target = function () {
                    return (0, _reactDom.findDOMNode)(root);
                };
                positionProps.align = 'tl tr';

                rtl ? positionProps.offset = [-2, 0] : positionProps.offset = [2, 0];
            } else {
                if (triggerIsIcon) {
                    positionProps.target = function () {
                        return (0, _reactDom.findDOMNode)(_this3);
                    };
                }
                positionProps.align = 'tl tr';

                rtl ? positionProps.offset = [2, -8] : positionProps.offset = [-2, -8];
            }

            arrowProps = {
                type: 'arrow-right',
                className: prefix + 'menu-icon-arrow'
            };
        }

        var arrow = _react2.default.createElement(_icon2.default, arrowProps);
        var trigger = triggerIsIcon ? arrow : this.renderItem(selectable, arrow, others);
        var popup = this.renderPopup(trigger, newTriggerType, positionProps, newChildren);
        return triggerIsIcon ? this.renderItem(selectable, popup, others) : popup;
    };

    return PopupItem;
}(_react.Component), _class.menuChildType = 'submenu', _class.propTypes = {
    _key: _propTypes2.default.string,
    root: _propTypes2.default.object,
    level: _propTypes2.default.number,
    hasSubMenu: _propTypes2.default.bool,
    rtl: _propTypes2.default.bool,
    selectable: _propTypes2.default.bool,
    /**
     * 标签内容
     */
    label: _propTypes2.default.node,
    /**
     * 自定义弹层内容
     */
    children: _propTypes2.default.node,
    className: _propTypes2.default.string,
    triggerType: _propTypes2.default.oneOf(['click', 'hover']),
    align: _propTypes2.default.oneOf(['outside', 'follow']),
    autoWidth: _propTypes2.default.bool
}, _class.defaultProps = {
    selectable: false
}, _temp);
PopupItem.displayName = 'PopupItem';
exports.default = PopupItem;
module.exports = exports['default'];

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _checkbox = __webpack_require__(37);

var _checkbox2 = _interopRequireDefault(_checkbox);

var _radio = __webpack_require__(61);

var _radio2 = _interopRequireDefault(_radio);

var _util = __webpack_require__(2);

var _item = __webpack_require__(14);

var _item2 = _interopRequireDefault(_item);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = {};
var bindCtx = _util.func.bindCtx;
var pickOthers = _util.obj.pickOthers;
var CheckableItem = (_temp = _class = function (_Component) {
    _inherits(CheckableItem, _Component);

    function CheckableItem(props) {
        _classCallCheck(this, CheckableItem);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        bindCtx(_this, ['stopPropagation', 'handleKeyDown', 'handleClick']);
        return _this;
    }

    CheckableItem.prototype.stopPropagation = function stopPropagation(e) {
        e.stopPropagation();
    };

    CheckableItem.prototype.handleCheck = function handleCheck(e) {
        var _props = this.props,
            checkType = _props.checkType,
            checked = _props.checked,
            onChange = _props.onChange;

        if (!(checkType === 'radio' && checked)) {
            onChange(!checked, e);
        }
    };

    CheckableItem.prototype.handleKeyDown = function handleKeyDown(e) {
        if (e.keyCode === _util.KEYCODE.SPACE && !this.props.checkDisabled) {
            this.handleCheck(e);
        }

        this.props.onKeyDown && this.props.onKeyDown(e);
    };

    CheckableItem.prototype.handleClick = function handleClick(e) {
        this.handleCheck(e);

        this.props.onClick && this.props.onClick(e);
    };

    CheckableItem.prototype.renderCheck = function renderCheck() {
        var _props2 = this.props,
            root = _props2.root,
            checked = _props2.checked,
            indeterminate = _props2.indeterminate,
            disabled = _props2.disabled,
            checkType = _props2.checkType,
            checkDisabled = _props2.checkDisabled,
            onChange = _props2.onChange;
        var labelToggleChecked = root.props.labelToggleChecked;

        var Check = checkType === 'radio' ? _radio2.default : _checkbox2.default;

        var checkProps = {
            tabIndex: '-1',
            checked: checked,
            disabled: disabled || checkDisabled
        };
        if (checkType === 'checkbox') {
            checkProps.indeterminate = indeterminate;
        }
        if (!labelToggleChecked) {
            checkProps.onChange = onChange;
            checkProps.onClick = this.stopPropagation;
        }

        return _react2.default.createElement(Check, checkProps);
    };

    CheckableItem.prototype.render = function render() {
        var _props3 = this.props,
            _key = _props3._key,
            root = _props3.root,
            checked = _props3.checked,
            disabled = _props3.disabled,
            onClick = _props3.onClick,
            helper = _props3.helper,
            children = _props3.children;
        var _root$props = root.props,
            prefix = _root$props.prefix,
            labelToggleChecked = _root$props.labelToggleChecked;

        var others = pickOthers(Object.keys(CheckableItem.propTypes), this.props);

        var newProps = _extends({
            _key: _key,
            root: root,
            disabled: disabled,
            type: 'item',
            onClick: onClick,
            onKeyDown: this.handleKeyDown
        }, others);
        if (labelToggleChecked && !disabled) {
            newProps.onClick = this.handleClick;
        }

        return _react2.default.createElement(
            _item2.default,
            _extends({ 'aria-checked': checked }, newProps),
            this.renderCheck(),
            _react2.default.createElement(
                'span',
                { className: prefix + 'menu-item-text' },
                children
            ),
            helper ? _react2.default.createElement(
                'div',
                { className: prefix + 'menu-item-helper' },
                helper
            ) : null
        );
    };

    return CheckableItem;
}(_react.Component), _class.propTypes = {
    _key: _propTypes2.default.string,
    root: _propTypes2.default.object,
    disabled: _propTypes2.default.bool,
    inlineIndent: _propTypes2.default.number,
    checked: _propTypes2.default.bool,
    indeterminate: _propTypes2.default.bool,
    onChange: _propTypes2.default.func,
    checkType: _propTypes2.default.oneOf(['checkbox', 'radio']),
    checkDisabled: _propTypes2.default.bool,
    helper: _propTypes2.default.node,
    children: _propTypes2.default.node,
    onKeyDown: _propTypes2.default.func,
    onClick: _propTypes2.default.func
}, _class.defaultProps = {
    disabled: false,
    checked: false,
    indeterminate: false,
    checkType: 'checkbox',
    checkDisabled: false,
    onChange: noop
}, _temp);
CheckableItem.displayName = 'CheckableItem';
exports.default = CheckableItem;
module.exports = exports['default'];

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _mixinUiState = __webpack_require__(60);

var _mixinUiState2 = _interopRequireDefault(_mixinUiState);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = _util.func.noop;
function isChecked(selectedValue, value) {
    return selectedValue.indexOf(value) > -1;
}
/**
 * Checkbox
 * @order 1
 */
var Checkbox = (_temp = _class = function (_UIState) {
    _inherits(Checkbox, _UIState);

    function Checkbox(props, context) {
        _classCallCheck(this, Checkbox);

        var _this = _possibleConstructorReturn(this, _UIState.call(this, props));

        var checked = void 0,
            indeterminate = void 0;
        if (context.__group__) {
            indeterminate = false;
            checked = isChecked(context.selectedValue, props.value);
        } else {
            if ('checked' in props) {
                checked = props.checked;
            } else {
                checked = props.defaultChecked;
            }

            if ('indeterminate' in props) {
                indeterminate = props.indeterminate;
            } else {
                indeterminate = props.defaultIndeterminate;
            }
        }

        _this.state = {
            checked: checked,
            indeterminate: indeterminate
        };

        _this.disabled = props.disabled || context.__group__ && 'disabled' in context && context.disabled;
        _this.onChange = _this.onChange.bind(_this);
        return _this;
    }

    Checkbox.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
        if (nextContext.__group__) {
            if ('selectedValue' in nextContext) {
                this.setState({
                    checked: isChecked(nextContext.selectedValue, nextProps.value)
                });
            }
            this.disabled = nextProps.disabled || 'disabled' in nextContext && nextContext.disabled;
        } else {
            if ('checked' in nextProps) {
                this.setState({
                    checked: nextProps.checked
                });
            }
            if ('indeterminate' in nextProps) {
                this.setState({
                    indeterminate: nextProps.indeterminate
                });
            }
            this.disabled = nextProps.disabled;
        }
    };

    Checkbox.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState, nextContext) {
        var shallowEqual = _util.obj.shallowEqual;

        return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState) || !shallowEqual(this.context, nextContext);
    };

    Checkbox.prototype.onChange = function onChange(e) {
        var checked = e.target.checked;
        var value = this.props.value;
        if (this.disabled) {
            return;
        }
        if (this.context.__group__) {
            this.context.onChange(value, e);
        } else {
            if (!('checked' in this.props)) {
                this.setState({
                    checked: checked
                });
            }

            if (!('indeterminate' in this.props)) {
                this.setState({
                    indeterminate: false
                });
            }
            this.props.onChange(checked, e);
        }
    };

    Checkbox.prototype.render = function render() {
        var _classnames;

        /* eslint-disable no-unused-vars */
        var _props = this.props,
            id = _props.id,
            className = _props.className,
            children = _props.children,
            style = _props.style,
            label = _props.label,
            onMouseEnter = _props.onMouseEnter,
            onMouseLeave = _props.onMouseLeave,
            rtl = _props.rtl,
            otherProps = _objectWithoutProperties(_props, ['id', 'className', 'children', 'style', 'label', 'onMouseEnter', 'onMouseLeave', 'rtl']);

        var checked = !!this.state.checked;
        var disabled = this.disabled;
        var indeterminate = !!this.state.indeterminate;
        var prefix = this.context.prefix || this.props.prefix;

        var others = _util.obj.pickOthers(Checkbox.propTypes, otherProps);
        var othersData = _util.obj.pickAttrsWith(others, 'data-');

        var childInput = _react2.default.createElement('input', _extends({}, _util.obj.pickOthers(Checkbox.propTypes, otherProps), {
            id: id,
            disabled: disabled,
            checked: checked,
            type: 'checkbox',
            onChange: this.onChange,
            'aria-checked': indeterminate ? 'mixed' : checked,
            className: prefix + 'checkbox-input'
        }));

        // disable 无状态操作
        if (!disabled) {
            childInput = this.getStateElement(childInput);
        }
        var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'checkbox-wrapper'] = true, _classnames[className] = !!className, _classnames.checked = checked, _classnames.disabled = disabled, _classnames.indeterminate = indeterminate, _classnames[this.getStateClassName()] = true, _classnames));
        var labelCls = prefix + 'checkbox-label';
        var type = indeterminate ? 'semi-select' : 'select';

        return _react2.default.createElement(
            'label',
            _extends({}, othersData, {
                className: cls,
                style: style,
                onMouseEnter: onMouseEnter,
                onMouseLeave: onMouseLeave
            }),
            _react2.default.createElement(
                'span',
                { className: prefix + 'checkbox' },
                _react2.default.createElement(
                    'span',
                    { className: prefix + 'checkbox-inner' },
                    _react2.default.createElement(_icon2.default, { type: type, size: 'xs', className: indeterminate ? 'zoomIn' : '' })
                ),
                childInput
            ),
            [label, children].map(function (item, i) {
                return item ? _react2.default.createElement(
                    'span',
                    { key: i, className: labelCls },
                    item
                ) : null;
            })
        );
    };

    return Checkbox;
}(_mixinUiState2.default), _class.displayName = 'Checkbox', _class.propTypes = {
    prefix: _propTypes2.default.string,
    rtl: _propTypes2.default.bool,
    /**
     * 自定义类名
     */
    className: _propTypes2.default.string,
    /**
     * checkbox id, 挂载在input上
     */
    id: _propTypes2.default.string,
    /**
     * 自定义内敛样式
     */
    style: _propTypes2.default.object,
    /**
     * 选中状态
     */
    checked: _propTypes2.default.bool,
    /**
     * 默认选中状态
     */
    defaultChecked: _propTypes2.default.bool,
    /**
     * 禁用
     */
    disabled: _propTypes2.default.bool,
    /**
     * 通过属性配置label，
     */
    label: _propTypes2.default.node,
    /**
     * Checkbox 的中间状态，只会影响到 Checkbox 的样式，并不影响其 checked 属性
     */
    indeterminate: _propTypes2.default.bool,
    /**
     *  Checkbox 的默认中间态，只会影响到 Checkbox 的样式，并不影响其 checked 属性
     */
    defaultIndeterminate: _propTypes2.default.bool,
    /**
     * 状态变化时触发的事件
     * @param {Boolean} checked 是否选中
     * @param {Event} e Dom 事件对象
     */
    onChange: _propTypes2.default.func,
    /**
     * 鼠标进入enter事件
     * @param {Event} e Dom 事件对象
     */
    onMouseEnter: _propTypes2.default.func,
    /**
     * 鼠标离开Leave事件
     * @param {Event} e Dom 事件对象
     */
    onMouseLeave: _propTypes2.default.func
}, _class.defaultProps = {
    defaultChecked: false,
    defaultIndeterminate: false,
    onChange: noop,
    onMouseEnter: noop,
    onMouseLeave: noop,
    prefix: 'next-'
}, _class.contextTypes = {
    onChange: _propTypes2.default.func,
    __group__: _propTypes2.default.bool,
    selectedValue: _propTypes2.default.array,
    disabled: _propTypes2.default.bool,
    prefix: _propTypes2.default.string
}, _temp);
exports.default = _configProvider2.default.config(Checkbox);
module.exports = exports['default'];

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var makeChain = _util.func.makeChain;
// UIState 为一些特殊元素的状态响应提供了标准的方式，
// 尤其适合CSS无法完全定制的控件，比如checkbox，radio等。
// 若组件 disable 则自行判断是否需要绑定状态管理。
// 注意：disable 不会触发事件，请使用resetUIState还原状态
/* eslint-disable react/prop-types */

var UIState = function (_Component) {
    _inherits(UIState, _Component);

    function UIState(props) {
        _classCallCheck(this, UIState);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        _this.state = {};
        ['_onUIFocus', '_onUIBlur'].forEach(function (item) {
            _this[item] = _this[item].bind(_this);
        });
        return _this;
    }
    // base 事件绑定的元素


    UIState.prototype.getStateElement = function getStateElement(base) {
        var _props = this.props,
            onFocus = _props.onFocus,
            onBlur = _props.onBlur;

        return _react2.default.cloneElement(base, {
            onFocus: makeChain(this._onUIFocus, onFocus),
            onBlur: makeChain(this._onUIBlur, onBlur)
        });
    };
    // 获取状态classname


    UIState.prototype.getStateClassName = function getStateClassName() {
        var focused = this.state.focused;

        return (0, _classnames2.default)({
            focused: focused
        });
    };
    // 复原状态


    UIState.prototype.resetUIState = function resetUIState() {
        this.setState({
            focused: false
        });
    };

    UIState.prototype._onUIFocus = function _onUIFocus() {
        this.setState({
            focused: true
        });
    };

    UIState.prototype._onUIBlur = function _onUIBlur() {
        this.setState({
            focused: false
        });
    };

    return UIState;
}(_react.Component);

UIState.displayName = 'UIState';
exports.default = UIState;
module.exports = exports['default'];

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _radio = __webpack_require__(62);

var _radio2 = _interopRequireDefault(_radio);

var _radioGroup = __webpack_require__(113);

var _radioGroup2 = _interopRequireDefault(_radioGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_radio2.default.Group = _radioGroup2.default;

exports.default = _radio2.default;
module.exports = exports['default'];

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames4 = __webpack_require__(3);

var _classnames5 = _interopRequireDefault(_classnames4);

var _mixinUiState = __webpack_require__(60);

var _mixinUiState2 = _interopRequireDefault(_mixinUiState);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var makeChain = _util.func.makeChain,
    noop = _util.func.noop;
/**
 * Radio
 * @order 1
 */

var Radio = (_temp = _class = function (_UIState) {
    _inherits(Radio, _UIState);

    function Radio(props, context) {
        _classCallCheck(this, Radio);

        var _this = _possibleConstructorReturn(this, _UIState.call(this, props));

        var checked = void 0;
        if (context.__group__) {
            checked = context.selectedValue === props.value;
        } else if ('checked' in props) {
            checked = props.checked;
        } else {
            checked = props.defaultChecked;
        }

        _this.state = { checked: checked };

        _this.onChange = _this.onChange.bind(_this);
        _this.disabled = props.disabled || context.__group__ && 'disabled' in context && context.disabled;

        return _this;
    }

    Radio.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
        if (nextContext.__group__) {
            var selectedValue = nextContext.selectedValue;

            if ('selectedValue' in nextContext) {
                this.setState({
                    checked: selectedValue === nextProps.value
                });
            }
        } else if ('checked' in nextProps) {
            this.setState({
                checked: nextProps.checked
            });
        }

        this.disabled = nextProps.disabled || nextContext.__group__ && 'disabled' in nextContext && nextContext.disabled;

        // when disabled, reset UIState
        if (this.disabled) {
            // only class has an impact, no effect on visual
            this.resetUIState();
        }
    };

    Radio.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState, nextContext) {
        var shallowEqual = _util.obj.shallowEqual;

        return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState) || !shallowEqual(this.nextContext, nextContext);
    };

    Radio.prototype.onChange = function onChange(e) {
        var checked = e.target.checked;
        var value = this.props.value;

        if (this.context.__group__) {
            this.context.onChange(value, e);
        } else if (this.state.checked !== checked) {
            if (!('checked' in this.props)) {
                this.setState({
                    checked: checked
                });
            }
            this.props.onChange(checked, e);
        }
    };

    Radio.prototype.render = function render() {
        var _classnames, _classnames2, _classnames3;

        /* eslint-disable no-unused-vars */
        var _props = this.props,
            id = _props.id,
            className = _props.className,
            children = _props.children,
            style = _props.style,
            label = _props.label,
            onMouseEnter = _props.onMouseEnter,
            onMouseLeave = _props.onMouseLeave,
            tabIndex = _props.tabIndex,
            rtl = _props.rtl,
            otherProps = _objectWithoutProperties(_props, ['id', 'className', 'children', 'style', 'label', 'onMouseEnter', 'onMouseLeave', 'tabIndex', 'rtl']);

        var checked = !!this.state.checked;
        var disabled = this.disabled;
        var isButton = this.context.isButton;
        var prefix = this.context.prefix || this.props.prefix;

        var others = _util.obj.pickOthers(Radio.propTypes, otherProps);
        var othersData = _util.obj.pickAttrsWith(others, 'data-');

        var input = _react2.default.createElement('input', _extends({}, _util.obj.pickOthers(othersData, others), {
            id: id,
            disabled: disabled,
            checked: checked,
            type: 'radio',
            onChange: this.onChange,
            'aria-checked': checked,
            className: prefix + 'radio-input'
        }));

        // disabled do not hove focus state
        if (!disabled) {
            input = this.getStateElement(input);
        }

        var cls = (0, _classnames5.default)((_classnames = {}, _classnames[prefix + 'radio'] = true, _classnames.checked = checked, _classnames.disabled = disabled, _classnames[this.getStateClassName()] = true, _classnames));
        var clsInner = (0, _classnames5.default)((_classnames2 = {}, _classnames2[prefix + 'radio-inner'] = true, _classnames2.press = checked, _classnames2.unpress = !checked, _classnames2));
        var clsWrapper = (0, _classnames5.default)((_classnames3 = {}, _classnames3[prefix + 'radio-wrapper'] = true, _classnames3[className] = !!className, _classnames3.checked = checked, _classnames3.disabled = disabled, _classnames3[this.getStateClassName()] = true, _classnames3));
        var childrenCls = prefix + 'radio-label';

        var radioComp = !isButton ? _react2.default.createElement(
            'span',
            { className: cls },
            _react2.default.createElement('span', { className: clsInner }),
            input
        ) : _react2.default.createElement(
            'span',
            { className: prefix + 'radio-single-input' },
            input
        );

        return _react2.default.createElement(
            'label',
            _extends({}, othersData, {
                role: 'radio',
                dir: rtl ? 'rtl' : 'ltr',
                style: style,
                tabIndex: tabIndex,
                'aria-checked': checked,
                'aria-disabled': disabled,
                className: clsWrapper,
                onMouseEnter: disabled ? onMouseEnter : makeChain(this._onUIMouseEnter, onMouseEnter),
                onMouseLeave: disabled ? onMouseLeave : makeChain(this._onUIMouseLeave, onMouseLeave)
            }),
            radioComp,
            [children, label].map(function (d, i) {
                return d !== undefined ? _react2.default.createElement(
                    'span',
                    { key: i, className: childrenCls },
                    d
                ) : null;
            })
        );
    };

    return Radio;
}(_mixinUiState2.default), _class.displayName = 'Radio', _class.propTypes = {
    prefix: _propTypes2.default.string,
    rtl: _propTypes2.default.bool,
    /**
     * 自定义类名
     */
    className: _propTypes2.default.string,
    /**
     * 组件input的id
     */
    id: _propTypes2.default.string,
    /**
     * 自定义内敛样式
     */
    style: _propTypes2.default.object,
    /**
     * 设置radio是否选中
     */
    checked: _propTypes2.default.bool,
    /**
     * 设置radio是否默认选中
     */
    defaultChecked: _propTypes2.default.bool,
    /**
     * 通过属性配置label
     */
    label: _propTypes2.default.node,
    /**
     * 状态变化时触发的事件
     * @param {Boolean} checked 是否选中
     * @param {Event} e Dom 事件对象
     */
    onChange: _propTypes2.default.func,
    /**
     * 鼠标进入enter事件
     * @param {Event} e Dom 事件对象
     */
    onMouseEnter: _propTypes2.default.func,
    /**
     * 鼠标离开事件
     * @param {Event} e Dom 事件对象
     */
    onMouseLeave: _propTypes2.default.func,
    /**
     * radio是否被禁用
     */
    disabled: _propTypes2.default.bool,
    /**
     * radio 的value
     */
    value: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number, _propTypes2.default.bool]),
    /**
     * name
     */
    name: _propTypes2.default.string
}, _class.defaultProps = {
    onChange: noop,
    onMouseLeave: noop,
    onMouseEnter: noop,
    tabIndex: 0,
    prefix: 'next-'
}, _class.contextTypes = {
    onChange: _propTypes2.default.func,
    __group__: _propTypes2.default.bool,
    isButton: _propTypes2.default.bool,
    selectedValue: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number, _propTypes2.default.bool]),
    disabled: _propTypes2.default.bool
}, _temp);
exports.default = _configProvider2.default.config(Radio);
module.exports = exports['default'];

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var Sort = (_temp2 = _class = function (_React$Component) {
    _inherits(Sort, _React$Component);

    function Sort() {
        var _temp, _this, _ret;

        _classCallCheck(this, Sort);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function () {
            var _this$props = _this.props,
                sort = _this$props.sort,
                dataIndex = _this$props.dataIndex;

            _this.onSort(dataIndex, sort[dataIndex] === 'desc' ? 'asc' : 'desc');
        }, _this.keydownHandler = function (e) {
            e.preventDefault();
            e.stopPropagation();

            if (e.keyCode === _util.KEYCODE.ENTER) {
                _this.handleClick();
            }
        }, _this.onSort = function (dataIndex, order) {
            var sort = {};
            sort[dataIndex] = order;

            _this.props.onSort(dataIndex, order, sort);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    // 渲染排序
    Sort.prototype.renderSort = function renderSort() {
        var _props = this.props,
            prefix = _props.prefix,
            sort = _props.sort,
            dataIndex = _props.dataIndex,
            locale = _props.locale,
            sortStatus = sort[dataIndex],
            map = {
            desc: 'descending',
            asc: 'ascending'
        };


        var icons = ['asc', 'desc'].map(function (sortOrder) {
            return _react2.default.createElement(
                'a',
                { href: 'javascript:;',
                    key: sortOrder,
                    className: sortStatus === sortOrder ? 'current' : '' },
                _react2.default.createElement(_icon2.default, { type: map[sortOrder], size: 'small' })
            );
        });

        return _react2.default.createElement(
            'span',
            { role: 'button',
                tabIndex: '0',
                'aria-label': locale[sortStatus],
                className: prefix + 'table-sort',
                onClick: this.handleClick.bind(this),
                onKeyDown: this.keydownHandler },
            icons
        );
    };

    Sort.prototype.render = function render() {
        return this.renderSort();
    };

    return Sort;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    className: _propTypes2.default.string,
    sort: _propTypes2.default.object,
    onSort: _propTypes2.default.func,
    dataIndex: _propTypes2.default.string,
    locale: _propTypes2.default.object
}, _class.defaultProps = {
    sort: {} }, _temp2);
Sort.displayName = 'Sort';
exports.default = Sort;
module.exports = exports['default'];

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _row = __webpack_require__(65);

var _row2 = _interopRequireDefault(_row);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var SelectionRow = (_temp = _class = function (_React$Component) {
    _inherits(SelectionRow, _React$Component);

    function SelectionRow() {
        _classCallCheck(this, SelectionRow);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    SelectionRow.prototype.render = function render() {
        var _classnames;

        /* eslint-disable no-unused-vars*/
        var _props = this.props,
            className = _props.className,
            record = _props.record,
            primaryKey = _props.primaryKey;
        var selectedRowKeys = this.context.selectedRowKeys;

        var cls = (0, _classnames3.default)((_classnames = {
            selected: selectedRowKeys.indexOf(record[primaryKey]) > -1
        }, _classnames[className] = className, _classnames));
        return _react2.default.createElement(_row2.default, _extends({}, this.props, { className: cls }));
    };

    return SelectionRow;
}(_react2.default.Component), _class.propTypes = _extends({}, _row2.default.propTypes), _class.defaultProps = _extends({}, _row2.default.defaultProps), _class.contextTypes = {
    selectedRowKeys: _propTypes2.default.array
}, _temp);
SelectionRow.displayName = 'SelectionRow';
exports.default = SelectionRow;
module.exports = exports['default'];

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

var _row = __webpack_require__(66);

var _row2 = _interopRequireDefault(_row);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var ExpandedRow = (_temp = _class = function (_React$Component) {
    _inherits(ExpandedRow, _React$Component);

    function ExpandedRow() {
        _classCallCheck(this, ExpandedRow);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    ExpandedRow.prototype.renderExpandedRow = function renderExpandedRow(record, index, colSpan) {
        var _context = this.context,
            expandedRowRender = _context.expandedRowRender,
            expandedRowIndent = _context.expandedRowIndent,
            openRowKeys = _context.openRowKeys,
            lockType = _context.lockType;
        var _props = this.props,
            columns = _props.columns,
            cellRef = _props.cellRef;

        if (expandedRowRender) {
            var _props2 = this.props,
                primaryKey = _props2.primaryKey,
                prefix = _props2.prefix,
                leftIndent = expandedRowIndent[0],
                rightIndent = expandedRowIndent[1],
                totalIndent = leftIndent + rightIndent,
                renderCols = function renderCols(number) {
                var ret = [];

                var _loop = function _loop(i) {
                    ret.push(_react2.default.createElement(
                        'td',
                        { key: i, ref: function ref(cell) {
                                return cellRef(index, i, cell);
                            } },
                        '\xA0'
                    ));
                };

                for (var i = 0; i < number; i++) {
                    _loop(i);
                }
                return ret;
            };

            var content = void 0;

            if (totalIndent > colSpan && !lockType) {
                _util.log.warning('It\'s not allowed expandedRowIndent is more than the number of columns.');
            }
            if (leftIndent < columns.length && lockType === 'left') {
                _util.log.warning('expandedRowIndent left is less than the number of left lock columns.');
            }
            if (rightIndent < columns.length && lockType === 'right') {
                _util.log.warning('expandedRowIndent right is less than the number of right lock columns.');
            }
            if (lockType) {
                return openRowKeys.indexOf(record[primaryKey]) > -1 ? _react2.default.createElement(
                    'tr',
                    { className: prefix + 'table-expanded-row', key: 'expanded-' + index },
                    _react2.default.createElement(
                        'td',
                        { colSpan: colSpan, ref: function ref(cell) {
                                return cellRef(index, 0, cell);
                            } },
                        '\xA0'
                    )
                ) : null;
            }
            content = expandedRowRender(record, index);
            if (!_react2.default.isValidElement(content)) {
                content = _react2.default.createElement(
                    'div',
                    { className: prefix + 'table-cell-wrapper' },
                    content
                );
            }
            return openRowKeys.indexOf(record[primaryKey]) > -1 ? _react2.default.createElement(
                'tr',
                { className: prefix + 'table-expanded-row', key: 'expanded-' + (record[primaryKey] || index) },
                renderCols(leftIndent),
                _react2.default.createElement(
                    'td',
                    { colSpan: colSpan - totalIndent },
                    content
                ),
                renderCols(rightIndent)
            ) : null;
        } else {
            return null;
        }
    };

    ExpandedRow.prototype.render = function render() {
        /* eslint-disable no-unused-vars*/
        var _props3 = this.props,
            record = _props3.record,
            rowIndex = _props3.rowIndex,
            columns = _props3.columns;

        if (record.__expanded) {
            return this.renderExpandedRow(record, rowIndex, columns.length);
        }
        return _react2.default.createElement(_row2.default, this.props);
    };

    return ExpandedRow;
}(_react2.default.Component), _class.propTypes = _extends({}, _row2.default.propTypes), _class.defaultProps = _extends({}, _row2.default.defaultProps), _class.contextTypes = {
    openRowKeys: _propTypes2.default.array,
    expandedRowRender: _propTypes2.default.func,
    expandedRowIndent: _propTypes2.default.array,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}, _temp);
ExpandedRow.displayName = 'ExpandedRow';
exports.default = ExpandedRow;
module.exports = exports['default'];

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _row = __webpack_require__(17);

var _row2 = _interopRequireDefault(_row);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var LockRow = (_temp2 = _class = function (_React$Component) {
    _inherits(LockRow, _React$Component);

    function LockRow() {
        var _temp, _this, _ret;

        _classCallCheck(this, LockRow);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onMouseEnter = function (record, index, e) {
            var onRowMouseEnter = _this.context.onRowMouseEnter;
            var onMouseEnter = _this.props.onMouseEnter;

            onRowMouseEnter && onRowMouseEnter(record, index, e);
            onMouseEnter(record, index, e);
        }, _this.onMouseLeave = function (record, index, e) {
            var onRowMouseLeave = _this.context.onRowMouseLeave;
            var onMouseLeave = _this.props.onMouseLeave;

            onRowMouseLeave && onRowMouseLeave(record, index, e);
            onMouseLeave(record, index, e);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    LockRow.prototype.render = function render() {
        /* eslint-disable no-unused-vars*/
        return _react2.default.createElement(_row2.default, _extends({}, this.props, { onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave }));
    };

    return LockRow;
}(_react2.default.Component), _class.propTypes = _extends({}, _row2.default.propTypes), _class.contextTypes = {
    onRowMouseEnter: _propTypes2.default.func,
    onRowMouseLeave: _propTypes2.default.func
}, _class.defaultProps = _extends({}, _row2.default.defaultProps), _temp2);
LockRow.displayName = 'LockRow';
exports.default = LockRow;
module.exports = exports['default'];

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _body = __webpack_require__(16);

var _body2 = _interopRequireDefault(_body);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var FixedBody = (_temp2 = _class = function (_React$Component) {
    _inherits(FixedBody, _React$Component);

    function FixedBody() {
        var _temp, _this, _ret;

        _classCallCheck(this, FixedBody);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onBodyScroll = function () {
            var onBodyScroll = _this.context.onBodyScroll;

            onBodyScroll && onBodyScroll();
            _this.props.onScroll();
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    FixedBody.prototype.componentDidMount = function componentDidMount() {
        var getNode = this.context.getNode;

        getNode && getNode('body', (0, _reactDom.findDOMNode)(this));
    };

    FixedBody.prototype.render = function render() {
        var _props = this.props,
            className = _props.className,
            colGroup = _props.colGroup,
            others = _objectWithoutProperties(_props, ['className', 'colGroup']);

        var _context = this.context,
            maxBodyHeight = _context.maxBodyHeight,
            fixedHeader = _context.fixedHeader;

        var style = {};
        if (fixedHeader) {
            style.maxHeight = maxBodyHeight;
        }
        return _react2.default.createElement(
            'div',
            { style: style, className: className, onScroll: this.onBodyScroll },
            _react2.default.createElement(
                'table',
                null,
                colGroup,
                _react2.default.createElement(_body2.default, _extends({}, others, { colGroup: colGroup }))
            )
        );
    };

    return FixedBody;
}(_react2.default.Component), _class.propTypes = {
    children: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    className: _propTypes2.default.string,
    colGroup: _propTypes2.default.any,
    onScroll: _propTypes2.default.func
}, _class.defaultProps = {
    onScroll: function onScroll() {}
}, _class.contextTypes = {
    fixedHeader: _propTypes2.default.bool,
    maxBodyHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    onBodyScroll: _propTypes2.default.func,
    getNode: _propTypes2.default.func
}, _temp2);
FixedBody.displayName = 'FixedBody';
exports.default = FixedBody;
module.exports = exports['default'];

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Table.GroupHeader
 * @order 2
 **/
var ListHeader = (_temp = _class = function (_React$Component) {
  _inherits(ListHeader, _React$Component);

  function ListHeader() {
    _classCallCheck(this, ListHeader);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  ListHeader.prototype.render = function render() {
    return null;
  };

  return ListHeader;
}(_react2.default.Component), _class.propTypes = {
  /**
   * 行渲染的逻辑
   */
  cell: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.node, _propTypes2.default.func]),
  /**
   * 是否在Children上面渲染selection
   */
  hasChildrenSelection: _propTypes2.default.bool,
  /**
   * 是否在GroupHeader上面渲染selection
   */
  hasSelection: _propTypes2.default.bool
}, _class.defaultProps = {
  cell: function cell() {
    return '';
  },
  hasSelection: true,
  hasChildrenSelection: false
}, _class._typeMark = 'listHeader', _temp);
ListHeader.displayName = 'ListHeader';
exports.default = ListHeader;
module.exports = exports['default'];

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Table.GroupFooter
 * @order 3
 **/
var ListFooter = (_temp = _class = function (_React$Component) {
    _inherits(ListFooter, _React$Component);

    function ListFooter() {
        _classCallCheck(this, ListFooter);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    ListFooter.prototype.render = function render() {
        return null;
    };

    return ListFooter;
}(_react2.default.Component), _class.propTypes = {
    /**
     * 行渲染的逻辑
     */
    cell: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.node, _propTypes2.default.func])
}, _class.defaultProps = {
    cell: function cell() {
        return '';
    }
}, _class._typeMark = 'listFooter', _temp);
ListFooter.displayName = 'ListFooter';
exports.default = ListFooter;
module.exports = exports['default'];

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(12);

__webpack_require__(146);

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _button = __webpack_require__(118);

var _button2 = _interopRequireDefault(_button);

var _group = __webpack_require__(119);

var _group2 = _interopRequireDefault(_group);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

_button2.default.Group = _group2.default;

exports.default = _configProvider2.default.config(_button2.default, {
    transform: function transform(props, deprecated) {
        if ('shape' in props) {
            deprecated('shape', 'text | warning | ghost', 'Button');

            var _props = props,
                shape = _props.shape,
                type = _props.type,
                others = _objectWithoutProperties(_props, ['shape', 'type']);

            var newType = type;
            if (type === 'light' || type === 'dark' || type === 'secondary' && shape === 'warning') {
                newType = 'normal';
            }

            var ghost = void 0;
            if (shape === 'ghost') {
                ghost = {
                    primary: 'dark',
                    secondary: 'dark',
                    normal: 'light',
                    dark: 'dark',
                    light: 'light'
                }[type || _button2.default.defaultProps.type];
            }

            var text = shape === 'text';
            var warning = shape === 'warning';

            props = _extends({ type: newType, ghost: ghost, text: text, warning: warning }, others);
        }

        return props;
    }
});
module.exports = exports['default'];

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(11);

__webpack_require__(148);

/***/ }),
/* 73 */,
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _animate = __webpack_require__(51);

var _animate2 = _interopRequireDefault(_animate);

var _expand = __webpack_require__(110);

var _expand2 = _interopRequireDefault(_expand);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_animate2.default.Expand = _expand2.default;

exports.default = _animate2.default;
module.exports = exports['default'];

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _overlay = __webpack_require__(15);

var _overlay2 = _interopRequireDefault(_overlay);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/** Loading */
var Loading = (_temp = _class = function (_React$Component) {
    _inherits(Loading, _React$Component);

    function Loading() {
        _classCallCheck(this, Loading);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    Loading.prototype.render = function render() {
        var _classNames2, _classNames3, _classNames4;

        var _props = this.props,
            tip = _props.tip,
            visible = _props.visible,
            children = _props.children,
            className = _props.className,
            style = _props.style,
            indicator = _props.indicator,
            color = _props.color,
            prefix = _props.prefix,
            fullScreen = _props.fullScreen,
            onVisibleChange = _props.onVisibleChange,
            tipAlign = _props.tipAlign,
            size = _props.size;


        var indicatorDom = null;
        var dotCls = prefix + 'loading-dot';

        if (indicator) {
            indicatorDom = indicator;
        } else {
            var _classNames;

            var backgroundColor = color;
            var fusionReactorCls = (0, _classnames2.default)((_classNames = {}, _classNames[prefix + 'loading-fusion-reactor'] = true, _classNames[prefix + 'loading-medium-fusion-reactor'] = size === 'medium', _classNames));
            indicatorDom = _react2.default.createElement(
                'div',
                { className: fusionReactorCls },
                _react2.default.createElement('span', { className: dotCls, style: { backgroundColor: backgroundColor } }),
                _react2.default.createElement('span', { className: dotCls, style: { backgroundColor: backgroundColor } }),
                _react2.default.createElement('span', { className: dotCls, style: { backgroundColor: backgroundColor } }),
                _react2.default.createElement('span', { className: dotCls, style: { backgroundColor: backgroundColor } })
            );
        }

        var loadingCls = (0, _classnames2.default)((_classNames2 = {}, _classNames2[prefix + 'loading'] = true, _classNames2[prefix + 'open'] = visible, _classNames2[className] = className, _classNames2));

        var tipCls = (0, _classnames2.default)((_classNames3 = {}, _classNames3[prefix + 'loading-tip'] = true, _classNames3[prefix + 'loading-right-tip'] = tipAlign === 'right', _classNames3));

        var others = _util.obj.pickOthers(Loading.propTypes, this.props);

        var contentCls = (0, _classnames2.default)((_classNames4 = {}, _classNames4[prefix + 'loading-component'] = visible, _classNames4[prefix + 'loading-wrap'] = true, _classNames4));

        return fullScreen ? [children, _react2.default.createElement(
            _overlay2.default,
            _extends({ key: 'overlay', hasMask: true, align: 'cc cc' }, others, {
                className: className,
                style: style,
                visible: visible,
                onRequestClose: onVisibleChange }),
            _react2.default.createElement(
                'div',
                { className: tipCls },
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'loading-indicator' },
                    indicatorDom
                ),
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'loading-tip-content' },
                    tip
                ),
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'loading-tip-placeholder' },
                    tip
                )
            )
        )] : _react2.default.createElement(
            'div',
            _extends({ className: loadingCls, style: style }, others),
            visible ? _react2.default.createElement(
                'div',
                { className: tipCls },
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'loading-indicator' },
                    indicatorDom
                ),
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'loading-tip-content' },
                    tip
                ),
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'loading-tip-placeholder' },
                    tip
                )
            ) : null,
            _react2.default.createElement(
                'div',
                { className: contentCls },
                visible ? _react2.default.createElement('div', { className: prefix + 'loading-masker' }) : null,
                children
            )
        );
    };

    return Loading;
}(_react2.default.Component), _class.propTypes = {
    /**
     * 样式前缀
     */
    prefix: _propTypes2.default.string,
    /**
     * 自定义内容
     */
    tip: _propTypes2.default.any,
    /**
     * 自定义内容位置
     * @enumdesc 出现在动画右边, 出现在动画下面
     */
    tipAlign: _propTypes2.default.oneOf(['right', 'bottom']),
    /**
     * loading 状态, 默认 true
     */
    visible: _propTypes2.default.bool,
    onVisibleChange: _propTypes2.default.func,
    /**
     * 自定义class
     */
    className: _propTypes2.default.string,
    /**
     * 自定义内联样式
     */
    style: _propTypes2.default.object,
    /**
     * 设置动画尺寸
     * @description 仅仅对默认动画效果起作用
     * @enumdesc 大号, 中号
     */
    size: _propTypes2.default.oneOf(['large', 'medium']),
    /**
     * 自定义动画
     */
    indicator: _propTypes2.default.any,
    /**
     * 动画颜色
     */
    color: _propTypes2.default.string,
    /**
     * 全屏展示
     */
    fullScreen: _propTypes2.default.bool,
    /**
     * 子元素
     */
    children: _propTypes2.default.any
}, _class.defaultProps = {
    prefix: 'next-',
    visible: true,
    onVisibleChange: _util.func.noop,
    animate: null,
    tipAlign: 'bottom',
    size: 'large'
}, _temp);
Loading.displayName = 'Loading';
exports.default = _configProvider2.default.config(Loading);
module.exports = exports['default'];

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _menu = __webpack_require__(50);

var _menu2 = _interopRequireDefault(_menu);

var _subMenu = __webpack_require__(101);

var _subMenu2 = _interopRequireDefault(_subMenu);

var _selectableItem = __webpack_require__(22);

var _selectableItem2 = _interopRequireDefault(_selectableItem);

var _checkboxItem = __webpack_require__(111);

var _checkboxItem2 = _interopRequireDefault(_checkboxItem);

var _radioItem = __webpack_require__(114);

var _radioItem2 = _interopRequireDefault(_radioItem);

var _popupItem = __webpack_require__(57);

var _popupItem2 = _interopRequireDefault(_popupItem);

var _group = __webpack_require__(115);

var _group2 = _interopRequireDefault(_group);

var _divider = __webpack_require__(116);

var _divider2 = _interopRequireDefault(_divider);

var _create = __webpack_require__(117);

var _create2 = _interopRequireDefault(_create);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

_menu2.default.SubMenu = _subMenu2.default;
_menu2.default.Item = _selectableItem2.default;
_menu2.default.CheckboxItem = _checkboxItem2.default;
_menu2.default.RadioItem = _radioItem2.default;
_menu2.default.PopupItem = _popupItem2.default;
_menu2.default.Group = _group2.default;
_menu2.default.Divider = _divider2.default;
_menu2.default.create = _create2.default;

/* istanbul ignore next */
var transform = function transform(props, deprecated) {
    if ('indentSize' in props) {
        deprecated('indentSize', 'inlineIndent', 'Menu');

        var _props = props,
            indentSize = _props.indentSize,
            others = _objectWithoutProperties(_props, ['indentSize']);

        props = _extends({ inlineIndent: indentSize }, others);
    }

    if ('onDeselect' in props) {
        deprecated('onDeselect', 'onSelect', 'Menu');
        if (props.onDeselect) {
            var _props2 = props,
                onDeselect = _props2.onDeselect,
                onSelect = _props2.onSelect,
                _others = _objectWithoutProperties(_props2, ['onDeselect', 'onSelect']);

            var newOnSelect = function newOnSelect(selectedKeys, item, extra) {
                if (!extra.select) {
                    onDeselect(extra.key);
                }
                if (onSelect) {
                    onSelect(selectedKeys, item, extra);
                }
            };

            props = _extends({ onSelect: newOnSelect }, _others);
        }
    }

    return props;
};

exports.default = _configProvider2.default.config(_menu2.default, {
    transform: transform
});
module.exports = exports['default'];

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(11);

__webpack_require__(12);

__webpack_require__(70);

__webpack_require__(38);

__webpack_require__(147);

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(11);

__webpack_require__(12);

__webpack_require__(36);

__webpack_require__(152);

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _base = __webpack_require__(95);

var _base2 = _interopRequireDefault(_base);

var _tree = __webpack_require__(123);

var _tree2 = _interopRequireDefault(_tree);

var _fixed = __webpack_require__(126);

var _fixed2 = _interopRequireDefault(_fixed);

var _selection = __webpack_require__(127);

var _selection2 = _interopRequireDefault(_selection);

var _expanded = __webpack_require__(128);

var _expanded2 = _interopRequireDefault(_expanded);

var _virtual = __webpack_require__(129);

var _virtual2 = _interopRequireDefault(_virtual);

var _lock = __webpack_require__(131);

var _lock2 = _interopRequireDefault(_lock);

var _list = __webpack_require__(134);

var _list2 = _interopRequireDefault(_list);

var _sticky = __webpack_require__(137);

var _sticky2 = _interopRequireDefault(_sticky);

var _listHeader = __webpack_require__(68);

var _listHeader2 = _interopRequireDefault(_listHeader);

var _listFooter = __webpack_require__(69);

var _listFooter2 = _interopRequireDefault(_listFooter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var ORDER_LIST = [_fixed2.default, _lock2.default, _selection2.default, _expanded2.default, _tree2.default, _virtual2.default, _list2.default, _sticky2.default];
var Table = ORDER_LIST.reduce(function (ret, current) {
    ret = current(ret);
    return ret;
}, _base2.default);
Table.Base = _base2.default;
Table.fixed = _fixed2.default;
Table.lock = _lock2.default;
Table.selection = _selection2.default;
Table.expanded = _expanded2.default;
Table.tree = _tree2.default;
Table.virtual = _virtual2.default;
Table.list = _list2.default;
Table.sticky = _sticky2.default;

Table.GroupHeader = _listHeader2.default;
Table.GroupFooter = _listFooter2.default;

exports.default = _configProvider2.default.config(Table, {
    componentName: 'Table',
    transform: function transform(props, deprecated) {
        if ('expandedRowKeys' in props) {
            deprecated('expandedRowKeys', 'openRowKeys', 'Table');

            var _props = props,
                expandedRowKeys = _props.expandedRowKeys,
                others = _objectWithoutProperties(_props, ['expandedRowKeys']);

            props = _extends({ openRowKeys: expandedRowKeys }, others);
        }
        if ('onExpandedChange' in props) {
            deprecated('onExpandedChange', 'onRowOpen', 'Table');

            var _props2 = props,
                onExpandedChange = _props2.onExpandedChange,
                _others = _objectWithoutProperties(_props2, ['onExpandedChange']);

            props = _extends({ onRowOpen: onExpandedChange }, _others);
        }
        if ('isLoading' in props) {
            deprecated('isLoading', 'loading', 'Table');

            var _props3 = props,
                isLoading = _props3.isLoading,
                _others2 = _objectWithoutProperties(_props3, ['isLoading']);

            props = _extends({ loading: isLoading }, _others2);
        }
        if ('indentSize' in props) {
            deprecated('indentSize', 'indent', 'Table');

            var _props4 = props,
                indentSize = _props4.indentSize,
                _others3 = _objectWithoutProperties(_props4, ['indentSize']);

            props = _extends({ indent: indentSize }, _others3);
        }
        if ('optimization' in props) {
            deprecated('optimization', 'pure', 'Table');

            var _props5 = props,
                optimization = _props5.optimization,
                _others4 = _objectWithoutProperties(_props5, ['optimization']);

            props = _extends({ pure: optimization }, _others4);
        }
        if ('getRowClassName' in props) {
            deprecated('getRowClassName', 'getRowProps', 'Table');

            var _props6 = props,
                getRowClassName = _props6.getRowClassName,
                getRowProps = _props6.getRowProps,
                _others5 = _objectWithoutProperties(_props6, ['getRowClassName', 'getRowProps']);

            if (getRowClassName) {
                var newGetRowProps = function newGetRowProps() {
                    return _extends({
                        className: getRowClassName.apply(undefined, arguments)
                    }, getRowProps ? getRowProps.apply(undefined, arguments) : {});
                };

                props = _extends({ getRowProps: newGetRowProps }, _others5);
            } else {
                props = _extends({ getRowProps: getRowProps }, _others5);
            }
        }

        return props;
    }
});
module.exports = exports['default'];

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var assign = __webpack_require__(81);

var ReactPropTypesSecret = __webpack_require__(20);
var checkPropTypes = __webpack_require__(82);

var printWarning = function printWarning() {};

if (process.env.NODE_ENV !== 'production') {
  printWarning = function printWarning(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function (isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
          err.name = 'Invariant Violation';
          throw err;
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (!manualPropTypeCallCache[cacheKey] &&
          // Avoid spamming the console because they are often not actionable except for lib authors
          manualPropTypeWarningCount < 3) {
            printWarning('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(_extends({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var printWarning = function printWarning() {};

if (process.env.NODE_ENV !== 'production') {
  var ReactPropTypesSecret = __webpack_require__(20);
  var loggedTypeFailures = {};

  printWarning = function printWarning(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + _typeof(typeSpecs[typeSpecName]) + '`.');
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + (typeof error === 'undefined' ? 'undefined' : _typeof(error)) + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
        }
      }
    }
  }
}

module.exports = checkPropTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__(20);

function emptyFunction() {}

module.exports = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.initLocales = initLocales;
exports.setLanguage = setLanguage;
exports.setLocale = setLocale;
exports.setDirection = setDirection;
exports.getLocale = getLocale;
exports.getLanguage = getLanguage;
exports.getDirection = getDirection;
exports.config = config;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _hoistNonReactStatics = __webpack_require__(85);

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _util = __webpack_require__(2);

var _getContextProps = __webpack_require__(39);

var _getContextProps2 = _interopRequireDefault(_getContextProps);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var shallowEqual = _util.obj.shallowEqual;


function getDisplayName(Component) {
    return Component.displayName || Component.name || 'Component';
}

var globalLocales = void 0;
var currentGlobalLanguage = 'zh-cn';
var currentGlobalLocale = {};
var currentGlobalRtl = false;

function initLocales(locales) {
    globalLocales = locales;
    currentGlobalLocale = locales[currentGlobalLanguage];
}

function setLanguage(language) {
    if (globalLocales) {
        currentGlobalLanguage = language;
        currentGlobalLocale = globalLocales[language];
    }
}

function setLocale(locale) {
    currentGlobalLocale = _extends({}, globalLocales ? globalLocales[currentGlobalLanguage] : {}, locale);
}

function setDirection(dir) {
    currentGlobalRtl = dir === 'rtl';
}

function getLocale() {
    return currentGlobalLocale;
}

function getLanguage() {
    return currentGlobalLanguage;
}

function getDirection() {
    return currentGlobalRtl;
}

function config(Component) {
    var _class, _temp;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (Component.prototype.shouldComponentUpdate === undefined) {
        Component.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
            if (this.props.pure) {
                return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);
            }

            return true;
        };
    }

    var ConfigedComponent = (_temp = _class = function (_React$Component) {
        _inherits(ConfigedComponent, _React$Component);

        function ConfigedComponent(props, context) {
            _classCallCheck(this, ConfigedComponent);

            var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

            _this._getInstance = _this._getInstance.bind(_this);
            _this._deprecated = _this._deprecated.bind(_this);
            return _this;
        }

        ConfigedComponent.prototype._getInstance = function _getInstance(ref) {
            var _this2 = this;

            this._instance = ref;

            if (this._instance && options.exportNames) {
                options.exportNames.forEach(function (name) {
                    var field = _this2._instance[name];
                    if (typeof field === 'function') {
                        _this2[name] = field.bind(_this2._instance);
                    } else {
                        _this2[name] = field;
                    }
                });
            }
        };

        ConfigedComponent.prototype._deprecated = function _deprecated() {
            if (this.context.nextWarning !== false) {
                _util.log.deprecated.apply(_util.log, arguments);
            }
        };

        ConfigedComponent.prototype.getInstance = function getInstance() {
            return this._instance;
        };

        ConfigedComponent.prototype.render = function render() {
            var _props = this.props,
                prefix = _props.prefix,
                locale = _props.locale,
                pure = _props.pure,
                rtl = _props.rtl,
                others = _objectWithoutProperties(_props, ['prefix', 'locale', 'pure', 'rtl']);

            var _context = this.context,
                nextPrefix = _context.nextPrefix,
                _context$nextLocale = _context.nextLocale,
                nextLocale = _context$nextLocale === undefined ? {} : _context$nextLocale,
                nextPure = _context.nextPure,
                nextRtl = _context.nextRtl;


            var displayName = options.componentName || getDisplayName(Component);
            var contextProps = (0, _getContextProps2.default)({ prefix: prefix, locale: locale, pure: pure, rtl: rtl }, {
                nextPrefix: nextPrefix,
                nextLocale: _extends({}, currentGlobalLocale, nextLocale),
                nextPure: nextPure,
                nextRtl: typeof nextRtl === 'boolean' ? nextRtl : currentGlobalRtl === true ? true : undefined
            }, displayName);

            var newContextProps = ['prefix', 'locale', 'pure', 'rtl'].reduce(function (ret, name) {
                if (typeof contextProps[name] !== 'undefined') {
                    ret[name] = contextProps[name];
                }
                return ret;
            }, {});

            var newOthers = options.transform ? options.transform(others, this._deprecated) : others;

            return _react2.default.createElement(Component, _extends({}, newOthers, newContextProps, {
                ref: this._getInstance
            }));
        };

        return ConfigedComponent;
    }(_react2.default.Component), _class.propTypes = _extends({}, Component.propTypes || {}, {
        prefix: _propTypes2.default.string,
        locale: _propTypes2.default.object,
        pure: _propTypes2.default.bool,
        rtl: _propTypes2.default.bool
    }), _class.contextTypes = _extends({}, Component.contextTypes || {}, {
        nextPrefix: _propTypes2.default.string,
        nextLocale: _propTypes2.default.object,
        nextPure: _propTypes2.default.bool,
        nextRtl: _propTypes2.default.bool,
        nextWarning: _propTypes2.default.bool
    }), _temp);
    ConfigedComponent.displayName = 'ConfigedComponent';


    ConfigedComponent.displayName = 'Config(' + getDisplayName(Component) + ')';

    (0, _hoistNonReactStatics2.default)(ConfigedComponent, Component);

    return ConfigedComponent;
}

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
        // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
}

module.exports = hoistNonReactStatics;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.on = on;
exports.once = once;
/**
 * 取消事件绑定
 * @param  {*}   node       DOM节点或任何可以绑定事件的对象
 * @param  {String}   eventName  事件名
 * @param  {Function} callback   回调方法
 * @param  {Boolean}   [useCapture=false] 是否开启事件捕获优先
 */
function _off(node, eventName, callback, useCapture) {
    /* istanbul ignore else */
    if (node.removeEventListener) {
        node.removeEventListener(eventName, callback, useCapture || false);
    }
}

/**
 * 绑定事件
 * @param  {*}   node       DOM节点或任何可以绑定事件的对象
 * @param  {String}   eventName  事件名
 * @param  {Function} callback   回调方法
 * @param  {Boolean}   useCapture 是否开启事件捕获优先
 * @return {Object}               返回的object中包含一个off方法，用于取消事件监听
 *
 * @example
 * const handler = events.on(document.body, 'click', e => {
 *     // handle click ...
 * });
 * // 取消事件绑定
 * handler.off();
 */
exports.off = _off;
function on(node, eventName, callback, useCapture) {
    /* istanbul ignore else */
    if (node.addEventListener) {
        node.addEventListener(eventName, callback, useCapture || false);
    }

    return {
        off: function off() {
            return _off(node, eventName, callback, useCapture);
        }
    };
}

/**
 * 绑定事件，只执行一次后销毁
 * @param  {*}   node       DOM节点或任何可以绑定事件的对象
 * @param  {String}   eventName  事件名
 * @param  {Function} callback   回调方法
 * @param  {Boolean}   useCapture 是否开启事件捕获优先
 * @return {Function}             返回的object中包含一个off方法，用于取消事件监听
 */
function once(node, eventName, callback, useCapture) {
    return on(node, eventName, function __fn() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        callback.apply(this, args);

        // 由于addEventListener中的参数options只在Chrome 55、Firefox(Gecko)以上版本支持，故还是用传统的方法实现once
        _off(node, eventName, __fn, useCapture);
    }, useCapture);
}

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.noop = undefined;
exports.makeChain = makeChain;
exports.bindCtx = bindCtx;
exports.promiseCall = promiseCall;

var _object = __webpack_require__(13);

/**
 * 一个空方法，返回入参本身或空对象
 */
var noop = exports.noop = function noop() {};

/**
 * 将N个方法合并为一个链式调用的方法
 * @return {Function}     合并后的方法
 * 参考 https://github.com/react-component/util/
 *
 * @example
 * func.makeChain(this.handleChange, this.props.onChange);
 */
function makeChain() {
    for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
        fns[_key] = arguments[_key];
    }

    if (fns.length === 1) {
        return fns[0];
    }

    return function chainedFunction() {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
        }

        for (var i = 0, j = fns.length; i < j; i++) {
            if (fns[i] && fns[i].apply) {
                fns[i].apply(this, args);
            }
        }
    };
}

/**
 * 批量改变方法的上下文
 * 此方法在react组件中很有用，在constructor中批量将组件上的方法执行上下文绑定到组件本身
 * 注意：用bind改变函数运行的上下文只会生效一次
 * @param  {Object} ctx 方法挂载的对象以及执行的上下文
 * @param  {Array<String>} fns 方法名列表
 *
 * @example
 * func.bindCtx(this, ['handleClick', 'handleChange']);
 */
function bindCtx(ctx, fns, ns) {
    if (typeof fns === 'string') {
        fns = [fns];
    }

    // 方法的挂载空间，如果不传，默认与ctx相同
    ns = ns || ctx;

    fns.forEach(function (fnName) {
        // 这里不要添加空方法判断，由调用者保证正确性，否则出了问题无法排查
        ns[fnName] = ns[fnName].bind(ctx);
    });
}

/**
 * 用于执行回调方法后的逻辑
 * @param  {*} ret            回调方法执行结果
 * @param  {Function} success 执行结果返回非false的回调
 * @param  {Function} [failure=noop] 执行结果返回false的回调
 */
function promiseCall(ret, success) {
    var failure = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

    if ((0, _object.isPromise)(ret)) {
        return ret.then(function (result) {
            success(result);
            return result;
        }).catch(function (e) {
            failure(e);
            // throw e;
        });
    }

    return ret !== false ? success(ret) : failure(ret);
}

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.deprecated = deprecated;
exports.warning = warning;

var _env = __webpack_require__(42);

/* eslint no-console: 0 */

/**
 * 反对使用某一方法或属性的警告
 * @param  {String} props     过时的属性或方法名
 * @param  {String} instead   替代的属性或方法名
 * @param  {String} component 组件名
 *
 * @example
 * log.deprecated('onBeforeClose', 'beforeClose', 'Dialog');
 * // Warning: onBeforeClose is deprecated at [ Dialog ], use [ beforeClose ] instead of it.
 */
function deprecated(props, instead, component) {
    /* istanbul ignore else */
    if (!(0, _env.isProduction)() && typeof console !== 'undefined' && console.error) {
        return console.error('Warning: [ ' + props + ' ] is deprecated at [ ' + component + ' ], ' + ('use [ ' + instead + ' ] instead of it.'));
    }
}

/**
 * 控制台警告日志
 * @param  {String} msg
 */
function warning(msg) {
    /* istanbul ignore else */
    if (typeof console !== 'undefined' && console.error) {
        return console.error('Warning: ' + msg);
    }
}

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.flex = exports.transition = exports.animation = undefined;

var _dom = __webpack_require__(40);

var _object = __webpack_require__(13);

var animationEndEventNames = {
    WebkitAnimation: 'webkitAnimationEnd',
    OAnimation: 'oAnimationEnd',
    animation: 'animationend'
};

var transitionEventNames = {
    WebkitTransition: 'webkitTransitionEnd',
    OTransition: 'oTransitionEnd',
    transition: 'transitionend'
};

/**
 * 是否支持某些动效事件，如果支持，返回相应的end事件名
 * @private
 * @param  {Object<String>} names
 * @return {Object|false}
 */
function _supportEnd(names) {
    /* istanbul ignore if */
    if (!_dom.hasDOM) {
        return false;
    }

    var el = document.createElement('div');
    var ret = false;

    (0, _object.each)(names, function (val, key) {
        /* istanbul ignore else */
        if (el.style[key] !== undefined) {
            ret = { end: val };
            return false;
        }
    });

    return ret;
}

/**
 * 是否支持某些CSS属性
 * @private
 * @param  {Object<Array<String>>} names
 * @return {Boolean}       is support
 */
function _supportCSS(names) {
    /* istanbul ignore if */
    if (!_dom.hasDOM) {
        return false;
    }

    var el = document.createElement('div');
    var ret = false;

    (0, _object.each)(names, function (val, key) {
        (0, _object.each)(val, function (item) {
            try {
                el.style[key] = item;
                ret = ret || el.style[key] === item;
            } catch (e) {
                // It will be throw error when set unknown property under IE8
            }
            return !ret; // 如果有一个支持就返回false，后面不需要再判断
        });

        return !ret;
    });

    return ret;
}

/**
 * 是否支持animation以及动画结束事件名
 * @type {Object|false}
 * @property {String} end 动画结束事件名
 */
var animation = exports.animation = _supportEnd(animationEndEventNames);

/**
 * 是否支持transition以及过滤效果结束事件名
 * @type {Object|false}
 * @property {String} end 过渡效果结束事件名
 */
var transition = exports.transition = _supportEnd(transitionEventNames);

/**
 * 是否支持flex属性
 * @type {Boolean}
 */
var flex = exports.flex = _supportCSS({
    display: ['flex', '-webkit-flex', '-moz-flex', '-ms-flexbox']
});

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getFocusNodeList = getFocusNodeList;
exports.saveLastFocusNode = saveLastFocusNode;
exports.clearLastFocusNode = clearLastFocusNode;
exports.backLastFocusNode = backLastFocusNode;
exports.limitTabRange = limitTabRange;

var _keycode = __webpack_require__(43);

var _keycode2 = _interopRequireDefault(_keycode);

var _object = __webpack_require__(13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 用于切换页面元素的焦点
 */

/**
 * 元素是否可见
 * @private
 * @param   {Element}  node
 * @return  {Boolean}
 */
function _isVisible(node) {
    while (node) {
        if (node === document.body || node === document.documentElement) {
            break;
        }
        if (node.style.display === 'none' || node.style.visibility === 'hidden') {
            return false;
        }
        node = node.parentNode;
    }
    return true;
}

/**
 * 元素是否可以获取焦点
 * @private
 * @param   {Element}  node
 * @return  {Boolean}
 */
function _isFocusable(node) {
    var nodeName = node.nodeName.toLowerCase();
    var tabIndex = parseInt(node.getAttribute('tabindex'), 10);
    var hasTabIndex = !isNaN(tabIndex) && tabIndex > -1;

    if (_isVisible(node)) {
        if (nodeName === 'input') {
            return !node.disabled && node.type !== 'hidden';
        } else if (['select', 'textarea', 'button'].indexOf(nodeName) > -1) {
            return !node.disabled;
        } else if (nodeName === 'a') {
            return node.getAttribute('href') || hasTabIndex;
        } else {
            return hasTabIndex;
        }
    }
    return false;
}

/**
 * 列出能获取焦点的子节点
 * @param  {Element} node 容器节点
 * @return {Array<Element>}
 */
function getFocusNodeList(node) {
    var res = [];
    var nodeList = node.querySelectorAll('*');

    (0, _object.each)(nodeList, function (item) {
        if (_isFocusable(item)) {
            var method = item.getAttribute('data-auto-focus') ? 'unshift' : 'push';
            res[method](item);
        }
    });

    if (_isFocusable(node)) {
        res.unshift(node);
    }

    return res;
}

// 用于记录上一次获得焦点的无素
var lastFocusElement = null;

/**
 * 保存最近一次获得焦点的无素
 */
function saveLastFocusNode() {
    lastFocusElement = document.activeElement;
}

/**
 * 清除焦点记录
 */
function clearLastFocusNode() {
    lastFocusElement = null;
}

/**
 * 尝试将焦点切换到上一个元素
 */
function backLastFocusNode() {
    if (lastFocusElement) {
        try {
            // 元素可能已经被移动了
            lastFocusElement.focus();
        } catch (e) {
            // ignore ...
        }
    }
}

/**
 * 在限制的范围内切换焦点
 * @param  {Element} node 容器节点
 * @param  {Event} e      键盘事件
 */
function limitTabRange(node, e) {
    if (e.keyCode === _keycode2.default.TAB) {
        var tabNodeList = getFocusNodeList(node);
        var maxIndex = tabNodeList.length - 1;
        var index = tabNodeList.indexOf(document.activeElement);

        if (index > -1) {
            var targetIndex = index + (e.shiftKey ? -1 : 1);
            targetIndex < 0 && (targetIndex = maxIndex);
            targetIndex > maxIndex && (targetIndex = 0);
            tabNodeList[targetIndex].focus();
            e.preventDefault();
        }
    }
}

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (prefix) {
  prefix = prefix || '';

  return prefix + (timestamp++).toString(36);
};

var timestamp = Date.now();

/**
 * 生成全局唯一的id
 * @param  {String} [prefix=''] 前缀字符串
 * @return {String}
 *
 * @example
 * guid(); // j7jv509c
 * guid('prefix-'); // prefix-j7jv509d
 */
module.exports = exports['default'];

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates an object with the same values as object and keys
 * generated by running each own enumerable string keyed property
 * of object thru iteratee.
 * @param {Object} obj
 * @param {Function} fn
 * @return {Object}
 */
var mapKeys = function mapKeys(obj, fn) {
    var result = {};
    for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var value = obj[key];
            var newKey = fn(key, value);
            result[newKey] = value;
        }
    }

    return result;
};

/**
 * Replace specific key with prefix `next`
 * and lowercase first character of the result.
 * @param {String} key
 * @return {String}
 */
var replaceKey = function replaceKey(key) {
    return key.replace(/^(next)([A-Z])/, function (match, p1, p2) {
        return p2.toLowerCase();
    });
};

/**
 * @param {Object} source
 * @return {Object}
 */
var transformContext = function transformContext(source) {
    return mapKeys(source, replaceKey);
};

/**
 * Consumer
 * @param {Object} prop
 * @param {Object} context
 */
var Consumer = function Consumer(_ref, context) {
    var children = _ref.children;
    return typeof children === 'function' ? children(transformContext(context)) : null;
};

/**
 * PropTypes
 * @type {Object}
 * @static
 */
Consumer.propTypes = {
    // Render context as function
    // Function(context: object): ReactElement
    children: _propTypes2.default.func
};

/**
 * ContextTypes (legacy context)
 * @type {Object}
 * @static
 */
Consumer.contextTypes = {
    nextPrefix: _propTypes2.default.string,
    nextLocale: _propTypes2.default.object,
    nextPure: _propTypes2.default.bool,
    newRtl: _propTypes2.default.bool,
    nextWarning: _propTypes2.default.bool
};

exports.default = Consumer;
module.exports = exports['default'];

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Cache = function () {
    function Cache() {
        _classCallCheck(this, Cache);

        this._root = null;
        this._store = new Map();
    }

    Cache.prototype.empty = function empty() {
        return this._store.size === 0;
    };

    Cache.prototype.has = function has(key) {
        return this._store.has(key);
    };

    Cache.prototype.get = function get(key, defaultValue) {
        var res = this.has(key) ? this._store.get(key) : this.root();
        return typeof res === 'undefined' || res === null ? defaultValue : res;
    };

    Cache.prototype.add = function add(key, value) {
        if (this.empty()) {
            this._root = key;
        }
        this._store.set(key, value);
    };

    Cache.prototype.update = function update(key, value) {
        if (this.has(key)) {
            this._store.set(key, value);
        }
    };

    Cache.prototype.remove = function remove(key) {
        this._store.delete(key);
    };

    Cache.prototype.root = function root() {
        return this._store.get(this._root);
    };

    return Cache;
}();

exports.default = Cache;
module.exports = exports['default'];

/***/ }),
/* 94 */
/***/ (function(module, exports) {

if(typeof window.moment === 'undefined') {var e = new Error("Cannot find module \"window.moment\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
module.exports = window.moment;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _shallowElementEquals = __webpack_require__(44);

var _shallowElementEquals2 = _interopRequireDefault(_shallowElementEquals);

var _loading = __webpack_require__(75);

var _loading2 = _interopRequireDefault(_loading);

var _zhCn = __webpack_require__(35);

var _zhCn2 = _interopRequireDefault(_zhCn);

var _util = __webpack_require__(2);

var _body = __webpack_require__(16);

var _body2 = _interopRequireDefault(_body);

var _header = __webpack_require__(48);

var _header2 = _interopRequireDefault(_header);

var _wrapper = __webpack_require__(121);

var _wrapper2 = _interopRequireDefault(_wrapper);

var _row = __webpack_require__(17);

var _row2 = _interopRequireDefault(_row);

var _cell = __webpack_require__(18);

var _cell2 = _interopRequireDefault(_cell);

var _filter = __webpack_require__(49);

var _filter2 = _interopRequireDefault(_filter);

var _sort = __webpack_require__(63);

var _sort2 = _interopRequireDefault(_sort);

var _column = __webpack_require__(23);

var _column2 = _interopRequireDefault(_column);

var _columnGroup = __webpack_require__(122);

var _columnGroup2 = _interopRequireDefault(_columnGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var Children = _react2.default.Children,
    noop = function noop() {};

//<Table>
//    <Table.Column/>
//    <Table.ColumnGroup>
//      <Table.Column/>
//      <Table.Column/>
//    </Table.ColumnGroup>
//</Table>

/** Table */
var Table = (_temp = _class = function (_React$Component) {
    _inherits(Table, _React$Component);

    function Table(props, context) {
        _classCallCheck(this, Table);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

        _this.state = {
            sort: _this.props.sort || {}
        };

        _this.onSort = function (dataIndex, order, sort) {
            if (typeof _this.props.sort === 'undefined') {
                _this.setState({
                    sort: sort
                }, function () {
                    _this.props.onSort(dataIndex, order, sort);
                });
            } else {
                _this.props.onSort(dataIndex, order, sort);
            }
        };

        _this.onFilter = function (filterParams) {
            _this.props.onFilter(filterParams);
        };

        _this.onResizeChange = function (dataIndex, value) {
            _this.props.onResizeChange(dataIndex, value);
        };

        _this.getWrapperRef = function (wrapper) {
            if (!wrapper) {
                return _this.wrapper;
            }
            _this.wrapper = wrapper;
        };

        _this.getAffixRef = function (affixRef) {
            if (!affixRef) {
                return _this.affixRef;
            }
            _this.affixRef = affixRef;
        };

        _this.getHeaderCellRef = function (i, j, cell) {
            var cellRef = 'header_cell_' + i + '_' + j;
            if (!cell) {
                return _this[cellRef];
            }
            _this[cellRef] = cell;
        };

        _this.getRowRef = function (i, row) {
            var rowRef = 'row_' + i;
            if (!row) {
                return _this[rowRef];
            }
            _this[rowRef] = row;
        };

        _this.getCellRef = function (i, j, cell) {
            var cellRef = 'cell_' + i + '_' + j;
            if (!cell) {
                return _this[cellRef];
            }
            _this[cellRef] = cell;
        };

        var _this$context = _this.context,
            getTableInstance = _this$context.getTableInstance,
            getTableInstanceForVirtual = _this$context.getTableInstanceForVirtual;

        getTableInstance && getTableInstance(props.lockType, _this);
        getTableInstanceForVirtual && getTableInstanceForVirtual(props.lockType, _this);
        _this.notRenderCellIndex = [];
        return _this;
    }

    Table.prototype.getChildContext = function getChildContext() {
        return {
            notRenderCellIndex: this.notRenderCellIndex,
            lockType: this.props.lockType
        };
    };

    Table.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (typeof this.props.sort !== 'undefined') {
            this.setState({
                sort: nextProps.sort
            });
        }
    };

    Table.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState, nextContext) {
        if (nextProps.pure) {
            var isEqual = (0, _shallowElementEquals2.default)(nextProps, this.props) && _util.obj.shallowEqual(nextState, this.state) && _util.obj.shallowEqual(nextContext, this.context);
            return !isEqual;
        }

        return true;
    };

    Table.prototype.componentWillUpdate = function componentWillUpdate() {
        this.notRenderCellIndex = [];
    };

    Table.prototype.normalizeChildrenState = function normalizeChildrenState(props) {
        var columns = props.columns;
        if (props.children) {
            columns = this.normalizeChildren(props);
        }
        return this.fetchInfoFromBinaryChildren(columns);
    };

    // 将React结构化数据提取props转换成数组


    Table.prototype.normalizeChildren = function normalizeChildren(props) {
        var columns = props.columns;

        var getChildren = function getChildren(children) {
            var ret = [];
            Children.forEach(children, function (child) {
                if (child) {
                    var _props = _extends({}, child.props);

                    if (!(child && typeof child.type === 'function' && (child.type._typeMark === 'column' || child.type._typeMark === 'columnGroup'))) {
                        _util.log.warning('Use <Table.Column/>, <Table.ColumnGroup/> as child.');
                    }
                    ret.push(_props);
                    if (child.props.children) {
                        _props.children = getChildren(child.props.children);
                    }
                }
            });
            return ret;
        };
        if (props.children) {
            columns = getChildren(props.children);
        }
        return columns;
    };

    Table.prototype.fetchInfoFromBinaryChildren = function fetchInfoFromBinaryChildren(children) {
        var hasGroupHeader = false;
        var flatChildren = [],
            groupChildren = [],
            getChildren = function getChildren(propsChildren, level) {
            groupChildren[level] = groupChildren[level] || [];
            propsChildren.forEach(function (child) {
                if (child.children) {
                    hasGroupHeader = true;
                    getChildren(child.children, level + 1);
                } else {
                    flatChildren.push(child);
                }
                groupChildren[level].push(child);
            });
        },
            getColSpan = function getColSpan(children, colSpan) {
            colSpan = colSpan || 0;
            children.forEach(function (child) {
                if (child.children) {
                    colSpan = getColSpan(child.children, colSpan);
                } else {
                    colSpan += 1;
                }
            });
            return colSpan;
        };

        getChildren(children, 0);

        groupChildren.forEach(function (groupChild, i) {
            groupChild.forEach(function (child, j) {
                var colSpan = void 0;
                var children = child.children;

                if (children) {
                    colSpan = getColSpan(children);
                    child.colSpan = colSpan;
                    groupChildren[i][j] = child;
                }
            });
        });

        return {
            flatChildren: flatChildren,
            groupChildren: groupChildren,
            hasGroupHeader: hasGroupHeader
        };
    };

    Table.prototype.renderColGroup = function renderColGroup(flatChildren) {
        var cols = flatChildren.map(function (col, index) {
            var width = col.width;
            var style = {};
            if (width) {
                style = {
                    width: width
                };
            }

            return _react2.default.createElement('col', { style: style, key: index });
        });
        return _react2.default.createElement(
            'colgroup',
            { key: 'table-colgroup' },
            cols
        );
    };

    // 通过头部和扁平的结构渲染表格
    Table.prototype.renderTable = function renderTable(groupChildren, flatChildren) {
        if (flatChildren.length || !flatChildren.length && !this.props.lockType) {
            var _props2 = this.props,
                hasHeader = _props2.hasHeader,
                components = _props2.components,
                prefix = _props2.prefix,
                wrapperContent = _props2.wrapperContent,
                filterParams = _props2.filterParams,
                locale = _props2.locale,
                dataSource = _props2.dataSource,
                emptyContent = _props2.emptyContent,
                loading = _props2.loading,
                getCellProps = _props2.getCellProps,
                primaryKey = _props2.primaryKey,
                getRowProps = _props2.getRowProps,
                onRowClick = _props2.onRowClick,
                onRowMouseEnter = _props2.onRowMouseEnter,
                onRowMouseLeave = _props2.onRowMouseLeave,
                pure = _props2.pure;
            var sort = this.state.sort;
            var _components$Header = components.Header,
                Header = _components$Header === undefined ? _header2.default : _components$Header,
                _components$Wrapper = components.Wrapper,
                Wrapper = _components$Wrapper === undefined ? _wrapper2.default : _components$Wrapper,
                _components$Body = components.Body,
                Body = _components$Body === undefined ? _body2.default : _components$Body;

            var colGroup = this.renderColGroup(flatChildren);

            return _react2.default.createElement(
                Wrapper,
                {
                    colGroup: colGroup,
                    ref: this.getWrapperRef,
                    prefix: prefix
                },
                hasHeader ? _react2.default.createElement(Header, {
                    prefix: prefix,
                    pure: pure,
                    affixRef: this.getAffixRef,
                    colGroup: colGroup,
                    className: prefix + 'table-header',
                    filterParams: filterParams,
                    columns: groupChildren,
                    locale: locale,
                    headerCellRef: this.getHeaderCellRef,
                    components: components,
                    onFilter: this.onFilter,
                    sort: sort,
                    onResizeChange: this.onResizeChange,
                    onSort: this.onSort
                }) : null,
                _react2.default.createElement(Body, {
                    prefix: prefix,
                    pure: pure,
                    colGroup: colGroup,
                    className: prefix + 'table-body',
                    components: components,
                    loading: loading,
                    emptyContent: emptyContent,
                    getCellProps: getCellProps,
                    primaryKey: primaryKey,
                    getRowProps: getRowProps,
                    columns: flatChildren,
                    rowRef: this.getRowRef,
                    cellRef: this.getCellRef,
                    onRowClick: onRowClick,
                    onRowMouseEnter: onRowMouseEnter,
                    onRowMouseLeave: onRowMouseLeave,
                    dataSource: dataSource,
                    locale: locale
                }),
                wrapperContent
            );
        } else {
            return null;
        }
    };

    Table.prototype.render = function render() {
        var _classnames;

        var ret = this.normalizeChildrenState(this.props);
        this.groupChildren = ret.groupChildren;
        this.flatChildren = ret.flatChildren;
        /* eslint-disable no-unused-vars, prefer-const */
        var table = this.renderTable(ret.groupChildren, ret.flatChildren),
            _props3 = this.props,
            className = _props3.className,
            hasBorder = _props3.hasBorder,
            isZebra = _props3.isZebra,
            loading = _props3.loading,
            hasHeader = _props3.hasHeader,
            prefix = _props3.prefix,
            dataSource = _props3.dataSource,
            entireDataSource = _props3.entireDataSource,
            onSort = _props3.onSort,
            onResizeChange = _props3.onResizeChange,
            onRowClick = _props3.onRowClick,
            onRowMouseEnter = _props3.onRowMouseEnter,
            onRowMouseLeave = _props3.onRowMouseLeave,
            onFilter = _props3.onFilter,
            getRowProps = _props3.getRowProps,
            getCellProps = _props3.getCellProps,
            primaryKey = _props3.primaryKey,
            components = _props3.components,
            wrapperContent = _props3.wrapperContent,
            lockType = _props3.lockType,
            locale = _props3.locale,
            refs = _props3.refs,
            pure = _props3.pure,
            rtl = _props3.rtl,
            emptyContent = _props3.emptyContent,
            filterParams = _props3.filterParams,
            _props3$loadingCompon = _props3.loadingComponent,
            LoadingComponent = _props3$loadingCompon === undefined ? _loading2.default : _props3$loadingCompon,
            others = _objectWithoutProperties(_props3, ['className', 'hasBorder', 'isZebra', 'loading', 'hasHeader', 'prefix', 'dataSource', 'entireDataSource', 'onSort', 'onResizeChange', 'onRowClick', 'onRowMouseEnter', 'onRowMouseLeave', 'onFilter', 'getRowProps', 'getCellProps', 'primaryKey', 'components', 'wrapperContent', 'lockType', 'locale', 'refs', 'pure', 'rtl', 'emptyContent', 'filterParams', 'loadingComponent']),
            cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table'] = true, _classnames['only-bottom-border'] = !hasBorder, _classnames['no-header'] = !hasHeader, _classnames.zebra = isZebra, _classnames[className] = className, _classnames));


        if (rtl) {
            others.dir = 'rtl';
        }
        var content = _react2.default.createElement(
            'div',
            _extends({ className: cls }, others),
            table
        );
        if (loading) {
            var loadingClassName = prefix + 'table-loading';
            return _react2.default.createElement(
                LoadingComponent,
                { className: loadingClassName },
                content
            );
        }
        return content;
    };

    return Table;
}(_react2.default.Component), _class.Column = _column2.default, _class.ColumnGroup = _columnGroup2.default, _class.Header = _header2.default, _class.Body = _body2.default, _class.Wrapper = _wrapper2.default, _class.Row = _row2.default, _class.Cell = _cell2.default, _class.Filter = _filter2.default, _class.Sort = _sort2.default, _class.propTypes = {
    /**
     * 样式类名的品牌前缀
     */
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    rtl: _propTypes2.default.bool,
    /**
     * 自定义类名
     */
    className: _propTypes2.default.string,
    /**
     * 自定义内联样式
     */
    style: _propTypes2.default.object,
    /**
     * 表格展示的数据源
     */
    dataSource: _propTypes2.default.array,
    entireDataSource: _propTypes2.default.array,
    /**
     * 点击表格每一行触发的事件
     * @param {Object} record 该行所对应的数据
     * @param {Number} index 该行所对应的序列
     * @param {Event} e DOM事件对象
     */
    onRowClick: _propTypes2.default.func,
    /**
     * 悬浮在表格每一行的时候触发的事件
     * @param {Object} record 该行所对应的数据
     * @param {Number} index 该行所对应的序列
     * @param {Event} e DOM事件对象
     */
    onRowMouseEnter: _propTypes2.default.func,
    /**
     * 离开表格每一行的时候触发的事件
     * @param {Object} record 该行所对应的数据
     * @param {Number} index 该行所对应的序列
     * @param {Event} e DOM事件对象
     */
    onRowMouseLeave: _propTypes2.default.func,
    /**
     * 点击列排序触发的事件
     * @param {String} dataIndex 指定的排序的字段
     * @param {String} order 排序对应的顺序, 有`desc`和`asc`两种
     */
    onSort: _propTypes2.default.func,
    /**
     * 点击过滤确认按钮触发的事件
     * @param {Object} filterParams 过滤的字段信息
     */
    onFilter: _propTypes2.default.func,
    /**
     * 重设列尺寸的时候触发的事件
     * @param {String} dataIndex 指定重设的字段
     * @param {Number} value 列宽变动的数值
     */
    onResizeChange: _propTypes2.default.func,
    /**
     * 设置每一行的属性，如果返回值和其他针对行操作的属性冲突则无效。
     * @param {Object} record 该行所对应的数据
     * @param {Number} index 该行所对应的序列
     * @returns {Object} 需要设置的行属性
     */
    getRowProps: _propTypes2.default.func,
    /**
     * 设置单元格的属性，通过该属性可以进行合并单元格
     * @param {Number} rowIndex 该行所对应的序列
     * @param {Number} colIndex 该列所对应的序列
     * @param {String} dataIndex 该列所对应的字段名称
     * @param {Object} record 该行对应的记录
     * @returns {Object} 返回td元素的所支持的属性对象
     */
    getCellProps: _propTypes2.default.func,
    /**
     * 表格是否具有边框
     */
    hasBorder: _propTypes2.default.bool,
    /**
     * 表格是否具有头部
     */
    hasHeader: _propTypes2.default.bool,
    /**
     * 表格是否是斑马线
     */
    isZebra: _propTypes2.default.bool,
    /**
     * 表格是否在加载中
     */
    loading: _propTypes2.default.bool,
    /**
     * 自定义 Loading 组件
     * @type {Function}
     */
    loadingComponent: _propTypes2.default.func,
    /**
     * 当前过滤的的keys,使用此属性可以控制表格的头部的过滤选项中哪个菜单被选中,格式为 {dataIndex: {selectedKeys:[]}}
     * 示例:
     * 假设要控制dataIndex为id的列的过滤菜单中key为one的菜单项选中
     * `<Table filterParams={{id: {selectedKeys: ['one']}}}/>`
     */
    filterParams: _propTypes2.default.object,
    /**
     * 当前排序的字段,使用此属性可以控制表格的字段的排序,格式为{dataIndex: 'asc'}
     */
    sort: _propTypes2.default.object,
    /**
     * 自定义国际化文案对象
     * @property {String} ok 过滤器中确认按钮文案
     * @property {String} reset 过滤器中重置按钮文案
     * @property {String} empty 没有数据情况下 table内的文案
     * @property {String} asc 排序升序状态下的文案
     * @property {String} desc 排序将序状态下的文案
     * @property {String} expanded 可折叠行，展开状态下的文案
     * @property {String} folded 可折叠行，折叠状态下的文案
     * @property {String} filter 过滤器文案
     * @property {String} selectAll header里全选的按钮文案
     */
    locale: _propTypes2.default.object,
    components: _propTypes2.default.object,
    columns: _propTypes2.default.array,
    /**
     * 设置数据为空的时候的表格内容展现
     */
    emptyContent: _propTypes2.default.node,
    /**
     * dataSource当中数据的主键，如果给定的数据源中的属性不包含该主键，会造成选择状态全部选中
     */
    primaryKey: _propTypes2.default.string,
    lockType: _propTypes2.default.oneOf(['left', 'right']),
    wrapperContent: _propTypes2.default.any,
    refs: _propTypes2.default.object,
    /**
     * 额外渲染行的渲染函数
     * @param {Object} record 该行所对应的数据
     * @param {Number} index 该行所对应的序列
     * @returns {Element} 渲染内容
     */
    expandedRowRender: _propTypes2.default.func,
    /**
     * 额外渲染行的缩进
     */
    expandedRowIndent: _propTypes2.default.array,
    /**
     * 默认情况下展开的渲染行或者Tree, 传入此属性为受控状态
     */
    openRowKeys: _propTypes2.default.array,
    /**
     * 是否显示点击展开额外渲染行的+号按钮
     */
    hasExpandedRowCtrl: _propTypes2.default.bool,
    /**
     * 设置额外渲染行的属性
     */
    getExpandedColProps: _propTypes2.default.func,
    /**
     * 在额外渲染行或者Tree展开或者收起的时候触发的事件
     * @param {Array} openRowKeys 展开的渲染行的key
     * @param {String} currentRowKey 当前点击的渲染行的key
     * @param {Boolean} expanded 当前点击是展开还是收起
     * @param {Object} currentRecord 当前点击额外渲染行的记录
     */
    onRowOpen: _propTypes2.default.func,
    /**
     * 点击额外渲染行触发的事件
     * @param {Object} record 该行所对应的数据
     * @param {Number} index 该行所对应的序列
     * @param {Event} e DOM事件对象
     */
    onExpandedRowClick: _propTypes2.default.func,
    /**
     * 表头是否固定，该属性配合maxBodyHeight使用，当内容区域的高度超过maxBodyHeight的时候，在内容区域会出现滚动条
     */
    fixedHeader: _propTypes2.default.bool,
    /**
     * 最大内容区域的高度,在`fixedHeader`为`true`的时候,超过这个高度会出现滚动条
     */
    maxBodyHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    /**
     * 是否启用选择模式
     * @property {Function} getProps `Function(record, index)=>Object` 获取selection的默认属性
     * @property {Function} onChange `Function(selectedRowKeys:Array, records:Array)` 选择改变的时候触发的事件，**注意:** 其中records只会包含当前dataSource的数据，很可能会小于selectedRowKeys的长度。
     * @property {Function} onSelect `Function(selected:Boolean, record:Object, records:Array)` 用户手动选择/取消选择某行的回调
     * @property {Function} onSelectAll `Function(selected:Boolean, records:Array)` 用户手动选择/取消选择所有行的回调
     * @property {Array} selectedRowKeys 设置了此属性,将rowSelection变为受控状态,接收值为该行数据的primaryKey的值
     * @property {String} mode 选择selection的模式, 可选值为`single`, `multiple`，默认为`multiple`
     */
    rowSelection: _propTypes2.default.object,
    /**
     * 表头是否是sticky
     */
    stickyHeader: _propTypes2.default.bool,
    /**
     * 距离窗口顶部达到指定偏移量后触发
     */
    offsetTop: _propTypes2.default.number,
    /**
     * affix组件的的属性
     */
    affixProps: _propTypes2.default.object,
    /**
     * 在tree模式下的缩进尺寸， 仅在isTree为true时候有效
     */
    indent: _propTypes2.default.number,
    /**
     * 开启Table的tree模式, 接收的数据格式中包含children则渲染成tree table
     */
    isTree: _propTypes2.default.bool,
    /**
     * 是否开启虚拟滚动
     */
    useVirtual: _propTypes2.default.bool,
    /**
     * 设置行高
     */
    rowHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.func]),
    /**
     * 在内容区域滚动的时候触发的函数
     */
    onBodyScroll: _propTypes2.default.func
}, _class.defaultProps = {
    dataSource: [],
    onRowClick: noop,
    onRowMouseEnter: noop,
    onRowMouseLeave: noop,
    onSort: noop,
    onFilter: noop,
    onResizeChange: noop,
    getRowProps: noop,
    getCellProps: noop,
    prefix: 'next-',
    hasBorder: true,
    hasHeader: true,
    isZebra: false,
    loading: false,
    primaryKey: 'id',
    components: {},
    locale: _zhCn2.default.Table
}, _class.childContextTypes = {
    notRenderCellIndex: _propTypes2.default.array,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}, _class.contextTypes = {
    getTableInstance: _propTypes2.default.func,
    getTableInstanceForVirtual: _propTypes2.default.func
}, _temp);
Table.displayName = 'Table';
exports.default = Table;
module.exports = exports['default'];

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var hasOwnProperty = Object.prototype.hasOwnProperty;

function transformEntryEqual(a, b) {
  for (var k in a) {
    if (hasOwnProperty.call(a, k)) {
      return a[k] === b[k];
    }
  }
  return false;
}

function transformEqual(a, b) {
  if (!a && !b || a === b) {
    return true;
  }
  if (!a !== !b) {
    return false;
  }
  if (a.length !== b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!transformEntryEqual(a[i], b[i])) {
      return false;
    }
  }
  return true;
}

function shallowObjectEquals(a, b) {
  var k;
  var i = 0;
  var j = 0;
  for (k in a) {
    if (hasOwnProperty.call(a, k)) {
      switch (k) {
        case 'transform':
          if (!transformEqual(a[k], b[k])) {
            return false;
          }
          break;
        case 'shadowOffset':
          if (!shallowObjectEquals(a[k], b[k])) {
            return false;
          }
          break;
        default:
          if (a[k] !== b[k]) {
            return false;
          }
          break;
      }
      i++;
    }
  }
  for (k in b) {
    if (hasOwnProperty.call(b, k)) {
      j++;
    }
  }
  return i === j;
}

function styleEqual(a, b) {
  if (!a && !b || a === b) {
    return true;
  }
  if (!a !== !b) {
    return false;
  }
  switch (typeof a === 'undefined' ? 'undefined' : _typeof(a)) {
    case 'object':
      if (a instanceof Array) {
        for (var i = 0; i < a.length; i++) {
          if (!styleEqual(a[i], b[i])) {
            return false;
          }
        }
        return a.length === b.length;
      } else {
        return shallowObjectEquals(a, b);
      }
      break;
    case 'number':
    default:
      return a === b;
  }
}

module.exports = styleEqual;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var overlayManager = {
    allOverlays: [],

    addOverlay: function addOverlay(overlay) {
        this.removeOverlay(overlay);
        this.allOverlays.unshift(overlay);
    },
    isCurrentOverlay: function isCurrentOverlay(overlay) {
        return overlay && this.allOverlays[0] === overlay;
    },
    removeOverlay: function removeOverlay(overlay) {
        var i = this.allOverlays.indexOf(overlay);
        if (i > -1) {
            this.allOverlays.splice(i, 1);
        }
    }
};

exports.default = overlayManager;
module.exports = exports["default"];

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _util = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var VIEWPORT = 'viewport';

// IE8 not support pageXOffset
var getPageX = function getPageX() {
    return window.pageXOffset || document.documentElement.scrollLeft;
};
var getPageY = function getPageY() {
    return window.pageYOffset || document.documentElement.scrollTop;
};

/**
 * @private get element rect
 * @param       {Element} elem
 * @return      {Object}
 */
function _getElementRect(elem) {
    var offsetTop = 0,
        offsetLeft = 0;

    var offsetHeight = elem.offsetHeight;
    var offsetWidth = elem.offsetWidth;

    do {
        if (!isNaN(elem.offsetTop)) {
            offsetTop += elem.offsetTop;
        }
        if (!isNaN(elem.offsetLeft)) {
            offsetLeft += elem.offsetLeft;
        }
    } while ((elem = elem.offsetParent) !== null);

    return {
        top: offsetTop - (document.documentElement.scrollTop || document.body.scrollTop),
        left: offsetLeft - (document.documentElement.scrollLeft || document.body.scrollLeft),
        height: offsetHeight,
        width: offsetWidth
    };
}

/**
 * @private get viewport size
 * @return {Object}
 */
function _getViewportSize() {
    return {
        width: document.documentElement.clientWidth,
        height: document.documentElement.clientHeight
    };
}
var Position = (_temp = _class = function () {
    function Position(props) {
        _classCallCheck(this, Position);

        this.pinElement = props.pinElement;
        this.baseElement = props.baseElement;
        this.align = props.align || 'tl tl';
        this.offset = props.offset || [0, 0];
        this.needAdjust = props.needAdjust || false;
        this.isRtl = props.isRtl || false;
    }

    /**
     * @public static place method
     * @param  {Object}       props
     *     @param  {DOM}      props.pinElement
     *     @param  {DOM}      props.baseElement
     *     @param  {String}   props.align
     *     @param  {Number}   props.offset
     *     @param  {Boolean}  props.needAdjust
     *     @param  {Boolean}  props.isRtl
     * @return {Position}
     */


    Position.prototype.setPosition = function setPosition() {
        var pinElement = this.pinElement;
        var baseElement = this.baseElement;
        var expectedAlign = this._getExpectedAlign();
        var isPinFixed = void 0,
            isBaseFixed = void 0,
            firstPositionResult = void 0;
        if (pinElement === VIEWPORT) {
            return;
        }
        if (_util.dom.getStyle(pinElement, 'position') !== 'fixed') {
            _util.dom.setStyle(pinElement, 'position', 'absolute');
            isPinFixed = false;
        } else {
            isPinFixed = true;
        }
        if (baseElement === VIEWPORT || _util.dom.getStyle(baseElement, 'position') !== 'fixed') {
            isBaseFixed = false;
        } else {
            isBaseFixed = true;
        }
        // 根据期望的定位
        for (var i = 0; i < expectedAlign.length; i++) {
            var align = expectedAlign[i];
            var pinElementPoints = this._normalizePosition(pinElement, align.split(' ')[0], isPinFixed);
            var baseElementPoints = this._normalizePosition(baseElement, align.split(' ')[1], isPinFixed);
            var pinElementParentOffset = this._getParentOffset(pinElement);
            var baseElementOffset = isPinFixed && isBaseFixed ? this._getLeftTop(baseElement) : baseElementPoints.offset();
            var top = baseElementOffset.top + baseElementPoints.y - pinElementParentOffset.top - pinElementPoints.y;
            var left = baseElementOffset.left + baseElementPoints.x - pinElementParentOffset.left - pinElementPoints.x;
            this._setPinElementPostion(pinElement, { left: left, top: top }, this.offset);

            if (!firstPositionResult) {
                firstPositionResult = { left: left, top: top };
            }
            if (this._isInViewport(pinElement)) {
                return align;
            }
        }

        var inViewportLeft = this._makeElementInViewport(pinElement, firstPositionResult.left, 'Left', isPinFixed);
        var inViewportTop = this._makeElementInViewport(pinElement, firstPositionResult.top, 'Top', isPinFixed);

        this._setPinElementPostion(pinElement, { left: inViewportLeft, top: inViewportTop });
        return expectedAlign[0];
    };

    Position.prototype._getParentOffset = function _getParentOffset(element) {
        var parent = element.offsetParent || document.documentElement;
        var offset = void 0;
        if (parent === document.body && _util.dom.getStyle(parent, 'position') === 'static') {
            offset = {
                top: 0,
                left: 0
            };
        } else {
            offset = this._getElementOffset(parent);
        }

        offset.top += parseFloat(_util.dom.getStyle(parent, 'border-top-width'), 10);
        offset.left += parseFloat(_util.dom.getStyle(parent, 'border-left-width'), 10);
        offset.offsetParent = parent;
        return offset;
    };

    Position.prototype._makeElementInViewport = function _makeElementInViewport(pinElement, number, type, isPinFixed) {
        var result = number;
        var docElement = document.documentElement;
        var offsetParent = pinElement.offsetParent || document.documentElement;

        if (result < 0) {
            if (isPinFixed) {
                result = 0;
            } else if (offsetParent === document.body && _util.dom.getStyle(offsetParent, 'position') === 'static') {
                // Only when div's offsetParent is document.body, we set new position result.
                result = Math.max(docElement['scroll' + type], document.body['scroll' + type]);
            }
        }

        return result;
    };

    Position.prototype._normalizePosition = function _normalizePosition(element, align, isPinFixed) {
        var points = this._normalizeElement(element, isPinFixed);
        this._normalizeXY(points, align);

        return points;
    };

    Position.prototype._normalizeXY = function _normalizeXY(points, align) {
        var x = align.split('')[1];
        var y = align.split('')[0];

        points.x = this._xyConverter(x, points, 'width');
        points.y = this._xyConverter(y, points, 'height');

        return points;
    };

    Position.prototype._xyConverter = function _xyConverter(align, points, type) {
        var res = align.replace(/t|l/gi, '0%').replace(/c/gi, '50%').replace(/b|r/gi, '100%').replace(/(\d+)%/gi, function (m, d) {
            return points.size()[type] * (d / 100);
        });

        return parseFloat(res, 10) || 0;
    };

    Position.prototype._getLeftTop = function _getLeftTop(element) {
        return {
            left: parseFloat(_util.dom.getStyle(element, 'left')) || 0,
            top: parseFloat(_util.dom.getStyle(element, 'top')) || 0
        };
    };

    Position.prototype._normalizeElement = function _normalizeElement(element, isPinFixed) {
        var _this = this;

        var result = {
            element: element,
            x: 0,
            y: 0
        },
            isViewport = element === VIEWPORT,
            docElement = document.documentElement;

        result.offset = function () {
            if (isPinFixed) {
                return {
                    left: 0,
                    top: 0
                };
            } else if (isViewport) {
                return {
                    left: getPageX(),
                    top: getPageY()
                };
            } else {
                return _this._getElementOffset(element);
            }
        };

        result.size = function () {
            if (isViewport) {
                return {
                    width: docElement.clientWidth,
                    height: docElement.clientHeight
                };
            } else {
                return {
                    width: element.offsetWidth,
                    height: element.offsetHeight
                };
            }
        };

        return result;
    };

    Position.prototype._getElementOffset = function _getElementOffset(element) {
        var rect = element.getBoundingClientRect();
        var docElement = document.documentElement;
        var body = document.body;
        var docClientLeft = docElement.clientLeft || body.clientLeft || 0;
        var docClientTop = docElement.clientTop || body.clientTop || 0;

        return {
            left: rect.left + (getPageX() - docClientLeft),
            top: rect.top + (getPageY() - docClientTop)
        };
    };

    // According to the location of the overflow to calculate the desired positioning


    Position.prototype._getExpectedAlign = function _getExpectedAlign() {
        var align = this.isRtl ? this._replaceAlignDir(this.align, /l|r/g, { l: 'r', r: 'l' }) : this.align;
        var expectedAlign = [align];

        if (this.needAdjust) {
            if (/t|b/g.test(align)) {
                expectedAlign.push(this._replaceAlignDir(align, /t|b/g, { t: 'b', b: 't' }));
            }
            if (/l|r/g.test(align)) {
                expectedAlign.push(this._replaceAlignDir(align, /l|r/g, { l: 'r', r: 'l' }));
            }
            if (/c/g.test(align)) {
                expectedAlign.push(this._replaceAlignDir(align, /c(?= |$)/g, { c: 'l' }));
                expectedAlign.push(this._replaceAlignDir(align, /c(?= |$)/g, { c: 'r' }));
            }
            expectedAlign.push(this._replaceAlignDir(align, /l|r|t|b/g, { l: 'r', r: 'l', t: 'b', b: 't' }));
        }
        return expectedAlign;
    };

    // Transform align order.


    Position.prototype._replaceAlignDir = function _replaceAlignDir(align, regExp, map) {
        return align.replace(regExp, function (res) {
            return map[res];
        });
    };

    // Detecting element is in the window， we want to adjust position later.


    Position.prototype._isInViewport = function _isInViewport(element) {
        var viewportSize = _getViewportSize();
        // Avoid animate problem that use offsetWidth instead of getBoundingClientRect.
        var elementRect = _getElementRect(element);
        return elementRect.left >= 0 && elementRect.left + element.offsetWidth <= viewportSize.width && elementRect.top >= 0 && elementRect.top + element.offsetHeight <= viewportSize.height;
    };
    // 在这里做RTL判断 top-left 定位转化为等效的 top-right定位


    Position.prototype._setPinElementPostion = function _setPinElementPostion(pinElement, postion) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];
        var top = postion.top,
            left = postion.left;

        if (!this.isRtl) {
            _util.dom.setStyle(pinElement, {
                left: left + offset[0] + 'px',
                top: top + offset[1] + 'px'
            });
            return;
        }

        // transfer {left,top} equaly to {right,top}
        var pinElementParentOffset = this._getParentOffset(pinElement);

        var _getElementRect2 = _getElementRect(pinElementParentOffset.offsetParent),
            offsetParentWidth = _getElementRect2.width;

        var _getElementRect3 = _getElementRect(pinElement),
            width = _getElementRect3.width;

        var right = offsetParentWidth - (left + width);
        _util.dom.setStyle(pinElement, {
            left: 'auto',
            right: right + offset[0] + 'px',
            top: top + offset[1] + 'px'
        });
    };

    return Position;
}(), _class.VIEWPORT = VIEWPORT, _class.place = function (props) {
    return new Position(props).setPosition();
}, _temp);
exports.default = Position;
module.exports = exports['default'];

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

var _overlay = __webpack_require__(45);

var _overlay2 = _interopRequireDefault(_overlay);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = _util.func.noop,
    makeChain = _util.func.makeChain,
    bindCtx = _util.func.bindCtx;

/**
 * Overlay.Popup
 * @description 继承 Overlay 的 API，除非特别说明
 * */

var Popup = (_temp = _class = function (_Component) {
    _inherits(Popup, _Component);

    function Popup(props) {
        _classCallCheck(this, Popup);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        _this.state = {
            visible: typeof props.visible === 'undefined' ? props.defaultVisible : props.visible
        };

        bindCtx(_this, ['handleTriggerClick', 'handleTriggerKeyDown', 'handleTriggerMouseEnter', 'handleTriggerMouseLeave', 'handleTriggerFocus', 'handleTriggerBlur', 'handleContentMouseEnter', 'handleContentMouseLeave', 'handleContentMouseDown', 'handleRequestClose', 'handleMaskMouseEnter', 'handleMaskMouseLeave']);
        return _this;
    }

    Popup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if ('visible' in nextProps) {
            this.setState({
                visible: nextProps.visible
            });
        }
    };

    Popup.prototype.componentWillUnmount = function componentWillUnmount() {
        var _this2 = this;

        ['_timer', '_hideTimer', '_showTimer'].forEach(function (time) {
            _this2[time] && clearTimeout(_this2[time]);
        });
    };

    Popup.prototype.handleVisibleChange = function handleVisibleChange(visible, type, e) {
        if (!('visible' in this.props)) {
            this.setState({
                visible: visible
            });
        }

        this.props.onVisibleChange(visible, type, e);
    };

    Popup.prototype.handleTriggerClick = function handleTriggerClick(e) {
        if (this.state.visible && !this.props.canCloseByTrigger) {
            return;
        }

        this.handleVisibleChange(!this.state.visible, 'fromTrigger', e);
    };

    Popup.prototype.handleTriggerKeyDown = function handleTriggerKeyDown(e) {
        if (e.keyCode === _util.KEYCODE.SPACE || e.keyCode === _util.KEYCODE.ENTER) {
            e.preventDefault();
            this.handleTriggerClick(e);
        }
    };

    Popup.prototype.handleTriggerMouseEnter = function handleTriggerMouseEnter(e) {
        var _this3 = this;

        this._mouseNotFirstOnMask = false;

        if (this._hideTimer) {
            clearTimeout(this._hideTimer);
            this._hideTimer = null;
        }
        if (this._showTimer) {
            clearTimeout(this._showTimer);
            this._showTimer = null;
        }
        if (!this.state.visible) {
            this._showTimer = setTimeout(function () {
                _this3.handleVisibleChange(true, 'fromTrigger', e);
            }, this.props.delay);
        }
    };

    Popup.prototype.handleTriggerMouseLeave = function handleTriggerMouseLeave(e, type) {
        var _this4 = this;

        if (this._showTimer) {
            clearTimeout(this._showTimer);
            this._showTimer = null;
        }
        if (this.state.visible) {
            this._hideTimer = setTimeout(function () {
                _this4.handleVisibleChange(false, type || 'fromTrigger', e);
            }, this.props.delay);
        }
    };

    Popup.prototype.handleTriggerFocus = function handleTriggerFocus(e) {
        this.handleVisibleChange(true, 'fromTrigger', e);
    };

    Popup.prototype.handleTriggerBlur = function handleTriggerBlur(e) {
        if (!this._isForwardContent) {
            this.handleVisibleChange(false, 'fromTrigger', e);
        }
        this._isForwardContent = false;
    };

    Popup.prototype.handleContentMouseDown = function handleContentMouseDown() {
        this._isForwardContent = true;
    };

    Popup.prototype.handleContentMouseEnter = function handleContentMouseEnter() {
        clearTimeout(this._hideTimer);
    };

    Popup.prototype.handleContentMouseLeave = function handleContentMouseLeave(e) {
        this.handleTriggerMouseLeave(e, 'fromContent');
    };

    Popup.prototype.handleMaskMouseEnter = function handleMaskMouseEnter() {
        if (!this._mouseNotFirstOnMask) {
            clearTimeout(this._hideTimer);
            this._hideTimer = null;
            this._mouseNotFirstOnMask = false;
        }
    };

    Popup.prototype.handleMaskMouseLeave = function handleMaskMouseLeave() {
        this._mouseNotFirstOnMask = true;
    };

    Popup.prototype.handleRequestClose = function handleRequestClose(type, e) {
        this.handleVisibleChange(false, type, e);
    };

    Popup.prototype.renderTrigger = function renderTrigger() {
        var _this5 = this;

        var _props = this.props,
            trigger = _props.trigger,
            disabled = _props.disabled;

        var props = {
            key: 'trigger',
            'aria-haspopup': true,
            'aria-expanded': this.state.visible
        };

        if (!disabled) {
            var triggerType = this.props.triggerType;

            var triggerTypes = Array.isArray(triggerType) ? triggerType : [triggerType];
            var _trigger$props = trigger.props,
                onClick = _trigger$props.onClick,
                onKeyDown = _trigger$props.onKeyDown,
                onMouseEnter = _trigger$props.onMouseEnter,
                onMouseLeave = _trigger$props.onMouseLeave,
                onFocus = _trigger$props.onFocus,
                onBlur = _trigger$props.onBlur;

            triggerTypes.forEach(function (triggerType) {
                switch (triggerType) {
                    case 'click':
                        props.onClick = makeChain(_this5.handleTriggerClick, onClick);
                        props.onKeyDown = makeChain(_this5.handleTriggerKeyDown, onKeyDown);
                        break;
                    case 'hover':
                        props.onMouseEnter = makeChain(_this5.handleTriggerMouseEnter, onMouseEnter);
                        props.onMouseLeave = makeChain(_this5.handleTriggerMouseLeave, onMouseLeave);
                        break;
                    case 'focus':
                        props.onFocus = makeChain(_this5.handleTriggerFocus, onFocus);
                        props.onBlur = makeChain(_this5.handleTriggerBlur, onBlur);
                        break;
                    default:
                        break;
                }
            });
        }

        return _react2.default.cloneElement(trigger, props);
    };

    Popup.prototype.renderContent = function renderContent() {
        var _this6 = this;

        var _props2 = this.props,
            children = _props2.children,
            triggerType = _props2.triggerType;

        var triggerTypes = Array.isArray(triggerType) ? triggerType : [triggerType];
        var content = _react.Children.only(children);
        var _content$props = content.props,
            onMouseDown = _content$props.onMouseDown,
            onMouseEnter = _content$props.onMouseEnter,
            onMouseLeave = _content$props.onMouseLeave;

        var props = {
            key: 'portal'
        };

        triggerTypes.forEach(function (triggerType) {
            switch (triggerType) {
                case 'focus':
                    props.onMouseDown = makeChain(_this6.handleContentMouseDown, onMouseDown);
                    break;
                case 'hover':
                    props.onMouseEnter = makeChain(_this6.handleContentMouseEnter, onMouseEnter);
                    props.onMouseLeave = makeChain(_this6.handleContentMouseLeave, onMouseLeave);
                    break;
                default:
                    break;
            }
        });

        return _react2.default.cloneElement(content, props);
    };

    Popup.prototype.renderPortal = function renderPortal() {
        var _this7 = this;

        var _props3 = this.props,
            target = _props3.target,
            safeNode = _props3.safeNode,
            followTrigger = _props3.followTrigger,
            triggerType = _props3.triggerType,
            hasMask = _props3.hasMask,
            wrapperStyle = _props3.wrapperStyle,
            others = _objectWithoutProperties(_props3, ['target', 'safeNode', 'followTrigger', 'triggerType', 'hasMask', 'wrapperStyle']);

        var container = this.props.container;

        var findTriggerNode = function findTriggerNode() {
            return (0, _reactDom.findDOMNode)(_this7) || {};
        };
        var safeNodes = Array.isArray(safeNode) ? [].concat(safeNode) : [safeNode];
        safeNodes.unshift(findTriggerNode);

        var newWrapperStyle = wrapperStyle || {};

        if (followTrigger) {
            container = function container(trigger) {
                return trigger.parentNode;
            };
            newWrapperStyle.position = 'relative';
        }

        if (triggerType === 'hover' && hasMask) {
            others.onMaskMouseEnter = this.handleMaskMouseEnter;
            others.onMaskMouseLeave = this.handleMaskMouseLeave;
        }

        return _react2.default.createElement(
            _overlay2.default,
            _extends({}, others, {
                key: 'overlay',
                ref: function ref(overlay) {
                    return _this7.overlay = overlay;
                },
                visible: this.state.visible,
                target: target || findTriggerNode,
                container: container,
                safeNode: safeNodes,
                wrapperStyle: newWrapperStyle,
                triggerType: triggerType,
                hasMask: hasMask,
                onRequestClose: this.handleRequestClose }),
            this.renderContent()
        );
    };

    Popup.prototype.render = function render() {
        return [this.renderTrigger(), this.renderPortal()];
    };

    return Popup;
}(_react.Component), _class.propTypes = {
    /**
     * 弹层内容
     */
    children: _propTypes2.default.node,
    /**
     * 触发弹层显示或隐藏的元素
     */
    trigger: _propTypes2.default.element,
    /**
     * 触发弹层显示或隐藏的操作类型，可以是 'click'，'hover'，'focus'，或者它们组成的数组，如 ['hover', 'focus']
     */
    triggerType: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),
    /**
     * 弹层当前是否显示
     */
    visible: _propTypes2.default.bool,
    /**
     * 弹层默认是否显示
     */
    defaultVisible: _propTypes2.default.bool,
    /**
     * 弹层显示或隐藏时触发的回调函数
     * @param {Boolean} visible 弹层是否显示
     * @param {String} type 触发弹层显示或隐藏的来源
     * @param {Object} e DOM事件
     */
    onVisibleChange: _propTypes2.default.func,
    /**
     * 设置此属性，弹层无法显示或隐藏
     */
    disabled: _propTypes2.default.bool,
    /**
     * 弹层显示或隐藏的延时时间（以毫秒为单位），在 triggerType 被设置为 hover 时生效
     */
    delay: _propTypes2.default.number,
    /**
     * 触发元素是否可以关闭弹层
     */
    canCloseByTrigger: _propTypes2.default.bool,
    /**
     * 弹层定位的参照元素
     * @default target 属性，即触发元素
     */
    target: _propTypes2.default.any,
    safeNode: _propTypes2.default.any,
    /**
     * 是否跟随trigger滚动
     */
    followTrigger: _propTypes2.default.bool,
    container: _propTypes2.default.any,
    hasMask: _propTypes2.default.bool,
    wrapperStyle: _propTypes2.default.object,
    rtl: _propTypes2.default.bool
}, _class.defaultProps = {
    triggerType: 'hover',
    defaultVisible: false,
    onVisibleChange: noop,
    disabled: false,
    delay: 200,
    canCloseByTrigger: true,
    followTrigger: false,
    container: function container() {
        return document.body;
    },
    rtl: false
}, _temp);
Popup.displayName = 'Popup';
exports.default = Popup;
module.exports = exports['default'];

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _overlay = __webpack_require__(15);

var _overlay2 = _interopRequireDefault(_overlay);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = _util.func.noop,
    makeChain = _util.func.makeChain,
    bindCtx = _util.func.bindCtx;

var Popup = _overlay2.default.Popup;

/**
 * Dropdown
 * @description 继承 Popup 的 API，除非特别说明
 */
var Dropdown = (_temp = _class = function (_Component) {
  _inherits(Dropdown, _Component);

  function Dropdown(props) {
    _classCallCheck(this, Dropdown);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.state = {
      visible: 'visible' in props ? props.visible : props.defaultVisible || false
    };

    bindCtx(_this, ['onMenuClick', 'onVisibleChange']);
    return _this;
  }

  Dropdown.prototype.getVisible = function getVisible() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;

    return 'visible' in props ? props.visible : this.state.visible;
  };

  Dropdown.prototype.onMenuClick = function onMenuClick() {
    this.onVisibleChange(false, 'fromContent');
  };

  Dropdown.prototype.onVisibleChange = function onVisibleChange(visible, from) {
    this.setState({ visible: visible });

    this.props.onVisibleChange(visible, from);
  };

  Dropdown.prototype.render = function render() {
    var child = _react.Children.only(this.props.children);
    if (typeof child.type === 'function' && child.type.isNextMenu) {
      child = _react2.default.cloneElement(child, {
        onItemClick: makeChain(this.onMenuClick, child.props.onItemClick)
      });
    }

    return _react2.default.createElement(
      Popup,
      _extends({}, this.props, {
        visible: this.getVisible(),
        onVisibleChange: this.onVisibleChange,
        canCloseByOutSideClick: true }),
      child
    );
  };

  return Dropdown;
}(_react.Component), _class.propTypes = {
  prefix: _propTypes2.default.string,
  pure: _propTypes2.default.bool,
  className: _propTypes2.default.string,
  /**
   * 弹层内容
   */
  children: _propTypes2.default.node,
  /**
   * 弹层当前是否显示
   */
  visible: _propTypes2.default.bool,
  /**
   * 弹层默认是否显示
   */
  defaultVisible: _propTypes2.default.bool,
  /**
   * 弹层显示或隐藏时触发的回调函数
   * @param {Boolean} visible 弹层是否显示
   * @param {String} type 触发弹层显示或隐藏的来源
   * @param {Object} e DOM事件
   */
  onVisibleChange: _propTypes2.default.func,
  /**
   * 触发弹层显示或者隐藏的元素
   */
  trigger: _propTypes2.default.node,
  /**
   * 触发弹层显示或隐藏的操作类型
   */
  triggerType: _propTypes2.default.oneOf(['hover', 'click', 'focus']),
  /**
   * 设置此属性，弹层无法显示或隐藏
   */
  disabled: _propTypes2.default.bool,
  /**
   * 弹层相对于触发元素的定位, 详见 Overlay 的定位部分
   */
  align: _propTypes2.default.string,
  /**
   * 弹层相对于触发元素定位的微调
   */
  offset: _propTypes2.default.array,
  /**
   * 弹层显示或隐藏的延时时间（以毫秒为单位），在 triggerType 被设置为 hover 时生效
   */
  delay: _propTypes2.default.number,
  /**
   * 弹层打开时是否让其中的元素自动获取焦点
   */
  autoFocus: _propTypes2.default.bool,
  /**
   * 是否显示遮罩
   */
  hasMask: _propTypes2.default.bool,
  /**
   * 隐藏时是否保留子节点
   */
  cache: _propTypes2.default.bool,
  /**
   * 配置动画的播放方式，支持 { in: 'enter-class', out: 'leave-class' } 的对象参数，如果设置为 false，则不播放动画
   * @default { in: 'expandInDown', out: 'expandOutUp' }
   */
  animation: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.bool])
}, _class.defaultProps = {
  prefix: 'next-',
  pure: false,
  defaultVisible: false,
  onVisibleChange: noop,
  triggerType: 'hover',
  disabled: false,
  align: 'tl bl',
  offset: [0, 0],
  delay: 200,
  autoFocus: true,
  hasMask: false,
  cache: false,
  onPosition: noop
}, _temp);
Dropdown.displayName = 'Dropdown';
exports.default = _configProvider2.default.config(Dropdown);
module.exports = exports['default'];

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _animate = __webpack_require__(74);

var _animate2 = _interopRequireDefault(_animate);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

var _item = __webpack_require__(14);

var _item2 = _interopRequireDefault(_item);

var _selectableItem = __webpack_require__(22);

var _selectableItem2 = _interopRequireDefault(_selectableItem);

var _popupItem = __webpack_require__(57);

var _popupItem2 = _interopRequireDefault(_popupItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var Expand = _animate2.default.Expand;
var bindCtx = _util.func.bindCtx;

/**
 * Menu.SubMenu
 * @order 1
 */

var SubMenu = (_temp = _class = function (_Component) {
    _inherits(SubMenu, _Component);

    function SubMenu(props) {
        _classCallCheck(this, SubMenu);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        bindCtx(_this, ['handleMouseEnter', 'handleMouseLeave', 'handleClick', 'handleOpen', 'afterLeave']);
        return _this;
    }

    SubMenu.prototype.componentDidMount = function componentDidMount() {
        this.itemNode = (0, _reactDom.findDOMNode)(this);
    };

    SubMenu.prototype.afterLeave = function afterLeave() {
        var _props = this.props,
            focused = _props.focused,
            root = _props.root;
        var focusable = root.props.focusable;

        if (focusable && focused) {
            this.itemNode.focus();
        }
    };

    SubMenu.prototype.getOpen = function getOpen() {
        var _props2 = this.props,
            _key = _props2._key,
            root = _props2.root;
        var openKeys = root.state.openKeys;


        return openKeys.indexOf(_key) > -1;
    };

    SubMenu.prototype.handleMouseEnter = function handleMouseEnter(e) {
        this.handleOpen(true);

        this.props.onMouseEnter && this.props.onMouseEnter(e);
    };

    SubMenu.prototype.handleMouseLeave = function handleMouseLeave(e) {
        this.handleOpen(false);

        this.props.onMouseLeave && this.props.onMouseLeave(e);
    };

    SubMenu.prototype.handleClick = function handleClick(e) {
        var _props3 = this.props,
            root = _props3.root,
            selectable = _props3.selectable;
        var selectMode = root.props.selectMode;

        if (selectMode && selectable) {
            e.stopPropagation();
        }

        var open = this.getOpen();
        this.handleOpen(!open);
    };

    SubMenu.prototype.handleOpen = function handleOpen(open, triggerType, e) {
        var _props4 = this.props,
            _key = _props4._key,
            root = _props4.root;

        root.handleOpen(_key, open, triggerType, e);
    };

    SubMenu.prototype.passParentToChildren = function passParentToChildren(children) {
        var _this2 = this;

        var _props5 = this.props,
            mode = _props5.mode,
            root = _props5.root;


        return _react.Children.map(children, function (child) {
            return (0, _react.cloneElement)(child, {
                parent: _this2,
                parentMode: mode || root.props.mode
            });
        });
    };

    SubMenu.prototype.renderInline = function renderInline() {
        var _cx, _cx2, _cx3;

        var _props6 = this.props,
            _key = _props6._key,
            level = _props6.level,
            root = _props6.root,
            className = _props6.className,
            selectableFromProps = _props6.selectable,
            label = _props6.label,
            children = _props6.children,
            subMenuContentClassName = _props6.subMenuContentClassName,
            propsTriggerType = _props6.triggerType,
            parentMode = _props6.parentMode;
        var _root$props = root.props,
            prefix = _root$props.prefix,
            selectMode = _root$props.selectMode,
            rootTriggerType = _root$props.triggerType,
            inlineArrowDirection = _root$props.inlineArrowDirection,
            expandAnimation = _root$props.expandAnimation,
            rtl = _root$props.rtl;

        var triggerType = propsTriggerType || rootTriggerType;
        var open = this.getOpen();
        var others = _util.obj.pickOthers(Object.keys(SubMenu.propTypes), this.props);

        var liProps = {
            className: (0, _classnames2.default)((_cx = {}, _cx[prefix + 'menu-sub-menu-wrapper'] = true, _cx[className] = !!className, _cx))
        };
        var itemProps = {
            'aria-expanded': open,
            _key: _key,
            level: level,
            root: root,
            type: 'submenu',
            component: 'div',
            parentMode: parentMode
        };
        var arrorProps = {
            type: inlineArrowDirection === 'right' ? 'arrow-right' : 'arrow-down',
            className: (0, _classnames2.default)((_cx2 = {}, _cx2[prefix + 'menu-icon-arrow'] = true, _cx2[prefix + 'menu-icon-arrow-down'] = inlineArrowDirection === 'down', _cx2[prefix + 'menu-icon-arrow-right'] = inlineArrowDirection === 'right', _cx2[prefix + 'open'] = open, _cx2))
        };

        var selectable = !!selectMode && selectableFromProps;
        var NewItem = selectable ? _selectableItem2.default : _item2.default;

        if (triggerType === 'hover') {
            liProps.onMouseEnter = this.handleMouseEnter;
            liProps.onMouseLeave = this.handleMouseLeave;
        } else if (selectable) {
            arrorProps.onClick = this.handleClick;
        } else {
            itemProps.onClick = this.handleClick;
        }
        if (open) {
            itemProps.className = prefix + 'opened';
        }

        var newSubMenuContentClassName = (0, _classnames2.default)((_cx3 = {}, _cx3[prefix + 'menu-sub-menu'] = true, _cx3[subMenuContentClassName] = !!subMenuContentClassName, _cx3));

        var subMenu = open ? _react2.default.createElement(
            'ul',
            { role: 'menu', dir: rtl ? 'rtl' : undefined, ref: 'subMenu', className: newSubMenuContentClassName },
            this.passParentToChildren(children)
        ) : null;

        return _react2.default.createElement(
            'li',
            _extends({}, others, liProps),
            _react2.default.createElement(
                NewItem,
                itemProps,
                _react2.default.createElement(
                    'span',
                    { className: prefix + 'menu-item-text' },
                    label
                ),
                _react2.default.createElement(_icon2.default, arrorProps)
            ),
            expandAnimation ? _react2.default.createElement(
                Expand,
                { animationAppear: false, afterLeave: this.afterLeave },
                subMenu
            ) : subMenu
        );
    };

    SubMenu.prototype.renderPopup = function renderPopup() {
        var _cx4;

        var _props7 = this.props,
            children = _props7.children,
            subMenuContentClassName = _props7.subMenuContentClassName,
            others = _objectWithoutProperties(_props7, ['children', 'subMenuContentClassName']);

        var root = this.props.root;
        var _root$props2 = root.props,
            prefix = _root$props2.prefix,
            popupClassName = _root$props2.popupClassName,
            popupStyle = _root$props2.popupStyle,
            rtl = _root$props2.rtl;


        var newClassName = (0, _classnames2.default)((_cx4 = {}, _cx4[prefix + 'menu'] = true, _cx4[prefix + 'ver'] = true, _cx4[popupClassName] = !!popupClassName, _cx4[subMenuContentClassName] = !!subMenuContentClassName, _cx4));

        others.rtl = rtl;

        return _react2.default.createElement(
            _popupItem2.default,
            _extends({}, others, { hasSubMenu: true }),
            _react2.default.createElement(
                'ul',
                { role: 'menu', dir: rtl ? 'rtl' : undefined, className: newClassName, style: popupStyle },
                this.passParentToChildren(children)
            )
        );
    };

    SubMenu.prototype.render = function render() {
        var _props8 = this.props,
            mode = _props8.mode,
            root = _props8.root;

        var newMode = mode || root.props.mode;

        return newMode === 'popup' ? this.renderPopup() : this.renderInline();
    };

    return SubMenu;
}(_react.Component), _class.menuChildType = 'submenu', _class.propTypes = {
    _key: _propTypes2.default.string,
    root: _propTypes2.default.object,
    level: _propTypes2.default.number,
    groupIndent: _propTypes2.default.number,
    /**
     * 标签内容
     */
    label: _propTypes2.default.node,
    /**
     * 是否可选，该属性仅在设置 Menu 组件 selectMode 属性后生效
     */
    selectable: _propTypes2.default.bool,
    /**
     * 子菜单打开方式，如果设置会覆盖 Menu 上的同名属性
     * @default Menu 的 mode 属性值
     */
    mode: _propTypes2.default.oneOf(['inline', 'popup']),
    /**
     * 菜单项或下一级子菜单
     */
    children: _propTypes2.default.node,
    onMouseEnter: _propTypes2.default.func,
    onMouseLeave: _propTypes2.default.func,
    subMenuContentClassName: _propTypes2.default.string,
    triggerType: _propTypes2.default.oneOf(['click', 'hover']),
    align: _propTypes2.default.oneOf(['outside', 'follow']),
    parentMode: _propTypes2.default.oneOf(['inline', 'popup'])
}, _class.defaultProps = {
    groupIndent: 0,
    selectable: false
}, _temp);
SubMenu.displayName = 'SubMenu';
exports.default = SubMenu;
module.exports = exports['default'];

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

exports.__esModule = true;
exports.default = void 0;

var PropTypes = _interopRequireWildcard(__webpack_require__(1));

var _addClass = _interopRequireDefault(__webpack_require__(103));

var _removeClass = _interopRequireDefault(__webpack_require__(106));

var _react = _interopRequireDefault(__webpack_require__(0));

var _Transition = _interopRequireDefault(__webpack_require__(53));

var _PropTypes = __webpack_require__(55);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }newObj.default = obj;return newObj;
  }
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;
  _defaults(subClass, superClass);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var addClass = function addClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return (0, _addClass.default)(node, c);
  });
};

var removeClass = function removeClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return (0, _removeClass.default)(node, c);
  });
};

var propTypes = process.env.NODE_ENV !== "production" ? _extends({}, _Transition.default.propTypes, {
  /**
   * The animation classNames applied to the component as it enters, exits or has finished the transition.
   * A single name can be provided and it will be suffixed for each stage: e.g.
   *
   * `classNames="fade"` applies `fade-enter`, `fade-enter-active`, `fade-enter-done`,
   * `fade-exit`, `fade-exit-active`, `fade-exit-done`, `fade-appear`, and `fade-appear-active`.
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply spread
   * them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */
  classNames: _PropTypes.classNamesShape,

  /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEnter: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntered: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * @type Function(node: HtmlElement)
   */
  onExit: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * @type Function(node: HtmlElement)
   */
  onExiting: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * @type Function(node: HtmlElement)
   */
  onExited: PropTypes.func
}) : {};;
/**
 * A `Transition` component using CSS transitions and animations.
 * It's inspired by the excellent [ng-animate](http://www.nganimate.org/) library.
 *
 * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
 * and `exit` stages of the transition. The first class is applied and then a
 * second "active" class in order to activate the css animation. After the animation,
 * matching `done` class names are applied to persist the animation state.
 *
 * When the `in` prop is toggled to `true` the Component will get
 * the `example-enter` CSS class and the `example-enter-active` CSS class
 * added in the next tick. This is a convention based on the `classNames` prop.
 */

var CSSTransition =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(CSSTransition, _React$Component);

  function CSSTransition() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

    _this.onEnter = function (node, appearing) {
      var _this$getClassNames = _this.getClassNames(appearing ? 'appear' : 'enter'),
          className = _this$getClassNames.className;

      _this.removeClasses(node, 'exit');

      addClass(node, className);

      if (_this.props.onEnter) {
        _this.props.onEnter(node, appearing);
      }
    };

    _this.onEntering = function (node, appearing) {
      var _this$getClassNames2 = _this.getClassNames(appearing ? 'appear' : 'enter'),
          activeClassName = _this$getClassNames2.activeClassName;

      _this.reflowAndAddClass(node, activeClassName);

      if (_this.props.onEntering) {
        _this.props.onEntering(node, appearing);
      }
    };

    _this.onEntered = function (node, appearing) {
      var _this$getClassNames3 = _this.getClassNames('enter'),
          doneClassName = _this$getClassNames3.doneClassName;

      _this.removeClasses(node, appearing ? 'appear' : 'enter');

      addClass(node, doneClassName);

      if (_this.props.onEntered) {
        _this.props.onEntered(node, appearing);
      }
    };

    _this.onExit = function (node) {
      var _this$getClassNames4 = _this.getClassNames('exit'),
          className = _this$getClassNames4.className;

      _this.removeClasses(node, 'appear');

      _this.removeClasses(node, 'enter');

      addClass(node, className);

      if (_this.props.onExit) {
        _this.props.onExit(node);
      }
    };

    _this.onExiting = function (node) {
      var _this$getClassNames5 = _this.getClassNames('exit'),
          activeClassName = _this$getClassNames5.activeClassName;

      _this.reflowAndAddClass(node, activeClassName);

      if (_this.props.onExiting) {
        _this.props.onExiting(node);
      }
    };

    _this.onExited = function (node) {
      var _this$getClassNames6 = _this.getClassNames('exit'),
          doneClassName = _this$getClassNames6.doneClassName;

      _this.removeClasses(node, 'exit');

      addClass(node, doneClassName);

      if (_this.props.onExited) {
        _this.props.onExited(node);
      }
    };

    _this.getClassNames = function (type) {
      var classNames = _this.props.classNames;
      var className = typeof classNames !== 'string' ? classNames[type] : classNames + '-' + type;
      var activeClassName = typeof classNames !== 'string' ? classNames[type + 'Active'] : className + '-active';
      var doneClassName = typeof classNames !== 'string' ? classNames[type + 'Done'] : className + '-done';
      return {
        className: className,
        activeClassName: activeClassName,
        doneClassName: doneClassName
      };
    };

    return _this;
  }

  var _proto = CSSTransition.prototype;

  _proto.removeClasses = function removeClasses(node, type) {
    var _this$getClassNames7 = this.getClassNames(type),
        className = _this$getClassNames7.className,
        activeClassName = _this$getClassNames7.activeClassName,
        doneClassName = _this$getClassNames7.doneClassName;

    className && removeClass(node, className);
    activeClassName && removeClass(node, activeClassName);
    doneClassName && removeClass(node, doneClassName);
  };

  _proto.reflowAndAddClass = function reflowAndAddClass(node, className) {
    // This is for to force a repaint,
    // which is necessary in order to transition styles when adding a class name.
    if (className) {
      /* eslint-disable no-unused-expressions */
      node && node.scrollTop;
      /* eslint-enable no-unused-expressions */

      addClass(node, className);
    }
  };

  _proto.render = function render() {
    var props = _extends({}, this.props);

    delete props.classNames;
    return _react.default.createElement(_Transition.default, _extends({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };

  return CSSTransition;
}(_react.default.Component);

CSSTransition.propTypes = process.env.NODE_ENV !== "production" ? propTypes : {};
var _default = CSSTransition;
exports.default = _default;
module.exports = exports["default"];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(104);

exports.__esModule = true;
exports.default = addClass;

var _hasClass = _interopRequireDefault(__webpack_require__(105));

function addClass(element, className) {
  if (element.classList) element.classList.add(className);else if (!(0, _hasClass.default)(element, className)) if (typeof element.className === 'string') element.className = element.className + ' ' + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + ' ' + className);
}

module.exports = exports["default"];

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = hasClass;

function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);else return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}

module.exports = exports["default"];

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp('(^|\\s)' + classToRemove + '(?:\\s|$)', 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
}

module.exports = function removeClass(element, className) {
  if (element.classList) element.classList.remove(className);else if (typeof element.className === 'string') element.className = replaceClassName(element.className, className);else element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

exports.__esModule = true;
exports.default = void 0;

var _propTypes = _interopRequireDefault(__webpack_require__(1));

var _react = _interopRequireDefault(__webpack_require__(0));

var _reactDom = __webpack_require__(4);

var _TransitionGroup = _interopRequireDefault(__webpack_require__(56));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];
  }return target;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;
  _defaults(subClass, superClass);
}

var propTypes = process.env.NODE_ENV !== "production" ? {
  in: _propTypes.default.bool.isRequired,
  children: function children(props, propName) {
    if (_react.default.Children.count(props[propName]) !== 2) return new Error("\"" + propName + "\" must be exactly two transition components.");
    return null;
  }
} : {};;
/**
 * The `<ReplaceTransition>` component is a specialized `Transition` component
 * that animates between two children.
 *
 * ```jsx
 * <ReplaceTransition in>
 *   <Fade><div>I appear first</div></Fade>
 *   <Fade><div>I replace the above</div></Fade>
 * </ReplaceTransition>
 * ```
 */

var ReplaceTransition =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(ReplaceTransition, _React$Component);

  function ReplaceTransition() {
    var _this;

    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;

    _this.handleEnter = function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return _this.handleLifecycle('onEnter', 0, args);
    };

    _this.handleEntering = function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return _this.handleLifecycle('onEntering', 0, args);
    };

    _this.handleEntered = function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return _this.handleLifecycle('onEntered', 0, args);
    };

    _this.handleExit = function () {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      return _this.handleLifecycle('onExit', 1, args);
    };

    _this.handleExiting = function () {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      return _this.handleLifecycle('onExiting', 1, args);
    };

    _this.handleExited = function () {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      return _this.handleLifecycle('onExited', 1, args);
    };

    return _this;
  }

  var _proto = ReplaceTransition.prototype;

  _proto.handleLifecycle = function handleLifecycle(handler, idx, originalArgs) {
    var _child$props;

    var children = this.props.children;

    var child = _react.default.Children.toArray(children)[idx];

    if (child.props[handler]) (_child$props = child.props)[handler].apply(_child$props, originalArgs);
    if (this.props[handler]) this.props[handler]((0, _reactDom.findDOMNode)(this));
  };

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        inProp = _this$props.in,
        props = _objectWithoutPropertiesLoose(_this$props, ["children", "in"]);

    var _React$Children$toArr = _react.default.Children.toArray(children),
        first = _React$Children$toArr[0],
        second = _React$Children$toArr[1];

    delete props.onEnter;
    delete props.onEntering;
    delete props.onEntered;
    delete props.onExit;
    delete props.onExiting;
    delete props.onExited;
    return _react.default.createElement(_TransitionGroup.default, props, inProp ? _react.default.cloneElement(first, {
      key: 'first',
      onEnter: this.handleEnter,
      onEntering: this.handleEntering,
      onEntered: this.handleEntered
    }) : _react.default.cloneElement(second, {
      key: 'second',
      onEnter: this.handleExit,
      onEntering: this.handleExiting,
      onEntered: this.handleExited
    }));
  };

  return ReplaceTransition;
}(_react.default.Component);

ReplaceTransition.propTypes = process.env.NODE_ENV !== "production" ? propTypes : {};
var _default = ReplaceTransition;
exports.default = _default;
module.exports = exports["default"];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getChildMapping = getChildMapping;
exports.mergeChildMappings = mergeChildMappings;
exports.getInitialChildMapping = getInitialChildMapping;
exports.getNextChildMapping = getNextChildMapping;

var _react = __webpack_require__(0);

/**
 * Given `this.props.children`, return an object mapping key to child.
 *
 * @param {*} children `this.props.children`
 * @return {object} Mapping of key to child
 */
function getChildMapping(children, mapFn) {
  var mapper = function mapper(child) {
    return mapFn && (0, _react.isValidElement)(child) ? mapFn(child) : child;
  };

  var result = Object.create(null);
  if (children) _react.Children.map(children, function (c) {
    return c;
  }).forEach(function (child) {
    // run the map function here instead so that the key is the computed one
    result[child.key] = mapper(child);
  });
  return result;
}
/**
 * When you're adding or removing children some may be added or removed in the
 * same render pass. We want to show *both* since we want to simultaneously
 * animate elements in and out. This function takes a previous set of keys
 * and a new set of keys and merges them with its best guess of the correct
 * ordering. In the future we may expose some of the utilities in
 * ReactMultiChild to make this easy, but for now React itself does not
 * directly have this concept of the union of prevChildren and nextChildren
 * so we implement it here.
 *
 * @param {object} prev prev children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @param {object} next next children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @return {object} a key set that contains all keys in `prev` and all keys
 * in `next` in a reasonable order.
 */

function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};

  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  } // For each key of `next`, the list of keys to insert before that key in
  // the combined list


  var nextKeysPending = Object.create(null);
  var pendingKeys = [];

  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }

  var i;
  var childMapping = {};

  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }

    childMapping[nextKey] = getValueForKey(nextKey);
  } // Finally, add the keys which didn't appear before any key in `next`


  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }

  return childMapping;
}

function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}

function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function (child) {
    return (0, _react.cloneElement)(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, 'appear', props),
      enter: getProp(child, 'enter', props),
      exit: getProp(child, 'exit', props)
    });
  });
}

function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function (key) {
    var child = children[key];
    if (!(0, _react.isValidElement)(child)) return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = (0, _react.isValidElement)(prevChild) && !prevChild.props.in; // item is new (entering)

    if (hasNext && (!hasPrev || isLeaving)) {
      // console.log('entering', key)
      children[key] = (0, _react.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      // item is old (exiting)
      // console.log('leaving', key)
      children[key] = (0, _react.cloneElement)(child, {
        in: false
      });
    } else if (hasNext && hasPrev && (0, _react.isValidElement)(prevChild)) {
      // item hasn't changed transition states
      // copy over the last transition props;
      // console.log('unchanged', key)
      children[key] = (0, _react.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    }
  });
  return children;
}

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactTransitionGroup = __webpack_require__(52);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};
var on = _util.events.on,
    off = _util.events.off;
var addClass = _util.dom.addClass,
    removeClass = _util.dom.removeClass;

var prefixes = ['-webkit-', '-moz-', '-o-', 'ms-', ''];

function getStyleProperty(node, name) {
    var style = window.getComputedStyle(node);
    var ret = '';
    for (var i = 0; i < prefixes.length; i++) {
        ret = style.getPropertyValue(prefixes[i] + name);
        if (ret) {
            break;
        }
    }
    return ret;
}

var AnimateChild = (_temp = _class = function (_Component) {
    _inherits(AnimateChild, _Component);

    function AnimateChild(props) {
        _classCallCheck(this, AnimateChild);

        var _this2 = _possibleConstructorReturn(this, _Component.call(this, props));

        _util.func.bindCtx(_this2, ['handleEnter', 'handleEntering', 'handleEntered', 'handleExit', 'handleExiting', 'handleExited', 'addEndListener']);
        _this2.endListeners = {
            transitionend: [],
            animationend: []
        };
        _this2.timeoutMap = {};
        return _this2;
    }

    AnimateChild.prototype.componentWillUnmount = function componentWillUnmount() {
        var _this3 = this;

        Object.keys(this.endListeners).forEach(function (eventName) {
            _this3.endListeners[eventName].forEach(function (listener) {
                off(_this3.node, eventName, listener);
            });
        });
        this.endListeners = {
            transitionend: [],
            animationend: []
        };
    };

    AnimateChild.prototype.generateEndListener = function generateEndListener(node, done, eventName, id) {
        var _this = this;
        return function endListener(e) {

            if (e && e.target === node) {
                if (_this.timeoutMap[id]) {
                    clearTimeout(_this.timeoutMap[id]);
                    delete _this.timeoutMap[id];
                }

                done();
                off(node, eventName, endListener);
                var listeners = _this.endListeners[eventName];
                var index = listeners.indexOf(endListener);
                index > -1 && listeners.splice(index, 1);
            }
        };
    };

    AnimateChild.prototype.addEndListener = function addEndListener(node, done) {
        var _this4 = this;

        if (_util.support.transition || _util.support.animation) {
            var id = (0, _util.guid)();

            this.node = node;
            if (_util.support.transition) {
                var transitionEndListener = this.generateEndListener(node, done, 'transitionend', id);
                on(node, 'transitionend', transitionEndListener);
                this.endListeners.transitionend.push(transitionEndListener);
            }
            if (_util.support.animation) {
                var animationEndListener = this.generateEndListener(node, done, 'animationend', id);
                on(node, 'animationend', animationEndListener);
                this.endListeners.animationend.push(animationEndListener);
            }

            setTimeout(function () {
                var transitionDelay = parseFloat(getStyleProperty(node, 'transition-delay')) || 0;
                var transitionDuration = parseFloat(getStyleProperty(node, 'transition-duration')) || 0;
                var animationDelay = parseFloat(getStyleProperty(node, 'animation-delay')) || 0;
                var animationDuration = parseFloat(getStyleProperty(node, 'animation-duration')) || 0;
                var time = Math.max(transitionDuration + transitionDelay, animationDuration + animationDelay);
                if (time) {
                    _this4.timeoutMap[id] = setTimeout(function () {
                        done();
                    }, time * 1000 + 200);
                }
            }, 15);
        } else {
            done();
        }
    };

    AnimateChild.prototype.removeEndtListener = function removeEndtListener() {
        this.transitionOff && this.transitionOff();
        this.animationOff && this.animationOff();
    };

    AnimateChild.prototype.removeClassNames = function removeClassNames(node, names) {
        Object.keys(names).forEach(function (key) {
            removeClass(node, names[key]);
        });
    };

    AnimateChild.prototype.handleEnter = function handleEnter(node, isAppearing) {
        var names = this.props.names;

        if (names) {
            this.removeClassNames(node, names);
            var className = isAppearing ? 'appear' : 'enter';
            addClass(node, names[className]);
        }

        var hook = isAppearing ? this.props.onAppear : this.props.onEnter;
        hook(node);
    };

    AnimateChild.prototype.handleEntering = function handleEntering(node, isAppearing) {
        var _this5 = this;

        setTimeout(function () {
            var names = _this5.props.names;

            if (names) {
                var className = isAppearing ? 'appearActive' : 'enterActive';
                addClass(node, names[className]);
            }

            var hook = isAppearing ? _this5.props.onAppearing : _this5.props.onEntering;
            hook(node);
        }, 10);
    };

    AnimateChild.prototype.handleEntered = function handleEntered(node, isAppearing) {
        var names = this.props.names;

        if (names) {
            var classNames = isAppearing ? [names.appear, names.appearActive] : [names.enter, names.enterActive];
            classNames.forEach(function (className) {
                removeClass(node, className);
            });
        }

        var hook = isAppearing ? this.props.onAppeared : this.props.onEntered;
        hook(node);
    };

    AnimateChild.prototype.handleExit = function handleExit(node) {
        var names = this.props.names;

        if (names) {
            this.removeClassNames(node, names);
            addClass(node, names.leave);
        }

        this.props.onExit(node);
    };

    AnimateChild.prototype.handleExiting = function handleExiting(node) {
        var _this6 = this;

        setTimeout(function () {
            var names = _this6.props.names;

            if (names) {
                addClass(node, names.leaveActive);
            }
            _this6.props.onExiting(node);
        }, 10);
    };

    AnimateChild.prototype.handleExited = function handleExited(node) {
        var names = this.props.names;

        if (names) {
            [names.leave, names.leaveActive].forEach(function (className) {
                removeClass(node, className);
            });
        }

        this.props.onExited(node);
    };

    AnimateChild.prototype.render = function render() {
        /* eslint-disable no-unused-vars */
        var _props = this.props,
            names = _props.names,
            onAppear = _props.onAppear,
            onAppeared = _props.onAppeared,
            onAppearing = _props.onAppearing,
            onEnter = _props.onEnter,
            onEntering = _props.onEntering,
            onEntered = _props.onEntered,
            onExit = _props.onExit,
            onExiting = _props.onExiting,
            onExited = _props.onExited,
            others = _objectWithoutProperties(_props, ['names', 'onAppear', 'onAppeared', 'onAppearing', 'onEnter', 'onEntering', 'onEntered', 'onExit', 'onExiting', 'onExited']);
        /* eslint-enable no-unused-vars */

        return _react2.default.createElement(_reactTransitionGroup.Transition, _extends({}, others, {
            onEnter: this.handleEnter,
            onEntering: this.handleEntering,
            onEntered: this.handleEntered,
            onExit: this.handleExit,
            onExiting: this.handleExiting,
            onExited: this.handleExited,
            addEndListener: this.addEndListener }));
    };

    return AnimateChild;
}(_react.Component), _class.propTypes = {
    names: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),
    onAppear: _propTypes2.default.func,
    onAppearing: _propTypes2.default.func,
    onAppeared: _propTypes2.default.func,
    onEnter: _propTypes2.default.func,
    onEntering: _propTypes2.default.func,
    onEntered: _propTypes2.default.func,
    onExit: _propTypes2.default.func,
    onExiting: _propTypes2.default.func,
    onExited: _propTypes2.default.func
}, _class.defaultProps = {
    onAppear: noop,
    onAppearing: noop,
    onAppeared: noop,
    onEnter: noop,
    onEntering: noop,
    onEntered: noop,
    onExit: noop,
    onExiting: noop,
    onExited: noop
}, _temp);
AnimateChild.displayName = 'AnimateChild';
exports.default = AnimateChild;
module.exports = exports['default'];

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

var _animate = __webpack_require__(51);

var _animate2 = _interopRequireDefault(_animate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};
var getStyle = _util.dom.getStyle;
var Expand = (_temp = _class = function (_Component) {
    _inherits(Expand, _Component);

    function Expand(props) {
        _classCallCheck(this, Expand);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        _util.func.bindCtx(_this, ['beforeEnter', 'onEnter', 'afterEnter', 'beforeLeave', 'onLeave', 'afterLeave']);
        return _this;
    }

    Expand.prototype.beforeEnter = function beforeEnter(node) {
        if (this.leaving) {
            this.afterLeave(node);
        }

        this.cacheCurrentStyle(node);
        this.cacheComputedStyle(node);
        this.setCurrentStyleToZero(node);

        this.props.beforeEnter(node);
    };

    Expand.prototype.onEnter = function onEnter(node) {
        this.setCurrentStyleToComputedStyle(node);

        this.props.onEnter(node);
    };

    Expand.prototype.afterEnter = function afterEnter(node) {
        this.restoreCurrentStyle(node);

        this.props.afterEnter(node);
    };

    Expand.prototype.beforeLeave = function beforeLeave(node) {
        this.leaving = true;

        this.cacheCurrentStyle(node);
        this.cacheComputedStyle(node);
        this.setCurrentStyleToComputedStyle(node);

        this.props.beforeLeave(node);
    };

    Expand.prototype.onLeave = function onLeave(node) {
        this.setCurrentStyleToZero(node);

        this.props.onLeave(node);
    };

    Expand.prototype.afterLeave = function afterLeave(node) {
        this.leaving = false;

        this.restoreCurrentStyle(node);

        this.props.afterLeave(node);
    };

    Expand.prototype.cacheCurrentStyle = function cacheCurrentStyle(node) {
        this.styleBorderTopWidth = node.style.borderTopWidth;
        this.stylePaddingTop = node.style.paddingTop;
        this.styleHeight = node.style.height;
        this.stylePaddingBottom = node.style.paddingBottom;
        this.styleBorderBottomWidth = node.style.borderBottomWidth;
    };

    Expand.prototype.cacheComputedStyle = function cacheComputedStyle(node) {
        this.borderTopWidth = getStyle(node, 'borderTopWidth');
        this.paddingTop = getStyle(node, 'paddingTop');
        this.height = node.offsetHeight;
        this.paddingBottom = getStyle(node, 'paddingBottom');
        this.borderBottomWidth = getStyle(node, 'borderBottomWidth');
    };

    Expand.prototype.setCurrentStyleToZero = function setCurrentStyleToZero(node) {
        node.style.borderTopWidth = '0px';
        node.style.paddingTop = '0px';
        node.style.height = '0px';
        node.style.paddingBottom = '0px';
        node.style.borderBottomWidth = '0px';
    };

    Expand.prototype.setCurrentStyleToComputedStyle = function setCurrentStyleToComputedStyle(node) {
        node.style.borderTopWidth = this.borderTopWidth + 'px';
        node.style.paddingTop = this.paddingTop + 'px';
        node.style.height = this.height + 'px';
        node.style.paddingBottom = this.paddingBottom + 'px';
        node.style.borderBottomWidth = this.borderBottomWidth + 'px';
    };

    Expand.prototype.restoreCurrentStyle = function restoreCurrentStyle(node) {
        node.style.borderTopWidth = this.styleBorderTopWidth;
        node.style.paddingTop = this.stylePaddingTop;
        node.style.height = this.styleHeight;
        node.style.paddingBottom = this.stylePaddingBottom;
        node.style.borderBottomWidth = this.styleBorderBottomWidth;
    };

    Expand.prototype.render = function render() {
        var _props = this.props,
            animation = _props.animation,
            others = _objectWithoutProperties(_props, ['animation']);

        var newAnimation = animation || 'expand';

        return _react2.default.createElement(_animate2.default, _extends({}, others, {
            animation: newAnimation,
            beforeEnter: this.beforeEnter,
            onEnter: this.onEnter,
            afterEnter: this.afterEnter,
            beforeLeave: this.beforeLeave,
            onLeave: this.onLeave,
            afterLeave: this.afterLeave }));
    };

    return Expand;
}(_react.Component), _class.propTypes = {
    animation: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),
    beforeEnter: _propTypes2.default.func,
    onEnter: _propTypes2.default.func,
    afterEnter: _propTypes2.default.func,
    beforeLeave: _propTypes2.default.func,
    onLeave: _propTypes2.default.func,
    afterLeave: _propTypes2.default.func
}, _class.defaultProps = {
    beforeEnter: noop,
    onEnter: noop,
    afterEnter: noop,
    beforeLeave: noop,
    onLeave: noop,
    afterLeave: noop
}, _temp);
Expand.displayName = 'Expand';
exports.default = Expand;
module.exports = exports['default'];

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _checkableItem = __webpack_require__(58);

var _checkableItem2 = _interopRequireDefault(_checkableItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Menu.CheckboxItem
 * @order 3
 * @description 该子组件选中情况不受 defaultSelectedKeys/selectedKeys 控制，请自行控制选中逻辑
 */
var CheckboxItem = (_temp = _class = function (_Component) {
  _inherits(CheckboxItem, _Component);

  function CheckboxItem() {
    _classCallCheck(this, CheckboxItem);

    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  CheckboxItem.prototype.render = function render() {
    var _props = this.props,
        checkboxDisabled = _props.checkboxDisabled,
        others = _objectWithoutProperties(_props, ['checkboxDisabled']);

    return _react2.default.createElement(_checkableItem2.default, _extends({ role: 'menuitemcheckbox', checkType: 'checkbox', checkDisabled: checkboxDisabled }, others));
  };

  return CheckboxItem;
}(_react.Component), _class.menuChildType = 'item', _class.propTypes = {
  /**
   * 是否选中
   */
  checked: _propTypes2.default.bool,
  /**
   * 是否半选中
   */
  indeterminate: _propTypes2.default.bool,
  /**
   * 是否禁用
   */
  disabled: _propTypes2.default.bool,
  /**
   * 选中或取消选中触发的回调函数
   * @param {Boolean} checked 是否选中
   * @param {Object} event 选中事件对象
   */
  onChange: _propTypes2.default.func,
  /**
   * 帮助文本
   */
  helper: _propTypes2.default.node,
  /**
   * 标签内容
   */
  children: _propTypes2.default.node,
  checkboxDisabled: _propTypes2.default.bool
}, _class.defaultProps = {
  checked: false,
  indeterminate: false,
  disabled: false,
  onChange: function onChange() {},
  checkboxDisabled: false
}, _temp);
CheckboxItem.displayName = 'CheckboxItem';
exports.default = CheckboxItem;
module.exports = exports['default'];

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _util = __webpack_require__(2);

var _checkbox = __webpack_require__(59);

var _checkbox2 = _interopRequireDefault(_checkbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var pickOthers = _util.obj.pickOthers;

/** Checkbox.Group */

var CheckboxGroup = (_temp = _class = function (_Component) {
    _inherits(CheckboxGroup, _Component);

    function CheckboxGroup(props) {
        _classCallCheck(this, CheckboxGroup);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        var value = [];
        if ('value' in props) {
            value = props.value;
        } else if ('defaultValue' in props) {
            value = props.defaultValue;
        }
        if (!Array.isArray(value)) {
            if (value === null || value === undefined) {
                value = [];
            } else {
                value = [value];
            }
        }
        _this.state = {
            value: [].concat(value)
        };

        _this.onChange = _this.onChange.bind(_this);
        return _this;
    }

    CheckboxGroup.prototype.getChildContext = function getChildContext() {
        return {
            __group__: true,
            onChange: this.onChange,
            selectedValue: this.state.value,
            disabled: this.props.disabled
        };
    };

    CheckboxGroup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if ('value' in nextProps) {
            var value = nextProps.value;

            if (!Array.isArray(value)) {
                if (value === null || value === undefined) {
                    value = [];
                } else {
                    value = [value];
                }
            }
            this.setState({
                value: value
            });
        }
    };

    CheckboxGroup.prototype.onChange = function onChange(currentValue, e) {
        var value = this.state.value;

        var index = value.indexOf(currentValue);
        var valTemp = [].concat(value);

        if (index === -1) {
            valTemp.push(currentValue);
        } else {
            valTemp.splice(index, 1);
        }

        if (!('value' in this.props)) {
            this.setState({ value: valTemp });
        }
        this.props.onChange(valTemp, e);
    };

    CheckboxGroup.prototype.render = function render() {
        var _this2 = this,
            _classnames;

        var _props = this.props,
            className = _props.className,
            style = _props.style,
            prefix = _props.prefix,
            disabled = _props.disabled,
            itemDirection = _props.itemDirection;

        var others = pickOthers(CheckboxGroup.propTypes, this.props);

        // 如果内嵌标签跟dataSource同时存在，以内嵌标签为主
        var children = void 0;
        if (this.props.children) {
            children = this.props.children;
        } else {
            children = this.props.dataSource.map(function (item, index) {
                var option = item;
                if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) !== 'object') {
                    option = {
                        label: item,
                        value: item,
                        disabled: disabled
                    };
                }
                var checked = _this2.state.value && _this2.state.value.indexOf(option.value) > -1;

                return _react2.default.createElement(_checkbox2.default, { key: index,
                    value: option.value,
                    checked: checked,
                    disabled: disabled || option.disabled,
                    label: option.label
                });
            });
        }

        var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'checkbox-group'] = true, _classnames[prefix + 'checkbox-group-' + itemDirection] = true, _classnames[className] = !!className, _classnames.disabled = disabled, _classnames));

        return _react2.default.createElement(
            'span',
            _extends({}, others, { className: cls, style: style }),
            children
        );
    };

    return CheckboxGroup;
}(_react.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    rtl: _propTypes2.default.bool,
    /**
     * 自定义类名
     */
    className: _propTypes2.default.string,
    /**
     * 自定义内敛样式
     */
    style: _propTypes2.default.object,
    /**
     * 整体禁用
     */
    disabled: _propTypes2.default.bool,
    /**
     * 可选项列表, 数据项可为 String 或者 Object, 如 `['apple', 'pear', 'orange']` 或者 `[{value: 'apple', label: '苹果',}, {value: 'pear', label: '梨'}, {value: 'orange', label: '橙子'}]`
     */
    dataSource: _propTypes2.default.arrayOf(_propTypes2.default.any),
    /**
     * 被选中的值列表
     */
    value: _propTypes2.default.oneOfType([_propTypes2.default.array, _propTypes2.default.string, _propTypes2.default.number]),
    /**
     * 默认被选中的值列表
     */
    defaultValue: _propTypes2.default.oneOfType([_propTypes2.default.array, _propTypes2.default.string, _propTypes2.default.number]),
    /**
     * 通过子元素方式设置内部 checkbox
     */
    children: _propTypes2.default.arrayOf(_propTypes2.default.element),
    /**
     * 选中值改变时的事件
     * @param {Array} value 选中项列表
     * @param {Event} e Dom 事件对象
     */
    onChange: _propTypes2.default.func,

    /**
     * 子项目的排列方式
     * - hoz: 水平排列 (default)
     * - ver: 垂直排列
     */
    itemDirection: _propTypes2.default.oneOf(['hoz', 'ver'])
}, _class.defaultProps = {
    dataSource: [],
    onChange: function onChange() {},
    prefix: 'next-',
    itemDirection: 'hoz'
}, _class.childContextTypes = {
    onChange: _propTypes2.default.func,
    __group__: _propTypes2.default.bool,
    selectedValue: _propTypes2.default.array,
    disabled: _propTypes2.default.bool
}, _temp);
CheckboxGroup.displayName = 'CheckboxGroup';
exports.default = _configProvider2.default.config(CheckboxGroup);
module.exports = exports['default'];

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _util = __webpack_require__(2);

var _radio = __webpack_require__(62);

var _radio2 = _interopRequireDefault(_radio);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var pickOthers = _util.obj.pickOthers;

/**
 * Radio.Group
 * @order 2
 */

var RadioGroup = (_temp = _class = function (_Component) {
    _inherits(RadioGroup, _Component);

    function RadioGroup(props) {
        _classCallCheck(this, RadioGroup);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        var value = '';
        if ('value' in props) {
            value = props.value;
        } else if ('defaultValue' in props) {
            value = props.defaultValue;
        }
        _this.state = { value: value };
        _this.onChange = _this.onChange.bind(_this);
        return _this;
    }

    RadioGroup.prototype.getChildContext = function getChildContext() {
        return {
            __group__: true,
            isButton: this.props.shape === 'button',
            onChange: this.onChange,
            selectedValue: this.state.value,
            disabled: this.props.disabled
        };
    };

    RadioGroup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var value = nextProps.value;

        if ('value' in nextProps) {
            if (value === undefined) {
                value = '';
            }
            this.setState({
                value: value
            });
        }
    };

    RadioGroup.prototype.onChange = function onChange(currentValue, e) {
        if (!('value' in this.props)) {
            this.setState({ value: currentValue });
        }
        if (currentValue !== this.state.value) {
            this.props.onChange(currentValue, e);
        }
    };

    RadioGroup.prototype.render = function render() {
        var _this2 = this,
            _classnames;

        var _props = this.props,
            rtl = _props.rtl,
            className = _props.className,
            shape = _props.shape,
            size = _props.size,
            style = _props.style,
            prefix = _props.prefix,
            itemDirection = _props.itemDirection;

        var others = pickOthers(Object.keys(RadioGroup.propTypes), this.props);
        var disabled = this.props.disabled;

        if (rtl) {
            others.dir = 'rtl';
        }

        var children = void 0;
        if (this.props.children) {
            children = this.props.children;
        } else {
            children = this.props.dataSource.map(function (item, index) {
                var option = item;
                if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) !== 'object') {
                    option = {
                        label: item,
                        value: item,
                        disabled: disabled
                    };
                }
                var checked = _this2.state.value === option.value;
                return _react2.default.createElement(_radio2.default, {
                    key: index,
                    tabIndex: index === 0 && !_this2.state.value || checked ? 0 : -1,
                    value: option.value,
                    checked: checked,
                    label: option.label,
                    disabled: disabled || option.disabled
                });
            });
        }

        var isButtonShape = shape === 'button';

        var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'radio-group'] = true, _classnames[prefix + 'radio-group-' + itemDirection] = !isButtonShape, _classnames[prefix + 'radio-button'] = isButtonShape, _classnames[prefix + 'radio-button-' + size] = isButtonShape, _classnames[className] = !!className, _classnames.disabled = disabled, _classnames));

        return _react2.default.createElement(
            'div',
            _extends({}, others, { 'aria-disabled': disabled, role: 'radiogroup', className: cls, style: style }),
            children
        );
    };

    return RadioGroup;
}(_react.Component), _class.propTypes = {
    /**
     * 样式类名的品牌前缀
     */
    prefix: _propTypes2.default.string,
    rtl: _propTypes2.default.bool,
    /**
     * 自定义类名
     */
    className: _propTypes2.default.string,
    /**
     * 自定义内敛样式
     */
    style: _propTypes2.default.object,
    /**
     * name
     */
    name: _propTypes2.default.string,
    /**
     * radio group的选中项的值
     */
    value: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number, _propTypes2.default.bool]),
    /**
     * radio group的默认值
     */
    defaultValue: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number, _propTypes2.default.bool]),
    /**
     * 选中值改变时的事件
     * @param {String/Number} value 选中项的值
     * @param {Event} e Dom 事件对象
     */
    onChange: _propTypes2.default.func,
    /**
     * 表示radio被禁用
     */
    disabled: _propTypes2.default.bool,
    /**
     * 可以设置成 button 展示形状
     * @enumdesc 按钮状
     */
    shape: _propTypes2.default.oneOf(['button']),
    /**
     * 与 `shape` 属性配套使用，shape设为button时有效
     * @enumdesc 大, 中, 小
     */
    size: _propTypes2.default.oneOf(['large', 'medium', 'small']),
    /**
     * 可选项列表, 数据项可为 String 或者 Object, 如 `['apple', 'pear', 'orange']`
     */
    dataSource: _propTypes2.default.arrayOf(_propTypes2.default.any),
    /**
     * 通过子元素方式设置内部radio
     */
    children: _propTypes2.default.oneOfType([_propTypes2.default.arrayOf(_propTypes2.default.element), _propTypes2.default.element]),

    /**
     * 子项目的排列方式
     * - hoz: 水平排列 (default)
     * - ver: 垂直排列
     */
    itemDirection: _propTypes2.default.oneOf(['hoz', 'ver'])
}, _class.defaultProps = {
    dataSource: [],
    size: 'medium',
    onChange: function onChange() {},
    prefix: 'next-',
    itemDirection: 'hoz'
}, _class.childContextTypes = {
    onChange: _propTypes2.default.func,
    __group__: _propTypes2.default.bool,
    isButton: _propTypes2.default.bool,
    selectedValue: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number, _propTypes2.default.bool]),
    disabled: _propTypes2.default.bool
}, _temp);
RadioGroup.displayName = 'RadioGroup';
exports.default = _configProvider2.default.config(RadioGroup);
module.exports = exports['default'];

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _checkableItem = __webpack_require__(58);

var _checkableItem2 = _interopRequireDefault(_checkableItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Menu.RadioItem
 * @order 4
 * @description 该子组件选中情况不受 defaultSelectedKeys/selectedKeys 控制，请自行控制选中逻辑
 */
var RadioItem = (_temp = _class = function (_Component) {
  _inherits(RadioItem, _Component);

  function RadioItem() {
    _classCallCheck(this, RadioItem);

    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  RadioItem.prototype.render = function render() {
    return _react2.default.createElement(_checkableItem2.default, _extends({ role: 'menuitemradio', checkType: 'radio' }, this.props));
  };

  return RadioItem;
}(_react.Component), _class.menuChildType = 'item', _class.propTypes = {
  /**
   * 是否选中
   */
  checked: _propTypes2.default.bool,
  /**
   * 是否禁用
   */
  disabled: _propTypes2.default.bool,
  /**
   * 选中或取消选中触发的回调函数
   * @param {Boolean} checked 是否选中
   * @param {Object} event 选中事件对象
   */
  onChange: _propTypes2.default.func,
  /**
   * 帮助文本
   */
  helper: _propTypes2.default.node,
  /**
   * 标签内容
   */
  children: _propTypes2.default.node
}, _class.defaultProps = {
  checked: false,
  disabled: false,
  onChange: function onChange() {}
}, _temp);
RadioItem.displayName = 'RadioItem';
exports.default = RadioItem;
module.exports = exports['default'];

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _item = __webpack_require__(14);

var _item2 = _interopRequireDefault(_item);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Menu.Group
 * @order 5
 */
var Group = (_temp = _class = function (_Component) {
    _inherits(Group, _Component);

    function Group() {
        _classCallCheck(this, Group);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    Group.prototype.render = function render() {
        var _cx;

        var _props = this.props,
            root = _props.root,
            className = _props.className,
            label = _props.label,
            children = _props.children,
            parentMode = _props.parentMode,
            others = _objectWithoutProperties(_props, ['root', 'className', 'label', 'children', 'parentMode']);

        var prefix = root.props.prefix;


        var newClassName = (0, _classnames2.default)((_cx = {}, _cx[prefix + 'menu-group-label'] = true, _cx[className] = !!className, _cx));

        var newChildren = children.map(function (child) {
            var _cx2;

            var className = child.props.className;

            var newChildClassName = (0, _classnames2.default)((_cx2 = {}, _cx2[prefix + 'menu-group-item'] = true, _cx2[className] = !!className, _cx2));

            return (0, _react.cloneElement)(child, {
                parentMode: parentMode,
                className: newChildClassName
            });
        });

        return [_react2.default.createElement(
            _item2.default,
            _extends({
                key: 'menu-group-label',
                className: newClassName,
                replaceClassName: true,
                root: root,
                parentMode: parentMode
            }, others),
            label
        )].concat(newChildren);
    };

    return Group;
}(_react.Component), _class.menuChildType = 'group', _class.propTypes = {
    root: _propTypes2.default.object,
    className: _propTypes2.default.string,
    /**
     * 标签内容
     */
    label: _propTypes2.default.node,
    /**
     * 菜单项
     */
    children: _propTypes2.default.node,
    parentMode: _propTypes2.default.oneOf(['inline', 'popup'])
}, _temp);
Group.displayName = 'Group';
exports.default = Group;
module.exports = exports['default'];

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Menu.Divider
 * @order 6
 */
var Divider = (_temp = _class = function (_Component) {
    _inherits(Divider, _Component);

    function Divider() {
        _classCallCheck(this, Divider);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    Divider.prototype.render = function render() {
        var _cx;

        var _props = this.props,
            root = _props.root,
            className = _props.className,
            others = _objectWithoutProperties(_props, ['root', 'className']);

        var prefix = root.props.prefix;


        var newClassName = (0, _classnames2.default)((_cx = {}, _cx[prefix + 'menu-divider'] = true, _cx[className] = !!className, _cx));

        return _react2.default.createElement('li', _extends({ role: 'separator', className: newClassName }, others));
    };

    return Divider;
}(_react.Component), _class.menuChildType = 'divider', _class.propTypes = {
    root: _propTypes2.default.object,
    className: _propTypes2.default.string
}, _temp);
Divider.displayName = 'Divider';
exports.default = Divider;
module.exports = exports['default'];

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

exports.default = create;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _overlay = __webpack_require__(15);

var _overlay2 = _interopRequireDefault(_overlay);

var _util = __webpack_require__(2);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _menu = __webpack_require__(50);

var _menu2 = _interopRequireDefault(_menu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var bindCtx = _util.func.bindCtx;
var getContextProps = _configProvider2.default.getContextProps;

var Menu = _configProvider2.default.config(_menu2.default);

var menuInstance = void 0;

var ContextMenu = (_temp = _class = function (_Component) {
    _inherits(ContextMenu, _Component);

    function ContextMenu(props) {
        _classCallCheck(this, ContextMenu);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        _this.state = {
            visible: true
        };

        bindCtx(_this, ['handleOverlayClose', 'handleOverlayOpen', 'handleItemClick', 'getOverlay']);
        return _this;
    }

    ContextMenu.prototype.getOverlay = function getOverlay(ref) {
        this.overlay = ref;
    };

    ContextMenu.prototype.close = function close() {
        this.setState({
            visible: false
        });
        menuInstance = null;
    };

    ContextMenu.prototype.handleOverlayClose = function handleOverlayClose(triggerType, e) {
        var clickedPopupMenu = triggerType === 'docClick' && this.popupNodes.some(function (node) {
            return node.contains(e.target);
        });
        if (!clickedPopupMenu) {
            this.close();
            var overlayProps = this.props.overlayProps;

            if (overlayProps && overlayProps.onRequestClose) {
                for (var _len = arguments.length, others = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                    others[_key - 2] = arguments[_key];
                }

                overlayProps.onRequestClose.apply(overlayProps, [triggerType, e].concat(others));
            }
        }
    };

    ContextMenu.prototype.handleOverlayOpen = function handleOverlayOpen() {
        this.popupNodes = this.overlay.getInstance().getContent().getInstance().popupNodes;
        var overlayProps = this.props.overlayProps;

        if (overlayProps && overlayProps.onOpen) {
            overlayProps.onOpen();
        }
    };

    ContextMenu.prototype.handleItemClick = function handleItemClick() {
        var _props;

        this.close();

        this.props.onItemClick && (_props = this.props).onItemClick.apply(_props, arguments);
    };

    ContextMenu.prototype.render = function render() {
        var _cx, _cx2;

        var _props2 = this.props,
            className = _props2.className,
            popupClassName = _props2.popupClassName,
            target = _props2.target,
            align = _props2.align,
            offset = _props2.offset,
            afterClose = _props2.afterClose,
            _props2$overlayProps = _props2.overlayProps,
            overlayProps = _props2$overlayProps === undefined ? {} : _props2$overlayProps,
            others = _objectWithoutProperties(_props2, ['className', 'popupClassName', 'target', 'align', 'offset', 'afterClose', 'overlayProps']);

        var contextProps = getContextProps(this.props);
        var prefix = contextProps.prefix;
        var visible = this.state.visible;


        var newOverlayProps = _extends({}, contextProps, overlayProps, {
            target: target, align: align, offset: offset, afterClose: afterClose, visible: visible,
            onRequestClose: this.handleOverlayClose,
            onOpen: this.handleOverlayOpen,
            ref: this.getOverlay
        });
        var menuProps = _extends({}, contextProps, {
            triggerType: 'hover'
        }, others, {
            className: (0, _classnames2.default)((_cx = {}, _cx[prefix + 'context'] = true, _cx[className] = !!className, _cx)),
            popupClassName: (0, _classnames2.default)((_cx2 = {}, _cx2[prefix + 'context'] = true, _cx2[popupClassName] = !!popupClassName, _cx2)),
            onItemClick: this.handleItemClick
        });

        newOverlayProps.rtl = false;

        return _react2.default.createElement(
            _overlay2.default,
            newOverlayProps,
            _react2.default.createElement(Menu, menuProps)
        );
    };

    return ContextMenu;
}(_react.Component), _class.propTypes = {
    className: _propTypes2.default.string,
    popupClassName: _propTypes2.default.string,
    target: _propTypes2.default.any,
    align: _propTypes2.default.string,
    offset: _propTypes2.default.array,
    overlayProps: _propTypes2.default.object,
    afterClose: _propTypes2.default.func,
    mode: _propTypes2.default.oneOf(['inline', 'popup']),
    onOpen: _propTypes2.default.func,
    onItemClick: _propTypes2.default.func
}, _class.defaultProps = {
    prefix: 'next-',
    align: 'tl tl',
    mode: 'popup'
}, _temp);

/**
 * 创建上下文菜单
 * @exportName create
 * @param {Object} props 属性对象
 */

ContextMenu.displayName = 'ContextMenu';
function create(props) {
    if (menuInstance) {
        menuInstance.destroy();
    }

    /* eslint-disable no-unused-vars */

    var afterClose = props.afterClose,
        others = _objectWithoutProperties(props, ['afterClose']);
    /* eslint-enable no-unused-vars */

    var div = document.createElement('div');
    document.body.appendChild(div);

    var closeChain = function closeChain() {
        (0, _reactDom.unmountComponentAtNode)(div);
        document.body.removeChild(div);

        afterClose && afterClose();
    };

    var newContext = _configProvider2.default.getContext();

    var menu = void 0;
    (0, _reactDom.render)(_react2.default.createElement(
        _configProvider2.default,
        newContext,
        _react2.default.createElement(ContextMenu, _extends({ ref: function ref(_ref) {
                menu = _ref;
            }, afterClose: closeChain }, others))
    ), div);

    menuInstance = {
        destroy: function destroy() {
            if (menu) {
                menu.close();
            }
        }
    };

    return menuInstance;
}
module.exports = exports['default'];

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function mapIconSize(size) {
    return {
        large: 'small',
        medium: 'xs',
        small: 'xs'
    }[size];
}

/** Button */
var Button = (_temp2 = _class = function (_Component) {
    _inherits(Button, _Component);

    function Button() {
        var _temp, _this, _ret;

        _classCallCheck(this, Button);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.onMouseUp = function (e) {
            _this.button.blur();

            if (_this.props.onMouseUp) {
                _this.props.onMouseUp(e);
            }
        }, _this.buttonRefHandler = function (button) {
            _this.button = button;
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Button.prototype.render = function render() {
        var _classNames;

        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            type = _props.type,
            size = _props.size,
            htmlType = _props.htmlType,
            loading = _props.loading,
            text = _props.text,
            warning = _props.warning,
            ghost = _props.ghost,
            component = _props.component,
            iconSize = _props.iconSize,
            children = _props.children,
            rtl = _props.rtl,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'type', 'size', 'htmlType', 'loading', 'text', 'warning', 'ghost', 'component', 'iconSize', 'children', 'rtl']);

        var ghostType = ['light', 'dark'].indexOf(ghost) >= 0 ? ghost : 'dark';

        var btnCls = (0, _classnames2.default)((_classNames = {}, _classNames[prefix + 'btn'] = true, _classNames['' + prefix + size] = size, _classNames[prefix + 'btn-' + type] = type && !ghost, _classNames[prefix + 'btn-text'] = text, _classNames[prefix + 'btn-warning'] = warning, _classNames[prefix + 'btn-loading'] = loading, _classNames[prefix + 'btn-ghost'] = ghost, _classNames[prefix + 'btn-' + ghostType] = ghost, _classNames[className] = className, _classNames));

        var count = _react.Children.count(children);
        var clonedChildren = _react.Children.map(children, function (child, index) {
            if (child && typeof child.type === 'function' && child.type._typeMark === 'icon') {
                var _classNames2;

                var iconCls = (0, _classnames2.default)((_classNames2 = {}, _classNames2[prefix + 'btn-icon'] = !iconSize, _classNames2[prefix + 'icon-first'] = count > 1 && index === 0, _classNames2[prefix + 'icon-last'] = count > 1 && index === count - 1, _classNames2[prefix + 'icon-alone'] = count === 1, _classNames2[child.props.className] = !!child.props.className, _classNames2));
                return _react2.default.cloneElement(child, {
                    className: iconCls,
                    size: iconSize || mapIconSize(size)
                });
            }

            return child;
        });

        var TagName = component;
        var tagAttrs = _extends({}, others, {
            type: htmlType,
            className: btnCls
        });

        if (TagName === 'a') {
            delete tagAttrs.type;

            if (tagAttrs.disabled) {
                delete tagAttrs.onClick; // a 标签的 onClick 浏览器默认不会禁用
                tagAttrs.href && delete tagAttrs.href; // a 标签在禁用状态下无跳转
            }
        }

        return _react2.default.createElement(
            TagName,
            _extends({}, tagAttrs, { dir: rtl ? 'rtl' : undefined, onMouseUp: this.onMouseUp, ref: this.buttonRefHandler, role: 'button' }),
            clonedChildren
        );
    };

    return Button;
}(_react.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    rtl: _propTypes2.default.bool,
    /**
     * 按钮的类型
     */
    type: _propTypes2.default.oneOf(['primary', 'secondary', 'normal']),
    /**
     * 按钮的尺寸
     */
    size: _propTypes2.default.oneOf(['small', 'medium', 'large']),
    /**
     * 按钮中 Icon 的尺寸，用于替代 Icon 的默认大小
     */
    iconSize: _propTypes2.default.oneOf(['xxs', 'xs', 'small', 'medium', 'large', 'xl', 'xxl', 'xxxl']),
    /**
     * 当 component = 'button' 时，设置 button 标签的 type 值
     */
    htmlType: _propTypes2.default.oneOf(['submit', 'reset', 'button']),
    /**
     * 设置标签类型
     */
    component: _propTypes2.default.oneOf(['button', 'a']),
    /**
     * 设置按钮的载入状态
     */
    loading: _propTypes2.default.bool,
    /**
     * 是否为幽灵按钮
     */
    ghost: _propTypes2.default.oneOf([true, false, 'light', 'dark']),
    /**
     * 是否为文本按钮
     */
    text: _propTypes2.default.bool,
    /**
     * 是否为警告按钮
     */
    warning: _propTypes2.default.bool,
    /**
     * 是否禁用
     */
    disabled: _propTypes2.default.bool,
    /**
     * 点击按钮的回调
     * @param {Object} e Event Object
     */
    onClick: _propTypes2.default.func,
    className: _propTypes2.default.string,
    onMouseUp: _propTypes2.default.func,
    children: _propTypes2.default.node
}, _class.defaultProps = {
    prefix: 'next-',
    type: 'normal',
    size: 'medium',
    htmlType: 'button',
    component: 'button',
    loading: false,
    ghost: false,
    text: false,
    warning: false,
    disabled: false,
    onClick: function onClick() {}
}, _temp2);
Button.displayName = 'Button';
exports.default = Button;
module.exports = exports['default'];

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Button.Group
 */
var ButtonGroup = (_temp = _class = function (_Component) {
    _inherits(ButtonGroup, _Component);

    function ButtonGroup() {
        _classCallCheck(this, ButtonGroup);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    ButtonGroup.prototype.render = function render() {
        var _classNames;

        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            size = _props.size,
            children = _props.children,
            rtl = _props.rtl,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'size', 'children', 'rtl']);

        var groupCls = (0, _classnames2.default)((_classNames = {}, _classNames[prefix + 'btn-group'] = true, _classNames[className] = className, _classNames));

        var cloneChildren = _react.Children.map(children, function (child) {
            if (child) {
                return _react2.default.cloneElement(child, {
                    size: size
                });
            }
        });

        if (rtl) {
            others.dir = 'rtl';
        }

        return _react2.default.createElement(
            'div',
            _extends({}, others, { className: groupCls }),
            cloneChildren
        );
    };

    return ButtonGroup;
}(_react.Component), _class.propTypes = {
    rtl: _propTypes2.default.bool,
    prefix: _propTypes2.default.string,
    /**
     * 统一设置 Button 组件的按钮大小
     */
    size: _propTypes2.default.string,
    className: _propTypes2.default.string,
    children: _propTypes2.default.node
}, _class.defaultProps = {
    prefix: 'next-',
    size: 'medium'
}, _temp);
ButtonGroup.displayName = 'ButtonGroup';
exports.default = _configProvider2.default.config(ButtonGroup);
module.exports = exports['default'];

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var Resize = (_temp2 = _class = function (_React$Component) {
    _inherits(Resize, _React$Component);

    function Resize() {
        var _temp, _this, _ret;

        _classCallCheck(this, Resize);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onMouseDown = function (e) {
            _this.lastPageX = e.pageX;
            _util.events.on(document, 'mousemove', _this.onMouseMove);
            _util.events.on(document, 'mouseup', _this.onMouseUp);
            _this.unSelect();
        }, _this.onMouseMove = function (e) {
            var pageX = e.pageX;
            var changedPageX = pageX - _this.lastPageX;
            _this.props.onChange(_this.props.dataIndex, changedPageX);
            _this.lastPageX = pageX;
        }, _this.onMouseUp = function () {
            _this.destory();
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Resize.prototype.componentWillUnmount = function componentWillUnmount() {
        this.destory();
    };

    Resize.prototype.destory = function destory() {
        _util.events.off(document, 'mousemove', this.onMouseMove);
        _util.events.off(document, 'mouseup', this.onMouseMove);
        this.select();
    };

    Resize.prototype.unSelect = function unSelect() {
        _util.dom.setStyle(document.body, {
            userSelect: 'none',
            cursor: 'ew-resize'
        });
        document.body.setAttribute('unselectable', 'on');
    };

    Resize.prototype.select = function select() {
        _util.dom.setStyle(document.body, {
            userSelect: '',
            cursor: ''
        });
        document.body.removeAttribute('unselectable');
    };

    Resize.prototype.render = function render() {
        var prefix = this.props.prefix;

        return _react2.default.createElement('a', { className: prefix + 'table-resize-handler', onMouseDown: this.onMouseDown });
    };

    return Resize;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    onChange: _propTypes2.default.func,
    dataIndex: _propTypes2.default.string
}, _class.defaultProps = {
    onChange: function onChange() {}
}, _temp2);
Resize.displayName = 'Resize';
exports.default = Resize;
module.exports = exports['default'];

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var Wrapper = function (_Component) {
    _inherits(Wrapper, _Component);

    function Wrapper() {
        _classCallCheck(this, Wrapper);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    Wrapper.prototype.render = function render() {
        var _props = this.props,
            colGroup = _props.colGroup,
            children = _props.children,
            Tag = _props.component;

        return _react2.default.createElement(
            Tag,
            { role: 'table' },
            colGroup,
            children
        );
    };

    return Wrapper;
}(_react.Component);

Wrapper.displayName = 'Wrapper';
exports.default = Wrapper;


Wrapper.defaultProps = {
    component: 'table'
};

Wrapper.propTypes = {
    children: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    colGroup: _propTypes2.default.any,
    component: _propTypes2.default.string
};
module.exports = exports['default'];

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Table.ColumnGroup
 * @order 1
 **/
var ColumnGroup = (_temp = _class = function (_React$Component) {
    _inherits(ColumnGroup, _React$Component);

    function ColumnGroup() {
        _classCallCheck(this, ColumnGroup);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    ColumnGroup.prototype.getChildContext = function getChildContext() {
        return {
            parent: this
        };
    };

    ColumnGroup.prototype.render = function render() {
        return null;
    };

    return ColumnGroup;
}(_react2.default.Component), _class.propTypes = {
    /**
     * 表头显示的内容
     */
    title: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.node, _propTypes2.default.func])
}, _class.childContextTypes = {
    parent: _propTypes2.default.any
}, _class.defaultProps = {
    title: 'column-group'
}, _class._typeMark = 'columnGroup', _temp);
ColumnGroup.displayName = 'ColumnGroup';
exports.default = ColumnGroup;
module.exports = exports['default'];

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = tree;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _row = __webpack_require__(124);

var _row2 = _interopRequireDefault(_row);

var _cell = __webpack_require__(125);

var _cell2 = _interopRequireDefault(_cell);

var _util = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};

function tree(BaseComponent) {
    var _class, _temp;

    var TreeTable = (_temp = _class = function (_React$Component) {
        _inherits(TreeTable, _React$Component);

        function TreeTable(props, context) {
            _classCallCheck(this, TreeTable);

            var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

            _this.onTreeNodeClick = function (record) {
                var primaryKey = _this.props.primaryKey,
                    id = record[primaryKey],
                    dataSource = _this.ds,
                    openRowKeys = [].concat(_this.state.openRowKeys),
                    index = openRowKeys.indexOf(id),
                    getChildrenKeyById = function getChildrenKeyById(id) {
                    var ret = [id];
                    var loop = function loop(data) {
                        data.forEach(function (item) {
                            ret.push(item[primaryKey]);
                            if (item.children) {
                                loop(item.children);
                            }
                        });
                    };
                    dataSource.forEach(function (item) {
                        if (item[primaryKey] === id) {
                            if (item.children) {
                                loop(item.children);
                            }
                        }
                    });
                    return ret;
                };


                if (index > -1) {
                    // 不仅要删除当前的openRowKey，还需要删除关联子节点的openRowKey
                    var ids = getChildrenKeyById(id);
                    ids.forEach(function (id) {
                        var i = openRowKeys.indexOf(id);
                        if (i > -1) {
                            openRowKeys.splice(i, 1);
                        }
                    });
                } else {
                    openRowKeys.push(id);
                }

                if (!('openRowKeys' in _this.props)) {
                    _this.setState({
                        openRowKeys: openRowKeys
                    });
                }
                _this.props.onRowOpen(openRowKeys, id, index === -1, record);
            };

            _this.state = {
                openRowKeys: props.openRowKeys || []
            };
            return _this;
        }

        TreeTable.prototype.getChildContext = function getChildContext() {
            return {
                openTreeRowKeys: this.state.openRowKeys,
                indent: this.props.indent,
                treeStatus: this.getTreeNodeStatus(this.ds),
                onTreeNodeClick: this.onTreeNodeClick,
                isTree: this.props.isTree
            };
        };

        TreeTable.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
            if ('openRowKeys' in nextProps) {
                var openRowKeys = nextProps.openRowKeys;

                this.setState({
                    openRowKeys: openRowKeys
                });
            }
        };

        TreeTable.prototype.normalizeDataSource = function normalizeDataSource(dataSource) {
            var ret = [],
                loop = function loop(dataSource, level) {
                dataSource.forEach(function (item) {
                    item.__level = level;
                    ret.push(item);
                    if (item.children) {
                        loop(item.children, level + 1);
                    }
                });
            };
            loop(dataSource, 0);
            this.ds = ret;
            return ret;
        };

        TreeTable.prototype.getTreeNodeStatus = function getTreeNodeStatus() {
            var dataSource = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            var openRowKeys = this.state.openRowKeys,
                primaryKey = this.props.primaryKey,
                ret = [];


            openRowKeys.forEach(function (openKey) {
                dataSource.forEach(function (item) {
                    if (item[primaryKey] === openKey) {
                        if (item.children) {
                            item.children.forEach(function (child) {
                                ret.push(child[primaryKey]);
                            });
                        }
                    }
                });
            });
            return ret;
        };

        TreeTable.prototype.render = function render() {
            /* eslint-disable no-unused-vars, prefer-const */
            var _props = this.props,
                components = _props.components,
                isTree = _props.isTree,
                dataSource = _props.dataSource,
                indent = _props.indent,
                others = _objectWithoutProperties(_props, ['components', 'isTree', 'dataSource', 'indent']);

            if (isTree) {
                components = _extends({}, components);
                if (!components.Row) {
                    components.Row = _row2.default;
                }
                if (!components.Cell) {
                    components.Cell = _cell2.default;
                }

                dataSource = this.normalizeDataSource(dataSource);
            }
            return _react2.default.createElement(BaseComponent, _extends({}, others, { dataSource: dataSource, components: components }));
        };

        return TreeTable;
    }(_react2.default.Component), _class.TreeRow = _row2.default, _class.TreeCell = _cell2.default, _class.propTypes = _extends({
        /**
         * 默认情况下展开的树形表格，传入了此属性代表tree的展开为受控操作
         */
        openRowKeys: _propTypes2.default.array,
        /**
         * 点击tree展开或者关闭的时候触发的事件
         * @param {Array} openRowKeys tree模式下展开的key
         * @param {String} currentRowKey 当前点击行的key
         * @param {Boolean} opened 当前点击是展开还是收起
         * @param {Object} currentRecord 当前点击行的记录
         */
        onRowOpen: _propTypes2.default.func,
        /**
         * dataSource当中数据的主键，如果给定的数据源中的属性不包含该主键，会造成选择状态全部选中
         */
        primaryKey: _propTypes2.default.string,
        /**
         * 在tree模式下的缩进尺寸， 仅在isTree为true时候有效
         */
        indent: _propTypes2.default.number,
        /**
         * 开启Table的tree模式, 接收的数据格式中包含children则渲染成tree table
         */
        isTree: _propTypes2.default.bool,
        locale: _propTypes2.default.object
    }, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps, {
        primaryKey: 'id',
        onRowOpen: noop,
        components: {},
        indent: 12
    }), _class.childContextTypes = {
        openTreeRowKeys: _propTypes2.default.array,
        indent: _propTypes2.default.number,
        treeStatus: _propTypes2.default.array,
        onTreeNodeClick: _propTypes2.default.func,
        isTree: _propTypes2.default.bool
    }, _temp);
    TreeTable.displayName = 'TreeTable';

    (0, _util.statics)(TreeTable, BaseComponent);
    return TreeTable;
}
module.exports = exports['default'];

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _row = __webpack_require__(64);

var _row2 = _interopRequireDefault(_row);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var TreeRow = (_temp = _class = function (_React$Component) {
    _inherits(TreeRow, _React$Component);

    function TreeRow() {
        _classCallCheck(this, TreeRow);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    TreeRow.prototype.render = function render() {
        var _classnames;

        /* eslint-disable no-unused-vars*/
        var _props = this.props,
            className = _props.className,
            record = _props.record,
            primaryKey = _props.primaryKey,
            prefix = _props.prefix,
            others = _objectWithoutProperties(_props, ['className', 'record', 'primaryKey', 'prefix']);

        var _context = this.context,
            treeStatus = _context.treeStatus,
            openRowKeys = _context.openRowKeys;

        var cls = (0, _classnames3.default)((_classnames = {
            hidden: !(treeStatus.indexOf(record[primaryKey]) > -1) && record.__level !== 0
        }, _classnames[prefix + 'table-row-level-' + record.__level] = true, _classnames.opened = openRowKeys.indexOf(record[primaryKey]) > -1, _classnames));
        return _react2.default.createElement(_row2.default, _extends({}, others, { record: record, className: cls, primaryKey: primaryKey, prefix: prefix }));
    };

    return TreeRow;
}(_react2.default.Component), _class.propTypes = _extends({}, _row2.default.propTypes), _class.defaultProps = _extends({}, _row2.default.defaultProps), _class.contextTypes = {
    treeStatus: _propTypes2.default.array,
    openRowKeys: _propTypes2.default.array
}, _temp);
TreeRow.displayName = 'TreeRow';
exports.default = TreeRow;
module.exports = exports['default'];

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

var _cell = __webpack_require__(18);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var TreeCell = (_temp2 = _class = function (_React$Component) {
    _inherits(TreeCell, _React$Component);

    function TreeCell() {
        var _temp, _this, _ret;

        _classCallCheck(this, TreeCell);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onTreeNodeClick = function (record, e) {
            e.stopPropagation();
            _this.context.onTreeNodeClick(record);
        }, _this.expandedKeydown = function (record, e) {
            e.preventDefault();
            e.stopPropagation();

            if (e.keyCode === _util.KEYCODE.ENTER) {
                _this.onTreeNodeClick(record, e);
            }
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    TreeCell.prototype.render = function render() {
        var _this2 = this;

        var _props = this.props,
            colIndex = _props.colIndex,
            record = _props.record,
            prefix = _props.prefix,
            primaryKey = _props.primaryKey,
            locale = _props.locale;
        var _context = this.context,
            openRowKeys = _context.openTreeRowKeys,
            indent = _context.indent,
            isTree = _context.isTree,
            rowSelection = _context.rowSelection;

        var treeArrowNodeIndex = rowSelection ? 1 : 0;
        var firstCellStyle = void 0,
            treeArrowNode = void 0;
        if (colIndex === treeArrowNodeIndex) {
            var treeArrowType = void 0;
            if (isTree) {
                firstCellStyle = {
                    paddingLeft: indent * (record.__level + 1)
                };
                treeArrowNode = _react2.default.createElement(_icon2.default, { size: 'xs', className: prefix + 'table-tree-placeholder' });
                if (record.children && record.children.length) {
                    var hasExpanded = openRowKeys.indexOf(record[primaryKey]) > -1;

                    treeArrowType = hasExpanded ? 'arrow-down' : 'arrow-right';

                    treeArrowNode = _react2.default.createElement(_icon2.default, {
                        className: prefix + 'table-tree-arrow',
                        type: treeArrowType,
                        size: 'xs',
                        onClick: function onClick(e) {
                            return _this2.onTreeNodeClick(record, e);
                        },
                        onKeyDown: function onKeyDown(e) {
                            return _this2.expandedKeydown(record, e);
                        },
                        role: 'button',
                        tabIndex: '0',
                        'aria-expanded': hasExpanded,
                        'aria-label': hasExpanded ? locale.expanded : locale.folded });
                }
            }
        }
        return _react2.default.createElement(
            _cell2.default,
            _extends({}, this.props, { innerStyle: firstCellStyle }),
            treeArrowNode
        );
    };

    return TreeCell;
}(_react2.default.Component), _class.propTypes = _extends({
    indent: _propTypes2.default.number,
    locale: _propTypes2.default.object
}, _cell2.default.propTypes), _class.defaultProps = _extends({}, _cell2.default.defaultProps, {
    component: 'td',
    indent: 20
}), _class.contextTypes = {
    openTreeRowKeys: _propTypes2.default.array,
    indent: _propTypes2.default.number,
    onTreeNodeClick: _propTypes2.default.func,
    isTree: _propTypes2.default.bool,
    rowSelection: _propTypes2.default.object
}, _temp2);
TreeCell.displayName = 'TreeCell';
exports.default = TreeCell;
module.exports = exports['default'];

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = fixed;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _util = __webpack_require__(2);

var _header = __webpack_require__(19);

var _header2 = _interopRequireDefault(_header);

var _body = __webpack_require__(67);

var _body2 = _interopRequireDefault(_body);

var _wrapper = __webpack_require__(24);

var _wrapper2 = _interopRequireDefault(_wrapper);

var _util2 = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function fixed(BaseComponent) {
    var _class, _temp2;

    /** Table */
    var FixedTable = (_temp2 = _class = function (_React$Component) {
        _inherits(FixedTable, _React$Component);

        function FixedTable() {
            var _temp, _this, _ret;

            _classCallCheck(this, FixedTable);

            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.getNode = function (type, node, lockType) {
                lockType = lockType ? lockType.charAt(0).toUpperCase() + lockType.substr(1) : '';
                _this['' + type + lockType + 'Node'] = node;
                if (type === 'header' && !lockType) {
                    _this.innerHeaderNode = _this.headerNode.querySelector('div');
                }
            }, _this.onBodyScroll = function () {
                _this.scrollTo(_this.bodyNode.scrollLeft, _this.bodyNode.scrollTop);
            }, _temp), _possibleConstructorReturn(_this, _ret);
        }

        FixedTable.prototype.getChildContext = function getChildContext() {
            return {
                fixedHeader: this.props.fixedHeader,
                maxBodyHeight: this.props.maxBodyHeight,
                onBodyScroll: this.onBodyScroll,
                getNode: this.getNode
            };
        };

        FixedTable.prototype.componentDidMount = function componentDidMount() {
            this.adjustFixedHeaderSize();
        };

        FixedTable.prototype.componentDidUpdate = function componentDidUpdate() {
            this.adjustFixedHeaderSize();
        };

        FixedTable.prototype.adjustFixedHeaderSize = function adjustFixedHeaderSize() {
            var _props = this.props,
                hasHeader = _props.hasHeader,
                fixedHeader = _props.fixedHeader,
                maxBodyHeight = _props.maxBodyHeight;

            if (hasHeader && fixedHeader && !this.props.lockType) {
                if (this.bodyNode.scrollHeight <= maxBodyHeight) {
                    _util.dom.setStyle(this.headerNode, 'paddingRight', 0);
                } else {
                    _util.dom.setStyle(this.headerNode, 'paddingRight', _util.dom.scrollbar().width);
                }
            }
        };

        FixedTable.prototype.scrollTo = function scrollTo(x) {
            if (this.innerHeaderNode) {
                this.innerHeaderNode.scrollLeft = x;
            }
        };

        FixedTable.prototype.render = function render() {
            /* eslint-disable no-unused-vars, prefer-const */
            var _props2 = this.props,
                components = _props2.components,
                className = _props2.className,
                prefix = _props2.prefix,
                fixedHeader = _props2.fixedHeader,
                maxBodyHeight = _props2.maxBodyHeight,
                others = _objectWithoutProperties(_props2, ['components', 'className', 'prefix', 'fixedHeader', 'maxBodyHeight']);

            if (fixedHeader) {
                var _classnames;

                components = _extends({}, components);
                if (!components.Header) {
                    components.Header = _header2.default;
                }
                if (!components.Body) {
                    components.Body = _body2.default;
                }
                if (!components.Wrapper) {
                    components.Wrapper = _wrapper2.default;
                }
                className = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-fixed'] = true, _classnames[className] = className, _classnames));
            }
            return _react2.default.createElement(BaseComponent, _extends({}, others, { components: components, className: className, prefix: prefix }));
        };

        return FixedTable;
    }(_react2.default.Component), _class.FixedHeader = _header2.default, _class.FixedBody = _body2.default, _class.FixedWrapper = _wrapper2.default, _class.propTypes = _extends({
        /**
          * 是否具有表头
          */
        hasHeader: _propTypes2.default.bool,
        /**
          * 表头是否固定，该属性配合maxBodyHeight使用，当内容区域的高度超过maxBodyHeight的时候，在内容区域会出现滚动条
          */
        fixedHeader: _propTypes2.default.bool,
        /**
         * 最大内容区域的高度,在`fixedHeader`为`true`的时候,超过这个高度会出现滚动条
         */
        maxBodyHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string])
    }, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps, {
        hasHeader: true,
        fixedHeader: false,
        maxBodyHeight: 200,
        components: {},
        refs: {},
        prefix: 'next-'
    }), _class.childContextTypes = {
        fixedHeader: _propTypes2.default.bool,
        maxBodyHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
        onBodyScroll: _propTypes2.default.func,
        getNode: _propTypes2.default.func
    }, _temp2);
    FixedTable.displayName = 'FixedTable';

    (0, _util2.statics)(FixedTable, BaseComponent);
    return FixedTable;
}
module.exports = exports['default'];

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = selection;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _checkbox = __webpack_require__(37);

var _checkbox2 = _interopRequireDefault(_checkbox);

var _radio = __webpack_require__(61);

var _radio2 = _interopRequireDefault(_radio);

var _util = __webpack_require__(2);

var _zhCn = __webpack_require__(35);

var _zhCn2 = _interopRequireDefault(_zhCn);

var _row = __webpack_require__(64);

var _row2 = _interopRequireDefault(_row);

var _column = __webpack_require__(23);

var _column2 = _interopRequireDefault(_column);

var _util2 = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var makeChain = _util.func.makeChain;


var unique = function unique(arr) {
    var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'this';

    var temp = {},
        ret = [];
    arr.forEach(function (item) {
        var value = void 0;
        if (key === 'this') {
            value = item;
        } else {
            value = item[key];
        }
        if (!temp[value]) {
            ret.push(item);
            temp[value] = true;
        }
    });
    return ret;
};

function selection(BaseComponent) {
    var _class, _temp;

    /** Table */
    var SelectionTable = (_temp = _class = function (_React$Component) {
        _inherits(SelectionTable, _React$Component);

        function SelectionTable(props, context) {
            _classCallCheck(this, SelectionTable);

            var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

            _this.renderSelectionHeader = function () {
                var onChange = _this.selectAllRow,
                    attrs = {},
                    _this$props = _this.props,
                    rowSelection = _this$props.rowSelection,
                    primaryKey = _this$props.primaryKey,
                    dataSource = _this$props.dataSource,
                    locale = _this$props.locale,
                    selectedRowKeys = _this.state.selectedRowKeys,
                    mode = rowSelection.mode ? rowSelection.mode : 'multiple';

                var checked = !!selectedRowKeys.length;
                var indeterminate = false;
                _this.flatDataSource(dataSource).filter(function (record, index) {
                    if (!rowSelection.getProps) {
                        return true;
                    } else {
                        return !(rowSelection.getProps(record, index) || {}).disabled;
                    }
                }).map(function (record) {
                    return record[primaryKey];
                }).forEach(function (id) {
                    if (selectedRowKeys.indexOf(id) === -1) {
                        checked = false;
                    } else {
                        indeterminate = true;
                    }
                });
                attrs.onClick = makeChain(function (e) {
                    e.stopPropagation();
                }, attrs.onClick);

                if (checked) {
                    indeterminate = false;
                }
                return mode === 'multiple' ? _react2.default.createElement(_checkbox2.default, _extends({ indeterminate: indeterminate, 'aria-label': locale.selectAll, checked: checked, onChange: onChange }, attrs)) : null;
            };

            _this.renderSelectionBody = function (value, index, record) {
                var _this$props2 = _this.props,
                    rowSelection = _this$props2.rowSelection,
                    primaryKey = _this$props2.primaryKey;
                var selectedRowKeys = _this.state.selectedRowKeys;

                var mode = rowSelection.mode ? rowSelection.mode : 'multiple';
                var checked = selectedRowKeys.indexOf(record[primaryKey]) > -1;
                var onChange = _this.selectOneRow.bind(_this, index, record);
                var attrs = rowSelection.getProps ? rowSelection.getProps(record, index) || {} : {};

                attrs.onClick = makeChain(function (e) {
                    e.stopPropagation();
                }, attrs.onClick);
                return mode === 'multiple' ? _react2.default.createElement(_checkbox2.default, _extends({ checked: checked, onChange: onChange }, attrs)) : _react2.default.createElement(_radio2.default, _extends({ checked: checked, onChange: onChange }, attrs));
            };

            _this.selectAllRow = function (checked, e) {
                var ret = [].concat(_this.state.selectedRowKeys),
                    _this$props3 = _this.props,
                    rowSelection = _this$props3.rowSelection,
                    primaryKey = _this$props3.primaryKey,
                    dataSource = _this$props3.dataSource,
                    entireDataSource = _this$props3.entireDataSource,
                    selectedRowKeys = _this.state.selectedRowKeys,
                    getProps = rowSelection.getProps;

                var attrs = {},
                    records = [];

                var source = entireDataSource ? entireDataSource : dataSource;

                _this.flatDataSource(source).forEach(function (record, index) {
                    var id = record[primaryKey];
                    if (getProps) {
                        attrs = getProps(record, index) || {};
                    }
                    // 反选和全选的时候不要丢弃禁用项的选中状态
                    if (checked && (!attrs.disabled || selectedRowKeys.indexOf(id) > -1)) {
                        ret.push(id);
                        records.push(record);
                    } else if (attrs.disabled && selectedRowKeys.indexOf(id) > -1) {
                        ret.push(id);
                        records.push(record);
                    } else {
                        var i = ret.indexOf(id);
                        i > -1 && ret.splice(i, 1);
                    }
                });

                records = unique(records, primaryKey);
                if (typeof rowSelection.onSelectAll === 'function') {
                    rowSelection.onSelectAll(checked, records);
                }
                _this.triggerSelection(rowSelection, unique(ret), records);
                e.stopPropagation();
            };

            _this.state = {
                selectedRowKeys: props.rowSelection && 'selectedRowKeys' in props.rowSelection ? props.rowSelection.selectedRowKeys || [] : []
            };
            return _this;
        }

        SelectionTable.prototype.getChildContext = function getChildContext() {
            return {
                rowSelection: this.props.rowSelection,
                selectedRowKeys: this.state.selectedRowKeys
            };
        };

        SelectionTable.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
            if (nextProps.rowSelection && 'selectedRowKeys' in nextProps.rowSelection) {
                var selectedRowKeys = nextProps.rowSelection.selectedRowKeys || [];
                this.setState({
                    selectedRowKeys: selectedRowKeys
                });
            }
        };

        SelectionTable.prototype.normalizeChildren = function normalizeChildren(children) {
            var _props = this.props,
                prefix = _props.prefix,
                rowSelection = _props.rowSelection;

            if (rowSelection) {
                children = _react.Children.map(children, function (child, index) {
                    return _react2.default.cloneElement(child, {
                        key: index
                    });
                });
                children.unshift(_react2.default.createElement(_column2.default, { key: 'selection', title: this.renderSelectionHeader.bind(this),
                    cell: this.renderSelectionBody.bind(this),
                    width: 50,
                    className: prefix + 'table-selection', __normalized: true }));
                return children;
            }
            return children;
        };

        SelectionTable.prototype.selectOneRow = function selectOneRow(index, record, checked, e) {
            var selectedRowKeys = [].concat(this.state.selectedRowKeys),
                i = void 0;
            var _props2 = this.props,
                primaryKey = _props2.primaryKey,
                rowSelection = _props2.rowSelection,
                dataSource = _props2.dataSource,
                mode = rowSelection.mode ? rowSelection.mode : 'multiple',
                id = record[primaryKey];

            if (!id) {
                _util.log.warning('Can\'t get value from record using given ' + primaryKey + ' as primaryKey.');
            }
            if (mode === 'multiple') {
                if (checked) {
                    selectedRowKeys.push(id);
                } else {
                    i = selectedRowKeys.indexOf(id);
                    selectedRowKeys.splice(i, 1);
                }
            } else if (checked) {
                selectedRowKeys = [id];
            }
            var records = unique(dataSource.filter(function (item) {
                return selectedRowKeys.indexOf(item[primaryKey]) > -1;
            }), primaryKey);
            if (typeof rowSelection.onSelect === 'function') {
                rowSelection.onSelect(checked, record, records);
            }

            this.triggerSelection(rowSelection, selectedRowKeys, records);

            e.stopPropagation();
        };

        SelectionTable.prototype.triggerSelection = function triggerSelection(rowSelection, selectedRowKeys, records) {
            if (!('selectedRowKeys' in rowSelection)) {
                this.setState({
                    selectedRowKeys: selectedRowKeys
                });
            }
            if (typeof rowSelection.onChange === 'function') {
                rowSelection.onChange(selectedRowKeys, records);
            }
        };

        SelectionTable.prototype.flatDataSource = function flatDataSource(dataSource) {
            var ret = dataSource;
            var listHeader = this.context.listHeader;


            if (listHeader) {
                ret = [];
                var hasChildrenSelection = listHeader.hasChildrenSelection,
                    hasSelection = listHeader.hasSelection;

                dataSource.forEach(function (item) {
                    var children = item.children;
                    // 如果需要渲染selection才将这条记录插入到dataSource
                    // 或者没有孩子节点
                    if (hasSelection) {
                        ret.push(item);
                    }
                    if (children && hasChildrenSelection) {
                        ret = ret.concat(children);
                    }
                });
            }
            return ret;
        };

        SelectionTable.prototype.render = function render() {
            /* eslint-disable prefer-const */
            var _props3 = this.props,
                rowSelection = _props3.rowSelection,
                components = _props3.components,
                children = _props3.children,
                others = _objectWithoutProperties(_props3, ['rowSelection', 'components', 'children']);

            if (rowSelection) {
                children = this.normalizeChildren(children);
                components = _extends({}, components);
                components.Row = components.Row || _row2.default;
            }
            return _react2.default.createElement(
                BaseComponent,
                _extends({}, others, { components: components }),
                children
            );
        };

        return SelectionTable;
    }(_react2.default.Component), _class.SelectionRow = _row2.default, _class.propTypes = _extends({
        /**
        * 是否启用选择模式
        * @property {Function} getProps `Function(record, index)=>Object` 获取selection的默认属性
        * @property {Function} onChange `Function(selectedRowKeys:Array, records:Array)` 选择改变的时候触发的事件，**注意:** 其中records只会包含当前dataSource的数据，很可能会小于selectedRowKeys的长度。
        * @property {Function} onSelect `Function(selected:Boolean, record:Object, records:Array)` 用户手动选择/取消选择某行的回调
        * @property {Function} onSelectAll `Function(selected:Boolean, records:Array)` 用户手动选择/取消选择所有行的回调
        * @property {Array} selectedRowKeys 设置了此属性,将rowSelection变为受控状态,接收值为该行数据的primaryKey的值
        * @property {String} mode 选择selection的模式, 可选值为`single`, `multiple`，默认为`multiple`
        */
        rowSelection: _propTypes2.default.object,
        primaryKey: _propTypes2.default.string,
        dataSource: _propTypes2.default.array,
        entireDataSource: _propTypes2.default.array
    }, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps, {
        locale: _zhCn2.default.Table,
        primaryKey: 'id',
        prefix: 'next-'
    }), _class.contextTypes = {
        listHeader: _propTypes2.default.any
    }, _class.childContextTypes = {
        rowSelection: _propTypes2.default.object,
        selectedRowKeys: _propTypes2.default.array
    }, _temp);
    SelectionTable.displayName = 'SelectionTable';

    (0, _util2.statics)(SelectionTable, BaseComponent);
    return SelectionTable;
}
module.exports = exports['default'];

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = expanded;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

var _row = __webpack_require__(65);

var _row2 = _interopRequireDefault(_row);

var _column = __webpack_require__(23);

var _column2 = _interopRequireDefault(_column);

var _util2 = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};

function expanded(BaseComponent) {
    var _class, _temp2;

    /** Table */
    var ExpandedTable = (_temp2 = _class = function (_React$Component) {
        _inherits(ExpandedTable, _React$Component);

        function ExpandedTable() {
            var _temp, _this, _ret;

            _classCallCheck(this, ExpandedTable);

            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
                openRowKeys: _this.props.openRowKeys || []
            }, _this.expandedKeydown = function (value, record, index, e) {
                e.preventDefault();
                e.stopPropagation();

                if (e.keyCode === _util.KEYCODE.ENTER) {
                    _this.onExpandedClick(value, record, index, e);
                }
            }, _this.renderExpandedCell = function (value, index, record) {
                var _classnames;

                var _this$props = _this.props,
                    getExpandedColProps = _this$props.getExpandedColProps,
                    prefix = _this$props.prefix,
                    locale = _this$props.locale;
                var openRowKeys = _this.state.openRowKeys,
                    primaryKey = _this.props.primaryKey,
                    hasExpanded = openRowKeys.indexOf(record[primaryKey]) > -1,
                    switchNode = hasExpanded ? _react2.default.createElement(_icon2.default, { type: 'minus', size: 'xs' }) : _react2.default.createElement(_icon2.default, { type: 'add', size: 'xs' }),
                    attrs = getExpandedColProps(record, index) || {};

                var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-expanded-ctrl'] = true, _classnames.disabled = attrs.disabled, _classnames[attrs.className] = attrs.className, _classnames));

                if (!attrs.disabled) {
                    attrs.onClick = _this.onExpandedClick.bind(_this, value, record, index);
                }
                return _react2.default.createElement(
                    'span',
                    _extends({}, attrs, {
                        role: 'button',
                        tabIndex: '0',
                        onKeyDown: _this.expandedKeydown.bind(_this, value, record, index),
                        'aria-label': hasExpanded ? locale.expanded : locale.folded,
                        'aria-expanded': hasExpanded,
                        className: cls }),
                    switchNode
                );
            }, _temp), _possibleConstructorReturn(_this, _ret);
        }

        ExpandedTable.prototype.getChildContext = function getChildContext() {
            return {
                openRowKeys: this.state.openRowKeys,
                expandedRowRender: this.props.expandedRowRender,
                expandedRowIndent: this.props.expandedRowIndent
            };
        };

        ExpandedTable.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
            if ('openRowKeys' in nextProps) {
                var openRowKeys = nextProps.openRowKeys;

                this.setState({
                    openRowKeys: openRowKeys
                });
            }
        };

        ExpandedTable.prototype.onExpandedClick = function onExpandedClick(value, record, i, e) {
            var openRowKeys = [].concat(this.state.openRowKeys),
                primaryKey = this.props.primaryKey,
                id = record[primaryKey],
                index = openRowKeys.indexOf(id);

            if (index > -1) {
                openRowKeys.splice(index, 1);
            } else {
                openRowKeys.push(id);
            }
            if (!('openRowKeys' in this.props)) {
                this.setState({
                    openRowKeys: openRowKeys
                });
            }
            this.props.onRowOpen(openRowKeys, id, index === -1, record);
            e.stopPropagation();
        };

        ExpandedTable.prototype.normalizeChildren = function normalizeChildren(children) {
            var toArrayChildren = _react.Children.map(children, function (child, index) {
                return _react2.default.cloneElement(child, {
                    key: index
                });
            });
            var prefix = this.props.prefix;

            toArrayChildren.unshift(_react2.default.createElement(_column2.default, { title: '', key: 'expanded', cell: this.renderExpandedCell.bind(this), width: 50, className: prefix + 'table-expanded', __normalized: true }));
            return toArrayChildren;
        };

        ExpandedTable.prototype.normalizeDataSource = function normalizeDataSource(ds) {
            var ret = [];
            ds.forEach(function (item) {
                var itemCopy = _extends({}, item);
                itemCopy.__expanded = true;
                ret.push(item, itemCopy);
            });
            return ret;
        };

        ExpandedTable.prototype.render = function render() {
            /* eslint-disable no-unused-vars, prefer-const */
            var _props = this.props,
                components = _props.components,
                openRowKeys = _props.openRowKeys,
                expandedRowRender = _props.expandedRowRender,
                hasExpandedRowCtrl = _props.hasExpandedRowCtrl,
                children = _props.children,
                dataSource = _props.dataSource,
                getExpandedColProps = _props.getExpandedColProps,
                expandedRowIndent = _props.expandedRowIndent,
                onRowOpen = _props.onRowOpen,
                onExpandedRowClick = _props.onExpandedRowClick,
                others = _objectWithoutProperties(_props, ['components', 'openRowKeys', 'expandedRowRender', 'hasExpandedRowCtrl', 'children', 'dataSource', 'getExpandedColProps', 'expandedRowIndent', 'onRowOpen', 'onExpandedRowClick']);

            if (expandedRowRender && !components.Row) {
                components = _extends({}, components);
                components.Row = _row2.default;
                dataSource = this.normalizeDataSource(dataSource);
            }
            if (expandedRowRender && hasExpandedRowCtrl) {
                children = this.normalizeChildren(children);
            }

            return _react2.default.createElement(
                BaseComponent,
                _extends({}, others, { dataSource: dataSource, components: components }),
                children
            );
        };

        return ExpandedTable;
    }(_react2.default.Component), _class.ExpandedRow = _row2.default, _class.propTypes = _extends({
        /**
         * 额外渲染行的渲染函数
         * @param {Object} record 该行所对应的数据
         * @param {Number} index 该行所对应的序列
         * @returns {Element}
         */
        expandedRowRender: _propTypes2.default.func,
        /**
         * 额外渲染行的缩进
         */
        expandedRowIndent: _propTypes2.default.array,
        /**
         * 默认情况下展开的渲染行或者Tree, 传入此属性为受控状态
         */
        openRowKeys: _propTypes2.default.array,
        /**
         * 是否显示点击展开额外渲染行的+号按钮
         */
        hasExpandedRowCtrl: _propTypes2.default.bool,
        /**
         * 设置额外渲染行的属性
         */
        getExpandedColProps: _propTypes2.default.func,
        /**
         * 在额外渲染行或者Tree展开或者收起的时候触发的事件
         * @param {Array} openRowKeys 展开的渲染行的key
         * @param {String} currentRowKey 当前点击的渲染行的key
         * @param {Boolean} expanded 当前点击是展开还是收起
         * @param {Object} currentRecord 当前点击额外渲染行的记录
         */
        onRowOpen: _propTypes2.default.func,
        /**
         * 点击额外渲染行触发的事件
         * @param {Object} record 该行所对应的数据
         * @param {Number} index 该行所对应的序列
         * @param {Event} e DOM事件对象
         */
        onExpandedRowClick: _propTypes2.default.func,
        locale: _propTypes2.default.object
    }, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps, {
        getExpandedColProps: noop,
        onRowOpen: noop,
        hasExpandedRowCtrl: true,
        components: {},
        expandedRowIndent: [1, 0],
        prefix: 'next-'
    }), _class.childContextTypes = {
        openRowKeys: _propTypes2.default.array,
        expandedRowRender: _propTypes2.default.func,
        expandedRowIndent: _propTypes2.default.array
    }, _temp2);
    ExpandedTable.displayName = 'ExpandedTable';

    (0, _util2.statics)(ExpandedTable, BaseComponent);
    return ExpandedTable;
}
module.exports = exports['default'];

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = virtual;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

var _body = __webpack_require__(130);

var _body2 = _interopRequireDefault(_body);

var _util2 = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};
function virtual(BaseComponent) {
    var _class, _temp2;

    var VirtualTable = (_temp2 = _class = function (_React$Component) {
        _inherits(VirtualTable, _React$Component);

        function VirtualTable() {
            var _temp, _this, _ret;

            _classCallCheck(this, VirtualTable);

            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
                rowHeight: _this.props.rowHeight,
                scrollToRow: _this.props.scrollToRow,
                height: _this.props.maxBodyHeight
            }, _this.onScroll = function () {
                // 避免横向滚动带来的性能问题
                var scrollTop = _this.bodyNode.scrollTop;
                if (scrollTop === _this.lastScrollTop) {
                    return;
                }
                var start = _this.computeScrollToRow(scrollTop);
                if (!('scrollToRow' in _this.props)) {
                    _this.setState({
                        scrollToRow: start
                    });
                }
                _this.props.onBodyScroll(start);
                _this.lastScrollTop = scrollTop;
            }, _this.getBodyNode = function (node, lockType) {
                lockType = lockType ? lockType.charAt(0).toUpperCase() + lockType.substr(1) : '';
                _this['body' + lockType + 'Node'] = node;
            }, _this.getTableInstance = function (type, instance) {
                type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';
                _this['table' + type + 'Inc'] = instance;
            }, _temp), _possibleConstructorReturn(_this, _ret);
        }

        VirtualTable.prototype.getChildContext = function getChildContext() {
            return {
                onVirtualScroll: this.onScroll,
                bodyHeight: this.computeBodyHeight(),
                innerTop: this.computeInnerTop(),
                getBodyNode: this.getBodyNode,
                getTableInstanceForVirtual: this.getTableInstance,
                rowSelection: this.rowSelection
            };
        };

        VirtualTable.prototype.componentWillMount = function componentWillMount() {
            var _props = this.props,
                useVirtual = _props.useVirtual,
                dataSource = _props.dataSource;


            this.hasVirtualData = useVirtual && dataSource && dataSource.length > 0;
        };

        VirtualTable.prototype.componentDidMount = function componentDidMount() {

            if (this.hasVirtualData) {
                this.lastScrollTop = this.bodyNode.scrollTop;
            }

            this.adjustScrollTop();
            this.adjustSize();
            this.reComputeSize();
        };

        VirtualTable.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
            var useVirtual = nextProps.useVirtual,
                dataSource = nextProps.dataSource;


            this.hasVirtualData = useVirtual && dataSource && dataSource.length > 0;

            if ('maxBodyHeight' in nextProps) {
                if (this.state.height !== nextProps.maxBodyHeight) {
                    this.setState({
                        height: nextProps.maxBodyHeight
                    });
                }
            }

            if ('scrollToRow' in nextProps) {
                this.setState({
                    scrollToRow: nextProps.scrollToRow
                });
            }

            if (this.state.rowHeight && 'rowHeight' in nextProps) {
                var row = this.getRowNode();
                var rowClientHeight = row && row.clientHeight;
                if (rowClientHeight && rowClientHeight !== this.state.rowHeight) {
                    this.setState({
                        rowHeight: rowClientHeight
                    });
                }
            }
        };

        VirtualTable.prototype.componentDidUpdate = function componentDidUpdate() {
            this.adjustScrollTop();
            this.adjustSize();
            this.reComputeSize();
        };

        VirtualTable.prototype.reComputeSize = function reComputeSize() {
            var rowHeight = this.state.rowHeight;

            if (typeof rowHeight === 'function' && this.hasVirtualData) {
                var row = this.getRowNode();
                var rowClientHeight = row && row.clientHeight;
                if (rowClientHeight !== this.state.rowHeight) {
                    this.setState({
                        rowHeight: rowClientHeight
                    });
                }
            }
        };

        VirtualTable.prototype.computeBodyHeight = function computeBodyHeight() {
            var rowHeight = this.state.rowHeight;
            var dataSource = this.props.dataSource;

            if (typeof rowHeight === 'function') {
                return 0;
            }
            return dataSource.length * rowHeight;
        };

        VirtualTable.prototype.computeInnerTop = function computeInnerTop() {
            var rowHeight = this.state.rowHeight;

            if (typeof rowHeight === 'function') {
                return 0;
            }
            return this.start * rowHeight;
        };

        VirtualTable.prototype.getVisibleRange = function getVisibleRange(ExpectStart) {
            var _state = this.state,
                height = _state.height,
                rowHeight = _state.rowHeight;

            var len = this.props.dataSource.length;

            var end = void 0,
                visibleCount = 0;
            var start = 0;
            if (typeof rowHeight === 'function') {
                // try get cell height;
                end = 1;
            } else {
                visibleCount = parseInt(height / rowHeight, 10);

                if ('number' === typeof ExpectStart) {
                    start = ExpectStart < len ? ExpectStart : 0;
                }

                end = Math.min(+start + 1 + visibleCount + 10, len);
            }
            this.end = end;
            this.visibleCount = visibleCount;
            return {
                start: start,
                end: end
            };
        };

        VirtualTable.prototype.adjustScrollTop = function adjustScrollTop() {
            if (this.hasVirtualData) {
                this.bodyNode.scrollTop = this.lastScrollTop % this.state.rowHeight + this.state.rowHeight * this.state.scrollToRow;
            }
        };

        VirtualTable.prototype.adjustSize = function adjustSize() {
            if (this.hasVirtualData) {
                var body = this.bodyNode;
                var virtualScrollNode = body.querySelector('div');
                var clientHeight = body.clientHeight,
                    clientWidth = body.clientWidth;


                var tableInc = this.tableInc;
                var tableNode = (0, _reactDom.findDOMNode)(tableInc);
                var prefix = this.props.prefix;

                var headerNode = tableNode.querySelector('.' + prefix + 'table-header table');
                var headerClientWidth = headerNode && headerNode.clientWidth;

                if (clientWidth < headerClientWidth) {
                    _util.dom.setStyle(virtualScrollNode, 'min-width', headerClientWidth);
                    var leftNode = this.bodyLeftNode;
                    var rightNode = this.bodyRightNode;
                    leftNode && _util.dom.setStyle(leftNode, 'max-height', clientHeight);
                    rightNode && _util.dom.setStyle(rightNode, 'max-height', clientHeight);
                    this.hasScrollbar = true;
                } else {
                    this.hasScrollbar = false;
                }
            }
        };

        VirtualTable.prototype.computeScrollToRow = function computeScrollToRow(offset) {
            var rowHeight = this.state.rowHeight;

            var start = parseInt(offset / rowHeight);
            this.start = start;
            return start;
        };

        VirtualTable.prototype.getRowNode = function getRowNode() {
            try {
                // in case of finding an unmounted component due to cached data
                // need to clear refs of this.tableInc when dataSource Changed
                // use try catch for temporary
                return (0, _reactDom.findDOMNode)(this.tableInc.getRowRef(0));
            } catch (error) {
                return null;
            }
        };

        VirtualTable.prototype.render = function render() {
            /* eslint-disable no-unused-vars, prefer-const */
            var _props2 = this.props,
                useVirtual = _props2.useVirtual,
                components = _props2.components,
                dataSource = _props2.dataSource,
                fixedHeader = _props2.fixedHeader,
                rowHeight = _props2.rowHeight,
                scrollToRow = _props2.scrollToRow,
                onBodyScroll = _props2.onBodyScroll,
                others = _objectWithoutProperties(_props2, ['useVirtual', 'components', 'dataSource', 'fixedHeader', 'rowHeight', 'scrollToRow', 'onBodyScroll']);

            var entireDataSource = dataSource;

            this.rowSelection = this.props.rowSelection;
            if (this.hasVirtualData) {
                components = _extends({}, components);

                var _getVisibleRange = this.getVisibleRange(this.state.scrollToRow),
                    start = _getVisibleRange.start,
                    end = _getVisibleRange.end;

                dataSource = dataSource.slice(start, end);

                if (!components.Body) {
                    components.Body = _body2.default;
                }
                fixedHeader = true;
            }

            return _react2.default.createElement(BaseComponent, _extends({}, others, { dataSource: dataSource, entireDataSource: entireDataSource, components: components, fixedHeader: fixedHeader }));
        };

        return VirtualTable;
    }(_react2.default.Component), _class.VirtualBody = _body2.default, _class.propTypes = _extends({
        /**
         * 是否开启虚拟滚动
         */
        useVirtual: _propTypes2.default.bool,
        /**
         * 设置行高
         */
        rowHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.func]),
        maxBodyHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
        primaryKey: _propTypes2.default.string,
        dataSource: _propTypes2.default.array,
        /**
         * 在内容区域滚动的时候触发的函数
         */
        onBodyScroll: _propTypes2.default.func
    }, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps, {
        primaryKey: 'id',
        rowHeight: noop,
        maxBodyHeight: 200,
        components: {},
        prefix: 'next-',
        onBodyScroll: noop
    }), _class.childContextTypes = {
        onVirtualScroll: _propTypes2.default.func,
        bodyHeight: _propTypes2.default.number,
        innerTop: _propTypes2.default.number,
        getBodyNode: _propTypes2.default.func,
        getTableInstanceForVirtual: _propTypes2.default.func,
        rowSelection: _propTypes2.default.object
    }, _temp2);
    VirtualTable.displayName = 'VirtualTable';

    (0, _util2.statics)(VirtualTable, BaseComponent);
    return VirtualTable;
}
module.exports = exports['default'];

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _body = __webpack_require__(16);

var _body2 = _interopRequireDefault(_body);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var VirtualBody = (_temp2 = _class = function (_React$Component) {
    _inherits(VirtualBody, _React$Component);

    function VirtualBody() {
        var _temp, _this, _ret;

        _classCallCheck(this, VirtualBody);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.tableRef = function (table) {
            _this.tableNode = table;
        }, _this.virtualScrollRef = function (virtualScroll) {
            _this.virtualScrollNode = virtualScroll;
        }, _this.onScroll = function () {
            // for fixed
            _this.context.onBodyScroll();
            // for lock
            _this.context.onLockBodyScroll();
            // for virtual
            _this.context.onVirtualScroll();
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    VirtualBody.prototype.componentDidMount = function componentDidMount() {
        var bodyNode = (0, _reactDom.findDOMNode)(this);
        // // for fixed
        this.context.getNode('body', bodyNode);
        // for virtual
        this.context.getBodyNode(bodyNode, this.context.lockType);
        // for lock
        this.context.getLockNode('body', bodyNode, this.context.lockType);
    };

    VirtualBody.prototype.render = function render() {
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            colGroup = _props.colGroup,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'colGroup']);

        var _context = this.context,
            maxBodyHeight = _context.maxBodyHeight,
            bodyHeight = _context.bodyHeight,
            innerTop = _context.innerTop;

        return _react2.default.createElement(
            'div',
            { style: { maxHeight: maxBodyHeight }, className: className, onScroll: this.onScroll },
            _react2.default.createElement(
                'div',
                { style: { height: bodyHeight, overflow: 'hidden', position: 'relative' }, ref: this.virtualScrollRef },
                _react2.default.createElement(
                    'div',
                    { style: { height: '100%', position: 'relative', transform: 'translateY(' + innerTop + 'px)' } },
                    _react2.default.createElement(
                        'table',
                        { ref: this.tableRef },
                        colGroup,
                        _react2.default.createElement(_body2.default, _extends({}, others, { prefix: prefix }))
                    )
                )
            )
        );
    };

    return VirtualBody;
}(_react2.default.Component), _class.propTypes = {
    children: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    className: _propTypes2.default.string,
    colGroup: _propTypes2.default.any
}, _class.contextTypes = {
    maxBodyHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    onBodyScroll: _propTypes2.default.func,
    onVirtualScroll: _propTypes2.default.func,
    onLockBodyScroll: _propTypes2.default.func,
    bodyHeight: _propTypes2.default.number,
    innerTop: _propTypes2.default.number,
    getNode: _propTypes2.default.func,
    getBodyNode: _propTypes2.default.func,
    getLockNode: _propTypes2.default.func,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}, _temp2);
VirtualBody.displayName = 'VirtualBody';
exports.default = VirtualBody;
module.exports = exports['default'];

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = lock;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _shallowElementEquals = __webpack_require__(44);

var _shallowElementEquals2 = _interopRequireDefault(_shallowElementEquals);

var _util = __webpack_require__(2);

var _row = __webpack_require__(66);

var _row2 = _interopRequireDefault(_row);

var _body = __webpack_require__(132);

var _body2 = _interopRequireDefault(_body);

var _header = __webpack_require__(133);

var _header2 = _interopRequireDefault(_header);

var _wrapper = __webpack_require__(24);

var _wrapper2 = _interopRequireDefault(_wrapper);

var _util2 = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function lock(BaseComponent) {
    var _class, _temp;

    /** Table */
    var LockTable = (_temp = _class = function (_React$Component) {
        _inherits(LockTable, _React$Component);

        function LockTable(props, context) {
            _classCallCheck(this, LockTable);

            var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

            _this.getTableInstance = function (type, instance) {
                type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';
                _this['table' + type + 'Inc'] = instance;
            };

            _this.getNode = function (type, node, lockType) {
                lockType = lockType ? lockType.charAt(0).toUpperCase() + lockType.substr(1) : '';
                _this['' + type + lockType + 'Node'] = node;
                if (type === 'header' && !_this.innerHeaderNode && !lockType) {
                    _this.innerHeaderNode = _this.headerNode.querySelector('div');
                }
            };

            _this.onRowMouseEnter = function (record, index) {
                if (_this.isLock()) {
                    var row = _this.getRowNode(index);
                    var leftRow = _this.getRowNode(index, 'left');
                    var rightRow = _this.getRowNode(index, 'right');
                    [row, leftRow, rightRow].forEach(function (row) {
                        row && _util.dom.addClass(row, 'hovered');
                    });
                }
            };

            _this.onRowMouseLeave = function (record, index) {
                if (_this.isLock()) {
                    var row = _this.getRowNode(index);
                    var leftRow = _this.getRowNode(index, 'left');
                    var rightRow = _this.getRowNode(index, 'right');
                    [row, leftRow, rightRow].forEach(function (row) {
                        row && _util.dom.removeClass(row, 'hovered');
                    });
                }
            };

            _this.onLockBodyWheel = function (e) {
                var y = e.deltaY;
                if (_this.isLock()) {
                    var lockRightBody = _this.bodyRightNode,
                        lockLeftBody = _this.bodyLeftNode,
                        scrollNode = _this.bodyNode,
                        scrollTop = scrollNode.scrollTop,
                        clientHeight = scrollNode.clientHeight,
                        scrollHeight = scrollNode.scrollHeight;


                    if (lockLeftBody) {
                        lockLeftBody.scrollTop = y;
                    }
                    if (lockRightBody) {
                        lockRightBody.scrollTop = y;
                    }
                    scrollNode.scrollTop = scrollTop + y;
                    var newScrollTop = scrollNode.scrollTop;

                    if (newScrollTop + clientHeight < scrollHeight && newScrollTop) {
                        e.preventDefault();
                    }
                }
            };

            _this.onLockBodyScroll = function () {
                if (_this.isLock()) {
                    var lockRightBody = _this.bodyRightNode,
                        lockLeftBody = _this.bodyLeftNode,
                        lockRightTable = _this.getWrapperNode('right'),
                        lockLeftTable = _this.getWrapperNode('left'),
                        shadowClassName = 'shadow';

                    var x = _this.bodyNode.scrollLeft,
                        y = _this.bodyNode.scrollTop;

                    if (lockLeftBody) {
                        lockLeftBody.scrollTop = y;
                    }
                    if (lockRightBody) {
                        lockRightBody.scrollTop = y;
                    }
                    if (x === 0) {
                        lockLeftTable && _util.dom.removeClass(lockLeftTable, shadowClassName);
                        lockRightTable && _util.dom.addClass(lockRightTable, shadowClassName);
                    } else if (x === _this.bodyNode.scrollWidth - _this.bodyNode.clientWidth) {
                        lockLeftTable && _util.dom.addClass(lockLeftTable, shadowClassName);
                        lockRightTable && _util.dom.removeClass(lockRightTable, shadowClassName);
                    } else {
                        lockLeftTable && _util.dom.addClass(lockLeftTable, shadowClassName);
                        lockRightTable && _util.dom.addClass(lockRightTable, shadowClassName);
                    }
                }
            };

            _this.lockLeftChildren = [];
            _this.lockRightChildren = [];
            return _this;
        }

        LockTable.prototype.getChildContext = function getChildContext() {
            return {
                getTableInstance: this.getTableInstance,
                getLockNode: this.getNode,
                onLockBodyWheel: this.onLockBodyWheel,
                onLockBodyScroll: this.onLockBodyScroll,
                onRowMouseEnter: this.onRowMouseEnter,
                onRowMouseLeave: this.onRowMouseLeave
            };
        };

        LockTable.prototype.componentDidMount = function componentDidMount() {
            this.adjustSize = this.adjustSize.bind(this);

            this.adjustSize();
            this.scroll();

            _util.events.on(window, 'resize', this.adjustSize);
        };

        LockTable.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState, nextContext) {
            if (nextProps.pure) {
                var isEqual = (0, _shallowElementEquals2.default)(nextProps, this.props);
                return !(isEqual && _util.obj.shallowEqual(nextContext, this.context));
            }

            return true;
        };

        LockTable.prototype.componentWillUpdate = function componentWillUpdate() {
            this._isLock = false;
        };

        LockTable.prototype.componentDidUpdate = function componentDidUpdate() {
            this.adjustSize();
        };

        LockTable.prototype.componentWillUnmount = function componentWillUnmount() {
            _util.events.off(window, 'resize', this.adjustSize);
        };

        LockTable.prototype.normalizeChildrenState = function normalizeChildrenState(props) {
            var children = props.children;

            children = this.normalizeChildren(children);
            var splitChildren = this.splitFromNormalizeChildren(children);
            var lockLeftChildren = splitChildren.lockLeftChildren,
                lockRightChildren = splitChildren.lockRightChildren;

            return {
                lockLeftChildren: lockLeftChildren,
                lockRightChildren: lockRightChildren,
                children: this.mergeFromSplitLockChildren(splitChildren)
            };
        };

        // 将React结构化数据提取props转换成数组


        LockTable.prototype.normalizeChildren = function normalizeChildren(children) {
            var isLock = false;
            var getChildren = function getChildren(children) {
                var ret = [];
                _react.Children.forEach(children, function (child) {
                    if (child) {
                        var props = _extends({}, child.props);
                        if ([true, 'left', 'right'].indexOf(props.lock) > -1) {
                            isLock = true;
                            if (!('width' in props)) {
                                _util.log.warning('Should config width for lock column named [ ' + props.dataIndex + ' ].');
                            }
                        }
                        ret.push(props);
                        if (child.props.children) {
                            props.children = getChildren(child.props.children);
                        }
                    }
                });
                return ret;
            };
            var ret = getChildren(children);
            ret.forEach(function (child) {
                // 为自定义的列特殊处理
                if (child.__normalized && isLock) {
                    child.lock = 'left';
                    delete child.__normalized;
                }
            });
            this._isLock = isLock;
            return ret;
        };

        //从数组中分离出lock的列和正常的列


        LockTable.prototype.splitFromNormalizeChildren = function splitFromNormalizeChildren(children) {
            var originChildren = deepCopy(children);
            var lockLeftChildren = deepCopy(children);
            var lockRightChildren = deepCopy(children);
            var loop = function loop(lockChildren, condition) {
                var ret = [];
                lockChildren.forEach(function (child) {
                    if (child.children) {
                        var res = loop(child.children, condition);
                        if (!res.length) {
                            ret.push(child);
                        }
                    } else {
                        var order = condition(child);
                        if (!order) {
                            ret.push(child);
                        }
                    }
                });
                ret.forEach(function (res) {
                    var index = lockChildren.indexOf(res);
                    lockChildren.splice(index, 1);
                });
                return lockChildren;
            };
            loop(lockLeftChildren, function (child) {
                if (child.lock === true || child.lock === 'left') {
                    return 'left';
                }
            });
            loop(lockRightChildren, function (child) {
                if (child.lock === 'right') {
                    return 'right';
                }
            });
            loop(originChildren, function (child) {
                return child.lock !== true && child.lock !== 'left' && child.lock !== 'right';
            });
            return {
                lockLeftChildren: lockLeftChildren,
                lockRightChildren: lockRightChildren,
                originChildren: originChildren
            };
        };

        //将左侧的锁列树和中间的普通树及右侧的锁列树进行合并


        LockTable.prototype.mergeFromSplitLockChildren = function mergeFromSplitLockChildren(splitChildren) {
            var lockLeftChildren = splitChildren.lockLeftChildren,
                lockRightChildren = splitChildren.lockRightChildren;
            var originChildren = splitChildren.originChildren;

            Array.prototype.unshift.apply(originChildren, lockLeftChildren);
            originChildren = originChildren.concat(lockRightChildren);
            return originChildren;
        };

        LockTable.prototype.scroll = function scroll() {
            var _props = this.props,
                _props$scrollToCol = _props.scrollToCol,
                scrollToCol = _props$scrollToCol === undefined ? 0 : _props$scrollToCol,
                _props$scrollToRow = _props.scrollToRow,
                scrollToRow = _props$scrollToRow === undefined ? 0 : _props$scrollToRow;

            if (!scrollToCol && !scrollToRow) {
                return;
            }
            var colCellNode = this.getCellNode(0, scrollToCol);
            var rowCellNode = this.getCellNode(scrollToRow, 0);
            var bodyNodeOffset = this.bodyNode.getBoundingClientRect();
            if (colCellNode) {
                var cellNodeoffset = colCellNode.getBoundingClientRect();
                var scrollLeft = cellNodeoffset.left - bodyNodeOffset.left;
                this.bodyNode.scrollLeft = scrollLeft;
            }
            if (rowCellNode) {
                var _cellNodeoffset = rowCellNode.getBoundingClientRect();
                var scrollTop = _cellNodeoffset.top - bodyNodeOffset.top;
                this.bodyNode.scrollTop = scrollTop;
            }
        };

        // Table处理过后真实的lock状态
        LockTable.prototype.isLock = function isLock() {
            return this.lockLeftChildren.length || this.lockRightChildren.length;
        };

        // 用户设置的lock状态


        LockTable.prototype.isOriginLock = function isOriginLock() {
            return this._isLock;
        };

        LockTable.prototype.adjustSize = function adjustSize() {
            if (!this.adjustIfTableNotNeedLock()) {
                this.adjustHeaderSize();
                this.adjustBodySize();
                this.adjustCellSize();
                this.onLockBodyScroll();
            }
        };

        LockTable.prototype.adjustIfTableNotNeedLock = function adjustIfTableNotNeedLock() {
            var _this2 = this;

            if (this.isOriginLock() && this.tableInc.props.dataSource.length) {
                var configWidths = this.tableInc.flatChildren.map(function (item, index) {
                    var row = _this2.getCellNode(0, index);
                    return row && row.clientWidth || 0;
                }).reduce(function (a, b) {
                    return a + b;
                }, 0);

                var node = (0, _reactDom.findDOMNode)(this);
                var width = node.clientWidth;
                var lockLeftLen = this.lockLeftChildren.length;
                var lockRightLen = this.lockRightChildren.length;

                if (configWidths <= width && configWidths > 0) {
                    if (lockLeftLen) {
                        this._notNeedAdjustLockLeft = true;
                    }
                    if (lockRightLen) {
                        this._notNeedAdjustLockRight = true;
                    }
                    if (lockRightLen || lockLeftLen) {
                        this.forceUpdate();
                        return true;
                    }
                } else if (this._notNeedAdjustLockLeft || this._notNeedAdjustLockRight) {
                    this._notNeedAdjustLockLeft = this._notNeedAdjustLockRight = false;
                    this.forceUpdate();
                } else {
                    this._notNeedAdjustLockLeft = this._notNeedAdjustLockRight = false;
                    return false;
                }
            }

            return false;
        };

        LockTable.prototype.adjustBodySize = function adjustBodySize() {
            if (this.isLock()) {
                var body = this.bodyNode,
                    lockLeftBody = this.bodyLeftNode,
                    lockRightBody = this.bodyRightNode,
                    lockRightBodyWrapper = this.getWrapperNode('right'),
                    scrollbar = _util.dom.scrollbar(),
                    bodyHeight = body.offsetHeight,
                    hasHozScroll = body.scrollWidth > body.clientWidth,
                    hasVerScroll = body.scrollHeight > body.clientHeight,
                    width = hasVerScroll ? scrollbar.width : 0,
                    lockBodyHeight = bodyHeight - (hasHozScroll ? scrollbar.height : 0);

                lockLeftBody && _util.dom.setStyle(lockLeftBody, 'max-height', lockBodyHeight);
                lockRightBody && _util.dom.setStyle(lockRightBody, 'max-height', lockBodyHeight);
                lockRightBodyWrapper && _util.dom.setStyle(lockRightBodyWrapper, 'right', width);
            }
        };

        LockTable.prototype.adjustHeaderSize = function adjustHeaderSize() {
            var _this3 = this;

            if (this.isLock()) {
                this.tableInc.groupChildren.forEach(function (child, index) {
                    var lastIndex = _this3.tableInc.groupChildren[index].length - 1;
                    var headerRightRow = _this3.getHeaderCellNode(index, lastIndex),
                        headerLeftRow = _this3.getHeaderCellNode(index, 0),
                        headerRightLockRow = _this3.getHeaderCellNode(index, 0, 'right'),
                        headerLeftLockRow = _this3.getHeaderCellNode(index, 0, 'left');

                    if (headerRightRow && headerRightLockRow) {
                        var maxRightRowHeight = headerRightRow.offsetHeight;

                        _util.dom.setStyle(headerRightLockRow, 'height', maxRightRowHeight);

                        setTimeout(function () {
                            _this3.tableRightInc.affixRef && _this3.tableRightInc.affixRef.getInstance().updatePosition();
                        });
                    }

                    if (headerLeftRow && headerLeftLockRow) {
                        var maxLeftRowHeight = headerLeftRow.offsetHeight;

                        _util.dom.setStyle(headerLeftLockRow, 'height', maxLeftRowHeight);

                        setTimeout(function () {
                            _this3.tableLeftInc.affixRef && _this3.tableLeftInc.affixRef.getInstance().updatePosition();
                        });
                    }
                });
            }
        };

        LockTable.prototype.adjustCellSize = function adjustCellSize() {
            var _this4 = this;

            if (this.isLock()) {
                this.tableInc.props.dataSource.forEach(function (item, index) {
                    var lockLeftRow = _this4.getCellNode(index, 0, 'left'),
                        lockRightRow = _this4.getCellNode(index, 0, 'right'),
                        row = _this4.getFirstNormalCellNode(index),
                        rowHeight = row && parseFloat(getComputedStyle(row).height) || 0;
                    var lockLeftHeight = 0,
                        lockRightHeight = 0;

                    if (lockLeftRow) {
                        lockLeftHeight = lockLeftRow.offsetHeight;
                    }
                    if (lockRightRow) {
                        lockRightHeight = lockRightRow.offsetHeight;
                    }
                    if (lockLeftRow && rowHeight !== lockLeftHeight) {
                        _util.dom.setStyle(lockLeftRow, 'height', rowHeight);
                    }
                    if (lockRightRow && rowHeight !== lockRightHeight) {
                        _util.dom.setStyle(lockRightRow, 'height', rowHeight);
                    }
                });
            }
        };

        LockTable.prototype.getWrapperNode = function getWrapperNode(type) {
            type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';
            try {
                // in case of finding an unmounted component due to cached data
                // need to clear refs of table when dataSource Changed
                // use try catch for temporary
                return (0, _reactDom.findDOMNode)(this.refs['lock' + type]);
            } catch (error) {
                return null;
            }
        };

        LockTable.prototype.getFirstNormalCellNode = function getFirstNormalCellNode(index) {
            var i = 0;
            var row = void 0;
            do {
                row = this.getCellNode(index, i);
                i++;
            } while ((!row || row && row.rowSpan && row.rowSpan > 1) && this.tableInc.flatChildren.length > i);

            return row;
        };

        LockTable.prototype.getRowNode = function getRowNode(index, type) {
            type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';
            var table = this['table' + type + 'Inc'];

            try {
                // in case of finding an unmounted component due to cached data
                // need to clear refs of table when dataSource Changed
                // use try catch for temporary
                return (0, _reactDom.findDOMNode)(table.getRowRef(index));
            } catch (error) {
                return null;
            }
        };

        LockTable.prototype.getHeaderCellNode = function getHeaderCellNode(index, i, type) {
            type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';
            var table = this['table' + type + 'Inc'];

            try {
                // in case of finding an unmounted component due to cached data
                // need to clear refs of table when dataSource Changed
                // use try catch for temporary
                return (0, _reactDom.findDOMNode)(table.getHeaderCellRef(index, i));
            } catch (error) {
                return null;
            }
        };

        LockTable.prototype.getCellNode = function getCellNode(index, i, type) {
            type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';
            var table = this['table' + type + 'Inc'];

            try {
                // in case of finding an unmounted component due to cached data
                // need to clear refs of table when dataSource Changed
                // use try catch for temporary
                return (0, _reactDom.findDOMNode)(table.getCellRef(index, i));
            } catch (error) {
                return null;
            }
        };

        LockTable.prototype.render = function render() {
            /* eslint-disable no-unused-vars, prefer-const */
            var _props2 = this.props,
                children = _props2.children,
                prefix = _props2.prefix,
                components = _props2.components,
                className = _props2.className,
                others = _objectWithoutProperties(_props2, ['children', 'prefix', 'components', 'className']);

            var _normalizeChildrenSta = this.normalizeChildrenState(this.props),
                lockLeftChildren = _normalizeChildrenSta.lockLeftChildren,
                lockRightChildren = _normalizeChildrenSta.lockRightChildren,
                normalizedChildren = _normalizeChildrenSta.children;

            if (this._notNeedAdjustLockLeft) {
                lockLeftChildren = [];
            }
            if (this._notNeedAdjustLockRight) {
                lockRightChildren = [];
            }
            this.lockLeftChildren = lockLeftChildren;
            this.lockRightChildren = lockRightChildren;

            if (this.isOriginLock()) {
                var _classnames;

                components = _extends({}, components);
                components.Body = components.Body || _body2.default;
                components.Header = components.Header || _header2.default;
                components.Wrapper = components.Wrapper || _wrapper2.default;
                components.Row = components.Row || _row2.default;
                className = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-lock'] = true, _classnames[className] = className, _classnames));
                var content = [_react2.default.createElement(BaseComponent, _extends({}, others, { key: 'lock-left', columns: lockLeftChildren, className: prefix + 'table-lock-left', prefix: prefix, lockType: 'left', components: components, ref: 'lockLeft', loading: false })), _react2.default.createElement(BaseComponent, _extends({}, others, { key: 'lock-right', columns: lockRightChildren, className: prefix + 'table-lock-right', prefix: prefix, lockType: 'right', components: components, ref: 'lockRight', loading: false }))];
                return _react2.default.createElement(BaseComponent, _extends({}, others, { columns: normalizedChildren, prefix: prefix, wrapperContent: content, components: components, className: className }));
            }
            return _react2.default.createElement(BaseComponent, this.props);
        };

        return LockTable;
    }(_react2.default.Component), _class.LockRow = _row2.default, _class.LockBody = _body2.default, _class.LockHeader = _header2.default, _class.propTypes = _extends({
        scrollToCol: _propTypes2.default.number,
        /**
         * 指定滚动到某一行，仅在`useVirtual`的时候生效
         */
        scrollToRow: _propTypes2.default.number
    }, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps), _class.childContextTypes = {
        getTableInstance: _propTypes2.default.func,
        getLockNode: _propTypes2.default.func,
        onLockBodyScroll: _propTypes2.default.func,
        onLockBodyWheel: _propTypes2.default.func,
        onRowMouseEnter: _propTypes2.default.func,
        onRowMouseLeave: _propTypes2.default.func
    }, _temp);
    LockTable.displayName = 'LockTable';

    (0, _util2.statics)(LockTable, BaseComponent);
    return LockTable;
}

function deepCopy(arr) {
    var copy = function copy(arr) {
        return arr.map(function (item) {
            var newItem = _extends({}, item);
            if (item.children) {
                item.children = copy(item.children);
            }
            return newItem;
        });
    };
    return copy(arr);
}
module.exports = exports['default'];

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _body = __webpack_require__(67);

var _body2 = _interopRequireDefault(_body);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var LockBody = (_temp2 = _class = function (_React$Component) {
    _inherits(LockBody, _React$Component);

    function LockBody() {
        var _temp, _this, _ret;

        _classCallCheck(this, LockBody);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onBodyScroll = function () {
            _this.context.onLockBodyScroll();
        }, _this.onBodyWheel = function (e) {
            _this.context.onLockBodyWheel(e);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    LockBody.prototype.componentDidMount = function componentDidMount() {
        this.context.getLockNode('body', (0, _reactDom.findDOMNode)(this), this.context.lockType);
    };

    LockBody.prototype.render = function render() {
        return _react2.default.createElement(_body2.default, _extends({}, this.props, { onScroll: this.onBodyScroll, onWheel: this.onBodyWheel }));
    };

    return LockBody;
}(_react2.default.Component), _class.propTypes = _extends({}, _body2.default.propTypes), _class.contextTypes = _extends({}, _body2.default.contextTypes, {
    getLockNode: _propTypes2.default.func,
    onLockBodyScroll: _propTypes2.default.func,
    onLockBodyWheel: _propTypes2.default.func,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}), _temp2);
LockBody.displayName = 'LockBody';
exports.default = LockBody;
module.exports = exports['default'];

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _header = __webpack_require__(19);

var _header2 = _interopRequireDefault(_header);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var LockHeader = (_temp = _class = function (_FixedHeader) {
    _inherits(LockHeader, _FixedHeader);

    function LockHeader() {
        _classCallCheck(this, LockHeader);

        return _possibleConstructorReturn(this, _FixedHeader.apply(this, arguments));
    }

    LockHeader.prototype.componentDidMount = function componentDidMount() {
        var _context = this.context,
            getNode = _context.getNode,
            getLockNode = _context.getLockNode;

        getNode && getNode('header', (0, _reactDom.findDOMNode)(this), this.context.lockType);
        getLockNode && getLockNode('header', (0, _reactDom.findDOMNode)(this), this.context.lockType);
    };

    return LockHeader;
}(_header2.default), _class.propTypes = _extends({}, _header2.default.propTypes), _class.contextTypes = _extends({}, _header2.default.contextTypes, {
    getLockNode: _propTypes2.default.func,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}), _temp);
exports.default = LockHeader;
module.exports = exports['default'];

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = list;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _listHeader = __webpack_require__(68);

var _listHeader2 = _interopRequireDefault(_listHeader);

var _listFooter = __webpack_require__(69);

var _listFooter2 = _interopRequireDefault(_listFooter);

var _row = __webpack_require__(135);

var _row2 = _interopRequireDefault(_row);

var _body = __webpack_require__(136);

var _body2 = _interopRequireDefault(_body);

var _header = __webpack_require__(19);

var _header2 = _interopRequireDefault(_header);

var _wrapper = __webpack_require__(24);

var _wrapper2 = _interopRequireDefault(_wrapper);

var _util = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function list(BaseComponent) {
    var _class, _temp;

    var ListTable = (_temp = _class = function (_React$Component) {
        _inherits(ListTable, _React$Component);

        function ListTable() {
            _classCallCheck(this, ListTable);

            return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
        }

        ListTable.prototype.getChildContext = function getChildContext() {
            return {
                listHeader: this.listHeader,
                listFooter: this.listFooter,
                rowSelection: this.rowSelection
            };
        };

        ListTable.prototype.normalizeDataSource = function normalizeDataSource(dataSource) {
            var ret = [];
            var loop = function loop(dataSource, level) {
                dataSource.forEach(function (item) {
                    item.__level = level;
                    ret.push(item);
                    if (item.children) {
                        loop(item.children, level + 1);
                    }
                });
            };
            loop(dataSource, 0);
            this.ds = ret;
            return ret;
        };

        ListTable.prototype.render = function render() {
            var _this2 = this;

            /* eslint-disable prefer-const */
            var _props = this.props,
                components = _props.components,
                children = _props.children,
                className = _props.className,
                prefix = _props.prefix,
                others = _objectWithoutProperties(_props, ['components', 'children', 'className', 'prefix']);

            var isList = false,
                ret = [];
            _react.Children.forEach(children, function (child) {
                if (child) {
                    if (typeof child.type === 'function') {
                        if (child.type._typeMark === 'listHeader') {
                            _this2.listHeader = child.props;
                            isList = true;
                        } else if (child.type._typeMark === 'listFooter') {
                            _this2.listFooter = child.props;
                        } else {
                            ret.push(child);
                        }
                    } else {
                        ret.push(child);
                    }
                }
            });
            this.rowSelection = this.props.rowSelection;
            if (isList) {
                var _classnames;

                components = _extends({}, components);
                components.Row = components.Row || _row2.default;
                components.Body = components.Body || _body2.default;
                components.Header = components.Header || _header2.default;
                components.Wrapper = components.Wrapper || _wrapper2.default;
                className = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-group'] = true, _classnames[className] = className, _classnames));
            }
            return _react2.default.createElement(BaseComponent, _extends({}, others, { components: components, children: ret, className: className, prefix: prefix }));
        };

        return ListTable;
    }(_react2.default.Component), _class.ListHeader = _listHeader2.default, _class.ListFooter = _listFooter2.default, _class.ListRow = _row2.default, _class.ListBody = _body2.default, _class.propTypes = _extends({}, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps), _class.childContextTypes = {
        listHeader: _propTypes2.default.any,
        listFooter: _propTypes2.default.any,
        rowSelection: _propTypes2.default.object
    }, _temp);
    ListTable.displayName = 'ListTable';

    (0, _util.statics)(ListTable, BaseComponent);
    return ListTable;
}
module.exports = exports['default'];

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _util = __webpack_require__(2);

var _row = __webpack_require__(17);

var _row2 = _interopRequireDefault(_row);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var GroupListRow = (_temp = _class = function (_Row) {
    _inherits(GroupListRow, _Row);

    function GroupListRow() {
        _classCallCheck(this, GroupListRow);

        return _possibleConstructorReturn(this, _Row.apply(this, arguments));
    }

    GroupListRow.prototype.render = function render() {
        var _classnames;

        /* eslint-disable no-unused-vars*/
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            onClick = _props.onClick,
            onMouseEnter = _props.onMouseEnter,
            onMouseLeave = _props.onMouseLeave,
            columns = _props.columns,
            Cell = _props.Cell,
            rowIndex = _props.rowIndex,
            record = _props.record,
            children = _props.children,
            primaryKey = _props.primaryKey,
            colGroup = _props.colGroup,
            cellRef = _props.cellRef,
            getCellProps = _props.getCellProps,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'onClick', 'onMouseEnter', 'onMouseLeave', 'columns', 'Cell', 'rowIndex', 'record', 'children', 'primaryKey', 'colGroup', 'cellRef', 'getCellProps']);

        var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-row'] = true, _classnames[className] = className, _classnames));
        return _react2.default.createElement(
            'table',
            _extends({ className: cls, role: 'row' }, others, {
                onClick: this.onClick, onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave }),
            colGroup,
            _react2.default.createElement(
                'tbody',
                null,
                this.renderContent('header'),
                this.renderChildren(),
                this.renderContent('footer')
            )
        );
    };

    GroupListRow.prototype.isChildrenSelection = function isChildrenSelection() {
        return this.context.listHeader && this.context.listHeader.hasChildrenSelection;
    };

    GroupListRow.prototype.isSelection = function isSelection() {
        return this.context.listHeader && this.context.listHeader.hasSelection;
    };

    GroupListRow.prototype.renderChildren = function renderChildren() {
        var _this2 = this;

        var _props2 = this.props,
            record = _props2.record,
            primaryKey = _props2.primaryKey;
        var children = record.children;

        if (children) {
            return children.map(function (child, index) {
                var cells = _this2.renderCells(child);
                if (_this2.isChildrenSelection()) {
                    if (!child[primaryKey]) {
                        _util.log.warning('record.children should contains primaryKey when childrenSelection is true.');
                    }
                    return _react2.default.createElement(
                        'tr',
                        { key: child[primaryKey] },
                        cells
                    );
                }
                if (_this2.context.rowSelection) {
                    cells.shift();
                    cells[0] = _react2.default.cloneElement(cells[0], _extends({
                        colSpan: 2
                    }, cells[0].props));
                }
                return _react2.default.createElement(
                    'tr',
                    { key: index },
                    cells
                );
            });
        }
        return null;
    };

    GroupListRow.prototype.renderContent = function renderContent(type) {
        var _props3 = this.props,
            columns = _props3.columns,
            prefix = _props3.prefix,
            record = _props3.record,
            rowIndex = _props3.rowIndex;

        var cameType = type.charAt(0).toUpperCase() + type.substr(1);
        var list = this.context['list' + cameType];
        var listNode = void 0;
        if (list) {
            if (_react2.default.isValidElement(list.cell)) {
                listNode = _react2.default.cloneElement(list.cell, { record: record, index: rowIndex });
            } else if (typeof list.cell === 'function') {
                listNode = list.cell(record, rowIndex);
            }
            if (listNode) {
                var cells = this.renderCells(record);
                if (type === 'header' && this.context.rowSelection && this.isSelection()) {
                    cells = cells.slice(0, 1);
                    cells.push(_react2.default.createElement(
                        'td',
                        { colSpan: columns.length - 1, key: 'listNode' },
                        _react2.default.createElement(
                            'div',
                            { className: prefix + 'table-cell-wrapper' },
                            listNode
                        )
                    ));
                    listNode = _react2.default.createElement(
                        'tr',
                        { className: prefix + 'table-group-' + type },
                        cells
                    );
                } else {
                    listNode = _react2.default.createElement(
                        'tr',
                        { className: prefix + 'table-group-' + type },
                        _react2.default.createElement(
                            'td',
                            { colSpan: columns.length },
                            _react2.default.createElement(
                                'div',
                                { className: prefix + 'table-cell-wrapper' },
                                listNode
                            )
                        )
                    );
                }
            }
        }
        return listNode;
    };

    return GroupListRow;
}(_row2.default), _class.contextTypes = {
    listHeader: _propTypes2.default.any,
    listFooter: _propTypes2.default.any,
    rowSelection: _propTypes2.default.object,
    notRenderCellIndex: _propTypes2.default.array,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}, _temp);
exports.default = GroupListRow;
module.exports = exports['default'];

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = ListBody;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _body = __webpack_require__(16);

var _body2 = _interopRequireDefault(_body);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ListBody(props) {
    return _react2.default.createElement(_body2.default, _extends({ component: 'div' }, props));
}
module.exports = exports['default'];

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = sticky;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _header = __webpack_require__(19);

var _header2 = _interopRequireDefault(_header);

var _header3 = __webpack_require__(138);

var _header4 = _interopRequireDefault(_header3);

var _util = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function sticky(BaseComponent) {
    var _class, _temp;

    /** Table */
    var StickyTable = (_temp = _class = function (_React$Component) {
        _inherits(StickyTable, _React$Component);

        function StickyTable() {
            _classCallCheck(this, StickyTable);

            return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
        }

        StickyTable.prototype.getChildContext = function getChildContext() {
            return {
                Header: this.props.components.Header || _header2.default,
                offsetTop: this.props.offsetTop,
                affixProps: this.props.affixProps
            };
        };

        StickyTable.prototype.render = function render() {
            /* eslint-disable no-unused-vars */
            var _props = this.props,
                stickyHeader = _props.stickyHeader,
                offsetTop = _props.offsetTop,
                affixProps = _props.affixProps,
                others = _objectWithoutProperties(_props, ['stickyHeader', 'offsetTop', 'affixProps']);

            var _props2 = this.props,
                components = _props2.components,
                maxBodyHeight = _props2.maxBodyHeight,
                fixedHeader = _props2.fixedHeader;

            if (stickyHeader) {
                components = _extends({}, components);
                components.Header = _header4.default;
                fixedHeader = true;
                maxBodyHeight = Math.max(maxBodyHeight, 10000);
            }
            return _react2.default.createElement(BaseComponent, _extends({}, others, { components: components, fixedHeader: fixedHeader, maxBodyHeight: maxBodyHeight }));
        };

        return StickyTable;
    }(_react2.default.Component), _class.StickyHeader = _header4.default, _class.propTypes = _extends({
        /**
         * 表头是否是sticky
         */
        stickyHeader: _propTypes2.default.bool,
        /**
         * 距离窗口顶部达到指定偏移量后触发
         */
        offsetTop: _propTypes2.default.number,
        /**
         * affix组件的的属性
         */
        affixProps: _propTypes2.default.object,
        components: _propTypes2.default.object
    }, BaseComponent.propTypes), _class.defaultProps = _extends({
        components: {}
    }, BaseComponent.defaultProps), _class.childContextTypes = {
        Header: _propTypes2.default.any,
        offsetTop: _propTypes2.default.number,
        affixProps: _propTypes2.default.object
    }, _temp);
    StickyTable.displayName = 'StickyTable';

    (0, _util.statics)(StickyTable, BaseComponent);
    return StickyTable;
}
module.exports = exports['default'];

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _affix = __webpack_require__(139);

var _affix2 = _interopRequireDefault(_affix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function*/
var StickHeader = (_temp2 = _class = function (_React$Component) {
    _inherits(StickHeader, _React$Component);

    function StickHeader() {
        var _temp, _this, _ret;

        _classCallCheck(this, StickHeader);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.getAffixRef = function (ref) {
            _this.props.affixRef && _this.props.affixRef(ref);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    StickHeader.prototype.render = function render() {
        var _classnames;

        var prefix = this.props.prefix;
        var _context = this.context,
            Header = _context.Header,
            offsetTop = _context.offsetTop,
            affixProps = _context.affixProps;


        var newAffixProps = affixProps || {};

        var className = newAffixProps.className,
            others = _objectWithoutProperties(newAffixProps, ['className']);

        var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-affix'] = true, _classnames.className = className, _classnames));

        return _react2.default.createElement(
            _affix2.default,
            _extends({ ref: this.getAffixRef }, others, { className: cls, offsetTop: offsetTop }),
            _react2.default.createElement(Header, this.props)
        );
    };

    return StickHeader;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string
}, _class.contextTypes = {
    Header: _propTypes2.default.any,
    offsetTop: _propTypes2.default.number,
    affixProps: _propTypes2.default.object
}, _temp2);
StickHeader.displayName = 'StickHeader';
exports.default = StickHeader;
module.exports = exports['default'];

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__(4);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _util = __webpack_require__(2);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _util2 = __webpack_require__(140);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/** Affix */
var Affix = (_temp = _class = function (_React$Component) {
    _inherits(Affix, _React$Component);

    function Affix(props, context) {
        _classCallCheck(this, Affix);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

        _this.updatePosition = function () {
            _this._updateNodePosition();
        };

        _this._updateNodePosition = function () {
            var _this$props = _this.props,
                container = _this$props.container,
                useAbsolute = _this$props.useAbsolute;

            var affixContainer = container();

            if (!affixContainer) {
                return false;
            }
            var containerScrollTop = (0, _util2.getScroll)(affixContainer, true); // 容器在垂直位置上的滚动 offset
            var affixOffset = _this._getOffset(_this.affixNode, affixContainer); // 目标节点当前相对于容器的 offset
            var containerHeight = (0, _util2.getNodeHeight)(affixContainer); // 容器的高度
            var affixHeight = _this.affixNode.offsetHeight;
            var containerRect = (0, _util2.getRect)(affixContainer);

            var affixChildHeight = _this.affixChildNode.offsetHeight;

            var affixMode = _this.affixMode;
            var affixStyle = {
                width: affixOffset.width
            };
            var containerStyle = {
                width: affixOffset.width,
                height: affixChildHeight
            };

            if (affixMode.top && containerScrollTop > affixOffset.top - affixMode.offset) {
                // affix top
                if (useAbsolute) {
                    affixStyle.position = 'absolute';
                    affixStyle.top = containerScrollTop - (affixOffset.top - affixMode.offset);
                    containerStyle.position = 'relative';
                } else {
                    affixStyle.position = 'fixed';
                    affixStyle.top = affixMode.offset + containerRect.top;
                }
                _this._setAffixStyle(affixStyle, true);
                _this._setContainerStyle(containerStyle);
            } else if (affixMode.bottom && containerScrollTop < affixOffset.top + affixHeight + affixMode.offset - containerHeight) {
                // affix bottom
                affixStyle.height = affixHeight;
                if (useAbsolute) {
                    affixStyle.position = 'absolute';
                    affixStyle.top = containerScrollTop - (affixOffset.top + affixHeight + affixMode.offset - containerHeight);
                    containerStyle.position = 'relative';
                } else {
                    affixStyle.position = 'fixed';
                    affixStyle.bottom = affixMode.offset;
                }
                _this._setAffixStyle(affixStyle, true);
                _this._setContainerStyle(containerStyle);
            } else {
                _this._setAffixStyle(null);
                _this._setContainerStyle(null);
            }
        };

        _this._affixNodeRefHandler = function (ref) {
            _this.affixNode = (0, _reactDom.findDOMNode)(ref);
        };

        _this._affixChildNodeRefHandler = function (ref) {
            _this.affixChildNode = (0, _reactDom.findDOMNode)(ref);
        };

        _this.state = {
            style: null,
            containerStyle: null
        };
        _this.affixMode = _this._getAffixMode(props);
        return _this;
    }

    Affix.prototype.componentDidMount = function componentDidMount() {
        var _this2 = this;

        var container = this.props.container;

        this._updateNodePosition();
        // wait for parent rendered
        this.timeout = setTimeout(function () {
            _this2._setEventHandlerForContainer(container);
        });
    };

    Affix.prototype.componentWillUnmount = function componentWillUnmount() {
        if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
        var container = this.props.container;

        this._removeEventHandlerForContainer(container);
    };

    Affix.prototype._setEventHandlerForContainer = function _setEventHandlerForContainer(getContainer) {
        var container = getContainer();
        if (!container) {
            return;
        }
        _util.events.on(container, 'scroll', this._updateNodePosition, false);
        _util.events.on(container, 'resize', this._updateNodePosition, false);
    };

    Affix.prototype._removeEventHandlerForContainer = function _removeEventHandlerForContainer(getContainer) {
        var container = getContainer();
        if (container) {
            _util.events.off(container, 'scroll', this._updateNodePosition);
            _util.events.off(container, 'resize', this._updateNodePosition);
        }
    };

    Affix.prototype._getAffixMode = function _getAffixMode() {
        var _props = this.props,
            offsetTop = _props.offsetTop,
            offsetBottom = _props.offsetBottom;

        var affixMode = {
            top: false,
            bottom: false,
            offset: 0
        };

        if (typeof offsetTop !== 'number' && typeof offsetBottom !== 'number') {
            // set default
            affixMode.top = true;
        } else if (typeof offsetTop === 'number') {
            affixMode.top = true;
            affixMode.offset = offsetTop;
        } else if (typeof offsetBottom === 'number') {
            affixMode.bottom = true;
            affixMode.offset = offsetBottom;
        }

        return affixMode;
    };

    Affix.prototype._setAffixStyle = function _setAffixStyle(affixStyle) {
        var affixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (_util.obj.shallowEqual(affixStyle, this.state.style)) {
            return;
        }

        this.setState({
            style: affixStyle
        });

        var onAffix = this.props.onAffix;


        if (affixed) {
            onAffix(true);
        } else if (!affixStyle) {
            onAffix(false);
        }
    };

    Affix.prototype._setContainerStyle = function _setContainerStyle(containerStyle) {
        if (_util.obj.shallowEqual(containerStyle, this.state.containerStyle)) {
            return;
        }
        this.setState({ containerStyle: containerStyle });
    };

    Affix.prototype._getOffset = function _getOffset(affixNode, affixContainer) {
        var affixRect = affixNode.getBoundingClientRect(); // affix 元素 相对浏览器窗口的位置
        var containerRect = (0, _util2.getRect)(affixContainer); // affix 容器 相对浏览器窗口的位置
        var containerScrollTop = (0, _util2.getScroll)(affixContainer, true);
        var containerScrollLeft = (0, _util2.getScroll)(affixContainer, false);

        return {
            top: affixRect.top - containerRect.top + containerScrollTop,
            left: affixRect.left - containerRect.left + containerScrollLeft,
            width: affixRect.width,
            height: affixRect.height
        };
    };

    Affix.prototype.render = function render() {
        var _classnames;

        var _props2 = this.props,
            prefix = _props2.prefix,
            className = _props2.className,
            style = _props2.style,
            children = _props2.children;

        var state = this.state;
        var classNames = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'affix'] = state.style, _classnames[prefix + 'affix-top'] = !state.style && this.affixMode.top, _classnames[prefix + 'affix-bottom'] = !state.style && this.affixMode.bottom, _classnames[className] = className, _classnames));
        var combinedStyle = _extends({}, state.containerStyle, style);

        return _react2.default.createElement(
            'div',
            { ref: this._affixNodeRefHandler, style: combinedStyle },
            _react2.default.createElement(
                'div',
                { ref: this._affixChildNodeRefHandler, className: classNames, style: state.style },
                children
            )
        );
    };

    return Affix;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    /**
     * 设置 Affix 需要监听滚动事件的容器元素
     * @return {ReactElement} 目标容器元素的实例
     */
    container: _propTypes2.default.func,
    /**
     * 距离窗口顶部达到指定偏移量后触发
     */
    offsetTop: _propTypes2.default.number,
    /**
     * 距离窗口底部达到制定偏移量后触发
     */
    offsetBottom: _propTypes2.default.number,
    /**
     * 当元素的样式发生固钉样式变化时触发的回调函数
     * @param {Boolean} 元素是否被固钉
     */
    onAffix: _propTypes2.default.func,
    /**
     * 是否启用绝对布局实现 affix
     * @param {Boolean} 是否启用绝对布局
     */
    useAbsolute: _propTypes2.default.bool,
    className: _propTypes2.default.string,
    style: _propTypes2.default.object,
    children: _propTypes2.default.any
}, _class.defaultProps = {
    prefix: 'next-',
    container: function container() {
        return window;
    },
    onAffix: _util.func.noop
}, _temp);
Affix.displayName = 'Affix';
exports.default = _configProvider2.default.config(Affix);
module.exports = exports['default'];

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getScroll = getScroll;
exports.getRect = getRect;
exports.getNodeHeight = getNodeHeight;
function getScroll(node, isVertical) {
    if (typeof window === 'undefined') {
        return 0;
    }
    var windowProp = isVertical ? 'pageYOffset' : 'pageXOffset';
    var elementProp = isVertical ? 'scrollTop' : 'scrollLeft';
    return node === window ? node[windowProp] : node[elementProp];
}

function getRect(node) {
    return node !== window ? node.getBoundingClientRect() : { top: 0, left: 0, bottom: 0 };
}

function getNodeHeight(node) {
    if (!node) {
        return 0;
    }
    if (node === window) {
        return window.innerHeight;
    }
    return node.clientHeight;
}

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(11);

__webpack_require__(38);

__webpack_require__(70);

__webpack_require__(77);

__webpack_require__(72);

__webpack_require__(149);

__webpack_require__(78);

__webpack_require__(153);

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(25);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(25, function () {
			var newContent = __webpack_require__(25);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
	// get current location
	var location = typeof window !== "undefined" && window.location;

	if (!location) {
		throw new Error("fixUrls requires window.location");
	}

	// blank or null?
	if (!css || typeof css !== "string") {
		return css;
	}

	var baseUrl = location.protocol + "//" + location.host;
	var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
 This regular expression is just a way to recursively match brackets within
 a string.
 	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
    (  = Start a capturing group
      (?:  = Start a non-capturing group
          [^)(]  = Match anything that isn't a parentheses
          |  = OR
          \(  = Match a start parentheses
              (?:  = Start another non-capturing groups
                  [^)(]+  = Match anything that isn't a parentheses
                  |  = OR
                  \(  = Match a start parentheses
                      [^)(]*  = Match anything that isn't a parentheses
                  \)  = Match a end parentheses
              )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
  \)  = Match a close parens
 	 /gi  = Get all matches, not the first.  Be case insensitive.
  */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
			return $1;
		}).replace(/^'(.*)'$/, function (o, $1) {
			return $1;
		});

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
			return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
			//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(26);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(26, function () {
			var newContent = __webpack_require__(26);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(27);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(27, function () {
			var newContent = __webpack_require__(27);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(28);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(28, function () {
			var newContent = __webpack_require__(28);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(29);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(29, function () {
			var newContent = __webpack_require__(29);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(30);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(30, function () {
			var newContent = __webpack_require__(30);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(36);

__webpack_require__(151);

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(31);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(31, function () {
			var newContent = __webpack_require__(31);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(32);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(32, function () {
			var newContent = __webpack_require__(32);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(33);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(33, function () {
			var newContent = __webpack_require__(33);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(34);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(34, function () {
			var newContent = __webpack_require__(34);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, ".beauty{\n  background: #f7f7f7;\n}", ""]);

// exports


/***/ }),
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(155);
module.exports = __webpack_require__(333);


/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _table = __webpack_require__(79);

var _table2 = _interopRequireDefault(_table);

__webpack_require__(141);

var _button = __webpack_require__(71);

var _button2 = _interopRequireDefault(_button);

__webpack_require__(72);

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);for (var i = 0; i < keys.length; i++) {
        var key = keys[i];var value = Object.getOwnPropertyDescriptor(defaults, key);if (value && value.configurable && obj[key] === undefined) {
            Object.defineProperty(obj, key, value);
        }
    }return obj;
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
}

__webpack_require__(334);

var dataSource = function dataSource() {
    var result = [];
    for (var i = 0; i < 5; i++) {
        result.push({
            title: 'Quotation for 1PCS Nano ' + (3 + i) + '.0 controller compatible',
            id: 100306660940 + i,
            time: 2000 + i
        });
    }
    return result;
},
    _render = function _render(value, index, record) {
    return React.createElement('a', null, 'Remove(', record.id, ')');
};

var App = function (_React$Component) {
    _inherits(App, _React$Component);

    function App(props) {
        _classCallCheck(this, App);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

        _this.state = {
            dataSource: dataSource(),
            className: '',
            align: 'left'
        };
        return _this;
    }

    App.prototype.toggleZebra = function toggleZebra() {
        this.setState({
            isZebra: !this.state.isZebra
        });
    };

    App.prototype.toggleBorder = function toggleBorder() {
        this.setState({
            hasBorder: !this.state.hasBorder
        });
    };

    App.prototype.makeBeauty = function makeBeauty() {
        this.setState({
            className: 'beauty'
        });
    };

    App.prototype.makeAlign = function makeAlign() {
        this.setState({
            align: 'right'
        });
    };

    App.prototype.render = function render() {
        return React.createElement('span', null, React.createElement('p', null, React.createElement(_button2.default, { onClick: this.toggleZebra.bind(this) }, ' Toggle zebra '), ' \xA0', React.createElement(_button2.default, { onClick: this.toggleBorder.bind(this) }, ' Toggle border'), ' \xA0', React.createElement(_button2.default, { onClick: this.makeBeauty.bind(this) }, ' Make second column beauty '), ' \xA0', React.createElement(_button2.default, { onClick: this.makeAlign.bind(this) }, ' Make first column align right '), ' \xA0'), React.createElement(_table2.default, { dataSource: this.state.dataSource,
            isZebra: this.state.isZebra,
            hasBorder: this.state.hasBorder }, React.createElement(_table2.default.Column, { title: 'Id', dataIndex: 'id', align: this.state.align }), React.createElement(_table2.default.Column, { title: 'Title', dataIndex: 'title', className: this.state.className }), React.createElement(_table2.default.Column, { title: 'Time', dataIndex: 'time' }), React.createElement(_table2.default.Column, { cell: _render, width: 200 })));
    };

    return App;
}(React.Component);

App.displayName = 'App';

ReactDOM.render(React.createElement(App, null), mountNode);

// HOT RELOAD CODE
var componentDesc = document.querySelector('#component-desc');
componentDesc.innerHTML = '\u81EA\u5B9A\u4E49\u8868\u683C\u8FB9\u6846';
var componentBody = document.querySelector('#component-body');
componentBody.innerHTML = '<pre><code class="language-jsx"><div class="hljs"><span class="hljs-keyword">import</span> { Table, Button } <span class="hljs-keyword">from</span> <span class="hljs-string">\'@alifd/next\'</span>;\n\n<span class="hljs-keyword">const</span> dataSource = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n        <span class="hljs-keyword">const</span> result = [];\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {\n            result.push({\n                <span class="hljs-attr">title</span>: <span class="hljs-string">{backquote}Quotation for 1PCS Nano <span class="hljs-subst">{dollar}{<span class="hljs-number">3</span> + i}</span>.0 controller compatible{backquote}</span>,\n                <span class="hljs-attr">id</span>: <span class="hljs-number">100306660940</span> + i,\n                <span class="hljs-attr">time</span>: <span class="hljs-number">2000</span> + i\n            });\n        }\n        <span class="hljs-keyword">return</span> result;\n    },\n    render = <span class="hljs-function">(<span class="hljs-params">value, index, record</span>) =&gt;</span> {\n        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>Remove({record.id})<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>;\n    };\n\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n    <span class="hljs-keyword">constructor</span>(props) {\n        <span class="hljs-keyword">super</span>(props);\n        <span class="hljs-keyword">this</span>.state = {\n            <span class="hljs-attr">dataSource</span>: dataSource(),\n            <span class="hljs-attr">className</span>: <span class="hljs-string">\'\'</span>,\n            <span class="hljs-attr">align</span>: <span class="hljs-string">\'left\'</span>\n        };\n    }\n    toggleZebra() {\n        <span class="hljs-keyword">this</span>.setState({\n            <span class="hljs-attr">isZebra</span>: !<span class="hljs-keyword">this</span>.state.isZebra\n        });\n    }\n    toggleBorder() {\n        <span class="hljs-keyword">this</span>.setState({\n            <span class="hljs-attr">hasBorder</span>: !<span class="hljs-keyword">this</span>.state.hasBorder\n        });\n    }\n    makeBeauty() {\n        <span class="hljs-keyword">this</span>.setState({\n            <span class="hljs-attr">className</span>: <span class="hljs-string">\'beauty\'</span>\n        });\n    }\n    makeAlign() {\n        <span class="hljs-keyword">this</span>.setState({\n            <span class="hljs-attr">align</span>: <span class="hljs-string">\'right\'</span>\n        });\n    }\n    render() {\n        <span class="hljs-keyword">return</span> (&lt;span&gt;\n            &lt;p&gt;\n                &lt;Button onClick={this.toggleZebra.bind(this)}&gt; Toggle zebra &lt;/Button&gt; &amp;nbsp;\n                &lt;Button onClick={this.toggleBorder.bind(this)}&gt; Toggle border&lt;/Button&gt; &amp;nbsp;\n                &lt;Button onClick={this.makeBeauty.bind(this)}&gt; Make second column beauty &lt;/Button&gt; &amp;nbsp;\n                &lt;Button onClick={this.makeAlign.bind(this)}&gt; Make first column align right &lt;/Button&gt; &amp;nbsp;\n            &lt;/p&gt;\n            &lt;Table dataSource={this.state.dataSource}\n                isZebra={this.state.isZebra}\n                hasBorder={this.state.hasBorder}&gt;\n                &lt;Table.Column title="Id" dataIndex="id"  align={this.state.align}/&gt;\n                &lt;Table.Column title="Title" dataIndex="title" className={this.state.className}/&gt;\n                &lt;Table.Column title="Time" dataIndex="time"/&gt;\n                &lt;Table.Column cell={render} width={200}/&gt;\n            &lt;/Table&gt;\n        &lt;/span&gt;);\n    }\n}\n\nReactDOM.render(&lt;App/&gt;, mountNode);\n</div></code></pre>\n<pre><code class="language-css"><div class="hljs"><span class="hljs-selector-class">.beauty</span>{\n  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f7f7f7</span>;\n}\n</div></code></pre>\n'.replace(/{backquote}/g, '`').replace(/{dollar}/g, '$');

if (true) {
    module.hot.accept();

    var reloading = document.querySelector('#next-demo-reloading');

    if (!window.hasAddStatusHandler) {
        module.hot.addStatusHandler(function (status) {
            window.hasAddStatusHandler = true;
            if (status === 'check') {
                reloading.style.display = 'block';
            } else if (status === 'idle') {
                reloading.style.display = 'none';
            }
        });
    }
}

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(186);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(true) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept(186, function() {
			var newContent = __webpack_require__(186);
			if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ })
],[332]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ3aW5kb3cuUmVhY3RcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3Byb3AtdHlwZXNAMTUuNi4yQHByb3AtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19jbGFzc25hbWVzQDIuMi42QGNsYXNzbmFtZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwid2luZG93LlJlYWN0RE9NXCIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy1wcm92aWRlci9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL3NyYy90YWJsZS91dGlsLmpzIiwid2VicGFjazovLy8uL3NyYy9pY29uL2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvaWNvbi9zdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYW5pbWF0ZS9zdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21lbnUvdmlldy9pdGVtLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvb3ZlcmxheS9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2Jhc2UvYm9keS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2Jhc2Uvcm93LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvYmFzZS9jZWxsLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvZml4ZWQvaGVhZGVyLmpzeCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3Byb3AtdHlwZXNAMTUuNi4yQHByb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL3NyYy9vdmVybGF5L3V0aWxzL2ZpbmQtbm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWVudS92aWV3L3NlbGVjdGFibGUtaXRlbS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2NvbHVtbi5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2ZpeGVkL3dyYXBwZXIuanN4Iiwid2VicGFjazovLy8uL3NyYy9pY29uL21haW4uc2Nzcz83MDIyIiwid2VicGFjazovLy8uL3NyYy9hbmltYXRlL21haW4uc2Nzcz9lYmE4Iiwid2VicGFjazovLy8uL3NyYy9jaGVja2JveC9tYWluLnNjc3M/ZWZlYSIsIndlYnBhY2s6Ly8vLi9zcmMvcmFkaW8vbWFpbi5zY3NzPzhiNTQiLCJ3ZWJwYWNrOi8vLy4vc3JjL21lbnUvbWFpbi5zY3NzPzVkZTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2J1dHRvbi9tYWluLnNjc3M/MGFkNCIsIndlYnBhY2s6Ly8vLi9zcmMvb3ZlcmxheS9tYWluLnNjc3M/MmM2ZCIsIndlYnBhY2s6Ly8vLi9zcmMvZHJvcGRvd24vbWFpbi5zY3NzPzY1ODAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvYWRpbmcvbWFpbi5zY3NzP2M1NDIiLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL21haW4uc2Nzcz83ZGRlIiwid2VicGFjazovLy8uL3NyYy9sb2NhbGUvemgtY24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL292ZXJsYXkvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NoZWNrYm94L2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY2hlY2tib3gvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy1wcm92aWRlci9nZXQtY29udGV4dC1wcm9wcy5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvZG9tLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlsL3N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9lbnYuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwva2V5Y29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3NoYWxsb3ctZWxlbWVudC1lcXVhbHNAMS4wLjFAc2hhbGxvdy1lbGVtZW50LWVxdWFscy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvb3ZlcmxheS9vdmVybGF5LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvb3ZlcmxheS9nYXRld2F5LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvb3ZlcmxheS9wb3NpdGlvbi5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2Jhc2UvaGVhZGVyLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvYmFzZS9maWx0ZXIuanN4Iiwid2VicGFjazovLy8uL3NyYy9tZW51L3ZpZXcvbWVudS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2FuaW1hdGUvYW5pbWF0ZS5qc3giLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19yZWFjdC10cmFuc2l0aW9uLWdyb3VwQDIuNS4yQHJlYWN0LXRyYW5zaXRpb24tZ3JvdXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19yZWFjdC10cmFuc2l0aW9uLWdyb3VwQDIuNS4yQHJlYWN0LXRyYW5zaXRpb24tZ3JvdXAvVHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3JlYWN0LWxpZmVjeWNsZXMtY29tcGF0QDMuMC40QHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0L3JlYWN0LWxpZmVjeWNsZXMtY29tcGF0LmVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9fcmVhY3QtdHJhbnNpdGlvbi1ncm91cEAyLjUuMkByZWFjdC10cmFuc2l0aW9uLWdyb3VwL3V0aWxzL1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3JlYWN0LXRyYW5zaXRpb24tZ3JvdXBAMi41LjJAcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9UcmFuc2l0aW9uR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21lbnUvdmlldy9wb3B1cC1pdGVtLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvbWVudS92aWV3L2NoZWNrYWJsZS1pdGVtLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY2hlY2tib3gvY2hlY2tib3guanN4Iiwid2VicGFjazovLy8uL3NyYy9taXhpbi11aS1zdGF0ZS9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3JhZGlvL2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvcmFkaW8vcmFkaW8uanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS9iYXNlL3NvcnQuanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS9zZWxlY3Rpb24vcm93LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvZXhwYW5kZWQvcm93LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvbG9jay9yb3cuanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS9maXhlZC9ib2R5LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvbGlzdC1oZWFkZXIuanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS9saXN0LWZvb3Rlci5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3JhZGlvL3N0eWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9idXR0b24vaW5kZXguanN4Iiwid2VicGFjazovLy8uL3NyYy9idXR0b24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FuaW1hdGUvaW5kZXguanN4Iiwid2VicGFjazovLy8uL3NyYy9sb2FkaW5nL2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvbWVudS9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL21lbnUvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvYWRpbmcvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3Byb3AtdHlwZXNAMTUuNi4yQHByb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19vYmplY3QtYXNzaWduQDQuMS4xQG9iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19wcm9wLXR5cGVzQDE1LjYuMkBwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9fcHJvcC10eXBlc0AxNS42LjJAcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy1wcm92aWRlci9jb25maWcuanN4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9faG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3NAMi41LjVAaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvZGlzdC9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy5janMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlsL2Z1bmMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvbG9nLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlsL3N1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvZm9jdXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvZ3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnLXByb3ZpZGVyL2NvbnN1bWVyLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnLXByb3ZpZGVyL2NhY2hlLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcIndpbmRvdy5tb21lbnRcIiIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvYmFzZS5qc3giLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19zdHlsZS1lcXVhbEAxLjAuMEBzdHlsZS1lcXVhbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvb3ZlcmxheS9tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9vdmVybGF5L3V0aWxzL3Bvc2l0aW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9vdmVybGF5L3BvcHVwLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvZHJvcGRvd24vaW5kZXguanN4Iiwid2VicGFjazovLy8uL3NyYy9tZW51L3ZpZXcvc3ViLW1lbnUuanN4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9fcmVhY3QtdHJhbnNpdGlvbi1ncm91cEAyLjUuMkByZWFjdC10cmFuc2l0aW9uLWdyb3VwL0NTU1RyYW5zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19kb20taGVscGVyc0AzLjQuMEBkb20taGVscGVycy9jbGFzcy9hZGRDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX0BiYWJlbF9ydW50aW1lQDcuMi4wQEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9fZG9tLWhlbHBlcnNAMy40LjBAZG9tLWhlbHBlcnMvY2xhc3MvaGFzQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19kb20taGVscGVyc0AzLjQuMEBkb20taGVscGVycy9jbGFzcy9yZW1vdmVDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3JlYWN0LXRyYW5zaXRpb24tZ3JvdXBAMi41LjJAcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9SZXBsYWNlVHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3JlYWN0LXRyYW5zaXRpb24tZ3JvdXBAMi41LjJAcmVhY3QtdHJhbnNpdGlvbi1ncm91cC91dGlscy9DaGlsZE1hcHBpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FuaW1hdGUvY2hpbGQuanN4Iiwid2VicGFjazovLy8uL3NyYy9hbmltYXRlL2V4cGFuZC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL21lbnUvdmlldy9jaGVja2JveC1pdGVtLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY2hlY2tib3gvY2hlY2tib3gtZ3JvdXAuanN4Iiwid2VicGFjazovLy8uL3NyYy9yYWRpby9yYWRpby1ncm91cC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL21lbnUvdmlldy9yYWRpby1pdGVtLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvbWVudS92aWV3L2dyb3VwLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvbWVudS92aWV3L2RpdmlkZXIuanN4Iiwid2VicGFjazovLy8uL3NyYy9tZW51L3ZpZXcvY3JlYXRlLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvYnV0dG9uL3ZpZXcvYnV0dG9uLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvYnV0dG9uL3ZpZXcvZ3JvdXAuanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS9iYXNlL3Jlc2l6ZS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2Jhc2Uvd3JhcHBlci5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2NvbHVtbi1ncm91cC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL3RyZWUuanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS90cmVlL3Jvdy5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL3RyZWUvY2VsbC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2ZpeGVkLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvc2VsZWN0aW9uLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvZXhwYW5kZWQuanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS92aXJ0dWFsLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvdmlydHVhbC9ib2R5LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvbG9jay5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2xvY2svYm9keS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2xvY2svaGVhZGVyLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvbGlzdC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2xpc3Qvcm93LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvbGlzdC9ib2R5LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvc3RpY2t5LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvc3RpY2t5L2hlYWRlci5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2FmZml4L2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvYWZmaXgvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ljb24vbWFpbi5zY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDAuMTguMkBzdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FuaW1hdGUvbWFpbi5zY3NzIiwid2VicGFjazovLy8uL3NyYy9jaGVja2JveC9tYWluLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JhZGlvL21haW4uc2NzcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWVudS9tYWluLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2J1dHRvbi9tYWluLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Ryb3Bkb3duL3N0eWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9vdmVybGF5L21haW4uc2NzcyIsIndlYnBhY2s6Ly8vLi9zcmMvZHJvcGRvd24vbWFpbi5zY3NzIiwid2VicGFjazovLy8uL3NyYy9sb2FkaW5nL21haW4uc2NzcyIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvbWFpbi5zY3NzIiwid2VicGFjazovLy8uL2RvY3MvdGFibGUvZGVtby9zdHlsZS5tZD85NTExIiwid2VicGFjazovLy8uL2RvY3MvdGFibGUvZGVtby9zdHlsZS5tZCIsIndlYnBhY2s6Ly8vLi9kb2NzL3RhYmxlL2RlbW8vc3R5bGUubWQ/OGFkOCJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJpc1ZhbGlkRWxlbWVudCIsIm9iamVjdCIsIiQkdHlwZW9mIiwidGhyb3dPbkRpcmVjdEFjY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiX2RvbSIsIl9lbnYiLCJfZXZlbnRzIiwiX2Z1bmMiLCJfbG9nIiwiX29iamVjdCIsIl9zdHJpbmciLCJfc3VwcG9ydCIsIl9mb2N1cyIsImRvbSIsImV2ZW50cyIsImZ1bmMiLCJsb2ciLCJvYmoiLCJzdHIiLCJzdXBwb3J0IiwiZm9jdXMiLCJndWlkIiwiX2d1aWQiLCJLRVlDT0RFIiwiX0tFWUNPREUiLCJoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsImNsYXNzTmFtZXMiLCJjbGFzc2VzIiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZyIsImFyZ1R5cGUiLCJwdXNoIiwiQXJyYXkiLCJpc0FycmF5IiwiaW5uZXIiLCJhcHBseSIsImtleSIsImNhbGwiLCJqb2luIiwiZGVmYXVsdCIsImRlZmluZSIsIndpbmRvdyIsImNoaWxkQ29udGV4dENhY2hlIiwiQ2FjaGUiLCJDb25maWdQcm92aWRlciIsImFyZ3MiLCJhZGQiLCJnZXQiLCJnZXRDaGlsZENvbnRleHQiLCJwcm9wcyIsInByZWZpeCIsImxvY2FsZSIsInB1cmUiLCJ3YXJuaW5nIiwicnRsIiwibmV4dFByZWZpeCIsIm5leHRMb2NhbGUiLCJuZXh0UHVyZSIsIm5leHRSdGwiLCJuZXh0V2FybmluZyIsImNvbXBvbmVudFdpbGxNb3VudCIsInNldE1vbWVudExvY2FsZSIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJuZXh0UHJvcHMiLCJjb21wb25lbnREaWRVcGRhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlbW92ZSIsIm1vbWVudCIsImUiLCJtb21lbnRMb2NhbGUiLCJyZW5kZXIiLCJDaGlsZHJlbiIsIm9ubHkiLCJjaGlsZHJlbiIsIkNvbXBvbmVudCIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsInN0cmluZyIsImJvb2wiLCJlbGVtZW50IiwiZGVmYXVsdFByb3BzIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJjb25maWciLCJvcHRpb25zIiwiZ2V0Q29udGV4dFByb3BzIiwiZGlzcGxheU5hbWUiLCJyb290IiwiaW5pdExvY2FsZXMiLCJzZXRMYW5ndWFnZSIsInNldExvY2FsZSIsInNldERpcmVjdGlvbiIsImdldExhbmd1YWdlIiwiZ2V0TG9jYWxlIiwiZ2V0RGlyZWN0aW9uIiwiQ29uc3VtZXIiLCJnZXRDb250ZXh0IiwidXNlU291cmNlTWFwIiwibGlzdCIsInRvU3RyaW5nIiwibWFwIiwiaXRlbSIsImNvbnRlbnQiLCJjc3NXaXRoTWFwcGluZ1RvU3RyaW5nIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwiaWQiLCJjc3NNYXBwaW5nIiwiYnRvYSIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlcyIsInNvdXJjZSIsInNvdXJjZVJvb3QiLCJjb25jYXQiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIiwiYmxhY2tMaXN0Iiwic3RhdGljcyIsIlRhcmdldCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiaW5kZXhPZiIsInByb3BlcnR5IiwiZmV0Y2hEYXRhQnlQYXRoIiwicGF0aCIsImZpZWxkIiwic3BsaXQiLCJ2YWwiLCJtYXRjaCIsImNvbEluZGV4IiwiSWNvbiIsInR5cGUiLCJzaXplIiwiY2xhc3NOYW1lIiwib3RoZXIiLCJkaXIiLCJvbmVPZiIsIl90eXBlTWFyayIsInR5cGVPZiIsImlzQXJyYXlMaWtlIiwiaXNQcm9taXNlIiwiaXNQbGFpbk9iamVjdCIsInNoYWxsb3dFcXVhbCIsImVhY2giLCJwaWNrT3RoZXJzIiwicGlja0F0dHJzV2l0aCIsInByb3RvdHlwZSIsInJlcGxhY2UiLCJ0aGVuIiwiY3RvciIsImNvbnN0cnVjdG9yIiwicHJvdCIsIm9iakEiLCJvYmpCIiwiY29tcGFyZSIsImtleUEiLCJrZXlCIiwibGVuIiwiaGFzQ2FsbGJhY2siLCJ2YWxBIiwidmFsQiIsInJldCIsImNhbGxiYWNrIiwiZGlyZWN0aW9uIiwicmV2ZXJzZWQiLCJ2YWx1ZSIsIl9pc0luT2JqIiwiaG9sZFByb3BzIiwib3RoZXJzIiwiYmluZEN0eCIsIkl0ZW0iLCJjb21wb25lbnREaWRNb3VudCIsIml0ZW1Ob2RlIiwicGFyZW50TW9kZSIsIm1lbnVOb2RlIiwicGFyZW50Tm9kZSIsImhlYWRlciIsImZvb3RlciIsInF1ZXJ5U2VsZWN0b3IiLCJzZXRGb2N1cyIsImZvY3VzYWJsZSIsImRpc2FibGVkIiwiZ2V0Rm9jdXNlZCIsIl9rZXkiLCJmb2N1c2VkS2V5Iiwic3RhdGUiLCJmb2N1c2VkIiwicHJldmVudFNjcm9sbCIsInNjcm9sbEhlaWdodCIsImNsaWVudEhlaWdodCIsInNjcm9sbEJvdHRvbSIsInNjcm9sbFRvcCIsIml0ZW1Cb3R0b20iLCJvZmZzZXRUb3AiLCJvZmZzZXRIZWlnaHQiLCJoYW5kbGVDbGljayIsInN0b3BQcm9wYWdhdGlvbiIsImhhbmRsZUl0ZW1DbGljayIsIm9uQ2xpY2siLCJwcmV2ZW50RGVmYXVsdCIsImhhbmRsZUtleURvd24iLCJoYW5kbGVJdGVtS2V5RG93biIsIm9uS2V5RG93biIsImdldFRpdGxlIiwibGFiZWxTdHJpbmciLCJsb29wIiwiY2hpbGQiLCJsZXZlbCIsInJlcGxhY2VDbGFzc05hbWUiLCJncm91cEluZGVudCIsImNvbXBvbmVudCIsIm5lZWRJbmRlbnQiLCJpbmxpbmVJbmRlbnQiLCJpdGVtQ2xhc3NOYW1lIiwibmV3Q2xhc3NOYW1lIiwidGFiSW5kZXgiLCJ0YWJiYWJsZUtleSIsInN0eWxlIiwiVGFnTmFtZSIsIm51bWJlciIsInBhcmVudCIsIk92ZXJsYXkiLCJHYXRld2F5IiwiUG9zaXRpb24iLCJQb3B1cCIsImV4cG9ydE5hbWVzIiwibm9vcCIsIkJvZHkiLCJnZXRSb3dSZWYiLCJyb3ciLCJyb3dSZWYiLCJvblJvd0NsaWNrIiwicmVjb3JkIiwiaW5kZXgiLCJvblJvd01vdXNlRW50ZXIiLCJvblJvd01vdXNlTGVhdmUiLCJUYWciLCJjb2xHcm91cCIsImxvYWRpbmciLCJlbXB0eUNvbnRlbnQiLCJjb21wb25lbnRzIiwiZ2V0Q2VsbFByb3BzIiwicHJpbWFyeUtleSIsImdldFJvd1Byb3BzIiwiZGF0YVNvdXJjZSIsImNlbGxSZWYiLCJjb2x1bW5zIiwiUm93IiwiUm93Q29tcG9uZW50IiwiQ2VsbCIsIkNlbGxDb21wb25lbnQiLCJlbXB0eSIsInJvd3MiLCJyb3dQcm9wcyIsInJvd0NsYXNzIiwiZmlyc3QiLCJsYXN0IiwiZXhwYW5kZWQiLCJfX2V4cGFuZGVkIiwiYmluZCIsIlJlYWN0IiwiYW55IiwiYXJyYXkiLCJyb3dJbmRleCIsIm9uTW91c2VFbnRlciIsIm9uUm93SG92ZXIiLCJvbk1vdXNlTGVhdmUiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJpc0VxdWFsIiwiaXNFbnRlciIsImN1cnJlbnRSb3ciLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwicmVuZGVyQ2VsbHMiLCJsb2NrVHlwZSIsImNvbnRleHQiLCJkYXRhSW5kZXgiLCJhbGlnbiIsIndpZHRoIiwiYXR0cnMiLCJub3RSZW5kZXJDZWxsSW5kZXgiLCJtYXRjaENlbGxJbmRleCIsImNlbGxJbmRleCIsInNwbGljZSIsImNvbFNwYW4iLCJyb3dTcGFuIiwiX2dldE5vdFJlbmRlckNlbGxJbmRleCIsImNlbGwiLCJtYXhDb2xJbmRleCIsIm1heFJvd0luZGV4IiwiaiIsImNscyIsImNvbnRleHRUeXBlcyIsInJlc2l6YWJsZSIsInRpdGxlIiwiaW5uZXJTdHlsZSIsIl9fbm9ybWFsaXplZCIsImZpbHRlck1vZGUiLCJmaWx0ZXJzIiwic29ydGFibGUiLCJsb2NrIiwidGFnU3R5bGUiLCJjZWxsUHJvcHMiLCJjbG9uZUVsZW1lbnQiLCJ0ZXh0QWxpZ24iLCJvbmVPZlR5cGUiLCJub2RlIiwiRml4ZWRIZWFkZXIiLCJnZXROb2RlIiwiUmVhY3RQcm9wVHlwZXNTZWNyZXQiLCJmaW5kTm9kZSIsInRhcmdldCIsInBhcmFtIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImVyciIsIlNlbGVjdGFibGVJdGVtIiwiZ2V0U2VsZWN0ZWQiLCJzZWxlY3RlZCIsInNlbGVjdE1vZGUiLCJzZWxlY3RlZEtleXMiLCJoYW5kbGVTZWxlY3QiLCJvblNlbGVjdCIsImtleUNvZGUiLCJTUEFDRSIsInJlbmRlclNlbGVjdGVkSWNvbiIsImhhc1NlbGVjdGVkSWNvbiIsInJvb3RTZWxlY3RlZEljb24iLCJsZWZ0IiwiaGVscGVyIiwibmV3UHJvcHMiLCJtZW51Q2hpbGRUeXBlIiwiQ29sdW1uIiwiYXJyYXlPZiIsInNoYXBlIiwibGFiZWwiLCJGaXhlZFdyYXBwZXIiLCJ3cmFwcGVyQ29udGVudCIsIlRpbWVsaW5lIiwiZXhwYW5kIiwiZm9sZCIsIkNhcmQiLCJDYWxlbmRhciIsInRvZGF5Iiwibm93Iiwib2siLCJjbGVhciIsIm1vbnRoIiwieWVhciIsInByZXZZZWFyIiwibmV4dFllYXIiLCJwcmV2TW9udGgiLCJuZXh0TW9udGgiLCJwcmV2RGVjYWRlIiwibmV4dERlY2FkZSIsIkRhdGVQaWNrZXIiLCJwbGFjZWhvbGRlciIsImRhdGV0aW1lUGxhY2Vob2xkZXIiLCJtb250aFBsYWNlaG9sZGVyIiwieWVhclBsYWNlaG9sZGVyIiwic2VsZWN0VGltZSIsInNlbGVjdERhdGUiLCJzdGFydFBsYWNlaG9sZGVyIiwiZW5kUGxhY2Vob2xkZXIiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwiRGlhbG9nIiwiY2FuY2VsIiwiUGFnaW5hdGlvbiIsInByZXYiLCJuZXh0IiwiZ29UbyIsInBhZ2UiLCJnbyIsInBhZ2VTaXplIiwiSW5wdXQiLCJTZWxlY3QiLCJzZWxlY3RQbGFjZWhvbGRlciIsImF1dG9Db21wbGV0ZVBsYWNlaG9sZGVyIiwibm90Rm91bmRDb250ZW50IiwiVGFibGUiLCJyZXNldCIsImFzYyIsImRlc2MiLCJmb2xkZWQiLCJmaWx0ZXIiLCJzZWxlY3RBbGwiLCJUaW1lUGlja2VyIiwiVHJhbnNmZXIiLCJpdGVtcyIsIm1vdmVBbGwiLCJzZWFyY2hQbGFjZWhvbGRlciIsIlVwbG9hZCIsImNhcmQiLCJhZGRQaG90byIsImRyYWciLCJ0ZXh0IiwiaGludCIsIlNlYXJjaCIsImJ1dHRvblRleHQiLCJDaGVja2JveCIsIkdyb3VwIiwibmV3UHJlZml4IiwibG9jYWxlRnJvbUNvbnRleHQiLCJuZXdMb2NhbGUiLCJuZXdQdXJlIiwibmV3UnRsIiwiaGFzQ2xhc3MiLCJ0b2dnbGVDbGFzcyIsImdldFN0eWxlIiwic2V0U3R5bGUiLCJzY3JvbGxiYXIiLCJnZXRPZmZzZXQiLCJoYXNET00iLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJfZm9yY2UiLCJ0cmltIiwidG9nZ2xlIiwiZmxhZyIsIm1hdGNoZXMiLCJtYXRjaGVzRm4iLCJfYm9keSIsImJvZHkiLCJoZWFkIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJzZWxlY3RvciIsIl9nZXRDb21wdXRlZFN0eWxlIiwibm9kZVR5cGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiUElYRUxfUEFUVEVSTiIsInJlbW92ZVBpeGVsIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJfZ2V0U3R5bGVWYWx1ZSIsInRvTG93ZXJDYXNlIiwib2Zmc2V0V2lkdGgiLCJ0ZXN0IiwicGFyc2VGbG9hdCIsImZsb2F0TWFwIiwiY3NzRmxvYXQiLCJzdHlsZUZsb2F0IiwiZmxvYXQiLCJuYW1lIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInNjcm9sbERpdiIsInBvc2l0aW9uIiwiaGVpZ2h0Iiwib3ZlcmZsb3ciLCJhcHBlbmRDaGlsZCIsInNjcm9sbGJhcldpZHRoIiwiY2xpZW50V2lkdGgiLCJzY3JvbGxiYXJIZWlnaHQiLCJyZW1vdmVDaGlsZCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aW4iLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJwYWdlWU9mZnNldCIsInBhZ2VYT2Zmc2V0IiwiY2FtZWxjYXNlIiwiaHlwaGVuYXRlIiwiJDAiLCIkMSIsInRvVXBwZXJDYXNlIiwiaWVWZXJzaW9uIiwiZG9jdW1lbnRNb2RlIiwidW5kZWZpbmVkIiwiaXNQcm9kdWN0aW9uIiwiUFJPRFVDVElPTl9FTlYiLCJyZXN1bHQiLCJCQUNLU1BBQ0UiLCJUQUIiLCJFTlRFUiIsIlNISUZUIiwiQ1RSTCIsIkFMVCIsIkVTQyIsIkVORCIsIkhPTUUiLCJMRUZUIiwiVVAiLCJSSUdIVCIsIkRPV04iLCJFU0NBUEUiLCJMRUZUX0FSUk9XIiwiVVBfQVJST1ciLCJSSUdIVF9BUlJPVyIsIkRPV05fQVJST1ciLCJDT05UUk9MIiwiT1BUSU9OIiwiQ01EIiwiQ09NTUFORCIsIkRFTEVURSIsInN0eWxlRXF1YWwiLCJhIiwiZWxlbWVudEVxdWFscyIsImIiLCJ0eXBlT2ZBIiwidHlwZU9mQiIsInJlZiIsInNoYWxsb3dFbGVtZW50RXF1YWxzIiwiYUNvdW50IiwiYkNvdW50Iiwic2F2ZUxhc3RGb2N1c05vZGUiLCJnZXRGb2N1c05vZGVMaXN0IiwiYmFja0xhc3RGb2N1c05vZGUiLCJtYWtlQ2hhaW4iLCJpc1Njcm9sbERpc3BsYXkiLCJzY3JvbGxiYXJTdHlsZSIsImhhc1Njcm9sbCIsImRvYyIsImRvY3VtZW50RWxlbWVudCIsInByZWZpeGVzIiwiZ2V0U3R5bGVQcm9wZXJ0eSIsIm1vZGFscyIsImJvZHlPdmVyZmxvd1kiLCJib2R5UGFkZGluZ1JpZ2h0Iiwic2F2ZUNvbnRlbnRSZWYiLCJjb250ZW50UmVmIiwic2F2ZUdhdGV3YXlSZWYiLCJnYXRld2F5UmVmIiwidmlzaWJsZSIsInN0YXR1cyIsImFuaW1hdGlvbiIsImdldEFuaW1hdGlvbiIsImxhc3RBbGlnbiIsInRpbWVvdXRNYXAiLCJiZWZvcmVPcGVuIiwiZW50ZXIiLCJhZGREb2N1bWVudEV2ZW50cyIsIm92ZXJsYXlNYW5hZ2VyIiwiYWRkT3ZlcmxheSIsIl9pc01vdW50ZWQiLCJ3aWxsT3BlbiIsIndpbGxDbG9zZSIsImJlZm9yZUNsb3NlIiwic2V0U3RhdGUiLCJsZWF2ZSIsInByZXZQcm9wcyIsIm9wZW4iLCJjbG9zZSIsImFkZEFuaW1hdGlvbkV2ZW50cyIsIndyYXBwZXJOb2RlIiwiZ2V0V3JhcHBlck5vZGUiLCJzZXRUaW1lb3V0Iiwib25PcGVuIiwiYWZ0ZXJPcGVuIiwib25DbG9zZSIsImFmdGVyQ2xvc2UiLCJyZW1vdmVPdmVybGF5Iiwic2V0Rm9jdXNOb2RlIiwiX2lzRGVzdHJveWVkIiwicmVtb3ZlRG9jdW1lbnRFdmVudHMiLCJmb2N1c1RpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJfYW5pbWF0aW9uIiwib2ZmIiwiZ2V0QW5pbWF0aW9uQnlBbGlnbiIsImluIiwib3V0IiwiZ2V0Q29udGVudE5vZGUiLCJvbiIsImVuZCIsImhhbmRsZUFuaW1hdGVFbmQiLCJhbmltYXRpb25EZWxheSIsImFuaW1hdGlvbkR1cmF0aW9uIiwidGltZSIsImhhbmRsZVBvc2l0aW9uIiwibmVlZEFkanVzdCIsIm9uTGVhdmVkIiwib25FbnRlcmVkIiwib25FbnRlcmluZyIsIm9uTGVhdmluZyIsImRpc2FibGVTY3JvbGwiLCJvdmVyZmxvd1kiLCJwYWRkaW5nUmlnaHQiLCJhdXRvRm9jdXMiLCJfaGFzRm9jdXNlZCIsImZvY3VzTm9kZUxpc3QiLCJnZXRDb250ZW50IiwiZ2V0Q2hpbGROb2RlIiwiY2FuQ2xvc2VCeUVzYyIsIl9rZXlkb3duRXZlbnRzIiwiaGFuZGxlRG9jdW1lbnRLZXlEb3duIiwiY2FuQ2xvc2VCeU91dFNpZGVDbGljayIsIl9jbGlja0V2ZW50cyIsImhhbmRsZURvY3VtZW50Q2xpY2siLCJpc0N1cnJlbnRPdmVybGF5Iiwib25SZXF1ZXN0Q2xvc2UiLCJzYWZlTm9kZSIsInNhZmVOb2RlcyIsInVuc2hpZnQiLCJoYW5kbGVNYXNrQ2xpY2siLCJjYW5DbG9zZUJ5TWFzayIsImdldEluc3RhbmNlIiwicHJvcENoaWxkcmVuIiwib2Zmc2V0IiwiY29udGFpbmVyIiwiaGFzTWFzayIsImJlZm9yZVBvc2l0aW9uIiwib25Qb3NpdGlvbiIsIndyYXBwZXJTdHlsZSIsInByb3BTaG91bGRVcGRhdGVQb3NpdGlvbiIsInNob3VsZFVwZGF0ZVBvc2l0aW9uIiwiY2FjaGUiLCJ3cmFwcGVyQ2xhc3NOYW1lIiwib25NYXNrTW91c2VFbnRlciIsIm9uTWFza01vdXNlTGVhdmUiLCJzdGF0ZVZpc2libGUiLCJjaGlsZENsYXp6IiwiRXJyb3IiLCJ3cmFwcGVyQ2xhenoiLCJuZXdXcmFwcGVyU3R5bGUiLCJkaXNwbGF5IiwiVklFV1BPUlQiLCJzYXZlQ2hpbGRSZWYiLCJjb250YWluZXJOb2RlIiwiZ2V0Q29udGFpbmVyTm9kZSIsImZvcmNlVXBkYXRlIiwidGFyZ2V0Tm9kZSIsInBsYWNlIiwic2V0UG9zaXRpb24iLCJuZWVkTGlzdGVuUmVzaXplIiwiaGFuZGxlUmVzaXplIiwicmVzaXplVGltZW91dCIsImNvbnRlbnROb2RlIiwiZ2V0VGFyZ2V0Tm9kZSIsInJlc3VsdEFsaWduIiwicGluRWxlbWVudCIsImJhc2VFbGVtZW50IiwiaXNSdGwiLCJIZWFkZXIiLCJnZXRDZWxsUmVmIiwiaGVhZGVyQ2VsbFJlZiIsIm9uU29ydCIsIm9yZGVyIiwic29ydCIsImZpbHRlclBhcmFtcyIsIm9uRmlsdGVyIiwiYWZmaXhSZWYiLCJvblJlc2l6ZUNoYW5nZSIsIkZpbHRlciIsIkZpbHRlckNvbXBvbmVudCIsIlNvcnQiLCJTb3J0Q29tcG9uZW50IiwiUmVzaXplIiwiUmVzaXplQ29tcG9uZW50IiwiY29scyIsImNvbCIsInNvcnRFbGVtZW50IiwiZmlsdGVyRWxlbWVudCIsInJlc2l6ZUVsZW1lbnQiLCJmaWx0ZXJDb25maWciLCJfc2VsZWN0ZWRLZXlzIiwicmVuZGVyTWVudUl0ZW0iLCJyZW5kZXJTdWJNZW51IiwicmVuZGVyTWVudUNvbnRlbnQiLCJvbkZpbHRlckNvbmZpcm0iLCJvbkZpbHRlckNsZWFyIiwiZmlsdGVyS2V5ZG93biIsIm9uRmlsdGVyVmlzaWJsZSIsIm9uRmlsdGVyU2VsZWN0IiwiTWVudSIsImRlZmF1bHRTZWxlY3RlZEtleXMiLCJuZXdDaGlsZHJlbiIsImdldE5ld0NoaWxkcmVuIiwiZ2V0Rmlyc3RBdmFsaWFibGVsQ2hpbGRLZXkiLCJvcGVuS2V5cyIsImdldEluaXRPcGVuS2V5cyIsIm5vcm1hbGl6ZVRvQXJyYXkiLCJwb3B1cE5vZGVzIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsImsybiIsIm9uQmx1ciIsImluaXRPcGVuS2V5cyIsImRlZmF1bHRPcGVuS2V5cyIsImRlZmF1bHRPcGVuQWxsIiwibW9kZSIsIm9wZW5Nb2RlIiwicDJuIiwicG9zUHJlZml4IiwiaW5kZXhXcmFwcGVyIiwibmV3Q2hpbGQiLCJwb3MiLCJpc1NpYmxpbmciLCJjdXJyZW50UG9zIiwidGFyZ2V0UG9zIiwiY3VycmVudE51bXMiLCJzbGljZSIsInRhcmdldE51bXMiLCJldmVyeSIsIm51bSIsImlzQW5jZXN0b3IiLCJoYW5kbGVPcGVuIiwidHJpZ2dlclR5cGUiLCJuZXdPcGVuS2V5cyIsImsiLCJzb21lIiwiZ2V0UGF0aCIsImtleVBhdGgiLCJsYWJlbFBhdGgiLCJudW1zIiwicGFyZW50TnVtcyIsInBhcmVudFBvcyIsInNlbGVjdCIsIm1lbnVJdGVtIiwic2hhbGxvd1NlbGVjdCIsIm5ld1NlbGVjdGVkS2V5cyIsIm9uSXRlbUZvY3VzIiwicHJldktleSIsIm5leHRLZXkiLCJvbkl0ZW1DbGljayIsImlzQXZhaWxhYmxlUG9zIiwicmVmUG9zIiwiZ2V0QXZhaWxhYmxlS2V5IiwicHMiLCJwIiwidGFyZ2V0SW5kZXgiLCJmaW5kIiwiZ2V0UGFyZW50S2V5IiwiYXZhbGlhYmxlS2V5IiwicGFyZW50S2V5Iiwib25JdGVtS2V5RG93biIsImhvekFsaWduIiwicm9sZSIsImhlYWRlckVsZW1lbnQiLCJpdGVtc0VsZW1lbnQiLCJmb290ZXJFbGVtZW50Iiwic2hvdWxkV3JhcEl0ZW1zQW5kRm9vdGVyIiwiaGFuZGxlRW50ZXIiLCJpc05leHRNZW51IiwiaW5saW5lQXJyb3dEaXJlY3Rpb24iLCJwb3B1cEF1dG9XaWR0aCIsInBvcHVwQWxpZ24iLCJwb3B1cFByb3BzIiwicG9wdXBDbGFzc05hbWUiLCJwb3B1cFN0eWxlIiwibGFiZWxUb2dnbGVDaGVja2VkIiwiZXhwYW5kQW5pbWF0aW9uIiwiRmlyc3RDaGlsZCIsImNoaWxkcmVuQXJyYXkiLCJ0b0FycmF5IiwiQW5pbWF0ZSIsIm5vcm1hbGl6ZU5hbWVzIiwibmFtZXMiLCJhcHBlYXIiLCJhcHBlYXJBY3RpdmUiLCJlbnRlckFjdGl2ZSIsImxlYXZlQWN0aXZlIiwiYW5pbWF0aW9uQXBwZWFyIiwic2luZ2xlTW9kZSIsImJlZm9yZUFwcGVhciIsIm9uQXBwZWFyIiwiYWZ0ZXJBcHBlYXIiLCJiZWZvcmVFbnRlciIsIm9uRW50ZXIiLCJhZnRlckVudGVyIiwiYmVmb3JlTGVhdmUiLCJvbkxlYXZlIiwiYWZ0ZXJMZWF2ZSIsImFuaW1hdGVDaGlsZHJlbiIsIl9DU1NUcmFuc2l0aW9uIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9SZXBsYWNlVHJhbnNpdGlvbiIsIl9UcmFuc2l0aW9uR3JvdXAiLCJfVHJhbnNpdGlvbiIsIl9fZXNNb2R1bGUiLCJUcmFuc2l0aW9uIiwiVHJhbnNpdGlvbkdyb3VwIiwiUmVwbGFjZVRyYW5zaXRpb24iLCJDU1NUcmFuc2l0aW9uIiwiRVhJVElORyIsIkVOVEVSRUQiLCJFTlRFUklORyIsIkVYSVRFRCIsIlVOTU9VTlRFRCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwiX3JlYWN0IiwiX3JlYWN0RG9tIiwiX3JlYWN0TGlmZWN5Y2xlc0NvbXBhdCIsIl9Qcm9wVHlwZXMiLCJuZXdPYmoiLCJkZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInNldCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiZXhjbHVkZWQiLCJzb3VyY2VLZXlzIiwiX2luaGVyaXRzTG9vc2UiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfUmVhY3QkQ29tcG9uZW50IiwiX3RoaXMiLCJwYXJlbnRHcm91cCIsInRyYW5zaXRpb25Hcm91cCIsImlzTW91bnRpbmciLCJpbml0aWFsU3RhdHVzIiwiYXBwZWFyU3RhdHVzIiwidW5tb3VudE9uRXhpdCIsIm1vdW50T25FbnRlciIsIm5leHRDYWxsYmFjayIsIl9wcm90byIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIl9yZWYiLCJwcmV2U3RhdGUiLCJuZXh0SW4iLCJ1cGRhdGVTdGF0dXMiLCJuZXh0U3RhdHVzIiwiY2FuY2VsTmV4dENhbGxiYWNrIiwiZ2V0VGltZW91dHMiLCJ0aW1lb3V0IiwiZXhpdCIsIm1vdW50aW5nIiwiZmluZERPTU5vZGUiLCJwZXJmb3JtRW50ZXIiLCJwZXJmb3JtRXhpdCIsIl90aGlzMiIsImFwcGVhcmluZyIsInRpbWVvdXRzIiwic2FmZVNldFN0YXRlIiwib25UcmFuc2l0aW9uRW5kIiwiX3RoaXMzIiwib25FeGl0ZWQiLCJvbkV4aXQiLCJvbkV4aXRpbmciLCJuZXh0U3RhdGUiLCJzZXROZXh0Q2FsbGJhY2siLCJfdGhpczQiLCJhY3RpdmUiLCJldmVudCIsImhhbmRsZXIiLCJhZGRFbmRMaXN0ZW5lciIsIl90aGlzJHByb3BzIiwiY2hpbGRQcm9wcyIsImlzUmVxdWlyZWQiLCJwdCIsInRpbWVvdXRzU2hhcGUiLCJfbGVuIiwiX2RlZmF1bHQiLCJwb2x5ZmlsbCIsInVwZGF0ZXIiLCJfX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEZsYWciLCJfX3JlYWN0SW50ZXJuYWxTbmFwc2hvdCIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyIsImlzUmVhY3RDb21wb25lbnQiLCJmb3VuZFdpbGxNb3VudE5hbWUiLCJmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIiwiZm91bmRXaWxsVXBkYXRlTmFtZSIsIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIiwiY29tcG9uZW50TmFtZSIsIm5ld0FwaU5hbWUiLCJjb21wb25lbnREaWRVcGRhdGVQb2x5ZmlsbCIsIm1heWJlU25hcHNob3QiLCJzbmFwc2hvdCIsInRyYW5zaXRpb25UaW1lb3V0IiwiY2xhc3NOYW1lc1NoYXBlIiwiX3Byb3BUeXBlcyIsInRyYW5zaXRpb25UeXBlIiwidGltZW91dFByb3BOYW1lIiwiZW5hYmxlZFByb3BOYW1lIiwiZW50ZXJEb25lIiwiZXhpdERvbmUiLCJleGl0QWN0aXZlIiwiX0NoaWxkTWFwcGluZyIsIl9leHRlbmRzIiwiYXNzaWduIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsInZhbHVlcyIsImNoaWxkRmFjdG9yeSIsImhhbmRsZUV4aXRlZCIsImZpcnN0UmVuZGVyIiwiYXBwZWFyZWQiLCJtb3VudGVkIiwicHJldkNoaWxkTWFwcGluZyIsImdldEluaXRpYWxDaGlsZE1hcHBpbmciLCJnZXROZXh0Q2hpbGRNYXBwaW5nIiwiY3VycmVudENoaWxkTWFwcGluZyIsImdldENoaWxkTWFwcGluZyIsIlBvcHVwSXRlbSIsImdldFBvcHVwIiwicG9wdXAiLCJnZXRPcGVuIiwiZ2V0UG9wdXBQcm9wcyIsIm9uVmlzaWJsZUNoYW5nZSIsImhhbmRsZVBvcHVwT3BlbiIsImF1dG9XaWR0aCIsInJvb3RQb3B1cEF1dG9XaWR0aCIsInJvb3RQb3B1cEFsaWduIiwicG9wdXBOb2RlIiwib3ZlcmxheSIsImhhbmRsZVBvcHVwQ2xvc2UiLCJyZW5kZXJJdGVtIiwic2VsZWN0YWJsZSIsIk5ld0l0ZW0iLCJpdGVtUHJvcHMiLCJyZW5kZXJQb3B1cCIsInRyaWdnZXIiLCJwb3NpdGlvblByb3BzIiwiaGFzU3ViTWVudSIsInNlbGVjdGFibGVGcm9tUHJvcHMiLCJyb290VHJpZ2dlclR5cGUiLCJuZXdUcmlnZ2VyVHlwZSIsInRyaWdnZXJJc0ljb24iLCJhcnJvd1Byb3BzIiwiYXJyb3ciLCJDaGVja2FibGVJdGVtIiwiaGFuZGxlQ2hlY2siLCJjaGVja1R5cGUiLCJjaGVja2VkIiwib25DaGFuZ2UiLCJjaGVja0Rpc2FibGVkIiwicmVuZGVyQ2hlY2siLCJpbmRldGVybWluYXRlIiwiQ2hlY2siLCJSYWRpbyIsImNoZWNrUHJvcHMiLCJpc0NoZWNrZWQiLCJzZWxlY3RlZFZhbHVlIiwiX19ncm91cF9fIiwiZGVmYXVsdENoZWNrZWQiLCJkZWZhdWx0SW5kZXRlcm1pbmF0ZSIsIm5leHRDb250ZXh0Iiwib3RoZXJQcm9wcyIsIm90aGVyc0RhdGEiLCJjaGlsZElucHV0IiwiZ2V0U3RhdGVFbGVtZW50IiwiZ2V0U3RhdGVDbGFzc05hbWUiLCJsYWJlbENscyIsIlVJU3RhdGUiLCJiYXNlIiwib25Gb2N1cyIsIl9vblVJRm9jdXMiLCJfb25VSUJsdXIiLCJyZXNldFVJU3RhdGUiLCJSYWRpb0dyb3VwIiwiaXNCdXR0b24iLCJpbnB1dCIsImNsc0lubmVyIiwicHJlc3MiLCJ1bnByZXNzIiwiY2xzV3JhcHBlciIsImNoaWxkcmVuQ2xzIiwicmFkaW9Db21wIiwiX29uVUlNb3VzZUVudGVyIiwiX29uVUlNb3VzZUxlYXZlIiwiZCIsImtleWRvd25IYW5kbGVyIiwicmVuZGVyU29ydCIsInNvcnRTdGF0dXMiLCJpY29ucyIsInNvcnRPcmRlciIsIlNlbGVjdGlvblJvdyIsInNlbGVjdGVkUm93S2V5cyIsIkV4cGFuZGVkUm93IiwicmVuZGVyRXhwYW5kZWRSb3ciLCJleHBhbmRlZFJvd1JlbmRlciIsImV4cGFuZGVkUm93SW5kZW50Iiwib3BlblJvd0tleXMiLCJsZWZ0SW5kZW50IiwicmlnaHRJbmRlbnQiLCJ0b3RhbEluZGVudCIsInJlbmRlckNvbHMiLCJMb2NrUm93IiwiRml4ZWRCb2R5Iiwib25Cb2R5U2Nyb2xsIiwib25TY3JvbGwiLCJtYXhCb2R5SGVpZ2h0IiwiZml4ZWRIZWFkZXIiLCJtYXhIZWlnaHQiLCJMaXN0SGVhZGVyIiwiaGFzQ2hpbGRyZW5TZWxlY3Rpb24iLCJoYXNTZWxlY3Rpb24iLCJMaXN0Rm9vdGVyIiwiQnV0dG9uIiwiQnV0dG9uR3JvdXAiLCJ0cmFuc2Zvcm0iLCJkZXByZWNhdGVkIiwibmV3VHlwZSIsImdob3N0IiwicHJpbWFyeSIsInNlY29uZGFyeSIsIm5vcm1hbCIsImRhcmsiLCJsaWdodCIsIkV4cGFuZCIsIkxvYWRpbmciLCJ0aXAiLCJpbmRpY2F0b3IiLCJjb2xvciIsImZ1bGxTY3JlZW4iLCJ0aXBBbGlnbiIsImluZGljYXRvckRvbSIsImRvdENscyIsImJhY2tncm91bmRDb2xvciIsImZ1c2lvblJlYWN0b3JDbHMiLCJsb2FkaW5nQ2xzIiwidGlwQ2xzIiwiY29udGVudENscyIsImFuaW1hdGUiLCJTdWJNZW51IiwiQ2hlY2tib3hJdGVtIiwiUmFkaW9JdGVtIiwiRGl2aWRlciIsImluZGVudFNpemUiLCJvbkRlc2VsZWN0IiwibmV3T25TZWxlY3QiLCJleHRyYSIsIk9SREVSX0xJU1QiLCJmaXhlZCIsInNlbGVjdGlvbiIsInRyZWUiLCJ2aXJ0dWFsIiwic3RpY2t5IiwicmVkdWNlIiwiY3VycmVudCIsIkJhc2UiLCJHcm91cEhlYWRlciIsIkdyb3VwRm9vdGVyIiwiZXhwYW5kZWRSb3dLZXlzIiwib25FeHBhbmRlZENoYW5nZSIsIm9uUm93T3BlbiIsImlzTG9hZGluZyIsImluZGVudCIsIm9wdGltaXphdGlvbiIsImdldFJvd0NsYXNzTmFtZSIsIm5ld0dldFJvd1Byb3BzIiwiY2hlY2tQcm9wVHlwZXMiLCJwcmludFdhcm5pbmciLCJtZXNzYWdlIiwiY29uc29sZSIsImVycm9yIiwieCIsImVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwiLCJJVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJpdGVyYXRvckZuIiwiQU5PTllNT1VTIiwiUmVhY3RQcm9wVHlwZXMiLCJjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlciIsInN5bWJvbCIsImNyZWF0ZUFueVR5cGVDaGVja2VyIiwiY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyIiwiY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyIiwiaW5zdGFuY2VPZiIsImNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIiLCJjcmVhdGVOb2RlQ2hlY2tlciIsIm9iamVjdE9mIiwiY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlciIsImNyZWF0ZUVudW1UeXBlQ2hlY2tlciIsImNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIiLCJjcmVhdGVTaGFwZVR5cGVDaGVja2VyIiwiZXhhY3QiLCJjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyIiwiaXMiLCJ5IiwiUHJvcFR5cGVFcnJvciIsInN0YWNrIiwiY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIiLCJ2YWxpZGF0ZSIsIm1hbnVhbFByb3BUeXBlQ2FsbENhY2hlIiwibWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQiLCJwcm9wTmFtZSIsImxvY2F0aW9uIiwicHJvcEZ1bGxOYW1lIiwic2VjcmV0IiwiY2FjaGVLZXkiLCJjaGFpbmVkQ2hlY2tUeXBlIiwiZXhwZWN0ZWRUeXBlIiwicHJvcFZhbHVlIiwicHJvcFR5cGUiLCJnZXRQcm9wVHlwZSIsInByZWNpc2VUeXBlIiwiZ2V0UHJlY2lzZVR5cGUiLCJ0eXBlQ2hlY2tlciIsImV4cGVjdGVkQ2xhc3MiLCJleHBlY3RlZENsYXNzTmFtZSIsImFjdHVhbENsYXNzTmFtZSIsImdldENsYXNzTmFtZSIsImV4cGVjdGVkVmFsdWVzIiwidmFsdWVzU3RyaW5nIiwiYXJyYXlPZlR5cGVDaGVja2VycyIsImNoZWNrZXIiLCJnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmciLCJpc05vZGUiLCJzaGFwZVR5cGVzIiwiYWxsS2V5cyIsInN0ZXAiLCJlbnRyaWVzIiwiZG9uZSIsImVudHJ5IiwiaXNTeW1ib2wiLCJSZWdFeHAiLCJEYXRlIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvcElzRW51bWVyYWJsZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwidG9PYmplY3QiLCJUeXBlRXJyb3IiLCJzaG91bGRVc2VOYXRpdmUiLCJ0ZXN0MSIsIlN0cmluZyIsImdldE93blByb3BlcnR5TmFtZXMiLCJ0ZXN0MiIsImZyb21DaGFyQ29kZSIsIm9yZGVyMiIsIm4iLCJ0ZXN0MyIsImxldHRlciIsImZyb20iLCJ0byIsInN5bWJvbHMiLCJzIiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwidHlwZVNwZWNzIiwiZ2V0U3RhY2siLCJ0eXBlU3BlY05hbWUiLCJleCIsImVtcHR5RnVuY3Rpb24iLCJzaGltIiwiZ2V0U2hpbSIsImdldERpc3BsYXlOYW1lIiwiZ2xvYmFsTG9jYWxlcyIsImN1cnJlbnRHbG9iYWxMYW5ndWFnZSIsImN1cnJlbnRHbG9iYWxMb2NhbGUiLCJjdXJyZW50R2xvYmFsUnRsIiwibG9jYWxlcyIsImxhbmd1YWdlIiwiQ29uZmlnZWRDb21wb25lbnQiLCJfZ2V0SW5zdGFuY2UiLCJfZGVwcmVjYXRlZCIsIl9pbnN0YW5jZSIsImNvbnRleHRQcm9wcyIsIm5ld0NvbnRleHRQcm9wcyIsIm5ld090aGVycyIsIlJFQUNUX1NUQVRJQ1MiLCJnZXREZWZhdWx0UHJvcHMiLCJtaXhpbnMiLCJLTk9XTl9TVEFUSUNTIiwiY2FsbGVyIiwiY2FsbGVlIiwiYXJpdHkiLCJnZXRQcm90b3R5cGVPZiIsIm9iamVjdFByb3RvdHlwZSIsImhvaXN0Tm9uUmVhY3RTdGF0aWNzIiwidGFyZ2V0Q29tcG9uZW50Iiwic291cmNlQ29tcG9uZW50IiwiYmxhY2tsaXN0IiwiaW5oZXJpdGVkQ29tcG9uZW50IiwiZGVzY3JpcHRvciIsIm9uY2UiLCJldmVudE5hbWUiLCJ1c2VDYXB0dXJlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJfX2ZuIiwicHJvbWlzZUNhbGwiLCJmbnMiLCJjaGFpbmVkRnVuY3Rpb24iLCJjdHgiLCJucyIsImZuTmFtZSIsInN1Y2Nlc3MiLCJmYWlsdXJlIiwiY2F0Y2giLCJpbnN0ZWFkIiwibXNnIiwiYW5pbWF0aW9uRW5kRXZlbnROYW1lcyIsIldlYmtpdEFuaW1hdGlvbiIsIk9BbmltYXRpb24iLCJ0cmFuc2l0aW9uRXZlbnROYW1lcyIsIldlYmtpdFRyYW5zaXRpb24iLCJPVHJhbnNpdGlvbiIsInRyYW5zaXRpb24iLCJfc3VwcG9ydEVuZCIsImVsIiwiX3N1cHBvcnRDU1MiLCJmbGV4IiwiY2xlYXJMYXN0Rm9jdXNOb2RlIiwibGltaXRUYWJSYW5nZSIsIl9pc1Zpc2libGUiLCJ2aXNpYmlsaXR5IiwiX2lzRm9jdXNhYmxlIiwibm9kZU5hbWUiLCJwYXJzZUludCIsImdldEF0dHJpYnV0ZSIsImhhc1RhYkluZGV4IiwiaXNOYU4iLCJyZXMiLCJub2RlTGlzdCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJtZXRob2QiLCJsYXN0Rm9jdXNFbGVtZW50IiwiYWN0aXZlRWxlbWVudCIsInRhYk5vZGVMaXN0IiwibWF4SW5kZXgiLCJzaGlmdEtleSIsInRpbWVzdGFtcCIsIm1hcEtleXMiLCJmbiIsIm5ld0tleSIsInJlcGxhY2VLZXkiLCJwMSIsInAyIiwidHJhbnNmb3JtQ29udGV4dCIsIl9yb290IiwiX3N0b3JlIiwiTWFwIiwiaGFzIiwiZGVmYXVsdFZhbHVlIiwidXBkYXRlIiwiZGVsZXRlIiwiZ2V0V3JhcHBlclJlZiIsIndyYXBwZXIiLCJnZXRBZmZpeFJlZiIsImdldEhlYWRlckNlbGxSZWYiLCJnZXRUYWJsZUluc3RhbmNlIiwiZ2V0VGFibGVJbnN0YW5jZUZvclZpcnR1YWwiLCJub3JtYWxpemVDaGlsZHJlblN0YXRlIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJmZXRjaEluZm9Gcm9tQmluYXJ5Q2hpbGRyZW4iLCJnZXRDaGlsZHJlbiIsImhhc0dyb3VwSGVhZGVyIiwiZmxhdENoaWxkcmVuIiwiZ3JvdXBDaGlsZHJlbiIsInByb3BzQ2hpbGRyZW4iLCJnZXRDb2xTcGFuIiwiZ3JvdXBDaGlsZCIsInJlbmRlckNvbEdyb3VwIiwicmVuZGVyVGFibGUiLCJoYXNIZWFkZXIiLCJIZWFkZXJDb21wb25lbnQiLCJXcmFwcGVyIiwiV3JhcHBlckNvbXBvbmVudCIsIkJvZHlDb21wb25lbnQiLCJoYXNCb3JkZXIiLCJpc1plYnJhIiwiZW50aXJlRGF0YVNvdXJjZSIsInJlZnMiLCJsb2FkaW5nQ29tcG9uZW50IiwiTG9hZGluZ0NvbXBvbmVudCIsInplYnJhIiwidGFibGUiLCJsb2FkaW5nQ2xhc3NOYW1lIiwiQ29sdW1uR3JvdXAiLCJoYXNFeHBhbmRlZFJvd0N0cmwiLCJnZXRFeHBhbmRlZENvbFByb3BzIiwib25FeHBhbmRlZFJvd0NsaWNrIiwicm93U2VsZWN0aW9uIiwic3RpY2t5SGVhZGVyIiwiYWZmaXhQcm9wcyIsImlzVHJlZSIsInVzZVZpcnR1YWwiLCJyb3dIZWlnaHQiLCJ6aENOIiwidHJhbnNmb3JtRW50cnlFcXVhbCIsInRyYW5zZm9ybUVxdWFsIiwic2hhbGxvd09iamVjdEVxdWFscyIsImFsbE92ZXJsYXlzIiwiZ2V0UGFnZVgiLCJzY3JvbGxMZWZ0IiwiZ2V0UGFnZVkiLCJfZ2V0RWxlbWVudFJlY3QiLCJlbGVtIiwib2Zmc2V0TGVmdCIsIm9mZnNldFBhcmVudCIsIl9nZXRWaWV3cG9ydFNpemUiLCJleHBlY3RlZEFsaWduIiwiX2dldEV4cGVjdGVkQWxpZ24iLCJpc1BpbkZpeGVkIiwiaXNCYXNlRml4ZWQiLCJmaXJzdFBvc2l0aW9uUmVzdWx0IiwicGluRWxlbWVudFBvaW50cyIsIl9ub3JtYWxpemVQb3NpdGlvbiIsImJhc2VFbGVtZW50UG9pbnRzIiwicGluRWxlbWVudFBhcmVudE9mZnNldCIsIl9nZXRQYXJlbnRPZmZzZXQiLCJiYXNlRWxlbWVudE9mZnNldCIsIl9nZXRMZWZ0VG9wIiwiX3NldFBpbkVsZW1lbnRQb3N0aW9uIiwiX2lzSW5WaWV3cG9ydCIsImluVmlld3BvcnRMZWZ0IiwiX21ha2VFbGVtZW50SW5WaWV3cG9ydCIsImluVmlld3BvcnRUb3AiLCJfZ2V0RWxlbWVudE9mZnNldCIsImRvY0VsZW1lbnQiLCJNYXRoIiwibWF4IiwicG9pbnRzIiwiX25vcm1hbGl6ZUVsZW1lbnQiLCJfbm9ybWFsaXplWFkiLCJfeHlDb252ZXJ0ZXIiLCJtIiwiaXNWaWV3cG9ydCIsImRvY0NsaWVudExlZnQiLCJjbGllbnRMZWZ0IiwiZG9jQ2xpZW50VG9wIiwiY2xpZW50VG9wIiwiX3JlcGxhY2VBbGlnbkRpciIsImwiLCJyIiwidCIsImMiLCJyZWdFeHAiLCJ2aWV3cG9ydFNpemUiLCJlbGVtZW50UmVjdCIsInBvc3Rpb24iLCJvZmZzZXRQYXJlbnRXaWR0aCIsImRlZmF1bHRWaXNpYmxlIiwiaGFuZGxlVmlzaWJsZUNoYW5nZSIsImhhbmRsZVRyaWdnZXJDbGljayIsImNhbkNsb3NlQnlUcmlnZ2VyIiwiaGFuZGxlVHJpZ2dlcktleURvd24iLCJoYW5kbGVUcmlnZ2VyTW91c2VFbnRlciIsIl9tb3VzZU5vdEZpcnN0T25NYXNrIiwiX2hpZGVUaW1lciIsIl9zaG93VGltZXIiLCJkZWxheSIsImhhbmRsZVRyaWdnZXJNb3VzZUxlYXZlIiwiaGFuZGxlVHJpZ2dlckZvY3VzIiwiaGFuZGxlVHJpZ2dlckJsdXIiLCJfaXNGb3J3YXJkQ29udGVudCIsImhhbmRsZUNvbnRlbnRNb3VzZURvd24iLCJoYW5kbGVDb250ZW50TW91c2VFbnRlciIsImhhbmRsZUNvbnRlbnRNb3VzZUxlYXZlIiwiaGFuZGxlTWFza01vdXNlRW50ZXIiLCJoYW5kbGVNYXNrTW91c2VMZWF2ZSIsImhhbmRsZVJlcXVlc3RDbG9zZSIsInJlbmRlclRyaWdnZXIiLCJ0cmlnZ2VyVHlwZXMiLCJyZW5kZXJDb250ZW50Iiwib25Nb3VzZURvd24iLCJyZW5kZXJQb3J0YWwiLCJmb2xsb3dUcmlnZ2VyIiwiZmluZFRyaWdnZXJOb2RlIiwiRHJvcGRvd24iLCJnZXRWaXNpYmxlIiwib25NZW51Q2xpY2siLCJoYW5kbGVNb3VzZUVudGVyIiwiaGFuZGxlTW91c2VMZWF2ZSIsInBhc3NQYXJlbnRUb0NoaWxkcmVuIiwicmVuZGVySW5saW5lIiwic3ViTWVudUNvbnRlbnRDbGFzc05hbWUiLCJwcm9wc1RyaWdnZXJUeXBlIiwibGlQcm9wcyIsImFycm9yUHJvcHMiLCJTZWxlY3RhYmVsSXRlbSIsIm5ld1N1Yk1lbnVDb250ZW50Q2xhc3NOYW1lIiwic3ViTWVudSIsIm5ld01vZGUiLCJfYWRkQ2xhc3MiLCJfcmVtb3ZlQ2xhc3MiLCJfdGhpcyRnZXRDbGFzc05hbWVzIiwiZ2V0Q2xhc3NOYW1lcyIsInJlbW92ZUNsYXNzZXMiLCJfdGhpcyRnZXRDbGFzc05hbWVzMiIsImFjdGl2ZUNsYXNzTmFtZSIsInJlZmxvd0FuZEFkZENsYXNzIiwiX3RoaXMkZ2V0Q2xhc3NOYW1lczMiLCJkb25lQ2xhc3NOYW1lIiwiX3RoaXMkZ2V0Q2xhc3NOYW1lczQiLCJfdGhpcyRnZXRDbGFzc05hbWVzNSIsIl90aGlzJGdldENsYXNzTmFtZXM2IiwiX3RoaXMkZ2V0Q2xhc3NOYW1lczciLCJfaGFzQ2xhc3MiLCJzZXRBdHRyaWJ1dGUiLCJiYXNlVmFsIiwib3JpZ0NsYXNzIiwiY2xhc3NUb1JlbW92ZSIsImNvdW50IiwiX2FyZ3MiLCJfbGVuMiIsIl9rZXkyIiwiaGFuZGxlTGlmZWN5Y2xlIiwiaGFuZGxlRW50ZXJpbmciLCJfbGVuMyIsIl9rZXkzIiwiaGFuZGxlRW50ZXJlZCIsIl9sZW40IiwiX2tleTQiLCJoYW5kbGVFeGl0IiwiX2xlbjUiLCJfa2V5NSIsImhhbmRsZUV4aXRpbmciLCJfbGVuNiIsIl9rZXk2IiwiX2xlbjciLCJfa2V5NyIsImlkeCIsIm9yaWdpbmFsQXJncyIsIl9jaGlsZCRwcm9wcyIsImluUHJvcCIsIl9SZWFjdCRDaGlsZHJlbiR0b0FyciIsIm1lcmdlQ2hpbGRNYXBwaW5ncyIsIm1hcEZuIiwibWFwcGVyIiwiZ2V0VmFsdWVGb3JLZXkiLCJuZXh0S2V5c1BlbmRpbmciLCJwZW5kaW5nS2V5cyIsImNoaWxkTWFwcGluZyIsInBlbmRpbmdOZXh0S2V5IiwiZ2V0UHJvcCIsInByb3AiLCJuZXh0Q2hpbGRNYXBwaW5nIiwiaGFzUHJldiIsImhhc05leHQiLCJwcmV2Q2hpbGQiLCJpc0xlYXZpbmciLCJBbmltYXRlQ2hpbGQiLCJlbmRMaXN0ZW5lcnMiLCJ0cmFuc2l0aW9uZW5kIiwiYW5pbWF0aW9uZW5kIiwibGlzdGVuZXIiLCJnZW5lcmF0ZUVuZExpc3RlbmVyIiwiZW5kTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJ0cmFuc2l0aW9uRW5kTGlzdGVuZXIiLCJhbmltYXRpb25FbmRMaXN0ZW5lciIsInRyYW5zaXRpb25EZWxheSIsInRyYW5zaXRpb25EdXJhdGlvbiIsInJlbW92ZUVuZHRMaXN0ZW5lciIsInRyYW5zaXRpb25PZmYiLCJhbmltYXRpb25PZmYiLCJyZW1vdmVDbGFzc05hbWVzIiwiaXNBcHBlYXJpbmciLCJob29rIiwib25BcHBlYXJpbmciLCJvbkFwcGVhcmVkIiwibGVhdmluZyIsImNhY2hlQ3VycmVudFN0eWxlIiwiY2FjaGVDb21wdXRlZFN0eWxlIiwic2V0Q3VycmVudFN0eWxlVG9aZXJvIiwic2V0Q3VycmVudFN0eWxlVG9Db21wdXRlZFN0eWxlIiwicmVzdG9yZUN1cnJlbnRTdHlsZSIsInN0eWxlQm9yZGVyVG9wV2lkdGgiLCJib3JkZXJUb3BXaWR0aCIsInN0eWxlUGFkZGluZ1RvcCIsInBhZGRpbmdUb3AiLCJzdHlsZUhlaWdodCIsInN0eWxlUGFkZGluZ0JvdHRvbSIsInBhZGRpbmdCb3R0b20iLCJzdHlsZUJvcmRlckJvdHRvbVdpZHRoIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJuZXdBbmltYXRpb24iLCJjaGVja2JveERpc2FibGVkIiwiQ2hlY2tib3hHcm91cCIsImN1cnJlbnRWYWx1ZSIsInZhbFRlbXAiLCJpdGVtRGlyZWN0aW9uIiwib3B0aW9uIiwiaXNCdXR0b25TaGFwZSIsIm5ld0NoaWxkQ2xhc3NOYW1lIiwibWVudSIsIm1lbnVJbnN0YW5jZSIsIkNvbnRleHRNZW51IiwiZ2V0T3ZlcmxheSIsImhhbmRsZU92ZXJsYXlDbG9zZSIsImNsaWNrZWRQb3B1cE1lbnUiLCJvdmVybGF5UHJvcHMiLCJoYW5kbGVPdmVybGF5T3BlbiIsIm5ld092ZXJsYXlQcm9wcyIsIm1lbnVQcm9wcyIsImRlc3Ryb3kiLCJkaXYiLCJjbG9zZUNoYWluIiwibmV3Q29udGV4dCIsIm1hcEljb25TaXplIiwibGFyZ2UiLCJtZWRpdW0iLCJzbWFsbCIsIm9uTW91c2VVcCIsImJ1dHRvbiIsImJsdXIiLCJidXR0b25SZWZIYW5kbGVyIiwiaHRtbFR5cGUiLCJpY29uU2l6ZSIsImdob3N0VHlwZSIsImJ0bkNscyIsImNsb25lZENoaWxkcmVuIiwiaWNvbkNscyIsInRhZ0F0dHJzIiwiaHJlZiIsImdyb3VwQ2xzIiwiY2xvbmVDaGlsZHJlbiIsImxhc3RQYWdlWCIsInBhZ2VYIiwib25Nb3VzZU1vdmUiLCJ1blNlbGVjdCIsImNoYW5nZWRQYWdlWCIsImRlc3RvcnkiLCJ1c2VyU2VsZWN0IiwiY3Vyc29yIiwicmVtb3ZlQXR0cmlidXRlIiwiVCIsIkJhc2VDb21wb25lbnQiLCJUcmVlVGFibGUiLCJvblRyZWVOb2RlQ2xpY2siLCJkcyIsImdldENoaWxkcmVuS2V5QnlJZCIsImlkcyIsIm9wZW5UcmVlUm93S2V5cyIsInRyZWVTdGF0dXMiLCJnZXRUcmVlTm9kZVN0YXR1cyIsIm5vcm1hbGl6ZURhdGFTb3VyY2UiLCJfX2xldmVsIiwib3BlbktleSIsIlRyZWVSb3ciLCJUcmVlQ2VsbCIsImhpZGRlbiIsIm9wZW5lZCIsImV4cGFuZGVkS2V5ZG93biIsInRyZWVBcnJvd05vZGVJbmRleCIsImZpcnN0Q2VsbFN0eWxlIiwidHJlZUFycm93Tm9kZSIsInRyZWVBcnJvd1R5cGUiLCJwYWRkaW5nTGVmdCIsImhhc0V4cGFuZGVkIiwiRml4ZWRUYWJsZSIsImNoYXJBdCIsInN1YnN0ciIsImlubmVySGVhZGVyTm9kZSIsImhlYWRlck5vZGUiLCJzY3JvbGxUbyIsImJvZHlOb2RlIiwiYWRqdXN0Rml4ZWRIZWFkZXJTaXplIiwidW5pcXVlIiwiYXJyIiwidGVtcCIsIlNlbGVjdGlvblRhYmxlIiwicmVuZGVyU2VsZWN0aW9uSGVhZGVyIiwic2VsZWN0QWxsUm93IiwiZmxhdERhdGFTb3VyY2UiLCJnZXRQcm9wcyIsInJlbmRlclNlbGVjdGlvbkJvZHkiLCJzZWxlY3RPbmVSb3ciLCJyZWNvcmRzIiwib25TZWxlY3RBbGwiLCJ0cmlnZ2VyU2VsZWN0aW9uIiwibGlzdEhlYWRlciIsIkV4cGFuZGVkVGFibGUiLCJvbkV4cGFuZGVkQ2xpY2siLCJyZW5kZXJFeHBhbmRlZENlbGwiLCJzd2l0Y2hOb2RlIiwidG9BcnJheUNoaWxkcmVuIiwiaXRlbUNvcHkiLCJWaXJ0dWFsVGFibGUiLCJzY3JvbGxUb1JvdyIsImxhc3RTY3JvbGxUb3AiLCJzdGFydCIsImNvbXB1dGVTY3JvbGxUb1JvdyIsImdldEJvZHlOb2RlIiwiaW5zdGFuY2UiLCJvblZpcnR1YWxTY3JvbGwiLCJib2R5SGVpZ2h0IiwiY29tcHV0ZUJvZHlIZWlnaHQiLCJpbm5lclRvcCIsImNvbXB1dGVJbm5lclRvcCIsImhhc1ZpcnR1YWxEYXRhIiwiYWRqdXN0U2Nyb2xsVG9wIiwiYWRqdXN0U2l6ZSIsInJlQ29tcHV0ZVNpemUiLCJnZXRSb3dOb2RlIiwicm93Q2xpZW50SGVpZ2h0IiwiZ2V0VmlzaWJsZVJhbmdlIiwiRXhwZWN0U3RhcnQiLCJ2aXNpYmxlQ291bnQiLCJtaW4iLCJ2aXJ0dWFsU2Nyb2xsTm9kZSIsInRhYmxlSW5jIiwidGFibGVOb2RlIiwiaGVhZGVyQ2xpZW50V2lkdGgiLCJsZWZ0Tm9kZSIsImJvZHlMZWZ0Tm9kZSIsInJpZ2h0Tm9kZSIsImJvZHlSaWdodE5vZGUiLCJoYXNTY3JvbGxiYXIiLCJWaXJ0dWFsQm9keSIsInRhYmxlUmVmIiwidmlydHVhbFNjcm9sbFJlZiIsInZpcnR1YWxTY3JvbGwiLCJvbkxvY2tCb2R5U2Nyb2xsIiwiZ2V0TG9ja05vZGUiLCJMb2NrVGFibGUiLCJpc0xvY2siLCJsZWZ0Um93IiwicmlnaHRSb3ciLCJvbkxvY2tCb2R5V2hlZWwiLCJkZWx0YVkiLCJsb2NrTGVmdEJvZHkiLCJzY3JvbGxOb2RlIiwibG9ja1JpZ2h0Qm9keSIsIm5ld1Njcm9sbFRvcCIsImxvY2tSaWdodFRhYmxlIiwibG9ja0xlZnRUYWJsZSIsInNoYWRvd0NsYXNzTmFtZSIsInNjcm9sbFdpZHRoIiwibG9ja0xlZnRDaGlsZHJlbiIsImxvY2tSaWdodENoaWxkcmVuIiwic2Nyb2xsIiwiX2lzTG9jayIsInNwbGl0Q2hpbGRyZW4iLCJzcGxpdEZyb21Ob3JtYWxpemVDaGlsZHJlbiIsIm1lcmdlRnJvbVNwbGl0TG9ja0NoaWxkcmVuIiwib3JpZ2luQ2hpbGRyZW4iLCJkZWVwQ29weSIsImxvY2tDaGlsZHJlbiIsImNvbmRpdGlvbiIsInNjcm9sbFRvQ29sIiwiY29sQ2VsbE5vZGUiLCJnZXRDZWxsTm9kZSIsInJvd0NlbGxOb2RlIiwiYm9keU5vZGVPZmZzZXQiLCJjZWxsTm9kZW9mZnNldCIsImlzT3JpZ2luTG9jayIsImFkanVzdElmVGFibGVOb3ROZWVkTG9jayIsImFkanVzdEhlYWRlclNpemUiLCJhZGp1c3RCb2R5U2l6ZSIsImFkanVzdENlbGxTaXplIiwiY29uZmlnV2lkdGhzIiwibG9ja0xlZnRMZW4iLCJsb2NrUmlnaHRMZW4iLCJfbm90TmVlZEFkanVzdExvY2tMZWZ0IiwiX25vdE5lZWRBZGp1c3RMb2NrUmlnaHQiLCJsb2NrUmlnaHRCb2R5V3JhcHBlciIsImhhc0hvelNjcm9sbCIsImhhc1ZlclNjcm9sbCIsImxvY2tCb2R5SGVpZ2h0IiwibGFzdEluZGV4IiwiaGVhZGVyUmlnaHRSb3ciLCJnZXRIZWFkZXJDZWxsTm9kZSIsImhlYWRlckxlZnRSb3ciLCJoZWFkZXJSaWdodExvY2tSb3ciLCJoZWFkZXJMZWZ0TG9ja1JvdyIsIm1heFJpZ2h0Um93SGVpZ2h0IiwidGFibGVSaWdodEluYyIsInVwZGF0ZVBvc2l0aW9uIiwibWF4TGVmdFJvd0hlaWdodCIsInRhYmxlTGVmdEluYyIsImxvY2tMZWZ0Um93IiwibG9ja1JpZ2h0Um93IiwiZ2V0Rmlyc3ROb3JtYWxDZWxsTm9kZSIsImxvY2tMZWZ0SGVpZ2h0IiwibG9ja1JpZ2h0SGVpZ2h0Iiwibm9ybWFsaXplZENoaWxkcmVuIiwiTG9ja0JvZHkiLCJMb2NrSGVhZGVyIiwiTG9ja1dyYXBwZXIiLCJjb3B5IiwibmV3SXRlbSIsIm9uQm9keVdoZWVsIiwiTGlzdFRhYmxlIiwibGlzdEZvb3RlciIsImlzTGlzdCIsIkxpc3RSb3ciLCJMaXN0Qm9keSIsIkdyb3VwTGlzdFJvdyIsInJlbmRlckNoaWxkcmVuIiwiaXNDaGlsZHJlblNlbGVjdGlvbiIsImlzU2VsZWN0aW9uIiwiY2VsbHMiLCJzaGlmdCIsImNhbWVUeXBlIiwibGlzdE5vZGUiLCJTdGlja3lUYWJsZSIsIlN0aWNreUhlYWRlciIsIlN0aWNrSGVhZGVyIiwibmV3QWZmaXhQcm9wcyIsIkFmZml4IiwiX3VwZGF0ZU5vZGVQb3NpdGlvbiIsInVzZUFic29sdXRlIiwiYWZmaXhDb250YWluZXIiLCJjb250YWluZXJTY3JvbGxUb3AiLCJhZmZpeE9mZnNldCIsIl9nZXRPZmZzZXQiLCJhZmZpeE5vZGUiLCJjb250YWluZXJIZWlnaHQiLCJhZmZpeEhlaWdodCIsImNvbnRhaW5lclJlY3QiLCJhZmZpeENoaWxkSGVpZ2h0IiwiYWZmaXhDaGlsZE5vZGUiLCJhZmZpeE1vZGUiLCJhZmZpeFN0eWxlIiwiY29udGFpbmVyU3R5bGUiLCJfc2V0QWZmaXhTdHlsZSIsIl9zZXRDb250YWluZXJTdHlsZSIsIl9hZmZpeE5vZGVSZWZIYW5kbGVyIiwiX2FmZml4Q2hpbGROb2RlUmVmSGFuZGxlciIsIl9nZXRBZmZpeE1vZGUiLCJfc2V0RXZlbnRIYW5kbGVyRm9yQ29udGFpbmVyIiwiX3JlbW92ZUV2ZW50SGFuZGxlckZvckNvbnRhaW5lciIsImdldENvbnRhaW5lciIsIm9mZnNldEJvdHRvbSIsImFmZml4ZWQiLCJvbkFmZml4IiwiYWZmaXhSZWN0IiwiY29udGFpbmVyU2Nyb2xsTGVmdCIsImNvbWJpbmVkU3R5bGUiLCJnZXRTY3JvbGwiLCJnZXRSZWN0IiwiZ2V0Tm9kZUhlaWdodCIsImlzVmVydGljYWwiLCJ3aW5kb3dQcm9wIiwiZWxlbWVudFByb3AiLCJpbm5lckhlaWdodCIsImxvY2FscyIsImhvdCIsImFjY2VwdCIsIm5ld0NvbnRlbnQiLCJkaXNwb3NlIiwiY3NzIiwiYmFzZVVybCIsInByb3RvY29sIiwiaG9zdCIsImN1cnJlbnREaXIiLCJwYXRobmFtZSIsImZpeGVkQ3NzIiwiZnVsbE1hdGNoIiwib3JpZ1VybCIsInVucXVvdGVkT3JpZ1VybCIsIm8iLCJuZXdVcmwiLCJBcHAiLCJ0b2dnbGVaZWJyYSIsInRvZ2dsZUJvcmRlciIsIm1ha2VCZWF1dHkiLCJtYWtlQWxpZ24iLCJSZWFjdERPTSIsImNvbXBvbmVudERlc2MiLCJjb21wb25lbnRCb2R5IiwicmVsb2FkaW5nIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUEsOEI7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7QUFPQSxJQUFJQSxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsTUFBSUMscUJBQXNCLE9BQU9DLE1BQVAsS0FBa0IsVUFBbEIsSUFDeEJBLE9BQU9DLEdBRGlCLElBRXhCRCxPQUFPQyxHQUFQLENBQVcsZUFBWCxDQUZ1QixJQUd2QixNQUhGOztBQUtBLE1BQUlDLGlCQUFpQixTQUFqQkEsY0FBaUIsQ0FBU0MsTUFBVCxFQUFpQjtBQUNwQyxXQUFPLFFBQU9BLE1BQVAseUNBQU9BLE1BQVAsT0FBa0IsUUFBbEIsSUFDTEEsV0FBVyxJQUROLElBRUxBLE9BQU9DLFFBQVAsS0FBb0JMLGtCQUZ0QjtBQUdELEdBSkQ7O0FBTUE7QUFDQTtBQUNBLE1BQUlNLHNCQUFzQixJQUExQjtBQUNBQyxTQUFPQyxPQUFQLEdBQWlCQyxtQkFBT0EsQ0FBQyxFQUFSLEVBQXFDTixjQUFyQyxFQUFxREcsbUJBQXJELENBQWpCO0FBQ0QsQ0FoQkQsTUFnQk87QUFDTDtBQUNBO0FBQ0FDLFNBQU9DLE9BQVAsR0FBaUJDLG1CQUFPQSxDQUFDLEVBQVIsR0FBakI7QUFDRCxDOzs7Ozs7Ozs7Ozs7O0FDM0JEOztJQUFZQyxJOztBQUNaOztJQUFZQyxJOztBQUNaOztJQUFZQyxPOztBQUNaOztJQUFZQyxLOztBQUNaOztJQUFZQyxJOztBQUNaOztJQUFZQyxPOztBQUNaOztJQUFZQyxPOztBQUNaOztJQUFZQyxROztBQUNaOztJQUFZQyxNOztBQUNaOzs7O0FBQ0E7Ozs7Ozs7O0FBRU8sSUFBTUMsb0JBQU1ULElBQVo7QUFDQSxJQUFNWixvQkFBTWEsSUFBWjtBQUNBLElBQU1TLDBCQUFTUixPQUFmO0FBQ0EsSUFBTVMsc0JBQU9SLEtBQWI7QUFDQSxJQUFNUyxvQkFBTVIsSUFBWjtBQUNBLElBQU1TLG9CQUFNUixPQUFaO0FBQ0EsSUFBTVMsb0JBQU1SLE9BQVo7QUFDQSxJQUFNUyw0QkFBVVIsUUFBaEI7QUFDQSxJQUFNUyx3QkFBUVIsTUFBZDtBQUNBLElBQU1TLHNCQUFPQyxjQUFiO0FBQ0EsSUFBTUMsNEJBQVVDLGlCQUFoQixDOzs7Ozs7Ozs7OztBQ3RCUDs7Ozs7QUFLQTs7QUFFQyxhQUFZO0FBQ1o7O0FBRUEsS0FBSUMsU0FBUyxHQUFHQyxjQUFoQjs7QUFFQSxVQUFTQyxVQUFULEdBQXVCO0FBQ3RCLE1BQUlDLFVBQVUsRUFBZDs7QUFFQSxPQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUMsVUFBVUMsTUFBOUIsRUFBc0NGLEdBQXRDLEVBQTJDO0FBQzFDLE9BQUlHLE1BQU1GLFVBQVVELENBQVYsQ0FBVjtBQUNBLE9BQUksQ0FBQ0csR0FBTCxFQUFVOztBQUVWLE9BQUlDLGlCQUFpQkQsR0FBakIseUNBQWlCQSxHQUFqQixDQUFKOztBQUVBLE9BQUlDLFlBQVksUUFBWixJQUF3QkEsWUFBWSxRQUF4QyxFQUFrRDtBQUNqREwsWUFBUU0sSUFBUixDQUFhRixHQUFiO0FBQ0EsSUFGRCxNQUVPLElBQUlHLE1BQU1DLE9BQU4sQ0FBY0osR0FBZCxLQUFzQkEsSUFBSUQsTUFBOUIsRUFBc0M7QUFDNUMsUUFBSU0sUUFBUVYsV0FBV1csS0FBWCxDQUFpQixJQUFqQixFQUF1Qk4sR0FBdkIsQ0FBWjtBQUNBLFFBQUlLLEtBQUosRUFBVztBQUNWVCxhQUFRTSxJQUFSLENBQWFHLEtBQWI7QUFDQTtBQUNELElBTE0sTUFLQSxJQUFJSixZQUFZLFFBQWhCLEVBQTBCO0FBQ2hDLFNBQUssSUFBSU0sR0FBVCxJQUFnQlAsR0FBaEIsRUFBcUI7QUFDcEIsU0FBSVAsT0FBT2UsSUFBUCxDQUFZUixHQUFaLEVBQWlCTyxHQUFqQixLQUF5QlAsSUFBSU8sR0FBSixDQUE3QixFQUF1QztBQUN0Q1gsY0FBUU0sSUFBUixDQUFhSyxHQUFiO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQsU0FBT1gsUUFBUWEsSUFBUixDQUFhLEdBQWIsQ0FBUDtBQUNBOztBQUVELEtBQUksT0FBT3hDLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNBLE9BQU9DLE9BQTVDLEVBQXFEO0FBQ3BEeUIsYUFBV2UsT0FBWCxHQUFxQmYsVUFBckI7QUFDQTFCLFNBQU9DLE9BQVAsR0FBaUJ5QixVQUFqQjtBQUNBLEVBSEQsTUFHTyxJQUFJLGVBQWtCLFVBQWxCLElBQWdDLFFBQU9nQix1QkFBUCxNQUFzQixRQUF0RCxJQUFrRUEsdUJBQXRFLEVBQWtGO0FBQ3hGO0FBQ0FBLG1DQUFxQixFQUFyQixtQ0FBeUIsWUFBWTtBQUNwQyxVQUFPaEIsVUFBUDtBQUNBLEdBRkQ7QUFBQTtBQUdBLEVBTE0sTUFLQTtBQUNOaUIsU0FBT2pCLFVBQVAsR0FBb0JBLFVBQXBCO0FBQ0E7QUFDRCxDQTVDQSxHQUFELEM7Ozs7OztBQ1BBLGlDOzs7Ozs7Ozs7Ozs7Ozs7QUNBQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBVUE7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNa0Isb0JBQW9CLElBQUlDLGVBQUosRUFBMUI7O0FBRUE7Ozs7SUFJTUMsYzs7O0FBa0RGOzs7Ozs7QUErQkEsOEJBQXFCO0FBQUE7O0FBQUEsMENBQU5DLElBQU07QUFBTkEsZ0JBQU07QUFBQTs7QUFBQSxxREFDakIsZ0RBQVNBLElBQVQsRUFEaUI7O0FBRWpCSCwwQkFBa0JJLEdBQWxCLFFBRUksU0FBYyxFQUFkLEVBQWtCSixrQkFBa0JLLEdBQWxCLFFBQTRCLEVBQTVCLENBQWxCLEVBQW1ELE1BQUtDLGVBQUwsRUFBbkQsQ0FGSjtBQUZpQjtBQU1wQjs7QUEvQ0Q7Ozs7Ozs7OzZCQWlEQUEsZSw4QkFBa0I7QUFBQSxxQkFDaUMsS0FBS0MsS0FEdEM7QUFBQSxZQUNOQyxNQURNLFVBQ05BLE1BRE07QUFBQSxZQUNFQyxNQURGLFVBQ0VBLE1BREY7QUFBQSxZQUNVQyxJQURWLFVBQ1VBLElBRFY7QUFBQSxZQUNnQkMsT0FEaEIsVUFDZ0JBLE9BRGhCO0FBQUEsWUFDeUJDLEdBRHpCLFVBQ3lCQSxHQUR6Qjs7O0FBR2QsZUFBTztBQUNIQyx3QkFBWUwsTUFEVDtBQUVITSx3QkFBWUwsTUFGVDtBQUdITSxzQkFBVUwsSUFIUDtBQUlITSxxQkFBU0osR0FKTjtBQUtISyx5QkFBYU47QUFMVixTQUFQO0FBT0gsSzs7NkJBRURPLGtCLGlDQUFxQjtBQUNqQixhQUFLQyxlQUFMLENBQXFCLEtBQUtaLEtBQUwsQ0FBV0UsTUFBaEM7QUFDSCxLOzs2QkFFRFcseUIsc0NBQTBCQyxTLEVBQVc7QUFDakMsWUFBSSxLQUFLZCxLQUFMLENBQVdFLE1BQVgsS0FBc0JZLFVBQVVaLE1BQXBDLEVBQTRDO0FBQ3hDLGlCQUFLVSxlQUFMLENBQXFCRSxVQUFVWixNQUEvQjtBQUNIO0FBQ0osSzs7NkJBRURhLGtCLGlDQUFxQjtBQUNqQnRCLDBCQUFrQkksR0FBbEIsQ0FDSSxJQURKLEVBRUksU0FBYyxFQUFkLEVBQWtCSixrQkFBa0JLLEdBQWxCLENBQXNCLElBQXRCLEVBQTRCLEVBQTVCLENBQWxCLEVBQW1ELEtBQUtDLGVBQUwsRUFBbkQsQ0FGSjtBQUlILEs7OzZCQUVEaUIsb0IsbUNBQXVCO0FBQ25CdkIsMEJBQWtCd0IsTUFBbEIsQ0FBeUIsSUFBekI7QUFDSCxLOzs2QkFFREwsZSw0QkFBZ0JWLE0sRUFBUTtBQUNwQixZQUFJZ0IsZUFBSjtBQUNBLFlBQUk7QUFDQUEscUJBQVNuRSxtQkFBT0EsQ0FBQyxFQUFSLENBQVQ7QUFDSCxTQUZELENBRUUsT0FBT29FLENBQVAsRUFBVTtBQUNSO0FBQ0g7O0FBRUQsWUFBSUQsVUFBVWhCLE1BQWQsRUFBc0I7QUFDbEJnQixtQkFBT2hCLE1BQVAsQ0FBY0EsT0FBT2tCLFlBQXJCO0FBQ0g7QUFDSixLOzs2QkFFREMsTSxxQkFBUztBQUNMLGVBQU9DLGdCQUFTQyxJQUFULENBQWMsS0FBS3ZCLEtBQUwsQ0FBV3dCLFFBQXpCLENBQVA7QUFDSCxLOzs7RUF6SXdCQyxnQixVQUNsQkMsUyxHQUFZO0FBQ2Y7OztBQUdBekIsWUFBUTBCLG9CQUFVQyxNQUpIO0FBS2Y7OztBQUdBMUIsWUFBUXlCLG9CQUFVakYsTUFSSDtBQVNmOzs7QUFHQXlELFVBQU13QixvQkFBVUUsSUFaRDtBQWFmOzs7QUFHQXpCLGFBQVN1QixvQkFBVUUsSUFoQko7QUFpQmY7OztBQUdBeEIsU0FBS3NCLG9CQUFVRSxJQXBCQTtBQXFCZjs7O0FBR0FMLGNBQVVHLG9CQUFVRztBQXhCTCxDLFNBMkJaQyxZLEdBQWU7QUFDbEIzQixhQUFTO0FBRFMsQyxTQUlmNEIsaUIsR0FBb0I7QUFDdkIxQixnQkFBWXFCLG9CQUFVQyxNQURDO0FBRXZCckIsZ0JBQVlvQixvQkFBVWpGLE1BRkM7QUFHdkI4RCxjQUFVbUIsb0JBQVVFLElBSEc7QUFJdkJwQixhQUFTa0Isb0JBQVVFLElBSkk7QUFLdkJuQixpQkFBYWlCLG9CQUFVRTtBQUxBLEMsU0FjcEJJLE0sR0FBUyxVQUFDUixTQUFELEVBQVlTLE9BQVosRUFBd0I7QUFDcEMsV0FBTyxvQkFBT1QsU0FBUCxFQUFrQlMsT0FBbEIsQ0FBUDtBQUNILEMsU0FRTUMsZSxHQUFrQixVQUFDbkMsS0FBRCxFQUFRb0MsV0FBUixFQUF3QjtBQUM3QyxXQUFPLCtCQUFnQnBDLEtBQWhCLEVBQXVCUCxrQkFBa0I0QyxJQUFsQixNQUE0QixFQUFuRCxFQUF1REQsV0FBdkQsQ0FBUDtBQUNILEMsU0FFTUUsVyxHQUFjQSxtQixTQUNkQyxXLEdBQWNBLG1CLFNBQ2RDLFMsR0FBWUEsaUIsU0FDWkMsWSxHQUFlQSxvQixTQUNmQyxXLEdBQWNBLG1CLFNBQ2RDLFMsR0FBWUEsaUIsU0FDWkMsWSxHQUFlQSxvQixTQUNmQyxRLEdBQVdBLGtCLFNBRVhDLFUsR0FBYSxZQUFNO0FBQUEsZUFDNkNyRCxrQkFBa0I0QyxJQUFsQixNQUE0QixFQUR6RTtBQUFBLFFBQ2QvQixVQURjLFFBQ2RBLFVBRGM7QUFBQSxRQUNGQyxVQURFLFFBQ0ZBLFVBREU7QUFBQSxRQUNVQyxRQURWLFFBQ1VBLFFBRFY7QUFBQSxRQUNvQkMsT0FEcEIsUUFDb0JBLE9BRHBCO0FBQUEsUUFDNkJDLFdBRDdCLFFBQzZCQSxXQUQ3Qjs7QUFHdEIsV0FBTztBQUNIVCxnQkFBUUssVUFETDtBQUVISixnQkFBUUssVUFGTDtBQUdISixjQUFNSyxRQUhIO0FBSUhILGFBQUtJLE9BSkY7QUFLSEwsaUJBQVNNO0FBTE4sS0FBUDtBQU9ILEM7QUEvRUNmLGM7a0JBNElTQSxjOzs7Ozs7Ozs7O0FDbEtmOzs7O0FBSUE7QUFDQTlDLE9BQU9DLE9BQVAsR0FBaUIsVUFBU2lHLFlBQVQsRUFBdUI7QUFDdkMsS0FBSUMsT0FBTyxFQUFYOztBQUVBO0FBQ0FBLE1BQUtDLFFBQUwsR0FBZ0IsU0FBU0EsUUFBVCxHQUFvQjtBQUNuQyxTQUFPLEtBQUtDLEdBQUwsQ0FBUyxVQUFVQyxJQUFWLEVBQWdCO0FBQy9CLE9BQUlDLFVBQVVDLHVCQUF1QkYsSUFBdkIsRUFBNkJKLFlBQTdCLENBQWQ7QUFDQSxPQUFHSSxLQUFLLENBQUwsQ0FBSCxFQUFZO0FBQ1gsV0FBTyxZQUFZQSxLQUFLLENBQUwsQ0FBWixHQUFzQixHQUF0QixHQUE0QkMsT0FBNUIsR0FBc0MsR0FBN0M7QUFDQSxJQUZELE1BRU87QUFDTixXQUFPQSxPQUFQO0FBQ0E7QUFDRCxHQVBNLEVBT0ovRCxJQVBJLENBT0MsRUFQRCxDQUFQO0FBUUEsRUFURDs7QUFXQTtBQUNBMkQsTUFBS3ZFLENBQUwsR0FBUyxVQUFTNkUsT0FBVCxFQUFrQkMsVUFBbEIsRUFBOEI7QUFDdEMsTUFBRyxPQUFPRCxPQUFQLEtBQW1CLFFBQXRCLEVBQ0NBLFVBQVUsQ0FBQyxDQUFDLElBQUQsRUFBT0EsT0FBUCxFQUFnQixFQUFoQixDQUFELENBQVY7QUFDRCxNQUFJRSx5QkFBeUIsRUFBN0I7QUFDQSxPQUFJLElBQUkvRSxJQUFJLENBQVosRUFBZUEsSUFBSSxLQUFLRSxNQUF4QixFQUFnQ0YsR0FBaEMsRUFBcUM7QUFDcEMsT0FBSWdGLEtBQUssS0FBS2hGLENBQUwsRUFBUSxDQUFSLENBQVQ7QUFDQSxPQUFHLE9BQU9nRixFQUFQLEtBQWMsUUFBakIsRUFDQ0QsdUJBQXVCQyxFQUF2QixJQUE2QixJQUE3QjtBQUNEO0FBQ0QsT0FBSWhGLElBQUksQ0FBUixFQUFXQSxJQUFJNkUsUUFBUTNFLE1BQXZCLEVBQStCRixHQUEvQixFQUFvQztBQUNuQyxPQUFJMEUsT0FBT0csUUFBUTdFLENBQVIsQ0FBWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBRyxPQUFPMEUsS0FBSyxDQUFMLENBQVAsS0FBbUIsUUFBbkIsSUFBK0IsQ0FBQ0ssdUJBQXVCTCxLQUFLLENBQUwsQ0FBdkIsQ0FBbkMsRUFBb0U7QUFDbkUsUUFBR0ksY0FBYyxDQUFDSixLQUFLLENBQUwsQ0FBbEIsRUFBMkI7QUFDMUJBLFVBQUssQ0FBTCxJQUFVSSxVQUFWO0FBQ0EsS0FGRCxNQUVPLElBQUdBLFVBQUgsRUFBZTtBQUNyQkosVUFBSyxDQUFMLElBQVUsTUFBTUEsS0FBSyxDQUFMLENBQU4sR0FBZ0IsU0FBaEIsR0FBNEJJLFVBQTVCLEdBQXlDLEdBQW5EO0FBQ0E7QUFDRFAsU0FBS2xFLElBQUwsQ0FBVXFFLElBQVY7QUFDQTtBQUNEO0FBQ0QsRUF4QkQ7QUF5QkEsUUFBT0gsSUFBUDtBQUNBLENBMUNEOztBQTRDQSxTQUFTSyxzQkFBVCxDQUFnQ0YsSUFBaEMsRUFBc0NKLFlBQXRDLEVBQW9EO0FBQ25ELEtBQUlLLFVBQVVELEtBQUssQ0FBTCxLQUFXLEVBQXpCO0FBQ0EsS0FBSU8sYUFBYVAsS0FBSyxDQUFMLENBQWpCO0FBQ0EsS0FBSSxDQUFDTyxVQUFMLEVBQWlCO0FBQ2hCLFNBQU9OLE9BQVA7QUFDQTs7QUFFRCxLQUFJTCxnQkFBZ0IsT0FBT1ksSUFBUCxLQUFnQixVQUFwQyxFQUFnRDtBQUMvQyxNQUFJQyxnQkFBZ0JDLFVBQVVILFVBQVYsQ0FBcEI7QUFDQSxNQUFJSSxhQUFhSixXQUFXSyxPQUFYLENBQW1CYixHQUFuQixDQUF1QixVQUFVYyxNQUFWLEVBQWtCO0FBQ3pELFVBQU8sbUJBQW1CTixXQUFXTyxVQUE5QixHQUEyQ0QsTUFBM0MsR0FBb0QsS0FBM0Q7QUFDQSxHQUZnQixDQUFqQjs7QUFJQSxTQUFPLENBQUNaLE9BQUQsRUFBVWMsTUFBVixDQUFpQkosVUFBakIsRUFBNkJJLE1BQTdCLENBQW9DLENBQUNOLGFBQUQsQ0FBcEMsRUFBcUR2RSxJQUFyRCxDQUEwRCxJQUExRCxDQUFQO0FBQ0E7O0FBRUQsUUFBTyxDQUFDK0QsT0FBRCxFQUFVL0QsSUFBVixDQUFlLElBQWYsQ0FBUDtBQUNBOztBQUVEO0FBQ0EsU0FBU3dFLFNBQVQsQ0FBbUJNLFNBQW5CLEVBQThCO0FBQzdCO0FBQ0EsS0FBSUMsU0FBU1QsS0FBS1UsU0FBU0MsbUJBQW1CQyxLQUFLQyxTQUFMLENBQWVMLFNBQWYsQ0FBbkIsQ0FBVCxDQUFMLENBQWI7QUFDQSxLQUFJTSxPQUFPLGlFQUFpRUwsTUFBNUU7O0FBRUEsUUFBTyxTQUFTSyxJQUFULEdBQWdCLEtBQXZCO0FBQ0EsQzs7Ozs7O0FDM0VEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLEdBQVE7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQSxtQkFBbUIsMkJBQTJCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBOztBQUVBLFFBQVEsdUJBQXVCO0FBQy9CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQsa0RBQWtELHNCQUFzQjtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUEsNkJBQTZCLG1CQUFtQjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUNoV0EsSUFBTUMsWUFBWSxDQUFDLGNBQUQsRUFBaUIsV0FBakIsRUFBOEIsY0FBOUIsRUFBOEMsbUJBQTlDLEVBQW1FLGFBQW5FLENBQWxCOztBQUVPLElBQU1DLDRCQUFVLFNBQVZBLE9BQVUsQ0FBQ0MsTUFBRCxFQUFTbkQsU0FBVCxFQUF1QjtBQUMxQ29ELFdBQU9DLElBQVAsQ0FBWXJELFNBQVosRUFBdUJzRCxPQUF2QixDQUErQixvQkFBWTtBQUN2QyxZQUFJTCxVQUFVTSxPQUFWLENBQWtCQyxRQUFsQixNQUFnQyxDQUFDLENBQXJDLEVBQXdDO0FBQ3BDTCxtQkFBT0ssUUFBUCxJQUFtQnhELFVBQVV3RCxRQUFWLENBQW5CO0FBQ0g7QUFDSixLQUpEO0FBS0gsQ0FOTTs7QUFRQSxJQUFNQyw0Q0FBa0IsU0FBbEJBLGVBQWtCLENBQUN4SSxNQUFELEVBQVN5SSxJQUFULEVBQWtCO0FBQzdDLFFBQUksQ0FBQ3pJLE1BQUQsSUFBVyxDQUFDeUksSUFBaEIsRUFBc0I7QUFDbEIsZUFBTyxLQUFQO0FBQ0g7QUFDREEsV0FBT0EsS0FBS2xDLFFBQUwsRUFBUDtBQUNBLFFBQU1tQyxRQUFRRCxLQUFLRSxLQUFMLENBQVcsR0FBWCxDQUFkO0FBQ0EsUUFBSUMsWUFBSjtBQUFBLFFBQVNuRyxZQUFUO0FBQ0EsUUFBSWlHLE1BQU16RyxNQUFWLEVBQWtCO0FBQ2RRLGNBQU1pRyxNQUFNLENBQU4sQ0FBTjtBQUNBO0FBQ0EsWUFBSWpHLElBQUk2RixPQUFKLENBQVksR0FBWixLQUFvQixDQUF4QixFQUEyQjtBQUN2QjdGLGtCQUFNQSxJQUFJb0csS0FBSixDQUFVLGNBQVYsQ0FBTjtBQUNBLGdCQUFJcEcsR0FBSixFQUFTO0FBQ0xtRyxzQkFBTTVJLE9BQU95QyxJQUFJLENBQUosQ0FBUCxFQUFlQSxJQUFJLENBQUosQ0FBZixDQUFOO0FBQ0g7QUFDSixTQUxELE1BS087QUFDSG1HLGtCQUFNNUksT0FBTzBJLE1BQU0sQ0FBTixDQUFQLENBQU47QUFDSDtBQUNELFlBQUlFLEdBQUosRUFBUztBQUNMLGlCQUFLLElBQUlFLFdBQVcsQ0FBcEIsRUFBdUJBLFdBQVdKLE1BQU16RyxNQUF4QyxFQUFnRDZHLFVBQWhELEVBQTREO0FBQ3hERixzQkFBTUEsSUFBSUYsTUFBTUksUUFBTixDQUFKLENBQU47QUFDQSxvQkFBSSxPQUFPRixHQUFQLEtBQWUsV0FBbkIsRUFBZ0M7QUFDNUI7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQUNELFdBQU9BLEdBQVA7QUFDSCxDQTVCTSxDOzs7Ozs7Ozs7Ozs7Ozs7QUNWUDs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7SUFHTUcsSTs7Ozs7Ozs7O21CQXNCRnBFLE0scUJBQVM7QUFBQTs7QUFDTDtBQURLLHFCQUVvRCxLQUFLckIsS0FGekQ7QUFBQSxZQUVHQyxNQUZILFVBRUdBLE1BRkg7QUFBQSxZQUVXeUYsSUFGWCxVQUVXQSxJQUZYO0FBQUEsWUFFaUJDLElBRmpCLFVBRWlCQSxJQUZqQjtBQUFBLFlBRXVCQyxTQUZ2QixVQUV1QkEsU0FGdkI7QUFBQSxZQUVrQ3ZGLEdBRmxDLFVBRWtDQSxHQUZsQztBQUFBLFlBRTBDd0YsS0FGMUM7O0FBSUwsWUFBTXJILFVBQVUseUNBQ1J5QixNQURRLGFBQ08sSUFEUCxNQUVSQSxNQUZRLGFBRU15RixJQUZOLElBRWUsQ0FBQyxDQUFDQSxJQUZqQixXQUdSekYsTUFIUSxHQUdDMEYsSUFIRCxJQUdVLENBQUMsQ0FBQ0EsSUFIWixNQUlYQyxTQUpXLElBSUMsQ0FBQyxDQUFDQSxTQUpILE9BQWhCOztBQU9BLFlBQUl2RixPQUFPLENBQUMsWUFBRCxFQUFlLGFBQWYsRUFBOEIsbUJBQTlCLEVBQW1ELG9CQUFuRCxFQUF5RSxRQUF6RSxFQUFtRixTQUFuRixFQUE4RixZQUE5RixFQUE0RyxXQUE1RyxFQUF5SDJFLE9BQXpILENBQWlJVSxJQUFqSSxNQUEySSxDQUFDLENBQXZKLEVBQTBKO0FBQ3RKRyxrQkFBTUMsR0FBTixHQUFZLEtBQVo7QUFDSDs7QUFFRCxlQUFPLGdEQUFPRCxLQUFQLElBQWMsV0FBV3JILE9BQXpCLElBQVA7QUFDSCxLOzs7RUF0Q2NpRCxnQixVQUNSQyxTLEdBQVk7QUFDZnpCLFlBQVEwQixvQkFBVUMsTUFESDtBQUVmdkIsU0FBS3NCLG9CQUFVRSxJQUZBO0FBR2Y7OztBQUdBNkQsVUFBTS9ELG9CQUFVQyxNQU5EO0FBT2Y7OztBQUdBK0QsVUFBTWhFLG9CQUFVb0UsS0FBVixDQUFnQixDQUFDLEtBQUQsRUFBUSxJQUFSLEVBQWMsT0FBZCxFQUF1QixRQUF2QixFQUFpQyxPQUFqQyxFQUEwQyxJQUExQyxFQUFnRCxLQUFoRCxFQUF1RCxNQUF2RCxDQUFoQixDQVZTO0FBV2ZILGVBQVdqRSxvQkFBVUM7QUFYTixDLFNBY1pHLFksR0FBZTtBQUNsQjlCLFlBQVEsT0FEVTtBQUVsQjBGLFVBQU07QUFGWSxDLFNBS2ZLLFMsR0FBWSxNO0FBcEJqQlAsSTtrQkF5Q1M5Rix5QkFBZXNDLE1BQWYsQ0FBc0J3RCxJQUF0QixDOzs7Ozs7Ozs7OztBQ2pEZix5Qjs7Ozs7Ozs7O0FDQUEseUI7Ozs7Ozs7Ozs7Ozs7UUNVZ0JRLE0sR0FBQUEsTTtRQWNBQyxXLEdBQUFBLFc7UUFhQUMsUyxHQUFBQSxTO1FBVUFDLGEsR0FBQUEsYTtRQWtDQUMsWSxHQUFBQSxZO1FBMERBQyxJLEdBQUFBLEk7UUEyQ0FDLFUsR0FBQUEsVTtRQXNCQUMsYSxHQUFBQSxhO0FBNU1oQjs7Ozs7Ozs7OztBQVVPLFNBQVNQLE1BQVQsQ0FBaUJwSSxHQUFqQixFQUFzQjtBQUN6QixXQUFPZ0gsT0FBTzRCLFNBQVAsQ0FBaUJ4RCxRQUFqQixDQUEwQjdELElBQTFCLENBQStCdkIsR0FBL0IsRUFBb0M2SSxPQUFwQyxDQUE0QyxlQUE1QyxFQUE2RCxFQUE3RCxDQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7QUFVTyxTQUFTUixXQUFULENBQXNCckksR0FBdEIsRUFBMkI7QUFDOUIsUUFBTWMsU0FBUyxDQUFDLENBQUNkLEdBQUYsSUFBUyxZQUFZQSxHQUFyQixJQUE0QkEsSUFBSWMsTUFBL0M7QUFDQSxRQUFNK0csT0FBT08sT0FBT3BJLEdBQVAsQ0FBYjs7QUFFQSxXQUFPNkgsU0FBUyxPQUFULElBQW9CL0csV0FBVyxDQUEvQixJQUNGLE9BQU9BLE1BQVAsS0FBa0IsUUFBbEIsSUFBOEJBLFNBQVMsQ0FBdkMsSUFBNkNBLFNBQVMsQ0FBVixJQUFnQmQsR0FEakU7QUFFSDs7QUFFRDs7Ozs7QUFLTyxTQUFTc0ksU0FBVCxDQUFvQnRJLEdBQXBCLEVBQXlCO0FBQzVCLFdBQU8sQ0FBQyxDQUFDQSxHQUFGLEtBQVUsUUFBT0EsR0FBUCx5Q0FBT0EsR0FBUCxPQUFlLFFBQWYsSUFBMkIsT0FBT0EsR0FBUCxLQUFlLFVBQXBELEtBQW1FLE9BQU9BLElBQUk4SSxJQUFYLEtBQW9CLFVBQTlGO0FBQ0g7O0FBRUQ7Ozs7OztBQU1PLFNBQVNQLGFBQVQsQ0FBd0J2SSxHQUF4QixFQUE2QjtBQUNoQyxRQUFJb0ksT0FBT3BJLEdBQVAsTUFBZ0IsUUFBcEIsRUFBOEI7QUFDMUIsZUFBTyxLQUFQO0FBQ0g7O0FBRUQsUUFBTStJLE9BQU8vSSxJQUFJZ0osV0FBakI7O0FBRUEsUUFBSSxPQUFPRCxJQUFQLEtBQWdCLFVBQXBCLEVBQWdDO0FBQzVCLGVBQU8sS0FBUDtBQUNIOztBQUVELFFBQU1FLE9BQU9GLEtBQUtILFNBQWxCOztBQUVBLFFBQUlSLE9BQU9hLElBQVAsTUFBaUIsUUFBckIsRUFBK0I7QUFDM0IsZUFBTyxLQUFQO0FBQ0g7O0FBRUQsUUFBSSxDQUFDQSxLQUFLeEksY0FBTCxDQUFvQixlQUFwQixDQUFMLEVBQTJDO0FBQ3ZDLGVBQU8sS0FBUDtBQUNIOztBQUVELFdBQU8sSUFBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7O0FBVU8sU0FBUytILFlBQVQsQ0FBdUJVLElBQXZCLEVBQTZCQyxJQUE3QixFQUFtQ0MsT0FBbkMsRUFBNEM7QUFDL0MsUUFBSUYsU0FBU0MsSUFBYixFQUFtQjtBQUNmLGVBQU8sSUFBUDtBQUNIOztBQUVEO0FBQ0EsUUFBSSxDQUFDRCxJQUFELElBQVMsQ0FBQ0MsSUFBVixJQUFtQixRQUFPRCxJQUFQLHlDQUFPQSxJQUFQLGFBQXFCQyxJQUFyQix5Q0FBcUJBLElBQXJCLE9BQThCLGNBQXJELEVBQXNFO0FBQ2xFLGVBQU8sS0FBUDtBQUNIOztBQUVELFFBQU1FLE9BQU9yQyxPQUFPQyxJQUFQLENBQVlpQyxJQUFaLENBQWI7QUFDQSxRQUFNSSxPQUFPdEMsT0FBT0MsSUFBUCxDQUFZa0MsSUFBWixDQUFiO0FBQ0EsUUFBTUksTUFBTUYsS0FBS3ZJLE1BQWpCOztBQUVBO0FBQ0EsUUFBSXlJLFFBQVFELEtBQUt4SSxNQUFqQixFQUF5QjtBQUNyQixlQUFPLEtBQVA7QUFDSDs7QUFFRCxRQUFNMEksY0FBYyxPQUFPSixPQUFQLEtBQW1CLFVBQXZDOztBQUVBLFNBQUssSUFBSXhJLElBQUksQ0FBYixFQUFnQkEsSUFBSTJJLEdBQXBCLEVBQXlCM0ksR0FBekIsRUFBOEI7QUFDMUIsWUFBTVUsTUFBTStILEtBQUt6SSxDQUFMLENBQVo7O0FBRUEsWUFBSSxDQUFDb0csT0FBTzRCLFNBQVAsQ0FBaUJuSSxjQUFqQixDQUFnQ2MsSUFBaEMsQ0FBcUM0SCxJQUFyQyxFQUEyQzdILEdBQTNDLENBQUwsRUFBc0Q7QUFDbEQsbUJBQU8sS0FBUDtBQUNIOztBQUVELFlBQU1tSSxPQUFPUCxLQUFLNUgsR0FBTCxDQUFiO0FBQ0EsWUFBTW9JLE9BQU9QLEtBQUs3SCxHQUFMLENBQWI7O0FBRUEsWUFBTXFJLE1BQU1ILGNBQWNKLFFBQVFLLElBQVIsRUFBY0MsSUFBZCxFQUFvQnBJLEdBQXBCLENBQWQsR0FBeUMsS0FBSyxDQUExRDs7QUFFQSxZQUFJcUksUUFBUSxLQUFSLElBQWlCQSxRQUFRLEtBQUssQ0FBYixJQUFrQkYsU0FBU0MsSUFBaEQsRUFBc0Q7QUFDbEQsbUJBQU8sS0FBUDtBQUNIO0FBQ0o7O0FBRUQsV0FBTyxJQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJPLFNBQVNqQixJQUFULENBQWV6SSxHQUFmLEVBQW9CNEosUUFBcEIsRUFBOEJDLFNBQTlCLEVBQXlDO0FBQzVDLFFBQU1DLFdBQVdELGNBQWMsQ0FBQyxDQUFoQztBQUNBLFFBQU0vSSxTQUFTZCxJQUFJYyxNQUFuQjtBQUNBLFFBQUlpSixjQUFKO0FBQUEsUUFDSW5KLElBQUlrSixXQUFXaEosU0FBUyxDQUFwQixHQUF3QixDQURoQzs7QUFHQSxRQUFJdUgsWUFBWXJJLEdBQVosQ0FBSixFQUFzQjtBQUNsQixlQUFPWSxJQUFJRSxNQUFKLElBQWNGLEtBQUssQ0FBMUIsRUFBNkJrSixXQUFXbEosR0FBWCxHQUFpQkEsR0FBOUMsRUFBbUQ7QUFDL0NtSixvQkFBUUgsU0FBU3JJLElBQVQsQ0FBY3ZCLElBQUlZLENBQUosQ0FBZCxFQUFzQlosSUFBSVksQ0FBSixDQUF0QixFQUE4QkEsQ0FBOUIsQ0FBUjs7QUFFQSxnQkFBSW1KLFVBQVUsS0FBZCxFQUFxQjtBQUNqQjtBQUNIO0FBQ0o7QUFDSixLQVJELE1BUU87QUFDSCxhQUFLbkosQ0FBTCxJQUFVWixHQUFWLEVBQWU7QUFDWDtBQUNBLGdCQUFJQSxJQUFJUyxjQUFKLENBQW1CRyxDQUFuQixDQUFKLEVBQTJCO0FBQ3ZCbUosd0JBQVFILFNBQVNySSxJQUFULENBQWN2QixJQUFJWSxDQUFKLENBQWQsRUFBc0JaLElBQUlZLENBQUosQ0FBdEIsRUFBOEJBLENBQTlCLENBQVI7O0FBRUEsb0JBQUltSixVQUFVLEtBQWQsRUFBcUI7QUFDakI7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFFRCxXQUFPL0osR0FBUDtBQUNIOztBQUVEO0FBQ0EsSUFBTWdLLFdBQVcsU0FBWEEsUUFBVyxDQUFDMUksR0FBRCxFQUFNdEIsR0FBTixFQUFXbUIsT0FBWDtBQUFBLFdBQXVCQSxVQUFXbkIsSUFBSW1ILE9BQUosQ0FBWTdGLEdBQVosSUFBbUIsQ0FBQyxDQUEvQixHQUFzQ0EsT0FBT3RCLEdBQXBFO0FBQUEsQ0FBakI7O0FBRUE7Ozs7Ozs7Ozs7QUFVTyxTQUFTMEksVUFBVCxDQUFxQnVCLFNBQXJCLEVBQWdDOUgsS0FBaEMsRUFBdUM7QUFDMUMsUUFBTStILFNBQVMsRUFBZjtBQUNBLFFBQU0vSSxVQUFVaUgsT0FBTzZCLFNBQVAsTUFBc0IsT0FBdEM7O0FBRUEsU0FBSyxJQUFNM0ksR0FBWCxJQUFrQmEsS0FBbEIsRUFBeUI7QUFDckIsWUFBSSxDQUFDNkgsU0FBUzFJLEdBQVQsRUFBYzJJLFNBQWQsRUFBeUI5SSxPQUF6QixDQUFMLEVBQXdDO0FBQ3BDK0ksbUJBQU81SSxHQUFQLElBQWNhLE1BQU1iLEdBQU4sQ0FBZDtBQUNIO0FBQ0o7O0FBRUQsV0FBTzRJLE1BQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU08sU0FBU3ZCLGFBQVQsQ0FBd0JzQixTQUF4QixFQUFtQzdILE1BQW5DLEVBQTJDO0FBQzlDLFFBQU04SCxTQUFTLEVBQWY7O0FBRUEsU0FBSyxJQUFNNUksR0FBWCxJQUFrQjJJLFNBQWxCLEVBQTZCO0FBQ3pCLFlBQUkzSSxJQUFJb0csS0FBSixDQUFVdEYsTUFBVixDQUFKLEVBQXVCO0FBQ25COEgsbUJBQU81SSxHQUFQLElBQWMySSxVQUFVM0ksR0FBVixDQUFkO0FBQ0g7QUFDSjs7QUFFRCxXQUFPNEksTUFBUDtBQUNILEM7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0TkQ7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztJQUVRQyxPLEdBQVlySyxVLENBQVpxSyxPO0lBQ0F6QixVLEdBQWUxSSxTLENBQWYwSSxVO0lBRWEwQixJOzs7QUF5QmpCLGtCQUFZakksS0FBWixFQUFtQjtBQUFBOztBQUFBLHFEQUNmLHNCQUFNQSxLQUFOLENBRGU7O0FBR2ZnSSx1QkFBYyxDQUFDLGFBQUQsRUFBZ0IsZUFBaEIsQ0FBZDtBQUhlO0FBSWxCOzttQkFFREUsaUIsZ0NBQW9CO0FBQ2hCLGFBQUtDLFFBQUwsR0FBZ0IsMkJBQVksSUFBWixDQUFoQjs7QUFEZ0IscUJBR2EsS0FBS25JLEtBSGxCO0FBQUEsWUFHUm9JLFVBSFEsVUFHUkEsVUFIUTtBQUFBLFlBR0kvRixJQUhKLFVBR0lBLElBSEo7O0FBSWhCLFlBQUkrRixlQUFlLE9BQW5CLEVBQTRCO0FBQ3hCLGlCQUFLQyxRQUFMLEdBQWdCLEtBQUtGLFFBQUwsQ0FBY0csVUFBOUI7QUFDSCxTQUZELE1BRU87QUFDSCxpQkFBS0QsUUFBTCxHQUFnQiwyQkFBWWhHLElBQVosQ0FBaEI7QUFERyw4QkFFZ0NBLEtBQUtyQyxLQUZyQztBQUFBLGdCQUVLQyxNQUZMLGVBRUtBLE1BRkw7QUFBQSxnQkFFYXNJLE1BRmIsZUFFYUEsTUFGYjtBQUFBLGdCQUVxQkMsTUFGckIsZUFFcUJBLE1BRnJCOztBQUdILGdCQUFJRCxVQUFVQyxNQUFkLEVBQXNCO0FBQ2xCLHFCQUFLSCxRQUFMLEdBQWdCLEtBQUtBLFFBQUwsQ0FBY0ksYUFBZCxPQUFnQ3hJLE1BQWhDLGtCQUFoQjtBQUNIO0FBQ0o7O0FBRUQsYUFBS3lJLFFBQUw7QUFDSCxLOzttQkFFRDNILGtCLGlDQUFxQjtBQUNqQixhQUFLMkgsUUFBTDtBQUNILEs7O21CQUVEQyxTLHdCQUFZO0FBQUEsc0JBQ3lCLEtBQUszSSxLQUQ5QjtBQUFBLFlBQ0FxQyxJQURBLFdBQ0FBLElBREE7QUFBQSxZQUNNcUQsSUFETixXQUNNQSxJQUROO0FBQUEsWUFDWWtELFFBRFosV0FDWUEsUUFEWjtBQUFBLFlBRUFELFNBRkEsR0FFY3RHLEtBQUtyQyxLQUZuQixDQUVBMkksU0FGQTs7QUFHUixlQUFPQSxjQUFjakQsU0FBUyxTQUFULElBQXNCLENBQUNrRCxRQUFyQyxDQUFQO0FBQ0gsSzs7bUJBRURDLFUseUJBQWE7QUFBQSxzQkFDYyxLQUFLN0ksS0FEbkI7QUFBQSxZQUNEOEksSUFEQyxXQUNEQSxJQURDO0FBQUEsWUFDS3pHLElBREwsV0FDS0EsSUFETDtBQUFBLFlBRUQwRyxVQUZDLEdBRWMxRyxLQUFLMkcsS0FGbkIsQ0FFREQsVUFGQzs7QUFHVCxlQUFPQSxlQUFlRCxJQUF0QjtBQUNILEs7O21CQUVESixRLHVCQUFXO0FBQ1AsWUFBTU8sVUFBVSxLQUFLSixVQUFMLEVBQWhCO0FBQ0EsWUFBSUksT0FBSixFQUFhO0FBQ1QsZ0JBQUksS0FBS04sU0FBTCxFQUFKLEVBQXNCO0FBQ2xCLHFCQUFLUixRQUFMLENBQWNuSyxLQUFkLENBQW9CLEVBQUVrTCxlQUFlLElBQWpCLEVBQXBCO0FBQ0g7QUFDRCxnQkFBSSxLQUFLYixRQUFMLElBQWlCLEtBQUtBLFFBQUwsQ0FBY2MsWUFBZCxHQUE2QixLQUFLZCxRQUFMLENBQWNlLFlBQWhFLEVBQThFO0FBQzFFLG9CQUFNQyxlQUFlLEtBQUtoQixRQUFMLENBQWNlLFlBQWQsR0FBNkIsS0FBS2YsUUFBTCxDQUFjaUIsU0FBaEU7QUFDQSxvQkFBTUMsYUFBYSxLQUFLcEIsUUFBTCxDQUFjcUIsU0FBZCxHQUEwQixLQUFLckIsUUFBTCxDQUFjc0IsWUFBM0Q7QUFDQSxvQkFBSUYsYUFBYUYsWUFBakIsRUFBK0I7QUFDM0IseUJBQUtoQixRQUFMLENBQWNpQixTQUFkLEdBQTBCQyxhQUFhLEtBQUtsQixRQUFMLENBQWNlLFlBQXJEO0FBQ0gsaUJBRkQsTUFFTyxJQUFJLEtBQUtqQixRQUFMLENBQWNxQixTQUFkLEdBQTBCLEtBQUtuQixRQUFMLENBQWNpQixTQUE1QyxFQUF1RDtBQUMxRCx5QkFBS2pCLFFBQUwsQ0FBY2lCLFNBQWQsR0FBMEIsS0FBS25CLFFBQUwsQ0FBY3FCLFNBQXhDO0FBQ0g7QUFDSjtBQUNKO0FBQ0osSzs7bUJBRURFLFcsd0JBQVl2SSxDLEVBQUc7QUFDWEEsVUFBRXdJLGVBQUY7O0FBRFcsc0JBR3NCLEtBQUszSixLQUgzQjtBQUFBLFlBR0g4SSxJQUhHLFdBR0hBLElBSEc7QUFBQSxZQUdHekcsSUFISCxXQUdHQSxJQUhIO0FBQUEsWUFHU3VHLFFBSFQsV0FHU0EsUUFIVDs7O0FBS1gsWUFBSSxDQUFDQSxRQUFMLEVBQWU7QUFDWHZHLGlCQUFLdUgsZUFBTCxDQUFxQmQsSUFBckIsRUFBMkIsSUFBM0IsRUFBaUMzSCxDQUFqQzs7QUFFQSxpQkFBS25CLEtBQUwsQ0FBVzZKLE9BQVgsSUFBc0IsS0FBSzdKLEtBQUwsQ0FBVzZKLE9BQVgsQ0FBbUIxSSxDQUFuQixDQUF0QjtBQUNILFNBSkQsTUFJTztBQUNIQSxjQUFFMkksY0FBRjtBQUNIO0FBQ0osSzs7bUJBRURDLGEsMEJBQWM1SSxDLEVBQUc7QUFBQSxzQkFDZ0IsS0FBS25CLEtBRHJCO0FBQUEsWUFDTDhJLElBREssV0FDTEEsSUFESztBQUFBLFlBQ0N6RyxJQURELFdBQ0NBLElBREQ7QUFBQSxZQUNPcUQsSUFEUCxXQUNPQSxJQURQOztBQUViLFlBQUksS0FBS2lELFNBQUwsRUFBSixFQUFzQjtBQUNsQnRHLGlCQUFLMkgsaUJBQUwsQ0FBdUJsQixJQUF2QixFQUE2QnBELElBQTdCLEVBQW1DLElBQW5DLEVBQXlDdkUsQ0FBekM7QUFDSDs7QUFFRCxhQUFLbkIsS0FBTCxDQUFXaUssU0FBWCxJQUF3QixLQUFLakssS0FBTCxDQUFXaUssU0FBWCxDQUFxQjlJLENBQXJCLENBQXhCO0FBQ0gsSzs7bUJBRUQrSSxRLHFCQUFTMUksUSxFQUFVO0FBQ2YsWUFBSTJJLGNBQWMsRUFBbEI7O0FBRUEsWUFBTUMsT0FBTyxTQUFQQSxJQUFPLFdBQVk7QUFDckI5SSw0QkFBU3lELE9BQVQsQ0FBaUJ2RCxRQUFqQixFQUEyQixpQkFBUztBQUNoQyxvQkFBSSwyQkFBZTZJLEtBQWYsS0FBMEJBLE1BQU1ySyxLQUFOLENBQVl3QixRQUExQyxFQUFvRDtBQUNoRDRJLHlCQUFLQyxNQUFNckssS0FBTixDQUFZd0IsUUFBakI7QUFDSCxpQkFGRCxNQUVPLElBQUksT0FBTzZJLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDbENGLG1DQUFlRSxLQUFmO0FBQ0g7QUFDSixhQU5EO0FBT0gsU0FSRDs7QUFVQUQsYUFBSzVJLFFBQUw7O0FBRUEsZUFBTzJJLFdBQVA7QUFDSCxLOzttQkFFRDlJLE0scUJBQVM7QUFBQTs7QUFBQSxzQkFDMEgsS0FBS3JCLEtBRC9IO0FBQUEsWUFDR3NLLEtBREgsV0FDR0EsS0FESDtBQUFBLFlBQ1VqSSxJQURWLFdBQ1VBLElBRFY7QUFBQSxZQUNnQmtJLGdCQURoQixXQUNnQkEsZ0JBRGhCO0FBQUEsWUFDa0NDLFdBRGxDLFdBQ2tDQSxXQURsQztBQUFBLFlBQytDQyxTQUQvQyxXQUMrQ0EsU0FEL0M7QUFBQSxZQUMwRDdCLFFBRDFELFdBQzBEQSxRQUQxRDtBQUFBLFlBQ29FaEQsU0FEcEUsV0FDb0VBLFNBRHBFO0FBQUEsWUFDK0VwRSxRQUQvRSxXQUMrRUEsUUFEL0U7QUFBQSxZQUN5RmtKLFVBRHpGLFdBQ3lGQSxVQUR6RjtBQUFBLFlBQ3FHdEMsVUFEckcsV0FDcUdBLFVBRHJHO0FBQUEsWUFDaUhVLElBRGpILFdBQ2lIQSxJQURqSDs7QUFFTCxZQUFNZixTQUFTeEIsV0FBVzFCLE9BQU9DLElBQVAsQ0FBWW1ELEtBQUt2RyxTQUFqQixDQUFYLEVBQXdDLEtBQUsxQixLQUE3QyxDQUFmOztBQUZLLDJCQUkyRHFDLEtBQUtyQyxLQUpoRTtBQUFBLFlBSUdDLE1BSkgsZ0JBSUdBLE1BSkg7QUFBQSxZQUlXMEksU0FKWCxnQkFJV0EsU0FKWDtBQUFBLFlBSXNCZ0MsWUFKdEIsZ0JBSXNCQSxZQUp0QjtBQUFBLFlBSW9DQyxhQUpwQyxnQkFJb0NBLGFBSnBDO0FBQUEsWUFJbUR2SyxHQUpuRCxnQkFJbURBLEdBSm5EOztBQUtMLFlBQU00SSxVQUFVLEtBQUtKLFVBQUwsRUFBaEI7O0FBRUEsWUFBTWdDLGVBQWVOLG1CQUFtQjNFLFNBQW5CLEdBQStCLHlDQUM1QzNGLE1BRDRDLGtCQUN4QixJQUR3QixNQUU1Q0EsTUFGNEMsaUJBRXpCMkksUUFGeUIsTUFHNUMzSSxNQUg0QyxnQkFHMUIsQ0FBQzBJLFNBQUQsSUFBY00sT0FIWSxNQUkvQzJCLGFBSitDLElBSS9CLENBQUMsQ0FBQ0EsYUFKNkIsTUFLL0NoRixTQUwrQyxJQUtuQyxDQUFDLENBQUNBLFNBTGlDLE9BQXBEO0FBT0EsWUFBSWdELFFBQUosRUFBYztBQUNWYixtQkFBTyxlQUFQLElBQTBCLElBQTFCO0FBQ0g7O0FBRURBLGVBQU8rQyxRQUFQLEdBQWtCekksS0FBSzBJLFdBQUwsS0FBcUJqQyxJQUFyQixHQUE0QixHQUE1QixHQUFrQyxJQUFwRDs7QUFFQSxZQUFJVixlQUFlLFFBQWYsSUFBMkJrQyxRQUFRLENBQW5DLElBQXdDSyxlQUFlLENBQXZELElBQTRERCxVQUFoRSxFQUE0RTtBQUFBOztBQUN4RTNDLG1CQUFPaUQsS0FBUCxnQkFDUWpELE9BQU9pRCxLQUFQLElBQWdCLEVBRHhCLDZCQUVLM0ssTUFBTSxjQUFOLEdBQXVCLGFBRjVCLElBRWdEaUssUUFBUUssWUFBVCxHQUEwQixDQUFDSCxlQUFlLENBQWhCLElBQXFCLEdBQXJCLEdBQTJCRyxZQUZwRztBQUlIO0FBQ0QsWUFBTU0sVUFBVVIsU0FBaEI7O0FBRUEsZUFDSTtBQUFDLG1CQUFEO0FBQUEsdUJBQVMsTUFBSyxVQUFkO0FBQ0ksdUJBQU8sS0FBS1AsUUFBTCxDQUFjMUksUUFBZDtBQURYLGVBRVF1RyxNQUZSO0FBR0ksMkJBQVc4QyxZQUhmO0FBSUkseUJBQVMsS0FBS25CLFdBSmxCO0FBS0ksMkJBQVcsS0FBS0ssYUFMcEI7QUFNSTtBQUFBO0FBQUEsa0JBQUssV0FBYzlKLE1BQWQsb0JBQUw7QUFBNkN1QjtBQUE3QztBQU5KLFNBREo7QUFVSCxLOzs7RUFqSzZCQyxnQixVQUN2QkMsUyxHQUFZO0FBQ2ZvSCxVQUFNbkgsb0JBQVVDLE1BREQ7QUFFZjBJLFdBQU8zSSxvQkFBVXVKLE1BRkY7QUFHZlYsaUJBQWE3SSxvQkFBVXVKLE1BSFI7QUFJZjdJLFVBQU1WLG9CQUFVakYsTUFKRDtBQUtmeU8sWUFBUXhKLG9CQUFVakYsTUFMSDtBQU1mMEwsZ0JBQVl6RyxvQkFBVW9FLEtBQVYsQ0FBZ0IsQ0FBQyxRQUFELEVBQVcsT0FBWCxDQUFoQixDQU5HO0FBT2ZMLFVBQU0vRCxvQkFBVW9FLEtBQVYsQ0FBZ0IsQ0FBQyxTQUFELEVBQVksTUFBWixDQUFoQixDQVBTO0FBUWYwRSxlQUFXOUksb0JBQVVDLE1BUk47QUFTZmdILGNBQVVqSCxvQkFBVUUsSUFUTDtBQVVmK0QsZUFBV2pFLG9CQUFVQyxNQVZOO0FBV2ZpSSxhQUFTbEksb0JBQVVoRSxJQVhKO0FBWWZzTSxlQUFXdEksb0JBQVVoRSxJQVpOO0FBYWYrTSxnQkFBWS9JLG9CQUFVRSxJQWJQO0FBY2YwSSxzQkFBa0I1SSxvQkFBVUU7QUFkYixDLFNBaUJaRSxZLEdBQWU7QUFDbEIwSSxlQUFXLElBRE87QUFFbEJELGlCQUFhLENBRks7QUFHbEJELHNCQUFrQixLQUhBO0FBSWxCRyxnQkFBWTtBQUpNLEM7QUFsQkx6QyxJO2tCQUFBQSxJOzs7Ozs7Ozs7Ozs7QUNUckI7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUFtRCxrQkFBUUMsT0FBUixHQUFrQkEsaUJBQWxCO0FBQ0FELGtCQUFRRSxRQUFSLEdBQW1CQSxrQkFBbkI7QUFDQUYsa0JBQVFHLEtBQVIsR0FBZ0I1TCx5QkFBZXNDLE1BQWYsQ0FBc0JzSixlQUF0QixFQUE2QjtBQUN6Q0MsaUJBQWEsQ0FBQyxTQUFEO0FBRDRCLENBQTdCLENBQWhCOztrQkFJZTdMLHlCQUFlc0MsTUFBZixDQUFzQm1KLGlCQUF0QixFQUErQjtBQUMxQ0ksaUJBQWEsQ0FBQyxZQUFELEVBQWUsZ0JBQWY7QUFENkIsQ0FBL0IsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaZjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTUMsT0FBTyxTQUFQQSxJQUFPLEdBQU0sQ0FBRyxDQUF0Qjs7SUFFcUJDLEk7Ozs7Ozs7Ozs7Ozs0SkFxQ2pCQyxTLEdBQVksVUFBQ2xOLENBQUQsRUFBSW1OLEdBQUosRUFBWTtBQUNwQixrQkFBSzVMLEtBQUwsQ0FBVzZMLE1BQVgsQ0FBa0JwTixDQUFsQixFQUFxQm1OLEdBQXJCO0FBQ0gsUyxRQUVERSxVLEdBQWEsVUFBQ0MsTUFBRCxFQUFTQyxLQUFULEVBQWdCN0ssQ0FBaEIsRUFBc0I7QUFDL0Isa0JBQUtuQixLQUFMLENBQVc4TCxVQUFYLENBQXNCQyxNQUF0QixFQUE4QkMsS0FBOUIsRUFBcUM3SyxDQUFyQztBQUNILFMsUUFFRDhLLGUsR0FBa0IsVUFBQ0YsTUFBRCxFQUFTQyxLQUFULEVBQWdCN0ssQ0FBaEIsRUFBc0I7QUFDcEMsa0JBQUtuQixLQUFMLENBQVdpTSxlQUFYLENBQTJCRixNQUEzQixFQUFtQ0MsS0FBbkMsRUFBMEM3SyxDQUExQztBQUNILFMsUUFFRCtLLGUsR0FBa0IsVUFBQ0gsTUFBRCxFQUFTQyxLQUFULEVBQWdCN0ssQ0FBaEIsRUFBc0I7QUFDcEMsa0JBQUtuQixLQUFMLENBQVdrTSxlQUFYLENBQTJCSCxNQUEzQixFQUFtQ0MsS0FBbkMsRUFBMEM3SyxDQUExQztBQUNILFM7OzttQkFFREUsTSxxQkFBUztBQUFBOztBQUNMO0FBREsscUJBR3dJLEtBQUtyQixLQUg3STtBQUFBLFlBRUdDLE1BRkgsVUFFR0EsTUFGSDtBQUFBLFlBRVcyRixTQUZYLFVBRVdBLFNBRlg7QUFBQSxZQUVzQnBFLFFBRnRCLFVBRXNCQSxRQUZ0QjtBQUFBLFlBRTJDMkssR0FGM0MsVUFFZ0MxQixTQUZoQztBQUFBLFlBRWdEMkIsUUFGaEQsVUFFZ0RBLFFBRmhEO0FBQUEsWUFFMERDLE9BRjFELFVBRTBEQSxPQUYxRDtBQUFBLFlBRW1FQyxZQUZuRSxVQUVtRUEsWUFGbkU7QUFBQSxZQUVpRkMsVUFGakYsVUFFaUZBLFVBRmpGO0FBQUEsWUFFNkZDLFlBRjdGLFVBRTZGQSxZQUY3RjtBQUFBLFlBR0RDLFVBSEMsVUFHREEsVUFIQztBQUFBLFlBR1dDLFdBSFgsVUFHV0EsV0FIWDtBQUFBLFlBR3dCQyxVQUh4QixVQUd3QkEsVUFIeEI7QUFBQSxZQUdvQ0MsT0FIcEMsVUFHb0NBLE9BSHBDO0FBQUEsWUFHNkNDLE9BSDdDLFVBRzZDQSxPQUg3QztBQUFBLFlBR3NEaEIsTUFIdEQsVUFHc0RBLE1BSHREO0FBQUEsWUFHOERDLFVBSDlELFVBRzhEQSxVQUg5RDtBQUFBLFlBRzBFRyxlQUgxRSxVQUcwRUEsZUFIMUU7QUFBQSxZQUcyRkMsZUFIM0YsVUFHMkZBLGVBSDNGO0FBQUEsWUFHNEdoTSxNQUg1RyxVQUc0R0EsTUFINUc7QUFBQSxZQUdvSEMsSUFIcEgsVUFHb0hBLElBSHBIO0FBQUEsWUFHNkg0SCxNQUg3SDs7QUFBQSw4QkFLZ0R3RSxVQUxoRCxDQUtHTyxHQUxIO0FBQUEsWUFLR0EsR0FMSCxtQ0FLU0MsYUFMVDtBQUFBLCtCQUtnRFIsVUFMaEQsQ0FLdUJTLElBTHZCO0FBQUEsWUFLdUJBLElBTHZCLG9DQUs4QkMsY0FMOUI7O0FBTUwsWUFBTUMsUUFBUWIsVUFBVTtBQUFBO0FBQUE7QUFBQTtBQUFBLFNBQVYsR0FBZ0NDLGdCQUFnQnBNLE9BQU9nTixLQUFyRTtBQUNBLFlBQUlDLE9BQVE7QUFBQTtBQUFBO0FBQ1I7QUFBQTtBQUFBLGtCQUFJLFNBQVNOLFFBQVFsTyxNQUFyQjtBQUNJO0FBQUE7QUFBQSxzQkFBSyxXQUFjc0IsTUFBZCxnQkFBTDtBQUF5Q2lOO0FBQXpDO0FBREo7QUFEUSxTQUFaO0FBS0EsWUFBSWYsUUFBUSxLQUFaLEVBQW1CO0FBQ2ZnQixtQkFBUTtBQUFBO0FBQUEsa0JBQU8sTUFBSyxPQUFaO0FBQW9CO0FBQUE7QUFBQTtBQUFRQTtBQUFSO0FBQXBCLGFBQVI7QUFDSDtBQUNELFlBQUlSLFdBQVdoTyxNQUFmLEVBQXVCO0FBQ25Cd08sbUJBQU9SLFdBQVd6SixHQUFYLENBQWUsVUFBQzZJLE1BQUQsRUFBU0MsS0FBVCxFQUFtQjtBQUFBOztBQUNyQyxvQkFBTW9CLFdBQVdWLFlBQVlYLE1BQVosRUFBb0JDLEtBQXBCLEtBQThCLEVBQS9DO0FBQ0Esb0JBQU1xQixXQUFXRCxTQUFTeEgsU0FBMUI7QUFDQSxvQkFBTUEsWUFBWTtBQUNkMEgsMkJBQU90QixVQUFVLENBREg7QUFFZHVCLDBCQUFNdkIsVUFBVVcsV0FBV2hPLE1BQVgsR0FBb0I7QUFGdEIsK0JBR2IwTyxRQUhhLElBR0ZBLFFBSEUsZUFBbEI7QUFLQSxvQkFBTUcsV0FBV3pCLE9BQU8wQixVQUFQLEdBQW9CLFVBQXBCLEdBQWlDLEVBQWxEO0FBQ0EsdUJBQVEsOEJBQUMsR0FBRCxhQUFLLFdBQVExQixPQUFPVSxVQUFQLEtBQXNCVCxLQUE5QixJQUFzQ3dCO0FBQTNDLG1CQUNBSixRQURBO0FBRUoseUJBQUssT0FBS3pCLFNBQUwsQ0FBZStCLElBQWYsQ0FBb0IsTUFBcEIsRUFBMEIxQixLQUExQixDQUZEO0FBR0osOEJBQVVJLFFBSE47QUFJSiw2QkFBU1MsT0FKTDtBQUtKLGdDQUFZSixVQUxSO0FBTUosNEJBQVFWLE1BTko7QUFPSiw4QkFBVUMsS0FQTjtBQVFKLDRCQUFRL0wsTUFSSjtBQVNKLDBCQUFNRSxJQVRGO0FBVUosNkJBQVN5TSxPQVZMO0FBV0osa0NBQWNKLFlBWFY7QUFZSiwrQkFBVzVHLFNBWlA7QUFhSiwwQkFBTW9ILElBYkY7QUFjSiw2QkFBUyxPQUFLbEIsVUFkVjtBQWVKLDRCQUFRNUwsTUFmSjtBQWdCSixrQ0FBYyxPQUFLK0wsZUFoQmY7QUFpQkosa0NBQWMsT0FBS0M7QUFqQmYsbUJBQVI7QUFtQkgsYUE1Qk0sQ0FBUDtBQTZCSDtBQUNELGVBQVE7QUFBQyxlQUFEO0FBQUEsdUJBQUssV0FBV3RHLFNBQWhCLElBQStCbUMsTUFBL0I7QUFDSG9GLGdCQURHO0FBRUgzTDtBQUZHLFNBQVI7QUFJSCxLOzs7RUF2RzZCbU0sZ0JBQU1sTSxTLFVBQzdCQyxTLEdBQVk7QUFDZjJLLGFBQVMxSyxvQkFBVUUsSUFESjtBQUVmeUssa0JBQWMzSyxvQkFBVWlNLEdBRlQ7QUFHZjNOLFlBQVEwQixvQkFBVUMsTUFISDtBQUlmekIsVUFBTXdCLG9CQUFVRSxJQUpEO0FBS2YwSyxnQkFBWTVLLG9CQUFVakYsTUFMUDtBQU1mOFAsa0JBQWM3SyxvQkFBVWhFLElBTlQ7QUFPZmlQLGFBQVNqTCxvQkFBVWhFLElBUEo7QUFRZjhPLGdCQUFZOUssb0JBQVVDLE1BUlA7QUFTZjhLLGlCQUFhL0ssb0JBQVVoRSxJQVRSO0FBVWZrTyxZQUFRbEssb0JBQVVoRSxJQVZIO0FBV2ZnUCxnQkFBWWhMLG9CQUFVa00sS0FYUDtBQVlmck0sY0FBVUcsb0JBQVVpTSxHQVpMO0FBYWZoSSxlQUFXakUsb0JBQVVDLE1BYk47QUFjZjZJLGVBQVc5SSxvQkFBVUMsTUFkTjtBQWVmd0ssY0FBVXpLLG9CQUFVakYsTUFmTDtBQWdCZm1RLGFBQVNsTCxvQkFBVWtNLEtBaEJKO0FBaUJmL0IsZ0JBQVluSyxvQkFBVWhFLElBakJQO0FBa0Jmc08scUJBQWlCdEssb0JBQVVoRSxJQWxCWjtBQW1CZnVPLHFCQUFpQnZLLG9CQUFVaEUsSUFuQlo7QUFvQmZ1QyxZQUFReUIsb0JBQVVqRjtBQXBCSCxDLFNBc0JacUYsWSxHQUFlO0FBQ2xCc0ssYUFBUyxLQURTO0FBRWxCcE0sWUFBUSxPQUZVO0FBR2xCc00sZ0JBQVksRUFITTtBQUlsQkMsa0JBQWNmLElBSkk7QUFLbEJtQixhQUFTbkIsSUFMUztBQU1sQmdCLGdCQUFZLElBTk07QUFPbEJDLGlCQUFhakIsSUFQSztBQVFsQkksWUFBUUosSUFSVTtBQVNsQmtCLGdCQUFZLEVBVE07QUFVbEJsQyxlQUFXLE9BVk87QUFXbEJvQyxhQUFTO0FBWFMsQztBQXZCTG5CLEk7a0JBQUFBLEk7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUnJCOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7OztBQUVBLElBQU1ELE9BQU8sU0FBUEEsSUFBTyxHQUFNLENBQUcsQ0FBdEI7O0lBRXFCcUIsRzs7Ozs7Ozs7Ozs7OzRKQStDakJqRCxPLEdBQVUsVUFBQzFJLENBQUQsRUFBTztBQUFBLDhCQUNnQixNQUFLbkIsS0FEckI7QUFBQSxnQkFDTCtMLE1BREssZUFDTEEsTUFESztBQUFBLGdCQUNHK0IsUUFESCxlQUNHQSxRQURIOztBQUViLGtCQUFLOU4sS0FBTCxDQUFXNkosT0FBWCxDQUFtQmtDLE1BQW5CLEVBQTJCK0IsUUFBM0IsRUFBcUMzTSxDQUFyQztBQUNILFMsUUFFRDRNLFksR0FBZSxVQUFDNU0sQ0FBRCxFQUFPO0FBQUEsK0JBQ1csTUFBS25CLEtBRGhCO0FBQUEsZ0JBQ1YrTCxNQURVLGdCQUNWQSxNQURVO0FBQUEsZ0JBQ0YrQixRQURFLGdCQUNGQSxRQURFOztBQUVsQixrQkFBS0UsVUFBTCxDQUFnQmpDLE1BQWhCLEVBQXdCK0IsUUFBeEIsRUFBa0MsSUFBbEMsRUFBd0MzTSxDQUF4QztBQUNILFMsUUFFRDhNLFksR0FBZSxVQUFDOU0sQ0FBRCxFQUFPO0FBQUEsK0JBQ1csTUFBS25CLEtBRGhCO0FBQUEsZ0JBQ1YrTCxNQURVLGdCQUNWQSxNQURVO0FBQUEsZ0JBQ0YrQixRQURFLGdCQUNGQSxRQURFOztBQUVsQixrQkFBS0UsVUFBTCxDQUFnQmpDLE1BQWhCLEVBQXdCK0IsUUFBeEIsRUFBa0MsS0FBbEMsRUFBeUMzTSxDQUF6QztBQUNILFM7OztrQkF0QkQrTSxxQixrQ0FBc0JwTixTLEVBQVc7QUFDN0IsWUFBSUEsVUFBVVgsSUFBZCxFQUFvQjtBQUNoQixnQkFBTWdPLFVBQVV0USxVQUFJd0ksWUFBSixDQUFpQixLQUFLckcsS0FBdEIsRUFBNkJjLFNBQTdCLENBQWhCO0FBQ0EsbUJBQU8sQ0FBQ3FOLE9BQVI7QUFDSDs7QUFFRCxlQUFPLElBQVA7QUFDSCxLOztrQkFpQkRILFUsdUJBQVdqQyxNLEVBQVFDLEssRUFBT29DLE8sRUFBU2pOLEMsRUFBRztBQUFBLHFCQUNLLEtBQUtuQixLQURWO0FBQUEsWUFDMUIrTixZQUQwQixVQUMxQkEsWUFEMEI7QUFBQSxZQUNaRSxZQURZLFVBQ1pBLFlBRFk7QUFBQSxZQUU5QkksVUFGOEIsR0FFakIsMkJBQVksSUFBWixDQUZpQjs7QUFHbEMsWUFBSUQsT0FBSixFQUFhO0FBQ1RMLHlCQUFhaEMsTUFBYixFQUFxQkMsS0FBckIsRUFBNEI3SyxDQUE1QjtBQUNBa04sMEJBQWM1USxVQUFJNlEsUUFBSixDQUFhRCxVQUFiLEVBQXlCLFNBQXpCLENBQWQ7QUFDSCxTQUhELE1BR087QUFDSEoseUJBQWFsQyxNQUFiLEVBQXFCQyxLQUFyQixFQUE0QjdLLENBQTVCO0FBQ0FrTiwwQkFBYzVRLFVBQUk4USxXQUFKLENBQWdCRixVQUFoQixFQUE0QixTQUE1QixDQUFkO0FBQ0g7QUFDSixLOztrQkFFREcsVyx3QkFBWXpDLE0sRUFBUTtBQUFBOztBQUFBLHNCQUM2RSxLQUFLL0wsS0FEbEY7QUFBQSxZQUNSZ04sSUFEUSxXQUNSQSxJQURRO0FBQUEsWUFDRkgsT0FERSxXQUNGQSxPQURFO0FBQUEsWUFDT0wsWUFEUCxXQUNPQSxZQURQO0FBQUEsWUFDcUJJLE9BRHJCLFdBQ3FCQSxPQURyQjtBQUFBLFlBQzhCM00sTUFEOUIsV0FDOEJBLE1BRDlCO0FBQUEsWUFDc0M2TixRQUR0QyxXQUNzQ0EsUUFEdEM7QUFBQSxZQUNnRHJCLFVBRGhELFdBQ2dEQSxVQURoRDtBQUFBLFlBQzREdE0sSUFENUQsV0FDNERBLElBRDVEO0FBQUEsWUFDa0VELE1BRGxFLFdBQ2tFQSxNQURsRTtBQUFBLFlBRVJ1TyxRQUZRLEdBRUssS0FBS0MsT0FGVixDQUVSRCxRQUZROztBQUdoQixlQUFPNUIsUUFBUTNKLEdBQVIsQ0FBWSxVQUFDbUgsS0FBRCxFQUFRN0UsUUFBUixFQUFxQjtBQUFBOztBQUFBLGdCQUM1Qm1KLFNBRDRCLEdBQ1d0RSxLQURYLENBQzVCc0UsU0FENEI7QUFBQSxnQkFDakJDLEtBRGlCLEdBQ1d2RSxLQURYLENBQ2pCdUUsS0FEaUI7QUFBQSxnQkFDVkMsS0FEVSxHQUNXeEUsS0FEWCxDQUNWd0UsS0FEVTtBQUFBLGdCQUNBOUcsTUFEQSw0QkFDV3NDLEtBRFg7O0FBR3BDLGdCQUFNekMsUUFBUSw0QkFBZ0JtRSxNQUFoQixFQUF3QjRDLFNBQXhCLENBQWQ7QUFDQSxnQkFBTUcsUUFBUXRDLGFBQWFzQixRQUFiLEVBQXVCdEksUUFBdkIsRUFBaUNtSixTQUFqQyxFQUE0QzVDLE1BQTVDLEtBQXVELEVBQXJFOztBQUVBLGdCQUFJLE9BQUsyQyxPQUFMLENBQWFLLGtCQUFqQixFQUFxQztBQUNqQyxvQkFBTUMsaUJBQWlCLE9BQUtOLE9BQUwsQ0FBYUssa0JBQWIsQ0FBZ0M3TCxHQUFoQyxDQUFvQztBQUFBLDJCQUFhK0wsVUFBVWhNLFFBQVYsRUFBYjtBQUFBLGlCQUFwQyxFQUF1RStCLE9BQXZFLENBQStFLENBQUM4SSxRQUFELEVBQVd0SSxRQUFYLEVBQXFCdkMsUUFBckIsRUFBL0UsQ0FBdkI7QUFDQSxvQkFBSStMLGlCQUFpQixDQUFDLENBQXRCLEVBQXlCO0FBQ3JCLDJCQUFLTixPQUFMLENBQWFLLGtCQUFiLENBQWdDRyxNQUFoQyxDQUF1Q0YsY0FBdkMsRUFBdUQsQ0FBdkQ7QUFDQSwyQkFBTyxJQUFQO0FBQ0g7QUFDSjtBQUNELGdCQUFJRixNQUFNSyxPQUFOLElBQWlCTCxNQUFNSyxPQUFOLEdBQWdCLENBQWpDLElBQXNDTCxNQUFNTSxPQUFOLElBQWlCTixNQUFNTSxPQUFOLEdBQWdCLENBQTNFLEVBQThFO0FBQzFFLHVCQUFLQyxzQkFBTCxDQUE0QjdKLFFBQTVCLEVBQXNDc0ksUUFBdEMsRUFBZ0RnQixNQUFNSyxPQUFOLElBQWlCLENBQWpFLEVBQW9FTCxNQUFNTSxPQUFOLElBQWlCLENBQXJGO0FBQ0g7O0FBRUQsZ0JBQU14SixZQUFZO0FBQ2QwSCx1QkFBT21CLGFBQWEsT0FBYixJQUF3QmpKLGFBQWEsQ0FEOUI7QUFFZCtILHNCQUFNa0IsYUFBYSxNQUFiLEtBQXdCakosYUFBYXFILFFBQVFsTyxNQUFSLEdBQWlCLENBQTlCLElBQW1DNkcsV0FBV3NKLE1BQU1LLE9BQWpCLEtBQTZCdEMsUUFBUWxPLE1BQWhHLENBRlEsZ0JBR2IwTCxNQUFNekUsU0FITyxJQUdLeUUsTUFBTXpFLFNBSFgsZUFBbEI7O0FBTUEsbUJBQVEsOEJBQUMsSUFBRCxhQUFNLEtBQUtKO0FBQVgsZUFDQXVDLE1BREEsRUFFQStHLEtBRkE7QUFHSixxQkFBSyxhQUFDUSxJQUFEO0FBQUEsMkJBQVUxQyxRQUFRa0IsUUFBUixFQUFrQnRJLFFBQWxCLEVBQTRCOEosSUFBNUIsQ0FBVjtBQUFBLGlCQUhEO0FBSUosd0JBQVFyUCxNQUpKO0FBS0osc0JBQU1FLElBTEY7QUFNSiw0QkFBWXNNLFVBTlI7QUFPSix3QkFBUVYsTUFQSjtBQVFKLDJCQUFXbkcsU0FSUDtBQVNKLHVCQUFPZ0MsS0FUSDtBQVVKLDBCQUFVcEMsUUFWTjtBQVdKLDBCQUFVc0ksUUFYTjtBQVlKLHVCQUFPYyxLQVpIO0FBYUosd0JBQVExTyxNQWJKO0FBY0osdUJBQU8yTztBQWRILGVBQVI7QUFnQkgsU0F2Q00sQ0FBUDtBQXdDSCxLOztrQkFFRFEsc0IsbUNBQXVCN0osUSxFQUFVc0ksUSxFQUFVcUIsTyxFQUFTQyxPLEVBQVM7QUFDekQsWUFBTUcsY0FBY0osT0FBcEI7QUFDQSxZQUFNSyxjQUFjSixPQUFwQjtBQUNBLFlBQU1MLHFCQUFxQixFQUEzQjtBQUNBLGFBQUssSUFBSXRRLElBQUksQ0FBYixFQUFnQkEsSUFBSThRLFdBQXBCLEVBQWlDOVEsR0FBakMsRUFBc0M7QUFDbEMsaUJBQUssSUFBSWdSLElBQUksQ0FBYixFQUFnQkEsSUFBSUQsV0FBcEIsRUFBaUNDLEdBQWpDLEVBQXNDO0FBQ2xDVixtQ0FBbUJqUSxJQUFuQixDQUF3QixDQUFDZ1AsV0FBVzJCLENBQVosRUFBZWpLLFdBQVcvRyxDQUExQixDQUF4QjtBQUNIO0FBQ0o7QUFDRCxXQUFHSyxJQUFILENBQVFJLEtBQVIsQ0FBYyxLQUFLd1AsT0FBTCxDQUFhSyxrQkFBM0IsRUFBK0NBLGtCQUEvQztBQUNILEs7O2tCQUVEMU4sTSxxQkFBUztBQUFBOztBQUNMO0FBREssc0JBRXVLLEtBQUtyQixLQUY1SztBQUFBLFlBRUdDLE1BRkgsV0FFR0EsTUFGSDtBQUFBLFlBRVcyRixTQUZYLFdBRVdBLFNBRlg7QUFBQSxZQUVzQmlFLE9BRnRCLFdBRXNCQSxPQUZ0QjtBQUFBLFlBRStCa0UsWUFGL0IsV0FFK0JBLFlBRi9CO0FBQUEsWUFFNkNFLFlBRjdDLFdBRTZDQSxZQUY3QztBQUFBLFlBRTJEcEIsT0FGM0QsV0FFMkRBLE9BRjNEO0FBQUEsWUFFb0VHLElBRnBFLFdBRW9FQSxJQUZwRTtBQUFBLFlBRTBFUixZQUYxRSxXQUUwRUEsWUFGMUU7QUFBQSxZQUV3RnNCLFFBRnhGLFdBRXdGQSxRQUZ4RjtBQUFBLFlBRWtHL0IsTUFGbEcsV0FFa0dBLE1BRmxHO0FBQUEsWUFFMEd2SyxRQUYxRyxXQUUwR0EsUUFGMUc7QUFBQSxZQUVvSGlMLFVBRnBILFdBRW9IQSxVQUZwSDtBQUFBLFlBRWdJRyxPQUZoSSxXQUVnSUEsT0FGaEk7QUFBQSxZQUV5SVIsUUFGekksV0FFeUlBLFFBRnpJO0FBQUEsWUFFbUpqTSxJQUZuSixXQUVtSkEsSUFGbko7QUFBQSxZQUU0SjRILE1BRjVKOztBQUdMLFlBQU0ySCxNQUFNLDJEQUNKelAsTUFESSxrQkFDZ0IsSUFEaEIsZUFFUDJGLFNBRk8sSUFFS0EsU0FGTCxnQkFBWjtBQUlBLGVBQVE7QUFBQTtBQUFBLHVCQUFJLFdBQVc4SixHQUFmLEVBQW9CLE1BQUssS0FBekIsSUFBbUMzSCxNQUFuQztBQUNKLHlCQUFTLEtBQUs4QixPQURWLEVBQ21CLGNBQWMsS0FBS2tFLFlBRHRDLEVBQ29ELGNBQWMsS0FBS0UsWUFEdkU7QUFFSCxpQkFBS08sV0FBTCxDQUFpQnpDLE1BQWpCLENBRkc7QUFHSHZLO0FBSEcsU0FBUjtBQUtILEs7OztFQS9JNEJtTSxnQkFBTWxNLFMsVUFDNUJDLFMsR0FBWTtBQUNmekIsWUFBUTBCLG9CQUFVQyxNQURIO0FBRWZ6QixVQUFNd0Isb0JBQVVFLElBRkQ7QUFHZjRLLGdCQUFZOUssb0JBQVVDLE1BSFA7QUFJZmdFLGVBQVdqRSxvQkFBVUMsTUFKTjtBQUtmaUwsYUFBU2xMLG9CQUFVa00sS0FMSjtBQU1mOUIsWUFBUXBLLG9CQUFVaU0sR0FOSDtBQU9mWixVQUFNckwsb0JBQVVoRSxJQVBEO0FBUWZtUSxjQUFVbk0sb0JBQVV1SixNQVJMO0FBU2ZzQixrQkFBYzdLLG9CQUFVaEUsSUFUVDtBQVVma00sYUFBU2xJLG9CQUFVaEUsSUFWSjtBQVdmb1Esa0JBQWNwTSxvQkFBVWhFLElBWFQ7QUFZZnNRLGtCQUFjdE0sb0JBQVVoRSxJQVpUO0FBYWY2RCxjQUFVRyxvQkFBVWlNLEdBYkw7QUFjZmhCLGFBQVNqTCxvQkFBVWhFLElBZEo7QUFlZnlPLGNBQVV6SyxvQkFBVWpGLE1BZkw7QUFnQmZ3RCxZQUFReUIsb0JBQVVqRjtBQWhCSCxDLFNBbUJacUYsWSxHQUFlO0FBQ2xCOUIsWUFBUSxPQURVO0FBRWxCd00sZ0JBQVksSUFGTTtBQUdsQkksYUFBUyxFQUhTO0FBSWxCZCxZQUFRLEVBSlU7QUFLbEJTLGtCQUFjZixJQUxJO0FBTWxCNUIsYUFBUzRCLElBTlM7QUFPbEJzQyxrQkFBY3RDLElBUEk7QUFRbEJ3QyxrQkFBY3hDLElBUkk7QUFTbEJtQixhQUFTbkIsSUFUUztBQVVsQlcsY0FBVTtBQVZRLEMsU0FhZnVELFksR0FBZTtBQUNsQlosd0JBQW9CcE4sb0JBQVVrTSxLQURaO0FBRWxCWSxjQUFVOU0sb0JBQVVvRSxLQUFWLENBQWdCLENBQUMsTUFBRCxFQUFTLE9BQVQsQ0FBaEI7QUFGUSxDO0FBakNMK0csRztrQkFBQUEsRzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNUckI7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBRXFCRSxJOzs7Ozs7Ozs7bUJBbUNqQmtCLHFCLGtDQUFzQnBOLFMsRUFBVztBQUM3QixZQUFJQSxVQUFVWCxJQUFkLEVBQW9CO0FBQ2hCLGdCQUFNZ08sVUFBVXRRLFVBQUl3SSxZQUFKLENBQWlCLEtBQUtyRyxLQUF0QixFQUE2QmMsU0FBN0IsQ0FBaEI7QUFDQSxtQkFBTyxDQUFDcU4sT0FBUjtBQUNIO0FBQ0QsZUFBTyxJQUFQO0FBQ0gsSzs7bUJBRUQ5TSxNLHFCQUFTO0FBQUE7O0FBQ0w7QUFESyxxQkFHcUgsS0FBS3JCLEtBSDFIO0FBQUEsWUFFRUMsTUFGRixVQUVFQSxNQUZGO0FBQUEsWUFFVTJGLFNBRlYsVUFFVUEsU0FGVjtBQUFBLFlBRXFCMEosSUFGckIsVUFFcUJBLElBRnJCO0FBQUEsWUFFMkIxSCxLQUYzQixVQUUyQkEsS0FGM0I7QUFBQSxZQUVrQ2dJLFNBRmxDLFVBRWtDQSxTQUZsQztBQUFBLFlBRTZDcEssUUFGN0MsVUFFNkNBLFFBRjdDO0FBQUEsWUFFdURzSSxRQUZ2RCxVQUV1REEsUUFGdkQ7QUFBQSxZQUVpRS9CLE1BRmpFLFVBRWlFQSxNQUZqRTtBQUFBLFlBRXlFMkMsT0FGekUsVUFFeUVBLE9BRnpFO0FBQUEsWUFFa0ZFLEtBRmxGLFVBRWtGQSxLQUZsRjtBQUFBLGtDQUV5RjVELEtBRnpGO0FBQUEsWUFFeUZBLEtBRnpGLGdDQUVpRyxFQUZqRztBQUFBLFlBRWdIbUIsR0FGaEgsVUFFcUcxQixTQUZyRztBQUFBLFlBR0RqSixRQUhDLFVBR0RBLFFBSEM7QUFBQSxZQUdTcU8sS0FIVCxVQUdTQSxLQUhUO0FBQUEsWUFHZ0JoQixLQUhoQixVQUdnQkEsS0FIaEI7QUFBQSxZQUd1QmlCLFVBSHZCLFVBR3VCQSxVQUh2QjtBQUFBLFlBR21DckQsVUFIbkMsVUFHbUNBLFVBSG5DO0FBQUEsWUFHK0NzRCxZQUgvQyxVQUcrQ0EsWUFIL0M7QUFBQSxZQUc2REMsVUFIN0QsVUFHNkRBLFVBSDdEO0FBQUEsWUFHeUVDLE9BSHpFLFVBR3lFQSxPQUh6RTtBQUFBLFlBR2tGQyxRQUhsRixVQUdrRkEsUUFIbEY7QUFBQSxZQUc0RkMsSUFINUYsVUFHNEZBLElBSDVGO0FBQUEsWUFHa0doUSxJQUhsRyxVQUdrR0EsSUFIbEc7QUFBQSxZQUcyRzRILE1BSDNHOztBQUlMLFlBQU1xSSx3QkFBZXBGLEtBQWYsQ0FBTjtBQUNBLFlBQU1xRixZQUFZLEVBQUN6SSxZQUFELEVBQVFvRSxPQUFPOEIsUUFBZixFQUF5Qi9CLGNBQXpCLEVBQWlDMkMsZ0JBQWpDLEVBQWxCO0FBQ0EsWUFBSXRMLFVBQVVrTSxJQUFkO0FBQ0EsWUFBSTNCLGdCQUFNbFIsY0FBTixDQUFxQjJHLE9BQXJCLENBQUosRUFBbUM7QUFDL0JBLHNCQUFVdUssZ0JBQU0yQyxZQUFOLENBQW1CbE4sT0FBbkIsRUFBNEJpTixTQUE1QixDQUFWO0FBQ0gsU0FGRCxNQUVPLElBQUksT0FBT2pOLE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDdENBLHNCQUFVQSxRQUFRd0UsS0FBUixFQUFla0csUUFBZixFQUF5Qi9CLE1BQXpCLEVBQWlDMkMsT0FBakMsQ0FBVjtBQUNIO0FBQ0QsWUFBSUUsS0FBSixFQUFXO0FBQ1B3QixxQkFBU0csU0FBVCxHQUFxQjNCLEtBQXJCO0FBQ0g7QUFDRCxZQUFNYyxNQUFNLHlEQUNKelAsTUFESSxtQkFDaUIsSUFEakIsY0FFUDJGLFNBRk8sSUFFS0EsU0FGTCxlQUFaOztBQUtBLGVBQVE7QUFBQyxlQUFEO0FBQUEseUJBQVNtQyxNQUFULElBQWlCLFdBQVcySCxHQUE1QixFQUFpQyxPQUFPVSxRQUF4QyxFQUFrRCxNQUFLLFVBQXZEO0FBQ0o7QUFBQTtBQUFBLGtCQUFLLFdBQWNuUSxNQUFkLHVCQUFMLEVBQStDLE9BQU82UCxVQUF0RDtBQUNLMU0sdUJBREw7QUFFSzVCO0FBRkw7QUFESSxTQUFSO0FBTUgsSzs7O0VBckU2Qm1NLGdCQUFNbE0sUyxVQUM3QkMsUyxHQUFZO0FBQ2Z6QixZQUFRMEIsb0JBQVVDLE1BREg7QUFFZnpCLFVBQU13QixvQkFBVUUsSUFGRDtBQUdmNEssZ0JBQVk5SyxvQkFBVUMsTUFIUDtBQUlmZ0UsZUFBV2pFLG9CQUFVQyxNQUpOO0FBS2ZtSyxZQUFRcEssb0JBQVVpTSxHQUxIO0FBTWZoRyxXQUFPakcsb0JBQVVpTSxHQU5GO0FBT2ZwSSxjQUFVN0Qsb0JBQVV1SixNQVBMO0FBUWY0QyxjQUFVbk0sb0JBQVV1SixNQVJMO0FBU2YyRSxXQUFPbE8sb0JBQVVpTSxHQVRGO0FBVWZpQixXQUFPbE4sb0JBQVU2TyxTQUFWLENBQW9CLENBQUM3TyxvQkFBVXVKLE1BQVgsRUFBbUJ2SixvQkFBVUMsTUFBN0IsQ0FBcEIsQ0FWUTtBQVdmOE0sYUFBUy9NLG9CQUFVaU0sR0FYSjtBQVlmMEIsVUFBTTNOLG9CQUFVNk8sU0FBVixDQUFvQixDQUFDN08sb0JBQVVHLE9BQVgsRUFBb0JILG9CQUFVOE8sSUFBOUIsRUFBb0M5TyxvQkFBVWhFLElBQTlDLENBQXBCLENBWlM7QUFhZmlSLFdBQU9qTixvQkFBVW9FLEtBQVYsQ0FBZ0IsQ0FBQyxNQUFELEVBQVMsUUFBVCxFQUFtQixPQUFuQixDQUFoQixDQWJRO0FBY2YwRSxlQUFXOUksb0JBQVVvRSxLQUFWLENBQWdCLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxLQUFiLENBQWhCLENBZEk7QUFlZnZFLGNBQVVHLG9CQUFVaU0sR0FmTDtBQWdCZjVDLFdBQU9ySixvQkFBVWpGLE1BaEJGO0FBaUJmb1QsZ0JBQVluTyxvQkFBVWpGLE1BakJQO0FBa0Jmc1QsZ0JBQVlyTyxvQkFBVW9FLEtBQVYsQ0FBZ0IsQ0FBQyxRQUFELEVBQVcsVUFBWCxDQUFoQixDQWxCRztBQW1CZmtLLGFBQVN0TyxvQkFBVWtNLEtBbkJKO0FBb0JmcUMsY0FBVXZPLG9CQUFVRSxJQXBCTDtBQXFCZnNPLFVBQU14TyxvQkFBVWlNLEdBckJEO0FBc0JmbEksVUFBTS9ELG9CQUFVb0UsS0FBVixDQUFnQixDQUFDLFFBQUQsRUFBVyxNQUFYLENBQWhCLENBdEJTO0FBdUJmNkosZUFBV2pPLG9CQUFVRSxJQXZCTjtBQXdCZmtPLGtCQUFjcE8sb0JBQVVFO0FBeEJULEMsU0EyQlpFLFksR0FBZTtBQUNsQjBJLGVBQVcsSUFETztBQUVsQi9FLFVBQU0sTUFGWTtBQUdsQjRKLFVBQU0sY0FBQzFILEtBQUQ7QUFBQSxlQUFXQSxLQUFYO0FBQUEsS0FIWTtBQUlsQjNILFlBQVE7QUFKVSxDO0FBNUJMK00sSTtrQkFBQUEsSTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMckI7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7SUFDcUIwRCxXOzs7Ozs7Ozs7MEJBYWpCeEksaUIsZ0NBQW9CO0FBQ2hCLGFBQUt3RyxPQUFMLENBQWFpQyxPQUFiLENBQXFCLFFBQXJCLEVBQStCLDJCQUFZLElBQVosQ0FBL0I7QUFDSCxLOzswQkFFRHRQLE0scUJBQVM7QUFBQSxxQkFDOEMsS0FBS3JCLEtBRG5EO0FBQUEsWUFDR0MsTUFESCxVQUNHQSxNQURIO0FBQUEsWUFDVzJGLFNBRFgsVUFDV0EsU0FEWDtBQUFBLFlBQ3NCd0csUUFEdEIsVUFDc0JBLFFBRHRCO0FBQUEsWUFDbUNyRSxNQURuQzs7QUFFTCxlQUFRO0FBQUE7QUFBQSxjQUFLLFdBQVduQyxTQUFoQjtBQUNKO0FBQUE7QUFBQSxrQkFBSyxXQUFjM0YsTUFBZCx1QkFBTDtBQUNJO0FBQUE7QUFBQTtBQUNLbU0sNEJBREw7QUFFSSxrREFBQyxnQkFBRCxlQUFxQnJFLE1BQXJCLElBQTZCLFFBQVE5SCxNQUFyQztBQUZKO0FBREo7QUFESSxTQUFSO0FBUUgsSzs7O0VBM0JvQzBOLGdCQUFNbE0sUyxVQUNwQ0MsUyxHQUFZO0FBQ2ZGLGNBQVVHLG9CQUFVaU0sR0FETDtBQUVmM04sWUFBUTBCLG9CQUFVQyxNQUZIO0FBR2ZnRSxlQUFXakUsb0JBQVVDLE1BSE47QUFJZndLLGNBQVV6SyxvQkFBVWlNO0FBSkwsQyxTQU9aK0IsWSxHQUFlO0FBQ2xCZ0IsYUFBU2hQLG9CQUFVaEUsSUFERDtBQUVsQjhRLGNBQVU5TSxvQkFBVW9FLEtBQVYsQ0FBZ0IsQ0FBQyxNQUFELEVBQVMsT0FBVCxDQUFoQjtBQUZRLEM7QUFSTDJLLFc7a0JBQUFBLFc7Ozs7Ozs7O0FDTnJCOzs7Ozs7O0FBT2E7O0FBRWIsSUFBSUUsdUJBQXVCLDhDQUEzQjs7QUFFQS9ULE9BQU9DLE9BQVAsR0FBaUI4VCxvQkFBakIsQzs7Ozs7Ozs7OztrQkNUd0JDLFE7O0FBRnhCOztBQUVlLFNBQVNBLFFBQVQsQ0FBa0JDLE1BQWxCLEVBQTBCQyxLQUExQixFQUFpQztBQUM1QyxRQUFJLENBQUNELE1BQUwsRUFBYTtBQUNULGVBQU8sSUFBUDtBQUNIOztBQUVELFFBQUksT0FBT0EsTUFBUCxLQUFrQixRQUF0QixFQUFnQztBQUM1QixlQUFPRSxTQUFTQyxjQUFULENBQXdCSCxNQUF4QixDQUFQO0FBQ0g7O0FBRUQsUUFBSSxPQUFPQSxNQUFQLEtBQWtCLFVBQXRCLEVBQWtDO0FBQzlCQSxpQkFBU0EsT0FBT0MsS0FBUCxDQUFUO0FBQ0g7O0FBRUQsUUFBSSxDQUFDRCxNQUFMLEVBQWE7QUFDVCxlQUFPLElBQVA7QUFDSDs7QUFFRCxRQUFJO0FBQ0EsZUFBTywyQkFBWUEsTUFBWixDQUFQO0FBQ0gsS0FGRCxDQUVFLE9BQU9JLEdBQVAsRUFBWTtBQUNWLGVBQU9KLE1BQVA7QUFDSDtBQUNKOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hCRDs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7OztJQUVROUksTyxHQUFZckssVSxDQUFacUssTztJQUNBekIsVSxHQUFlMUksUyxDQUFmMEksVTs7QUFFUjs7Ozs7SUFJcUI0SyxjOzs7QUFpQ2pCLDRCQUFZblIsS0FBWixFQUFtQjtBQUFBOztBQUFBLHFEQUNmLHNCQUFNQSxLQUFOLENBRGU7O0FBR2ZnSSx1QkFBYyxDQUFDLGVBQUQsRUFBa0IsYUFBbEIsQ0FBZDtBQUhlO0FBSWxCOzs2QkFFRG9KLFcsMEJBQWM7QUFBQSxxQkFDdUIsS0FBS3BSLEtBRDVCO0FBQUEsWUFDRjhJLElBREUsVUFDRkEsSUFERTtBQUFBLFlBQ0l6RyxJQURKLFVBQ0lBLElBREo7QUFBQSxZQUNVZ1AsUUFEVixVQUNVQSxRQURWO0FBQUEsWUFFRkMsVUFGRSxHQUVhalAsS0FBS3JDLEtBRmxCLENBRUZzUixVQUZFO0FBQUEsWUFHRkMsWUFIRSxHQUdlbFAsS0FBSzJHLEtBSHBCLENBR0Z1SSxZQUhFOztBQUlWLGVBQU9GLFlBQWEsQ0FBQyxDQUFDQyxVQUFGLElBQWdCQyxhQUFhdk0sT0FBYixDQUFxQjhELElBQXJCLElBQTZCLENBQUMsQ0FBbEU7QUFDSCxLOzs2QkFFRDBJLFkseUJBQWFyUSxDLEVBQUc7QUFBQSxzQkFDcUIsS0FBS25CLEtBRDFCO0FBQUEsWUFDSjhJLElBREksV0FDSkEsSUFESTtBQUFBLFlBQ0V6RyxJQURGLFdBQ0VBLElBREY7QUFBQSxZQUNRb1AsUUFEUixXQUNRQSxRQURSOztBQUVaLFlBQUlBLFFBQUosRUFBYztBQUNWQSxxQkFBUyxDQUFDLEtBQUtMLFdBQUwsRUFBVixFQUE4QixJQUE5QixFQUFvQ2pRLENBQXBDO0FBQ0gsU0FGRCxNQUVPO0FBQ0hrQixpQkFBS21QLFlBQUwsQ0FBa0IxSSxJQUFsQixFQUF3QixDQUFDLEtBQUtzSSxXQUFMLEVBQXpCLEVBQTZDLElBQTdDO0FBQ0g7QUFDSixLOzs2QkFFRHJILGEsMEJBQWM1SSxDLEVBQUc7QUFDYixZQUFJQSxFQUFFdVEsT0FBRixLQUFjdlQsY0FBUXdULEtBQTFCLEVBQWlDO0FBQzdCLGlCQUFLSCxZQUFMLENBQWtCclEsQ0FBbEI7QUFDSDs7QUFFRCxhQUFLbkIsS0FBTCxDQUFXaUssU0FBWCxJQUF3QixLQUFLakssS0FBTCxDQUFXaUssU0FBWCxDQUFxQjlJLENBQXJCLENBQXhCO0FBQ0gsSzs7NkJBRUR1SSxXLHdCQUFZdkksQyxFQUFHO0FBQ1gsYUFBS3FRLFlBQUwsQ0FBa0JyUSxDQUFsQjs7QUFFQSxhQUFLbkIsS0FBTCxDQUFXNkosT0FBWCxJQUFzQixLQUFLN0osS0FBTCxDQUFXNkosT0FBWCxDQUFtQjFJLENBQW5CLENBQXRCO0FBQ0gsSzs7NkJBRUR5USxrQiwrQkFBbUJQLFEsRUFBVTtBQUFBLHNCQUNtQyxLQUFLclIsS0FEeEM7QUFBQSxZQUNqQnFDLElBRGlCLFdBQ2pCQSxJQURpQjtBQUFBLFlBQ1hzSSxZQURXLFdBQ1hBLFlBRFc7QUFBQSxZQUNHRCxVQURILFdBQ0dBLFVBREg7QUFBQSxZQUNlbUgsZUFEZixXQUNlQSxlQURmO0FBQUEsMEJBRTZCeFAsS0FBS3JDLEtBRmxDO0FBQUEsWUFFakJDLE1BRmlCLGVBRWpCQSxNQUZpQjtBQUFBLFlBRVE2UixnQkFGUixlQUVURCxlQUZTOzs7QUFJekIsZUFDSSxDQUFDLHFCQUFxQixLQUFLN1IsS0FBMUIsR0FBa0M2UixlQUFsQyxHQUFvREMsZ0JBQXJELEtBQTBFVCxRQUExRSxHQUNJLDhCQUFDLGNBQUQsSUFBTSxPQUFPM0csY0FBY0MsZUFBZSxDQUE3QixHQUFpQyxFQUFFb0gsTUFBU3BILFlBQVQsT0FBRixFQUFqQyxHQUFpRSxJQUE5RSxFQUFvRixXQUFjMUssTUFBZCx1QkFBcEYsRUFBOEgsTUFBSyxRQUFuSSxHQURKLEdBRUksSUFIUjtBQUtILEs7OzZCQUVEb0IsTSxxQkFBUztBQUFBOztBQUFBLHNCQUNxRSxLQUFLckIsS0FEMUU7QUFBQSxZQUNHOEksSUFESCxXQUNHQSxJQURIO0FBQUEsWUFDU3pHLElBRFQsV0FDU0EsSUFEVDtBQUFBLFlBQ2V1RCxTQURmLFdBQ2VBLFNBRGY7QUFBQSxZQUMwQmdELFFBRDFCLFdBQzBCQSxRQUQxQjtBQUFBLFlBQ29Db0osTUFEcEMsV0FDb0NBLE1BRHBDO0FBQUEsWUFDNEN4USxRQUQ1QyxXQUM0Q0EsUUFENUM7QUFBQSxZQUNzRGtKLFVBRHRELFdBQ3NEQSxVQUR0RDtBQUFBLFlBRUd6SyxNQUZILEdBRWNvQyxLQUFLckMsS0FGbkIsQ0FFR0MsTUFGSDs7QUFHTCxZQUFNOEgsU0FBU3hCLFdBQVcxQixPQUFPQyxJQUFQLENBQVlxTSxlQUFlelAsU0FBM0IsQ0FBWCxFQUFrRCxLQUFLMUIsS0FBdkQsQ0FBZjtBQUNBLFlBQU1xUixXQUFXLEtBQUtELFdBQUwsRUFBakI7O0FBRUEsWUFBTWE7QUFDRm5KLHNCQURFO0FBRUZ6RyxzQkFGRTtBQUdGdUcsOEJBSEU7QUFJRmxELGtCQUFNLE1BSko7QUFLRkUsdUJBQVcseUNBQ0gzRixNQURHLGlCQUNnQm9SLFFBRGhCLE1BRU56TCxTQUZNLElBRU0sQ0FBQyxDQUFDQSxTQUZSLE9BTFQ7QUFTRnFFLHVCQUFXLEtBQUtGLGFBVGQ7QUFVRkYscUJBQVMsQ0FBQ2pCLFFBQUQsR0FBWSxLQUFLYyxXQUFqQixHQUErQixLQUFLMUosS0FBTCxDQUFXNkosT0FWakQ7QUFXRmEsa0NBWEU7QUFZRiw2QkFBaUIyRztBQVpmLFdBYUN0SixNQWJELENBQU47O0FBZ0JBLGVBQ0k7QUFBQywwQkFBRDtBQUFVa0ssb0JBQVY7QUFDSyxpQkFBS0wsa0JBQUwsQ0FBd0JQLFFBQXhCLENBREw7QUFFSTtBQUFBO0FBQUEsa0JBQU0sV0FBY3BSLE1BQWQsbUJBQU47QUFBNkN1QjtBQUE3QyxhQUZKO0FBR0t3USxxQkFBUztBQUFBO0FBQUEsa0JBQUssV0FBYy9SLE1BQWQscUJBQUw7QUFBOEMrUjtBQUE5QyxhQUFULEdBQXVFO0FBSDVFLFNBREo7QUFPSCxLOzs7RUE3R3VDdlEsZ0IsVUFDakN5USxhLEdBQWdCLE0sU0FFaEJ4USxTLEdBQVk7QUFDZm9ILFVBQU1uSCxvQkFBVUMsTUFERDtBQUVmUyxVQUFNVixvQkFBVWpGLE1BRkQ7QUFHZjJVLGNBQVUxUCxvQkFBVUUsSUFITDtBQUlmNFAsY0FBVTlQLG9CQUFVaEUsSUFKTDtBQUtmZ04sa0JBQWNoSixvQkFBVXVKLE1BTFQ7QUFNZjs7O0FBR0F0QyxjQUFVakgsb0JBQVVFLElBVEw7QUFVZjs7O0FBR0FtUSxZQUFRclEsb0JBQVU4TyxJQWJIO0FBY2Y7OztBQUdBalAsY0FBVUcsb0JBQVU4TyxJQWpCTDtBQWtCZjdLLGVBQVdqRSxvQkFBVUMsTUFsQk47QUFtQmZxSSxlQUFXdEksb0JBQVVoRSxJQW5CTjtBQW9CZmtNLGFBQVNsSSxvQkFBVWhFLElBcEJKO0FBcUJmK00sZ0JBQVkvSSxvQkFBVUUsSUFyQlA7QUFzQmZnUSxxQkFBaUJsUSxvQkFBVUU7QUF0QlosQyxTQXlCWkUsWSxHQUFlO0FBQ2xCNkcsY0FBVSxLQURRO0FBRWxCOEIsZ0JBQVk7QUFGTSxDO0FBNUJMeUcsYztrQkFBQUEsYzs7Ozs7Ozs7Ozs7Ozs7O0FDZHJCOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7SUFJcUJnQixNOzs7Ozs7Ozs7bUJBK0RqQjlRLE0scUJBQVM7QUFDTCxXQUFPLElBQVA7QUFDSCxHOzs7RUFqRStCc00sZ0JBQU1sTSxTLFVBRS9CQyxTLEdBQVk7QUFDZjs7O0FBR0FpTixhQUFXaE4sb0JBQVVDLE1BSk47QUFLZjs7Ozs7QUFLQTBOLFFBQU0zTixvQkFBVTZPLFNBQVYsQ0FBb0IsQ0FBQzdPLG9CQUFVRyxPQUFYLEVBQW9CSCxvQkFBVThPLElBQTlCLEVBQW9DOU8sb0JBQVVoRSxJQUE5QyxDQUFwQixDQVZTO0FBV2Y7Ozs7QUFJQWtTLFNBQU9sTyxvQkFBVTZPLFNBQVYsQ0FBb0IsQ0FBQzdPLG9CQUFVRyxPQUFYLEVBQW9CSCxvQkFBVThPLElBQTlCLEVBQW9DOU8sb0JBQVVoRSxJQUE5QyxDQUFwQixDQWZRO0FBZ0JmOzs7QUFHQXVTLFlBQVV2TyxvQkFBVUUsSUFuQkw7QUFvQmY7OztBQUdBZ04sU0FBT2xOLG9CQUFVNk8sU0FBVixDQUFvQixDQUFDN08sb0JBQVV1SixNQUFYLEVBQW1Cdkosb0JBQVVDLE1BQTdCLENBQXBCLENBdkJRO0FBd0JmOzs7QUFHQWdOLFNBQU9qTixvQkFBVW9FLEtBQVYsQ0FBZ0IsQ0FBQyxNQUFELEVBQVMsUUFBVCxFQUFtQixPQUFuQixDQUFoQixDQTNCUTtBQTRCZjs7O0FBR0FrSyxXQUFTdE8sb0JBQVV5USxPQUFWLENBQWtCelEsb0JBQVUwUSxLQUFWLENBQWdCO0FBQ3ZDQyxXQUFPM1Esb0JBQVVDLE1BRHNCO0FBRXZDZ0csV0FBT2pHLG9CQUFVNk8sU0FBVixDQUFvQixDQUFDN08sb0JBQVU4TyxJQUFYLEVBQWlCOU8sb0JBQVVDLE1BQTNCLENBQXBCO0FBRmdDLEdBQWhCLENBQWxCLENBL0JNO0FBbUNmOzs7QUFHQW9PLGNBQVlyTyxvQkFBVW9FLEtBQVYsQ0FBZ0IsQ0FBQyxRQUFELEVBQVcsVUFBWCxDQUFoQixDQXRDRztBQXVDZjs7O0FBR0FvSyxRQUFNeE8sb0JBQVU2TyxTQUFWLENBQW9CLENBQUM3TyxvQkFBVUUsSUFBWCxFQUFpQkYsb0JBQVVDLE1BQTNCLENBQXBCLENBMUNTO0FBMkNmOzs7QUFHQWdPLGFBQVdqTyxvQkFBVUU7QUE5Q04sQyxTQWlEWjhOLFksR0FBZTtBQUNsQnhFLFVBQVF4SixvQkFBVWlNO0FBREEsQyxTQUlmN0wsWSxHQUFlO0FBQ2xCdU4sUUFBTSxjQUFDMUgsS0FBRDtBQUFBLFdBQVdBLEtBQVg7QUFBQSxHQURZO0FBRWxCb0ksY0FBWSxVQUZNO0FBR2xCSixhQUFXO0FBSE8sQyxTQU1mNUosUyxHQUFZLFE7QUE3REZtTSxNO2tCQUFBQSxNOzs7Ozs7Ozs7Ozs7Ozs7QUNQckI7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFQTtJQUNxQkksWTs7Ozs7Ozs7OzJCQU9qQmxSLE0scUJBQVM7QUFBQSxxQkFDd0MsS0FBS3JCLEtBRDdDO0FBQUEsWUFDR3dCLFFBREgsVUFDR0EsUUFESDtBQUFBLFlBQ2FnUixjQURiLFVBQ2FBLGNBRGI7QUFBQSxZQUM2QnZTLE1BRDdCLFVBQzZCQSxNQUQ3Qjs7QUFFTCxlQUFRO0FBQUE7QUFBQSxjQUFLLFdBQWNBLE1BQWQsZ0JBQUw7QUFDSHVCLG9CQURHO0FBRUhnUjtBQUZHLFNBQVI7QUFJSCxLOzs7RUFicUM3RSxnQkFBTWxNLFMsVUFDckNDLFMsR0FBWTtBQUNmRixjQUFVRyxvQkFBVWlNLEdBREw7QUFFZjNOLFlBQVEwQixvQkFBVUMsTUFGSDtBQUdmd0ssY0FBVXpLLG9CQUFVaU0sR0FITDtBQUlmNEUsb0JBQWdCN1Esb0JBQVVpTTtBQUpYLEM7QUFERjJFLFk7a0JBQUFBLFk7Ozs7Ozs7QUNKckIsMkJBQTJCLG1CQUFPLENBQUMsQ0FBbUU7QUFDdEc7OztBQUdBO0FBQ0EsY0FBYyxRQUFTLHNCQUFzQixpTEFBaUwsK0JBQStCLFFBQVEsK0NBQStDLCtCQUErQixRQUFRLHdDQUF3Qyx1Q0FBdUMsdUNBQXVDLEVBQUUsZ0JBQWdCLDBCQUEwQixvRUFBb0UsNlZBQTZWLEVBQUUsZ0JBQWdCLDBCQUEwQiwwQkFBMEIsdUJBQXVCLHdCQUF3Qix5QkFBeUIsd0NBQXdDLHVDQUF1QyxFQUFFLHVCQUF1Qiw0QkFBNEIsNkJBQTZCLHlCQUF5QixFQUFFLDZCQUE2QiwwQkFBMEIsRUFBRSwyQkFBMkIsMEJBQTBCLEVBQUUsK0JBQStCLDBCQUEwQixFQUFFLCtCQUErQiwwQkFBMEIsRUFBRSw4QkFBOEIsMEJBQTBCLEVBQUUsNkJBQTZCLDBCQUEwQixFQUFFLDRCQUE0QiwwQkFBMEIsRUFBRSw2QkFBNkIsMEJBQTBCLEVBQUUsdUNBQXVDLDBCQUEwQixFQUFFLHNDQUFzQywwQkFBMEIsRUFBRSx5Q0FBeUMsMEJBQTBCLEVBQUUsMkJBQTJCLDBCQUEwQixFQUFFLDZCQUE2QiwwQkFBMEIsRUFBRSxnQ0FBZ0MsMEJBQTBCLEVBQUUsa0NBQWtDLDBCQUEwQixFQUFFLGtDQUFrQywwQkFBMEIsRUFBRSxtQ0FBbUMsMEJBQTBCLEVBQUUseUNBQXlDLDBCQUEwQixFQUFFLDBDQUEwQywwQkFBMEIsRUFBRSw4QkFBOEIsMEJBQTBCLEVBQUUsK0JBQStCLDBCQUEwQixFQUFFLGtDQUFrQywwQkFBMEIsRUFBRSxpQ0FBaUMsMEJBQTBCLEVBQUUsOEJBQThCLDBCQUEwQixFQUFFLG1DQUFtQywwQkFBMEIsRUFBRSw4QkFBOEIsMEJBQTBCLEVBQUUsNkJBQTZCLDBCQUEwQixFQUFFLGdDQUFnQywwQkFBMEIsRUFBRSwrQkFBK0IsMEJBQTBCLEVBQUUsZ0NBQWdDLDBCQUEwQixFQUFFLDhCQUE4QiwwQkFBMEIsRUFBRSw4QkFBOEIsMEJBQTBCLEVBQUUsZ0NBQWdDLDBCQUEwQixFQUFFLDJCQUEyQiwwQkFBMEIsRUFBRSw0QkFBNEIsMEJBQTBCLEVBQUUsK0JBQStCLDBCQUEwQixFQUFFLDhCQUE4QiwwQkFBMEIsRUFBRSxrQ0FBa0MsMEJBQTBCLEVBQUUsK0JBQStCLDBCQUEwQixFQUFFLDZCQUE2QiwwQkFBMEIsRUFBRSwyQkFBMkIsMEJBQTBCLEVBQUUsK0JBQStCLDBCQUEwQiwwREFBMEQsMERBQTBELEVBQUUsc0NBQXNDLFFBQVEsd0NBQXdDLHdDQUF3QyxzQ0FBc0Msc0NBQXNDLEVBQUUsVUFBVSx3Q0FBd0Msd0NBQXdDLHdDQUF3Qyx3Q0FBd0MsRUFBRSxFQUFFLDhCQUE4QixRQUFRLHdDQUF3Qyx3Q0FBd0Msc0NBQXNDLHNDQUFzQyxFQUFFLFVBQVUsd0NBQXdDLHdDQUF3Qyx3Q0FBd0Msd0NBQXdDLEVBQUUsRUFBRSxnQ0FBZ0MsZUFBZSxtQkFBbUIseUJBQXlCLEVBQUUsd0ZBQXdGLHlCQUF5QixvQ0FBb0Msb0NBQW9DLG9DQUFvQyx3QkFBd0IseUJBQXlCLEVBQUUsa0NBQWtDLG9CQUFvQix3QkFBd0IsRUFBRSxFQUFFLCtCQUErQixnQkFBZ0Isb0JBQW9CLHlCQUF5QixFQUFFLGtDQUFrQyxnQkFBZ0Isb0JBQW9CLHlCQUF5QixFQUFFLG1DQUFtQyxnQkFBZ0Isb0JBQW9CLHlCQUF5QixFQUFFLGtDQUFrQyxnQkFBZ0Isb0JBQW9CLHlCQUF5QixFQUFFLCtCQUErQixnQkFBZ0Isb0JBQW9CLHlCQUF5QixFQUFFLGdDQUFnQyxnQkFBZ0Isb0JBQW9CLHlCQUF5QixFQUFFLGlDQUFpQyxnQkFBZ0Isb0JBQW9CLHlCQUF5QixFQUFFOztBQUVubkw7Ozs7Ozs7QUNQQSwyQkFBMkIsbUJBQU8sQ0FBQyxDQUFtRTtBQUN0Rzs7O0FBR0E7QUFDQSxjQUFjLFFBQVMsOEJBQThCLFFBQVEsaUJBQWlCLEVBQUUsVUFBVSxpQkFBaUIsRUFBRSxFQUFFLHVCQUF1QixRQUFRLGlCQUFpQixFQUFFLFVBQVUsaUJBQWlCLEVBQUUsRUFBRSxtQ0FBbUMsUUFBUSxpQkFBaUIsNENBQTRDLHdDQUF3QyxvQ0FBb0MsRUFBRSxVQUFVLGlCQUFpQix1Q0FBdUMsbUNBQW1DLCtCQUErQixFQUFFLEVBQUUsMkJBQTJCLFFBQVEsaUJBQWlCLDRDQUE0Qyx3Q0FBd0Msb0NBQW9DLEVBQUUsVUFBVSxpQkFBaUIsdUNBQXVDLG1DQUFtQywrQkFBK0IsRUFBRSxFQUFFLG1DQUFtQyxRQUFRLGlCQUFpQiwyQ0FBMkMsdUNBQXVDLG1DQUFtQyxFQUFFLFVBQVUsaUJBQWlCLHVDQUF1QyxtQ0FBbUMsK0JBQStCLEVBQUUsRUFBRSwyQkFBMkIsUUFBUSxpQkFBaUIsMkNBQTJDLHVDQUF1QyxtQ0FBbUMsRUFBRSxVQUFVLGlCQUFpQix1Q0FBdUMsbUNBQW1DLCtCQUErQixFQUFFLEVBQUUsb0NBQW9DLFFBQVEsaUJBQWlCLDBDQUEwQyxzQ0FBc0Msa0NBQWtDLEVBQUUsVUFBVSxpQkFBaUIsdUNBQXVDLG1DQUFtQywrQkFBK0IsRUFBRSxFQUFFLDRCQUE0QixRQUFRLGlCQUFpQiwwQ0FBMEMsc0NBQXNDLGtDQUFrQyxFQUFFLFVBQVUsaUJBQWlCLHVDQUF1QyxtQ0FBbUMsK0JBQStCLEVBQUUsRUFBRSxpQ0FBaUMsUUFBUSxpQkFBaUIsMENBQTBDLHNDQUFzQyxrQ0FBa0MsRUFBRSxVQUFVLGlCQUFpQix1Q0FBdUMsbUNBQW1DLCtCQUErQixFQUFFLEVBQUUseUJBQXlCLFFBQVEsaUJBQWlCLDBDQUEwQyxzQ0FBc0Msa0NBQWtDLEVBQUUsVUFBVSxpQkFBaUIsdUNBQXVDLG1DQUFtQywrQkFBK0IsRUFBRSxFQUFFLGdDQUFnQyxRQUFRLGlCQUFpQixFQUFFLFVBQVUsaUJBQWlCLEVBQUUsRUFBRSx3QkFBd0IsUUFBUSxpQkFBaUIsRUFBRSxVQUFVLGlCQUFpQixFQUFFLEVBQUUsb0NBQW9DLFFBQVEsaUJBQWlCLHVDQUF1QyxtQ0FBbUMsK0JBQStCLEVBQUUsVUFBVSxpQkFBaUIsMENBQTBDLHNDQUFzQyxrQ0FBa0MsRUFBRSxFQUFFLDRCQUE0QixRQUFRLGlCQUFpQix1Q0FBdUMsbUNBQW1DLCtCQUErQixFQUFFLFVBQVUsaUJBQWlCLDBDQUEwQyxzQ0FBc0Msa0NBQWtDLEVBQUUsRUFBRSxvQ0FBb0MsUUFBUSxpQkFBaUIsdUNBQXVDLG1DQUFtQywrQkFBK0IsRUFBRSxVQUFVLGlCQUFpQiwyQ0FBMkMsdUNBQXVDLG1DQUFtQyxFQUFFLEVBQUUsNEJBQTRCLFFBQVEsaUJBQWlCLHVDQUF1QyxtQ0FBbUMsK0JBQStCLEVBQUUsVUFBVSxpQkFBaUIsMkNBQTJDLHVDQUF1QyxtQ0FBbUMsRUFBRSxFQUFFLHFDQUFxQyxRQUFRLGlCQUFpQix1Q0FBdUMsbUNBQW1DLCtCQUErQixFQUFFLFVBQVUsaUJBQWlCLDBDQUEwQyxzQ0FBc0Msa0NBQWtDLEVBQUUsRUFBRSw2QkFBNkIsUUFBUSxpQkFBaUIsdUNBQXVDLG1DQUFtQywrQkFBK0IsRUFBRSxVQUFVLGlCQUFpQiwwQ0FBMEMsc0NBQXNDLGtDQUFrQyxFQUFFLEVBQUUsa0NBQWtDLFFBQVEsaUJBQWlCLHVDQUF1QyxtQ0FBbUMsK0JBQStCLEVBQUUsVUFBVSxpQkFBaUIsNENBQTRDLHdDQUF3QyxvQ0FBb0MsRUFBRSxFQUFFLDBCQUEwQixRQUFRLGlCQUFpQix1Q0FBdUMsbUNBQW1DLCtCQUErQixFQUFFLFVBQVUsaUJBQWlCLDRDQUE0Qyx3Q0FBd0Msb0NBQW9DLEVBQUUsRUFBRSwrQkFBK0IsUUFBUSxpQkFBaUIsZ0RBQWdELDRDQUE0Qyx3Q0FBd0MsRUFBRSxTQUFTLGlCQUFpQixFQUFFLEVBQUUsdUJBQXVCLFFBQVEsaUJBQWlCLGdEQUFnRCw0Q0FBNEMsd0NBQXdDLEVBQUUsU0FBUyxpQkFBaUIsRUFBRSxFQUFFLGdDQUFnQyxRQUFRLGlCQUFpQixFQUFFLFNBQVMsaUJBQWlCLGdEQUFnRCw0Q0FBNEMsd0NBQXdDLEVBQUUsVUFBVSxpQkFBaUIsRUFBRSxFQUFFLHdCQUF3QixRQUFRLGlCQUFpQixFQUFFLFNBQVMsaUJBQWlCLGdEQUFnRCw0Q0FBNEMsd0NBQXdDLEVBQUUsVUFBVSxpQkFBaUIsRUFBRSxFQUFFLHFDQUFxQyxRQUFRLGlCQUFpQixxQ0FBcUMsaUNBQWlDLDZCQUE2QiwyQ0FBMkMsdUNBQXVDLG1DQUFtQyxFQUFFLFVBQVUsaUJBQWlCLG1DQUFtQywrQkFBK0IsMkJBQTJCLDJDQUEyQyx1Q0FBdUMsbUNBQW1DLEVBQUUsRUFBRSw2QkFBNkIsUUFBUSxpQkFBaUIscUNBQXFDLGlDQUFpQyw2QkFBNkIsMkNBQTJDLHVDQUF1QyxtQ0FBbUMsRUFBRSxVQUFVLGlCQUFpQixtQ0FBbUMsK0JBQStCLDJCQUEyQiwyQ0FBMkMsdUNBQXVDLG1DQUFtQyxFQUFFLEVBQUUsbUNBQW1DLFFBQVEsaUJBQWlCLHFDQUFxQyxpQ0FBaUMsNkJBQTZCLDhDQUE4QywwQ0FBMEMsc0NBQXNDLEVBQUUsVUFBVSxpQkFBaUIsbUNBQW1DLCtCQUErQiwyQkFBMkIsOENBQThDLDBDQUEwQyxzQ0FBc0MsRUFBRSxFQUFFLDJCQUEyQixRQUFRLGlCQUFpQixxQ0FBcUMsaUNBQWlDLDZCQUE2Qiw4Q0FBOEMsMENBQTBDLHNDQUFzQyxFQUFFLFVBQVUsaUJBQWlCLG1DQUFtQywrQkFBK0IsMkJBQTJCLDhDQUE4QywwQ0FBMEMsc0NBQXNDLEVBQUUsRUFBRSx5Q0FBeUMsUUFBUSxpQkFBaUIsRUFBRSxTQUFTLGtCQUFrQixFQUFFLFNBQVMsa0JBQWtCLEVBQUUsVUFBVSxpQkFBaUIsRUFBRSxFQUFFLGlDQUFpQyxRQUFRLGlCQUFpQixFQUFFLFNBQVMsa0JBQWtCLEVBQUUsU0FBUyxrQkFBa0IsRUFBRSxVQUFVLGlCQUFpQixFQUFFLEVBQUUsb0NBQW9DLFFBQVEsaUJBQWlCLG1DQUFtQywrQkFBK0IsMkJBQTJCLDJDQUEyQyx1Q0FBdUMsbUNBQW1DLEVBQUUsVUFBVSxpQkFBaUIscUNBQXFDLGlDQUFpQyw2QkFBNkIsMkNBQTJDLHVDQUF1QyxtQ0FBbUMsRUFBRSxFQUFFLDRCQUE0QixRQUFRLGlCQUFpQixtQ0FBbUMsK0JBQStCLDJCQUEyQiwyQ0FBMkMsdUNBQXVDLG1DQUFtQyxFQUFFLFVBQVUsaUJBQWlCLHFDQUFxQyxpQ0FBaUMsNkJBQTZCLDJDQUEyQyx1Q0FBdUMsbUNBQW1DLEVBQUUsRUFBRSxzQ0FBc0MsUUFBUSxpQkFBaUIsbUNBQW1DLCtCQUErQiwyQkFBMkIsOENBQThDLDBDQUEwQyxzQ0FBc0MsRUFBRSxVQUFVLGlCQUFpQixxQ0FBcUMsaUNBQWlDLDZCQUE2Qiw4Q0FBOEMsMENBQTBDLHNDQUFzQyxFQUFFLEVBQUUsOEJBQThCLFFBQVEsaUJBQWlCLG1DQUFtQywrQkFBK0IsMkJBQTJCLDhDQUE4QywwQ0FBMEMsc0NBQXNDLEVBQUUsVUFBVSxpQkFBaUIscUNBQXFDLGlDQUFpQyw2QkFBNkIsOENBQThDLDBDQUEwQyxzQ0FBc0MsRUFBRSxFQUFFLDBDQUEwQyxRQUFRLGlCQUFpQixFQUFFLFNBQVMsaUJBQWlCLEVBQUUsVUFBVSxpQkFBaUIsRUFBRSxFQUFFLGtDQUFrQyxRQUFRLGlCQUFpQixFQUFFLFNBQVMsaUJBQWlCLEVBQUUsVUFBVSxpQkFBaUIsRUFBRSxFQUFFLDhCQUE4QixVQUFVLGtDQUFrQyw4QkFBOEIsMEJBQTBCLEVBQUUsU0FBUyxvQ0FBb0MsZ0NBQWdDLDRCQUE0QixFQUFFLFFBQVEsa0NBQWtDLDhCQUE4QiwwQkFBMEIsRUFBRSxFQUFFLHNCQUFzQixVQUFVLGtDQUFrQyw4QkFBOEIsMEJBQTBCLEVBQUUsU0FBUyxvQ0FBb0MsZ0NBQWdDLDRCQUE0QixFQUFFLFFBQVEsa0NBQWtDLDhCQUE4QiwwQkFBMEIsRUFBRSxFQUFFLGFBQWEsbUNBQW1DLDJCQUEyQix5Q0FBeUMsaUNBQWlDLHFDQUFxQyw2QkFBNkIsZ0NBQWdDLHdCQUF3QixzRUFBc0UsOERBQThELHNDQUFzQyw4QkFBOEIsd0NBQXdDLGdDQUFnQyxFQUFFLGlCQUFpQix1Q0FBdUMsK0JBQStCLHlDQUF5QyxpQ0FBaUMscUNBQXFDLDZCQUE2QixnQ0FBZ0Msd0JBQXdCLHNFQUFzRSw4REFBOEQsc0NBQXNDLDhCQUE4Qix3Q0FBd0MsZ0NBQWdDLEVBQUUsaUJBQWlCLHVDQUF1QywrQkFBK0IseUNBQXlDLGlDQUFpQyxxQ0FBcUMsNkJBQTZCLGdDQUFnQyx3QkFBd0Isc0VBQXNFLDhEQUE4RCxzQ0FBc0MsOEJBQThCLHdDQUF3QyxnQ0FBZ0MsRUFBRSxrQkFBa0Isd0NBQXdDLGdDQUFnQyx5Q0FBeUMsaUNBQWlDLHFDQUFxQyw2QkFBNkIsZ0NBQWdDLHdCQUF3QixzRUFBc0UsOERBQThELHNDQUFzQyw4QkFBOEIsd0NBQXdDLGdDQUFnQyxFQUFFLGVBQWUscUNBQXFDLDZCQUE2Qix5Q0FBeUMsaUNBQWlDLHFDQUFxQyw2QkFBNkIsZ0NBQWdDLHdCQUF3QixzRUFBc0UsOERBQThELHNDQUFzQyw4QkFBOEIsd0NBQXdDLGdDQUFnQyxFQUFFLGNBQWMsb0NBQW9DLDRCQUE0Qix5Q0FBeUMsaUNBQWlDLHFDQUFxQyw2QkFBNkIsZ0NBQWdDLHdCQUF3Qiw4RUFBOEUsc0VBQXNFLHNDQUFzQyw4QkFBOEIsd0NBQXdDLGdDQUFnQyxFQUFFLGtCQUFrQix3Q0FBd0MsZ0NBQWdDLHlDQUF5QyxpQ0FBaUMscUNBQXFDLDZCQUE2QixnQ0FBZ0Msd0JBQXdCLDhFQUE4RSxzRUFBc0Usc0NBQXNDLDhCQUE4Qix3Q0FBd0MsZ0NBQWdDLEVBQUUsa0JBQWtCLHdDQUF3QyxnQ0FBZ0MseUNBQXlDLGlDQUFpQyxxQ0FBcUMsNkJBQTZCLGdDQUFnQyx3QkFBd0IsOEVBQThFLHNFQUFzRSxzQ0FBc0MsOEJBQThCLHdDQUF3QyxnQ0FBZ0MsRUFBRSxtQkFBbUIseUNBQXlDLGlDQUFpQyx5Q0FBeUMsaUNBQWlDLHFDQUFxQyw2QkFBNkIsZ0NBQWdDLHdCQUF3Qiw4RUFBOEUsc0VBQXNFLHNDQUFzQyw4QkFBOEIsd0NBQXdDLGdDQUFnQyxFQUFFLGdCQUFnQixzQ0FBc0MsOEJBQThCLHlDQUF5QyxpQ0FBaUMscUNBQXFDLDZCQUE2QixnQ0FBZ0Msd0JBQXdCLDhFQUE4RSxzRUFBc0Usc0NBQXNDLDhCQUE4Qix3Q0FBd0MsZ0NBQWdDLEVBQUUsYUFBYSxtQ0FBbUMsMkJBQTJCLHlDQUF5QyxpQ0FBaUMscUNBQXFDLDZCQUE2QixnQ0FBZ0Msd0JBQXdCLHNFQUFzRSw4REFBOEQsc0NBQXNDLDhCQUE4Qix3Q0FBd0MsZ0NBQWdDLEVBQUUsY0FBYyxvQ0FBb0MsNEJBQTRCLHlDQUF5QyxpQ0FBaUMscUNBQXFDLDZCQUE2QixnQ0FBZ0Msd0JBQXdCLDhFQUE4RSxzRUFBc0Usc0NBQXNDLDhCQUE4Qix3Q0FBd0MsZ0NBQWdDLEVBQUUsbUJBQW1CLHlDQUF5QyxpQ0FBaUMseUNBQXlDLGlDQUFpQyxxQ0FBcUMsNkJBQTZCLGdDQUFnQyx3QkFBd0Isc0VBQXNFLDhEQUE4RCxzQ0FBc0MsOEJBQThCLHdDQUF3QyxnQ0FBZ0MsRUFBRSxrQkFBa0Isd0NBQXdDLGdDQUFnQyx5Q0FBeUMsaUNBQWlDLHNDQUFzQyw4QkFBOEIsZ0NBQWdDLHdCQUF3QixzRUFBc0UsOERBQThELHNDQUFzQyw4QkFBOEIsd0NBQXdDLGdDQUFnQyxFQUFFLGlCQUFpQix1Q0FBdUMsK0JBQStCLHlDQUF5QyxpQ0FBaUMscUNBQXFDLDZCQUE2QixnQ0FBZ0Msd0JBQXdCLHNFQUFzRSw4REFBOEQsc0NBQXNDLDhCQUE4Qix3Q0FBd0MsZ0NBQWdDLEVBQUUsb0JBQW9CLDBDQUEwQyxrQ0FBa0MseUNBQXlDLGlDQUFpQyxzQ0FBc0MsOEJBQThCLGdDQUFnQyx3QkFBd0Isc0VBQXNFLDhEQUE4RCxzQ0FBc0MsOEJBQThCLHdDQUF3QyxnQ0FBZ0MsRUFBRSxZQUFZLGtDQUFrQywwQkFBMEIseUNBQXlDLGlDQUFpQyxxQ0FBcUMsNkJBQTZCLGdDQUFnQyx3QkFBd0Isc0VBQXNFLDhEQUE4RCxzQ0FBc0MsOEJBQThCLHdDQUF3QyxnQ0FBZ0MsRUFBRSxtQkFBbUIscUJBQXFCLEVBQUUsMEJBQTBCLHlDQUF5QyxpQ0FBaUMsRUFBRSw4QkFBOEIsK0NBQStDLHVDQUF1QywyQ0FBMkMsbUNBQW1DLHVDQUF1QywrQkFBK0Isa0NBQWtDLDBCQUEwQix3RUFBd0UsZ0VBQWdFLGdEQUFnRCx3Q0FBd0MsMENBQTBDLGtDQUFrQyxFQUFFLG1CQUFtQixxQkFBcUIsRUFBRSwwQkFBMEIseUNBQXlDLGlDQUFpQyxFQUFFLDhCQUE4QixnREFBZ0Qsd0NBQXdDLDJDQUEyQyxtQ0FBbUMsdUNBQXVDLCtCQUErQixrQ0FBa0MsMEJBQTBCLHdFQUF3RSxnRUFBZ0UsZ0RBQWdELHdDQUF3QywwQ0FBMEMsa0NBQWtDLEVBQUU7O0FBRTl1c0I7Ozs7Ozs7QUNQQSwyQkFBMkIsbUJBQU8sQ0FBQyxDQUFtRTtBQUN0Rzs7O0FBR0E7QUFDQSxjQUFjLFFBQVMsc0JBQXNCLGlMQUFpTCwrQkFBK0IsUUFBUSwrQ0FBK0MsK0JBQStCLFFBQVEsMEVBQTBFLG1DQUFtQyxtQ0FBbUMsRUFBRSxxR0FBcUcscUNBQXFDLHFDQUFxQyxFQUFFLDJDQUEyQyw0QkFBNEIseUJBQXlCLHFCQUFxQiw2QkFBNkIsRUFBRSxxREFBcUQsaUJBQWlCLHlCQUF5QixhQUFhLGNBQWMsa0JBQWtCLG1CQUFtQixnQkFBZ0IsRUFBRSxpREFBaUQscUJBQXFCLGtCQUFrQixtQkFBbUIsMEJBQTBCLHlCQUF5QixnQ0FBZ0MsMENBQTBDLGtDQUFrQyx1QkFBdUIsaURBQWlELCtCQUErQixpQ0FBaUMsS0FBSyxnRUFBZ0Usb0NBQW9DLG9DQUFvQyxvQ0FBb0MsMkJBQTJCLGVBQWUsbUJBQW1CLDBCQUEwQiwwRUFBMEUsa0VBQWtFLHVCQUF1QixrQkFBa0IsdUJBQXVCLEVBQUUseUVBQXlFLHFCQUFxQix5QkFBeUIsK0JBQStCLEVBQUUsNEZBQTRGLG9FQUFvRSwwQ0FBMEMsMENBQTBDLDBDQUEwQyw4QkFBOEIsK0JBQStCLEVBQUUsNkVBQTZFLDBCQUEwQiw4QkFBOEIsRUFBRSxFQUFFLHdFQUF3RSw0QkFBNEIsc0JBQXNCLEVBQUUseURBQXlELGdDQUFnQyxnQ0FBZ0MsRUFBRSw4SEFBOEgsa0NBQWtDLEVBQUUsd0VBQXdFLG1CQUFtQixvQ0FBb0Msb0NBQW9DLG9DQUFvQyx1QkFBdUIsd0NBQXdDLGlGQUFpRixxQkFBcUIseUJBQXlCLCtCQUErQixFQUFFLDRGQUE0Riw0RUFBNEUsMENBQTBDLDBDQUEwQywwQ0FBMEMsOEJBQThCLCtCQUErQixFQUFFLHFGQUFxRiwwQkFBMEIsOEJBQThCLEVBQUUsRUFBRSwrREFBK0QsZ0NBQWdDLGdDQUFnQyxFQUFFLDBJQUEwSSxrQ0FBa0MsRUFBRSw4RUFBOEUsbUJBQW1CLDRDQUE0Qyw0Q0FBNEMsdUJBQXVCLHdDQUF3Qyx1RkFBdUYscUJBQXFCLHlCQUF5QiwrQkFBK0IsRUFBRSw0RkFBNEYsa0ZBQWtGLDBDQUEwQywwQ0FBMEMsMENBQTBDLDhCQUE4QiwrQkFBK0IsRUFBRSwyRkFBMkYsMEJBQTBCLDhCQUE4QixFQUFFLEVBQUUsOERBQThELDBCQUEwQixFQUFFLDBEQUEwRCw0QkFBNEIsMEJBQTBCLEVBQUUsb1NBQW9TLDRCQUE0QixFQUFFLGdLQUFnSyxxQkFBcUIsaUJBQWlCLEVBQUUsZ0xBQWdMLDRCQUE0QixnQ0FBZ0MsRUFBRSw0YkFBNGIsZ0NBQWdDLGdDQUFnQyxFQUFFLDRnQkFBNGdCLHVCQUF1QixtQkFBbUIsRUFBRSxpREFBaUQscUJBQXFCLEVBQUUsNkRBQTZELHFCQUFxQixFQUFFLHFEQUFxRCxtQkFBbUIsbUJBQW1CLHVCQUF1QixFQUFFLDBCQUEwQixvQkFBb0IsMkJBQTJCLGNBQWMscUJBQXFCLG1CQUFtQixFQUFFOztBQUV4MU87Ozs7Ozs7QUNQQSwyQkFBMkIsbUJBQU8sQ0FBQyxDQUFtRTtBQUN0Rzs7O0FBR0E7QUFDQSxjQUFjLFFBQVMsc0JBQXNCLGlMQUFpTCwrQkFBK0IsUUFBUSwrQ0FBK0MsK0JBQStCLFFBQVEsZ0VBQWdFLHNCQUFzQixpQ0FBaUMsb0NBQW9DLDhCQUE4QixpQ0FBaUMsRUFBRSw0REFBNEQsbUJBQW1CLCtCQUErQixrQ0FBa0MsZ0NBQWdDLG1DQUFtQyxFQUFFLDJEQUEyRCxpQkFBaUIsc0JBQXNCLG9CQUFvQixFQUFFLDhEQUE4RCxzQkFBc0IsOEJBQThCLGlDQUFpQyxpQ0FBaUMsb0NBQW9DLEVBQUUsNkRBQTZELG1CQUFtQiwrQkFBK0Isa0NBQWtDLGdDQUFnQyxtQ0FBbUMsRUFBRSw2REFBNkQsc0JBQXNCLDhCQUE4QixpQ0FBaUMsaUNBQWlDLG9DQUFvQyxFQUFFLDREQUE0RCxtQkFBbUIsK0JBQStCLGtDQUFrQyxnQ0FBZ0MsbUNBQW1DLEVBQUUsc0RBQXNELG1CQUFtQixzQkFBc0IsRUFBRSxvREFBb0Qsc0JBQXNCLHNCQUFzQixFQUFFLDZEQUE2RCxjQUFjLEVBQUUseUJBQXlCLGVBQWUsRUFBRSxxQ0FBcUMscUNBQXFDLHFDQUFxQyw0QkFBNEIsNkJBQTZCLHlCQUF5QixxQkFBcUIsRUFBRSxzSUFBc0ksdUNBQXVDLHVDQUF1QyxFQUFFLDZEQUE2RCxtQkFBbUIsMkJBQTJCLCtCQUErQixlQUFlLGdCQUFnQixvQkFBb0IscUJBQXFCLGtCQUFrQixFQUFFLDJDQUEyQyxzQ0FBc0MsK0NBQStDLGlEQUFpRCxhQUFhLHVCQUF1Qiw0Q0FBNEMsaURBQWlELGFBQWEsd0JBQXdCLGtCQUFrQixtQkFBbUIsMEJBQTBCLHlCQUF5QixnQ0FBZ0MsMkNBQTJDLG1DQUFtQywrQkFBK0IsK0JBQStCLEVBQUUsbURBQW1ELG9DQUFvQyxvQ0FBb0Msb0NBQW9DLDJCQUEyQiwyQkFBMkIsaUJBQWlCLHlCQUF5QixrQkFBa0IsMEJBQTBCLDRCQUE0QixxQkFBcUIsMEVBQTBFLGtFQUFrRSxFQUFFLG1EQUFtRCw0QkFBNEIsMEJBQTBCLEVBQUUsMkRBQTJELG1CQUFtQixvQkFBb0IsMEJBQTBCLDRCQUE0QixvQ0FBb0Msb0NBQW9DLG9DQUFvQyxFQUFFLGdIQUFnSCxnQ0FBZ0MsRUFBRSx3REFBd0QsMEJBQTBCLEVBQUUsb0RBQW9ELDRCQUE0QiwwQkFBMEIsRUFBRSxvSEFBb0gsOEJBQThCLEVBQUUsa0VBQWtFLDBCQUEwQixFQUFFLHdQQUF3UCw0QkFBNEIsZ0NBQWdDLEVBQUUseVFBQXlRLGdDQUFnQywwQkFBMEIsRUFBRSxtU0FBbVMsNEJBQTRCLEVBQUUsb0NBQW9DLGFBQWEsY0FBYyxFQUFFLDhDQUE4QyxhQUFhLGNBQWMsRUFBRSxnQ0FBZ0MsMEJBQTBCLG1DQUFtQyxtQ0FBbUMsdUJBQXVCLGVBQWUsdUJBQXVCLDhCQUE4Qiw4QkFBOEIsd0NBQXdDLGdDQUFnQyxFQUFFLGtEQUFrRCxxQkFBcUIscUJBQXFCLGdCQUFnQiwwQ0FBMEMsa0NBQWtDLEVBQUUsNEdBQTRHLGtCQUFrQiw0QkFBNEIsZ0NBQWdDLEVBQUUsb0tBQW9LLHVCQUF1QixFQUFFLHdDQUF3QyxrQkFBa0IsNEJBQTRCLGdDQUFnQyxFQUFFLDREQUE0RCx1QkFBdUIsRUFBRSx5Q0FBeUMsaUJBQWlCLDBCQUEwQiw0QkFBNEIsZ0NBQWdDLEVBQUUsNkRBQTZELHVCQUF1QixFQUFFLGlEQUFpRCxpQkFBaUIsNEJBQTRCLGdDQUFnQyxFQUFFLHFFQUFxRSx1QkFBdUIsRUFBRSxzQ0FBc0MsbUJBQW1CLGlCQUFpQixzQkFBc0IsRUFBRSxrREFBa0QscUJBQXFCLGtDQUFrQyxxQ0FBcUMsRUFBRSxpREFBaUQsbUNBQW1DLHNDQUFzQyxFQUFFLGdEQUFnRCxpQkFBaUIsc0JBQXNCLG9CQUFvQixFQUFFLHVDQUF1QyxtQkFBbUIsaUJBQWlCLHNCQUFzQixFQUFFLG1EQUFtRCxxQkFBcUIsa0NBQWtDLHFDQUFxQyxFQUFFLGtEQUFrRCxtQ0FBbUMsc0NBQXNDLEVBQUUsaURBQWlELGlCQUFpQixzQkFBc0Isb0JBQW9CLEVBQUUsc0NBQXNDLG1CQUFtQixpQkFBaUIsc0JBQXNCLEVBQUUsa0RBQWtELHFCQUFxQixrQ0FBa0MscUNBQXFDLEVBQUUsaURBQWlELG1DQUFtQyxzQ0FBc0MsRUFBRSxnREFBZ0QsaUJBQWlCLHNCQUFzQixvQkFBb0IsRUFBRSxvREFBb0QsZUFBZSx1QkFBdUIsV0FBVyxZQUFZLGNBQWMsRUFBRSx1QkFBdUIsMEJBQTBCLEVBQUUseUNBQXlDLHFCQUFxQix5QkFBeUIsRUFBRSxrREFBa0QscUJBQXFCLEVBQUUsK0NBQStDLG1CQUFtQix1QkFBdUIsRUFBRSx1QkFBdUIsY0FBYyxxQkFBcUIsb0JBQW9CLDJCQUEyQixtQkFBbUIsRUFBRSxpQ0FBaUMsaUJBQWlCLHVCQUF1QixFQUFFLHdFQUF3RSwwQ0FBMEMseUJBQXlCLEVBQUUsRUFBRSxFQUFFOztBQUU3NVM7Ozs7Ozs7QUNQQSwyQkFBMkIsbUJBQU8sQ0FBQyxDQUFtRTtBQUN0Rzs7O0FBR0E7QUFDQSxjQUFjLFFBQVMsc0JBQXNCLGlMQUFpTCwrQkFBK0IsUUFBUSwrQ0FBK0MsK0JBQStCLFFBQVEsdURBQXVELGdCQUFnQixFQUFFLGtIQUFrSCxxQkFBcUIsb0JBQW9CLEVBQUUsa0RBQWtELGlCQUFpQixFQUFFLDZEQUE2RCxlQUFlLGdCQUFnQixFQUFFLGlFQUFpRSxjQUFjLGdCQUFnQixFQUFFLGdFQUFnRSxtQkFBbUIsd0JBQXdCLEVBQUUsdUVBQXVFLGtCQUFrQixzQkFBc0IsMkJBQTJCLEVBQUUsNkRBQTZELGVBQWUsZ0JBQWdCLEVBQUUsZ0JBQWdCLG1DQUFtQyxtQ0FBbUMsdUJBQXVCLHFCQUFxQixtQkFBbUIsY0FBYyxxQkFBcUIsOEJBQThCLHVCQUF1Qiw2QkFBNkIsNkJBQTZCLHdCQUF3QixzQkFBc0Isb0JBQW9CLGtDQUFrQyw0QkFBNEIsV0FBVyxLQUFLLGlFQUFpRSxxQ0FBcUMscUNBQXFDLEVBQUUsNkNBQTZDLGlCQUFpQixFQUFFLHdCQUF3Qix5QkFBeUIsaUJBQWlCLGdCQUFnQix1QkFBdUIsRUFBRSx5QkFBeUIsaUJBQWlCLGdCQUFnQix1QkFBdUIsRUFBRSw2Q0FBNkMseUJBQXlCLEVBQUUsb0RBQW9ELGdEQUFnRCx3Q0FBd0MsRUFBRSw2Q0FBNkMseUJBQXlCLEVBQUUsb0RBQW9ELGdEQUFnRCx3Q0FBd0MsRUFBRSxxQkFBcUIseUJBQXlCLHNCQUFzQiw4Q0FBOEMsc0NBQXNDLHFCQUFxQixzQkFBc0IsRUFBRSw4QkFBOEIscUJBQXFCLHVCQUF1QiwyQkFBMkIsd0JBQXdCLEVBQUUsd0VBQXdFLDBCQUEwQixFQUFFLHFDQUFxQyx1QkFBdUIsa0NBQWtDLEVBQUUsNkRBQTZELHlCQUF5QixFQUFFLGdFQUFnRSx5QkFBeUIsRUFBRSxrR0FBa0csdUJBQXVCLGtDQUFrQyw0QkFBNEIsRUFBRSxrSkFBa0oseUJBQXlCLEVBQUUsd0pBQXdKLHlCQUF5QixFQUFFLHFjQUFxYyx1QkFBdUIsa0NBQWtDLEVBQUUsdW5CQUF1bkIseUJBQXlCLEVBQUUsK29CQUErb0IseUJBQXlCLEVBQUUsMkJBQTJCLG1CQUFtQixzQkFBc0IsdUJBQXVCLDhCQUE4QiwwQkFBMEIsd0JBQXdCLEVBQUUsMEJBQTBCLDZCQUE2QixFQUFFLGdDQUFnQyw4QkFBOEIsOEJBQThCLHVCQUF1QixFQUFFLDBDQUEwQyw2QkFBNkIsd0NBQXdDLGlCQUFpQixrQkFBa0Isb0JBQW9CLG1CQUFtQixzQkFBc0IsRUFBRSx5QkFBeUIsaUJBQWlCLEVBQUUsNEdBQTRHLDhCQUE4Qiw0QkFBNEIsRUFBRSxzSUFBc0ksOEJBQThCLEVBQUUsMEJBQTBCLG1CQUFtQixFQUFFLDRCQUE0QixzQkFBc0IscUJBQXFCLEVBQUUsd0JBQXdCLHVCQUF1Qix1Q0FBdUMsRUFBRSxtREFBbUQseUJBQXlCLGFBQWEseUJBQXlCLEVBQUUsNERBQTRELG9CQUFvQix3QkFBd0IsNkJBQTZCLEVBQUUsZ0RBQWdELHlCQUF5QixhQUFhLGtCQUFrQixxQkFBcUIsdUNBQXVDLCtCQUErQixFQUFFLHlEQUF5RCxtQkFBbUIsdUJBQXVCLDZCQUE2QixFQUFFLDBGQUEwRixvREFBb0Qsd0NBQXdDLHdDQUF3Qyx3Q0FBd0MsNEJBQTRCLDZCQUE2QixFQUFFLDZEQUE2RCx3QkFBd0IsNEJBQTRCLEVBQUUsRUFBRSxxREFBcUQsd0NBQXdDLHdDQUF3Qyx3Q0FBd0MsRUFBRSw4REFBOEQsbUJBQW1CLHVCQUF1Qiw2QkFBNkIsRUFBRSwwRkFBMEYseURBQXlELHVEQUF1RCx1REFBdUQsdURBQXVELDRCQUE0Qiw2QkFBNkIsRUFBRSxrRUFBa0Usd0JBQXdCLDRCQUE0QixFQUFFLEVBQUUsc0RBQXNELHdDQUF3Qyx3Q0FBd0Msd0NBQXdDLEVBQUUsK0RBQStELG1CQUFtQix1QkFBdUIsNkJBQTZCLEVBQUUsMEZBQTBGLDBEQUEwRCx1REFBdUQsdURBQXVELHVEQUF1RCw0QkFBNEIsNkJBQTZCLEVBQUUsbUVBQW1FLHdCQUF3Qiw0QkFBNEIsRUFBRSxFQUFFLG9EQUFvRCx5QkFBeUIsYUFBYSxpQkFBaUIscUJBQXFCLHVDQUF1QywrQkFBK0IsRUFBRSw2REFBNkQsb0JBQW9CLHdCQUF3Qiw2QkFBNkIsRUFBRSxvREFBb0Qsd0NBQXdDLHdDQUF3Qyx3Q0FBd0MsRUFBRSw2REFBNkQsb0JBQW9CLHdCQUF3Qiw2QkFBNkIsRUFBRSw2QkFBNkIsd0JBQXdCLEVBQUUscURBQXFELHFCQUFxQixFQUFFOztBQUUzMVQ7Ozs7Ozs7QUNQQSwyQkFBMkIsbUJBQU8sQ0FBQyxDQUFtRTtBQUN0Rzs7O0FBR0E7QUFDQSxjQUFjLFFBQVMsc0JBQXNCLGlMQUFpTCwrQkFBK0IsUUFBUSwrQ0FBK0MsK0JBQStCLFFBQVEsa0JBQWtCLG1DQUFtQyxtQ0FBbUMsRUFBRSw4REFBOEQscUNBQXFDLHFDQUFxQyxFQUFFLGlDQUFpQyxnQkFBZ0IsaUJBQWlCLEVBQUUsbUVBQW1FLGlCQUFpQixFQUFFLHNDQUFzQyxRQUFRLHdDQUF3Qyx3Q0FBd0Msc0NBQXNDLHNDQUFzQyxFQUFFLFVBQVUsd0NBQXdDLHdDQUF3Qyx3Q0FBd0Msd0NBQXdDLEVBQUUsRUFBRSw4QkFBOEIsUUFBUSx3Q0FBd0Msd0NBQXdDLHNDQUFzQyxzQ0FBc0MsRUFBRSxVQUFVLHdDQUF3Qyx3Q0FBd0Msd0NBQXdDLHdDQUF3QyxFQUFFLEVBQUUsZUFBZSw0UUFBNFEsZUFBZSx5QkFBeUIsNEJBQTRCLCtCQUErQiwrQkFBK0IsNEJBQTRCLHlCQUF5QiwyQkFBMkIsMEJBQTBCLDZCQUE2QixnQ0FBZ0MsZ0NBQWdDLGdDQUFnQyxnQ0FBZ0MsMkNBQTJDLG1DQUFtQyxzQkFBc0IsRUFBRSx1QkFBdUIsMkJBQTJCLDJCQUEyQixtQkFBbUIsMkJBQTJCLDZDQUE2QyxxQ0FBcUMsRUFBRSwyQ0FBMkMsaUNBQWlDLEVBQUUsd0NBQXdDLGlDQUFpQyxpQ0FBaUMsRUFBRSwwQkFBMEIseUJBQXlCLHFCQUFxQixtQkFBbUIsd0JBQXdCLHNCQUFzQix3QkFBd0IsRUFBRSw2REFBNkQsdUJBQXVCLDBCQUEwQixFQUFFLHNFQUFzRSxzQkFBc0IsMEJBQTBCLCtCQUErQixFQUFFLDREQUE0RCx5QkFBeUIsd0JBQXdCLEVBQUUscUVBQXFFLHNCQUFzQiwwQkFBMEIsK0JBQStCLEVBQUUsb0VBQW9FLG9CQUFvQix3QkFBd0IsNkJBQTZCLEVBQUUsNkNBQTZDLDJCQUEyQixFQUFFLHFEQUFxRCxzQkFBc0IsdUJBQXVCLDBCQUEwQiw0QkFBNEIsb0JBQW9CLG1CQUFtQiw2QkFBNkIsMkJBQTJCLDRCQUE0QixFQUFFLDREQUE0RCx3QkFBd0IsRUFBRSwyQkFBMkIseUJBQXlCLHNCQUFzQixtQkFBbUIsd0JBQXdCLHNCQUFzQix3QkFBd0IsRUFBRSw4REFBOEQsdUJBQXVCLDBCQUEwQixFQUFFLHVFQUF1RSxzQkFBc0IsMEJBQTBCLCtCQUErQixFQUFFLDZEQUE2RCx5QkFBeUIsd0JBQXdCLEVBQUUsc0VBQXNFLHNCQUFzQiwwQkFBMEIsK0JBQStCLEVBQUUscUVBQXFFLG9CQUFvQix3QkFBd0IsNkJBQTZCLEVBQUUsOENBQThDLDJCQUEyQixFQUFFLHNEQUFzRCxzQkFBc0IsdUJBQXVCLDBCQUEwQiw0QkFBNEIscUJBQXFCLG1CQUFtQiw2QkFBNkIsMkJBQTJCLDRCQUE0QixFQUFFLDZEQUE2RCx3QkFBd0IsRUFBRSwwQkFBMEIseUJBQXlCLHNCQUFzQixtQkFBbUIsd0JBQXdCLHNCQUFzQix3QkFBd0IsRUFBRSw2REFBNkQsdUJBQXVCLDBCQUEwQixFQUFFLHNFQUFzRSxzQkFBc0IsMEJBQTBCLCtCQUErQixFQUFFLDREQUE0RCx5QkFBeUIsd0JBQXdCLEVBQUUscUVBQXFFLHNCQUFzQiwwQkFBMEIsK0JBQStCLEVBQUUsb0VBQW9FLG9CQUFvQix3QkFBd0IsNkJBQTZCLEVBQUUsNkNBQTZDLDJCQUEyQixFQUFFLHFEQUFxRCxzQkFBc0IsdUJBQXVCLDBCQUEwQiw0QkFBNEIscUJBQXFCLG1CQUFtQiw2QkFBNkIsMkJBQTJCLDRCQUE0QixFQUFFLDREQUE0RCx3QkFBd0IsRUFBRSwrQkFBK0IsMEJBQTBCLGdDQUFnQyw0QkFBNEIsRUFBRSx1SUFBdUksdUJBQXVCLEVBQUUsNktBQTZLLHVCQUF1QixrQ0FBa0MsOEJBQThCLDhCQUE4QixFQUFFLGdDQUFnQywwQkFBMEIsZ0NBQWdDLGdDQUFnQyxFQUFFLDJJQUEySSx1QkFBdUIsRUFBRSxrTEFBa0wsdUJBQXVCLGtDQUFrQyxrQ0FBa0MsOEJBQThCLEVBQUUsa0NBQWtDLDBCQUEwQixnQ0FBZ0MsNEJBQTRCLEVBQUUsbUpBQW1KLHVCQUF1QixFQUFFLDRMQUE0TCx1QkFBdUIsa0NBQWtDLDhCQUE4Qiw4QkFBOEIsRUFBRSw2Q0FBNkMsMEJBQTBCLGdDQUFnQyw0QkFBNEIsRUFBRSxvTkFBb04sdUJBQXVCLEVBQUUsbVJBQW1SLHVCQUF1QixrQ0FBa0MsOEJBQThCLDhCQUE4QixFQUFFLHVCQUF1QiwwQkFBMEIsRUFBRSwwQ0FBMEMsa0NBQWtDLDhCQUE4QixFQUFFLDZLQUE2Syx5QkFBeUIsRUFBRSw0TkFBNE4seUJBQXlCLG9DQUFvQyxnQ0FBZ0MsZ0NBQWdDLEVBQUUsbUdBQW1HLG9DQUFvQyxnQ0FBZ0MsRUFBRSxnYUFBZ2EsMkJBQTJCLEVBQUUsaWhCQUFpaEIsMkJBQTJCLHNDQUFzQyxrQ0FBa0Msa0NBQWtDLEVBQUUseUNBQXlDLGtDQUFrQyw4QkFBOEIsRUFBRSx5S0FBeUsseUJBQXlCLEVBQUUsdU5BQXVOLHlCQUF5QixvQ0FBb0MsZ0NBQWdDLGdDQUFnQyxFQUFFLGlHQUFpRyxvQ0FBb0MsZ0NBQWdDLEVBQUUsd1pBQXdaLDJCQUEyQixFQUFFLHVnQkFBdWdCLDJCQUEyQixzQ0FBc0Msa0NBQWtDLGtDQUFrQyxFQUFFLG9CQUFvQiwrQkFBK0IsK0JBQStCLHVCQUF1QixFQUFFLGtEQUFrRCxpQ0FBaUMsaUNBQWlDLEVBQUUsdUNBQXVDLHNDQUFzQyxrQ0FBa0MsRUFBRSxpS0FBaUsseUJBQXlCLEVBQUUsNk1BQTZNLHlCQUF5Qix3Q0FBd0Msb0NBQW9DLGdDQUFnQyxFQUFFLHlDQUF5QyxzQ0FBc0Msa0NBQWtDLEVBQUUseUtBQXlLLHlCQUF5QixFQUFFLHVOQUF1Tix5QkFBeUIsd0NBQXdDLG9DQUFvQyxnQ0FBZ0MsRUFBRSxzQ0FBc0Msc0NBQXNDLGtDQUFrQyxFQUFFLDZKQUE2Six5QkFBeUIsRUFBRSx3TUFBd00seUJBQXlCLHdDQUF3QyxvQ0FBb0MsZ0NBQWdDLEVBQUUsaUNBQWlDLHlCQUF5QixxQkFBcUIscUJBQXFCLDBCQUEwQix3QkFBd0Isd0JBQXdCLEVBQUUsb0VBQW9FLHlCQUF5Qiw0QkFBNEIsRUFBRSw2RUFBNkUsd0JBQXdCLDRCQUE0QixpQ0FBaUMsRUFBRSxtRUFBbUUsMkJBQTJCLDBCQUEwQixFQUFFLDRFQUE0RSx3QkFBd0IsNEJBQTRCLGlDQUFpQyxFQUFFLDJFQUEyRSxzQkFBc0IsMEJBQTBCLCtCQUErQixFQUFFLG9EQUFvRCw2QkFBNkIsRUFBRSw0REFBNEQsd0JBQXdCLHlCQUF5Qiw0QkFBNEIsOEJBQThCLG9CQUFvQixxQkFBcUIsK0JBQStCLDZCQUE2Qiw4QkFBOEIsRUFBRSxtRUFBbUUsMEJBQTBCLEVBQUUsa0NBQWtDLHlCQUF5QixxQkFBcUIscUJBQXFCLDBCQUEwQix3QkFBd0Isd0JBQXdCLEVBQUUscUVBQXFFLHlCQUF5Qiw0QkFBNEIsRUFBRSw4RUFBOEUsd0JBQXdCLDRCQUE0QixpQ0FBaUMsRUFBRSxvRUFBb0UsMkJBQTJCLDBCQUEwQixFQUFFLDZFQUE2RSx3QkFBd0IsNEJBQTRCLGlDQUFpQyxFQUFFLDRFQUE0RSxzQkFBc0IsMEJBQTBCLCtCQUErQixFQUFFLHFEQUFxRCw2QkFBNkIsRUFBRSw2REFBNkQsd0JBQXdCLHlCQUF5Qiw0QkFBNEIsOEJBQThCLG9CQUFvQixxQkFBcUIsK0JBQStCLDZCQUE2Qiw4QkFBOEIsRUFBRSxvRUFBb0UsMEJBQTBCLEVBQUUsaUNBQWlDLHlCQUF5QixxQkFBcUIscUJBQXFCLDBCQUEwQix3QkFBd0Isd0JBQXdCLEVBQUUsb0VBQW9FLHlCQUF5Qiw0QkFBNEIsRUFBRSw2RUFBNkUsd0JBQXdCLDRCQUE0QixpQ0FBaUMsRUFBRSxtRUFBbUUsMkJBQTJCLDBCQUEwQixFQUFFLDRFQUE0RSx3QkFBd0IsNEJBQTRCLGlDQUFpQyxFQUFFLDJFQUEyRSxzQkFBc0IsMEJBQTBCLCtCQUErQixFQUFFLG9EQUFvRCw2QkFBNkIsRUFBRSw0REFBNEQsd0JBQXdCLHlCQUF5Qiw0QkFBNEIsOEJBQThCLG9CQUFvQixxQkFBcUIsK0JBQStCLDZCQUE2Qiw4QkFBOEIsRUFBRSxtRUFBbUUsMEJBQTBCLEVBQUUseURBQXlELHNDQUFzQyxrQ0FBa0MsRUFBRSw4UEFBOFAseUJBQXlCLEVBQUUsdVVBQXVVLHlCQUF5Qix3Q0FBd0Msb0NBQW9DLGdDQUFnQyxFQUFFLHVDQUF1QyxzQ0FBc0Msa0NBQWtDLEVBQUUsaUtBQWlLLHlCQUF5QixFQUFFLDZNQUE2TSx5QkFBeUIsd0NBQXdDLG9DQUFvQyxnQ0FBZ0MsRUFBRSx1QkFBdUIsMkJBQTJCLEVBQUUsK0JBQStCLDhCQUE4Qiw0QkFBNEIsbUJBQW1CLDRCQUE0Qiw0REFBNEQsNERBQTRELEVBQUUscUJBQXFCLCtCQUErQiwrQkFBK0IsMEJBQTBCLEVBQUUscUNBQXFDLHNDQUFzQyw4QkFBOEIsRUFBRSx5SkFBeUoseUJBQXlCLEVBQUUsbU1BQW1NLHlCQUF5QixxREFBcUQsZ0NBQWdDLGdDQUFnQyxFQUFFLHlGQUF5Rix3Q0FBd0MsaURBQWlELEVBQUUsd1hBQXdYLDRDQUE0QyxFQUFFLCtkQUErZCw0Q0FBNEMsMENBQTBDLG1EQUFtRCxrQ0FBa0MsRUFBRSxzQ0FBc0Msc0NBQXNDLDhCQUE4QixFQUFFLDZKQUE2Six5QkFBeUIsRUFBRSx3TUFBd00seUJBQXlCLGdEQUFnRCxnQ0FBZ0MsZ0NBQWdDLEVBQUUsMkZBQTJGLHdDQUF3QywyQ0FBMkMsRUFBRSxnWUFBZ1ksc0NBQXNDLEVBQUUseWVBQXllLHNDQUFzQywwQ0FBMEMsNkNBQTZDLGtDQUFrQyxFQUFFLHFCQUFxQix5QkFBeUIsNEJBQTRCLDZCQUE2QixFQUFFLG1DQUFtQywyQkFBMkIsb0JBQW9CLGlDQUFpQyxpQ0FBaUMsRUFBRSxzSkFBc0oscUJBQXFCLEVBQUUscUZBQXFGLHFCQUFxQixFQUFFLDBDQUEwQywyQkFBMkIsRUFBRSxvRUFBb0UseUJBQXlCLEVBQUUsK0NBQStDLGtCQUFrQixFQUFFLGdFQUFnRSxzQ0FBc0MsbUNBQW1DLEVBQUUsZ0VBQWdFLHFDQUFxQyxrQ0FBa0MsRUFBRSw2REFBNkQsb0RBQW9ELEVBQUUscUVBQXFFLHlDQUF5QyxFQUFFLHlJQUF5SSxxQ0FBcUMsRUFBRSx3R0FBd0csaUJBQWlCLEVBQUUscURBQXFELHVCQUF1QixFQUFFLDJFQUEyRSxpQ0FBaUMsOEJBQThCLEVBQUUsMkVBQTJFLGtDQUFrQywrQkFBK0IsRUFBRSx3RUFBd0UsaURBQWlELEVBQUUsOEVBQThFLHNDQUFzQyxFQUFFLCtKQUErSixrQ0FBa0MsRUFBRSxtR0FBbUcsdUJBQXVCLEVBQUUsd0VBQXdFLHVCQUF1QixzQkFBc0IsRUFBRSxpRkFBaUYsb0JBQW9CLHdCQUF3Qiw2QkFBNkIsRUFBRSx1RUFBdUUscUJBQXFCLHdCQUF3QixFQUFFLGdGQUFnRixvQkFBb0Isd0JBQXdCLDZCQUE2QixFQUFFLHdEQUF3RCx3QkFBd0IsMEJBQTBCLEVBQUUsZ0VBQWdFLG1CQUFtQixpQkFBaUIsd0JBQXdCLHlCQUF5QixFQUFFLHdDQUF3Qyx1QkFBdUIsRUFBRSx5RUFBeUUsdUJBQXVCLHNCQUFzQixFQUFFLGtGQUFrRixvQkFBb0Isd0JBQXdCLDZCQUE2QixFQUFFLHdFQUF3RSxxQkFBcUIsd0JBQXdCLEVBQUUsaUZBQWlGLG9CQUFvQix3QkFBd0IsNkJBQTZCLEVBQUUseURBQXlELHlCQUF5QiwwQkFBMEIsRUFBRSxpRUFBaUUsb0JBQW9CLGlCQUFpQix3QkFBd0IseUJBQXlCLEVBQUUsdUNBQXVDLHVCQUF1QixFQUFFLHdFQUF3RSx1QkFBdUIsc0JBQXNCLEVBQUUsaUZBQWlGLG9CQUFvQix3QkFBd0IsNkJBQTZCLEVBQUUsdUVBQXVFLHFCQUFxQix3QkFBd0IsRUFBRSxnRkFBZ0Ysb0JBQW9CLHdCQUF3Qiw2QkFBNkIsRUFBRSx3REFBd0QseUJBQXlCLDBCQUEwQixFQUFFLGdFQUFnRSxvQkFBb0IsaUJBQWlCLHdCQUF3Qix5QkFBeUIsRUFBRSx3REFBd0QscUJBQXFCLEVBQUUsNkVBQTZFLHVCQUF1QixzQkFBc0IsRUFBRSxzRkFBc0Ysb0JBQW9CLHdCQUF3Qiw2QkFBNkIsRUFBRSw0RUFBNEUscUJBQXFCLHdCQUF3QixFQUFFLHFGQUFxRixvQkFBb0Isd0JBQXdCLDZCQUE2QixFQUFFLDZEQUE2RCxzQkFBc0IsMEJBQTBCLEVBQUUscUVBQXFFLGlCQUFpQixpQkFBaUIsd0JBQXdCLHlCQUF5QixFQUFFLDZDQUE2QyxxQkFBcUIsRUFBRSw4RUFBOEUsdUJBQXVCLHNCQUFzQixFQUFFLHVGQUF1RixvQkFBb0Isd0JBQXdCLDZCQUE2QixFQUFFLDZFQUE2RSxxQkFBcUIsd0JBQXdCLEVBQUUsc0ZBQXNGLG9CQUFvQix3QkFBd0IsNkJBQTZCLEVBQUUsOERBQThELHNCQUFzQiwwQkFBMEIsRUFBRSxzRUFBc0UsaUJBQWlCLGlCQUFpQix3QkFBd0IseUJBQXlCLEVBQUUsNENBQTRDLHFCQUFxQixFQUFFLDZFQUE2RSx1QkFBdUIsc0JBQXNCLEVBQUUsc0ZBQXNGLG9CQUFvQix3QkFBd0IsNkJBQTZCLEVBQUUsNEVBQTRFLHFCQUFxQix3QkFBd0IsRUFBRSxxRkFBcUYsb0JBQW9CLHdCQUF3Qiw2QkFBNkIsRUFBRSw2REFBNkQsc0JBQXNCLDBCQUEwQixFQUFFLHFFQUFxRSxpQkFBaUIsaUJBQWlCLHdCQUF3Qix5QkFBeUIsRUFBRTs7QUFFOTQvQjs7Ozs7OztBQ1BBLDJCQUEyQixtQkFBTyxDQUFDLENBQW1FO0FBQ3RHOzs7QUFHQTtBQUNBLGNBQWMsUUFBUyxzQkFBc0IsaUxBQWlMLCtCQUErQixRQUFRLCtDQUErQywrQkFBK0IsUUFBUSxrREFBa0Qsa0JBQWtCLEVBQUUsa0RBQWtELG9CQUFvQixrQkFBa0IsV0FBVyxZQUFZLGdCQUFnQixpQkFBaUIsd0JBQXdCLG9DQUFvQyw0QkFBNEIsZUFBZSxFQUFFLHlEQUF5RCxpQkFBaUIsRUFBRTs7QUFFdHVCOzs7Ozs7O0FDUEEsMkJBQTJCLG1CQUFPLENBQUMsQ0FBbUU7QUFDdEc7OztBQUdBO0FBQ0EsY0FBYyxRQUFTOztBQUV2Qjs7Ozs7OztBQ1BBLDJCQUEyQixtQkFBTyxDQUFDLENBQW1FO0FBQ3RHOzs7QUFHQTtBQUNBLGNBQWMsUUFBUyxzQkFBc0IsaUxBQWlMLCtCQUErQixRQUFRLCtDQUErQywrQkFBK0IsUUFBUSxnREFBZ0QsdUJBQXVCLDBCQUEwQixrRkFBa0YsNkJBQTZCLDJCQUEyQixFQUFFLDJDQUEyQyxrQkFBa0IsZ0NBQWdDLHdCQUF3QixrR0FBa0csa0dBQWtHLDRDQUE0QywyQkFBMkIsRUFBRSwwQkFBMEIseUJBQXlCLGFBQWEsZ0JBQWdCLGNBQWMsZUFBZSxrQkFBa0Isa0JBQWtCLHVCQUF1QixFQUFFLHVCQUF1QixxQkFBcUIseUJBQXlCLGVBQWUsZ0JBQWdCLGlCQUFpQiwrQ0FBK0MsK0NBQStDLCtDQUErQyx5QkFBeUIsRUFBRSxtQ0FBbUMsb0JBQW9CLEVBQUUscURBQXFELDRCQUE0QixFQUFFLHVEQUF1RCx5QkFBeUIscUJBQXFCLGVBQWUsZUFBZSw0Q0FBNEMsNENBQTRDLDRDQUE0QyxFQUFFLDJEQUEyRCw0QkFBNEIseUJBQXlCLHVCQUF1QixFQUFFLGtDQUFrQyw0QkFBNEIsa0JBQWtCLG1CQUFtQix5QkFBeUIsZ0JBQWdCLHVDQUF1QywrQkFBK0Isa0RBQWtELDBDQUEwQyxnREFBZ0Qsd0NBQXdDLDhDQUE4QyxzQ0FBc0MsRUFBRSxzREFBc0QsMkJBQTJCLHFCQUFxQixvQkFBb0IscUJBQXFCLDJCQUEyQiw0QkFBNEIsdURBQXVELCtDQUErQyxvREFBb0QsNENBQTRDLHlDQUF5QyxpQ0FBaUMsRUFBRSxxRUFBcUUsaUJBQWlCLG9CQUFvQixrQkFBa0Isa0RBQWtELDBDQUEwQyxFQUFFLHFFQUFxRSxrQkFBa0IsbUJBQW1CLGlCQUFpQixzQkFBc0Isa0RBQWtELDBDQUEwQyxFQUFFLHFFQUFxRSxpQkFBaUIsb0JBQW9CLG1CQUFtQixzQkFBc0IsbURBQW1ELDJDQUEyQyxFQUFFLHFFQUFxRSxrQkFBa0IsbUJBQW1CLG9CQUFvQixzQkFBc0IsbURBQW1ELDJDQUEyQyxFQUFFLHlDQUF5QyxrQkFBa0IsbUJBQW1CLEVBQUUsNkRBQTZELG1CQUFtQixvQkFBb0IsRUFBRSw0RUFBNEUseURBQXlELGlEQUFpRCxFQUFFLDRFQUE0RSx5REFBeUQsaURBQWlELEVBQUUsNEVBQTRFLDBEQUEwRCxrREFBa0QsRUFBRSw0RUFBNEUsMERBQTBELGtEQUFrRCxFQUFFLHdDQUF3QyxRQUFRLHNDQUFzQyxrQ0FBa0MsOEJBQThCLEVBQUUsUUFBUSx1Q0FBdUMsbUNBQW1DLCtCQUErQixFQUFFLFNBQVMsdUNBQXVDLG1DQUFtQywrQkFBK0IsRUFBRSxTQUFTLHdDQUF3QyxvQ0FBb0MsZ0NBQWdDLEVBQUUsU0FBUyx3Q0FBd0Msb0NBQW9DLGdDQUFnQyxFQUFFLFNBQVMsd0NBQXdDLG9DQUFvQyxnQ0FBZ0MsRUFBRSxTQUFTLHdDQUF3QyxvQ0FBb0MsZ0NBQWdDLEVBQUUsU0FBUyx3Q0FBd0Msb0NBQW9DLGdDQUFnQyxFQUFFLFVBQVUsd0NBQXdDLG9DQUFvQyxnQ0FBZ0MsRUFBRSxFQUFFLGdDQUFnQyxRQUFRLHNDQUFzQyxrQ0FBa0MsOEJBQThCLEVBQUUsUUFBUSx1Q0FBdUMsbUNBQW1DLCtCQUErQixFQUFFLFNBQVMsdUNBQXVDLG1DQUFtQywrQkFBK0IsRUFBRSxTQUFTLHdDQUF3QyxvQ0FBb0MsZ0NBQWdDLEVBQUUsU0FBUyx3Q0FBd0Msb0NBQW9DLGdDQUFnQyxFQUFFLFNBQVMsd0NBQXdDLG9DQUFvQyxnQ0FBZ0MsRUFBRSxTQUFTLHdDQUF3QyxvQ0FBb0MsZ0NBQWdDLEVBQUUsU0FBUyx3Q0FBd0Msb0NBQW9DLGdDQUFnQyxFQUFFLFVBQVUsd0NBQXdDLG9DQUFvQyxnQ0FBZ0MsRUFBRSxFQUFFLDJEQUEyRCxTQUFTLGdCQUFnQixFQUFFLGlCQUFpQixxQkFBcUIscUJBQXFCLG9CQUFvQixFQUFFLFNBQVMsZ0JBQWdCLG1CQUFtQixrQkFBa0IsRUFBRSxFQUFFLGlDQUFpQyxTQUFTLGdCQUFnQixFQUFFLGlCQUFpQixxQkFBcUIscUJBQXFCLG9CQUFvQixFQUFFLFNBQVMsZ0JBQWdCLG1CQUFtQixrQkFBa0IsRUFBRSxFQUFFLHdDQUF3QyxTQUFTLGFBQWEsRUFBRSxpQkFBaUIsa0JBQWtCLHFCQUFxQixvQkFBb0IsRUFBRSxTQUFTLGFBQWEsbUJBQW1CLGtCQUFrQixFQUFFLEVBQUUsZ0NBQWdDLFNBQVMsYUFBYSxFQUFFLGlCQUFpQixrQkFBa0IscUJBQXFCLG9CQUFvQixFQUFFLFNBQVMsYUFBYSxtQkFBbUIsa0JBQWtCLEVBQUUsRUFBRSx3Q0FBd0MsU0FBUyxjQUFjLEVBQUUsaUJBQWlCLG1CQUFtQixvQkFBb0IscUJBQXFCLEVBQUUsU0FBUyxjQUFjLG1CQUFtQixrQkFBa0IsRUFBRSxFQUFFLGdDQUFnQyxTQUFTLGNBQWMsRUFBRSxpQkFBaUIsbUJBQW1CLG9CQUFvQixxQkFBcUIsRUFBRSxTQUFTLGNBQWMsbUJBQW1CLGtCQUFrQixFQUFFLEVBQUUseUNBQXlDLFNBQVMsZUFBZSxFQUFFLGlCQUFpQixvQkFBb0Isb0JBQW9CLHFCQUFxQixFQUFFLFNBQVMsZUFBZSxtQkFBbUIsa0JBQWtCLEVBQUUsRUFBRSxpQ0FBaUMsU0FBUyxlQUFlLEVBQUUsaUJBQWlCLG9CQUFvQixvQkFBb0IscUJBQXFCLEVBQUUsU0FBUyxlQUFlLG1CQUFtQixrQkFBa0IsRUFBRSxFQUFFLGdEQUFnRCxTQUFTLGdCQUFnQixFQUFFLGlCQUFpQixxQkFBcUIsb0JBQW9CLG1CQUFtQixFQUFFLFNBQVMsZ0JBQWdCLGtCQUFrQixpQkFBaUIsRUFBRSxFQUFFLHdDQUF3QyxTQUFTLGdCQUFnQixFQUFFLGlCQUFpQixxQkFBcUIsb0JBQW9CLG1CQUFtQixFQUFFLFNBQVMsZ0JBQWdCLGtCQUFrQixpQkFBaUIsRUFBRSxFQUFFLCtDQUErQyxTQUFTLGFBQWEsRUFBRSxpQkFBaUIsa0JBQWtCLG9CQUFvQixtQkFBbUIsRUFBRSxTQUFTLGFBQWEsa0JBQWtCLGlCQUFpQixFQUFFLEVBQUUsdUNBQXVDLFNBQVMsYUFBYSxFQUFFLGlCQUFpQixrQkFBa0Isb0JBQW9CLG1CQUFtQixFQUFFLFNBQVMsYUFBYSxrQkFBa0IsaUJBQWlCLEVBQUUsRUFBRSwrQ0FBK0MsU0FBUyxjQUFjLEVBQUUsaUJBQWlCLG1CQUFtQixtQkFBbUIsb0JBQW9CLEVBQUUsU0FBUyxjQUFjLGtCQUFrQixpQkFBaUIsRUFBRSxFQUFFLHVDQUF1QyxTQUFTLGNBQWMsRUFBRSxpQkFBaUIsbUJBQW1CLG1CQUFtQixvQkFBb0IsRUFBRSxTQUFTLGNBQWMsa0JBQWtCLGlCQUFpQixFQUFFLEVBQUUsZ0RBQWdELFNBQVMsZUFBZSxFQUFFLGlCQUFpQixvQkFBb0IsbUJBQW1CLG9CQUFvQixFQUFFLFNBQVMsZUFBZSxrQkFBa0IsaUJBQWlCLEVBQUUsRUFBRSx3Q0FBd0MsU0FBUyxlQUFlLEVBQUUsaUJBQWlCLG9CQUFvQixtQkFBbUIsb0JBQW9CLEVBQUUsU0FBUyxlQUFlLGtCQUFrQixpQkFBaUIsRUFBRSxFQUFFOztBQUV2a1U7Ozs7Ozs7QUNQQSwyQkFBMkIsbUJBQU8sQ0FBQyxDQUFtRTtBQUN0Rzs7O0FBR0E7QUFDQSxjQUFjLFFBQVMsc0JBQXNCLGlMQUFpTCwrQkFBK0IsUUFBUSwrQ0FBK0MsK0JBQStCLFFBQVEsOENBQThDLG1DQUFtQyxtQ0FBbUMsdUJBQXVCLEVBQUUsb0VBQW9FLHFDQUFxQyxxQ0FBcUMsRUFBRSx1QkFBdUIsZ0NBQWdDLHdCQUF3QixrQkFBa0IsMEJBQTBCLEVBQUUsMkNBQTJDLDRCQUE0QixFQUFFLG9CQUFvQixpQkFBaUIsMEJBQTBCLHFCQUFxQix1QkFBdUIsMEJBQTBCLGdDQUFnQyxFQUFFLCtDQUErQywyQkFBMkIseUJBQXlCLGdDQUFnQyw4QkFBOEIsRUFBRSx1QkFBdUIsaUJBQWlCLEVBQUUsa0NBQWtDLHlCQUF5QixFQUFFLCtEQUErRCwyQkFBMkIsaUJBQWlCLGVBQWUsa0JBQWtCLG1CQUFtQixnQ0FBZ0MsMEJBQTBCLEVBQUUsb0JBQW9CLGlCQUFpQixnQ0FBZ0MsRUFBRSwrQ0FBK0MsMkJBQTJCLHlCQUF5QixnQ0FBZ0MsOEJBQThCLEVBQUUsdVFBQXVRLDRCQUE0QixzQkFBc0IsRUFBRSx3TUFBd00sc0JBQXNCLDBCQUEwQiwrQkFBK0IsRUFBRSw4SEFBOEgsd0JBQXdCLEVBQUUsbURBQW1ELDRCQUE0QixFQUFFLG9DQUFvQyxzQkFBc0IsRUFBRSx5Q0FBeUMsZ0NBQWdDLEVBQUUseUNBQXlDLGdDQUFnQyxFQUFFLGtFQUFrRSxnQ0FBZ0MsRUFBRSxrRUFBa0UsZ0NBQWdDLEVBQUUseUJBQXlCLHFCQUFxQixFQUFFLDRDQUE0QywwQkFBMEIsRUFBRSw2Q0FBNkMsMEJBQTBCLEVBQUUsa0RBQWtELDBCQUEwQixxQkFBcUIsRUFBRSxtREFBbUQsMEJBQTBCLHFCQUFxQixFQUFFLHVCQUF1QixxQkFBcUIsc0JBQXNCLHlCQUF5QixFQUFFLGlDQUFpQyxzQkFBc0IsRUFBRSwrQ0FBK0MsK0JBQStCLEVBQUUsOENBQThDLGdDQUFnQyxFQUFFLDRDQUE0QywrQkFBK0IsRUFBRSxtREFBbUQsNkJBQTZCLEVBQUUsK0JBQStCLDBCQUEwQixFQUFFLHdDQUF3QywwQkFBMEIsRUFBRSxxQkFBcUIsdUNBQXVDLCtCQUErQiwwQkFBMEIscUJBQXFCLEVBQUUsOEJBQThCLHNCQUFzQixFQUFFLCtCQUErQiw0QkFBNEIsdUJBQXVCLEVBQUUsZ0NBQWdDLDRCQUE0Qix1QkFBdUIsRUFBRSxrQ0FBa0MsNEJBQTRCLGtCQUFrQixFQUFFLHVDQUF1Qyw2QkFBNkIsRUFBRSwyQ0FBMkMsbUJBQW1CLG9CQUFvQixFQUFFLHNCQUFzQixvQkFBb0IsRUFBRSx1QkFBdUIsOEJBQThCLEVBQUUsNkJBQTZCLDBCQUEwQixFQUFFLDBDQUEwQywwQkFBMEIsRUFBRSw2RkFBNkYsMkJBQTJCLEVBQUUsNkNBQTZDLDBCQUEwQixFQUFFLDJEQUEyRCw0QkFBNEIsRUFBRSwyQ0FBMkMsMEJBQTBCLEVBQUUseURBQXlELDZCQUE2QixFQUFFLHlEQUF5RCw0QkFBNEIsRUFBRSwrSEFBK0gsNkJBQTZCLEVBQUUsOERBQThELDRCQUE0QixFQUFFLDRFQUE0RSw4QkFBOEIsRUFBRSw0REFBNEQsNEJBQTRCLEVBQUUsMEVBQTBFLCtCQUErQixFQUFFLDBFQUEwRSw4QkFBOEIsRUFBRSx1Q0FBdUMscUJBQXFCLHdCQUF3QixFQUFFLHVCQUF1QixvQkFBb0IsRUFBRSx3Q0FBd0Msc0JBQXNCLEVBQUUsZ0RBQWdELDJCQUEyQixFQUFFLG9FQUFvRSxnQ0FBZ0MsRUFBRSxtREFBbUQsMEJBQTBCLHFCQUFxQixFQUFFLG1EQUFtRCwwQkFBMEIscUJBQXFCLEVBQUUsOEZBQThGLDBCQUEwQixxQkFBcUIsRUFBRSxzQkFBc0IsdUJBQXVCLEVBQUUsNEJBQTRCLDBCQUEwQixFQUFFLDhCQUE4QixxQkFBcUIsRUFBRSxvREFBb0QsdUJBQXVCLFlBQVksV0FBVyxlQUFlLGNBQWMsRUFBRSxrRUFBa0Usa0JBQWtCLEVBQUUsd0ZBQXdGLHVCQUF1QixFQUFFLDRCQUE0QixhQUFhLGVBQWUsRUFBRSx1R0FBdUcsNkJBQTZCLEVBQUUsbUNBQW1DLHlEQUF5RCx5REFBeUQsRUFBRSxrQ0FBa0Msc0RBQXNELHNEQUFzRCxFQUFFLHdCQUF3QixtQkFBbUIsRUFBRSxzQkFBc0IsdUJBQXVCLGdCQUFnQixpQkFBaUIsMEJBQTBCLDJCQUEyQixtQkFBbUIsRUFBRSxpQ0FBaUMseUJBQXlCLGNBQWMscUJBQXFCLEVBQUUsMENBQTBDLG9CQUFvQix3QkFBd0IsNkJBQTZCLEVBQUUsMENBQTBDLHFCQUFxQixFQUFFLDJDQUEyQyxnQkFBZ0IsRUFBRSx3QkFBd0IscUJBQXFCLG9CQUFvQixnQkFBZ0IsMEJBQTBCLEVBQUUsbUNBQW1DLHFCQUFxQixFQUFFLDRDQUE0QyxvQkFBb0Isd0JBQXdCLDZCQUE2QixFQUFFLHdDQUF3QyxtQkFBbUIsRUFBRSxpREFBaUQsZ0JBQWdCLG9CQUFvQix5QkFBeUIsRUFBRTs7QUFFajhROzs7Ozs7Ozs7OztrQkNQZTtBQUNYblIsa0JBQWMsT0FESDtBQUVYcVIsY0FBVTtBQUNOQyxnQkFBUSxJQURGO0FBRU5DLGNBQU07QUFGQSxLQUZDO0FBTVhDLFVBQU07QUFDRkYsZ0JBQVEsSUFETjtBQUVGQyxjQUFNO0FBRkosS0FOSztBQVVYRSxjQUFVO0FBQ05DLGVBQU8sSUFERDtBQUVOQyxhQUFLLElBRkM7QUFHTkMsWUFBSSxJQUhFO0FBSU5DLGVBQU8sSUFKRDtBQUtOQyxlQUFPLEdBTEQ7QUFNTkMsY0FBTSxHQU5BO0FBT05DLGtCQUFVLEtBUEo7QUFRTkMsa0JBQVUsS0FSSjtBQVNOQyxtQkFBVyxLQVRMO0FBVU5DLG1CQUFXLEtBVkw7QUFXTkMsb0JBQVksS0FYTjtBQVlOQyxvQkFBWTtBQVpOLEtBVkM7QUF3QlhDLGdCQUFZO0FBQ1JDLHFCQUFhLE9BREw7QUFFUkMsNkJBQXFCLFVBRmI7QUFHUkMsMEJBQWtCLE1BSFY7QUFJUkMseUJBQWlCLE1BSlQ7QUFLUmYsYUFBSyxJQUxHO0FBTVJnQixvQkFBWSxNQU5KO0FBT1JDLG9CQUFZLE1BUEo7QUFRUmhCLFlBQUksSUFSSTtBQVNSQyxlQUFPLElBVEM7QUFVUmdCLDBCQUFrQixNQVZWO0FBV1JDLHdCQUFnQixNQVhSO0FBWVJDLGNBQU0sR0FaRTtBQWFSQyxnQkFBUSxHQWJBO0FBY1JDLGdCQUFRO0FBZEEsS0F4QkQ7QUF3Q1hDLFlBQVE7QUFDSnRCLFlBQUksSUFEQTtBQUVKdUIsZ0JBQVE7QUFGSixLQXhDRztBQTRDWEMsZ0JBQVk7QUFDUkMsY0FBTSxLQURFO0FBRVJDLGNBQU0sS0FGRTtBQUdSQyxjQUFNLElBSEU7QUFJUkMsY0FBTSxHQUpFO0FBS1JDLFlBQUksSUFMSTtBQU1SQyxrQkFBVTtBQU5GLEtBNUNEO0FBb0RYQyxXQUFPO0FBQ0g5QixlQUFPO0FBREosS0FwREk7QUF1RFgrQixZQUFRO0FBQ0pDLDJCQUFtQixLQURmO0FBRUpDLGlDQUF5QixLQUZyQjtBQUdKQyx5QkFBaUI7QUFIYixLQXZERztBQTREWEMsV0FBTztBQUNIbEksZUFBTyxNQURKO0FBRUg4RixZQUFJLElBRkQ7QUFHSHFDLGVBQU8sSUFISjtBQUlIQyxhQUFLLElBSkY7QUFLSEMsY0FBTSxJQUxIO0FBTUgvSCxrQkFBVSxLQU5QO0FBT0hnSSxnQkFBUSxLQVBMO0FBUUhDLGdCQUFRLElBUkw7QUFTSEMsbUJBQVc7QUFUUixLQTVESTtBQXVFWEMsZ0JBQVk7QUFDUmhDLHFCQUFhLE9BREw7QUFFUlYsZUFBTyxJQUZDO0FBR1JrQixjQUFNLEdBSEU7QUFJUkMsZ0JBQVEsR0FKQTtBQUtSQyxnQkFBUTtBQUxBLEtBdkVEO0FBOEVYdUIsY0FBVTtBQUNOQyxlQUFPLEdBREQ7QUFFTjFTLGNBQU0sR0FGQTtBQUdOMlMsaUJBQVMsTUFISDtBQUlOQywyQkFBbUI7QUFKYixLQTlFQztBQW9GWEMsWUFBUTtBQUNKQyxjQUFNO0FBQ0YxQixvQkFBUSxJQUROO0FBRUYyQixzQkFBVTtBQUZSLFNBREY7QUFLSkMsY0FBTTtBQUNGQyxrQkFBTSxpQkFESjtBQUVGQyxrQkFBTTtBQUZKO0FBTEYsS0FwRkc7QUE4RlhDLFlBQVE7QUFDSkMsb0JBQVk7QUFEUjtBQTlGRyxDOzs7Ozs7Ozs7O0FDQWY7O0FBQ0EseUI7Ozs7Ozs7Ozs7O0FDREE7Ozs7QUFDQTs7Ozs7O0FBRUFDLG1CQUFTQyxLQUFULEdBQWlCQSx1QkFBakI7O2tCQUVlRCxrQjs7Ozs7Ozs7OztBQ0xmOztBQUNBOztBQUNBLHlCOzs7Ozs7Ozs7Ozs7O2tCQ0Z3QnJVLGU7QUFBVCxTQUFTQSxlQUFULENBQXlCbkMsS0FBekIsRUFBZ0MwTyxPQUFoQyxFQUF5Q3RNLFdBQXpDLEVBQXNEO0FBQUEsUUFDekRuQyxNQUR5RCxHQUMzQkQsS0FEMkIsQ0FDekRDLE1BRHlEO0FBQUEsUUFDakRDLE1BRGlELEdBQzNCRixLQUQyQixDQUNqREUsTUFEaUQ7QUFBQSxRQUN6Q0MsSUFEeUMsR0FDM0JILEtBRDJCLENBQ3pDRyxJQUR5QztBQUFBLFFBQ25DRSxHQURtQyxHQUMzQkwsS0FEMkIsQ0FDbkNLLEdBRG1DO0FBQUEsUUFFekRDLFVBRnlELEdBRUVvTyxPQUZGLENBRXpEcE8sVUFGeUQ7QUFBQSxRQUU3Q0MsVUFGNkMsR0FFRW1PLE9BRkYsQ0FFN0NuTyxVQUY2QztBQUFBLFFBRWpDQyxRQUZpQyxHQUVFa08sT0FGRixDQUVqQ2xPLFFBRmlDO0FBQUEsUUFFdkJFLFdBRnVCLEdBRUVnTyxPQUZGLENBRXZCaE8sV0FGdUI7QUFBQSxRQUVWRCxPQUZVLEdBRUVpTyxPQUZGLENBRVZqTyxPQUZVOzs7QUFJakUsUUFBTWlXLFlBQVl6VyxVQUFVSyxVQUE1Qjs7QUFFQSxRQUFJcVcsMEJBQUo7QUFDQSxRQUFJcFcsVUFBSixFQUFnQjtBQUNab1csNEJBQW9CcFcsV0FBVzZCLFdBQVgsQ0FBcEI7QUFDQSxZQUFJdVUsaUJBQUosRUFBdUI7QUFDbkJBLDhCQUFrQnZWLFlBQWxCLEdBQWlDYixXQUFXYSxZQUE1QztBQUNIO0FBQ0o7QUFDRCxRQUFJd1Ysa0JBQUo7QUFDQSxRQUFJMVcsTUFBSixFQUFZO0FBQ1IwVyxpQ0FBa0JELHFCQUFxQixFQUF2QyxFQUErQ3pXLE1BQS9DO0FBQ0gsS0FGRCxNQUVPLElBQUl5VyxpQkFBSixFQUF1QjtBQUMxQkMsb0JBQVlELGlCQUFaO0FBQ0g7O0FBRUQsUUFBTUUsVUFBVSxPQUFPMVcsSUFBUCxLQUFnQixTQUFoQixHQUE0QkEsSUFBNUIsR0FBbUNLLFFBQW5EO0FBQ0EsUUFBTXNXLFNBQVMsT0FBT3pXLEdBQVAsS0FBZSxTQUFmLEdBQTJCQSxHQUEzQixHQUFpQ0ksT0FBaEQ7O0FBRUEsV0FBTztBQUNIUixnQkFBUXlXLFNBREw7QUFFSHhXLGdCQUFRMFcsU0FGTDtBQUdIelcsY0FBTTBXLE9BSEg7QUFJSHhXLGFBQUt5VyxNQUpGO0FBS0gxVyxpQkFBU007QUFMTixLQUFQO0FBT0g7Ozs7Ozs7Ozs7Ozs7OztRQ1plcVcsUSxHQUFBQSxRO1FBcUJBekksUSxHQUFBQSxRO1FBcUJBQyxXLEdBQUFBLFc7UUFzQkF5SSxXLEdBQUFBLFc7UUE2RkFDLFEsR0FBQUEsUTtRQWlDQUMsUSxHQUFBQSxRO1FBc0JBQyxTLEdBQUFBLFM7UUF5QkFDLFMsR0FBQUEsUzs7QUEvUGhCOztBQUNBOztBQUVBOzs7O0FBSU8sSUFBTUMsMEJBQVMsT0FBTzdYLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUMsQ0FBQyxDQUFDQSxPQUFPd1IsUUFBMUMsSUFBc0QsQ0FBQyxDQUFDQSxTQUFTc0csYUFBaEY7O0FBRVA7Ozs7Ozs7OztBQVNPLFNBQVNQLFFBQVQsQ0FBbUJ0RyxJQUFuQixFQUF5QjdLLFNBQXpCLEVBQW9DO0FBQ3ZDO0FBQ0EsUUFBSSxDQUFDeVIsTUFBRCxJQUFXLENBQUM1RyxJQUFoQixFQUFzQjtBQUNsQixlQUFPLEtBQVA7QUFDSDs7QUFFRCxRQUFJQSxLQUFLOEcsU0FBVCxFQUFvQjtBQUNoQixlQUFPOUcsS0FBSzhHLFNBQUwsQ0FBZUMsUUFBZixDQUF3QjVSLFNBQXhCLENBQVA7QUFDSCxLQUZELE1BRU87QUFDSCxlQUFPNkssS0FBSzdLLFNBQUwsQ0FBZVosT0FBZixDQUF1QlksU0FBdkIsSUFBb0MsQ0FBQyxDQUE1QztBQUNIO0FBQ0o7O0FBRUQ7Ozs7Ozs7O0FBUU8sU0FBUzBJLFFBQVQsQ0FBbUJtQyxJQUFuQixFQUF5QjdLLFNBQXpCLEVBQW9DNlIsTUFBcEMsRUFBNEM7QUFDL0M7QUFDQSxRQUFJLENBQUNKLE1BQUQsSUFBVyxDQUFDNUcsSUFBaEIsRUFBc0I7QUFDbEI7QUFDSDs7QUFFRCxRQUFJQSxLQUFLOEcsU0FBVCxFQUFvQjtBQUNoQjlHLGFBQUs4RyxTQUFMLENBQWUxWCxHQUFmLENBQW1CK0YsU0FBbkI7QUFDSCxLQUZELE1BRU8sSUFBSTZSLFdBQVcsSUFBWCxJQUFtQixDQUFDVixTQUFTdEcsSUFBVCxFQUFlN0ssU0FBZixDQUF4QixFQUFtRDtBQUN0RDZLLGFBQUs3SyxTQUFMLFVBQXNCQSxTQUF0QjtBQUNIO0FBQ0o7O0FBRUQ7Ozs7Ozs7O0FBUU8sU0FBUzJJLFdBQVQsQ0FBc0JrQyxJQUF0QixFQUE0QjdLLFNBQTVCLEVBQXVDNlIsTUFBdkMsRUFBK0M7QUFDbEQ7QUFDQSxRQUFJLENBQUNKLE1BQUQsSUFBVyxDQUFDNUcsSUFBaEIsRUFBc0I7QUFDbEI7QUFDSDs7QUFFRCxRQUFJQSxLQUFLOEcsU0FBVCxFQUFvQjtBQUNoQjlHLGFBQUs4RyxTQUFMLENBQWV0VyxNQUFmLENBQXNCMkUsU0FBdEI7QUFDSCxLQUZELE1BRU8sSUFBSTZSLFdBQVcsSUFBWCxJQUFtQlYsU0FBU3RHLElBQVQsRUFBZTdLLFNBQWYsQ0FBdkIsRUFBa0Q7QUFDckQ2SyxhQUFLN0ssU0FBTCxHQUFpQjZLLEtBQUs3SyxTQUFMLENBQWVjLE9BQWYsQ0FBdUJkLFNBQXZCLEVBQWtDLEVBQWxDLEVBQXNDYyxPQUF0QyxDQUE4QyxNQUE5QyxFQUFzRCxHQUF0RCxFQUEyRGdSLElBQTNELEVBQWpCO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7O0FBU08sU0FBU1YsV0FBVCxDQUFzQnZHLElBQXRCLEVBQTRCN0ssU0FBNUIsRUFBdUM7QUFDMUM7QUFDQSxRQUFJLENBQUN5UixNQUFELElBQVcsQ0FBQzVHLElBQWhCLEVBQXNCO0FBQ2xCLGVBQU8sS0FBUDtBQUNIOztBQUVELFFBQUlBLEtBQUs4RyxTQUFULEVBQW9CO0FBQ2hCLGVBQU85RyxLQUFLOEcsU0FBTCxDQUFlSSxNQUFmLENBQXNCL1IsU0FBdEIsQ0FBUDtBQUNILEtBRkQsTUFFTztBQUNILFlBQU1nUyxPQUFPYixTQUFTdEcsSUFBVCxFQUFlN0ssU0FBZixDQUFiO0FBQ0FnUyxlQUFPckosWUFBWWtDLElBQVosRUFBa0I3SyxTQUFsQixFQUE2QixJQUE3QixDQUFQLEdBQTRDMEksU0FBU21DLElBQVQsRUFBZTdLLFNBQWYsRUFBMEIsSUFBMUIsQ0FBNUM7O0FBRUEsZUFBTyxDQUFDZ1MsSUFBUjtBQUNIO0FBQ0o7O0FBRUQ7Ozs7Ozs7OztBQVNPLElBQU1DLDRCQUFVLFlBQVk7QUFDL0IsUUFBSUMsWUFBWSxJQUFoQjtBQUNBO0FBQ0EsUUFBSVQsTUFBSixFQUFZO0FBQ1IsWUFBTVUsUUFBUS9HLFNBQVNnSCxJQUFULElBQWlCaEgsU0FBU2lILElBQXhDO0FBQ0FILG9CQUFZQyxNQUFNRixPQUFOLEdBQWdCLFNBQWhCLEdBQ1JFLE1BQU1HLHFCQUFOLEdBQThCLHVCQUE5QixHQUNJSCxNQUFNSSxpQkFBTixHQUEwQixtQkFBMUIsR0FDSUosTUFBTUssa0JBQU4sR0FBMkIsb0JBQTNCLEdBQWtELElBSDlEO0FBSUg7O0FBRUQsV0FBTyxVQUFVM0gsSUFBVixFQUFnQjRILFFBQWhCLEVBQTBCO0FBQzdCLFlBQUksQ0FBQ2hCLE1BQUQsSUFBVyxDQUFDNUcsSUFBaEIsRUFBc0I7QUFDbEIsbUJBQU8sS0FBUDtBQUNIOztBQUVELGVBQU9xSCxZQUFZckgsS0FBS3FILFNBQUwsRUFBZ0JPLFFBQWhCLENBQVosR0FBd0MsS0FBL0M7QUFDSCxLQU5EO0FBT0gsQ0FsQnNCLEVBQWhCOztBQW9CUDs7Ozs7O0FBTUEsU0FBU0MsaUJBQVQsQ0FBNEI3SCxJQUE1QixFQUFrQztBQUM5QixXQUFPQSxRQUFRQSxLQUFLOEgsUUFBTCxLQUFrQixDQUExQixHQUE4Qi9ZLE9BQU9nWixnQkFBUCxDQUF3Qi9ILElBQXhCLEVBQThCLElBQTlCLENBQTlCLEdBQW9FLEVBQTNFO0FBQ0g7O0FBRUQsSUFBTWdJLGdCQUFnQixrREFBdEI7QUFDQSxJQUFNQyxjQUFjLEVBQUMzRyxNQUFNLENBQVAsRUFBVTRHLEtBQUssQ0FBZixFQUFrQkMsT0FBTyxDQUF6QixFQUE0QkMsUUFBUSxDQUFwQyxFQUFwQjs7QUFFQTs7Ozs7OztBQU9BLFNBQVNDLGNBQVQsQ0FBeUJySSxJQUF6QixFQUErQi9LLElBQS9CLEVBQXFDa0MsS0FBckMsRUFBNEM7QUFDeENsQyxXQUFPQSxLQUFLcVQsV0FBTCxFQUFQOztBQUVBLFFBQUluUixVQUFVLE1BQWQsRUFBc0I7QUFDbEIsWUFBSWxDLFNBQVMsUUFBYixFQUF1QjtBQUNuQixtQkFBTytLLEtBQUtoSCxZQUFMLElBQXFCLENBQTVCO0FBQ0g7QUFDRCxZQUFJL0QsU0FBUyxPQUFiLEVBQXNCO0FBQ2xCLG1CQUFPK0ssS0FBS3VJLFdBQUwsSUFBb0IsQ0FBM0I7QUFDSDtBQUNKOztBQUVELFFBQUksRUFBRXRULFFBQVFnVCxXQUFWLENBQUosRUFBNEI7QUFDeEI7QUFDQUEsb0JBQVloVCxJQUFaLElBQW9CK1MsY0FBY1EsSUFBZCxDQUFtQnZULElBQW5CLENBQXBCO0FBQ0g7O0FBRUQsV0FBT2dULFlBQVloVCxJQUFaLElBQXFCd1QsV0FBV3RSLEtBQVgsS0FBcUIsQ0FBMUMsR0FBK0NBLEtBQXREO0FBQ0g7O0FBRUQsSUFBTXVSLFdBQVcsRUFBQ0MsVUFBVSxDQUFYLEVBQWNDLFlBQVksQ0FBMUIsRUFBNkJDLE9BQU8sQ0FBcEMsRUFBakI7O0FBRUE7Ozs7OztBQU1PLFNBQVNyQyxRQUFULENBQW1CeEcsSUFBbkIsRUFBeUI4SSxJQUF6QixFQUErQjtBQUNsQztBQUNBLFFBQUksQ0FBQ2xDLE1BQUQsSUFBVyxDQUFDNUcsSUFBaEIsRUFBc0I7QUFDbEIsZUFBTyxJQUFQO0FBQ0g7O0FBRUQsUUFBTXpGLFFBQVFzTixrQkFBa0I3SCxJQUFsQixDQUFkOztBQUVBO0FBQ0EsUUFBSS9SLFVBQVVDLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEI7QUFDeEIsZUFBT3FNLEtBQVA7QUFDSDs7QUFFRHVPLFdBQU9KLFNBQVNJLElBQVQsSUFBaUIsY0FBYzlJLEtBQUt6RixLQUFuQixHQUEyQixVQUEzQixHQUF3QyxZQUF6RCxHQUF3RXVPLElBQS9FOztBQUVBLFdBQU9ULGVBQWVySSxJQUFmLEVBQXFCOEksSUFBckIsRUFBMkJ2TyxNQUFNd08sZ0JBQU4sQ0FBdUIsdUJBQVVELElBQVYsQ0FBdkIsS0FBMkM5SSxLQUFLekYsS0FBTCxDQUFXLHVCQUFVdU8sSUFBVixDQUFYLENBQXRFLENBQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7O0FBZU8sU0FBU3JDLFFBQVQsQ0FBbUJ6RyxJQUFuQixFQUF5QjhJLElBQXpCLEVBQStCM1IsS0FBL0IsRUFBc0M7QUFDekM7QUFDQSxRQUFJLENBQUN5UCxNQUFELElBQVcsQ0FBQzVHLElBQWhCLEVBQXNCO0FBQ2xCLGVBQU8sS0FBUDtBQUNIOztBQUVEO0FBQ0EsUUFBSSxRQUFPOEksSUFBUCx5Q0FBT0EsSUFBUCxPQUFnQixRQUFoQixJQUE0QjdhLFVBQVVDLE1BQVYsS0FBcUIsQ0FBckQsRUFBd0Q7QUFDcEQsMEJBQUs0YSxJQUFMLEVBQVcsVUFBQ2pVLEdBQUQsRUFBTW5HLEdBQU47QUFBQSxtQkFBYytYLFNBQVN6RyxJQUFULEVBQWV0UixHQUFmLEVBQW9CbUcsR0FBcEIsQ0FBZDtBQUFBLFNBQVg7QUFDSCxLQUZELE1BRU87QUFDSGlVLGVBQU9KLFNBQVNJLElBQVQsSUFBaUIsY0FBYzlJLEtBQUt6RixLQUFuQixHQUEyQixVQUEzQixHQUF3QyxZQUF6RCxHQUF3RXVPLElBQS9FO0FBQ0EsWUFBSSxPQUFPM1IsS0FBUCxLQUFpQixRQUFqQixJQUE2QjZRLGNBQWNRLElBQWQsQ0FBbUJNLElBQW5CLENBQWpDLEVBQTJEO0FBQ3ZEM1Isb0JBQVdBLEtBQVg7QUFDSDtBQUNENkksYUFBS3pGLEtBQUwsQ0FBVyx1QkFBVXVPLElBQVYsQ0FBWCxJQUE4QjNSLEtBQTlCLENBTEcsQ0FLa0M7QUFDeEM7QUFDSjs7QUFFRDs7OztBQUlPLFNBQVN1UCxTQUFULEdBQXNCO0FBQ3pCLFFBQU1zQyxZQUFZekksU0FBU3NHLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBbEI7O0FBRUFKLGFBQVN1QyxTQUFULEVBQW9CO0FBQ2hCQyxrQkFBVSxVQURNO0FBRWhCN0ssZUFBTyxPQUZTO0FBR2hCOEssZ0JBQVEsT0FIUTtBQUloQkMsa0JBQVUsUUFKTTtBQUtoQmpCLGFBQUs7QUFMVyxLQUFwQjtBQU9BM0gsYUFBU2dILElBQVQsQ0FBYzZCLFdBQWQsQ0FBMEJKLFNBQTFCO0FBQ0EsUUFBTUssaUJBQWlCTCxVQUFVVCxXQUFWLEdBQXdCUyxVQUFVTSxXQUF6RDtBQUNBLFFBQU1DLGtCQUFrQlAsVUFBVWhRLFlBQVYsR0FBeUJnUSxVQUFVclEsWUFBM0Q7QUFDQTRILGFBQVNnSCxJQUFULENBQWNpQyxXQUFkLENBQTBCUixTQUExQjs7QUFFQSxXQUFPO0FBQ0g1SyxlQUFPaUwsY0FESjtBQUVISCxnQkFBUUs7QUFGTCxLQUFQO0FBSUg7O0FBRUQ7Ozs7QUFJTyxTQUFTNUMsU0FBVCxDQUFvQjNHLElBQXBCLEVBQTBCO0FBQzdCLFFBQU15SixPQUFPekosS0FBSzBKLHFCQUFMLEVBQWI7QUFDQSxRQUFNQyxNQUFNM0osS0FBSzRKLGFBQUwsQ0FBbUJDLFdBQS9CO0FBQ0EsV0FBTztBQUNIM0IsYUFBS3VCLEtBQUt2QixHQUFMLEdBQVd5QixJQUFJRyxXQURqQjtBQUVIeEksY0FBTW1JLEtBQUtuSSxJQUFMLEdBQVlxSSxJQUFJSTtBQUZuQixLQUFQO0FBSUgsQzs7Ozs7Ozs7OztRQ2pRZUMsUyxHQUFBQSxTO1FBWUFDLFMsR0FBQUEsUztBQWpCaEI7Ozs7O0FBS08sU0FBU0QsU0FBVCxDQUFvQjNjLEdBQXBCLEVBQXlCO0FBQzVCLFFBQUksQ0FBQyxJQUFJbWIsSUFBSixDQUFTbmIsR0FBVCxDQUFMLEVBQW9CO0FBQ2hCLGVBQU9BLE9BQU8sRUFBZDtBQUNIO0FBQ0QsV0FBT0EsSUFBSWliLFdBQUosR0FBa0JyUyxPQUFsQixDQUEwQixXQUExQixFQUF1QyxVQUFDaVUsRUFBRCxFQUFLQyxFQUFMO0FBQUEsZUFBWUEsR0FBR0MsV0FBSCxFQUFaO0FBQUEsS0FBdkMsQ0FBUDtBQUNIOztBQUVEOzs7OztBQUtPLFNBQVNILFNBQVQsQ0FBb0I1YyxHQUFwQixFQUF5QjtBQUM1QixXQUFPQSxJQUFJNEksT0FBSixDQUFZLFVBQVosRUFBd0I7QUFBQSxxQkFBVWlVLEdBQUc1QixXQUFILEVBQVY7QUFBQSxLQUF4QixDQUFQO0FBQ0gsQzs7Ozs7Ozs7OztBQ25CRDs7Ozs7QUFLTyxJQUFNK0IsZ0NBQVksT0FBTzlKLFFBQVAsS0FBb0IsV0FBcEIsR0FBa0NBLFNBQVMrSixZQUEzQyxHQUEwREMsU0FBNUU7O0FBRVA7Ozs7QUFJTyxJQUFNQyxzQ0FBZSxTQUFmQSxZQUFlLEdBQU07QUFDOUIsUUFBTUMsaUJBQWlCLFlBQXZCO0FBQ0EsUUFBSUMsU0FBUyxLQUFiO0FBQ0EsUUFBSTtBQUNBLFlBQUloZixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUI2ZSxjQUE3QixFQUE2QztBQUN6Q0MscUJBQVMsSUFBVDtBQUNIO0FBQ0osS0FKRCxDQUlFLE9BQU9qSyxHQUFQLEVBQVk7QUFDVjtBQUNIOztBQUVELFFBQUksQ0FBQ2lLLE1BQUwsRUFBYTtBQUNULFlBQUk7QUFDQSxnQkFBSTNiLE9BQU9yRCxPQUFQLENBQWVDLEdBQWYsQ0FBbUJDLFFBQW5CLEtBQWdDNmUsY0FBcEMsRUFBb0Q7QUFDaERDLHlCQUFTLElBQVQ7QUFDSDtBQUNKLFNBSkQsQ0FJRSxPQUFPakssR0FBUCxFQUFZO0FBQ1Y7QUFDSDtBQUNKOztBQUdELFdBQU9pSyxNQUFQO0FBQ0gsQ0F2Qk07O2tCQXlCUTtBQUNYTCx3QkFEVztBQUVYRztBQUZXLEM7Ozs7Ozs7Ozs7O2tCQ3BDQTtBQUNYRyxlQUFXLENBREE7QUFFWEMsU0FBSyxDQUZNO0FBR1hDLFdBQU8sRUFISTtBQUlYQyxXQUFPLEVBSkk7QUFLWEMsVUFBTSxFQUxLO0FBTVhDLFNBQUssRUFOTTtBQU9YQyxTQUFLLEVBUE07QUFRWC9KLFdBQU8sRUFSSTtBQVNYZ0ssU0FBSyxFQVRNO0FBVVhDLFVBQU0sRUFWSztBQVdYQyxVQUFNLEVBWEs7QUFZWEMsUUFBSSxFQVpPO0FBYVhDLFdBQU8sRUFiSTtBQWNYQyxVQUFNLEVBZEs7O0FBZ0JYO0FBQ0FDLFlBQVEsRUFqQkc7QUFrQlhDLGdCQUFZLEVBbEJEO0FBbUJYQyxjQUFVLEVBbkJDO0FBb0JYQyxpQkFBYSxFQXBCRjtBQXFCWEMsZ0JBQVksRUFyQkQ7O0FBdUJYO0FBQ0FDLGFBQVMsRUF4QkU7QUF5QlhDLFlBQVEsRUF6Qkc7QUEwQlhDLFNBQUssRUExQk07QUEyQlhDLGFBQVMsRUEzQkU7QUE0QlhDLFlBQVE7QUE1QkcsQzs7Ozs7Ozs7Ozs7O0FDQWYsSUFBSUMsYUFBYTVmLG1CQUFPQSxDQUFDLEVBQVIsQ0FBakI7QUFDQSxJQUFJdUIsaUJBQWlCdUcsT0FBTzRCLFNBQVAsQ0FBaUJuSSxjQUF0Qzs7QUFFQSxTQUFTb0gsSUFBVCxDQUFja1gsQ0FBZCxFQUFpQjtBQUNmLFNBQU83ZCxNQUFNQyxPQUFOLENBQWM0ZCxDQUFkLElBQW1CLE9BQW5CLFVBQW9DQSxDQUFwQyx5Q0FBb0NBLENBQXBDLENBQVA7QUFDRDs7QUFFRCxTQUFTQyxhQUFULENBQXVCRCxDQUF2QixFQUEwQkUsQ0FBMUIsRUFBNkI7QUFDM0IsTUFBSUMsVUFBVXJYLEtBQUtrWCxDQUFMLENBQWQ7QUFDQSxNQUFJSSxVQUFVdFgsS0FBS29YLENBQUwsQ0FBZDs7QUFFQSxNQUFJQyxZQUFZQyxPQUFoQixFQUF5QixPQUFPLEtBQVA7O0FBRXpCLFVBQVFELE9BQVI7QUFDRSxTQUFLLE9BQUw7QUFDRSxVQUFJSCxFQUFFamUsTUFBRixLQUFhbWUsRUFBRW5lLE1BQW5CLEVBQTJCLE9BQU8sS0FBUDtBQUMzQixXQUFLLElBQUlGLElBQUksQ0FBYixFQUFnQkEsSUFBSW1lLEVBQUVqZSxNQUF0QixFQUE4QkYsR0FBOUIsRUFBbUM7QUFDakMsWUFBSSxDQUFDb2UsY0FBY0QsRUFBRW5lLENBQUYsQ0FBZCxFQUFvQnFlLEVBQUVyZSxDQUFGLENBQXBCLENBQUwsRUFBZ0MsT0FBTyxLQUFQO0FBQ2pDO0FBQ0QsYUFBTyxJQUFQO0FBQ0YsU0FBSyxRQUFMO0FBQ0UsVUFBSSxDQUFDbWUsQ0FBRCxJQUFNLENBQUNFLENBQVgsRUFBYyxPQUFPRixNQUFNRSxDQUFiO0FBQ2QsVUFBSUYsRUFBRWxYLElBQUYsS0FBV29YLEVBQUVwWCxJQUFqQixFQUF1QixPQUFPLEtBQVA7QUFDdkIsVUFBSWtYLEVBQUV6ZCxHQUFGLEtBQVUyZCxFQUFFM2QsR0FBaEIsRUFBcUIsT0FBTyxLQUFQO0FBQ3JCLFVBQUl5ZCxFQUFFSyxHQUFGLEtBQVVILEVBQUVHLEdBQWhCLEVBQXFCLE9BQU8sS0FBUDtBQUNyQixhQUFPQyxxQkFBcUJOLEVBQUU1YyxLQUF2QixFQUE4QjhjLEVBQUU5YyxLQUFoQyxDQUFQO0FBQ0E7QUFDRjtBQUNFLGFBQU80YyxNQUFNRSxDQUFiO0FBZko7QUFpQkQ7O0FBRUQsU0FBU0ksb0JBQVQsQ0FBOEJOLENBQTlCLEVBQWlDRSxDQUFqQyxFQUFvQztBQUNsQyxNQUFJSyxTQUFTLENBQWI7QUFDQSxNQUFJQyxTQUFTLENBQWI7O0FBRUEsT0FBSyxJQUFJamUsR0FBVCxJQUFnQnlkLENBQWhCLEVBQW1CO0FBQ2pCLFFBQUl0ZSxlQUFlYyxJQUFmLENBQW9Cd2QsQ0FBcEIsRUFBdUJ6ZCxHQUF2QixDQUFKLEVBQWlDO0FBQy9CLFVBQUlBLFFBQVEsT0FBWixFQUFxQjtBQUNuQjtBQUNBO0FBQ0EsWUFBSSxDQUFDd2QsV0FBV0MsRUFBRXpkLEdBQUYsQ0FBWCxFQUFtQjJkLEVBQUUzZCxHQUFGLENBQW5CLENBQUwsRUFBaUMsT0FBTyxLQUFQO0FBQ2xDLE9BSkQsTUFJTyxJQUFJQSxRQUFRLFVBQVosRUFBd0I7QUFDN0I7QUFDRCxPQUZNLE1BRUE7QUFDTCxZQUFJeWQsRUFBRXpkLEdBQUYsTUFBVzJkLEVBQUUzZCxHQUFGLENBQWYsRUFBdUIsT0FBTyxLQUFQO0FBQ3hCO0FBQ0RnZTtBQUNEO0FBQ0Y7O0FBRUQsT0FBSyxJQUFJaGUsR0FBVCxJQUFnQjJkLENBQWhCLEVBQW1CO0FBQ2pCLFFBQUl4ZSxlQUFlYyxJQUFmLENBQW9CMGQsQ0FBcEIsRUFBdUIzZCxHQUF2QixDQUFKLEVBQWlDO0FBQy9CaWU7QUFDRDtBQUNGOztBQUVELE1BQUlELFdBQVdDLE1BQWYsRUFBdUIsT0FBTyxLQUFQOztBQUV2QjtBQUNBLFNBQU9QLGNBQWNELEVBQUVwYixRQUFoQixFQUEwQnNiLEVBQUV0YixRQUE1QixDQUFQO0FBQ0Q7O0FBRUQzRSxPQUFPQyxPQUFQLEdBQWlCb2dCLG9CQUFqQixDOzs7Ozs7Ozs7Ozs7Ozs7O0FDL0RBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7OztJQUVRRyxpQixHQUEyRHJmLFcsQ0FBM0RxZixpQjtJQUFtQkMsZ0IsR0FBd0N0ZixXLENBQXhDc2YsZ0I7SUFBa0JDLGlCLEdBQXNCdmYsVyxDQUF0QnVmLGlCO0lBQ3JDQyxTLEdBQTZCN2YsVSxDQUE3QjZmLFM7SUFBVy9SLEksR0FBa0I5TixVLENBQWxCOE4sSTtJQUFNekQsTyxHQUFZckssVSxDQUFacUssTzs7O0FBRXpCLElBQU15VixrQkFBa0IsU0FBbEJBLGVBQWtCLENBQVMzYixPQUFULEVBQWtCO0FBQ3RDLFFBQUk7QUFDQSxZQUFNNGIsaUJBQWlCbGUsT0FBT2daLGdCQUFQLENBQXdCMVcsT0FBeEIsRUFBaUMscUJBQWpDLENBQXZCO0FBQ0EsZUFBTyxDQUFDNGIsY0FBRCxJQUFtQkEsZUFBZWxFLGdCQUFmLENBQWdDLFNBQWhDLE1BQStDLE1BQXpFO0FBQ0gsS0FIRCxDQUdFLE9BQU9yWSxDQUFQLEVBQVU7QUFDUjtBQUNIOztBQUVELFdBQU8sSUFBUDtBQUNILENBVEQ7QUFVQSxJQUFNd2MsWUFBWSxTQUFaQSxTQUFZLEdBQU07QUFDcEIsUUFBTUMsTUFBTTVNLFNBQVM2TSxlQUFyQjtBQUNBLFdBQU9ELElBQUl6VSxZQUFKLEdBQW1CeVUsSUFBSXhVLFlBQXZCLElBQXVDM0wsVUFBSTBaLFNBQUosR0FBZ0J0SSxLQUFoQixHQUF3QixDQUEvRCxJQUFvRTRPLGdCQUFnQnpNLFNBQVM2TSxlQUF6QixDQUFwRSxJQUFpSEosZ0JBQWdCek0sU0FBU2dILElBQXpCLENBQXhIO0FBQ0gsQ0FIRDtBQUlBLElBQU04RixXQUFXLENBQUMsVUFBRCxFQUFhLE9BQWIsRUFBc0IsS0FBdEIsRUFBNkIsS0FBN0IsRUFBb0MsRUFBcEMsQ0FBakI7QUFDQSxJQUFNQyxtQkFBbUIsU0FBbkJBLGdCQUFtQixDQUFDdE4sSUFBRCxFQUFPOEksSUFBUCxFQUFnQjtBQUNyQyxRQUFNdk8sUUFBUXhMLE9BQU9nWixnQkFBUCxDQUF3Qi9ILElBQXhCLENBQWQ7QUFDQSxRQUFJakosTUFBTSxFQUFWO0FBQ0EsU0FBSyxJQUFJL0ksSUFBSSxDQUFiLEVBQWdCQSxJQUFJcWYsU0FBU25mLE1BQTdCLEVBQXFDRixHQUFyQyxFQUEwQztBQUN0QytJLGNBQU13RCxNQUFNd08sZ0JBQU4sQ0FBdUJzRSxTQUFTcmYsQ0FBVCxJQUFjOGEsSUFBckMsQ0FBTjtBQUNBLFlBQUkvUixHQUFKLEVBQVM7QUFDTDtBQUNIO0FBQ0o7QUFDRCxXQUFPQSxHQUFQO0FBQ0gsQ0FWRDs7QUFZQSxJQUFNd1csU0FBUyxFQUFmO0FBQ0EsSUFBSUMsc0JBQUo7QUFBQSxJQUFtQkMseUJBQW5COztBQUVBOzs7SUFHcUI5UyxPOzs7QUFnS2pCLHFCQUFZcEwsS0FBWixFQUFtQjtBQUFBOztBQUFBLHFEQUNmLHNCQUFNQSxLQUFOLENBRGU7O0FBQUEsY0F5WW5CbWUsY0F6WW1CLEdBeVlGLFVBQUNsQixHQUFELEVBQVM7QUFDdEIsa0JBQUttQixVQUFMLEdBQWtCbkIsR0FBbEI7QUFDSCxTQTNZa0I7O0FBQUEsY0E2WW5Cb0IsY0E3WW1CLEdBNllGLFVBQUNwQixHQUFELEVBQVM7QUFDdEIsa0JBQUtxQixVQUFMLEdBQWtCckIsR0FBbEI7QUFDSCxTQS9Za0I7O0FBR2YsY0FBS2pVLEtBQUwsR0FBYTtBQUNUdVYscUJBQVN2ZSxNQUFNdWUsT0FETjtBQUVUQyxvQkFBUSxNQUZDO0FBR1RDLHVCQUFXLE1BQUtDLFlBQUwsQ0FBa0IxZSxLQUFsQjtBQUhGLFNBQWI7O0FBTUEsY0FBSzJlLFNBQUwsR0FBaUIzZSxNQUFNNE8sS0FBdkI7O0FBRUE1Ryx1QkFBYyxDQUNWLGdCQURVLEVBRVYsa0JBRlUsRUFHVix1QkFIVSxFQUlWLHFCQUpVLEVBS1YsaUJBTFUsRUFNVixZQU5VLEVBT1YsYUFQVSxDQUFkOztBQVVBLGNBQUs0VyxVQUFMLEdBQWtCLEVBQWxCO0FBckJlO0FBc0JsQjs7c0JBRURqZSxrQixpQ0FBcUI7QUFDakIsWUFBSSxLQUFLWCxLQUFMLENBQVd1ZSxPQUFmLEVBQXdCO0FBQ3BCLGlCQUFLTSxVQUFMO0FBQ0EsaUJBQUs3ZSxLQUFMLENBQVc2ZSxVQUFYOztBQUVBLGdCQUFJLEtBQUs3VixLQUFMLENBQVd5VixTQUFYLElBQXdCMWdCLGNBQVEwZ0IsU0FBcEMsRUFBK0M7QUFDM0MscUJBQUtLLEtBQUw7QUFDSDtBQUNKO0FBQ0osSzs7c0JBRUQ1VyxpQixnQ0FBb0I7QUFDaEIsYUFBS25ILGtCQUFMLENBQXdCLEVBQUV3ZCxTQUFTLEtBQVgsRUFBeEI7QUFDQSxhQUFLUSxpQkFBTDs7QUFFQUMsMEJBQWVDLFVBQWYsQ0FBMEIsSUFBMUI7O0FBRUEsWUFBSSxLQUFLalcsS0FBTCxDQUFXdVYsT0FBZixFQUF3QjtBQUNwQixpQkFBS1csVUFBTCxHQUFrQixJQUFsQjtBQUNIO0FBQ0osSzs7c0JBRURyZSx5QixzQ0FBMEJDLFMsRUFBVztBQUNqQyxZQUFJLENBQUMsS0FBS29lLFVBQU4sSUFBb0JwZSxVQUFVeWQsT0FBbEMsRUFBMkM7QUFDdkMsaUJBQUtXLFVBQUwsR0FBa0IsSUFBbEI7QUFDSDs7QUFFRCxZQUFNQyxXQUFXLENBQUMsS0FBS25mLEtBQUwsQ0FBV3VlLE9BQVosSUFBdUJ6ZCxVQUFVeWQsT0FBbEQ7QUFDQSxZQUFNYSxZQUFZLEtBQUtwZixLQUFMLENBQVd1ZSxPQUFYLElBQXNCLENBQUN6ZCxVQUFVeWQsT0FBbkQ7QUFDQSxZQUFJWSxRQUFKLEVBQWM7QUFDVixpQkFBS04sVUFBTDtBQUNBL2Qsc0JBQVUrZCxVQUFWO0FBQ0gsU0FIRCxNQUdPLElBQUlPLFNBQUosRUFBZTtBQUNsQixpQkFBS0MsV0FBTDtBQUNBdmUsc0JBQVV1ZSxXQUFWO0FBQ0g7O0FBRUQsWUFBSXZlLFVBQVUyZCxTQUFWLElBQXVCM2QsVUFBVTJkLFNBQVYsS0FBd0IsS0FBbkQsRUFBMEQ7QUFDdEQsaUJBQUthLFFBQUwsQ0FBYztBQUNWYiwyQkFBVzNkLFVBQVUyZDtBQURYLGFBQWQ7QUFHSDs7QUFFRCxZQUFJM2QsVUFBVTJkLFNBQVYsS0FBd0IsS0FBeEIsSUFBaUMxZ0IsY0FBUTBnQixTQUE3QyxFQUF3RDtBQUNwRCxnQkFBSVUsUUFBSixFQUFjO0FBQ1YscUJBQUtMLEtBQUw7QUFDSCxhQUZELE1BRU8sSUFBSU0sU0FBSixFQUFlO0FBQ2xCLHFCQUFLRyxLQUFMO0FBQ0g7QUFDSixTQU5ELE1BTU87QUFDSCxpQkFBS0QsUUFBTCxDQUFjO0FBQ1ZmLHlCQUFTemQsVUFBVXlkO0FBRFQsYUFBZDtBQUdIO0FBQ0osSzs7c0JBRUR4ZCxrQiwrQkFBbUJ5ZSxTLEVBQVc7QUFBQTs7QUFDMUIsWUFBTUMsT0FBTyxDQUFDRCxVQUFVakIsT0FBWCxJQUFzQixLQUFLdmUsS0FBTCxDQUFXdWUsT0FBOUM7QUFDQSxZQUFNbUIsUUFBUUYsVUFBVWpCLE9BQVYsSUFBcUIsQ0FBQyxLQUFLdmUsS0FBTCxDQUFXdWUsT0FBL0M7QUFDQSxZQUFJLEtBQUt2VixLQUFMLENBQVd5VixTQUFYLElBQXdCMWdCLGNBQVEwZ0IsU0FBcEMsRUFBK0M7QUFDM0MsZ0JBQUlnQixRQUFRQyxLQUFaLEVBQW1CO0FBQ2YscUJBQUtDLGtCQUFMO0FBQ0g7QUFDSixTQUpELE1BSU87QUFDSCxnQkFBTUMsY0FBYyxLQUFLQyxjQUFMLEVBQXBCO0FBQ0EsZ0JBQUlKLElBQUosRUFBVTtBQUNOSywyQkFBVyxZQUFNO0FBQ2IsMkJBQUs5ZixLQUFMLENBQVcrZixNQUFYO0FBQ0EsMkJBQUsvZixLQUFMLENBQVdnZ0IsU0FBWDtBQUNBdmlCLDhCQUFJNlEsUUFBSixDQUFhc1IsV0FBYixFQUEwQixRQUExQjtBQUNBWixzQ0FBZUMsVUFBZixDQUEwQixNQUExQjtBQUNILGlCQUxEO0FBTUgsYUFQRCxNQU9PLElBQUlTLEtBQUosRUFBVztBQUNkLHFCQUFLMWYsS0FBTCxDQUFXaWdCLE9BQVg7QUFDQSxxQkFBS2pnQixLQUFMLENBQVdrZ0IsVUFBWDtBQUNBemlCLDBCQUFJOFEsV0FBSixDQUFnQnFSLFdBQWhCLEVBQTZCLFFBQTdCO0FBQ0FaLGtDQUFlbUIsYUFBZixDQUE2QixJQUE3QjtBQUNIO0FBQ0QsaUJBQUtDLFlBQUw7QUFDSDtBQUNKLEs7O3NCQUVEcGYsb0IsbUNBQXVCO0FBQ25CLGFBQUtxZixZQUFMLEdBQW9CLElBQXBCO0FBQ0EsYUFBS25CLFVBQUwsR0FBa0IsS0FBbEI7QUFDQUYsMEJBQWVtQixhQUFmLENBQTZCLElBQTdCO0FBQ0EsYUFBS0csb0JBQUw7QUFDQSxZQUFJLEtBQUtDLFlBQVQsRUFBdUI7QUFDbkJDLHlCQUFhLEtBQUtELFlBQWxCO0FBQ0g7QUFDRCxZQUFJLEtBQUtFLFVBQVQsRUFBcUI7QUFDakIsaUJBQUtBLFVBQUwsQ0FBZ0JDLEdBQWhCO0FBQ0EsaUJBQUtELFVBQUwsR0FBa0IsSUFBbEI7QUFDSDtBQUNELGFBQUtwQixXQUFMO0FBQ0gsSzs7c0JBRURYLFkseUJBQWExZSxLLEVBQU87QUFDaEIsWUFBSUEsTUFBTXllLFNBQU4sS0FBb0IsS0FBeEIsRUFBK0I7QUFDM0IsbUJBQU8sS0FBUDtBQUNIOztBQUVELFlBQUl6ZSxNQUFNeWUsU0FBVixFQUFxQjtBQUNqQixtQkFBT3plLE1BQU15ZSxTQUFiO0FBQ0g7O0FBRUQsZUFBTyxLQUFLa0MsbUJBQUwsQ0FBeUIzZ0IsTUFBTTRPLEtBQS9CLENBQVA7QUFDSCxLOztzQkFFRCtSLG1CLGdDQUFvQi9SLEssRUFBTztBQUN2QixnQkFBUUEsTUFBTSxDQUFOLENBQVI7QUFDSSxpQkFBSyxHQUFMO0FBQ0ksdUJBQU87QUFDSGdTLHdCQUFJLGNBREQ7QUFFSEMseUJBQUs7QUFGRixpQkFBUDtBQUlKLGlCQUFLLEdBQUw7QUFDSSx1QkFBTztBQUNIRCx3QkFBSSxZQUREO0FBRUhDLHlCQUFLO0FBRkYsaUJBQVA7QUFJSjtBQUNJLHVCQUFPO0FBQ0hELHdCQUFJLGNBREQ7QUFFSEMseUJBQUs7QUFGRixpQkFBUDtBQVpSO0FBaUJILEs7O3NCQUVEbEIsa0IsaUNBQXFCO0FBQUE7O0FBQ2pCRyxtQkFBVyxZQUFNO0FBQ2IsZ0JBQU1yUCxPQUFPLE9BQUtxUSxjQUFMLEVBQWI7QUFDQSxnQkFBSXJRLElBQUosRUFBVTtBQUNOLG9CQUFNaE4sS0FBSyxpQkFBWDs7QUFFQSx1QkFBS2dkLFVBQUwsR0FBa0IvaUIsYUFBT3FqQixFQUFQLENBQVV0USxJQUFWLEVBQWdCMVMsY0FBUTBnQixTQUFSLENBQWtCdUMsR0FBbEMsRUFBdUMsT0FBS0MsZ0JBQUwsQ0FBc0J2VCxJQUF0QixDQUEyQixNQUEzQixFQUFpQ2pLLEVBQWpDLENBQXZDLENBQWxCOztBQUVBLG9CQUFNeWQsaUJBQWlCaEksV0FBVzZFLGlCQUFpQnROLElBQWpCLEVBQXVCLGlCQUF2QixDQUFYLEtBQXlELENBQWhGO0FBQ0Esb0JBQU0wUSxvQkFBb0JqSSxXQUFXNkUsaUJBQWlCdE4sSUFBakIsRUFBdUIsb0JBQXZCLENBQVgsS0FBNEQsQ0FBdEY7QUFDQSxvQkFBTTJRLE9BQU9GLGlCQUFpQkMsaUJBQTlCO0FBQ0Esb0JBQUlDLElBQUosRUFBVTtBQUNOLDJCQUFLeEMsVUFBTCxDQUFnQm5iLEVBQWhCLElBQXNCcWMsV0FBVyxZQUFNO0FBQ25DLCtCQUFLbUIsZ0JBQUwsQ0FBc0J4ZCxFQUF0QjtBQUNILHFCQUZxQixFQUVuQjJkLE9BQU8sSUFBUCxHQUFjLEdBRkssQ0FBdEI7QUFHSDtBQUNKO0FBQ0osU0FoQkQ7QUFpQkgsSzs7c0JBRURDLGMsMkJBQWVwZixNLEVBQVE7QUFDbkIsWUFBTTJNLFFBQVEzTSxPQUFPMk0sS0FBUCxDQUFhdlAsSUFBYixDQUFrQixHQUFsQixDQUFkOztBQUVBLFlBQUksRUFBRSxlQUFlLEtBQUtXLEtBQXRCLEtBQWdDLEtBQUtBLEtBQUwsQ0FBV3NoQixVQUEzQyxJQUF5RCxLQUFLM0MsU0FBTCxLQUFtQi9QLEtBQWhGLEVBQXVGO0FBQ25GLGlCQUFLMFEsUUFBTCxDQUFjO0FBQ1ZiLDJCQUFXLEtBQUtrQyxtQkFBTCxDQUF5Qi9SLEtBQXpCO0FBREQsYUFBZDtBQUdIOztBQUVELGFBQUsrUCxTQUFMLEdBQWlCL1AsS0FBakI7QUFDSCxLOztzQkFFRHFTLGdCLDZCQUFpQnhkLEUsRUFBSTtBQUNqQixZQUFJLEtBQUttYixVQUFMLENBQWdCbmIsRUFBaEIsQ0FBSixFQUF5QjtBQUNyQitjLHlCQUFhLEtBQUs1QixVQUFMLENBQWdCbmIsRUFBaEIsQ0FBYjtBQUNIO0FBQ0QsZUFBTyxLQUFLbWIsVUFBTCxDQUFnQm5iLEVBQWhCLENBQVA7O0FBRUEsWUFBSSxLQUFLZ2QsVUFBVCxFQUFxQjtBQUNqQixpQkFBS0EsVUFBTCxDQUFnQkMsR0FBaEI7QUFDQSxpQkFBS0QsVUFBTCxHQUFrQixJQUFsQjtBQUNIOztBQUVELFlBQUksQ0FBQyxLQUFLdkIsVUFBVixFQUFzQjtBQUNsQjtBQUNIOztBQUVELFlBQUksS0FBS2xXLEtBQUwsQ0FBV3dWLE1BQVgsS0FBc0IsU0FBMUIsRUFBcUM7QUFDakMsaUJBQUtjLFFBQUwsQ0FBYztBQUNWZix5QkFBUyxLQURDO0FBRVZDLHdCQUFRO0FBRkUsYUFBZDs7QUFLQSxpQkFBSytDLFFBQUw7QUFDSCxTQVBELE1BT08sSUFBSSxLQUFLdlksS0FBTCxDQUFXd1YsTUFBWCxLQUFzQixVQUExQixFQUFzQztBQUN6QyxpQkFBS2MsUUFBTCxDQUFjO0FBQ1ZkLHdCQUFRO0FBREUsYUFBZDs7QUFJQSxpQkFBS2dELFNBQUw7QUFDSDtBQUNKLEs7O3NCQUVEMUMsSyxvQkFBUTtBQUFBOztBQUNKLGFBQUtRLFFBQUwsQ0FBYztBQUNWZixxQkFBUyxJQURDO0FBRVZDLG9CQUFRO0FBRkUsU0FBZCxFQUdHLFlBQU07QUFDTDtBQUNBc0IsdUJBQVcsWUFBTTtBQUNiLG9CQUFJLENBQUMsT0FBS08sWUFBVixFQUF3QjtBQUNwQiwyQkFBS29CLFVBQUw7QUFDSDtBQUNKLGFBSkQ7QUFLSCxTQVZEO0FBV0gsSzs7c0JBRURsQyxLLG9CQUFRO0FBQ0osYUFBS0QsUUFBTCxDQUFjO0FBQ1ZkLG9CQUFRO0FBREUsU0FBZDs7QUFJQSxhQUFLa0QsU0FBTDtBQUNILEs7O3NCQUVERCxVLHlCQUFhO0FBQ1QsWUFBTTdCLGNBQWMsS0FBS0MsY0FBTCxFQUFwQjtBQUNBcGlCLGtCQUFJNlEsUUFBSixDQUFhc1IsV0FBYixFQUEwQixRQUExQjtBQUNBLGFBQUs1ZixLQUFMLENBQVcrZixNQUFYO0FBQ0gsSzs7c0JBRUQyQixTLHdCQUFZO0FBQ1IsWUFBTTlCLGNBQWMsS0FBS0MsY0FBTCxFQUFwQjtBQUNBcGlCLGtCQUFJOFEsV0FBSixDQUFnQnFSLFdBQWhCLEVBQTZCLFFBQTdCO0FBQ0EsYUFBSzVmLEtBQUwsQ0FBV2lnQixPQUFYO0FBQ0gsSzs7c0JBRUR1QixTLHdCQUFZO0FBQ1J4QywwQkFBZUMsVUFBZixDQUEwQixJQUExQjtBQUNBLGFBQUttQixZQUFMO0FBQ0EsYUFBS3BnQixLQUFMLENBQVdnZ0IsU0FBWDtBQUNILEs7O3NCQUVEdUIsUSx1QkFBVztBQUNQdkMsMEJBQWVtQixhQUFmLENBQTZCLElBQTdCO0FBQ0EsYUFBS0MsWUFBTDtBQUNBLGFBQUtwZ0IsS0FBTCxDQUFXa2dCLFVBQVg7QUFDSCxLOztzQkFFRHJCLFUseUJBQWE7QUFDVCxZQUFJLEtBQUs3ZSxLQUFMLENBQVcyaEIsYUFBZixFQUE4QjtBQUMxQixnQkFBSTNELE9BQU9yZixNQUFQLEtBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLG9CQUFNcU0sUUFBUTtBQUNWNFcsK0JBQVc7QUFERCxpQkFBZDtBQUdBLG9CQUFNNUosT0FBT2hILFNBQVNnSCxJQUF0QjtBQUNBaUcsZ0NBQWdCakcsS0FBS2hOLEtBQUwsQ0FBVzRXLFNBQTNCO0FBQ0Esb0JBQUlqRSxXQUFKLEVBQWlCO0FBQ2JPLHVDQUFtQmxHLEtBQUtoTixLQUFMLENBQVc2VyxZQUE5QjtBQUNBN1csMEJBQU02VyxZQUFOLEdBQXdCcGtCLFVBQUl3WixRQUFKLENBQWFlLElBQWIsRUFBbUIsY0FBbkIsSUFBcUN2YSxVQUFJMFosU0FBSixHQUFnQnRJLEtBQTdFO0FBQ0g7O0FBRURwUiwwQkFBSXlaLFFBQUosQ0FBYWMsSUFBYixFQUFtQmhOLEtBQW5CO0FBQ0g7QUFDRGdULG1CQUFPbGYsSUFBUCxDQUFZLElBQVo7QUFDSDtBQUNKLEs7O3NCQUVEdWdCLFcsMEJBQWM7QUFDVixZQUFJLEtBQUtyZixLQUFMLENBQVcyaEIsYUFBZixFQUE4QjtBQUMxQixnQkFBTTNWLFFBQVFnUyxPQUFPaFosT0FBUCxDQUFlLElBQWYsQ0FBZDtBQUNBLGdCQUFJZ0gsUUFBUSxDQUFDLENBQWIsRUFBZ0I7QUFDWixvQkFBSWdTLE9BQU9yZixNQUFQLEtBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLHdCQUFNcU0sUUFBUTtBQUNWNFcsbUNBQVczRDtBQURELHFCQUFkO0FBR0Esd0JBQUlOLFdBQUosRUFBaUI7QUFDYjNTLDhCQUFNNlcsWUFBTixHQUFxQjNELGdCQUFyQjtBQUNIOztBQUVEemdCLDhCQUFJeVosUUFBSixDQUFhbEcsU0FBU2dILElBQXRCLEVBQTRCaE4sS0FBNUI7O0FBRUFpVCxvQ0FBZ0JqRCxTQUFoQjtBQUNBa0QsdUNBQW1CbEQsU0FBbkI7QUFDSDs7QUFFRGdELHVCQUFPOU8sTUFBUCxDQUFjbEQsS0FBZCxFQUFxQixDQUFyQjtBQUNIO0FBQ0o7QUFDSixLOztzQkFFRG9VLFksMkJBQWU7QUFBQTs7QUFDWCxZQUFJLENBQUMsS0FBS3BnQixLQUFMLENBQVc4aEIsU0FBaEIsRUFBMkI7QUFDdkI7QUFDSDs7QUFFRCxZQUFJLEtBQUs5WSxLQUFMLENBQVd1VixPQUFYLElBQXNCLENBQUMsS0FBS3dELFdBQWhDLEVBQTZDO0FBQ3pDMUU7QUFDQTtBQUNBO0FBQ0EsaUJBQUtrRCxZQUFMLEdBQW9CVCxXQUFXLFlBQU07QUFDakMsb0JBQU1yUCxPQUFPLE9BQUtxUSxjQUFMLEVBQWI7QUFDQSxvQkFBSXJRLElBQUosRUFBVTtBQUNOLHdCQUFNdVIsZ0JBQWdCMUUsaUJBQWlCN00sSUFBakIsQ0FBdEI7QUFDQSx3QkFBSXVSLGNBQWNyakIsTUFBbEIsRUFBMEI7QUFDdEJxakIsc0NBQWMsQ0FBZCxFQUFpQmhrQixLQUFqQjtBQUNIO0FBQ0QsMkJBQUsrakIsV0FBTCxHQUFtQixJQUFuQjtBQUNIO0FBQ0osYUFUbUIsRUFTakIsR0FUaUIsQ0FBcEI7QUFVSCxTQWRELE1BY08sSUFBSSxDQUFDLEtBQUsvWSxLQUFMLENBQVd1VixPQUFaLElBQXVCLEtBQUt3RCxXQUFoQyxFQUE2QztBQUNoRHhFO0FBQ0EsaUJBQUt3RSxXQUFMLEdBQW1CLEtBQW5CO0FBQ0g7QUFDSixLOztzQkFFREUsVSx5QkFBYTtBQUNULGVBQU8sS0FBSzdELFVBQVo7QUFDSCxLOztzQkFFRDBDLGMsNkJBQWlCO0FBQ2IsZUFBTywyQkFBWSxLQUFLMUMsVUFBakIsQ0FBUDtBQUNILEs7O3NCQUVEeUIsYyw2QkFBaUI7QUFDYixlQUFPLEtBQUt2QixVQUFMLEdBQWtCLEtBQUtBLFVBQUwsQ0FBZ0I0RCxZQUFoQixFQUFsQixHQUFtRCxJQUExRDtBQUNILEs7O3NCQUVEbkQsaUIsZ0NBQW9CO0FBQ2hCLFlBQUksS0FBSy9lLEtBQUwsQ0FBV21pQixhQUFmLEVBQThCO0FBQzFCLGlCQUFLQyxjQUFMLEdBQXNCMWtCLGFBQU9xakIsRUFBUCxDQUFVL1AsUUFBVixFQUFvQixTQUFwQixFQUErQixLQUFLcVIscUJBQXBDLENBQXRCO0FBQ0g7QUFDRCxZQUFJLEtBQUtyaUIsS0FBTCxDQUFXc2lCLHNCQUFmLEVBQXVDO0FBQ25DLGlCQUFLQyxZQUFMLEdBQW9CN2tCLGFBQU9xakIsRUFBUCxDQUFVL1AsUUFBVixFQUFvQixPQUFwQixFQUE2QixLQUFLd1IsbUJBQWxDLENBQXBCO0FBQ0g7QUFDSixLOztzQkFFRGxDLG9CLG1DQUF1QjtBQUNuQixZQUFJLEtBQUs4QixjQUFULEVBQXlCO0FBQ3JCLGlCQUFLQSxjQUFMLENBQW9CMUIsR0FBcEI7QUFDQSxpQkFBSzBCLGNBQUwsR0FBc0IsSUFBdEI7QUFDSDtBQUNELFlBQUksS0FBS0csWUFBVCxFQUF1QjtBQUNuQixpQkFBS0EsWUFBTCxDQUFrQjdCLEdBQWxCO0FBQ0EsaUJBQUs2QixZQUFMLEdBQW9CLElBQXBCO0FBQ0g7QUFDSixLOztzQkFFREYscUIsa0NBQXNCbGhCLEMsRUFBRztBQUNyQixZQUFJLEtBQUs2SCxLQUFMLENBQVd1VixPQUFYLElBQXNCcGQsRUFBRXVRLE9BQUYsS0FBY3ZULGNBQVF1ZCxHQUE1QyxJQUFtRHNELGtCQUFleUQsZ0JBQWYsQ0FBZ0MsSUFBaEMsQ0FBdkQsRUFBOEY7QUFDMUYsaUJBQUt6aUIsS0FBTCxDQUFXMGlCLGNBQVgsQ0FBMEIsVUFBMUIsRUFBc0N2aEIsQ0FBdEM7QUFDSDtBQUNKLEs7O3NCQUVEcWhCLG1CLGdDQUFvQnJoQixDLEVBQUc7QUFBQTs7QUFDbkIsWUFBSSxLQUFLNkgsS0FBTCxDQUFXdVYsT0FBZixFQUF3QjtBQUFBLGdCQUNab0UsUUFEWSxHQUNDLEtBQUszaUIsS0FETixDQUNaMmlCLFFBRFk7O0FBRXBCLGdCQUFNQyxZQUFhN2pCLE1BQU1DLE9BQU4sQ0FBYzJqQixRQUFkLGNBQThCQSxRQUE5QixJQUEwQyxDQUFDQSxRQUFELENBQTdEO0FBQ0FDLHNCQUFVQyxPQUFWLENBQWtCO0FBQUEsdUJBQU0sT0FBS2hELGNBQUwsRUFBTjtBQUFBLGFBQWxCOztBQUVBLGlCQUFLLElBQUlwaEIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJbWtCLFVBQVVqa0IsTUFBOUIsRUFBc0NGLEdBQXRDLEVBQTJDO0FBQ3ZDLG9CQUFNZ1MsT0FBTyx3QkFBU21TLFVBQVVua0IsQ0FBVixDQUFULEVBQXVCLEtBQUt1QixLQUE1QixDQUFiO0FBQ0E7QUFDQTtBQUNBLG9CQUFJeVEsU0FBU0EsU0FBU3RQLEVBQUUyUCxNQUFYLElBQXFCTCxLQUFLK0csUUFBTCxDQUFjclcsRUFBRTJQLE1BQWhCLENBQXJCLElBQ1ozUCxFQUFFMlAsTUFBRixLQUFhRSxRQUFiLElBQXlCLENBQUNBLFNBQVM2TSxlQUFULENBQXlCckcsUUFBekIsQ0FBa0NyVyxFQUFFMlAsTUFBcEMsQ0FEdkIsQ0FBSixFQUMwRTtBQUN0RTtBQUNIO0FBQ0o7O0FBRUQsaUJBQUs5USxLQUFMLENBQVcwaUIsY0FBWCxDQUEwQixVQUExQixFQUFzQ3ZoQixDQUF0QztBQUNIO0FBQ0osSzs7c0JBRUQyaEIsZSw0QkFBZ0IzaEIsQyxFQUFHO0FBQ2YsWUFBSSxLQUFLbkIsS0FBTCxDQUFXK2lCLGNBQWYsRUFBK0I7QUFDM0IsaUJBQUsvaUIsS0FBTCxDQUFXMGlCLGNBQVgsQ0FBMEIsV0FBMUIsRUFBdUN2aEIsQ0FBdkM7QUFDSDtBQUNKLEs7O0FBVUQ7c0JBQ0E2aEIsVywwQkFBYztBQUNWLGVBQU8sSUFBUDtBQUNILEs7O3NCQUVEM2hCLE0scUJBQVM7QUFBQSxxQkFPRCxLQUFLckIsS0FQSjtBQUFBLFlBRURDLE1BRkMsVUFFREEsTUFGQztBQUFBLFlBRU8yRixTQUZQLFVBRU9BLFNBRlA7QUFBQSxZQUVrQm9GLEtBRmxCLFVBRWtCQSxLQUZsQjtBQUFBLFlBRW1DaVksWUFGbkMsVUFFeUJ6aEIsUUFGekI7QUFBQSxZQUdEc1AsTUFIQyxVQUdEQSxNQUhDO0FBQUEsWUFHT2xDLEtBSFAsVUFHT0EsS0FIUDtBQUFBLFlBR2NzVSxNQUhkLFVBR2NBLE1BSGQ7QUFBQSxZQUdzQkMsU0FIdEIsVUFHc0JBLFNBSHRCO0FBQUEsWUFHaUNDLE9BSGpDLFVBR2lDQSxPQUhqQztBQUFBLFlBRzBDOUIsVUFIMUMsVUFHMENBLFVBSDFDO0FBQUEsWUFJRCtCLGNBSkMsVUFJREEsY0FKQztBQUFBLFlBSWVDLFVBSmYsVUFJZUEsVUFKZjtBQUFBLFlBSTJCQyxZQUozQixVQUkyQkEsWUFKM0I7QUFBQSxZQUl5Q2xqQixHQUp6QyxVQUl5Q0EsR0FKekM7QUFBQSxZQUtxQm1qQix3QkFMckIsVUFLREMsb0JBTEM7QUFBQSxZQU1EQyxLQU5DLFVBTURBLEtBTkM7QUFBQSxZQU1NQyxnQkFOTixVQU1NQSxnQkFOTjtBQUFBLFlBTXdCQyxnQkFOeEIsVUFNd0JBLGdCQU54QjtBQUFBLFlBTTBDQyxnQkFOMUMsVUFNMENBLGdCQU4xQztBQUFBLHFCQVFnRCxLQUFLN2EsS0FSckQ7QUFBQSxZQVFZOGEsWUFSWixVQVFHdkYsT0FSSDtBQUFBLFlBUTBCQyxNQVIxQixVQVEwQkEsTUFSMUI7QUFBQSxZQVFrQ0MsU0FSbEMsVUFRa0NBLFNBUmxDOzs7QUFVTCxZQUFJamQsV0FBV3NpQixnQkFBaUJKLFNBQVMsS0FBS3hFLFVBQS9CLEdBQTZDK0QsWUFBN0MsR0FBNEQsSUFBM0U7QUFDQSxZQUFJemhCLFFBQUosRUFBYztBQUFBOztBQUNWLGdCQUFNNkksUUFBUS9JLGdCQUFTQyxJQUFULENBQWNDLFFBQWQsQ0FBZDtBQUNBLGdCQUFNdWlCLGFBQWEseURBQ1g5akIsTUFEVyxzQkFDYSxJQURiLGNBRWR3ZSxVQUFVbUMsRUFGSSxJQUVDcEMsV0FBVyxVQUZaLGNBR2RDLFVBQVVvQyxHQUhJLElBR0VyQyxXQUFXLFNBSGIsY0FJZG5VLE1BQU1ySyxLQUFOLENBQVk0RixTQUpFLElBSVUsQ0FBQyxDQUFDeUUsTUFBTXJLLEtBQU4sQ0FBWTRGLFNBSnhCLGNBS2RBLFNBTGMsSUFLRixDQUFDLENBQUNBLFNBTEEsZUFBbkI7QUFPQSxnQkFBSSxPQUFPeUUsTUFBTTRTLEdBQWIsS0FBcUIsUUFBekIsRUFBbUM7QUFDL0Isc0JBQU0sSUFBSStHLEtBQUosQ0FBVSw2REFBVixDQUFOO0FBQ0g7O0FBRUR4aUIsdUJBQVdtTSxnQkFBTTJDLFlBQU4sQ0FBbUJqRyxLQUFuQixFQUEwQjtBQUNqQ3pFLDJCQUFXbWUsVUFEc0I7QUFFakMvWSxvQ0FBV1gsTUFBTXJLLEtBQU4sQ0FBWWdMLEtBQXZCLEVBQWlDQSxLQUFqQyxDQUZpQztBQUdqQ2lTLHFCQUFLTyxVQUFVLEtBQUtXLGNBQWYsRUFBK0I5VCxNQUFNNFMsR0FBckMsQ0FINEI7QUFJakMsK0JBQWUsQ0FBQzZHLFlBQUQsSUFBaUJKLEtBQWpCLElBQTBCLEtBQUt4RTtBQUpiLGFBQTFCLENBQVg7O0FBT0EsZ0JBQUl0USxLQUFKLEVBQVc7QUFDUCxvQkFBTTZVLHVCQUF1QmpGLFdBQVcsU0FBWCxHQUF1QixLQUF2QixHQUErQmdGLHdCQUE1RDtBQUNBaGlCLDJCQUNJLDhCQUFDLGtCQUFELEVBQWU7QUFDWEEsc0NBRFcsRUFDRHNQLGNBREMsRUFDT2xDLFlBRFAsRUFDY3NVLGNBRGQsRUFDc0I1QixzQkFEdEI7QUFFWCtCLGtEQUZXO0FBR1hDLGdDQUFZOUYsVUFBVSxLQUFLNkQsY0FBZixFQUErQmlDLFVBQS9CLENBSEQ7QUFJWEcsOERBSlcsRUFJV3BqQjtBQUpYLGlCQUFmLENBREo7QUFRSDs7QUFFRCxnQkFBTTRqQixlQUFlLDBCQUFXLENBQ3pCaGtCLE1BRHlCLHNCQUU1QjBqQixnQkFGNEIsQ0FBWCxDQUFyQjtBQUlBLGdCQUFNTyxrQkFBa0IsU0FBYyxFQUFkLEVBQWtCO0FBQ3RDQyx5QkFBU0wsZUFBZSxFQUFmLEdBQW9CO0FBRFMsYUFBbEIsRUFFckJQLFlBRnFCLENBQXhCOztBQUlBL2hCLHVCQUNJO0FBQUE7QUFBQSxrQkFBSyxXQUFXeWlCLFlBQWhCLEVBQThCLE9BQU9DLGVBQXJDLEVBQXNELEtBQUs3akIsTUFBTSxLQUFOLEdBQWMyYSxTQUF6RTtBQUNLb0ksMEJBQ0csdUNBQUssV0FBY25qQixNQUFkLHFCQUFMO0FBQ0ksNkJBQVMsS0FBSzZpQixlQURsQjtBQUVJLGtDQUFjYyxnQkFGbEI7QUFHSSxrQ0FBY0MsZ0JBSGxCO0FBSUkseUJBQUt4akIsTUFBTSxLQUFOLEdBQWMyYSxTQUp2QixHQURILEdBTUcsSUFQUjtBQVFLeFo7QUFSTCxhQURKO0FBWUg7O0FBRUQsZUFBTyw4QkFBQyxpQkFBRCxXQUFjLEVBQUMyaEIsb0JBQUQsRUFBWXJTLGNBQVosRUFBb0J0UCxrQkFBcEIsRUFBZCxJQUE4QyxLQUFLLEtBQUs2YyxjQUF4RCxJQUFQO0FBQ0gsSzs7O0VBeG5CZ0M1YyxnQixVQUMxQkMsUyxHQUFZO0FBQ2Z6QixZQUFRMEIsb0JBQVVDLE1BREg7QUFFZnpCLFVBQU13QixvQkFBVUUsSUFGRDtBQUdmeEIsU0FBS3NCLG9CQUFVRSxJQUhBO0FBSWYrRCxlQUFXakUsb0JBQVVDLE1BSk47QUFLZm9KLFdBQU9ySixvQkFBVWpGLE1BTEY7QUFNZjs7O0FBR0E4RSxjQUFVRyxvQkFBVWlNLEdBVEw7QUFVZjs7O0FBR0EyUSxhQUFTNWMsb0JBQVVFLElBYko7QUFjZjs7Ozs7QUFLQTZnQixvQkFBZ0IvZ0Isb0JBQVVoRSxJQW5CWDtBQW9CZjs7O0FBR0FtVCxZQUFRblAsb0JBQVVpTSxHQXZCSDtBQXdCZjs7O0FBR0FnQixXQUFPak4sb0JBQVU2TyxTQUFWLENBQW9CLENBQUM3TyxvQkFBVUMsTUFBWCxFQUFtQkQsb0JBQVVFLElBQTdCLENBQXBCLENBM0JRO0FBNEJmOzs7QUFHQXFoQixZQUFRdmhCLG9CQUFVa00sS0EvQkg7QUFnQ2Y7OztBQUdBc1YsZUFBV3hoQixvQkFBVWlNLEdBbkNOO0FBb0NmOzs7QUFHQXdWLGFBQVN6aEIsb0JBQVVFLElBdkNKO0FBd0NmOzs7QUFHQXNnQixtQkFBZXhnQixvQkFBVUUsSUEzQ1Y7QUE0Q2Y7OztBQUdBeWdCLDRCQUF3QjNnQixvQkFBVUUsSUEvQ25CO0FBZ0RmOzs7QUFHQWtoQixvQkFBZ0JwaEIsb0JBQVVFLElBbkRYO0FBb0RmOzs7QUFHQWdkLGdCQUFZbGQsb0JBQVVoRSxJQXZEUDtBQXdEZjs7O0FBR0FvaUIsWUFBUXBlLG9CQUFVaEUsSUEzREg7QUE0RGY7OztBQUdBcWlCLGVBQVdyZSxvQkFBVWhFLElBL0ROO0FBZ0VmOzs7QUFHQTBoQixpQkFBYTFkLG9CQUFVaEUsSUFuRVI7QUFvRWY7OztBQUdBc2lCLGFBQVN0ZSxvQkFBVWhFLElBdkVKO0FBd0VmOzs7QUFHQXVpQixnQkFBWXZlLG9CQUFVaEUsSUEzRVA7QUE0RWY7OztBQUdBMGxCLG9CQUFnQjFoQixvQkFBVWhFLElBL0VYO0FBZ0ZmOzs7Ozs7OztBQVFBMmxCLGdCQUFZM2hCLG9CQUFVaEUsSUF4RlA7QUF5RmY7OztBQUdBOGxCLDBCQUFzQjloQixvQkFBVUUsSUE1RmpCO0FBNkZmOzs7QUFHQWlnQixlQUFXbmdCLG9CQUFVRSxJQWhHTjtBQWlHZjs7O0FBR0F5ZixnQkFBWTNmLG9CQUFVRSxJQXBHUDtBQXFHZjs7O0FBR0E4ZixtQkFBZWhnQixvQkFBVUUsSUF4R1Y7QUF5R2Y7OztBQUdBNmhCLFdBQU8vaEIsb0JBQVVFLElBNUdGO0FBNkdmOzs7QUFHQThnQixjQUFVaGhCLG9CQUFVaU0sR0FoSEw7QUFpSGY7OztBQUdBK1Ysc0JBQWtCaGlCLG9CQUFVQyxNQXBIYjtBQXFIZjs7O0FBR0EyaEIsa0JBQWM1aEIsb0JBQVVqRixNQXhIVDtBQXlIZjs7OztBQUlBK2hCLGVBQVc5YyxvQkFBVTZPLFNBQVYsQ0FBb0IsQ0FBQzdPLG9CQUFVakYsTUFBWCxFQUFtQmlGLG9CQUFVRSxJQUE3QixDQUFwQixDQTdISTtBQThIZitoQixzQkFBa0JqaUIsb0JBQVVoRSxJQTlIYjtBQStIZmttQixzQkFBa0JsaUIsb0JBQVVoRTtBQS9IYixDLFNBa0lab0UsWSxHQUFlO0FBQ2xCOUIsWUFBUSxPQURVO0FBRWxCRSxVQUFNLEtBRlk7QUFHbEJvZSxhQUFTLEtBSFM7QUFJbEJtRSxvQkFBZ0JqWCxJQUpFO0FBS2xCcUYsWUFBUXhGLG1CQUFTOFksUUFMQztBQU1sQnhWLFdBQU8sT0FOVztBQU9sQnNVLFlBQVEsQ0FBQyxDQUFELEVBQUksQ0FBSixDQVBVO0FBUWxCRSxhQUFTLEtBUlM7QUFTbEJqQixtQkFBZSxJQVRHO0FBVWxCRyw0QkFBd0IsSUFWTjtBQVdsQlMsb0JBQWdCLElBWEU7QUFZbEJsRSxnQkFBWXBULElBWk07QUFhbEJzVSxZQUFRdFUsSUFiVTtBQWNsQnVVLGVBQVd2VSxJQWRPO0FBZWxCNFQsaUJBQWE1VCxJQWZLO0FBZ0JsQndVLGFBQVN4VSxJQWhCUztBQWlCbEJ5VSxnQkFBWXpVLElBakJNO0FBa0JsQjRYLG9CQUFnQjVYLElBbEJFO0FBbUJsQjZYLGdCQUFZN1gsSUFuQk07QUFvQmxCbVksc0JBQWtCblksSUFwQkE7QUFxQmxCb1ksc0JBQWtCcFksSUFyQkE7QUFzQmxCZ1ksMEJBQXNCLEtBdEJKO0FBdUJsQjNCLGVBQVcsS0F2Qk87QUF3QmxCUixnQkFBWSxJQXhCTTtBQXlCbEJLLG1CQUFlLEtBekJHO0FBMEJsQitCLFdBQU87QUExQlcsQztBQW5JTHRZLE87a0JBQUFBLE87Ozs7Ozs7Ozs7Ozs7OztBQzlDckI7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7OztJQUVRb1MsUyxHQUFjN2YsVSxDQUFkNmYsUztJQUVhblMsTzs7Ozs7Ozs7Ozs7O2dKQTZCakJnWixZLEdBQWUsZUFBTztBQUNsQixrQkFBS2hhLEtBQUwsR0FBYTRTLEdBQWI7QUFDSCxTOzs7c0JBcEJEL1UsaUIsZ0NBQW9CO0FBQ2hCLGFBQUtvYyxhQUFMLEdBQXFCLEtBQUtDLGdCQUFMLENBQXNCLEtBQUt2a0IsS0FBM0IsQ0FBckI7QUFDQSxhQUFLd2tCLFdBQUw7QUFDSCxLOztzQkFFRDNqQix5QixzQ0FBMEJDLFMsRUFBVztBQUNqQyxhQUFLd2pCLGFBQUwsR0FBcUIsS0FBS0MsZ0JBQUwsQ0FBc0J6akIsU0FBdEIsQ0FBckI7QUFDSCxLOztzQkFFRHlqQixnQiw2QkFBaUJ2a0IsSyxFQUFPO0FBQ3BCLFlBQU15a0IsYUFBYSx3QkFBU3prQixNQUFNOFEsTUFBZixDQUFuQjtBQUNBLGVBQU8sd0JBQVM5USxNQUFNbWpCLFNBQWYsRUFBMEJzQixVQUExQixDQUFQO0FBQ0gsSzs7c0JBRUR2QyxZLDJCQUFlO0FBQ1gsZUFBTywyQkFBWSxLQUFLN1gsS0FBakIsQ0FBUDtBQUNILEs7O3NCQU1EaEosTSxxQkFBUztBQUNMLFlBQUksQ0FBQyxLQUFLaWpCLGFBQVYsRUFBeUI7QUFDckIsbUJBQU8sSUFBUDtBQUNIOztBQUhJLFlBS0c5aUIsUUFMSCxHQUtnQixLQUFLeEIsS0FMckIsQ0FLR3dCLFFBTEg7O0FBTUwsWUFBSTZJLFFBQVE3SSxXQUFXRixnQkFBU0MsSUFBVCxDQUFjQyxRQUFkLENBQVgsR0FBcUMsSUFBakQ7QUFDQSxZQUFJLENBQUM2SSxLQUFMLEVBQVk7QUFDUixtQkFBTyxJQUFQO0FBQ0g7O0FBRUQsWUFBSSxPQUFPQSxNQUFNNFMsR0FBYixLQUFxQixRQUF6QixFQUFtQztBQUMvQixrQkFBTSxJQUFJK0csS0FBSixDQUFVLDZEQUFWLENBQU47QUFDSDtBQUNEM1osZ0JBQVFzRCxnQkFBTTJDLFlBQU4sQ0FBbUJqRyxLQUFuQixFQUEwQjtBQUM5QjRTLGlCQUFLTyxVQUFVLEtBQUs2RyxZQUFmLEVBQTZCaGEsTUFBTTRTLEdBQW5DO0FBRHlCLFNBQTFCLENBQVI7O0FBSUEsZUFBTyw0QkFBYTVTLEtBQWIsRUFBb0IsS0FBS2lhLGFBQXpCLENBQVA7QUFDSCxLOzs7RUFwRGdDN2lCLGdCLFVBQzFCQyxTLEdBQVk7QUFDZkYsY0FBVUcsb0JBQVU4TyxJQURMO0FBRWYwUyxlQUFXeGhCLG9CQUFVaU0sR0FGTjtBQUdma0QsWUFBUW5QLG9CQUFVaU07QUFISCxDLFNBTVo3TCxZLEdBQWU7QUFDbEJvaEIsZUFBVztBQUFBLGVBQU1uUyxTQUFTZ0gsSUFBZjtBQUFBO0FBRE8sQztBQVBMM00sTztrQkFBQUEsTzs7Ozs7Ozs7Ozs7Ozs7O0FDUnJCOztBQUNBOztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFFUUksSSxHQUFrQjlOLFUsQ0FBbEI4TixJO0lBQU16RCxPLEdBQVlySyxVLENBQVpxSyxPO0lBQ05pUCxRLEdBQWF4WixTLENBQWJ3WixROztBQUNSLElBQU15TixRQUFRaEwsbUJBQVNnTCxLQUF2Qjs7SUFFcUJwWixROzs7QUEyQmpCLHNCQUFZdEwsS0FBWixFQUFtQjtBQUFBOztBQUFBLHFEQUNmLHNCQUFNQSxLQUFOLENBRGU7O0FBR2ZnSSx1QkFBYyxDQUFDLGNBQUQsQ0FBZDtBQUhlO0FBSWxCOzt1QkFFREUsaUIsZ0NBQW9CO0FBQ2hCLGFBQUt5YyxXQUFMOztBQUVBLFlBQUksS0FBSzNrQixLQUFMLENBQVc0a0IsZ0JBQWYsRUFBaUM7QUFDN0JsbkIseUJBQU9xakIsRUFBUCxDQUFVdmhCLE1BQVYsRUFBa0IsUUFBbEIsRUFBNEIsS0FBS3FsQixZQUFqQztBQUNIO0FBQ0osSzs7dUJBRURoa0IseUIsc0NBQTBCQyxTLEVBQVc7QUFDakMsWUFBSSxXQUFXQSxTQUFYLElBQXdCQSxVQUFVOE4sS0FBVixLQUFvQixLQUFLNU8sS0FBTCxDQUFXNE8sS0FBdkQsSUFBZ0U5TixVQUFVMmlCLG9CQUE5RSxFQUFvRztBQUNoRyxpQkFBS0Esb0JBQUwsR0FBNEIsSUFBNUI7QUFDSDtBQUNKLEs7O3VCQUVEMWlCLGtCLGlDQUFxQjtBQUNqQixZQUFJLEtBQUswaUIsb0JBQVQsRUFBK0I7QUFDM0IsaUJBQUtrQixXQUFMO0FBQ0EsaUJBQUtsQixvQkFBTCxHQUE0QixLQUE1QjtBQUNIO0FBQ0osSzs7dUJBRUR6aUIsb0IsbUNBQXVCO0FBQ25CLFlBQUksS0FBS2hCLEtBQUwsQ0FBVzRrQixnQkFBZixFQUFpQztBQUM3QmxuQix5QkFBT2dqQixHQUFQLENBQVdsaEIsTUFBWCxFQUFtQixRQUFuQixFQUE2QixLQUFLcWxCLFlBQWxDO0FBQ0g7O0FBRURyRSxxQkFBYSxLQUFLc0UsYUFBbEI7QUFDSCxLOzt1QkFFREgsVywwQkFBYztBQUFBLHFCQUM2RCxLQUFLM2tCLEtBRGxFO0FBQUEsWUFDRjRPLEtBREUsVUFDRkEsS0FERTtBQUFBLFlBQ0tzVSxNQURMLFVBQ0tBLE1BREw7QUFBQSxZQUNhRyxjQURiLFVBQ2FBLGNBRGI7QUFBQSxZQUM2QkMsVUFEN0IsVUFDNkJBLFVBRDdCO0FBQUEsWUFDeUNoQyxVQUR6QyxVQUN5Q0EsVUFEekM7QUFBQSxZQUNxRGpoQixHQURyRCxVQUNxREEsR0FEckQ7OztBQUdWZ2pCOztBQUVBLFlBQU0wQixjQUFjLEtBQUtqRSxjQUFMLEVBQXBCO0FBQ0EsWUFBTTJELGFBQWEsS0FBS08sYUFBTCxFQUFuQjtBQUNBLFlBQUlELGVBQWVOLFVBQW5CLEVBQStCO0FBQzNCLGdCQUFNUSxjQUFjUCxNQUFNO0FBQ3RCUSw0QkFBWUgsV0FEVTtBQUV0QkksNkJBQWFWLFVBRlM7QUFHdEI3Viw0QkFIc0I7QUFJdEJzVSw4QkFKc0I7QUFLdEI1QixzQ0FMc0I7QUFNdEI4RCx1QkFBTy9rQjtBQU5lLGFBQU4sQ0FBcEI7QUFRQSxnQkFBTXNZLE1BQU0xQixTQUFTOE4sV0FBVCxFQUFzQixLQUF0QixDQUFaO0FBQ0EsZ0JBQU1oVCxPQUFPa0YsU0FBUzhOLFdBQVQsRUFBc0IsTUFBdEIsQ0FBYjs7QUFFQXpCLHVCQUFXO0FBQ1AxVSx1QkFBT3FXLFlBQVk1ZixLQUFaLENBQWtCLEdBQWxCLENBREE7QUFFUHNULHdCQUZPO0FBR1A1RztBQUhPLGFBQVgsRUFJR2dULFdBSkg7QUFLSDtBQUNKLEs7O3VCQUVEakUsYyw2QkFBaUI7QUFDYixlQUFPLDJCQUFZLElBQVosQ0FBUDtBQUNILEs7O3VCQUVEa0UsYSw0QkFBZ0I7QUFBQSxZQUNKbFUsTUFESSxHQUNPLEtBQUs5USxLQURaLENBQ0o4USxNQURJOzs7QUFHWixlQUFPQSxXQUFXNEksbUJBQVMwSyxRQUFwQixHQUErQjFLLG1CQUFTMEssUUFBeEMsR0FBbUQsd0JBQVN0VCxNQUFULEVBQWlCLEtBQUs5USxLQUF0QixDQUExRDtBQUNILEs7O3VCQUVENmtCLFksMkJBQWU7QUFBQTs7QUFDWHJFLHFCQUFhLEtBQUtzRSxhQUFsQjs7QUFFQSxhQUFLQSxhQUFMLEdBQXFCaEYsV0FBVyxZQUFNO0FBQ2xDLG1CQUFLNkUsV0FBTDtBQUNILFNBRm9CLEVBRWxCLEdBRmtCLENBQXJCO0FBR0gsSzs7dUJBRUR0akIsTSxxQkFBUztBQUNMLGVBQU9DLGdCQUFTQyxJQUFULENBQWMsS0FBS3ZCLEtBQUwsQ0FBV3dCLFFBQXpCLENBQVA7QUFDSCxLOzs7RUE3R2lDQyxnQixVQUMzQjJpQixRLEdBQVcxSyxtQkFBUzBLLFEsU0FFcEIxaUIsUyxHQUFZO0FBQ2ZGLGNBQVVHLG9CQUFVOE8sSUFETDtBQUVmSyxZQUFRblAsb0JBQVVpTSxHQUZIO0FBR2ZnQixXQUFPak4sb0JBQVU2TyxTQUFWLENBQW9CLENBQUM3TyxvQkFBVUMsTUFBWCxFQUFtQkQsb0JBQVVFLElBQTdCLENBQXBCLENBSFE7QUFJZnFoQixZQUFRdmhCLG9CQUFVa00sS0FKSDtBQUtmd1Ysb0JBQWdCMWhCLG9CQUFVaEUsSUFMWDtBQU1mMmxCLGdCQUFZM2hCLG9CQUFVaEUsSUFOUDtBQU9mMmpCLGdCQUFZM2Ysb0JBQVVFLElBUFA7QUFRZitpQixzQkFBa0JqakIsb0JBQVVFLElBUmI7QUFTZjRoQiwwQkFBc0I5aEIsb0JBQVVFLElBVGpCO0FBVWZ4QixTQUFLc0Isb0JBQVVFO0FBVkEsQyxTQWFaRSxZLEdBQWU7QUFDbEI2TSxXQUFPLE9BRFc7QUFFbEJzVSxZQUFRLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FGVTtBQUdsQkcsb0JBQWdCNVgsSUFIRTtBQUlsQjZYLGdCQUFZN1gsSUFKTTtBQUtsQjZWLGdCQUFZLElBTE07QUFNbEJzRCxzQkFBa0IsSUFOQTtBQU9sQm5CLDBCQUFzQixLQVBKO0FBUWxCcGpCLFNBQUs7QUFSYSxDO0FBaEJMaUwsUTtrQkFBQUEsUTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNYckI7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNRyxPQUFPLFNBQVBBLElBQU8sR0FBTSxDQUFHLENBQXRCO0lBQ3FCNFosTTs7Ozs7Ozs7Ozs7OzRKQTRCakJDLFUsR0FBYSxVQUFDN21CLENBQUQsRUFBSWdSLENBQUosRUFBT0gsSUFBUCxFQUFnQjtBQUN6QixrQkFBS3RQLEtBQUwsQ0FBV3VsQixhQUFYLENBQXlCOW1CLENBQXpCLEVBQTRCZ1IsQ0FBNUIsRUFBK0JILElBQS9CO0FBQ0gsUyxRQUVEa1csTSxHQUFTLFVBQUM3VyxTQUFELEVBQVk4VyxLQUFaLEVBQW1CQyxJQUFuQixFQUE0QjtBQUNqQyxrQkFBSzFsQixLQUFMLENBQVd3bEIsTUFBWCxDQUFrQjdXLFNBQWxCLEVBQTZCOFcsS0FBN0IsRUFBb0NDLElBQXBDO0FBQ0gsUzs7O3FCQUVEcmtCLE0scUJBQVM7QUFBQTs7QUFDTDtBQURLLHFCQUlELEtBQUtyQixLQUpKO0FBQUEsWUFFR0MsTUFGSCxVQUVHQSxNQUZIO0FBQUEsWUFFVzJGLFNBRlgsVUFFV0EsU0FGWDtBQUFBLFlBRXNCcEUsUUFGdEIsVUFFc0JBLFFBRnRCO0FBQUEsWUFFMkMySyxHQUYzQyxVQUVnQzFCLFNBRmhDO0FBQUEsWUFFZ0QyQixRQUZoRCxVQUVnREEsUUFGaEQ7QUFBQSxZQUUwRFMsT0FGMUQsVUFFMERBLE9BRjFEO0FBQUEsWUFFbUUzTSxNQUZuRSxVQUVtRUEsTUFGbkU7QUFBQSxZQUUyRXlsQixZQUYzRSxVQUUyRUEsWUFGM0U7QUFBQSxZQUdEQyxRQUhDLFVBR0RBLFFBSEM7QUFBQSxZQUdTclosVUFIVCxVQUdTQSxVQUhUO0FBQUEsWUFHcUJzWixRQUhyQixVQUdxQkEsUUFIckI7QUFBQSxZQUcrQk4sYUFIL0IsVUFHK0JBLGFBSC9CO0FBQUEsWUFHOENDLE1BSDlDLFVBRzhDQSxNQUg5QztBQUFBLFlBR3NERSxJQUh0RCxVQUdzREEsSUFIdEQ7QUFBQSxZQUc0REksY0FINUQsVUFHNERBLGNBSDVEO0FBQUEsWUFHNEUzbEIsSUFINUUsVUFHNEVBLElBSDVFO0FBQUEsWUFHcUY0SCxNQUhyRjs7QUFBQSwrQkFNc0d3RSxVQU50RyxDQU1HUyxJQU5IO0FBQUEsWUFNR0EsSUFOSCxvQ0FNVUMsY0FOVjtBQUFBLGlDQU1zR1YsVUFOdEcsQ0FNeUJ3WixNQU56QjtBQUFBLFlBTXlCQSxNQU56QixzQ0FNa0NDLGdCQU5sQztBQUFBLCtCQU1zR3paLFVBTnRHLENBTW1EMFosSUFObkQ7QUFBQSxZQU1tREEsSUFObkQsb0NBTTBEQyxjQU4xRDtBQUFBLGlDQU1zRzNaLFVBTnRHLENBTXlFNFosTUFOekU7QUFBQSxZQU15RUEsTUFOekUsc0NBTWtGQyxnQkFObEY7O0FBT0wsWUFBTWhYLFVBQVV2QyxRQUFRbE8sTUFBeEI7O0FBRUEsWUFBTTRKLFNBQVNzRSxRQUFRM0osR0FBUixDQUFZLFVBQUNtakIsSUFBRCxFQUFPcmEsS0FBUCxFQUFpQjtBQUN4QyxnQkFBTXNhLE1BQU1ELEtBQUtuakIsR0FBTCxDQUFTLFVBQUNvakIsR0FBRCxFQUFNN1csQ0FBTixFQUFZO0FBQUE7O0FBQzdCO0FBRDZCLG9CQUV2QkksS0FGdUIsR0FFeUd5VyxHQUZ6RyxDQUV2QnpXLEtBRnVCO0FBQUEsb0JBRWhCVixPQUZnQixHQUV5R21YLEdBRnpHLENBRWhCblgsT0FGZ0I7QUFBQSxvQkFFUGUsUUFGTyxHQUV5R29XLEdBRnpHLENBRVBwVyxRQUZPO0FBQUEsb0JBRUdOLFNBRkgsR0FFeUcwVyxHQUZ6RyxDQUVHMVcsU0FGSDtBQUFBLG9CQUVjakIsU0FGZCxHQUV5RzJYLEdBRnpHLENBRWMzWCxTQUZkO0FBQUEsb0JBRXlCc0IsT0FGekIsR0FFeUdxVyxHQUZ6RyxDQUV5QnJXLE9BRnpCO0FBQUEsb0JBRWtDRCxVQUZsQyxHQUV5R3NXLEdBRnpHLENBRWtDdFcsVUFGbEM7QUFBQSxvQkFFOENuQixLQUY5QyxHQUV5R3lYLEdBRnpHLENBRThDelgsS0FGOUM7QUFBQSxvQkFFcURELEtBRnJELEdBRXlHMFgsR0FGekcsQ0FFcUQxWCxLQUZyRDtBQUFBLG9CQUU0RGhKLFNBRjVELEdBRXlHMGdCLEdBRnpHLENBRTREMWdCLFNBRjVEO0FBQUEsb0JBRXVFbUssWUFGdkUsR0FFeUd1VyxHQUZ6RyxDQUV1RXZXLFlBRnZFO0FBQUEsb0JBRXFGSSxJQUZyRixHQUV5R21XLEdBRnpHLENBRXFGblcsSUFGckY7QUFBQSxvQkFFOEZwSSxNQUY5Riw0QkFFeUd1ZSxHQUZ6Rzs7QUFJN0IxZ0IsNEJBQVkseURBQ0ozRixNQURJLDBCQUN3QixJQUR4QixjQUVKQSxNQUZJLCtCQUU2QjJQLFNBRjdCLGNBR1BoSyxTQUhPLElBR0tBLFNBSEwsZUFBWjtBQUtBLG9CQUFJa0osUUFBUSxFQUFaO0FBQUEsb0JBQWdCeVgsb0JBQWhCO0FBQUEsb0JBQTZCQyxzQkFBN0I7QUFBQSxvQkFBNENDLHNCQUE1QztBQUNBLG9CQUFJSCxJQUFJOWtCLFFBQUosSUFBZ0I4a0IsSUFBSTlrQixRQUFKLENBQWE3QyxNQUFqQyxFQUF5QztBQUNyQ21RLDBCQUFNSyxPQUFOLEdBQWdCQSxPQUFoQjtBQUNILGlCQUZELE1BRU87QUFDSCx3QkFBSWUsUUFBSixFQUFjO0FBQ1ZxVyxzQ0FBZSw4QkFBQyxJQUFELElBQU0sUUFBUXRtQixNQUFkO0FBQ1gsdUNBQVcwTyxTQURBO0FBRVgsb0NBQVEsT0FBSzZXLE1BRkY7QUFHWCxrQ0FBTUUsSUFISztBQUlYLG9DQUFReGxCLE1BSkcsR0FBZjtBQUtIO0FBQ0Qsd0JBQUkwUCxTQUFKLEVBQWU7QUFDWDZXLHdDQUFnQiw4QkFBQyxNQUFELElBQVEsUUFBUXhtQixNQUFoQixFQUF3QixXQUFXME8sU0FBbkMsRUFBOEMsVUFBVW1YLGNBQXhELEdBQWhCO0FBQ0g7O0FBRUQsd0JBQUk3VixPQUFKLEVBQWE7QUFDVHVXLHdDQUFnQnZXLFFBQVF0UixNQUFSLEdBQ1gsOEJBQUMsTUFBRCxJQUFRLFdBQVdnUSxTQUFuQjtBQUNHLHFDQUFTc0IsT0FEWjtBQUVHLG9DQUFRaFEsTUFGWDtBQUdHLG9DQUFRQyxNQUhYO0FBSUcsMENBQWN5bEIsWUFKakI7QUFLRyx3Q0FBWTNWLFVBTGY7QUFNRyxzQ0FBVTRWLFFBTmIsR0FEVyxHQU9rQixJQVBsQztBQVFIO0FBQ0Q5VywwQkFBTU0sT0FBTixHQUFnQkEsVUFBVXBELEtBQTFCO0FBQ0g7QUFDRCx1QkFBUTtBQUFDLHdCQUFEO0FBQUEsaUNBQVVqRSxNQUFWLEVBQXNCK0csS0FBdEI7QUFDSiw2QkFBS1csQ0FERDtBQUVKLGdDQUFReFAsTUFGSjtBQUdKLDhCQUFNRSxJQUhGO0FBSUosOEJBQU0wUCxLQUpGO0FBS0osbUNBQVUsSUFMTjtBQU1KLCtCQUFPakIsS0FOSDtBQU9KLG1DQUFXaEosU0FQUDtBQVFKLDZCQUFLLE9BQUswZixVQUFMLENBQWdCNVgsSUFBaEIsQ0FBcUIsTUFBckIsRUFBMkIxQixLQUEzQixFQUFrQ3lELENBQWxDLENBUkQ7QUFTSiw4QkFBSyxRQVREO0FBVUg4VywrQkFWRztBQVVVQyxpQ0FWVjtBQVV5QkM7QUFWekIsaUJBQVI7QUFZSCxhQWhEVyxDQUFaO0FBaURBLG1CQUFPO0FBQUE7QUFBQSxrQkFBSSxLQUFLemEsS0FBVDtBQUFpQnNhO0FBQWpCLGFBQVA7QUFDSCxTQW5EYyxDQUFmOztBQXFEQSxlQUFRO0FBQUMsZUFBRDtBQUFBLHVCQUFLLFdBQVcxZ0IsU0FBaEIsSUFBK0JtQyxNQUEvQjtBQUNIUSxrQkFERztBQUVIL0c7QUFGRyxTQUFSO0FBSUgsSzs7O0VBdEcrQm1NLGdCQUFNbE0sUyxVQUMvQkMsUyxHQUFZO0FBQ2ZGLGNBQVVHLG9CQUFVaU0sR0FETDtBQUVmM04sWUFBUTBCLG9CQUFVQyxNQUZIO0FBR2Z6QixVQUFNd0Isb0JBQVVFLElBSEQ7QUFJZitELGVBQVdqRSxvQkFBVUMsTUFKTjtBQUtmNkksZUFBVzlJLG9CQUFVQyxNQUxOO0FBTWZpTCxhQUFTbEwsb0JBQVVrTSxLQU5KO0FBT2Z6QixjQUFVekssb0JBQVVqRixNQVBMO0FBUWY2b0IsbUJBQWU1akIsb0JBQVVoRSxJQVJWO0FBU2Z1QyxZQUFReUIsb0JBQVVqRixNQVRIO0FBVWZpcEIsa0JBQWNoa0Isb0JBQVVqRixNQVZUO0FBV2ZrcEIsY0FBVWprQixvQkFBVWhFLElBWEw7QUFZZjRPLGdCQUFZNUssb0JBQVVqRixNQVpQO0FBYWZncEIsVUFBTS9qQixvQkFBVWpGLE1BYkQ7QUFjZjhvQixZQUFRN2pCLG9CQUFVaEUsSUFkSDtBQWVmbW9CLG9CQUFnQm5rQixvQkFBVWhFO0FBZlgsQyxTQWlCWm9FLFksR0FBZTtBQUNsQjBJLGVBQVcsT0FETztBQUVsQm9DLGFBQVMsRUFGUztBQUdsQjBZLG1CQUFlOVosSUFIRztBQUlsQm1hLGNBQVVuYSxJQUpRO0FBS2xCYyxnQkFBWSxFQUxNO0FBTWxCaVosWUFBUS9aLElBTlU7QUFPbEJxYSxvQkFBZ0JyYTtBQVBFLEM7QUFsQkw0WixNO2tCQUFBQSxNOzs7Ozs7Ozs7Ozs7Ozs7QUNUckI7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBO0lBQ3FCVSxNOzs7QUFlakIsb0JBQVkvbEIsS0FBWixFQUFtQjtBQUFBOztBQUFBLHFEQUNmLDRCQUFNQSxLQUFOLENBRGU7O0FBQUE7O0FBRWYsWUFBTTJsQixlQUFlM2xCLE1BQU0ybEIsWUFBTixJQUFzQixFQUEzQztBQUNBLFlBQU1lLGVBQWVmLGFBQWEzbEIsTUFBTTJPLFNBQW5CLEtBQWlDLEVBQXREO0FBQ0EsY0FBSzNGLEtBQUwsR0FBYTtBQUNUdVYscUJBQVNtSSxhQUFhbkksT0FBYixJQUF3QixLQUR4QjtBQUVUaE4sMEJBQWNtVixhQUFhblYsWUFBYixJQUE2QjtBQUZsQyxTQUFiO0FBSUEsY0FBS29WLGFBQUwsYUFBeUIsTUFBSzNkLEtBQUwsQ0FBV3VJLFlBQXBDO0FBUmU7QUFTbEI7O3FCQUVEMVEseUIsc0NBQTBCQyxTLEVBQVc7QUFDakMsWUFBSUEsVUFBVXhDLGNBQVYsQ0FBeUIsY0FBekIsS0FBNEMsT0FBT3dDLFVBQVU2a0IsWUFBakIsS0FBa0MsV0FBbEYsRUFBK0Y7QUFDM0YsZ0JBQU1oWCxZQUFZN04sVUFBVTZOLFNBQVYsSUFBdUIsS0FBSzNPLEtBQUwsQ0FBVzJPLFNBQXBEO0FBQ0EsZ0JBQU1nWCxlQUFlN2tCLFVBQVU2a0IsWUFBVixJQUEwQixFQUEvQztBQUNBLGdCQUFNZSxlQUFlZixhQUFhaFgsU0FBYixLQUEyQixFQUFoRDtBQUNBLGdCQUFNNEMsZUFBZW1WLGFBQWFuVixZQUFiLElBQTZCLEVBQWxEO0FBQ0EsaUJBQUsrTixRQUFMLENBQWM7QUFDVi9OO0FBRFUsYUFBZDtBQUdBLGlCQUFLb1YsYUFBTCxhQUF5QnBWLFlBQXpCO0FBQ0g7QUFDSixLOztxQkFrRURsUSxNLHFCQUFTO0FBQUEscUJBQzJDLEtBQUtyQixLQURoRDtBQUFBLFlBQ0dpUSxPQURILFVBQ0dBLE9BREg7QUFBQSxZQUNZaFEsTUFEWixVQUNZQSxNQURaO0FBQUEsWUFDb0JDLE1BRHBCLFVBQ29CQSxNQURwQjtBQUFBLFlBQzRCOFAsVUFENUIsVUFDNEJBLFVBRDVCO0FBQUEscUJBRTZCLEtBQUtoSCxLQUZsQztBQUFBLFlBRUd1VixPQUZILFVBRUdBLE9BRkg7QUFBQSxZQUVZaE4sWUFGWixVQUVZQSxZQUZaOzs7QUFJTCxpQkFBU3FWLGNBQVQsQ0FBd0J6akIsSUFBeEIsRUFBOEI7QUFDMUIsbUJBQU87QUFBQyw4QkFBRCxDQUFNLElBQU47QUFBQSxrQkFBVyxLQUFLQSxLQUFLeUUsS0FBckI7QUFBNkJ6RSxxQkFBS21QO0FBQWxDLGFBQVA7QUFDSDs7QUFFRCxpQkFBU3VVLGFBQVQsQ0FBdUIxYixNQUF2QixFQUErQjNKLFFBQS9CLEVBQXlDO0FBQ3JDLG1CQUNJO0FBQUMsOEJBQUQsQ0FBTSxPQUFOO0FBQUEsa0JBQWMsT0FBTzJKLE9BQU9tSCxLQUE1QixFQUFtQyxLQUFLbkgsT0FBT3ZELEtBQS9DLEVBQXNELFlBQVksS0FBbEU7QUFDS2tmLGtDQUFrQnRsQixRQUFsQjtBQURMLGFBREo7QUFLSDs7QUFFRCxpQkFBU3NsQixpQkFBVCxDQUEyQjlqQixJQUEzQixFQUFpQztBQUM3QixtQkFBT0EsS0FBS0UsR0FBTCxDQUFTLGdCQUFRO0FBQ3BCLG9CQUFJQyxLQUFLM0IsUUFBVCxFQUFtQjtBQUNmLDJCQUFPcWxCLGNBQWMxakIsSUFBZCxFQUFvQkEsS0FBSzNCLFFBQXpCLENBQVA7QUFDSCxpQkFGRCxNQUVPO0FBQ0gsMkJBQU9vbEIsZUFBZXpqQixJQUFmLENBQVA7QUFDSDtBQUNKLGFBTk0sQ0FBUDtBQU9IOztBQUVELFlBQU1DLFVBQVUwakIsa0JBQWtCN1csT0FBbEIsQ0FBaEI7QUFBQSxZQUNJekgsU0FDSTtBQUFBO0FBQUEsY0FBSyxXQUFjdkksTUFBZCx3QkFBTDtBQUNJO0FBQUMsZ0NBQUQ7QUFBQSxrQkFBUSxNQUFLLFNBQWIsRUFBdUIsU0FBUyxLQUFLOG1CLGVBQXJDO0FBQXVEN21CLHVCQUFPOFM7QUFBOUQsYUFESjtBQUVJO0FBQUMsZ0NBQUQ7QUFBQSxrQkFBUSxTQUFTLEtBQUtnVSxhQUF0QjtBQUFzQzltQix1QkFBT21WO0FBQTdDO0FBRkosU0FGUjs7QUFRQSxlQUNJO0FBQUMsOEJBQUQ7QUFBQSxjQUFVLFNBQ047QUFBQTtBQUFBLHNCQUFNLE1BQUssUUFBWDtBQUNJLHNDQUFZblYsT0FBT3VWLE1BRHZCO0FBRUksbUNBQVcsS0FBS3dSLGFBRnBCO0FBR0ksa0NBQVMsR0FIYjtBQUlJLG1DQUFjaG5CLE1BQWQsaUJBSko7QUFLSSxrREFBQyxjQUFELElBQU0sTUFBSyxRQUFYLEVBQW9CLE1BQUssT0FBekI7QUFMSixpQkFESjtBQVNBLDZCQUFZLE9BVFo7QUFVQSx5QkFBU3NlLE9BVlQ7QUFXQSwrQkFYQTtBQVlBLDJCQUFXO0FBQUEsMkJBQVE5TixLQUFLbkksVUFBYjtBQUFBLGlCQVpYO0FBYUEsaUNBQWlCLEtBQUs0ZSxlQWJ0QjtBQWNJO0FBQUMsOEJBQUQ7QUFBQSxrQkFBTSxRQUFRMWUsTUFBZDtBQUNJLGtDQUFjK0ksWUFEbEI7QUFFSSxnQ0FBWXZCLFVBRmhCO0FBR0ksOEJBQVUsS0FBS21YLGNBSG5CO0FBSUsvakI7QUFKTDtBQWRKLFNBREo7QUF1QkgsSzs7O0VBaEsrQnVLLGdCQUFNbE0sUyxVQUMvQkMsUyxHQUFZO0FBQ2ZpTixlQUFXaE4sb0JBQVVDLE1BRE47QUFFZnFPLGFBQVN0TyxvQkFBVWtNLEtBRko7QUFHZm1DLGdCQUFZck8sb0JBQVVDLE1BSFA7QUFJZitqQixrQkFBY2hrQixvQkFBVWpGLE1BSlQ7QUFLZndELFlBQVF5QixvQkFBVWpGLE1BTEg7QUFNZmtwQixjQUFVamtCLG9CQUFVaEUsSUFOTDtBQU9mc0MsWUFBUTBCLG9CQUFVQztBQVBILEMsU0FVWkcsWSxHQUFlO0FBQ2xCNmpCLGNBQVUsb0JBQU0sQ0FBRTtBQURBLEM7OztTQTRCdEJxQixhLEdBQWdCLGFBQUs7QUFDakI5bEIsVUFBRTJJLGNBQUY7QUFDQTNJLFVBQUV3SSxlQUFGOztBQUVBLFlBQUl4SSxFQUFFdVEsT0FBRixLQUFjdlQsY0FBUW1kLEtBQTFCLEVBQWlDO0FBQzdCLG1CQUFLZ0UsUUFBTCxDQUFjO0FBQ1ZmLHlCQUFTLENBQUMsT0FBS3ZWLEtBQUwsQ0FBV3VWO0FBRFgsYUFBZDtBQUdIO0FBQ0osSzs7U0FFRDJJLGUsR0FBa0IsVUFBQzNJLE9BQUQsRUFBYTtBQUMzQixlQUFLZSxRQUFMLENBQWM7QUFDVmY7QUFEVSxTQUFkOztBQUlBLFlBQUksQ0FBQ0EsT0FBTCxFQUFjO0FBQ1YsZ0JBQU1oTix5QkFBbUIsT0FBS29WLGFBQXhCLENBQU47O0FBRUEsbUJBQUtySCxRQUFMLENBQWM7QUFDVi9OO0FBRFUsYUFBZDtBQUdIO0FBQ0osSzs7U0FFRDRWLGMsR0FBaUIsVUFBQzVWLFlBQUQsRUFBa0I7QUFDL0IsZUFBSytOLFFBQUwsQ0FBYztBQUNWZixxQkFBUyxJQURDO0FBRVZoTjtBQUZVLFNBQWQ7QUFJSCxLOztTQUVEd1YsZSxHQUFrQixZQUFNO0FBQ3BCLFlBQU14VixlQUFlLE9BQUt2SSxLQUFMLENBQVd1SSxZQUFoQztBQUNNLDJCQUFlLEVBQWY7QUFBQSxZQUFxQjVDLFNBQXJCLEdBQW1DLE9BQUszTyxLQUF4QyxDQUFxQjJPLFNBQXJCOztBQUVOZ1gscUJBQWFoWCxTQUFiLElBQTBCO0FBQ3RCNFAscUJBQVMsS0FEYTtBQUV0QmhOLDBCQUFjQTtBQUZRLFNBQTFCO0FBSUEsZUFBS29WLGFBQUwsYUFBeUJwVixZQUF6QjtBQUNBLGVBQUsrTixRQUFMLENBQWM7QUFDVmYscUJBQVM7QUFEQyxTQUFkO0FBR0E7QUFDQSxlQUFLdmUsS0FBTCxDQUFXNGxCLFFBQVgsQ0FBb0JELFlBQXBCO0FBQ0gsSzs7U0FFRHFCLGEsR0FBZ0IsWUFBTTtBQUNaLDJCQUFlLEVBQWY7QUFBQSxZQUFxQnJZLFNBQXJCLEdBQW1DLE9BQUszTyxLQUF4QyxDQUFxQjJPLFNBQXJCOztBQUVOZ1gscUJBQWFoWCxTQUFiLElBQTBCO0FBQ3RCNFAscUJBQVMsS0FEYTtBQUV0QmhOLDBCQUFjO0FBRlEsU0FBMUI7QUFJQSxlQUFLb1YsYUFBTCxHQUFxQixFQUFyQjtBQUNBLGVBQUtySCxRQUFMLENBQWM7QUFDVi9OLDBCQUFjLEVBREo7QUFFVmdOLHFCQUFTO0FBRkMsU0FBZDtBQUlBO0FBQ0EsZUFBS3ZlLEtBQUwsQ0FBVzRsQixRQUFYLENBQW9CRCxZQUFwQjtBQUNILEs7O0FBckdnQkksTTtrQkFBQUEsTTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNUckI7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztJQUVRL2QsTyxHQUFZckssVSxDQUFacUssTztJQUNBekIsVSxHQUFlMUksUyxDQUFmMEksVTs7QUFDUixJQUFNa0YsT0FBTyxTQUFQQSxJQUFPLEdBQU0sQ0FBRSxDQUFyQjs7QUFFQTs7O0lBR3FCMmIsSTs7O0FBeUtqQixrQkFBWXBuQixLQUFaLEVBQW1CO0FBQUE7O0FBQUEscURBQ2Ysc0JBQU1BLEtBQU4sQ0FEZTs7QUFBQSwwQkFHMkUsTUFBS0EsS0FIaEY7QUFBQSxZQUdQd0IsUUFITyxlQUdQQSxRQUhPO0FBQUEsWUFHRytQLFlBSEgsZUFHR0EsWUFISDtBQUFBLFlBR2lCOFYsbUJBSGpCLGVBR2lCQSxtQkFIakI7QUFBQSxZQUdzQ3RlLFVBSHRDLGVBR3NDQSxVQUh0QztBQUFBLFlBR2tESixTQUhsRCxlQUdrREEsU0FIbEQ7QUFBQSxZQUc2RG1aLFNBSDdELGVBRzZEQSxTQUg3RDs7O0FBS2YsY0FBS3dGLFdBQUwsR0FBbUIsTUFBS0MsY0FBTCxDQUFvQi9sQixRQUFwQixDQUFuQjs7QUFFQSxZQUFJbUgsU0FBSixFQUFlO0FBQ1gsa0JBQUtvQyxXQUFMLEdBQW1CLE1BQUt5YywwQkFBTCxDQUFnQyxHQUFoQyxDQUFuQjtBQUNIO0FBQ0QsY0FBS3hlLEtBQUwsR0FBYTtBQUNUeWUsc0JBQVUsTUFBS0MsZUFBTCxDQUFxQjFuQixLQUFyQixDQUREO0FBRVR1UiwwQkFBYyxNQUFLb1csZ0JBQUwsQ0FBc0JwVyxnQkFBZ0I4VixtQkFBdEMsQ0FGTDtBQUdUdGUsd0JBQVksZ0JBQWdCLE1BQUsvSSxLQUFyQixHQUE2QitJLFVBQTdCLEdBQTJDSixhQUFhbVosU0FBYixHQUF5QixNQUFLL1csV0FBOUIsR0FBNEM7QUFIMUYsU0FBYjs7QUFNQS9DLHVCQUFjLENBQUMsWUFBRCxFQUFlLGNBQWYsRUFBK0IsaUJBQS9CLEVBQWtELG1CQUFsRCxFQUF1RSxRQUF2RSxDQUFkOztBQUVBLGNBQUs0ZixVQUFMLEdBQWtCLEVBQWxCO0FBbEJlO0FBbUJsQjs7bUJBRUQxZixpQixnQ0FBb0I7QUFDaEIsYUFBS0csUUFBTCxHQUFnQiwyQkFBWSxJQUFaLENBQWhCO0FBQ0gsSzs7bUJBRUR4SCx5QixzQ0FBMEJDLFMsRUFBVztBQUNqQyxZQUFNa0ksUUFBUSxFQUFkOztBQUVBLFlBQUksY0FBY2xJLFNBQWxCLEVBQTZCO0FBQ3pCa0ksa0JBQU15ZSxRQUFOLEdBQWlCLEtBQUtFLGdCQUFMLENBQXNCN21CLFVBQVUybUIsUUFBaEMsQ0FBakI7QUFDSDtBQUNELFlBQUksa0JBQWtCM21CLFNBQXRCLEVBQWlDO0FBQzdCa0ksa0JBQU11SSxZQUFOLEdBQXFCLEtBQUtvVyxnQkFBTCxDQUFzQjdtQixVQUFVeVEsWUFBaEMsQ0FBckI7QUFDSDtBQUNELFlBQUksZ0JBQWdCelEsU0FBcEIsRUFBK0I7QUFDM0JrSSxrQkFBTUQsVUFBTixHQUFtQmpJLFVBQVVpSSxVQUE3QjtBQUNIOztBQUVELFlBQUlsRSxPQUFPQyxJQUFQLENBQVlrRSxLQUFaLEVBQW1CckssTUFBdkIsRUFBK0I7QUFDM0IsaUJBQUsyZ0IsUUFBTCxDQUFjdFcsS0FBZDtBQUNIO0FBQ0osSzs7bUJBRUQ2ZSxtQixnQ0FBb0IvbUIsUyxFQUFXO0FBQzNCLGFBQUt3bUIsV0FBTCxHQUFtQixLQUFLQyxjQUFMLENBQW9Cem1CLFVBQVVVLFFBQTlCLENBQW5CO0FBQ0EsWUFBSSxLQUFLeEIsS0FBTCxDQUFXMkksU0FBZixFQUEwQjtBQUN0QixnQkFBSSxLQUFLb0MsV0FBTCxJQUFvQixLQUFLK2MsR0FBN0IsRUFBa0M7QUFDOUIsb0JBQUksS0FBSzllLEtBQUwsQ0FBV0QsVUFBZixFQUEyQjtBQUN2Qix5QkFBS2dDLFdBQUwsR0FBbUIsS0FBSy9CLEtBQUwsQ0FBV0QsVUFBOUI7QUFDSDtBQUNKLGFBSkQsTUFJTztBQUNILHFCQUFLZ0MsV0FBTCxHQUFtQixLQUFLeWMsMEJBQUwsQ0FBZ0MsR0FBaEMsQ0FBbkI7QUFDSDtBQUNKO0FBQ0osSzs7bUJBRURPLE0sbUJBQU81bUIsQyxFQUFHO0FBQ04sYUFBS21lLFFBQUwsQ0FBYztBQUNWdlcsd0JBQVk7QUFERixTQUFkOztBQUlBLGFBQUsvSSxLQUFMLENBQVcrbkIsTUFBWCxJQUFxQixLQUFLL25CLEtBQUwsQ0FBVytuQixNQUFYLENBQWtCNW1CLENBQWxCLENBQXJCO0FBQ0gsSzs7bUJBRUR1bUIsZSw0QkFBZ0IxbkIsSyxFQUFPO0FBQUE7O0FBQ25CLFlBQUlnb0IscUJBQUo7O0FBRG1CLFlBR1hQLFFBSFcsR0FHbUR6bkIsS0FIbkQsQ0FHWHluQixRQUhXO0FBQUEsWUFHRFEsZUFIQyxHQUdtRGpvQixLQUhuRCxDQUdEaW9CLGVBSEM7QUFBQSxZQUdnQkMsY0FIaEIsR0FHbURsb0IsS0FIbkQsQ0FHZ0Jrb0IsY0FIaEI7QUFBQSxZQUdnQ0MsSUFIaEMsR0FHbURub0IsS0FIbkQsQ0FHZ0Ntb0IsSUFIaEM7QUFBQSxZQUdzQ0MsUUFIdEMsR0FHbURwb0IsS0FIbkQsQ0FHc0Nvb0IsUUFIdEM7O0FBSW5CLFlBQUlYLFFBQUosRUFBYztBQUNWTywyQkFBZVAsUUFBZjtBQUNILFNBRkQsTUFFTyxJQUFJUyxrQkFBa0JDLFNBQVMsUUFBM0IsSUFBdUNDLGFBQWEsVUFBeEQsRUFBb0U7QUFDdkVKLDJCQUFlbmpCLE9BQU9DLElBQVAsQ0FBWSxLQUFLZ2pCLEdBQWpCLEVBQXNCclMsTUFBdEIsQ0FBNkIsZUFBTztBQUMvQyx1QkFBTyxPQUFLcVMsR0FBTCxDQUFTM29CLEdBQVQsRUFBY3VHLElBQWQsS0FBdUIsU0FBOUI7QUFDSCxhQUZjLENBQWY7QUFHSCxTQUpNLE1BSUE7QUFDSHNpQiwyQkFBZUMsZUFBZjtBQUNIOztBQUVELGVBQU8sS0FBS04sZ0JBQUwsQ0FBc0JLLFlBQXRCLENBQVA7QUFDSCxLOzttQkFFRFQsYywyQkFBZS9sQixRLEVBQVU7QUFBQTs7QUFDckIsYUFBS3NtQixHQUFMLEdBQVcsRUFBWDtBQUNBLGFBQUtPLEdBQUwsR0FBVyxFQUFYO0FBQ0EsWUFBTWplLE9BQU8sU0FBUEEsSUFBTyxDQUFDNUksUUFBRCxFQUFXOG1CLFNBQVgsRUFBc0Q7QUFBQSxnQkFBaENDLFlBQWdDLHVFQUFqQixFQUFFdmMsT0FBTyxDQUFULEVBQWlCOztBQUMvRCxtQkFBTzFLLGdCQUFTNEIsR0FBVCxDQUFhMUIsUUFBYixFQUF1QixpQkFBUztBQUNuQyxvQkFBSTZJLFNBQVMsT0FBT0EsTUFBTTNFLElBQWIsS0FBc0IsVUFBL0IsSUFBOEMsbUJBQW1CMkUsTUFBTTNFLElBQTNFLEVBQWtGO0FBQzlFLHdCQUFJOGlCLGlCQUFKOztBQUVBLHdCQUFJQyxZQUFKO0FBQ0Esd0JBQU16b0IsUUFBUSxFQUFFcUMsTUFBTSxNQUFSLEVBQWQ7O0FBRUEsd0JBQUksQ0FBQyxNQUFELEVBQVMsU0FBVCxFQUFvQixPQUFwQixFQUE2QjJDLE9BQTdCLENBQXFDcUYsTUFBTTNFLElBQU4sQ0FBV3dNLGFBQWhELElBQWlFLENBQUMsQ0FBdEUsRUFBeUU7QUFDckV1Vyw4QkFBU0gsU0FBVCxTQUFzQkMsYUFBYXZjLEtBQWIsRUFBdEI7QUFDQSw0QkFBTTdNLE1BQU0sT0FBT2tMLE1BQU1sTCxHQUFiLEtBQXFCLFFBQXJCLEdBQWdDa0wsTUFBTWxMLEdBQXRDLEdBQTRDc3BCLEdBQXhEO0FBQ0EsNEJBQU1uZSxRQUFRbWUsSUFBSXBqQixLQUFKLENBQVUsR0FBVixFQUFlMUcsTUFBZixHQUF3QixDQUF0QztBQUNBLCtCQUFLbXBCLEdBQUwsQ0FBUzNvQixHQUFULElBQWdCLE9BQUtrcEIsR0FBTCxDQUFTSSxHQUFULElBQWdCO0FBQzVCdHBCLG9DQUQ0QjtBQUU1QnNwQixvQ0FGNEI7QUFHNUIvaUIsa0NBQU0yRSxNQUFNM0UsSUFBTixDQUFXd00sYUFIVztBQUk1QnRKLHNDQUFVeUIsTUFBTXJLLEtBQU4sQ0FBWTRJLFFBSk07QUFLNUIwSixtQ0FBT2pJLE1BQU1ySyxLQUFOLENBQVlzUyxLQUFaLElBQXFCakksTUFBTXJLLEtBQU4sQ0FBWXdCO0FBTFoseUJBQWhDOztBQVFBeEIsOEJBQU04SSxJQUFOLEdBQWEzSixHQUFiO0FBQ0FhLDhCQUFNc0ssS0FBTixHQUFjQSxLQUFkO0FBQ0F0Syw4QkFBTXdLLFdBQU4sR0FBb0JILE1BQU0zRSxJQUFOLENBQVd3TSxhQUFYLEtBQTZCLE9BQTdCLEdBQXVDLENBQXZDLEdBQTJDLENBQS9EO0FBQ0g7O0FBRUQsNEJBQVE3SCxNQUFNM0UsSUFBTixDQUFXd00sYUFBbkI7QUFDSSw2QkFBSyxTQUFMO0FBQ0lzVyx1Q0FBVyx5QkFBYW5lLEtBQWIsRUFBb0JySyxLQUFwQixFQUEyQm9LLEtBQUtDLE1BQU1ySyxLQUFOLENBQVl3QixRQUFqQixFQUEyQmluQixHQUEzQixDQUEzQixDQUFYO0FBQ0E7QUFDSiw2QkFBSyxPQUFMO0FBQ0lELHVDQUFXLHlCQUFhbmUsS0FBYixFQUFvQnJLLEtBQXBCLEVBQTJCb0ssS0FBS0MsTUFBTXJLLEtBQU4sQ0FBWXdCLFFBQWpCLEVBQTJCOG1CLFNBQTNCLEVBQXNDQyxZQUF0QyxDQUEzQixDQUFYO0FBQ0E7QUFDSiw2QkFBSyxNQUFMO0FBQ0EsNkJBQUssU0FBTDtBQUNJQyx1Q0FBVyx5QkFBYW5lLEtBQWIsRUFBb0JySyxLQUFwQixDQUFYO0FBQ0E7QUFDSjtBQUNJd29CLHVDQUFXbmUsS0FBWDtBQUNBO0FBYlI7O0FBZ0JBLDJCQUFPbWUsUUFBUDtBQUNIOztBQUVELHVCQUFPbmUsS0FBUDtBQUNILGFBNUNNLENBQVA7QUE2Q0gsU0E5Q0Q7O0FBZ0RBLGVBQU9ELEtBQUs1SSxRQUFMLEVBQWUsR0FBZixDQUFQO0FBQ0gsSzs7bUJBRURtbUIsZ0IsNkJBQWlCOVIsSyxFQUFPO0FBQ3BCLFlBQUlBLEtBQUosRUFBVztBQUNQLGdCQUFJOVcsTUFBTUMsT0FBTixDQUFjNlcsS0FBZCxDQUFKLEVBQTBCO0FBQ3RCLHVCQUFPQSxLQUFQO0FBQ0g7QUFDRCxtQkFBTyxDQUFDQSxLQUFELENBQVA7QUFDSDs7QUFFRCxlQUFPLEVBQVA7QUFDSCxLOzttQkFFRDZTLFMsc0JBQVVDLFUsRUFBWUMsUyxFQUFXO0FBQzdCLFlBQU1DLGNBQWNGLFdBQVd0akIsS0FBWCxDQUFpQixHQUFqQixFQUFzQnlqQixLQUF0QixDQUE0QixDQUE1QixFQUErQixDQUFDLENBQWhDLENBQXBCO0FBQ0EsWUFBTUMsYUFBYUgsVUFBVXZqQixLQUFWLENBQWdCLEdBQWhCLEVBQXFCeWpCLEtBQXJCLENBQTJCLENBQTNCLEVBQThCLENBQUMsQ0FBL0IsQ0FBbkI7O0FBRUEsZUFBT0QsWUFBWWxxQixNQUFaLEtBQXVCb3FCLFdBQVdwcUIsTUFBbEMsSUFBNENrcUIsWUFBWUcsS0FBWixDQUFrQixVQUFDQyxHQUFELEVBQU1qZCxLQUFOLEVBQWdCO0FBQ2pGLG1CQUFPaWQsUUFBUUYsV0FBVy9jLEtBQVgsQ0FBZjtBQUNILFNBRmtELENBQW5EO0FBR0gsSzs7bUJBRURrZCxVLHVCQUFXUCxVLEVBQVlDLFMsRUFBVztBQUM5QixZQUFNQyxjQUFjRixXQUFXdGpCLEtBQVgsQ0FBaUIsR0FBakIsQ0FBcEI7QUFDQSxZQUFNMGpCLGFBQWFILFVBQVV2akIsS0FBVixDQUFnQixHQUFoQixDQUFuQjs7QUFFQSxlQUFPd2pCLFlBQVlscUIsTUFBWixHQUFxQm9xQixXQUFXcHFCLE1BQWhDLElBQTBDb3FCLFdBQVdDLEtBQVgsQ0FBaUIsVUFBQ0MsR0FBRCxFQUFNamQsS0FBTixFQUFnQjtBQUM5RSxtQkFBT2lkLFFBQVFKLFlBQVk3YyxLQUFaLENBQWY7QUFDSCxTQUZnRCxDQUFqRDtBQUdILEs7O21CQUVEbWQsVSx1QkFBV2hxQixHLEVBQUtzZ0IsSSxFQUFNMkosVyxFQUFham9CLEMsRUFBRztBQUFBOztBQUNsQyxZQUFJa29CLG9CQUFKOztBQURrQyxxQkFHUCxLQUFLcnBCLEtBSEU7QUFBQSxZQUcxQm1vQixJQUgwQixVQUcxQkEsSUFIMEI7QUFBQSxZQUdwQkMsUUFIb0IsVUFHcEJBLFFBSG9CO0FBQUEsWUFJMUJYLFFBSjBCLEdBSWIsS0FBS3plLEtBSlEsQ0FJMUJ5ZSxRQUowQjs7QUFLbEMsWUFBTXpiLFFBQVF5YixTQUFTemlCLE9BQVQsQ0FBaUI3RixHQUFqQixDQUFkO0FBQ0EsWUFBSXNnQixRQUFRelQsVUFBVSxDQUFDLENBQXZCLEVBQTBCO0FBQ3RCLGdCQUFJbWMsU0FBUyxRQUFiLEVBQXVCO0FBQ25CLG9CQUFJQyxhQUFhLFFBQWpCLEVBQTJCO0FBQ3ZCaUIsa0NBQWM1QixTQUFTaFMsTUFBVCxDQUFnQjtBQUFBLCtCQUFLLENBQUMsT0FBS2lULFNBQUwsQ0FBZSxPQUFLWixHQUFMLENBQVMzb0IsR0FBVCxFQUFjc3BCLEdBQTdCLEVBQWtDLE9BQUtYLEdBQUwsQ0FBU3dCLENBQVQsRUFBWWIsR0FBOUMsQ0FBTjtBQUFBLHFCQUFoQixDQUFkO0FBQ0FZLGdDQUFZdnFCLElBQVosQ0FBaUJLLEdBQWpCO0FBQ0gsaUJBSEQsTUFHTztBQUNIa3FCLGtDQUFjNUIsU0FBU3ZqQixNQUFULENBQWdCL0UsR0FBaEIsQ0FBZDtBQUNIO0FBQ0osYUFQRCxNQU9PO0FBQ0hrcUIsOEJBQWM1QixTQUFTaFMsTUFBVCxDQUFnQixhQUFLO0FBQy9CLDJCQUFPLE9BQUt5VCxVQUFMLENBQWdCLE9BQUtwQixHQUFMLENBQVMzb0IsR0FBVCxFQUFjc3BCLEdBQTlCLEVBQW1DLE9BQUtYLEdBQUwsQ0FBU3dCLENBQVQsRUFBWWIsR0FBL0MsQ0FBUDtBQUNILGlCQUZhLENBQWQ7QUFHQVksNEJBQVl2cUIsSUFBWixDQUFpQkssR0FBakI7QUFDSDtBQUNKLFNBZEQsTUFjTyxJQUFJLENBQUNzZ0IsSUFBRCxJQUFTelQsUUFBUSxDQUFDLENBQXRCLEVBQXlCO0FBQzVCLGdCQUFJbWMsU0FBUyxRQUFiLEVBQXVCO0FBQ25Ca0Isd0NBQ081QixTQUFTcUIsS0FBVCxDQUFlLENBQWYsRUFBa0I5YyxLQUFsQixDQURQLEVBRU95YixTQUFTcUIsS0FBVCxDQUFlOWMsUUFBUSxDQUF2QixDQUZQO0FBSUgsYUFMRCxNQUtPLElBQUlvZCxnQkFBZ0IsVUFBcEIsRUFBZ0M7QUFDbkMsb0JBQUksQ0FBQyxLQUFLeEIsVUFBTCxDQUFnQjFqQixNQUFoQixDQUF1QixLQUFLbUUsUUFBNUIsRUFBc0NraEIsSUFBdEMsQ0FBMkM7QUFBQSwyQkFBUTlZLEtBQUsrRyxRQUFMLENBQWNyVyxFQUFFMlAsTUFBaEIsQ0FBUjtBQUFBLGlCQUEzQyxDQUFMLEVBQWtGO0FBQzlFdVksa0NBQWMsRUFBZDtBQUNIO0FBQ0osYUFKTSxNQUlBO0FBQ0hBLDhCQUFjNUIsU0FBU2hTLE1BQVQsQ0FBZ0IsYUFBSztBQUMvQiwyQkFBTzZULE1BQU1ucUIsR0FBTixJQUFhLENBQUMsT0FBSytwQixVQUFMLENBQWdCLE9BQUtwQixHQUFMLENBQVN3QixDQUFULEVBQVliLEdBQTVCLEVBQWlDLE9BQUtYLEdBQUwsQ0FBUzNvQixHQUFULEVBQWNzcEIsR0FBL0MsQ0FBckI7QUFDSCxpQkFGYSxDQUFkO0FBR0g7QUFDSjs7QUFFRCxZQUFJWSxXQUFKLEVBQWlCO0FBQ2IsZ0JBQUksRUFBRSxjQUFjLEtBQUtycEIsS0FBckIsQ0FBSixFQUFpQztBQUM3QixxQkFBS3NmLFFBQUwsQ0FBYztBQUNWbUksOEJBQVU0QjtBQURBLGlCQUFkO0FBR0g7O0FBRUQsaUJBQUtycEIsS0FBTCxDQUFXK2YsTUFBWCxDQUFrQnNKLFdBQWxCLEVBQStCO0FBQzNCbHFCLHdCQUQyQjtBQUUzQnNnQjtBQUYyQixhQUEvQjtBQUlIO0FBQ0osSzs7bUJBRUQrSixPLG9CQUFRcnFCLEcsRUFBSztBQUNULFlBQU1zcUIsVUFBVSxFQUFoQjtBQUNBLFlBQU1DLFlBQVksRUFBbEI7O0FBRUEsWUFBTWpCLE1BQU0sS0FBS1gsR0FBTCxDQUFTM29CLEdBQVQsRUFBY3NwQixHQUExQjtBQUNBLFlBQU1rQixPQUFPbEIsSUFBSXBqQixLQUFKLENBQVUsR0FBVixDQUFiO0FBQ0EsYUFBSyxJQUFJNUcsSUFBSSxDQUFiLEVBQWdCQSxJQUFJa3JCLEtBQUtockIsTUFBTCxHQUFjLENBQWxDLEVBQXFDRixHQUFyQyxFQUEwQztBQUN0QyxnQkFBTW1yQixhQUFhRCxLQUFLYixLQUFMLENBQVcsQ0FBWCxFQUFjcnFCLElBQUksQ0FBbEIsQ0FBbkI7QUFDQSxnQkFBTW9yQixZQUFZRCxXQUFXdnFCLElBQVgsQ0FBZ0IsR0FBaEIsQ0FBbEI7QUFDQSxnQkFBTThMLFNBQVMsS0FBS2tkLEdBQUwsQ0FBU3dCLFNBQVQsQ0FBZjtBQUNBSixvQkFBUTNxQixJQUFSLENBQWFxTSxPQUFPaE0sR0FBcEI7QUFDQXVxQixzQkFBVTVxQixJQUFWLENBQWVxTSxPQUFPbUgsS0FBdEI7QUFDSDs7QUFFRCxlQUFPO0FBQ0htWCw0QkFERztBQUVIQztBQUZHLFNBQVA7QUFJSCxLOzttQkFFRGxZLFkseUJBQWFyUyxHLEVBQUsycUIsTSxFQUFRQyxRLEVBQVU7QUFDaEMsWUFBTXRCLE1BQU0sS0FBS1gsR0FBTCxDQUFTM29CLEdBQVQsRUFBY3NwQixHQUExQjtBQUNBLFlBQU1uZSxRQUFRbWUsSUFBSXBqQixLQUFKLENBQVUsR0FBVixFQUFlMUcsTUFBZixHQUF3QixDQUF0QztBQUNBLFlBQUksS0FBS3FCLEtBQUwsQ0FBV2dxQixhQUFYLElBQTRCMWYsUUFBUSxDQUF4QyxFQUEyQztBQUN2QztBQUNIOztBQUVELFlBQUkyZix3QkFBSjs7QUFQZ0MsWUFTeEIzWSxVQVR3QixHQVNULEtBQUt0UixLQVRJLENBU3hCc1IsVUFUd0I7QUFBQSxZQVV4QkMsWUFWd0IsR0FVUCxLQUFLdkksS0FWRSxDQVV4QnVJLFlBVndCOztBQVdoQyxZQUFNdkYsUUFBUXVGLGFBQWF2TSxPQUFiLENBQXFCN0YsR0FBckIsQ0FBZDtBQUNBLFlBQUkycUIsVUFBVTlkLFVBQVUsQ0FBQyxDQUF6QixFQUE0QjtBQUN4QixnQkFBSXNGLGVBQWUsUUFBbkIsRUFBNkI7QUFDekIyWSxrQ0FBa0IsQ0FBQzlxQixHQUFELENBQWxCO0FBQ0gsYUFGRCxNQUVPLElBQUltUyxlQUFlLFVBQW5CLEVBQStCO0FBQ2xDMlksa0NBQWtCMVksYUFBYXJOLE1BQWIsQ0FBb0IvRSxHQUFwQixDQUFsQjtBQUNIO0FBQ0osU0FORCxNQU1PLElBQUksQ0FBQzJxQixNQUFELElBQVc5ZCxRQUFRLENBQUMsQ0FBcEIsSUFBeUJzRixlQUFlLFVBQTVDLEVBQXdEO0FBQzNEMlksd0NBQ08xWSxhQUFhdVgsS0FBYixDQUFtQixDQUFuQixFQUFzQjljLEtBQXRCLENBRFAsRUFFT3VGLGFBQWF1WCxLQUFiLENBQW1COWMsUUFBUSxDQUEzQixDQUZQO0FBSUg7O0FBRUQsWUFBSWllLGVBQUosRUFBcUI7QUFDakIsZ0JBQUksRUFBRSxrQkFBa0IsS0FBS2pxQixLQUF6QixDQUFKLEVBQXFDO0FBQ2pDLHFCQUFLc2YsUUFBTCxDQUFjO0FBQ1YvTixrQ0FBYzBZO0FBREosaUJBQWQ7QUFHSDs7QUFFRCxpQkFBS2pxQixLQUFMLENBQVd5UixRQUFYLENBQW9Cd1ksZUFBcEIsRUFBcUNGLFFBQXJDO0FBQ0k1cUIsd0JBREo7QUFFSTJxQiw4QkFGSjtBQUdJeFgsdUJBQU8sS0FBS3dWLEdBQUwsQ0FBUzNvQixHQUFULEVBQWNtVDtBQUh6QixlQUlPLEtBQUtrWCxPQUFMLENBQWFycUIsR0FBYixDQUpQO0FBTUg7QUFDSixLOzttQkFFRHlLLGUsNEJBQWdCekssRyxFQUFLZ0UsSSxFQUFNaEMsQyxFQUFHO0FBQUE7O0FBQzFCLFlBQUksS0FBS25CLEtBQUwsQ0FBVzJJLFNBQWYsRUFBMEI7QUFDdEIsZ0JBQUksRUFBRSxnQkFBZ0IsS0FBSzNJLEtBQXZCLENBQUosRUFBbUM7QUFDL0IscUJBQUtzZixRQUFMLENBQWM7QUFDVnZXLGdDQUFZNUo7QUFERixpQkFBZDtBQUdIOztBQUVELGlCQUFLYSxLQUFMLENBQVdrcUIsV0FBWCxDQUF1Qi9xQixHQUF2QixFQUE0QmdFLElBQTVCLEVBQWtDaEMsQ0FBbEM7QUFDSDs7QUFFRCxZQUFJZ0MsS0FBS25ELEtBQUwsQ0FBVzBGLElBQVgsS0FBb0IsTUFBeEIsRUFBZ0M7QUFDNUIsZ0JBQUl2QyxLQUFLbkQsS0FBTCxDQUFXb0ksVUFBWCxLQUEwQixPQUExQixJQUFxQyxLQUFLWSxLQUFMLENBQVd5ZSxRQUFYLENBQW9COW9CLE1BQTdELEVBQXFFO0FBQ2pFLG9CQUFJLEVBQUUsY0FBYyxLQUFLcUIsS0FBckIsQ0FBSixFQUFpQztBQUM3Qix5QkFBS3NmLFFBQUwsQ0FBYztBQUNWbUksa0NBQVU7QUFEQSxxQkFBZDtBQUdIOztBQUVELHFCQUFLem5CLEtBQUwsQ0FBVytmLE1BQVgsQ0FBa0IsRUFBbEIsRUFBc0I7QUFDbEI1Z0IseUJBQUssS0FBSzZKLEtBQUwsQ0FBV3llLFFBQVgsQ0FBb0IvQixJQUFwQixDQUF5QixVQUFDeUUsT0FBRCxFQUFVQyxPQUFWO0FBQUEsK0JBQXNCLE9BQUt0QyxHQUFMLENBQVNzQyxPQUFULEVBQWtCM0IsR0FBbEIsQ0FBc0JwakIsS0FBdEIsQ0FBNEIsR0FBNUIsRUFBaUMxRyxNQUFqQyxHQUEwQyxPQUFLbXBCLEdBQUwsQ0FBU3FDLE9BQVQsRUFBa0IxQixHQUFsQixDQUFzQnBqQixLQUF0QixDQUE0QixHQUE1QixFQUFpQzFHLE1BQWpHO0FBQUEscUJBQXpCLEVBQWtJLENBQWxJLENBRGE7QUFFbEI4Z0IsMEJBQU07QUFGWSxpQkFBdEI7QUFJSDs7QUFFRCxpQkFBS3pmLEtBQUwsQ0FBV3FxQixXQUFYLENBQXVCbHJCLEdBQXZCLEVBQTRCZ0UsSUFBNUIsRUFBa0NoQyxDQUFsQztBQUNIO0FBQ0osSzs7bUJBRURtcEIsYywyQkFBZUMsTSxFQUFRM0IsUyxFQUFXO0FBQUEsNkJBQ0gsS0FBS1AsR0FBTCxDQUFTTyxTQUFULENBREc7QUFBQSxZQUN0QmxqQixJQURzQixrQkFDdEJBLElBRHNCO0FBQUEsWUFDaEJrRCxRQURnQixrQkFDaEJBLFFBRGdCOzs7QUFHOUIsZUFBTyxLQUFLOGYsU0FBTCxDQUFlNkIsTUFBZixFQUF1QjNCLFNBQXZCLE1BQ0ZsakIsU0FBUyxNQUFULElBQW1CLENBQUNrRCxRQUFwQixJQUFnQ2xELFNBQVMsU0FEdkMsQ0FBUDtBQUVILEs7O21CQUVEOGtCLGUsNEJBQWdCL0IsRyxFQUFLaFUsSSxFQUFNO0FBQUE7O0FBQ3ZCLFlBQU1nVyxLQUFLNWxCLE9BQU9DLElBQVAsQ0FBWSxLQUFLdWpCLEdBQWpCLEVBQXNCNVMsTUFBdEIsQ0FBNkI7QUFBQSxtQkFBSyxPQUFLNlUsY0FBTCxDQUFvQjdCLEdBQXBCLEVBQXlCaUMsQ0FBekIsQ0FBTDtBQUFBLFNBQTdCLENBQVg7QUFDQSxZQUFJRCxHQUFHOXJCLE1BQUgsR0FBWSxDQUFoQixFQUFtQjtBQUNmLGdCQUFNcU4sUUFBUXllLEdBQUd6bEIsT0FBSCxDQUFXeWpCLEdBQVgsQ0FBZDtBQUNBLGdCQUFJa0Msb0JBQUo7QUFDQSxnQkFBSWxXLElBQUosRUFBVTtBQUNOa1csOEJBQWMzZSxVQUFVLENBQVYsR0FBY3llLEdBQUc5ckIsTUFBSCxHQUFZLENBQTFCLEdBQThCcU4sUUFBUSxDQUFwRDtBQUNILGFBRkQsTUFFTztBQUNIMmUsOEJBQWMzZSxVQUFVeWUsR0FBRzlyQixNQUFILEdBQVksQ0FBdEIsR0FBMEIsQ0FBMUIsR0FBOEJxTixRQUFRLENBQXBEO0FBQ0g7O0FBRUQsbUJBQU8sS0FBS3FjLEdBQUwsQ0FBU29DLEdBQUdFLFdBQUgsQ0FBVCxFQUEwQnhyQixHQUFqQztBQUNIOztBQUVELGVBQU8sSUFBUDtBQUNILEs7O21CQUVEcW9CLDBCLHVDQUEyQnFDLFMsRUFBVztBQUFBOztBQUNsQyxZQUFNcEIsTUFBTTVqQixPQUFPQyxJQUFQLENBQVksS0FBS3VqQixHQUFqQixFQUFzQnVDLElBQXRCLENBQTJCO0FBQUEsbUJBQUssT0FBS04sY0FBTCxDQUF1QlQsU0FBdkIsU0FBc0NhLENBQXRDLENBQUw7QUFBQSxTQUEzQixDQUFaO0FBQ0EsZUFBT2pDLE1BQU0sS0FBS0osR0FBTCxDQUFTSSxHQUFULEVBQWN0cEIsR0FBcEIsR0FBMEIsSUFBakM7QUFDSCxLOzttQkFFRDByQixZLHlCQUFhcEMsRyxFQUFLO0FBQ2QsZUFBTyxLQUFLSixHQUFMLENBQVNJLElBQUlLLEtBQUosQ0FBVSxDQUFWLEVBQWFMLElBQUk5cEIsTUFBSixHQUFhLENBQTFCLENBQVQsRUFBdUNRLEdBQTlDO0FBQ0gsSzs7bUJBRUQ2SyxpQiw4QkFBa0I3SyxHLEVBQUt1RyxJLEVBQU12QyxJLEVBQU1oQyxDLEVBQUc7QUFDbEMsWUFBSSxDQUNBaEQsY0FBUTJkLEVBRFIsRUFDWTNkLGNBQVE2ZCxJQURwQixFQUMwQjdkLGNBQVE0ZCxLQURsQyxFQUN5QzVkLGNBQVEwZCxJQURqRCxFQUVBMWQsY0FBUW1kLEtBRlIsRUFFZW5kLGNBQVF1ZCxHQUZ2QixFQUU0QnZkLGNBQVF3VCxLQUZwQyxFQUdGM00sT0FIRSxDQUdNN0QsRUFBRXVRLE9BSFIsSUFHbUIsQ0FBQyxDQUh4QixFQUcyQjtBQUN2QnZRLGNBQUUySSxjQUFGO0FBQ0EzSSxjQUFFd0ksZUFBRjtBQUNIOztBQUVELFlBQUlaLGFBQWEsS0FBS0MsS0FBTCxDQUFXRCxVQUE1Qjs7QUFUa0MsWUFXMUJyQixTQVgwQixHQVdaLEtBQUsxSCxLQVhPLENBVzFCMEgsU0FYMEI7O0FBWWxDLFlBQU0rZ0IsTUFBTSxLQUFLWCxHQUFMLENBQVMzb0IsR0FBVCxFQUFjc3BCLEdBQTFCO0FBQ0EsWUFBTW5lLFFBQVFtZSxJQUFJcGpCLEtBQUosQ0FBVSxHQUFWLEVBQWUxRyxNQUFmLEdBQXdCLENBQXRDO0FBQ0EsZ0JBQVF3QyxFQUFFdVEsT0FBVjtBQUNJLGlCQUFLdlQsY0FBUTJkLEVBQWI7QUFBaUI7QUFDYix3QkFBTWdQLGVBQWUsS0FBS04sZUFBTCxDQUFxQi9CLEdBQXJCLEVBQTBCLElBQTFCLENBQXJCO0FBQ0Esd0JBQUlxQyxZQUFKLEVBQWtCO0FBQ2QvaEIscUNBQWEraEIsWUFBYjtBQUNIO0FBQ0Q7QUFDSDtBQUNELGlCQUFLM3NCLGNBQVE2ZCxJQUFiO0FBQW1CO0FBQ2Ysd0JBQUk4TyxzQkFBSjtBQUNBLHdCQUFJcGpCLGNBQWMsS0FBZCxJQUF1QjRDLFVBQVUsQ0FBakMsSUFBc0M1RSxTQUFTLFNBQW5ELEVBQThEO0FBQzFELDZCQUFLeWpCLFVBQUwsQ0FBZ0JocUIsR0FBaEIsRUFBcUIsSUFBckI7QUFDQTJyQix3Q0FBZSxLQUFLdEQsMEJBQUwsQ0FBZ0NpQixHQUFoQyxDQUFmO0FBQ0gscUJBSEQsTUFHTztBQUNIcUMsd0NBQWUsS0FBS04sZUFBTCxDQUFxQi9CLEdBQXJCLEVBQTBCLEtBQTFCLENBQWY7QUFDSDtBQUNELHdCQUFJcUMsYUFBSixFQUFrQjtBQUNkL2hCLHFDQUFhK2hCLGFBQWI7QUFDSDtBQUNEO0FBQ0g7QUFDRCxpQkFBSzNzQixjQUFRNGQsS0FBYjtBQUFvQjtBQUNoQix3QkFBSStPLHVCQUFKO0FBQ0Esd0JBQUlwakIsY0FBYyxLQUFkLElBQXVCNEMsVUFBVSxDQUFyQyxFQUF3QztBQUNwQ3dnQix5Q0FBZSxLQUFLTixlQUFMLENBQXFCL0IsR0FBckIsRUFBMEIsS0FBMUIsQ0FBZjtBQUNILHFCQUZELE1BRU8sSUFBSS9pQixTQUFTLFNBQWIsRUFBd0I7QUFDM0IsNkJBQUt5akIsVUFBTCxDQUFnQmhxQixHQUFoQixFQUFxQixJQUFyQjtBQUNBMnJCLHlDQUFlLEtBQUt0RCwwQkFBTCxDQUFnQ2lCLEdBQWhDLENBQWY7QUFDSDtBQUNELHdCQUFJcUMsY0FBSixFQUFrQjtBQUNkL2hCLHFDQUFhK2hCLGNBQWI7QUFDSDtBQUNEO0FBQ0g7QUFDRCxpQkFBSzNzQixjQUFRbWQsS0FBYjtBQUFvQjtBQUNoQix3QkFBSTVWLFNBQVMsU0FBYixFQUF3QjtBQUNwQiw2QkFBS3lqQixVQUFMLENBQWdCaHFCLEdBQWhCLEVBQXFCLElBQXJCO0FBQ0EsNEJBQU0yckIsaUJBQWUsS0FBS3RELDBCQUFMLENBQWdDaUIsR0FBaEMsQ0FBckI7QUFDQSw0QkFBSXFDLGNBQUosRUFBa0I7QUFDZC9oQix5Q0FBYStoQixjQUFiO0FBQ0g7QUFDSjtBQUNEO0FBQ0g7QUFDRCxpQkFBSzNzQixjQUFRMGQsSUFBYjtBQUFtQjtBQUNmLHdCQUFJblUsY0FBYyxLQUFkLElBQXVCNEMsVUFBVSxDQUFyQyxFQUF3QztBQUNwQyw0QkFBTXdnQixpQkFBZSxLQUFLTixlQUFMLENBQXFCL0IsR0FBckIsRUFBMEIsSUFBMUIsQ0FBckI7QUFDQSw0QkFBSXFDLGNBQUosRUFBa0I7QUFDZC9oQix5Q0FBYStoQixjQUFiO0FBQ0g7QUFDSixxQkFMRCxNQUtPLElBQUl4Z0IsUUFBUSxDQUFaLEVBQWU7QUFDbEIsNEJBQU15Z0IsWUFBWSxLQUFLRixZQUFMLENBQWtCcEMsR0FBbEIsQ0FBbEI7QUFDQSw2QkFBS1UsVUFBTCxDQUFnQjRCLFNBQWhCLEVBQTJCLEtBQTNCO0FBQ0FoaUIscUNBQWFnaUIsU0FBYjtBQUNIO0FBQ0Q7QUFDSDtBQUNELGlCQUFLNXNCLGNBQVF1ZCxHQUFiO0FBQ0ksb0JBQUlwUixRQUFRLENBQVosRUFBZTtBQUNYLHdCQUFNeWdCLGFBQVksS0FBS0YsWUFBTCxDQUFrQnBDLEdBQWxCLENBQWxCO0FBQ0EseUJBQUtVLFVBQUwsQ0FBZ0I0QixVQUFoQixFQUEyQixLQUEzQjtBQUNBaGlCLGlDQUFhZ2lCLFVBQWI7QUFDSDtBQUNEOztBQUVKLGlCQUFLNXNCLGNBQVFrZCxHQUFiO0FBQ0l0Uyw2QkFBYSxJQUFiO0FBQ0E7QUFDSjtBQUNJO0FBckVSOztBQXdFQSxZQUFJQSxlQUFlLEtBQUtDLEtBQUwsQ0FBV0QsVUFBOUIsRUFBMEM7QUFDdEMsZ0JBQUksRUFBRSxnQkFBZ0IsS0FBSy9JLEtBQXZCLENBQUosRUFBbUM7QUFDL0IscUJBQUtzZixRQUFMLENBQWM7QUFDVnZXO0FBRFUsaUJBQWQ7QUFHSDs7QUFFRCxpQkFBSy9JLEtBQUwsQ0FBV2dyQixhQUFYLENBQXlCamlCLFVBQXpCLEVBQXFDNUYsSUFBckMsRUFBMkNoQyxDQUEzQztBQUNBLGlCQUFLbkIsS0FBTCxDQUFXa3FCLFdBQVgsQ0FBdUJuaEIsVUFBdkIsRUFBbUM1SCxDQUFuQztBQUNIO0FBQ0osSzs7bUJBRURFLE0scUJBQVM7QUFBQTs7QUFBQSxzQkFDK0UsS0FBS3JCLEtBRHBGO0FBQUEsWUFDR0MsTUFESCxXQUNHQSxNQURIO0FBQUEsWUFDVzJGLFNBRFgsV0FDV0EsU0FEWDtBQUFBLFlBQ3NCOEIsU0FEdEIsV0FDc0JBLFNBRHRCO0FBQUEsWUFDaUN1akIsUUFEakMsV0FDaUNBLFFBRGpDO0FBQUEsWUFDMkMxaUIsTUFEM0MsV0FDMkNBLE1BRDNDO0FBQUEsWUFDbURDLE1BRG5ELFdBQ21EQSxNQURuRDtBQUFBLFlBQzJEOEksVUFEM0QsV0FDMkRBLFVBRDNEO0FBQUEsWUFDdUVqUixHQUR2RSxXQUN1RUEsR0FEdkU7O0FBRUwsWUFBTTBILFNBQVN4QixXQUFXMUIsT0FBT0MsSUFBUCxDQUFZc2lCLEtBQUsxbEIsU0FBakIsQ0FBWCxFQUF3QyxLQUFLMUIsS0FBN0MsQ0FBZjs7QUFFQSxZQUFNNkssZUFBZSx5Q0FDYjVLLE1BRGEsYUFDRSxJQURGLE1BRWJBLE1BRmEsWUFFQ3lILGNBQWMsS0FGZixNQUdiekgsTUFIYSxZQUdDeUgsY0FBYyxLQUhmLE1BSWhCOUIsU0FKZ0IsSUFJSixDQUFDLENBQUNBLFNBSkUsT0FBckI7O0FBT0EsWUFBTXNsQixPQUFPeGpCLGNBQWMsS0FBZCxHQUFzQixTQUF0QixHQUFrQyxNQUEvQztBQUNBLFlBQU15akIsZ0JBQWdCNWlCLFNBQVM7QUFBQTtBQUFBLGNBQUksV0FBY3RJLE1BQWQsZ0JBQUo7QUFBd0NzSTtBQUF4QyxTQUFULEdBQWdFLElBQXRGO0FBQ0EsWUFBTTZpQixlQUFlN2lCLFVBQVVDLE1BQVYsR0FBb0I7QUFBQTtBQUFBLGNBQUksV0FBY3ZJLE1BQWQsaUJBQUo7QUFBeUMsaUJBQUtxbkI7QUFBOUMsU0FBcEIsR0FBc0YsS0FBS0EsV0FBaEg7QUFDQSxZQUFNK0QsZ0JBQWdCN2lCLFNBQVM7QUFBQTtBQUFBLGNBQUksV0FBY3ZJLE1BQWQsZ0JBQUo7QUFBd0N1STtBQUF4QyxTQUFULEdBQWdFLElBQXRGO0FBQ0EsWUFBTThpQiwyQkFBMkJMLGFBQWEsT0FBYixJQUF3QixDQUFDLENBQUMxaUIsTUFBM0Q7O0FBRUEsWUFBSWxJLEdBQUosRUFBUztBQUNMMEgsbUJBQU9qQyxHQUFQLEdBQWEsS0FBYjtBQUNIOztBQUVELGVBQ0k7QUFBQTtBQUFBLHVCQUFJLE1BQU1vbEIsSUFBVixFQUFnQixRQUFRLEtBQUtuRCxNQUE3QixFQUFxQyxXQUFXbGQsWUFBaEQsRUFBOEQsV0FBVyxLQUFLMGdCLFdBQTlFLEVBQTJGLHdCQUFzQmphLGVBQWUsVUFBaEksSUFBZ0p2SixNQUFoSjtBQUNLb2pCLHlCQURMO0FBRUtHLHVDQUNHO0FBQUE7QUFBQSxrQkFBSyxXQUFjcnJCLE1BQWQsbUJBQUw7QUFDS21yQiw0QkFETDtBQUVLQztBQUZMLGFBREgsR0FJWSxJQU5qQjtBQVFLLGFBQUNDLHdCQUFELEdBQTRCRixZQUE1QixHQUEyQyxJQVJoRDtBQVNLLGFBQUNFLHdCQUFELEdBQTRCRCxhQUE1QixHQUE0QztBQVRqRCxTQURKO0FBYUgsSzs7O0VBL25CNkI1cEIsZ0IsVUFDdkIrcEIsVSxHQUFhLEksU0FFYjlwQixTLEdBQVk7QUFDZnpCLFlBQVEwQixvQkFBVUMsTUFESDtBQUVmekIsVUFBTXdCLG9CQUFVRSxJQUZEO0FBR2Z4QixTQUFLc0Isb0JBQVVFLElBSEE7QUFJZitELGVBQVdqRSxvQkFBVUMsTUFKTjtBQUtmOzs7QUFHQUosY0FBVUcsb0JBQVU4TyxJQVJMO0FBU2Y7Ozs7OztBQU1BNFosaUJBQWExb0Isb0JBQVVoRSxJQWZSO0FBZ0JmOzs7QUFHQThwQixjQUFVOWxCLG9CQUFVNk8sU0FBVixDQUFvQixDQUFDN08sb0JBQVVDLE1BQVgsRUFBbUJELG9CQUFVa00sS0FBN0IsQ0FBcEIsQ0FuQks7QUFvQmY7OztBQUdBb2EscUJBQWlCdG1CLG9CQUFVNk8sU0FBVixDQUFvQixDQUFDN08sb0JBQVVDLE1BQVgsRUFBbUJELG9CQUFVa00sS0FBN0IsQ0FBcEIsQ0F2QkY7QUF3QmY7OztBQUdBcWEsb0JBQWdCdm1CLG9CQUFVRSxJQTNCWDtBQTRCZjs7Ozs7OztBQU9Ba2UsWUFBUXBlLG9CQUFVaEUsSUFuQ0g7QUFvQ2Y7OztBQUdBd3FCLFVBQU14bUIsb0JBQVVvRSxLQUFWLENBQWdCLENBQUMsUUFBRCxFQUFXLE9BQVgsQ0FBaEIsQ0F2Q1M7QUF3Q2Y7OztBQUdBcWpCLGlCQUFhem5CLG9CQUFVb0UsS0FBVixDQUFnQixDQUFDLE9BQUQsRUFBVSxPQUFWLENBQWhCLENBM0NFO0FBNENmOzs7QUFHQXFpQixjQUFVem1CLG9CQUFVb0UsS0FBVixDQUFnQixDQUFDLFFBQUQsRUFBVyxVQUFYLENBQWhCLENBL0NLO0FBZ0RmOzs7QUFHQTRFLGtCQUFjaEosb0JBQVV1SixNQW5EVDtBQW9EZnVnQiwwQkFBc0I5cEIsb0JBQVVvRSxLQUFWLENBQWdCLENBQUMsTUFBRCxFQUFTLE9BQVQsQ0FBaEIsQ0FwRFA7QUFxRGY7OztBQUdBMmxCLG9CQUFnQi9wQixvQkFBVUUsSUF4RFg7QUF5RGY7OztBQUdBOHBCLGdCQUFZaHFCLG9CQUFVb0UsS0FBVixDQUFnQixDQUFDLFFBQUQsRUFBVyxTQUFYLENBQWhCLENBNURHO0FBNkRmOzs7QUFHQTZsQixnQkFBWWpxQixvQkFBVTZPLFNBQVYsQ0FBb0IsQ0FBQzdPLG9CQUFVakYsTUFBWCxFQUFtQmlGLG9CQUFVaEUsSUFBN0IsQ0FBcEIsQ0FoRUc7QUFpRWY7OztBQUdBa3VCLG9CQUFnQmxxQixvQkFBVUMsTUFwRVg7QUFxRWY7OztBQUdBa3FCLGdCQUFZbnFCLG9CQUFVakYsTUF4RVA7QUF5RWY7OztBQUdBNlUsa0JBQWM1UCxvQkFBVTZPLFNBQVYsQ0FBb0IsQ0FBQzdPLG9CQUFVQyxNQUFYLEVBQW1CRCxvQkFBVWtNLEtBQTdCLENBQXBCLENBNUVDO0FBNkVmOzs7QUFHQXdaLHlCQUFxQjFsQixvQkFBVTZPLFNBQVYsQ0FBb0IsQ0FBQzdPLG9CQUFVQyxNQUFYLEVBQW1CRCxvQkFBVWtNLEtBQTdCLENBQXBCLENBaEZOO0FBaUZmOzs7Ozs7Ozs7O0FBVUE0RCxjQUFVOVAsb0JBQVVoRSxJQTNGTDtBQTRGZjs7O0FBR0EyVCxnQkFBWTNQLG9CQUFVb0UsS0FBVixDQUFnQixDQUFDLFFBQUQsRUFBVyxVQUFYLENBQWhCLENBL0ZHO0FBZ0dmOzs7QUFHQWlrQixtQkFBZXJvQixvQkFBVUUsSUFuR1Y7QUFvR2Y7OztBQUdBZ1EscUJBQWlCbFEsb0JBQVVFLElBdkdaO0FBd0dma3FCLHdCQUFvQnBxQixvQkFBVUUsSUF4R2Y7QUF5R2Y7OztBQUdBNkYsZUFBVy9GLG9CQUFVb0UsS0FBVixDQUFnQixDQUFDLEtBQUQsRUFBUSxLQUFSLENBQWhCLENBNUdJO0FBNkdmOzs7QUFHQWtsQixjQUFVdHBCLG9CQUFVb0UsS0FBVixDQUFnQixDQUFDLE1BQUQsRUFBUyxPQUFULENBQWhCLENBaEhLO0FBaUhmOzs7QUFHQXdDLFlBQVE1RyxvQkFBVThPLElBcEhIO0FBcUhmOzs7QUFHQWpJLFlBQVE3RyxvQkFBVThPLElBeEhIO0FBeUhmOzs7QUFHQXFSLGVBQVduZ0Isb0JBQVVFLElBNUhOO0FBNkhmOzs7QUFHQWtILGdCQUFZcEgsb0JBQVVDLE1BaElQO0FBaUlmK0csZUFBV2hILG9CQUFVRSxJQWpJTjtBQWtJZnFvQixpQkFBYXZvQixvQkFBVWhFLElBbElSO0FBbUlmb3FCLFlBQVFwbUIsb0JBQVVoRSxJQW5JSDtBQW9JZnF0QixtQkFBZXJwQixvQkFBVWhFLElBcElWO0FBcUlmcXVCLHFCQUFpQnJxQixvQkFBVUUsSUFySVo7QUFzSWYrSSxtQkFBZWpKLG9CQUFVQztBQXRJVixDLFNBeUlaRyxZLEdBQWU7QUFDbEI5QixZQUFRLE9BRFU7QUFFbEJFLFVBQU0sS0FGWTtBQUdsQjhuQixxQkFBaUIsRUFIQztBQUlsQkMsb0JBQWdCLEtBSkU7QUFLbEJuSSxZQUFRdFUsSUFMVTtBQU1sQjBjLFVBQU0sUUFOWTtBQU9sQmlCLGlCQUFhLE9BUEs7QUFRbEJoQixjQUFVLFVBUlE7QUFTbEJ6ZCxrQkFBYyxFQVRJO0FBVWxCOGdCLDBCQUFzQixNQVZKO0FBV2xCQyxvQkFBZ0IsS0FYRTtBQVlsQkMsZ0JBQVksUUFaTTtBQWFsQkMsZ0JBQVksRUFiTTtBQWNsQnZFLHlCQUFxQixFQWRIO0FBZWxCNVYsY0FBVWhHLElBZlE7QUFnQmxCdWUsbUJBQWUsS0FoQkc7QUFpQmxCblkscUJBQWlCLElBakJDO0FBa0JsQmthLHdCQUFvQixJQWxCRjtBQW1CbEJya0IsZUFBVyxLQW5CTztBQW9CbEJ1akIsY0FBVSxNQXBCUTtBQXFCbEJuSixlQUFXLEtBckJPO0FBc0JsQm5aLGVBQVcsSUF0Qk87QUF1QmxCdWhCLGlCQUFhemUsSUF2Qks7QUF3QmxCdWYsbUJBQWV2ZixJQXhCRztBQXlCbEI0ZSxpQkFBYTVlLElBekJLO0FBMEJsQnVnQixxQkFBaUI7QUExQkMsQztBQTVJTDVFLEk7a0JBQUFBLEk7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2JyQjs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNM2IsT0FBTyxTQUFQQSxJQUFPLEdBQU0sQ0FBRSxDQUFyQjtBQUNBLElBQU13Z0IsYUFBYSxTQUFiQSxVQUFhLFFBQVM7QUFDeEIsUUFBTUMsZ0JBQWdCdmUsZ0JBQU1yTSxRQUFOLENBQWU2cUIsT0FBZixDQUF1Qm5zQixNQUFNd0IsUUFBN0IsQ0FBdEI7QUFDQSxXQUFPMHFCLGNBQWMsQ0FBZCxLQUFvQixJQUEzQjtBQUNILENBSEQ7O0FBS0E7OztJQUdNRSxPOzs7Ozs7Ozs7c0JBbUZGQyxjLDJCQUFlQyxLLEVBQU87QUFDbEIsWUFBSSxPQUFPQSxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzNCLG1CQUFPO0FBQ0hDLHdCQUFXRCxLQUFYLFlBREc7QUFFSEUsOEJBQWlCRixLQUFqQixtQkFGRztBQUdIeE4sdUJBQVV3TixLQUFWLFdBSEc7QUFJSEcsNkJBQWdCSCxLQUFoQixrQkFKRztBQUtIL00sdUJBQVUrTSxLQUFWLFdBTEc7QUFNSEksNkJBQWdCSixLQUFoQjtBQU5HLGFBQVA7QUFRSDtBQUNELFlBQUksUUFBT0EsS0FBUCx5Q0FBT0EsS0FBUCxPQUFpQixRQUFyQixFQUErQjtBQUMzQixtQkFBTztBQUNIQyx3QkFBUUQsTUFBTUMsTUFEWDtBQUVIQyw4QkFBaUJGLE1BQU1DLE1BQXZCLFlBRkc7QUFHSHpOLDRCQUFVd04sTUFBTXhOLEtBSGI7QUFJSDJOLDZCQUFnQkgsTUFBTXhOLEtBQXRCLFlBSkc7QUFLSFMsNEJBQVUrTSxNQUFNL00sS0FMYjtBQU1IbU4sNkJBQWdCSixNQUFNL00sS0FBdEI7QUFORyxhQUFQO0FBUUg7QUFDSixLOztzQkFHRGxlLE0scUJBQVM7QUFBQTs7QUFDTDtBQURLLHFCQU9ELEtBQUtyQixLQVBKO0FBQUEsWUFFR3llLFNBRkgsVUFFR0EsU0FGSDtBQUFBLFlBRWNqZCxRQUZkLFVBRWNBLFFBRmQ7QUFBQSxZQUV3Qm1yQixlQUZ4QixVQUV3QkEsZUFGeEI7QUFBQSxZQUV5Q0MsVUFGekMsVUFFeUNBLFVBRnpDO0FBQUEsWUFFcURuaUIsU0FGckQsVUFFcURBLFNBRnJEO0FBQUEsWUFHRG9pQixZQUhDLFVBR0RBLFlBSEM7QUFBQSxZQUdhQyxRQUhiLFVBR2FBLFFBSGI7QUFBQSxZQUd1QkMsV0FIdkIsVUFHdUJBLFdBSHZCO0FBQUEsWUFJREMsV0FKQyxVQUlEQSxXQUpDO0FBQUEsWUFJWUMsT0FKWixVQUlZQSxPQUpaO0FBQUEsWUFJcUJDLFVBSnJCLFVBSXFCQSxVQUpyQjtBQUFBLFlBS0RDLFdBTEMsVUFLREEsV0FMQztBQUFBLFlBS1lDLE9BTFosVUFLWUEsT0FMWjtBQUFBLFlBS3FCQyxVQUxyQixVQUtxQkEsVUFMckI7QUFBQSxZQU1FdGxCLE1BTkY7QUFRTDs7QUFFQSxZQUFNdWxCLGtCQUFrQmhzQixnQkFBUzRCLEdBQVQsQ0FBYTFCLFFBQWIsRUFBdUIsaUJBQVM7QUFDcEQsbUJBQ0k7QUFBQywrQkFBRDtBQUFBLGtCQUFjLEtBQUs2SSxNQUFNbEwsR0FBekI7QUFDSSwyQkFBTyxPQUFLa3RCLGNBQUwsQ0FBb0I1TixTQUFwQixDQURYO0FBRUksOEJBQVVvTyxZQUZkO0FBR0ksaUNBQWFDLFFBSGpCO0FBSUksZ0NBQVlDLFdBSmhCO0FBS0ksNkJBQVNDLFdBTGI7QUFNSSxnQ0FBWUMsT0FOaEI7QUFPSSwrQkFBV0MsVUFQZjtBQVFJLDRCQUFRQyxXQVJaO0FBU0ksK0JBQVdDLE9BVGY7QUFVSSw4QkFBVUMsVUFWZDtBQVdLaGpCO0FBWEwsYUFESjtBQWVILFNBaEJ1QixDQUF4Qjs7QUFrQkEsZUFDSTtBQUFDLGlEQUFEO0FBQUEsdUJBQWlCLFFBQVFzaUIsZUFBekIsRUFBMEMsV0FBV0MsYUFBYVgsVUFBYixHQUEwQnhoQixTQUEvRSxJQUE4RjFDLE1BQTlGO0FBQ0t1bEI7QUFETCxTQURKO0FBS0gsSzs7O0VBNUlpQjdyQixnQixVQUNYQyxTLEdBQVk7QUFDZjs7O0FBR0ErYyxlQUFXOWMsb0JBQVU2TyxTQUFWLENBQW9CLENBQUM3TyxvQkFBVUMsTUFBWCxFQUFtQkQsb0JBQVVqRixNQUE3QixDQUFwQixDQUpJO0FBS2Y7OztBQUdBaXdCLHFCQUFpQmhyQixvQkFBVUUsSUFSWjtBQVNmOzs7QUFHQTRJLGVBQVc5SSxvQkFBVWlNLEdBWk47QUFhZjs7O0FBR0FnZixnQkFBWWpyQixvQkFBVUUsSUFoQlA7QUFpQmY7OztBQUdBTCxjQUFVRyxvQkFBVTZPLFNBQVYsQ0FBb0IsQ0FBQzdPLG9CQUFVRyxPQUFYLEVBQW9CSCxvQkFBVXlRLE9BQVYsQ0FBa0J6USxvQkFBVUcsT0FBNUIsQ0FBcEIsQ0FBcEIsQ0FwQks7QUFxQmY7OztBQUdBK3FCLGtCQUFjbHJCLG9CQUFVaEUsSUF4QlQ7QUF5QmY7Ozs7QUFJQW12QixjQUFVbnJCLG9CQUFVaEUsSUE3Qkw7QUE4QmY7Ozs7QUFJQW92QixpQkFBYXByQixvQkFBVWhFLElBbENSO0FBbUNmOzs7O0FBSUFxdkIsaUJBQWFyckIsb0JBQVVoRSxJQXZDUjtBQXdDZjs7OztBQUlBc3ZCLGFBQVN0ckIsb0JBQVVoRSxJQTVDSjtBQTZDZjs7OztBQUlBdXZCLGdCQUFZdnJCLG9CQUFVaEUsSUFqRFA7QUFrRGY7Ozs7QUFJQXd2QixpQkFBYXhyQixvQkFBVWhFLElBdERSO0FBdURmOzs7O0FBSUF5dkIsYUFBU3pyQixvQkFBVWhFLElBM0RKO0FBNERmOzs7O0FBSUEwdkIsZ0JBQVkxckIsb0JBQVVoRTtBQWhFUCxDLFNBbUVab0UsWSxHQUFlO0FBQ2xCNHFCLHFCQUFpQixJQURDO0FBRWxCbGlCLGVBQVcsS0FGTztBQUdsQm1pQixnQkFBWSxJQUhNO0FBSWxCQyxrQkFBY3BoQixJQUpJO0FBS2xCcWhCLGNBQVVyaEIsSUFMUTtBQU1sQnNoQixpQkFBYXRoQixJQU5LO0FBT2xCdWhCLGlCQUFhdmhCLElBUEs7QUFRbEJ3aEIsYUFBU3hoQixJQVJTO0FBU2xCeWhCLGdCQUFZemhCLElBVE07QUFVbEIwaEIsaUJBQWExaEIsSUFWSztBQVdsQjJoQixhQUFTM2hCLElBWFM7QUFZbEI0aEIsZ0JBQVk1aEI7QUFaTSxDO0FBcEVwQjJnQixPO2tCQStJU0EsTzs7Ozs7Ozs7QUM3SkY7O0FBRWIsSUFBSW1CLGlCQUFpQkMsdUJBQXVCendCLG1CQUFPQSxDQUFDLEdBQVIsQ0FBdkIsQ0FBckI7O0FBRUEsSUFBSTB3QixxQkFBcUJELHVCQUF1Qnp3QixtQkFBT0EsQ0FBQyxHQUFSLENBQXZCLENBQXpCOztBQUVBLElBQUkyd0IsbUJBQW1CRix1QkFBdUJ6d0IsbUJBQU9BLENBQUMsRUFBUixDQUF2QixDQUF2Qjs7QUFFQSxJQUFJNHdCLGNBQWNILHVCQUF1Qnp3QixtQkFBT0EsQ0FBQyxFQUFSLENBQXZCLENBQWxCOztBQUVBLFNBQVN5d0Isc0JBQVQsQ0FBZ0MzdkIsR0FBaEMsRUFBcUM7QUFBRSxTQUFPQSxPQUFPQSxJQUFJK3ZCLFVBQVgsR0FBd0IvdkIsR0FBeEIsR0FBOEIsRUFBRXlCLFNBQVN6QixHQUFYLEVBQXJDO0FBQXdEOztBQUUvRmhCLE9BQU9DLE9BQVAsR0FBaUI7QUFDZit3QixjQUFZRixZQUFZcnVCLE9BRFQ7QUFFZnd1QixtQkFBaUJKLGlCQUFpQnB1QixPQUZuQjtBQUdmeXVCLHFCQUFtQk4sbUJBQW1CbnVCLE9BSHZCO0FBSWYwdUIsaUJBQWVULGVBQWVqdUI7QUFKZixDQUFqQixDOzs7Ozs7O0FDWkEsK0NBQWE7Ozs7QUFFYnhDLFFBQVE4d0IsVUFBUixHQUFxQixJQUFyQjtBQUNBOXdCLFFBQVF3QyxPQUFSLEdBQWtCeEMsUUFBUW14QixPQUFSLEdBQWtCbnhCLFFBQVFveEIsT0FBUixHQUFrQnB4QixRQUFRcXhCLFFBQVIsR0FBbUJyeEIsUUFBUXN4QixNQUFSLEdBQWlCdHhCLFFBQVF1eEIsU0FBUixHQUFvQixLQUFLLENBQW5IOztBQUVBLElBQUkxc0IsWUFBWTJzQix3QkFBd0J2eEIsbUJBQU9BLENBQUMsQ0FBUixDQUF4QixDQUFoQjs7QUFFQSxJQUFJd3hCLFNBQVNmLHVCQUF1Qnp3QixtQkFBT0EsQ0FBQyxDQUFSLENBQXZCLENBQWI7O0FBRUEsSUFBSXl4QixZQUFZaEIsdUJBQXVCendCLG1CQUFPQSxDQUFDLENBQVIsQ0FBdkIsQ0FBaEI7O0FBRUEsSUFBSTB4Qix5QkFBeUIxeEIsbUJBQU9BLENBQUMsRUFBUixDQUE3Qjs7QUFFQSxJQUFJMnhCLGFBQWEzeEIsbUJBQU9BLENBQUMsRUFBUixDQUFqQjs7QUFFQSxTQUFTeXdCLHNCQUFULENBQWdDM3ZCLEdBQWhDLEVBQXFDO0FBQUUsU0FBT0EsT0FBT0EsSUFBSSt2QixVQUFYLEdBQXdCL3ZCLEdBQXhCLEdBQThCLEVBQUV5QixTQUFTekIsR0FBWCxFQUFyQztBQUF3RDs7QUFFL0YsU0FBU3l3Qix1QkFBVCxDQUFpQ3p3QixHQUFqQyxFQUFzQztBQUFFLE1BQUlBLE9BQU9BLElBQUkrdkIsVUFBZixFQUEyQjtBQUFFLFdBQU8vdkIsR0FBUDtBQUFhLEdBQTFDLE1BQWdEO0FBQUUsUUFBSTh3QixTQUFTLEVBQWIsQ0FBaUIsSUFBSTl3QixPQUFPLElBQVgsRUFBaUI7QUFBRSxXQUFLLElBQUlzQixHQUFULElBQWdCdEIsR0FBaEIsRUFBcUI7QUFBRSxZQUFJZ0gsT0FBTzRCLFNBQVAsQ0FBaUJuSSxjQUFqQixDQUFnQ2MsSUFBaEMsQ0FBcUN2QixHQUFyQyxFQUEwQ3NCLEdBQTFDLENBQUosRUFBb0Q7QUFBRSxjQUFJb1csT0FBTzFRLE9BQU8rcEIsY0FBUCxJQUF5Qi9wQixPQUFPZ3FCLHdCQUFoQyxHQUEyRGhxQixPQUFPZ3FCLHdCQUFQLENBQWdDaHhCLEdBQWhDLEVBQXFDc0IsR0FBckMsQ0FBM0QsR0FBdUcsRUFBbEgsQ0FBc0gsSUFBSW9XLEtBQUt6VixHQUFMLElBQVl5VixLQUFLdVosR0FBckIsRUFBMEI7QUFBRWpxQixtQkFBTytwQixjQUFQLENBQXNCRCxNQUF0QixFQUE4Qnh2QixHQUE5QixFQUFtQ29XLElBQW5DO0FBQTJDLFdBQXZFLE1BQTZFO0FBQUVvWixtQkFBT3h2QixHQUFQLElBQWN0QixJQUFJc0IsR0FBSixDQUFkO0FBQXlCO0FBQUU7QUFBRTtBQUFFLEtBQUN3dkIsT0FBT3J2QixPQUFQLEdBQWlCekIsR0FBakIsQ0FBc0IsT0FBTzh3QixNQUFQO0FBQWdCO0FBQUU7O0FBRXhkLFNBQVNJLDZCQUFULENBQXVDL3FCLE1BQXZDLEVBQStDZ3JCLFFBQS9DLEVBQXlEO0FBQUUsTUFBSWhyQixVQUFVLElBQWQsRUFBb0IsT0FBTyxFQUFQLENBQVcsSUFBSThNLFNBQVMsRUFBYixDQUFpQixJQUFJbWUsYUFBYXBxQixPQUFPQyxJQUFQLENBQVlkLE1BQVosQ0FBakIsQ0FBc0MsSUFBSTdFLEdBQUosRUFBU1YsQ0FBVCxDQUFZLEtBQUtBLElBQUksQ0FBVCxFQUFZQSxJQUFJd3dCLFdBQVd0d0IsTUFBM0IsRUFBbUNGLEdBQW5DLEVBQXdDO0FBQUVVLFVBQU04dkIsV0FBV3h3QixDQUFYLENBQU4sQ0FBcUIsSUFBSXV3QixTQUFTaHFCLE9BQVQsQ0FBaUI3RixHQUFqQixLQUF5QixDQUE3QixFQUFnQyxTQUFVMlIsT0FBTzNSLEdBQVAsSUFBYzZFLE9BQU83RSxHQUFQLENBQWQ7QUFBNEIsR0FBQyxPQUFPMlIsTUFBUDtBQUFnQjs7QUFFblQsU0FBU29lLGNBQVQsQ0FBd0JDLFFBQXhCLEVBQWtDQyxVQUFsQyxFQUE4QztBQUFFRCxXQUFTMW9CLFNBQVQsR0FBcUI1QixPQUFPd3FCLE1BQVAsQ0FBY0QsV0FBVzNvQixTQUF6QixDQUFyQixDQUEwRDBvQixTQUFTMW9CLFNBQVQsQ0FBbUJJLFdBQW5CLEdBQWlDc29CLFFBQWpDO0FBQTVELFlBQXVHQSxRQUF2RyxFQUE0SEMsVUFBNUg7QUFBeUk7O0FBRXZMLElBQUlmLFlBQVksV0FBaEI7QUFDQXZ4QixRQUFRdXhCLFNBQVIsR0FBb0JBLFNBQXBCO0FBQ0EsSUFBSUQsU0FBUyxRQUFiO0FBQ0F0eEIsUUFBUXN4QixNQUFSLEdBQWlCQSxNQUFqQjtBQUNBLElBQUlELFdBQVcsVUFBZjtBQUNBcnhCLFFBQVFxeEIsUUFBUixHQUFtQkEsUUFBbkI7QUFDQSxJQUFJRCxVQUFVLFNBQWQ7QUFDQXB4QixRQUFRb3hCLE9BQVIsR0FBa0JBLE9BQWxCO0FBQ0EsSUFBSUQsVUFBVSxTQUFkO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdHQW54QixRQUFRbXhCLE9BQVIsR0FBa0JBLE9BQWxCOztBQUVBLElBQUlKO0FBQ0o7QUFDQSxVQUFVeUIsZ0JBQVYsRUFBNEI7QUFDMUJKLGlCQUFlckIsVUFBZixFQUEyQnlCLGdCQUEzQjs7QUFFQSxXQUFTekIsVUFBVCxDQUFvQjd0QixLQUFwQixFQUEyQjBPLE9BQTNCLEVBQW9DO0FBQ2xDLFFBQUk2Z0IsS0FBSjs7QUFFQUEsWUFBUUQsaUJBQWlCbHdCLElBQWpCLENBQXNCLElBQXRCLEVBQTRCWSxLQUE1QixFQUFtQzBPLE9BQW5DLEtBQStDLElBQXZEO0FBQ0EsUUFBSThnQixjQUFjOWdCLFFBQVErZ0IsZUFBMUIsQ0FKa0MsQ0FJUzs7QUFFM0MsUUFBSWxELFNBQVNpRCxlQUFlLENBQUNBLFlBQVlFLFVBQTVCLEdBQXlDMXZCLE1BQU04ZSxLQUEvQyxHQUF1RDllLE1BQU11c0IsTUFBMUU7QUFDQSxRQUFJb0QsYUFBSjtBQUNBSixVQUFNSyxZQUFOLEdBQXFCLElBQXJCOztBQUVBLFFBQUk1dkIsTUFBTTRnQixFQUFWLEVBQWM7QUFDWixVQUFJMkwsTUFBSixFQUFZO0FBQ1ZvRCx3QkFBZ0J2QixNQUFoQjtBQUNBbUIsY0FBTUssWUFBTixHQUFxQnpCLFFBQXJCO0FBQ0QsT0FIRCxNQUdPO0FBQ0x3Qix3QkFBZ0J6QixPQUFoQjtBQUNEO0FBQ0YsS0FQRCxNQU9PO0FBQ0wsVUFBSWx1QixNQUFNNnZCLGFBQU4sSUFBdUI3dkIsTUFBTTh2QixZQUFqQyxFQUErQztBQUM3Q0gsd0JBQWdCdEIsU0FBaEI7QUFDRCxPQUZELE1BRU87QUFDTHNCLHdCQUFnQnZCLE1BQWhCO0FBQ0Q7QUFDRjs7QUFFRG1CLFVBQU12bUIsS0FBTixHQUFjO0FBQ1p3VixjQUFRbVI7QUFESSxLQUFkO0FBR0FKLFVBQU1RLFlBQU4sR0FBcUIsSUFBckI7QUFDQSxXQUFPUixLQUFQO0FBQ0Q7O0FBRUQsTUFBSVMsU0FBU25DLFdBQVdwbkIsU0FBeEI7O0FBRUF1cEIsU0FBT2p3QixlQUFQLEdBQXlCLFNBQVNBLGVBQVQsR0FBMkI7QUFDbEQsV0FBTztBQUNMMHZCLHVCQUFpQixJQURaLENBQ2lCOztBQURqQixLQUFQO0FBSUQsR0FMRDs7QUFPQTVCLGFBQVdvQyx3QkFBWCxHQUFzQyxTQUFTQSx3QkFBVCxDQUFrQ0MsSUFBbEMsRUFBd0NDLFNBQXhDLEVBQW1EO0FBQ3ZGLFFBQUlDLFNBQVNGLEtBQUt0UCxFQUFsQjs7QUFFQSxRQUFJd1AsVUFBVUQsVUFBVTNSLE1BQVYsS0FBcUI2UCxTQUFuQyxFQUE4QztBQUM1QyxhQUFPO0FBQ0w3UCxnQkFBUTRQO0FBREgsT0FBUDtBQUdEOztBQUVELFdBQU8sSUFBUDtBQUNELEdBVkQsQ0E1QzBCLENBc0R2QjtBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E0QixTQUFPOW5CLGlCQUFQLEdBQTJCLFNBQVNBLGlCQUFULEdBQTZCO0FBQ3RELFNBQUttb0IsWUFBTCxDQUFrQixJQUFsQixFQUF3QixLQUFLVCxZQUE3QjtBQUNELEdBRkQ7O0FBSUFJLFNBQU9qdkIsa0JBQVAsR0FBNEIsU0FBU0Esa0JBQVQsQ0FBNEJ5ZSxTQUE1QixFQUF1QztBQUNqRSxRQUFJOFEsYUFBYSxJQUFqQjs7QUFFQSxRQUFJOVEsY0FBYyxLQUFLeGYsS0FBdkIsRUFBOEI7QUFDNUIsVUFBSXdlLFNBQVMsS0FBS3hWLEtBQUwsQ0FBV3dWLE1BQXhCOztBQUVBLFVBQUksS0FBS3hlLEtBQUwsQ0FBVzRnQixFQUFmLEVBQW1CO0FBQ2pCLFlBQUlwQyxXQUFXMlAsUUFBWCxJQUF1QjNQLFdBQVcwUCxPQUF0QyxFQUErQztBQUM3Q29DLHVCQUFhbkMsUUFBYjtBQUNEO0FBQ0YsT0FKRCxNQUlPO0FBQ0wsWUFBSTNQLFdBQVcyUCxRQUFYLElBQXVCM1AsV0FBVzBQLE9BQXRDLEVBQStDO0FBQzdDb0MsdUJBQWFyQyxPQUFiO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQUtvQyxZQUFMLENBQWtCLEtBQWxCLEVBQXlCQyxVQUF6QjtBQUNELEdBbEJEOztBQW9CQU4sU0FBT2h2QixvQkFBUCxHQUE4QixTQUFTQSxvQkFBVCxHQUFnQztBQUM1RCxTQUFLdXZCLGtCQUFMO0FBQ0QsR0FGRDs7QUFJQVAsU0FBT1EsV0FBUCxHQUFxQixTQUFTQSxXQUFULEdBQXVCO0FBQzFDLFFBQUlDLFVBQVUsS0FBS3p3QixLQUFMLENBQVd5d0IsT0FBekI7QUFDQSxRQUFJQyxJQUFKLEVBQVU1UixLQUFWLEVBQWlCeU4sTUFBakI7QUFDQW1FLFdBQU81UixRQUFReU4sU0FBU2tFLE9BQXhCOztBQUVBLFFBQUlBLFdBQVcsSUFBWCxJQUFtQixPQUFPQSxPQUFQLEtBQW1CLFFBQTFDLEVBQW9EO0FBQ2xEQyxhQUFPRCxRQUFRQyxJQUFmO0FBQ0E1UixjQUFRMlIsUUFBUTNSLEtBQWhCO0FBQ0F5TixlQUFTa0UsUUFBUWxFLE1BQWpCO0FBQ0Q7O0FBRUQsV0FBTztBQUNMbUUsWUFBTUEsSUFERDtBQUVMNVIsYUFBT0EsS0FGRjtBQUdMeU4sY0FBUUE7QUFISCxLQUFQO0FBS0QsR0FoQkQ7O0FBa0JBeUQsU0FBT0ssWUFBUCxHQUFzQixTQUFTQSxZQUFULENBQXNCTSxRQUF0QixFQUFnQ0wsVUFBaEMsRUFBNEM7QUFDaEUsUUFBSUssYUFBYSxLQUFLLENBQXRCLEVBQXlCO0FBQ3ZCQSxpQkFBVyxLQUFYO0FBQ0Q7O0FBRUQsUUFBSUwsZUFBZSxJQUFuQixFQUF5QjtBQUN2QjtBQUNBLFdBQUtDLGtCQUFMOztBQUVBLFVBQUk5ZixPQUFPK2QsVUFBVWx2QixPQUFWLENBQWtCc3hCLFdBQWxCLENBQThCLElBQTlCLENBQVg7O0FBRUEsVUFBSU4sZUFBZW5DLFFBQW5CLEVBQTZCO0FBQzNCLGFBQUswQyxZQUFMLENBQWtCcGdCLElBQWxCLEVBQXdCa2dCLFFBQXhCO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsYUFBS0csV0FBTCxDQUFpQnJnQixJQUFqQjtBQUNEO0FBQ0YsS0FYRCxNQVdPLElBQUksS0FBS3pRLEtBQUwsQ0FBVzZ2QixhQUFYLElBQTRCLEtBQUs3bUIsS0FBTCxDQUFXd1YsTUFBWCxLQUFzQjRQLE1BQXRELEVBQThEO0FBQ25FLFdBQUs5TyxRQUFMLENBQWM7QUFDWmQsZ0JBQVE2UDtBQURJLE9BQWQ7QUFHRDtBQUNGLEdBckJEOztBQXVCQTJCLFNBQU9hLFlBQVAsR0FBc0IsU0FBU0EsWUFBVCxDQUFzQnBnQixJQUF0QixFQUE0QmtnQixRQUE1QixFQUFzQztBQUMxRCxRQUFJSSxTQUFTLElBQWI7O0FBRUEsUUFBSWpTLFFBQVEsS0FBSzllLEtBQUwsQ0FBVzhlLEtBQXZCO0FBQ0EsUUFBSWtTLFlBQVksS0FBS3RpQixPQUFMLENBQWErZ0IsZUFBYixHQUErQixLQUFLL2dCLE9BQUwsQ0FBYStnQixlQUFiLENBQTZCQyxVQUE1RCxHQUF5RWlCLFFBQXpGO0FBQ0EsUUFBSU0sV0FBVyxLQUFLVCxXQUFMLEVBQWYsQ0FMMEQsQ0FLdkI7QUFDbkM7O0FBRUEsUUFBSSxDQUFDRyxRQUFELElBQWEsQ0FBQzdSLEtBQWxCLEVBQXlCO0FBQ3ZCLFdBQUtvUyxZQUFMLENBQWtCO0FBQ2hCMVMsZ0JBQVEwUDtBQURRLE9BQWxCLEVBRUcsWUFBWTtBQUNiNkMsZUFBTy93QixLQUFQLENBQWF3aEIsU0FBYixDQUF1Qi9RLElBQXZCO0FBQ0QsT0FKRDtBQUtBO0FBQ0Q7O0FBRUQsU0FBS3pRLEtBQUwsQ0FBV2l0QixPQUFYLENBQW1CeGMsSUFBbkIsRUFBeUJ1Z0IsU0FBekI7QUFDQSxTQUFLRSxZQUFMLENBQWtCO0FBQ2hCMVMsY0FBUTJQO0FBRFEsS0FBbEIsRUFFRyxZQUFZO0FBQ2I0QyxhQUFPL3dCLEtBQVAsQ0FBYXloQixVQUFiLENBQXdCaFIsSUFBeEIsRUFBOEJ1Z0IsU0FBOUIsRUFEYSxDQUM2Qjs7O0FBRzFDRCxhQUFPSSxlQUFQLENBQXVCMWdCLElBQXZCLEVBQTZCd2dCLFNBQVNuUyxLQUF0QyxFQUE2QyxZQUFZO0FBQ3ZEaVMsZUFBT0csWUFBUCxDQUFvQjtBQUNsQjFTLGtCQUFRMFA7QUFEVSxTQUFwQixFQUVHLFlBQVk7QUFDYjZDLGlCQUFPL3dCLEtBQVAsQ0FBYXdoQixTQUFiLENBQXVCL1EsSUFBdkIsRUFBNkJ1Z0IsU0FBN0I7QUFDRCxTQUpEO0FBS0QsT0FORDtBQU9ELEtBYkQ7QUFjRCxHQWhDRDs7QUFrQ0FoQixTQUFPYyxXQUFQLEdBQXFCLFNBQVNBLFdBQVQsQ0FBcUJyZ0IsSUFBckIsRUFBMkI7QUFDOUMsUUFBSTJnQixTQUFTLElBQWI7O0FBRUEsUUFBSVYsT0FBTyxLQUFLMXdCLEtBQUwsQ0FBVzB3QixJQUF0QjtBQUNBLFFBQUlPLFdBQVcsS0FBS1QsV0FBTCxFQUFmLENBSjhDLENBSVg7O0FBRW5DLFFBQUksQ0FBQ0UsSUFBTCxFQUFXO0FBQ1QsV0FBS1EsWUFBTCxDQUFrQjtBQUNoQjFTLGdCQUFRNFA7QUFEUSxPQUFsQixFQUVHLFlBQVk7QUFDYmdELGVBQU9weEIsS0FBUCxDQUFhcXhCLFFBQWIsQ0FBc0I1Z0IsSUFBdEI7QUFDRCxPQUpEO0FBS0E7QUFDRDs7QUFFRCxTQUFLelEsS0FBTCxDQUFXc3hCLE1BQVgsQ0FBa0I3Z0IsSUFBbEI7QUFDQSxTQUFLeWdCLFlBQUwsQ0FBa0I7QUFDaEIxUyxjQUFReVA7QUFEUSxLQUFsQixFQUVHLFlBQVk7QUFDYm1ELGFBQU9weEIsS0FBUCxDQUFhdXhCLFNBQWIsQ0FBdUI5Z0IsSUFBdkI7O0FBRUEyZ0IsYUFBT0QsZUFBUCxDQUF1QjFnQixJQUF2QixFQUE2QndnQixTQUFTUCxJQUF0QyxFQUE0QyxZQUFZO0FBQ3REVSxlQUFPRixZQUFQLENBQW9CO0FBQ2xCMVMsa0JBQVE0UDtBQURVLFNBQXBCLEVBRUcsWUFBWTtBQUNiZ0QsaUJBQU9weEIsS0FBUCxDQUFhcXhCLFFBQWIsQ0FBc0I1Z0IsSUFBdEI7QUFDRCxTQUpEO0FBS0QsT0FORDtBQU9ELEtBWkQ7QUFhRCxHQTdCRDs7QUErQkF1ZixTQUFPTyxrQkFBUCxHQUE0QixTQUFTQSxrQkFBVCxHQUE4QjtBQUN4RCxRQUFJLEtBQUtSLFlBQUwsS0FBc0IsSUFBMUIsRUFBZ0M7QUFDOUIsV0FBS0EsWUFBTCxDQUFrQnhiLE1BQWxCO0FBQ0EsV0FBS3diLFlBQUwsR0FBb0IsSUFBcEI7QUFDRDtBQUNGLEdBTEQ7O0FBT0FDLFNBQU9rQixZQUFQLEdBQXNCLFNBQVNBLFlBQVQsQ0FBc0JNLFNBQXRCLEVBQWlDL3BCLFFBQWpDLEVBQTJDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBQSxlQUFXLEtBQUtncUIsZUFBTCxDQUFxQmhxQixRQUFyQixDQUFYO0FBQ0EsU0FBSzZYLFFBQUwsQ0FBY2tTLFNBQWQsRUFBeUIvcEIsUUFBekI7QUFDRCxHQU5EOztBQVFBdW9CLFNBQU95QixlQUFQLEdBQXlCLFNBQVNBLGVBQVQsQ0FBeUJocUIsUUFBekIsRUFBbUM7QUFDMUQsUUFBSWlxQixTQUFTLElBQWI7O0FBRUEsUUFBSUMsU0FBUyxJQUFiOztBQUVBLFNBQUs1QixZQUFMLEdBQW9CLFVBQVU2QixLQUFWLEVBQWlCO0FBQ25DLFVBQUlELE1BQUosRUFBWTtBQUNWQSxpQkFBUyxLQUFUO0FBQ0FELGVBQU8zQixZQUFQLEdBQXNCLElBQXRCO0FBQ0F0b0IsaUJBQVNtcUIsS0FBVDtBQUNEO0FBQ0YsS0FORDs7QUFRQSxTQUFLN0IsWUFBTCxDQUFrQnhiLE1BQWxCLEdBQTJCLFlBQVk7QUFDckNvZCxlQUFTLEtBQVQ7QUFDRCxLQUZEOztBQUlBLFdBQU8sS0FBSzVCLFlBQVo7QUFDRCxHQWxCRDs7QUFvQkFDLFNBQU9tQixlQUFQLEdBQXlCLFNBQVNBLGVBQVQsQ0FBeUIxZ0IsSUFBekIsRUFBK0JnZ0IsT0FBL0IsRUFBd0NvQixPQUF4QyxFQUFpRDtBQUN4RSxTQUFLSixlQUFMLENBQXFCSSxPQUFyQjs7QUFFQSxRQUFJcGhCLElBQUosRUFBVTtBQUNSLFVBQUksS0FBS3pRLEtBQUwsQ0FBVzh4QixjQUFmLEVBQStCO0FBQzdCLGFBQUs5eEIsS0FBTCxDQUFXOHhCLGNBQVgsQ0FBMEJyaEIsSUFBMUIsRUFBZ0MsS0FBS3NmLFlBQXJDO0FBQ0Q7O0FBRUQsVUFBSVUsV0FBVyxJQUFmLEVBQXFCO0FBQ25CM1EsbUJBQVcsS0FBS2lRLFlBQWhCLEVBQThCVSxPQUE5QjtBQUNEO0FBQ0YsS0FSRCxNQVFPO0FBQ0wzUSxpQkFBVyxLQUFLaVEsWUFBaEIsRUFBOEIsQ0FBOUI7QUFDRDtBQUNGLEdBZEQ7O0FBZ0JBQyxTQUFPM3VCLE1BQVAsR0FBZ0IsU0FBU0EsTUFBVCxHQUFrQjtBQUNoQyxRQUFJbWQsU0FBUyxLQUFLeFYsS0FBTCxDQUFXd1YsTUFBeEI7O0FBRUEsUUFBSUEsV0FBVzZQLFNBQWYsRUFBMEI7QUFDeEIsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsUUFBSTBELGNBQWMsS0FBSy94QixLQUF2QjtBQUFBLFFBQ0l3QixXQUFXdXdCLFlBQVl2d0IsUUFEM0I7QUFBQSxRQUVJd3dCLGFBQWFqRCw4QkFBOEJnRCxXQUE5QixFQUEyQyxDQUFDLFVBQUQsQ0FBM0MsQ0FGakIsQ0FQZ0MsQ0FTMkM7OztBQUczRSxXQUFPQyxXQUFXcFIsRUFBbEI7QUFDQSxXQUFPb1IsV0FBV2xDLFlBQWxCO0FBQ0EsV0FBT2tDLFdBQVduQyxhQUFsQjtBQUNBLFdBQU9tQyxXQUFXekYsTUFBbEI7QUFDQSxXQUFPeUYsV0FBV2xULEtBQWxCO0FBQ0EsV0FBT2tULFdBQVd0QixJQUFsQjtBQUNBLFdBQU9zQixXQUFXdkIsT0FBbEI7QUFDQSxXQUFPdUIsV0FBV0YsY0FBbEI7QUFDQSxXQUFPRSxXQUFXL0UsT0FBbEI7QUFDQSxXQUFPK0UsV0FBV3ZRLFVBQWxCO0FBQ0EsV0FBT3VRLFdBQVd4USxTQUFsQjtBQUNBLFdBQU93USxXQUFXVixNQUFsQjtBQUNBLFdBQU9VLFdBQVdULFNBQWxCO0FBQ0EsV0FBT1MsV0FBV1gsUUFBbEI7O0FBRUEsUUFBSSxPQUFPN3ZCLFFBQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDbEMsYUFBT0EsU0FBU2dkLE1BQVQsRUFBaUJ3VCxVQUFqQixDQUFQO0FBQ0Q7O0FBRUQsUUFBSTNuQixRQUFRa2tCLE9BQU9qdkIsT0FBUCxDQUFlZ0MsUUFBZixDQUF3QkMsSUFBeEIsQ0FBNkJDLFFBQTdCLENBQVo7O0FBRUEsV0FBTytzQixPQUFPanZCLE9BQVAsQ0FBZWdSLFlBQWYsQ0FBNEJqRyxLQUE1QixFQUFtQzJuQixVQUFuQyxDQUFQO0FBQ0QsR0FsQ0Q7O0FBb0NBLFNBQU9uRSxVQUFQO0FBQ0QsQ0F0U0QsQ0FzU0VVLE9BQU9qdkIsT0FBUCxDQUFlbUMsU0F0U2pCLENBRkE7O0FBMFNBb3NCLFdBQVdsZSxZQUFYLEdBQTBCO0FBQ3hCOGYsbUJBQWlCOXRCLFVBQVVqRjtBQURILENBQTFCO0FBR0FteEIsV0FBVzdyQixpQkFBWCxHQUErQjtBQUM3Qnl0QixtQkFBaUIsU0FBU0EsZUFBVCxHQUEyQixDQUFFO0FBRGpCLENBQS9CO0FBR0E1QixXQUFXbnNCLFNBQVgsR0FBdUJ2RixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsR0FBd0M7QUFDN0Q7Ozs7Ozs7Ozs7Ozs7O0FBY0FtRixZQUFVRyxVQUFVNk8sU0FBVixDQUFvQixDQUFDN08sVUFBVWhFLElBQVYsQ0FBZXMwQixVQUFoQixFQUE0QnR3QixVQUFVRyxPQUFWLENBQWtCbXdCLFVBQTlDLENBQXBCLEVBQStFQSxVQWY1Qjs7QUFpQjdEOzs7QUFHQXJSLE1BQUlqZixVQUFVRSxJQXBCK0M7O0FBc0I3RDs7Ozs7O0FBTUFpdUIsZ0JBQWNudUIsVUFBVUUsSUE1QnFDOztBQThCN0Q7Ozs7QUFJQWd1QixpQkFBZWx1QixVQUFVRSxJQWxDb0M7O0FBb0M3RDs7Ozs7OztBQU9BMHFCLFVBQVE1cUIsVUFBVUUsSUEzQzJDOztBQTZDN0Q7OztBQUdBaWQsU0FBT25kLFVBQVVFLElBaEQ0Qzs7QUFrRDdEOzs7QUFHQTZ1QixRQUFNL3VCLFVBQVVFLElBckQ2Qzs7QUF1RDdEOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBNHVCLFdBQVMsU0FBU0EsT0FBVCxDQUFpQnp3QixLQUFqQixFQUF3QjtBQUMvQixRQUFJa3lCLEtBQUsvMUIsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLEdBQXdDcXlCLFdBQVd5RCxhQUFuRCxHQUFtRSxFQUE1RSxDQUErRTtBQUMvRSxRQUFJLENBQUNueUIsTUFBTTh4QixjQUFYLEVBQTJCSSxLQUFLQSxHQUFHRCxVQUFSOztBQUUzQixTQUFLLElBQUlHLE9BQU8xekIsVUFBVUMsTUFBckIsRUFBNkJpQixPQUFPLElBQUliLEtBQUosQ0FBVXF6QixPQUFPLENBQVAsR0FBV0EsT0FBTyxDQUFsQixHQUFzQixDQUFoQyxDQUFwQyxFQUF3RXRwQixPQUFPLENBQXBGLEVBQXVGQSxPQUFPc3BCLElBQTlGLEVBQW9HdHBCLE1BQXBHLEVBQTRHO0FBQzFHbEosV0FBS2tKLE9BQU8sQ0FBWixJQUFpQnBLLFVBQVVvSyxJQUFWLENBQWpCO0FBQ0Q7O0FBRUQsV0FBT29wQixHQUFHaHpCLEtBQUgsQ0FBUyxLQUFLLENBQWQsRUFBaUIsQ0FBQ2MsS0FBRCxFQUFRa0UsTUFBUixDQUFldEUsSUFBZixDQUFqQixDQUFQO0FBQ0QsR0FoRjREOztBQWtGN0Q7Ozs7Ozs7Ozs7OztBQVlBa3lCLGtCQUFnQm53QixVQUFVaEUsSUE5Rm1DOztBQWdHN0Q7Ozs7OztBQU1Bc3ZCLFdBQVN0ckIsVUFBVWhFLElBdEcwQzs7QUF3RzdEOzs7Ozs7QUFNQThqQixjQUFZOWYsVUFBVWhFLElBOUd1Qzs7QUFnSDdEOzs7Ozs7QUFNQTZqQixhQUFXN2YsVUFBVWhFLElBdEh3Qzs7QUF3SDdEOzs7OztBQUtBMnpCLFVBQVEzdkIsVUFBVWhFLElBN0gyQzs7QUErSDdEOzs7OztBQUtBNHpCLGFBQVc1dkIsVUFBVWhFLElBcEl3Qzs7QUFzSTdEOzs7OztBQUtBMHpCLFlBQVUxdkIsVUFBVWhFLElBM0l5QyxDQTJJcEM7O0FBM0lvQyxDQUF4QyxHQTZJbkIsRUE3SUo7O0FBK0lBLFNBQVM4TixJQUFULEdBQWdCLENBQUU7O0FBRWxCb2lCLFdBQVc5ckIsWUFBWCxHQUEwQjtBQUN4QjZlLE1BQUksS0FEb0I7QUFFeEJrUCxnQkFBYyxLQUZVO0FBR3hCRCxpQkFBZSxLQUhTO0FBSXhCdEQsVUFBUSxLQUpnQjtBQUt4QnpOLFNBQU8sSUFMaUI7QUFNeEI0UixRQUFNLElBTmtCO0FBT3hCekQsV0FBU3hoQixJQVBlO0FBUXhCZ1csY0FBWWhXLElBUlk7QUFTeEIrVixhQUFXL1YsSUFUYTtBQVV4QjZsQixVQUFRN2xCLElBVmdCO0FBV3hCOGxCLGFBQVc5bEIsSUFYYTtBQVl4QjRsQixZQUFVNWxCO0FBWmMsQ0FBMUI7QUFjQW9pQixXQUFXUSxTQUFYLEdBQXVCLENBQXZCO0FBQ0FSLFdBQVdPLE1BQVgsR0FBb0IsQ0FBcEI7QUFDQVAsV0FBV00sUUFBWCxHQUFzQixDQUF0QjtBQUNBTixXQUFXSyxPQUFYLEdBQXFCLENBQXJCO0FBQ0FMLFdBQVdJLE9BQVgsR0FBcUIsQ0FBckI7O0FBRUEsSUFBSW9FLFdBQVcsQ0FBQyxHQUFHNUQsdUJBQXVCNkQsUUFBM0IsRUFBcUN6RSxVQUFyQyxDQUFmOztBQUVBL3dCLFFBQVF3QyxPQUFSLEdBQWtCK3lCLFFBQWxCLEM7Ozs7Ozs7Ozs7O0FDemxCQTs7Ozs7OztBQU9BLFNBQVMxeEIsa0JBQVQsR0FBOEI7QUFDNUI7QUFDQSxNQUFJcUksUUFBUSxLQUFLbkMsV0FBTCxDQUFpQm9wQix3QkFBakIsQ0FBMEMsS0FBS2p3QixLQUEvQyxFQUFzRCxLQUFLZ0osS0FBM0QsQ0FBWjtBQUNBLE1BQUlBLFVBQVUsSUFBVixJQUFrQkEsVUFBVWdTLFNBQWhDLEVBQTJDO0FBQ3pDLFNBQUtzRSxRQUFMLENBQWN0VyxLQUFkO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTbkkseUJBQVQsQ0FBbUNDLFNBQW5DLEVBQThDO0FBQzVDO0FBQ0E7QUFDQSxXQUFTeXhCLE9BQVQsQ0FBaUJwQyxTQUFqQixFQUE0QjtBQUMxQixRQUFJbm5CLFFBQVEsS0FBS25DLFdBQUwsQ0FBaUJvcEIsd0JBQWpCLENBQTBDbnZCLFNBQTFDLEVBQXFEcXZCLFNBQXJELENBQVo7QUFDQSxXQUFPbm5CLFVBQVUsSUFBVixJQUFrQkEsVUFBVWdTLFNBQTVCLEdBQXdDaFMsS0FBeEMsR0FBZ0QsSUFBdkQ7QUFDRDtBQUNEO0FBQ0EsT0FBS3NXLFFBQUwsQ0FBY2lULFFBQVE3a0IsSUFBUixDQUFhLElBQWIsQ0FBZDtBQUNEOztBQUVELFNBQVNtYSxtQkFBVCxDQUE2Qi9tQixTQUE3QixFQUF3QzB3QixTQUF4QyxFQUFtRDtBQUNqRCxNQUFJO0FBQ0YsUUFBSWhTLFlBQVksS0FBS3hmLEtBQXJCO0FBQ0EsUUFBSW13QixZQUFZLEtBQUtubkIsS0FBckI7QUFDQSxTQUFLaEosS0FBTCxHQUFhYyxTQUFiO0FBQ0EsU0FBS2tJLEtBQUwsR0FBYXdvQixTQUFiO0FBQ0EsU0FBS2dCLDJCQUFMLEdBQW1DLElBQW5DO0FBQ0EsU0FBS0MsdUJBQUwsR0FBK0IsS0FBS0MsdUJBQUwsQ0FDN0JsVCxTQUQ2QixFQUU3QjJRLFNBRjZCLENBQS9CO0FBSUQsR0FWRCxTQVVVO0FBQ1IsU0FBS253QixLQUFMLEdBQWF3ZixTQUFiO0FBQ0EsU0FBS3hXLEtBQUwsR0FBYW1uQixTQUFiO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBO0FBQ0F4dkIsbUJBQW1CZ3lCLDRCQUFuQixHQUFrRCxJQUFsRDtBQUNBOXhCLDBCQUEwQjh4Qiw0QkFBMUIsR0FBeUQsSUFBekQ7QUFDQTlLLG9CQUFvQjhLLDRCQUFwQixHQUFtRCxJQUFuRDs7QUFFQSxTQUFTTCxRQUFULENBQWtCN3dCLFNBQWxCLEVBQTZCO0FBQzNCLE1BQUlnRixZQUFZaEYsVUFBVWdGLFNBQTFCOztBQUVBLE1BQUksQ0FBQ0EsU0FBRCxJQUFjLENBQUNBLFVBQVVtc0IsZ0JBQTdCLEVBQStDO0FBQzdDLFVBQU0sSUFBSTVPLEtBQUosQ0FBVSxvQ0FBVixDQUFOO0FBQ0Q7O0FBRUQsTUFDRSxPQUFPdmlCLFVBQVV3dUIsd0JBQWpCLEtBQThDLFVBQTlDLElBQ0EsT0FBT3hwQixVQUFVaXNCLHVCQUFqQixLQUE2QyxVQUYvQyxFQUdFO0FBQ0EsV0FBT2p4QixTQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsTUFBSW94QixxQkFBcUIsSUFBekI7QUFDQSxNQUFJQyw0QkFBNEIsSUFBaEM7QUFDQSxNQUFJQyxzQkFBc0IsSUFBMUI7QUFDQSxNQUFJLE9BQU90c0IsVUFBVTlGLGtCQUFqQixLQUF3QyxVQUE1QyxFQUF3RDtBQUN0RGt5Qix5QkFBcUIsb0JBQXJCO0FBQ0QsR0FGRCxNQUVPLElBQUksT0FBT3BzQixVQUFVdXNCLHlCQUFqQixLQUErQyxVQUFuRCxFQUErRDtBQUNwRUgseUJBQXFCLDJCQUFyQjtBQUNEO0FBQ0QsTUFBSSxPQUFPcHNCLFVBQVU1Rix5QkFBakIsS0FBK0MsVUFBbkQsRUFBK0Q7QUFDN0RpeUIsZ0NBQTRCLDJCQUE1QjtBQUNELEdBRkQsTUFFTyxJQUFJLE9BQU9yc0IsVUFBVXdzQixnQ0FBakIsS0FBc0QsVUFBMUQsRUFBc0U7QUFDM0VILGdDQUE0QixrQ0FBNUI7QUFDRDtBQUNELE1BQUksT0FBT3JzQixVQUFVb2hCLG1CQUFqQixLQUF5QyxVQUE3QyxFQUF5RDtBQUN2RGtMLDBCQUFzQixxQkFBdEI7QUFDRCxHQUZELE1BRU8sSUFBSSxPQUFPdHNCLFVBQVV5c0IsMEJBQWpCLEtBQWdELFVBQXBELEVBQWdFO0FBQ3JFSCwwQkFBc0IsNEJBQXRCO0FBQ0Q7QUFDRCxNQUNFRix1QkFBdUIsSUFBdkIsSUFDQUMsOEJBQThCLElBRDlCLElBRUFDLHdCQUF3QixJQUgxQixFQUlFO0FBQ0EsUUFBSUksZ0JBQWdCMXhCLFVBQVVXLFdBQVYsSUFBeUJYLFVBQVU4WCxJQUF2RDtBQUNBLFFBQUk2WixhQUNGLE9BQU8zeEIsVUFBVXd1Qix3QkFBakIsS0FBOEMsVUFBOUMsR0FDSSw0QkFESixHQUVJLDJCQUhOOztBQUtBLFVBQU1qTSxNQUNKLDZGQUNFbVAsYUFERixHQUVFLFFBRkYsR0FHRUMsVUFIRixHQUlFLHFEQUpGLElBS0dQLHVCQUF1QixJQUF2QixHQUE4QixTQUFTQSxrQkFBdkMsR0FBNEQsRUFML0QsS0FNR0MsOEJBQThCLElBQTlCLEdBQ0csU0FBU0EseUJBRFosR0FFRyxFQVJOLEtBU0dDLHdCQUF3QixJQUF4QixHQUErQixTQUFTQSxtQkFBeEMsR0FBOEQsRUFUakUsSUFVRSxtRkFWRixHQVdFLHFEQVpFLENBQU47QUFjRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxNQUFJLE9BQU90eEIsVUFBVXd1Qix3QkFBakIsS0FBOEMsVUFBbEQsRUFBOEQ7QUFDNUR4cEIsY0FBVTlGLGtCQUFWLEdBQStCQSxrQkFBL0I7QUFDQThGLGNBQVU1Rix5QkFBVixHQUFzQ0EseUJBQXRDO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsTUFBSSxPQUFPNEYsVUFBVWlzQix1QkFBakIsS0FBNkMsVUFBakQsRUFBNkQ7QUFDM0QsUUFBSSxPQUFPanNCLFVBQVUxRixrQkFBakIsS0FBd0MsVUFBNUMsRUFBd0Q7QUFDdEQsWUFBTSxJQUFJaWpCLEtBQUosQ0FDSixtSEFESSxDQUFOO0FBR0Q7O0FBRUR2ZCxjQUFVb2hCLG1CQUFWLEdBQWdDQSxtQkFBaEM7O0FBRUEsUUFBSTltQixxQkFBcUIwRixVQUFVMUYsa0JBQW5DOztBQUVBMEYsY0FBVTFGLGtCQUFWLEdBQStCLFNBQVNzeUIsMEJBQVQsQ0FDN0I3VCxTQUQ2QixFQUU3QjJRLFNBRjZCLEVBRzdCbUQsYUFINkIsRUFJN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBSUMsV0FBVyxLQUFLZiwyQkFBTCxHQUNYLEtBQUtDLHVCQURNLEdBRVhhLGFBRko7O0FBSUF2eUIseUJBQW1CM0IsSUFBbkIsQ0FBd0IsSUFBeEIsRUFBOEJvZ0IsU0FBOUIsRUFBeUMyUSxTQUF6QyxFQUFvRG9ELFFBQXBEO0FBQ0QsS0FsQkQ7QUFtQkQ7O0FBRUQsU0FBTzl4QixTQUFQO0FBQ0Q7O1FBRVE2d0IsUSxHQUFBQSxROzs7Ozs7O0FDN0pJOztBQUVieDFCLFFBQVE4d0IsVUFBUixHQUFxQixJQUFyQjtBQUNBOXdCLFFBQVEwMkIsaUJBQVIsR0FBNEJBLGlCQUE1QjtBQUNBMTJCLFFBQVEyMkIsZUFBUixHQUEwQjMyQixRQUFRcTFCLGFBQVIsR0FBd0IsS0FBSyxDQUF2RDs7QUFFQSxJQUFJdUIsYUFBYWxHLHVCQUF1Qnp3QixtQkFBT0EsQ0FBQyxDQUFSLENBQXZCLENBQWpCOztBQUVBLFNBQVN5d0Isc0JBQVQsQ0FBZ0MzdkIsR0FBaEMsRUFBcUM7QUFBRSxTQUFPQSxPQUFPQSxJQUFJK3ZCLFVBQVgsR0FBd0IvdkIsR0FBeEIsR0FBOEIsRUFBRXlCLFNBQVN6QixHQUFYLEVBQXJDO0FBQXdEOztBQUUvRixTQUFTMjFCLGlCQUFULENBQTJCRyxjQUEzQixFQUEyQztBQUN6QyxNQUFJQyxrQkFBa0IsZUFBZUQsY0FBZixHQUFnQyxTQUF0RDtBQUNBLE1BQUlFLGtCQUFrQixlQUFlRixjQUFyQztBQUNBLFNBQU8sVUFBVTN6QixLQUFWLEVBQWlCO0FBQ3RCO0FBQ0EsUUFBSUEsTUFBTTZ6QixlQUFOLENBQUosRUFBNEI7QUFDMUI7QUFDQSxVQUFJN3pCLE1BQU00ekIsZUFBTixLQUEwQixJQUE5QixFQUFvQztBQUNsQyxlQUFPLElBQUk1UCxLQUFKLENBQVU0UCxrQkFBa0IsMkNBQWxCLEdBQWdFLGtFQUFoRSxHQUFxSSxpQ0FBckksR0FBeUssa0VBQXpLLEdBQThPLGNBQXhQLENBQVAsQ0FEa0MsQ0FDOE87QUFDalIsT0FGRCxNQUVPLElBQUksT0FBTzV6QixNQUFNNHpCLGVBQU4sQ0FBUCxLQUFrQyxRQUF0QyxFQUFnRDtBQUNyRCxlQUFPLElBQUk1UCxLQUFKLENBQVU0UCxrQkFBa0IscUNBQTVCLENBQVA7QUFDRDtBQUNGOztBQUVELFdBQU8sSUFBUDtBQUNELEdBWkQ7QUFhRDs7QUFFRCxJQUFJekIsZ0JBQWdCdUIsV0FBV3AwQixPQUFYLENBQW1Ca1IsU0FBbkIsQ0FBNkIsQ0FBQ2tqQixXQUFXcDBCLE9BQVgsQ0FBbUI0TCxNQUFwQixFQUE0QndvQixXQUFXcDBCLE9BQVgsQ0FBbUIrUyxLQUFuQixDQUF5QjtBQUNwR3lNLFNBQU80VSxXQUFXcDBCLE9BQVgsQ0FBbUI0TCxNQUQwRTtBQUVwR3dsQixRQUFNZ0QsV0FBV3AwQixPQUFYLENBQW1CNEw7QUFGMkUsQ0FBekIsRUFHMUUrbUIsVUFIOEMsQ0FBN0IsQ0FBcEI7O0FBS0FuMUIsUUFBUXExQixhQUFSLEdBQXdCQSxhQUF4Qjs7QUFFQSxJQUFJc0Isa0JBQWtCQyxXQUFXcDBCLE9BQVgsQ0FBbUJrUixTQUFuQixDQUE2QixDQUFDa2pCLFdBQVdwMEIsT0FBWCxDQUFtQnNDLE1BQXBCLEVBQTRCOHhCLFdBQVdwMEIsT0FBWCxDQUFtQitTLEtBQW5CLENBQXlCO0FBQ3RHeU0sU0FBTzRVLFdBQVdwMEIsT0FBWCxDQUFtQnNDLE1BRDRFO0FBRXRHOHVCLFFBQU1nRCxXQUFXcDBCLE9BQVgsQ0FBbUJzQyxNQUY2RTtBQUd0Ryt2QixVQUFRK0IsV0FBV3AwQixPQUFYLENBQW1Cc0M7QUFIMkUsQ0FBekIsQ0FBNUIsRUFJL0M4eEIsV0FBV3AwQixPQUFYLENBQW1CK1MsS0FBbkIsQ0FBeUI7QUFDM0J5TSxTQUFPNFUsV0FBV3AwQixPQUFYLENBQW1Cc0MsTUFEQztBQUUzQmt5QixhQUFXSixXQUFXcDBCLE9BQVgsQ0FBbUJzQyxNQUZIO0FBRzNCNnFCLGVBQWFpSCxXQUFXcDBCLE9BQVgsQ0FBbUJzQyxNQUhMO0FBSTNCOHVCLFFBQU1nRCxXQUFXcDBCLE9BQVgsQ0FBbUJzQyxNQUpFO0FBSzNCbXlCLFlBQVVMLFdBQVdwMEIsT0FBWCxDQUFtQnNDLE1BTEY7QUFNM0JveUIsY0FBWU4sV0FBV3AwQixPQUFYLENBQW1Cc0M7QUFOSixDQUF6QixDQUorQyxDQUE3QixDQUF0Qjs7QUFhQTlFLFFBQVEyMkIsZUFBUixHQUEwQkEsZUFBMUIsQzs7Ozs7OztBQ2hEQSwrQ0FBYTs7OztBQUViMzJCLFFBQVE4d0IsVUFBUixHQUFxQixJQUFyQjtBQUNBOXdCLFFBQVF3QyxPQUFSLEdBQWtCLEtBQUssQ0FBdkI7O0FBRUEsSUFBSW8wQixhQUFhbEcsdUJBQXVCendCLG1CQUFPQSxDQUFDLENBQVIsQ0FBdkIsQ0FBakI7O0FBRUEsSUFBSXd4QixTQUFTZix1QkFBdUJ6d0IsbUJBQU9BLENBQUMsQ0FBUixDQUF2QixDQUFiOztBQUVBLElBQUkweEIseUJBQXlCMXhCLG1CQUFPQSxDQUFDLEVBQVIsQ0FBN0I7O0FBRUEsSUFBSWszQixnQkFBZ0JsM0IsbUJBQU9BLENBQUMsR0FBUixDQUFwQjs7QUFFQSxTQUFTeXdCLHNCQUFULENBQWdDM3ZCLEdBQWhDLEVBQXFDO0FBQUUsU0FBT0EsT0FBT0EsSUFBSSt2QixVQUFYLEdBQXdCL3ZCLEdBQXhCLEdBQThCLEVBQUV5QixTQUFTekIsR0FBWCxFQUFyQztBQUF3RDs7QUFFL0YsU0FBU2t4Qiw2QkFBVCxDQUF1Qy9xQixNQUF2QyxFQUErQ2dyQixRQUEvQyxFQUF5RDtBQUFFLE1BQUlockIsVUFBVSxJQUFkLEVBQW9CLE9BQU8sRUFBUCxDQUFXLElBQUk4TSxTQUFTLEVBQWIsQ0FBaUIsSUFBSW1lLGFBQWFwcUIsT0FBT0MsSUFBUCxDQUFZZCxNQUFaLENBQWpCLENBQXNDLElBQUk3RSxHQUFKLEVBQVNWLENBQVQsQ0FBWSxLQUFLQSxJQUFJLENBQVQsRUFBWUEsSUFBSXd3QixXQUFXdHdCLE1BQTNCLEVBQW1DRixHQUFuQyxFQUF3QztBQUFFVSxVQUFNOHZCLFdBQVd4d0IsQ0FBWCxDQUFOLENBQXFCLElBQUl1d0IsU0FBU2hxQixPQUFULENBQWlCN0YsR0FBakIsS0FBeUIsQ0FBN0IsRUFBZ0MsU0FBVTJSLE9BQU8zUixHQUFQLElBQWM2RSxPQUFPN0UsR0FBUCxDQUFkO0FBQTRCLEdBQUMsT0FBTzJSLE1BQVA7QUFBZ0I7O0FBRW5ULFNBQVNvakIsUUFBVCxHQUFvQjtBQUFFQSxhQUFXcnZCLE9BQU9zdkIsTUFBUCxJQUFpQixVQUFVcmpCLE1BQVYsRUFBa0I7QUFBRSxTQUFLLElBQUlyUyxJQUFJLENBQWIsRUFBZ0JBLElBQUlDLFVBQVVDLE1BQTlCLEVBQXNDRixHQUF0QyxFQUEyQztBQUFFLFVBQUl1RixTQUFTdEYsVUFBVUQsQ0FBVixDQUFiLENBQTJCLEtBQUssSUFBSVUsR0FBVCxJQUFnQjZFLE1BQWhCLEVBQXdCO0FBQUUsWUFBSWEsT0FBTzRCLFNBQVAsQ0FBaUJuSSxjQUFqQixDQUFnQ2MsSUFBaEMsQ0FBcUM0RSxNQUFyQyxFQUE2QzdFLEdBQTdDLENBQUosRUFBdUQ7QUFBRTJSLGlCQUFPM1IsR0FBUCxJQUFjNkUsT0FBTzdFLEdBQVAsQ0FBZDtBQUE0QjtBQUFFO0FBQUUsS0FBQyxPQUFPMlIsTUFBUDtBQUFnQixHQUE1UCxDQUE4UCxPQUFPb2pCLFNBQVNoMUIsS0FBVCxDQUFlLElBQWYsRUFBcUJSLFNBQXJCLENBQVA7QUFBeUM7O0FBRTdULFNBQVN3d0IsY0FBVCxDQUF3QkMsUUFBeEIsRUFBa0NDLFVBQWxDLEVBQThDO0FBQUVELFdBQVMxb0IsU0FBVCxHQUFxQjVCLE9BQU93cUIsTUFBUCxDQUFjRCxXQUFXM29CLFNBQXpCLENBQXJCLENBQTBEMG9CLFNBQVMxb0IsU0FBVCxDQUFtQkksV0FBbkIsR0FBaUNzb0IsUUFBakM7QUFBNUQsWUFBdUdBLFFBQXZHLEVBQTRIQyxVQUE1SDtBQUF5STs7QUFFdkwsU0FBU2dGLHNCQUFULENBQWdDQyxJQUFoQyxFQUFzQztBQUFFLE1BQUlBLFNBQVMsS0FBSyxDQUFsQixFQUFxQjtBQUFFLFVBQU0sSUFBSUMsY0FBSixDQUFtQiwyREFBbkIsQ0FBTjtBQUF3RixHQUFDLE9BQU9ELElBQVA7QUFBYzs7QUFFdEssSUFBSUUsU0FBUzF2QixPQUFPMHZCLE1BQVAsSUFBaUIsVUFBVTEyQixHQUFWLEVBQWU7QUFDM0MsU0FBT2dILE9BQU9DLElBQVAsQ0FBWWpILEdBQVosRUFBaUJxRixHQUFqQixDQUFxQixVQUFVb21CLENBQVYsRUFBYTtBQUN2QyxXQUFPenJCLElBQUl5ckIsQ0FBSixDQUFQO0FBQ0QsR0FGTSxDQUFQO0FBR0QsQ0FKRDs7QUFNQSxJQUFJNW5CLFlBQVl2RixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsR0FBd0M7QUFDdEQ7Ozs7Ozs7QUFPQW9PLGFBQVdpcEIsV0FBV3AwQixPQUFYLENBQW1Cc08sR0FSd0I7O0FBVXREOzs7Ozs7QUFNQXBNLFlBQVVreUIsV0FBV3AwQixPQUFYLENBQW1CbVIsSUFoQnlCOztBQWtCdEQ7Ozs7O0FBS0E4YixVQUFRbUgsV0FBV3AwQixPQUFYLENBQW1CdUMsSUF2QjJCOztBQXlCdEQ7Ozs7O0FBS0FpZCxTQUFPNFUsV0FBV3AwQixPQUFYLENBQW1CdUMsSUE5QjRCOztBQWdDdEQ7Ozs7O0FBS0E2dUIsUUFBTWdELFdBQVdwMEIsT0FBWCxDQUFtQnVDLElBckM2Qjs7QUF1Q3REOzs7Ozs7Ozs7O0FBVUEyeUIsZ0JBQWNkLFdBQVdwMEIsT0FBWCxDQUFtQjNCO0FBakRxQixDQUF4QyxHQWtEWixFQWxESixDQWtETztBQUNQLElBQUlvRSxlQUFlO0FBQ2pCMEksYUFBVyxLQURNO0FBRWpCK3BCLGdCQUFjLFNBQVNBLFlBQVQsQ0FBc0JucUIsS0FBdEIsRUFBNkI7QUFDekMsV0FBT0EsS0FBUDtBQUNEO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7OztBQUxpQixDQUFuQjs7QUFzQkEsSUFBSXlqQjtBQUNKO0FBQ0EsVUFBVXdCLGdCQUFWLEVBQTRCO0FBQzFCSixpQkFBZXBCLGVBQWYsRUFBZ0N3QixnQkFBaEM7O0FBRUEsV0FBU3hCLGVBQVQsQ0FBeUI5dEIsS0FBekIsRUFBZ0MwTyxPQUFoQyxFQUF5QztBQUN2QyxRQUFJNmdCLEtBQUo7O0FBRUFBLFlBQVFELGlCQUFpQmx3QixJQUFqQixDQUFzQixJQUF0QixFQUE0QlksS0FBNUIsRUFBbUMwTyxPQUFuQyxLQUErQyxJQUF2RDs7QUFFQSxRQUFJK2xCLGVBQWVsRixNQUFNa0YsWUFBTixDQUFtQi9tQixJQUFuQixDQUF3QjBtQix1QkFBdUJBLHVCQUF1QjdFLEtBQXZCLENBQXZCLENBQXhCLENBQW5CLENBTHVDLENBSzREOzs7QUFHbkdBLFVBQU12bUIsS0FBTixHQUFjO0FBQ1p5ckIsb0JBQWNBLFlBREY7QUFFWkMsbUJBQWE7QUFGRCxLQUFkO0FBSUEsV0FBT25GLEtBQVA7QUFDRDs7QUFFRCxNQUFJUyxTQUFTbEMsZ0JBQWdCcm5CLFNBQTdCOztBQUVBdXBCLFNBQU9qd0IsZUFBUCxHQUF5QixTQUFTQSxlQUFULEdBQTJCO0FBQ2xELFdBQU87QUFDTDB2Qix1QkFBaUI7QUFDZkMsb0JBQVksQ0FBQyxLQUFLaUY7QUFESDtBQURaLEtBQVA7QUFLRCxHQU5EOztBQVFBM0UsU0FBTzluQixpQkFBUCxHQUEyQixTQUFTQSxpQkFBVCxHQUE2QjtBQUN0RCxTQUFLeXNCLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxTQUFLQyxPQUFMLEdBQWUsSUFBZjtBQUNELEdBSEQ7O0FBS0E1RSxTQUFPaHZCLG9CQUFQLEdBQThCLFNBQVNBLG9CQUFULEdBQWdDO0FBQzVELFNBQUs0ekIsT0FBTCxHQUFlLEtBQWY7QUFDRCxHQUZEOztBQUlBOUcsa0JBQWdCbUMsd0JBQWhCLEdBQTJDLFNBQVNBLHdCQUFULENBQWtDbnZCLFNBQWxDLEVBQTZDb3ZCLElBQTdDLEVBQW1EO0FBQzVGLFFBQUkyRSxtQkFBbUIzRSxLQUFLMXVCLFFBQTVCO0FBQUEsUUFDSWl6QixlQUFldkUsS0FBS3VFLFlBRHhCO0FBQUEsUUFFSUMsY0FBY3hFLEtBQUt3RSxXQUZ2QjtBQUdBLFdBQU87QUFDTGx6QixnQkFBVWt6QixjQUFjLENBQUMsR0FBR1QsY0FBY2Esc0JBQWxCLEVBQTBDaDBCLFNBQTFDLEVBQXFEMnpCLFlBQXJELENBQWQsR0FBbUYsQ0FBQyxHQUFHUixjQUFjYyxtQkFBbEIsRUFBdUNqMEIsU0FBdkMsRUFBa0QrekIsZ0JBQWxELEVBQW9FSixZQUFwRSxDQUR4RjtBQUVMQyxtQkFBYTtBQUZSLEtBQVA7QUFJRCxHQVJEOztBQVVBMUUsU0FBT3lFLFlBQVAsR0FBc0IsU0FBU0EsWUFBVCxDQUFzQnBxQixLQUF0QixFQUE2Qm9HLElBQTdCLEVBQW1DO0FBQ3ZELFFBQUl1a0Isc0JBQXNCLENBQUMsR0FBR2YsY0FBY2dCLGVBQWxCLEVBQW1DLEtBQUtqMUIsS0FBTCxDQUFXd0IsUUFBOUMsQ0FBMUI7QUFDQSxRQUFJNkksTUFBTWxMLEdBQU4sSUFBYTYxQixtQkFBakIsRUFBc0M7O0FBRXRDLFFBQUkzcUIsTUFBTXJLLEtBQU4sQ0FBWXF4QixRQUFoQixFQUEwQjtBQUN4QmhuQixZQUFNckssS0FBTixDQUFZcXhCLFFBQVosQ0FBcUI1Z0IsSUFBckI7QUFDRDs7QUFFRCxRQUFJLEtBQUtta0IsT0FBVCxFQUFrQjtBQUNoQixXQUFLdFYsUUFBTCxDQUFjLFVBQVV0VyxLQUFWLEVBQWlCO0FBQzdCLFlBQUl4SCxXQUFXMHlCLFNBQVMsRUFBVCxFQUFhbHJCLE1BQU14SCxRQUFuQixDQUFmOztBQUVBLGVBQU9BLFNBQVM2SSxNQUFNbEwsR0FBZixDQUFQO0FBQ0EsZUFBTztBQUNMcUMsb0JBQVVBO0FBREwsU0FBUDtBQUdELE9BUEQ7QUFRRDtBQUNGLEdBbEJEOztBQW9CQXd1QixTQUFPM3VCLE1BQVAsR0FBZ0IsU0FBU0EsTUFBVCxHQUFrQjtBQUNoQyxRQUFJMHdCLGNBQWMsS0FBSy94QixLQUF2QjtBQUFBLFFBQ0l5QixZQUFZc3dCLFlBQVl0bkIsU0FENUI7QUFBQSxRQUVJK3BCLGVBQWV6QyxZQUFZeUMsWUFGL0I7QUFBQSxRQUdJeDBCLFFBQVErdUIsOEJBQThCZ0QsV0FBOUIsRUFBMkMsQ0FBQyxXQUFELEVBQWMsY0FBZCxDQUEzQyxDQUhaOztBQUtBLFFBQUl2d0IsV0FBVyt5QixPQUFPLEtBQUt2ckIsS0FBTCxDQUFXeEgsUUFBbEIsRUFBNEIwQixHQUE1QixDQUFnQ3N4QixZQUFoQyxDQUFmO0FBQ0EsV0FBT3gwQixNQUFNdXNCLE1BQWI7QUFDQSxXQUFPdnNCLE1BQU04ZSxLQUFiO0FBQ0EsV0FBTzllLE1BQU0wd0IsSUFBYjs7QUFFQSxRQUFJanZCLGNBQWMsSUFBbEIsRUFBd0I7QUFDdEIsYUFBT0QsUUFBUDtBQUNEOztBQUVELFdBQU8rc0IsT0FBT2p2QixPQUFQLENBQWVnWSxhQUFmLENBQTZCN1YsU0FBN0IsRUFBd0N6QixLQUF4QyxFQUErQ3dCLFFBQS9DLENBQVA7QUFDRCxHQWhCRDs7QUFrQkEsU0FBT3NzQixlQUFQO0FBQ0QsQ0F0RkQsQ0FzRkVTLE9BQU9qdkIsT0FBUCxDQUFlbUMsU0F0RmpCLENBRkE7O0FBMEZBcXNCLGdCQUFnQjlyQixpQkFBaEIsR0FBb0M7QUFDbEN5dEIsbUJBQWlCaUUsV0FBV3AwQixPQUFYLENBQW1CNUMsTUFBbkIsQ0FBMEJ1MUI7QUFEVCxDQUFwQztBQUdBbkUsZ0JBQWdCcHNCLFNBQWhCLEdBQTRCdkYsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLEdBQXdDcUYsU0FBeEMsR0FBb0QsRUFBaEY7QUFDQW9zQixnQkFBZ0IvckIsWUFBaEIsR0FBK0JBLFlBQS9COztBQUVBLElBQUlzd0IsV0FBVyxDQUFDLEdBQUc1RCx1QkFBdUI2RCxRQUEzQixFQUFxQ3hFLGVBQXJDLENBQWY7O0FBRUFoeEIsUUFBUXdDLE9BQVIsR0FBa0IreUIsUUFBbEI7QUFDQXgxQixPQUFPQyxPQUFQLEdBQWlCQSxRQUFRLFNBQVIsQ0FBakIsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6TUE7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBRVFrTCxPLEdBQVlySyxVLENBQVpxSyxPO0lBQ0FrUCxRLEdBQWF6WixTLENBQWJ5WixROztBQUNSLElBQU0zTCxRQUFRSCxrQkFBUUcsS0FBdEI7O0FBRUE7Ozs7SUFJcUIycEIsUzs7O0FBNEJqQix1QkFBWWwxQixLQUFaLEVBQW1CO0FBQUE7O0FBQUEscURBQ2Ysc0JBQU1BLEtBQU4sQ0FEZTs7QUFHZmdJLHVCQUFjLENBQUUsWUFBRixFQUFnQixpQkFBaEIsRUFBbUMsa0JBQW5DLEVBQXVELFVBQXZELENBQWQ7QUFIZTtBQUlsQjs7d0JBRURtdEIsUSxxQkFBU2xZLEcsRUFBSztBQUNWLGFBQUttWSxLQUFMLEdBQWFuWSxHQUFiO0FBQ0gsSzs7d0JBRURvWSxPLHNCQUFVO0FBQUEscUJBQ2lCLEtBQUtyMUIsS0FEdEI7QUFBQSxZQUNFOEksSUFERixVQUNFQSxJQURGO0FBQUEsWUFDUXpHLElBRFIsVUFDUUEsSUFEUjtBQUFBLFlBRUVvbEIsUUFGRixHQUVlcGxCLEtBQUsyRyxLQUZwQixDQUVFeWUsUUFGRjs7O0FBSU4sZUFBT0EsU0FBU3ppQixPQUFULENBQWlCOEQsSUFBakIsSUFBeUIsQ0FBQyxDQUFqQztBQUNILEs7O3dCQUVEd3NCLGEsNEJBQWdCO0FBQUEsWUFDTjFKLFVBRE0sR0FDUyxLQUFLNXJCLEtBQUwsQ0FBV3FDLElBQVgsQ0FBZ0JyQyxLQUR6QixDQUNONHJCLFVBRE07O0FBRVosWUFBSSxPQUFPQSxVQUFQLEtBQXNCLFVBQTFCLEVBQXNDO0FBQ2xDQSx5QkFBYUEsV0FBVyxLQUFLNXJCLEtBQWhCLENBQWI7QUFDSDtBQUNELGVBQU80ckIsVUFBUDtBQUNILEs7O3dCQUVEekMsVSx1QkFBVzFKLEksRUFBTTJKLFcsRUFBYWpvQixDLEVBQUc7QUFBQSxzQkFDTixLQUFLbkIsS0FEQztBQUFBLFlBQ3JCOEksSUFEcUIsV0FDckJBLElBRHFCO0FBQUEsWUFDZnpHLElBRGUsV0FDZkEsSUFEZTs7QUFFN0JBLGFBQUs4bUIsVUFBTCxDQUFnQnJnQixJQUFoQixFQUFzQjJXLElBQXRCLEVBQTRCMkosV0FBNUIsRUFBeUNqb0IsQ0FBekM7O0FBRUEsWUFBTXlxQixhQUFhLEtBQUtBLFVBQXhCO0FBQ0FBLG1CQUFXMkosZUFBWCxJQUE4QjNKLFdBQVcySixlQUFYLENBQTJCOVYsSUFBM0IsRUFBaUMySixXQUFqQyxFQUE4Q2pvQixDQUE5QyxDQUE5QjtBQUNILEs7O3dCQUVEcTBCLGUsOEJBQWtCO0FBQUEsc0JBQzRCLEtBQUt4MUIsS0FEakM7QUFBQSxZQUNOcUMsSUFETSxXQUNOQSxJQURNO0FBQUEsWUFDQWlJLEtBREEsV0FDQUEsS0FEQTtBQUFBLFlBQ09zRSxLQURQLFdBQ09BLEtBRFA7QUFBQSxZQUNjNm1CLFNBRGQsV0FDY0EsU0FEZDtBQUFBLDBCQUV3RXB6QixLQUFLckMsS0FGN0U7QUFBQSxZQUVVMDFCLGtCQUZWLGVBRU5oSyxjQUZNO0FBQUEsWUFFMENpSyxjQUYxQyxlQUU4QmhLLFVBRjlCO0FBQUEsWUFFMERqa0IsU0FGMUQsZUFFMERBLFNBRjFEOztBQUdkLFlBQU1pa0IsYUFBYS9jLFNBQVMrbUIsY0FBNUI7QUFDQSxZQUFNakssaUJBQWlCLGVBQWUsS0FBSzFyQixLQUFwQixHQUE0QnkxQixTQUE1QixHQUF3Q0Msa0JBQS9EO0FBQ0EsWUFBTXZ0QixXQUFXLDJCQUFZLElBQVosQ0FBakI7QUFDQSxZQUFNRSxXQUFXRixTQUFTRyxVQUExQjtBQUNBLGFBQUtzdEIsU0FBTCxHQUFpQixLQUFLUixLQUFMLENBQVdwUyxXQUFYLEdBQXlCNlMsT0FBekIsQ0FBaUM3UyxXQUFqQyxHQUErQ2xDLGNBQS9DLEVBQWpCO0FBQ0F6ZSxhQUFLdWxCLFVBQUwsQ0FBZ0I5b0IsSUFBaEIsQ0FBcUIsS0FBSzgyQixTQUExQjs7QUFFQSxZQUFJbEssY0FBSixFQUFvQjtBQUNoQixnQkFBTWpILGFBQWEvYyxjQUFjLEtBQWQsSUFBdUI0QyxVQUFVLENBQWpDLEdBQXFDbkMsUUFBckMsR0FBZ0RFLFFBQW5FOztBQUVBLGdCQUFJb2MsV0FBV3pMLFdBQVgsR0FBeUIsS0FBSzRjLFNBQUwsQ0FBZTVjLFdBQTVDLEVBQXlEO0FBQ3JEOUIseUJBQVMsS0FBSzBlLFNBQWQsRUFBeUIsT0FBekIsRUFBcUNuUixXQUFXekwsV0FBaEQ7QUFDSDtBQUNKO0FBQ0QsWUFBSTJTLGVBQWUsU0FBZixJQUE0QixFQUFFamtCLGNBQWMsS0FBZCxJQUF1QjRDLFVBQVUsQ0FBbkMsQ0FBaEMsRUFBdUU7QUFDbkU0TSxxQkFBUyxLQUFLMGUsU0FBZCxFQUF5QixRQUF6QixFQUFzQ3Z0QixTQUFTb0IsWUFBL0M7QUFDQXlOLHFCQUFTLEtBQUswZSxTQUFkLEVBQXlCLFlBQXpCLEVBQXVDLFFBQXZDO0FBQ0g7QUFDRDs7QUFFQSxZQUFNaEssYUFBYSxLQUFLQSxVQUF4QjtBQUNBQSxtQkFBVzdMLE1BQVgsSUFBcUI2TCxXQUFXN0wsTUFBWCxFQUFyQjtBQUNILEs7O3dCQUVEK1YsZ0IsK0JBQW1CO0FBQUEsWUFDUHp6QixJQURPLEdBQ0UsS0FBS3JDLEtBRFAsQ0FDUHFDLElBRE87O0FBRWYsWUFBTXVsQixhQUFhdmxCLEtBQUt1bEIsVUFBeEI7QUFDQSxZQUFNNWIsUUFBUTRiLFdBQVc1aUIsT0FBWCxDQUFtQixLQUFLNHdCLFNBQXhCLENBQWQ7QUFDQTVwQixnQkFBUSxDQUFDLENBQVQsSUFBYzRiLFdBQVcxWSxNQUFYLENBQWtCbEQsS0FBbEIsRUFBeUIsQ0FBekIsQ0FBZDs7QUFFQSxZQUFNNGYsYUFBYSxLQUFLQSxVQUF4QjtBQUNBQSxtQkFBVzNMLE9BQVgsSUFBc0IyTCxXQUFXM0wsT0FBWCxFQUF0QjtBQUNILEs7O3dCQUVEOFYsVSx1QkFBV0MsVSxFQUFZeDBCLFEsRUFBVXVHLE0sRUFBUTtBQUFBLHNCQUNXLEtBQUsvSCxLQURoQjtBQUFBLFlBQzdCOEksSUFENkIsV0FDN0JBLElBRDZCO0FBQUEsWUFDdkJ6RyxJQUR1QixXQUN2QkEsSUFEdUI7QUFBQSxZQUNqQmlJLEtBRGlCLFdBQ2pCQSxLQURpQjtBQUFBLFlBQ1ZnSSxLQURVLFdBQ1ZBLEtBRFU7QUFBQSxZQUNIMU0sU0FERyxXQUNIQSxTQURHO0FBQUEsWUFFN0IzRixNQUY2QixHQUVsQm9DLEtBQUtyQyxLQUZhLENBRTdCQyxNQUY2Qjs7QUFHckMsWUFBTWcyQixVQUFVRCxhQUFhN2tCLHdCQUFiLEdBQThCbEosY0FBOUM7QUFDQSxZQUFNd1gsT0FBTyxLQUFLNFYsT0FBTCxFQUFiOztBQUVBLFlBQU1hLFlBQVk7QUFDZCw2QkFBaUIsSUFESDtBQUVkLDZCQUFpQnpXLElBRkg7QUFHZDNXLHNCQUhjO0FBSWR6RyxzQkFKYztBQUtkaUksd0JBTGM7QUFNZDVFLGtCQUFNO0FBTlEsU0FBbEI7QUFRQSxZQUFJK1osSUFBSixFQUFVO0FBQUE7O0FBQ055VyxzQkFBVXR3QixTQUFWLEdBQXNCLHlDQUNkM0YsTUFEYyxlQUNHLElBREgsTUFFakIyRixTQUZpQixJQUVMLENBQUMsQ0FBQ0EsU0FGRyxPQUF0QjtBQUlILFNBTEQsTUFLTztBQUNIc3dCLHNCQUFVdHdCLFNBQVYsR0FBc0JBLFNBQXRCO0FBQ0g7O0FBRUQsZUFDSTtBQUFDLG1CQUFEO0FBQUEseUJBQWFzd0IsU0FBYixFQUE0Qm51QixNQUE1QjtBQUNJO0FBQUE7QUFBQSxrQkFBTSxXQUFjOUgsTUFBZCxtQkFBTjtBQUE2Q3FTO0FBQTdDLGFBREo7QUFFSzlRO0FBRkwsU0FESjtBQU1ILEs7O3dCQUVEMjBCLFcsd0JBQVlDLE8sRUFBU2hOLFcsRUFBYWlOLGEsRUFBZTcwQixRLEVBQVU7QUFBQTs7QUFBQSxzQkFDbkIsS0FBS3hCLEtBRGM7QUFBQSxZQUMvQ3FDLElBRCtDLFdBQy9DQSxJQUQrQztBQUFBLFlBQ3pDaUksS0FEeUMsV0FDekNBLEtBRHlDO0FBQUEsWUFDbEMwckIsVUFEa0MsV0FDbENBLFVBRGtDO0FBQUEsWUFFL0N0dUIsU0FGK0MsR0FFakNyRixLQUFLckMsS0FGNEIsQ0FFL0MwSCxTQUYrQzs7QUFHdkQsYUFBS2trQixVQUFMLEdBQWtCLEtBQUswSixhQUFMLEVBQWxCO0FBQ0EsWUFBTTdWLE9BQU8sS0FBSzRWLE9BQUwsRUFBYjs7QUFFQSxZQUFJM3RCLGNBQWMsS0FBZCxJQUF1QjRDLFVBQVUsQ0FBakMsSUFBc0MwckIsVUFBMUMsRUFBc0Q7QUFDbERLLDBCQUFjdmxCLE1BQWQsR0FBdUI7QUFBQSx1QkFBTSwyQkFBWSxNQUFaLENBQU47QUFBQSxhQUF2QjtBQUNIOztBQUVELGVBQ0k7QUFBQyxpQkFBRDtBQUFBLHVCQUFPLEtBQUssS0FBS3FrQjtBQUFqQixlQUNRa0IsYUFEUixFQUVRLEtBQUt6SyxVQUZiO0FBR0ksK0JBQWUsS0FIbkI7QUFJSSx5QkFBU3dLLE9BSmI7QUFLSSw2QkFBYWhOLFdBTGpCO0FBTUkseUJBQVMzSixJQU5iO0FBT0ksaUNBQWlCLEtBQUswSixVQVAxQjtBQVFJLHdCQUFRLEtBQUtxTSxlQVJqQjtBQVNJLHlCQUFTLEtBQUtNLGdCQVRsQjtBQVVLdDBCO0FBVkwsU0FESjtBQWNILEs7O3dCQUVESCxNLHFCQUFTO0FBQUE7O0FBQUEsc0JBQ21HLEtBQUtyQixLQUR4RztBQUFBLFlBQ0dxQyxJQURILFdBQ0dBLElBREg7QUFBQSxZQUNTaUksS0FEVCxXQUNTQSxLQURUO0FBQUEsWUFDZ0Jnc0IsVUFEaEIsV0FDZ0JBLFVBRGhCO0FBQUEsWUFDd0NDLG1CQUR4QyxXQUM0QlAsVUFENUI7QUFBQSxZQUM2RHgwQixRQUQ3RCxXQUM2REEsUUFEN0Q7QUFBQSxZQUN1RTRuQixXQUR2RSxXQUN1RUEsV0FEdkU7QUFBQSxZQUNvRnhhLEtBRHBGLFdBQ29GQSxLQURwRjtBQUFBLFlBQzJGdk8sR0FEM0YsV0FDMkZBLEdBRDNGOztBQUVMLFlBQU0wSCxTQUFTbEssVUFBSTBJLFVBQUosQ0FBZTFCLE9BQU9DLElBQVAsQ0FBWW93QixVQUFVeHpCLFNBQXRCLENBQWYsRUFBaUQsS0FBSzFCLEtBQXRELENBQWY7QUFGSywyQkFHK0ZxQyxLQUFLckMsS0FIcEc7QUFBQSxZQUdHQyxNQUhILGdCQUdHQSxNQUhIO0FBQUEsWUFHV3FSLFVBSFgsZ0JBR1dBLFVBSFg7QUFBQSxZQUd1QjVKLFNBSHZCLGdCQUd1QkEsU0FIdkI7QUFBQSxZQUc4Q2l1QixjQUg5QyxnQkFHa0NoSyxVQUhsQztBQUFBLFlBRzJFNkssZUFIM0UsZ0JBRzhEcE4sV0FIOUQ7O0FBSUwsWUFBTXVDLGFBQWEvYyxTQUFTK21CLGNBQTVCO0FBQ0EsWUFBTWMsaUJBQWlCck4sZ0JBQWdCa04sYUFBYUUsZUFBYixHQUErQixPQUEvQyxDQUF2QjtBQUNBLFlBQU1sUCxjQUFjdm9CLE1BQU1DLE9BQU4sQ0FBY3dDLFFBQWQsSUFBMEJBLFNBQVMsQ0FBVCxDQUExQixHQUF3Q0EsUUFBNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBTXcwQixhQUFhMWtCLGNBQWNpbEIsbUJBQWpDO0FBQ0EsWUFBTUcsZ0JBQWdCVixjQUFjUyxtQkFBbUIsT0FBdkQ7QUFDQSxZQUFNaFgsT0FBTyxLQUFLNFYsT0FBTCxFQUFiOztBQUVBLFlBQU1nQixnQkFBZ0IsRUFBdEI7QUFDQSxZQUFJTSxtQkFBSjs7QUFFQSxZQUFJanZCLGNBQWMsS0FBZCxJQUF1QjRDLFVBQVUsQ0FBckMsRUFBd0M7QUFBQTs7QUFDcEMrckIsMEJBQWN6bkIsS0FBZCxHQUFzQixPQUF0QjtBQUNBeW5CLDBCQUFjblQsTUFBZCxHQUF1QixDQUFDLENBQUQsRUFBSSxDQUFKLENBQXZCOztBQUVBeVQseUJBQWE7QUFDVGp4QixzQkFBTSxZQURHO0FBRVRFLDJCQUFXLDJDQUNIM0YsTUFERyw0QkFDMkIsSUFEM0IsT0FFSEEsTUFGRyxhQUVZd2YsSUFGWjtBQUZGLGFBQWI7QUFPSCxTQVhELE1BV087QUFDSCxnQkFBSWtNLGVBQWUsU0FBbkIsRUFBOEI7QUFDMUIwSyw4QkFBY3ZsQixNQUFkLEdBQXVCLFlBQU07QUFDekIsMkJBQU8sMkJBQVl6TyxJQUFaLENBQVA7QUFDSCxpQkFGRDtBQUdBZzBCLDhCQUFjem5CLEtBQWQsR0FBc0IsT0FBdEI7O0FBRUF2TyxzQkFDSWcyQixjQUFjblQsTUFBZCxHQUF1QixDQUFDLENBQUMsQ0FBRixFQUFLLENBQUwsQ0FEM0IsR0FFSW1ULGNBQWNuVCxNQUFkLEdBQXVCLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FGM0I7QUFHSCxhQVRELE1BU087QUFDSCxvQkFBSXdULGFBQUosRUFBbUI7QUFDZkwsa0NBQWN2bEIsTUFBZCxHQUF1QixZQUFNO0FBQ3pCLCtCQUFPLDJCQUFZLE1BQVosQ0FBUDtBQUNILHFCQUZEO0FBR0g7QUFDRHVsQiw4QkFBY3puQixLQUFkLEdBQXNCLE9BQXRCOztBQUVBdk8sc0JBQ0lnMkIsY0FBY25ULE1BQWQsR0FBdUIsQ0FBQyxDQUFELEVBQUksQ0FBQyxDQUFMLENBRDNCLEdBRUltVCxjQUFjblQsTUFBZCxHQUF1QixDQUFDLENBQUMsQ0FBRixFQUFLLENBQUMsQ0FBTixDQUYzQjtBQUdIOztBQUVEeVQseUJBQWE7QUFDVGp4QixzQkFBTSxhQURHO0FBRVRFLDJCQUFjM0YsTUFBZDtBQUZTLGFBQWI7QUFJSDs7QUFFRCxZQUFNMjJCLFFBQVEsOEJBQUMsY0FBRCxFQUFVRCxVQUFWLENBQWQ7QUFDQSxZQUFNUCxVQUFVTSxnQkFBZ0JFLEtBQWhCLEdBQXdCLEtBQUtiLFVBQUwsQ0FBZ0JDLFVBQWhCLEVBQTRCWSxLQUE1QixFQUFtQzd1QixNQUFuQyxDQUF4QztBQUNBLFlBQU1xdEIsUUFBUSxLQUFLZSxXQUFMLENBQWlCQyxPQUFqQixFQUEwQkssY0FBMUIsRUFBMENKLGFBQTFDLEVBQXlEL08sV0FBekQsQ0FBZDtBQUNBLGVBQU9vUCxnQkFBZ0IsS0FBS1gsVUFBTCxDQUFnQkMsVUFBaEIsRUFBNEJaLEtBQTVCLEVBQW1DcnRCLE1BQW5DLENBQWhCLEdBQTZEcXRCLEtBQXBFO0FBQ0gsSzs7O0VBN05rQzN6QixnQixVQUM1QnlRLGEsR0FBZ0IsUyxTQUVoQnhRLFMsR0FBWTtBQUNmb0gsVUFBTW5ILG9CQUFVQyxNQUREO0FBRWZTLFVBQU1WLG9CQUFVakYsTUFGRDtBQUdmNE4sV0FBTzNJLG9CQUFVdUosTUFIRjtBQUlmb3JCLGdCQUFZMzBCLG9CQUFVRSxJQUpQO0FBS2Z4QixTQUFLc0Isb0JBQVVFLElBTEE7QUFNZm0wQixnQkFBWXIwQixvQkFBVUUsSUFOUDtBQU9mOzs7QUFHQXlRLFdBQU8zUSxvQkFBVThPLElBVkY7QUFXZjs7O0FBR0FqUCxjQUFVRyxvQkFBVThPLElBZEw7QUFlZjdLLGVBQVdqRSxvQkFBVUMsTUFmTjtBQWdCZnduQixpQkFBYXpuQixvQkFBVW9FLEtBQVYsQ0FBZ0IsQ0FBQyxPQUFELEVBQVUsT0FBVixDQUFoQixDQWhCRTtBQWlCZjZJLFdBQU9qTixvQkFBVW9FLEtBQVYsQ0FBZ0IsQ0FBQyxTQUFELEVBQVksUUFBWixDQUFoQixDQWpCUTtBQWtCZjB2QixlQUFXOXpCLG9CQUFVRTtBQWxCTixDLFNBcUJaRSxZLEdBQWU7QUFDbEJpMEIsZ0JBQVk7QUFETSxDO0FBeEJMZCxTO2tCQUFBQSxTOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2xCckI7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNenBCLE9BQU8sRUFBYjtJQUNRekQsTyxHQUFZckssVSxDQUFacUssTztJQUNBekIsVSxHQUFlMUksUyxDQUFmMEksVTtJQUVhc3dCLGE7OztBQTBCakIsMkJBQVk3MkIsS0FBWixFQUFtQjtBQUFBOztBQUFBLHFEQUNmLHNCQUFNQSxLQUFOLENBRGU7O0FBR2ZnSSx1QkFBYyxDQUFDLGlCQUFELEVBQW9CLGVBQXBCLEVBQXFDLGFBQXJDLENBQWQ7QUFIZTtBQUlsQjs7NEJBRUQyQixlLDRCQUFnQnhJLEMsRUFBRztBQUNmQSxVQUFFd0ksZUFBRjtBQUNILEs7OzRCQUVEbXRCLFcsd0JBQVkzMUIsQyxFQUFHO0FBQUEscUJBQzhCLEtBQUtuQixLQURuQztBQUFBLFlBQ0grMkIsU0FERyxVQUNIQSxTQURHO0FBQUEsWUFDUUMsT0FEUixVQUNRQSxPQURSO0FBQUEsWUFDaUJDLFFBRGpCLFVBQ2lCQSxRQURqQjs7QUFFWCxZQUFJLEVBQUVGLGNBQWMsT0FBZCxJQUF5QkMsT0FBM0IsQ0FBSixFQUF5QztBQUNyQ0MscUJBQVMsQ0FBQ0QsT0FBVixFQUFtQjcxQixDQUFuQjtBQUNIO0FBQ0osSzs7NEJBRUQ0SSxhLDBCQUFjNUksQyxFQUFHO0FBQ2IsWUFBSUEsRUFBRXVRLE9BQUYsS0FBY3ZULGNBQVF3VCxLQUF0QixJQUErQixDQUFDLEtBQUszUixLQUFMLENBQVdrM0IsYUFBL0MsRUFBOEQ7QUFDMUQsaUJBQUtKLFdBQUwsQ0FBaUIzMUIsQ0FBakI7QUFDSDs7QUFFRCxhQUFLbkIsS0FBTCxDQUFXaUssU0FBWCxJQUF3QixLQUFLakssS0FBTCxDQUFXaUssU0FBWCxDQUFxQjlJLENBQXJCLENBQXhCO0FBQ0gsSzs7NEJBRUR1SSxXLHdCQUFZdkksQyxFQUFHO0FBQ1gsYUFBSzIxQixXQUFMLENBQWlCMzFCLENBQWpCOztBQUVBLGFBQUtuQixLQUFMLENBQVc2SixPQUFYLElBQXNCLEtBQUs3SixLQUFMLENBQVc2SixPQUFYLENBQW1CMUksQ0FBbkIsQ0FBdEI7QUFDSCxLOzs0QkFFRGcyQixXLDBCQUFjO0FBQUEsc0JBQzZFLEtBQUtuM0IsS0FEbEY7QUFBQSxZQUNGcUMsSUFERSxXQUNGQSxJQURFO0FBQUEsWUFDSTIwQixPQURKLFdBQ0lBLE9BREo7QUFBQSxZQUNhSSxhQURiLFdBQ2FBLGFBRGI7QUFBQSxZQUM0Qnh1QixRQUQ1QixXQUM0QkEsUUFENUI7QUFBQSxZQUNzQ211QixTQUR0QyxXQUNzQ0EsU0FEdEM7QUFBQSxZQUNpREcsYUFEakQsV0FDaURBLGFBRGpEO0FBQUEsWUFDZ0VELFFBRGhFLFdBQ2dFQSxRQURoRTtBQUFBLFlBRUZsTCxrQkFGRSxHQUVxQjFwQixLQUFLckMsS0FGMUIsQ0FFRityQixrQkFGRTs7QUFHVixZQUFNc0wsUUFBUU4sY0FBYyxPQUFkLEdBQXdCTyxlQUF4QixHQUFnQzlnQixrQkFBOUM7O0FBRUEsWUFBTStnQixhQUFhO0FBQ2Z6c0Isc0JBQVUsSUFESztBQUVma3NCLDRCQUZlO0FBR2ZwdUIsc0JBQVVBLFlBQVlzdUI7QUFIUCxTQUFuQjtBQUtBLFlBQUlILGNBQWMsVUFBbEIsRUFBOEI7QUFDMUJRLHVCQUFXSCxhQUFYLEdBQTJCQSxhQUEzQjtBQUNIO0FBQ0QsWUFBSSxDQUFDckwsa0JBQUwsRUFBeUI7QUFDckJ3TCx1QkFBV04sUUFBWCxHQUFzQkEsUUFBdEI7QUFDQU0sdUJBQVcxdEIsT0FBWCxHQUFxQixLQUFLRixlQUExQjtBQUNIOztBQUVELGVBQ0ksOEJBQUMsS0FBRCxFQUFXNHRCLFVBQVgsQ0FESjtBQUdILEs7OzRCQUVEbDJCLE0scUJBQVM7QUFBQSxzQkFDZ0UsS0FBS3JCLEtBRHJFO0FBQUEsWUFDRzhJLElBREgsV0FDR0EsSUFESDtBQUFBLFlBQ1N6RyxJQURULFdBQ1NBLElBRFQ7QUFBQSxZQUNlMjBCLE9BRGYsV0FDZUEsT0FEZjtBQUFBLFlBQ3dCcHVCLFFBRHhCLFdBQ3dCQSxRQUR4QjtBQUFBLFlBQ2tDaUIsT0FEbEMsV0FDa0NBLE9BRGxDO0FBQUEsWUFDMkNtSSxNQUQzQyxXQUMyQ0EsTUFEM0M7QUFBQSxZQUNtRHhRLFFBRG5ELFdBQ21EQSxRQURuRDtBQUFBLDBCQUVrQ2EsS0FBS3JDLEtBRnZDO0FBQUEsWUFFR0MsTUFGSCxlQUVHQSxNQUZIO0FBQUEsWUFFVzhyQixrQkFGWCxlQUVXQSxrQkFGWDs7QUFHTCxZQUFNaGtCLFNBQVN4QixXQUFXMUIsT0FBT0MsSUFBUCxDQUFZK3hCLGNBQWNuMUIsU0FBMUIsQ0FBWCxFQUFpRCxLQUFLMUIsS0FBdEQsQ0FBZjs7QUFFQSxZQUFNaVM7QUFDRm5KLHNCQURFO0FBRUZ6RyxzQkFGRTtBQUdGdUcsOEJBSEU7QUFJRmxELGtCQUFNLE1BSko7QUFLRm1FLDRCQUxFO0FBTUZJLHVCQUFXLEtBQUtGO0FBTmQsV0FPQ2hDLE1BUEQsQ0FBTjtBQVNBLFlBQUlna0Isc0JBQXNCLENBQUNuakIsUUFBM0IsRUFBcUM7QUFDakNxSixxQkFBU3BJLE9BQVQsR0FBbUIsS0FBS0gsV0FBeEI7QUFDSDs7QUFFRCxlQUNJO0FBQUMsMEJBQUQ7QUFBQSx1QkFBTSxnQkFBY3N0QixPQUFwQixJQUFpQy9rQixRQUFqQztBQUNLLGlCQUFLa2xCLFdBQUwsRUFETDtBQUVJO0FBQUE7QUFBQSxrQkFBTSxXQUFjbDNCLE1BQWQsbUJBQU47QUFBNkN1QjtBQUE3QyxhQUZKO0FBR0t3USxxQkFBUztBQUFBO0FBQUEsa0JBQUssV0FBYy9SLE1BQWQscUJBQUw7QUFBOEMrUjtBQUE5QyxhQUFULEdBQXVFO0FBSDVFLFNBREo7QUFPSCxLOzs7RUF6R3NDdlEsZ0IsVUFDaENDLFMsR0FBWTtBQUNmb0gsVUFBTW5ILG9CQUFVQyxNQUREO0FBRWZTLFVBQU1WLG9CQUFVakYsTUFGRDtBQUdma00sY0FBVWpILG9CQUFVRSxJQUhMO0FBSWY4SSxrQkFBY2hKLG9CQUFVdUosTUFKVDtBQUtmOHJCLGFBQVNyMUIsb0JBQVVFLElBTEo7QUFNZnUxQixtQkFBZXoxQixvQkFBVUUsSUFOVjtBQU9mbzFCLGNBQVV0MUIsb0JBQVVoRSxJQVBMO0FBUWZvNUIsZUFBV3AxQixvQkFBVW9FLEtBQVYsQ0FBZ0IsQ0FBQyxVQUFELEVBQWEsT0FBYixDQUFoQixDQVJJO0FBU2ZteEIsbUJBQWV2MUIsb0JBQVVFLElBVFY7QUFVZm1RLFlBQVFyUSxvQkFBVThPLElBVkg7QUFXZmpQLGNBQVVHLG9CQUFVOE8sSUFYTDtBQVlmeEcsZUFBV3RJLG9CQUFVaEUsSUFaTjtBQWFma00sYUFBU2xJLG9CQUFVaEU7QUFiSixDLFNBZ0Jab0UsWSxHQUFlO0FBQ2xCNkcsY0FBVSxLQURRO0FBRWxCb3VCLGFBQVMsS0FGUztBQUdsQkksbUJBQWUsS0FIRztBQUlsQkwsZUFBVyxVQUpPO0FBS2xCRyxtQkFBZSxLQUxHO0FBTWxCRCxjQUFVeHJCO0FBTlEsQztBQWpCTG9yQixhO2tCQUFBQSxhOzs7Ozs7Ozs7Ozs7Ozs7O0FDWHJCOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7OztBQUVBLElBQU1wckIsT0FBTzlOLFdBQUs4TixJQUFsQjtBQUNBLFNBQVMrckIsU0FBVCxDQUFtQkMsYUFBbkIsRUFBa0M3dkIsS0FBbEMsRUFBeUM7QUFDckMsV0FBTzZ2QixjQUFjenlCLE9BQWQsQ0FBc0I0QyxLQUF0QixJQUErQixDQUFDLENBQXZDO0FBQ0g7QUFDRDs7OztJQUlNNE8sUTs7O0FBNEVGLHNCQUFZeFcsS0FBWixFQUFtQjBPLE9BQW5CLEVBQTRCO0FBQUE7O0FBQUEscURBQ3hCLG9CQUFNMU8sS0FBTixDQUR3Qjs7QUFHeEIsWUFBSWczQixnQkFBSjtBQUFBLFlBQWFJLHNCQUFiO0FBQ0EsWUFBSTFvQixRQUFRZ3BCLFNBQVosRUFBdUI7QUFDbkJOLDRCQUFnQixLQUFoQjtBQUNBSixzQkFBVVEsVUFBVTlvQixRQUFRK29CLGFBQWxCLEVBQWlDejNCLE1BQU00SCxLQUF2QyxDQUFWO0FBQ0gsU0FIRCxNQUdPO0FBQ0gsZ0JBQUksYUFBYTVILEtBQWpCLEVBQXdCO0FBQ3BCZzNCLDBCQUFVaDNCLE1BQU1nM0IsT0FBaEI7QUFDSCxhQUZELE1BRU87QUFDSEEsMEJBQVVoM0IsTUFBTTIzQixjQUFoQjtBQUNIOztBQUVELGdCQUFJLG1CQUFtQjMzQixLQUF2QixFQUE4QjtBQUMxQm8zQixnQ0FBZ0JwM0IsTUFBTW8zQixhQUF0QjtBQUNILGFBRkQsTUFFTztBQUNIQSxnQ0FBZ0JwM0IsTUFBTTQzQixvQkFBdEI7QUFDSDtBQUNKOztBQUVELGNBQUs1dUIsS0FBTCxHQUFhO0FBQ1RndUIsNEJBRFM7QUFFVEk7QUFGUyxTQUFiOztBQUtBLGNBQUt4dUIsUUFBTCxHQUFpQjVJLE1BQU00SSxRQUFOLElBQW1COEYsUUFBUWdwQixTQUFSLElBQXNCLGNBQWNocEIsT0FBcEMsSUFBZ0RBLFFBQVE5RixRQUE1RjtBQUNBLGNBQUtxdUIsUUFBTCxHQUFnQixNQUFLQSxRQUFMLENBQWN2cEIsSUFBZCxPQUFoQjtBQTNCd0I7QUE0QjNCOzt1QkFFRDdNLHlCLHNDQUEwQkMsUyxFQUFXKzJCLFcsRUFBYTtBQUM5QyxZQUFJQSxZQUFZSCxTQUFoQixFQUEyQjtBQUN2QixnQkFBSSxtQkFBbUJHLFdBQXZCLEVBQW9DO0FBQ2hDLHFCQUFLdlksUUFBTCxDQUFjO0FBQ1YwWCw2QkFBU1EsVUFBVUssWUFBWUosYUFBdEIsRUFBcUMzMkIsVUFBVThHLEtBQS9DO0FBREMsaUJBQWQ7QUFHSDtBQUNELGlCQUFLZ0IsUUFBTCxHQUFnQjlILFVBQVU4SCxRQUFWLElBQ1osY0FBY2l2QixXQUFkLElBQ0FBLFlBQVlqdkIsUUFGaEI7QUFJSCxTQVZELE1BVU87QUFDSCxnQkFBSSxhQUFhOUgsU0FBakIsRUFBNEI7QUFDeEIscUJBQUt3ZSxRQUFMLENBQWM7QUFDVjBYLDZCQUFTbDJCLFVBQVVrMkI7QUFEVCxpQkFBZDtBQUdIO0FBQ0QsZ0JBQUksbUJBQW1CbDJCLFNBQXZCLEVBQWtDO0FBQzlCLHFCQUFLd2UsUUFBTCxDQUFjO0FBQ1Y4WCxtQ0FBZXQyQixVQUFVczJCO0FBRGYsaUJBQWQ7QUFHSDtBQUNELGlCQUFLeHVCLFFBQUwsR0FBZ0I5SCxVQUFVOEgsUUFBMUI7QUFDSDtBQUNKLEs7O3VCQUNEc0YscUIsa0NBQXNCcE4sUyxFQUFXMHdCLFMsRUFBV3FHLFcsRUFBYTtBQUFBLFlBQzdDeHhCLFlBRDZDLEdBQzVCeEksU0FENEIsQ0FDN0N3SSxZQUQ2Qzs7QUFFckQsZUFBTyxDQUFDQSxhQUFhLEtBQUtyRyxLQUFsQixFQUF5QmMsU0FBekIsQ0FBRCxJQUNILENBQUN1RixhQUFhLEtBQUsyQyxLQUFsQixFQUF5QndvQixTQUF6QixDQURFLElBRUgsQ0FBQ25yQixhQUFhLEtBQUtxSSxPQUFsQixFQUEyQm1wQixXQUEzQixDQUZMO0FBR0gsSzs7dUJBRURaLFEscUJBQVM5MUIsQyxFQUFHO0FBQ1IsWUFBTTYxQixVQUFVNzFCLEVBQUUyUCxNQUFGLENBQVNrbUIsT0FBekI7QUFDQSxZQUFNcHZCLFFBQVEsS0FBSzVILEtBQUwsQ0FBVzRILEtBQXpCO0FBQ0EsWUFBSSxLQUFLZ0IsUUFBVCxFQUFtQjtBQUNmO0FBQ0g7QUFDRCxZQUFJLEtBQUs4RixPQUFMLENBQWFncEIsU0FBakIsRUFBNEI7QUFDeEIsaUJBQUtocEIsT0FBTCxDQUFhdW9CLFFBQWIsQ0FBc0JydkIsS0FBdEIsRUFBNkJ6RyxDQUE3QjtBQUNILFNBRkQsTUFFTztBQUNILGdCQUFJLEVBQUUsYUFBYSxLQUFLbkIsS0FBcEIsQ0FBSixFQUFnQztBQUM1QixxQkFBS3NmLFFBQUwsQ0FBYztBQUNWMFgsNkJBQVNBO0FBREMsaUJBQWQ7QUFHSDs7QUFFRCxnQkFBSSxFQUFFLG1CQUFtQixLQUFLaDNCLEtBQTFCLENBQUosRUFBc0M7QUFDbEMscUJBQUtzZixRQUFMLENBQWM7QUFDVjhYLG1DQUFlO0FBREwsaUJBQWQ7QUFHSDtBQUNELGlCQUFLcDNCLEtBQUwsQ0FBV2kzQixRQUFYLENBQW9CRCxPQUFwQixFQUE2QjcxQixDQUE3QjtBQUNIO0FBQ0osSzs7dUJBRURFLE0scUJBQVM7QUFBQTs7QUFDTDtBQURLLHFCQUdpQixLQUFLckIsS0FIdEI7QUFBQSxZQUVHeUQsRUFGSCxVQUVHQSxFQUZIO0FBQUEsWUFFT21DLFNBRlAsVUFFT0EsU0FGUDtBQUFBLFlBRWtCcEUsUUFGbEIsVUFFa0JBLFFBRmxCO0FBQUEsWUFFNEJ3SixLQUY1QixVQUU0QkEsS0FGNUI7QUFBQSxZQUVtQ3NILEtBRm5DLFVBRW1DQSxLQUZuQztBQUFBLFlBRTBDdkUsWUFGMUMsVUFFMENBLFlBRjFDO0FBQUEsWUFFd0RFLFlBRnhELFVBRXdEQSxZQUZ4RDtBQUFBLFlBRXNFNU4sR0FGdEUsVUFFc0VBLEdBRnRFO0FBQUEsWUFHRXkzQixVQUhGOztBQUlMLFlBQU1kLFVBQVUsQ0FBQyxDQUFDLEtBQUtodUIsS0FBTCxDQUFXZ3VCLE9BQTdCO0FBQ0EsWUFBTXB1QixXQUFXLEtBQUtBLFFBQXRCO0FBQ0EsWUFBTXd1QixnQkFBZ0IsQ0FBQyxDQUFDLEtBQUtwdUIsS0FBTCxDQUFXb3VCLGFBQW5DO0FBQ0EsWUFBTW4zQixTQUFTLEtBQUt5TyxPQUFMLENBQWF6TyxNQUFiLElBQXVCLEtBQUtELEtBQUwsQ0FBV0MsTUFBakQ7O0FBRUEsWUFBTThILFNBQVNsSyxVQUFJMEksVUFBSixDQUFlaVEsU0FBUzlVLFNBQXhCLEVBQW1DbzJCLFVBQW5DLENBQWY7QUFDQSxZQUFNQyxhQUFhbDZCLFVBQUkySSxhQUFKLENBQWtCdUIsTUFBbEIsRUFBMEIsT0FBMUIsQ0FBbkI7O0FBSUEsWUFBSWl3QixhQUFjLG9EQUNWbjZCLFVBQUkwSSxVQUFKLENBQWVpUSxTQUFTOVUsU0FBeEIsRUFBbUNvMkIsVUFBbkMsQ0FEVTtBQUVkLGdCQUFJcjBCLEVBRlU7QUFHZCxzQkFBVW1GLFFBSEk7QUFJZCxxQkFBU291QixPQUpLO0FBS2Qsa0JBQUssVUFMUztBQU1kLHNCQUFVLEtBQUtDLFFBTkQ7QUFPZCw0QkFBY0csZ0JBQWdCLE9BQWhCLEdBQTBCSixPQVAxQjtBQVFkLHVCQUFjLzJCLE1BQWQ7QUFSYyxXQUFsQjs7QUFXQTtBQUNBLFlBQUksQ0FBQzJJLFFBQUwsRUFBZTtBQUNYb3ZCLHlCQUFhLEtBQUtDLGVBQUwsQ0FBcUJELFVBQXJCLENBQWI7QUFDSDtBQUNELFlBQU10b0IsTUFBTSx5REFDSnpQLE1BREkseUJBQ3VCLElBRHZCLGNBRVAyRixTQUZPLElBRUssQ0FBQyxDQUFDQSxTQUZQLGNBR1JveEIsT0FIUSxHQUdSQSxPQUhRLGNBSVJwdUIsUUFKUSxHQUlSQSxRQUpRLGNBS1J3dUIsYUFMUSxHQUtSQSxhQUxRLGNBTVAsS0FBS2MsaUJBQUwsRUFOTyxJQU1vQixJQU5wQixlQUFaO0FBUUEsWUFBTUMsV0FBY2w0QixNQUFkLG1CQUFOO0FBQ0EsWUFBTXlGLE9BQU8weEIsZ0JBQWdCLGFBQWhCLEdBQWdDLFFBQTdDOztBQUVBLGVBQ0k7QUFBQTtBQUFBLHlCQUNRVyxVQURSO0FBRUksMkJBQVdyb0IsR0FGZjtBQUdJLHVCQUFPMUUsS0FIWDtBQUlJLDhCQUFjK0MsWUFKbEI7QUFLSSw4QkFBY0U7QUFMbEI7QUFPSTtBQUFBO0FBQUEsa0JBQU0sV0FBY2hPLE1BQWQsYUFBTjtBQUNJO0FBQUE7QUFBQSxzQkFBTSxXQUFjQSxNQUFkLG1CQUFOO0FBQ0ksa0RBQUMsY0FBRCxJQUFNLE1BQU15RixJQUFaLEVBQWtCLE1BQUssSUFBdkIsRUFBNEIsV0FBVzB4QixnQkFBZ0IsUUFBaEIsR0FBMkIsRUFBbEU7QUFESixpQkFESjtBQUlLWTtBQUpMLGFBUEo7QUFhSyxhQUFDMWxCLEtBQUQsRUFBUTlRLFFBQVIsRUFBa0IwQixHQUFsQixDQUFzQixVQUFDQyxJQUFELEVBQU8xRSxDQUFQO0FBQUEsdUJBQWMwRSxPQUFPO0FBQUE7QUFBQSxzQkFBTSxLQUFLMUUsQ0FBWCxFQUFjLFdBQVcwNUIsUUFBekI7QUFBb0NoMUI7QUFBcEMsaUJBQVAsR0FBMEQsSUFBeEU7QUFBQSxhQUF0QjtBQWJMLFNBREo7QUFnQkgsSzs7O0VBMU5rQmkxQixzQixVQUNaaDJCLFcsR0FBYyxVLFNBQ2RWLFMsR0FBWTtBQUNmekIsWUFBUTBCLG9CQUFVQyxNQURIO0FBRWZ2QixTQUFLc0Isb0JBQVVFLElBRkE7QUFHZjs7O0FBR0ErRCxlQUFXakUsb0JBQVVDLE1BTk47QUFPZjs7O0FBR0E2QixRQUFJOUIsb0JBQVVDLE1BVkM7QUFXZjs7O0FBR0FvSixXQUFPckosb0JBQVVqRixNQWRGO0FBZWY7OztBQUdBczZCLGFBQVNyMUIsb0JBQVVFLElBbEJKO0FBbUJmOzs7QUFHQTgxQixvQkFBZ0JoMkIsb0JBQVVFLElBdEJYO0FBdUJmOzs7QUFHQStHLGNBQVVqSCxvQkFBVUUsSUExQkw7QUEyQmY7OztBQUdBeVEsV0FBTzNRLG9CQUFVOE8sSUE5QkY7QUErQmY7OztBQUdBMm1CLG1CQUFlejFCLG9CQUFVRSxJQWxDVjtBQW1DZjs7O0FBR0ErMUIsMEJBQXNCajJCLG9CQUFVRSxJQXRDakI7QUF1Q2Y7Ozs7O0FBS0FvMUIsY0FBVXQxQixvQkFBVWhFLElBNUNMO0FBNkNmOzs7O0FBSUFvUSxrQkFBY3BNLG9CQUFVaEUsSUFqRFQ7QUFrRGY7Ozs7QUFJQXNRLGtCQUFjdE0sb0JBQVVoRTtBQXREVCxDLFNBeURab0UsWSxHQUFlO0FBQ2xCNDFCLG9CQUFnQixLQURFO0FBRWxCQywwQkFBc0IsS0FGSjtBQUdsQlgsY0FBVXhyQixJQUhRO0FBSWxCc0Msa0JBQWN0QyxJQUpJO0FBS2xCd0Msa0JBQWN4QyxJQUxJO0FBTWxCeEwsWUFBUTtBQU5VLEMsU0FTZjBQLFksR0FBZTtBQUNsQnNuQixjQUFVdDFCLG9CQUFVaEUsSUFERjtBQUVsQis1QixlQUFXLzFCLG9CQUFVRSxJQUZIO0FBR2xCNDFCLG1CQUFlOTFCLG9CQUFVa00sS0FIUDtBQUlsQmpGLGNBQVVqSCxvQkFBVUUsSUFKRjtBQUtsQjVCLFlBQVEwQixvQkFBVUM7QUFMQSxDO2tCQXlKWGpDLHlCQUFlc0MsTUFBZixDQUFzQnVVLFFBQXRCLEM7Ozs7Ozs7Ozs7OztBQzdPZjs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztJQUVRZ0gsUyxHQUFjN2YsVSxDQUFkNmYsUztBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0lBQ000YSxPOzs7QUFDRixxQkFBWXA0QixLQUFaLEVBQW1CO0FBQUE7O0FBQUEscURBQ2Ysc0JBQU1BLEtBQU4sQ0FEZTs7QUFFZixjQUFLZ0osS0FBTCxHQUFhLEVBQWI7QUFDQSxTQUFDLFlBQUQsRUFBZSxXQUFmLEVBQTRCakUsT0FBNUIsQ0FBb0MsZ0JBQVE7QUFDeEMsa0JBQUs1QixJQUFMLElBQWEsTUFBS0EsSUFBTCxFQUFXdUssSUFBWCxPQUFiO0FBQ0gsU0FGRDtBQUhlO0FBTWxCO0FBQ0Q7OztzQkFDQXVxQixlLDRCQUFnQkksSSxFQUFNO0FBQUEscUJBQ1UsS0FBS3I0QixLQURmO0FBQUEsWUFDVnM0QixPQURVLFVBQ1ZBLE9BRFU7QUFBQSxZQUNEdlEsTUFEQyxVQUNEQSxNQURDOztBQUVsQixlQUFPcGEsZ0JBQU0yQyxZQUFOLENBQW1CK25CLElBQW5CLEVBQXlCO0FBQzVCQyxxQkFBUzlhLFVBQVUsS0FBSythLFVBQWYsRUFBMkJELE9BQTNCLENBRG1CO0FBRTVCdlEsb0JBQVF2SyxVQUFVLEtBQUtnYixTQUFmLEVBQTBCelEsTUFBMUI7QUFGb0IsU0FBekIsQ0FBUDtBQUtILEs7QUFDRDs7O3NCQUNBbVEsaUIsZ0NBQW9CO0FBQUEsWUFDUmp2QixPQURRLEdBQ0ksS0FBS0QsS0FEVCxDQUNSQyxPQURROztBQUVoQixlQUFPLDBCQUFXO0FBQ2RBO0FBRGMsU0FBWCxDQUFQO0FBR0gsSztBQUNEOzs7c0JBQ0F3dkIsWSwyQkFBZTtBQUNYLGFBQUtuWixRQUFMLENBQWM7QUFDVnJXLHFCQUFTO0FBREMsU0FBZDtBQUdILEs7O3NCQUNEc3ZCLFUseUJBQWE7QUFDVCxhQUFLalosUUFBTCxDQUFjO0FBQ1ZyVyxxQkFBUztBQURDLFNBQWQ7QUFHSCxLOztzQkFDRHV2QixTLHdCQUFZO0FBQ1IsYUFBS2xaLFFBQUwsQ0FBYztBQUNWclcscUJBQVM7QUFEQyxTQUFkO0FBR0gsSzs7O0VBdkNpQnhILGdCOztBQUFoQjIyQixPO2tCQTBDU0EsTzs7Ozs7Ozs7Ozs7O0FDcERmOzs7O0FBQ0E7Ozs7OztBQUVBZCxnQkFBTTdnQixLQUFOLEdBQWNpaUIsb0JBQWQ7O2tCQUVlcEIsZTs7Ozs7Ozs7Ozs7Ozs7OztBQ0xmOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFFUTlaLFMsR0FBb0I3ZixVLENBQXBCNmYsUztJQUFXL1IsSSxHQUFTOU4sVSxDQUFUOE4sSTtBQUNuQjs7Ozs7SUFJTTZyQixLOzs7QUEyRUYsbUJBQVl0M0IsS0FBWixFQUFtQjBPLE9BQW5CLEVBQTRCO0FBQUE7O0FBQUEscURBQ3hCLG9CQUFNMU8sS0FBTixDQUR3Qjs7QUFHeEIsWUFBSWczQixnQkFBSjtBQUNBLFlBQUl0b0IsUUFBUWdwQixTQUFaLEVBQXVCO0FBQ25CVixzQkFBVXRvQixRQUFRK29CLGFBQVIsS0FBMEJ6M0IsTUFBTTRILEtBQTFDO0FBQ0gsU0FGRCxNQUVPLElBQUksYUFBYTVILEtBQWpCLEVBQXdCO0FBQzNCZzNCLHNCQUFVaDNCLE1BQU1nM0IsT0FBaEI7QUFDSCxTQUZNLE1BRUE7QUFDSEEsc0JBQVVoM0IsTUFBTTIzQixjQUFoQjtBQUNIOztBQUVELGNBQUszdUIsS0FBTCxHQUFhLEVBQUVndUIsZ0JBQUYsRUFBYjs7QUFFQSxjQUFLQyxRQUFMLEdBQWdCLE1BQUtBLFFBQUwsQ0FBY3ZwQixJQUFkLE9BQWhCO0FBQ0EsY0FBSzlFLFFBQUwsR0FBZ0I1SSxNQUFNNEksUUFBTixJQUFvQjhGLFFBQVFncEIsU0FBUixJQUFzQixjQUFjaHBCLE9BQXBDLElBQWdEQSxRQUFROUYsUUFBNUY7O0FBZndCO0FBaUIzQjs7b0JBRUQvSCx5QixzQ0FBMEJDLFMsRUFBVysyQixXLEVBQWE7QUFDOUMsWUFBSUEsWUFBWUgsU0FBaEIsRUFBMkI7QUFBQSxnQkFDZkQsYUFEZSxHQUNHSSxXQURILENBQ2ZKLGFBRGU7O0FBRXZCLGdCQUFJLG1CQUFtQkksV0FBdkIsRUFBb0M7QUFDaEMscUJBQUt2WSxRQUFMLENBQWM7QUFDVjBYLDZCQUFTUyxrQkFBa0IzMkIsVUFBVThHO0FBRDNCLGlCQUFkO0FBR0g7QUFDSixTQVBELE1BT08sSUFBSSxhQUFhOUcsU0FBakIsRUFBNEI7QUFDL0IsaUJBQUt3ZSxRQUFMLENBQWM7QUFDVjBYLHlCQUFTbDJCLFVBQVVrMkI7QUFEVCxhQUFkO0FBR0g7O0FBRUQsYUFBS3B1QixRQUFMLEdBQWdCOUgsVUFBVThILFFBQVYsSUFBd0JpdkIsWUFBWUgsU0FBWixJQUEwQixjQUFjRyxXQUF4QyxJQUF3REEsWUFBWWp2QixRQUE1Rzs7QUFFQTtBQUNBLFlBQUksS0FBS0EsUUFBVCxFQUFtQjtBQUNmO0FBQ0EsaUJBQUs2dkIsWUFBTDtBQUNIO0FBQ0osSzs7b0JBRUR2cUIscUIsa0NBQXNCcE4sUyxFQUFXMHdCLFMsRUFBV3FHLFcsRUFBYTtBQUFBLFlBQzdDeHhCLFlBRDZDLEdBQzVCeEksU0FENEIsQ0FDN0N3SSxZQUQ2Qzs7QUFFckQsZUFBTyxDQUFDQSxhQUFhLEtBQUtyRyxLQUFsQixFQUF5QmMsU0FBekIsQ0FBRCxJQUNILENBQUN1RixhQUFhLEtBQUsyQyxLQUFsQixFQUF5QndvQixTQUF6QixDQURFLElBRUgsQ0FBQ25yQixhQUFhLEtBQUt3eEIsV0FBbEIsRUFBK0JBLFdBQS9CLENBRkw7QUFHSCxLOztvQkFFRFosUSxxQkFBUzkxQixDLEVBQUc7QUFDUixZQUFNNjFCLFVBQVU3MUIsRUFBRTJQLE1BQUYsQ0FBU2ttQixPQUF6QjtBQUNBLFlBQU1wdkIsUUFBUSxLQUFLNUgsS0FBTCxDQUFXNEgsS0FBekI7O0FBRUEsWUFBSSxLQUFLOEcsT0FBTCxDQUFhZ3BCLFNBQWpCLEVBQTRCO0FBQ3hCLGlCQUFLaHBCLE9BQUwsQ0FBYXVvQixRQUFiLENBQXNCcnZCLEtBQXRCLEVBQTZCekcsQ0FBN0I7QUFDSCxTQUZELE1BRU8sSUFBSSxLQUFLNkgsS0FBTCxDQUFXZ3VCLE9BQVgsS0FBdUJBLE9BQTNCLEVBQW9DO0FBQ3ZDLGdCQUFJLEVBQUUsYUFBYSxLQUFLaDNCLEtBQXBCLENBQUosRUFBZ0M7QUFDNUIscUJBQUtzZixRQUFMLENBQWM7QUFDVjBYLDZCQUFTQTtBQURDLGlCQUFkO0FBR0g7QUFDRCxpQkFBS2gzQixLQUFMLENBQVdpM0IsUUFBWCxDQUFvQkQsT0FBcEIsRUFBNkI3MUIsQ0FBN0I7QUFDSDtBQUNKLEs7O29CQUVERSxNLHFCQUFTO0FBQUE7O0FBQ0w7QUFESyxxQkFHaUIsS0FBS3JCLEtBSHRCO0FBQUEsWUFFR3lELEVBRkgsVUFFR0EsRUFGSDtBQUFBLFlBRU9tQyxTQUZQLFVBRU9BLFNBRlA7QUFBQSxZQUVrQnBFLFFBRmxCLFVBRWtCQSxRQUZsQjtBQUFBLFlBRTRCd0osS0FGNUIsVUFFNEJBLEtBRjVCO0FBQUEsWUFFbUNzSCxLQUZuQyxVQUVtQ0EsS0FGbkM7QUFBQSxZQUUwQ3ZFLFlBRjFDLFVBRTBDQSxZQUYxQztBQUFBLFlBRXdERSxZQUZ4RCxVQUV3REEsWUFGeEQ7QUFBQSxZQUVzRW5ELFFBRnRFLFVBRXNFQSxRQUZ0RTtBQUFBLFlBRWdGekssR0FGaEYsVUFFZ0ZBLEdBRmhGO0FBQUEsWUFHRXkzQixVQUhGOztBQUlMLFlBQU1kLFVBQVUsQ0FBQyxDQUFDLEtBQUtodUIsS0FBTCxDQUFXZ3VCLE9BQTdCO0FBQ0EsWUFBTXB1QixXQUFXLEtBQUtBLFFBQXRCO0FBQ0EsWUFBTSt2QixXQUFXLEtBQUtqcUIsT0FBTCxDQUFhaXFCLFFBQTlCO0FBQ0EsWUFBTTE0QixTQUFTLEtBQUt5TyxPQUFMLENBQWF6TyxNQUFiLElBQXVCLEtBQUtELEtBQUwsQ0FBV0MsTUFBakQ7O0FBRUEsWUFBTThILFNBQVNsSyxVQUFJMEksVUFBSixDQUFlK3dCLE1BQU01MUIsU0FBckIsRUFBZ0NvMkIsVUFBaEMsQ0FBZjtBQUNBLFlBQU1DLGFBQWFsNkIsVUFBSTJJLGFBQUosQ0FBa0J1QixNQUFsQixFQUEwQixPQUExQixDQUFuQjs7QUFHQSxZQUFJNndCLFFBQVMsb0RBQ0wvNkIsVUFBSTBJLFVBQUosQ0FBZXd4QixVQUFmLEVBQTJCaHdCLE1BQTNCLENBREs7QUFFVCxnQkFBSXRFLEVBRks7QUFHVCxzQkFBVW1GLFFBSEQ7QUFJVCxxQkFBU291QixPQUpBO0FBS1Qsa0JBQUssT0FMSTtBQU1ULHNCQUFVLEtBQUtDLFFBTk47QUFPVCw0QkFBY0QsT0FQTDtBQVFULHVCQUFjLzJCLE1BQWQ7QUFSUyxXQUFiOztBQVdBO0FBQ0EsWUFBSSxDQUFDMkksUUFBTCxFQUFlO0FBQ1hnd0Isb0JBQVEsS0FBS1gsZUFBTCxDQUFxQlcsS0FBckIsQ0FBUjtBQUNIOztBQUVELFlBQU1scEIsTUFBTSx5REFDSnpQLE1BREksY0FDWSxJQURaLGNBRVIrMkIsT0FGUSxHQUVSQSxPQUZRLGNBR1JwdUIsUUFIUSxHQUdSQSxRQUhRLGNBSVAsS0FBS3N2QixpQkFBTCxFQUpPLElBSW9CLElBSnBCLGVBQVo7QUFNQSxZQUFNVyxXQUFXLDJEQUNUNTRCLE1BRFMsb0JBQ2EsSUFEYixlQUViNjRCLEtBRmEsR0FFTjlCLE9BRk0sZUFHYitCLE9BSGEsR0FHSixDQUFDL0IsT0FIRyxnQkFBakI7QUFLQSxZQUFNZ0MsYUFBYSwyREFDWC80QixNQURXLHNCQUNhLElBRGIsZUFFZDJGLFNBRmMsSUFFRixDQUFDLENBQUNBLFNBRkEsZUFHZm94QixPQUhlLEdBR2ZBLE9BSGUsZUFJZnB1QixRQUplLEdBSWZBLFFBSmUsZUFLZCxLQUFLc3ZCLGlCQUFMLEVBTGMsSUFLYSxJQUxiLGdCQUFuQjtBQU9BLFlBQU1lLGNBQWlCaDVCLE1BQWpCLGdCQUFOOztBQUVBLFlBQU1pNUIsWUFBWSxDQUFDUCxRQUFELEdBQ2I7QUFBQTtBQUFBLGNBQU0sV0FBV2pwQixHQUFqQjtBQUNHLG9EQUFNLFdBQVdtcEIsUUFBakIsR0FESDtBQUVJRDtBQUZKLFNBRGEsR0FLYjtBQUFBO0FBQUEsY0FBTSxXQUFjMzRCLE1BQWQsdUJBQU47QUFDSTI0QjtBQURKLFNBTEw7O0FBU0EsZUFDSTtBQUFBO0FBQUEseUJBQ1FiLFVBRFI7QUFFSSxzQkFBSyxPQUZUO0FBR0kscUJBQUsxM0IsTUFBTSxLQUFOLEdBQWMsS0FIdkI7QUFJSSx1QkFBTzJLLEtBSlg7QUFLSSwwQkFBVUYsUUFMZDtBQU1JLGdDQUFja3NCLE9BTmxCO0FBT0ksaUNBQWVwdUIsUUFQbkI7QUFRSSwyQkFBV293QixVQVJmO0FBU0ksOEJBQWNwd0IsV0FBV21GLFlBQVgsR0FBMEJ5UCxVQUFVLEtBQUsyYixlQUFmLEVBQWdDcHJCLFlBQWhDLENBVDVDO0FBVUksOEJBQWNuRixXQUFXcUYsWUFBWCxHQUEwQnVQLFVBQVUsS0FBSzRiLGVBQWYsRUFBZ0NuckIsWUFBaEM7QUFWNUM7QUFZS2lyQixxQkFaTDtBQWFLLGFBQUMxM0IsUUFBRCxFQUFXOFEsS0FBWCxFQUFrQnBQLEdBQWxCLENBQXNCLFVBQUNtMkIsQ0FBRCxFQUFJNTZCLENBQUo7QUFBQSx1QkFBVTQ2QixNQUFNcmUsU0FBTixHQUM3QjtBQUFBO0FBQUEsc0JBQU0sS0FBS3ZjLENBQVgsRUFBYyxXQUFXdzZCLFdBQXpCO0FBQXVDSTtBQUF2QyxpQkFENkIsR0FDc0IsSUFEaEM7QUFBQSxhQUF0QjtBQWJMLFNBREo7QUFrQkgsSzs7O0VBeE5lakIsc0IsVUFDVGgyQixXLEdBQWMsTyxTQUNkVixTLEdBQVk7QUFDZnpCLFlBQVEwQixvQkFBVUMsTUFESDtBQUVmdkIsU0FBS3NCLG9CQUFVRSxJQUZBO0FBR2Y7OztBQUdBK0QsZUFBV2pFLG9CQUFVQyxNQU5OO0FBT2Y7OztBQUdBNkIsUUFBSTlCLG9CQUFVQyxNQVZDO0FBV2Y7OztBQUdBb0osV0FBT3JKLG9CQUFVakYsTUFkRjtBQWVmOzs7QUFHQXM2QixhQUFTcjFCLG9CQUFVRSxJQWxCSjtBQW1CZjs7O0FBR0E4MUIsb0JBQWdCaDJCLG9CQUFVRSxJQXRCWDtBQXVCZjs7O0FBR0F5USxXQUFPM1Esb0JBQVU4TyxJQTFCRjtBQTJCZjs7Ozs7QUFLQXdtQixjQUFVdDFCLG9CQUFVaEUsSUFoQ0w7QUFpQ2Y7Ozs7QUFJQW9RLGtCQUFjcE0sb0JBQVVoRSxJQXJDVDtBQXNDZjs7OztBQUlBc1Esa0JBQWN0TSxvQkFBVWhFLElBMUNUO0FBMkNmOzs7QUFHQWlMLGNBQVVqSCxvQkFBVUUsSUE5Q0w7QUErQ2Y7OztBQUdBK0YsV0FBT2pHLG9CQUFVNk8sU0FBVixDQUFvQixDQUFDN08sb0JBQVVDLE1BQVgsRUFBbUJELG9CQUFVdUosTUFBN0IsRUFBcUN2SixvQkFBVUUsSUFBL0MsQ0FBcEIsQ0FsRFE7QUFtRGY7OztBQUdBMFgsVUFBTTVYLG9CQUFVQztBQXRERCxDLFNBeURaRyxZLEdBQWU7QUFDbEJrMUIsY0FBVXhyQixJQURRO0FBRWxCd0Msa0JBQWN4QyxJQUZJO0FBR2xCc0Msa0JBQWN0QyxJQUhJO0FBSWxCWCxjQUFVLENBSlE7QUFLbEI3SyxZQUFRO0FBTFUsQyxTQVFmMFAsWSxHQUFlO0FBQ2xCc25CLGNBQVV0MUIsb0JBQVVoRSxJQURGO0FBRWxCKzVCLGVBQVcvMUIsb0JBQVVFLElBRkg7QUFHbEI4MkIsY0FBVWgzQixvQkFBVUUsSUFIRjtBQUlsQjQxQixtQkFBZTkxQixvQkFBVTZPLFNBQVYsQ0FBb0IsQ0FBQzdPLG9CQUFVQyxNQUFYLEVBQW1CRCxvQkFBVXVKLE1BQTdCLEVBQXFDdkosb0JBQVVFLElBQS9DLENBQXBCLENBSkc7QUFLbEIrRyxjQUFVakgsb0JBQVVFO0FBTEYsQztrQkF3SlhsQyx5QkFBZXNDLE1BQWYsQ0FBc0JxMUIsS0FBdEIsQzs7Ozs7Ozs7Ozs7Ozs7O0FDdk9mOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTtJQUNxQnJSLEk7Ozs7Ozs7Ozs7Ozs0SkEyQ2pCdmMsVyxHQUFjLFlBQU07QUFBQSw4QkFDVSxNQUFLMUosS0FEZjtBQUFBLGdCQUNUMGxCLElBRFMsZUFDVEEsSUFEUztBQUFBLGdCQUNIL1csU0FERyxlQUNIQSxTQURHOztBQUVoQixrQkFBSzZXLE1BQUwsQ0FBWTdXLFNBQVosRUFBdUIrVyxLQUFLL1csU0FBTCxNQUFvQixNQUFwQixHQUE2QixLQUE3QixHQUFxQyxNQUE1RDtBQUNILFMsUUFFRDJxQixjLEdBQWlCLGFBQUs7QUFDbEJuNEIsY0FBRTJJLGNBQUY7QUFDQTNJLGNBQUV3SSxlQUFGOztBQUVBLGdCQUFJeEksRUFBRXVRLE9BQUYsS0FBY3ZULGNBQVFtZCxLQUExQixFQUFpQztBQUM3QixzQkFBSzVSLFdBQUw7QUFDSDtBQUNKLFMsUUFFRDhiLE0sR0FBUyxVQUFDN1csU0FBRCxFQUFZOFcsS0FBWixFQUFzQjtBQUMzQixnQkFBTUMsT0FBTyxFQUFiO0FBQ0FBLGlCQUFLL1csU0FBTCxJQUFrQjhXLEtBQWxCOztBQUVBLGtCQUFLemxCLEtBQUwsQ0FBV3dsQixNQUFYLENBQWtCN1csU0FBbEIsRUFBNkI4VyxLQUE3QixFQUFvQ0MsSUFBcEM7QUFDSCxTOzs7QUFsREQ7bUJBQ0E2VCxVLHlCQUFhO0FBQUEscUJBQ2lDLEtBQUt2NUIsS0FEdEM7QUFBQSxZQUNGQyxNQURFLFVBQ0ZBLE1BREU7QUFBQSxZQUNNeWxCLElBRE4sVUFDTUEsSUFETjtBQUFBLFlBQ1kvVyxTQURaLFVBQ1lBLFNBRFo7QUFBQSxZQUN1QnpPLE1BRHZCLFVBQ3VCQSxNQUR2QjtBQUFBLFlBRUxzNUIsVUFGSyxHQUVROVQsS0FBSy9XLFNBQUwsQ0FGUjtBQUFBLFlBR0x6TCxHQUhLLEdBR0M7QUFDRnFTLGtCQUFNLFlBREo7QUFFRkQsaUJBQUs7QUFGSCxTQUhEOzs7QUFRVCxZQUFNbWtCLFFBQVEsQ0FBQyxLQUFELEVBQVEsTUFBUixFQUFnQnYyQixHQUFoQixDQUFvQixxQkFBYTtBQUMzQyxtQkFDSTtBQUFBO0FBQUEsa0JBQUcsTUFBSyxjQUFSO0FBQ0kseUJBQUt3MkIsU0FEVDtBQUVJLCtCQUFXRixlQUFlRSxTQUFmLEdBQTJCLFNBQTNCLEdBQXVDLEVBRnREO0FBR0ksOENBQUMsY0FBRCxJQUFNLE1BQU14MkIsSUFBSXcyQixTQUFKLENBQVosRUFBNEIsTUFBSyxPQUFqQztBQUhKLGFBREo7QUFPSCxTQVJhLENBQWQ7O0FBVUEsZUFDSTtBQUFBO0FBQUEsY0FBTSxNQUFLLFFBQVg7QUFDSSwwQkFBUyxHQURiO0FBRUksOEJBQVl4NUIsT0FBT3M1QixVQUFQLENBRmhCO0FBR0ksMkJBQWN2NUIsTUFBZCxlQUhKO0FBSUkseUJBQVMsS0FBS3lKLFdBQUwsQ0FBaUJnRSxJQUFqQixDQUFzQixJQUF0QixDQUpiO0FBS0ksMkJBQVcsS0FBSzRyQixjQUxwQjtBQU1LRztBQU5MLFNBREo7QUFVSCxLOzttQkF1QkRwNEIsTSxxQkFBUztBQUNMLGVBQU8sS0FBS2s0QixVQUFMLEVBQVA7QUFDSCxLOzs7RUFsRTZCNXJCLGdCQUFNbE0sUyxVQUM3QkMsUyxHQUFZO0FBQ2Z6QixZQUFRMEIsb0JBQVVDLE1BREg7QUFFZmdFLGVBQVdqRSxvQkFBVUMsTUFGTjtBQUdmOGpCLFVBQU0vakIsb0JBQVVqRixNQUhEO0FBSWY4b0IsWUFBUTdqQixvQkFBVWhFLElBSkg7QUFLZmdSLGVBQVdoTixvQkFBVUMsTUFMTjtBQU1mMUIsWUFBUXlCLG9CQUFVakY7QUFOSCxDLFNBUVpxRixZLEdBQWU7QUFDbEIyakIsVUFBTSxFQURZLEU7QUFUTE8sSTtrQkFBQUEsSTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOckI7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBRUE7SUFDcUIwVCxZOzs7Ozs7Ozs7MkJBYWpCdDRCLE0scUJBQVM7QUFBQTs7QUFDTDtBQURLLHFCQUVxQyxLQUFLckIsS0FGMUM7QUFBQSxZQUVHNEYsU0FGSCxVQUVHQSxTQUZIO0FBQUEsWUFFY21HLE1BRmQsVUFFY0EsTUFGZDtBQUFBLFlBRXNCVSxVQUZ0QixVQUVzQkEsVUFGdEI7QUFBQSxZQUdHbXRCLGVBSEgsR0FHdUIsS0FBS2xyQixPQUg1QixDQUdHa3JCLGVBSEg7O0FBSUwsWUFBTWxxQixNQUFNO0FBQ1IyQixzQkFBVXVvQixnQkFBZ0I1MEIsT0FBaEIsQ0FBd0IrRyxPQUFPVSxVQUFQLENBQXhCLElBQThDLENBQUM7QUFEakQsdUJBRVA3RyxTQUZPLElBRUtBLFNBRkwsZUFBWjtBQUlBLGVBQVEsOEJBQUMsYUFBRCxlQUFTLEtBQUs1RixLQUFkLElBQXFCLFdBQVcwUCxHQUFoQyxJQUFSO0FBQ0gsSzs7O0VBdEJxQy9CLGdCQUFNbE0sUyxVQUNyQ0MsUyxnQkFDQW9MLGNBQUlwTCxTLFVBR0pLLFksZ0JBQ0ErSyxjQUFJL0ssWSxVQUdKNE4sWSxHQUFlO0FBQ2xCaXFCLHFCQUFpQmo0QixvQkFBVWtNO0FBRFQsQztBQVRMOHJCLFk7a0JBQUFBLFk7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTnJCOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFFcUJFLFc7Ozs7Ozs7OzswQkFnQmpCQyxpQiw4QkFBa0IvdEIsTSxFQUFRQyxLLEVBQU9tRCxPLEVBQVM7QUFBQSx1QkFDa0MsS0FBS1QsT0FEdkM7QUFBQSxZQUM5QnFyQixpQkFEOEIsWUFDOUJBLGlCQUQ4QjtBQUFBLFlBQ1hDLGlCQURXLFlBQ1hBLGlCQURXO0FBQUEsWUFDUUMsV0FEUixZQUNRQSxXQURSO0FBQUEsWUFDcUJ4ckIsUUFEckIsWUFDcUJBLFFBRHJCO0FBQUEscUJBRVQsS0FBS3pPLEtBRkk7QUFBQSxZQUU5QjZNLE9BRjhCLFVBRTlCQSxPQUY4QjtBQUFBLFlBRXJCRCxPQUZxQixVQUVyQkEsT0FGcUI7O0FBR3RDLFlBQUltdEIsaUJBQUosRUFBdUI7QUFBQSwwQkFDWSxLQUFLLzVCLEtBRGpCO0FBQUEsZ0JBQ1h5TSxVQURXLFdBQ1hBLFVBRFc7QUFBQSxnQkFDQ3hNLE1BREQsV0FDQ0EsTUFERDtBQUFBLGdCQUVmaTZCLFVBRmUsR0FFRkYsa0JBQWtCLENBQWxCLENBRkU7QUFBQSxnQkFHZkcsV0FIZSxHQUdESCxrQkFBa0IsQ0FBbEIsQ0FIQztBQUFBLGdCQUlmSSxXQUplLEdBSURGLGFBQWFDLFdBSlo7QUFBQSxnQkFLZkUsVUFMZSxHQUtGLFNBQWJBLFVBQWEsQ0FBQ252QixNQUFELEVBQVk7QUFDckIsb0JBQU0xRCxNQUFNLEVBQVo7O0FBRHFCLDJDQUVaL0ksQ0FGWTtBQUdqQitJLHdCQUFJMUksSUFBSixDQUFTO0FBQUE7QUFBQSwwQkFBSSxLQUFLTCxDQUFULEVBQVksS0FBSyxhQUFDNlEsSUFBRDtBQUFBLHVDQUFVMUMsUUFBUVosS0FBUixFQUFldk4sQ0FBZixFQUFrQjZRLElBQWxCLENBQVY7QUFBQSw2QkFBakI7QUFBQTtBQUFBLHFCQUFUO0FBSGlCOztBQUVyQixxQkFBSyxJQUFJN1EsSUFBSSxDQUFiLEVBQWdCQSxJQUFJeU0sTUFBcEIsRUFBNEJ6TSxHQUE1QixFQUFpQztBQUFBLDBCQUF4QkEsQ0FBd0I7QUFFaEM7QUFDRCx1QkFBTytJLEdBQVA7QUFDSCxhQVhjOztBQVluQixnQkFBSXBFLGdCQUFKOztBQUVBLGdCQUFJZzNCLGNBQWNqckIsT0FBZCxJQUF5QixDQUFDVixRQUE5QixFQUF3QztBQUNwQzdRLDBCQUFJd0MsT0FBSixDQUFZLHlFQUFaO0FBQ0g7QUFDRCxnQkFBSTg1QixhQUFhcnRCLFFBQVFsTyxNQUFyQixJQUErQjhQLGFBQWEsTUFBaEQsRUFBd0Q7QUFDcEQ3USwwQkFBSXdDLE9BQUosQ0FBWSxzRUFBWjtBQUNIO0FBQ0QsZ0JBQUkrNUIsY0FBY3R0QixRQUFRbE8sTUFBdEIsSUFBZ0M4UCxhQUFhLE9BQWpELEVBQTBEO0FBQ3REN1EsMEJBQUl3QyxPQUFKLENBQVksd0VBQVo7QUFDSDtBQUNELGdCQUFJcU8sUUFBSixFQUFjO0FBQ1YsdUJBQ0l3ckIsWUFBWWoxQixPQUFaLENBQW9CK0csT0FBT1UsVUFBUCxDQUFwQixJQUEwQyxDQUFDLENBQTNDLEdBQStDO0FBQUE7QUFBQSxzQkFBSSxXQUFjeE0sTUFBZCx1QkFBSixFQUErQyxtQkFBaUIrTCxLQUFoRTtBQUMzQztBQUFBO0FBQUEsMEJBQUksU0FBU21ELE9BQWIsRUFBc0IsS0FBSyxhQUFDRyxJQUFEO0FBQUEsdUNBQVUxQyxRQUFRWixLQUFSLEVBQWUsQ0FBZixFQUFrQnNELElBQWxCLENBQVY7QUFBQSw2QkFBM0I7QUFBQTtBQUFBO0FBRDJDLGlCQUEvQyxHQUVRLElBSFo7QUFLSDtBQUNEbE0sc0JBQVUyMkIsa0JBQWtCaHVCLE1BQWxCLEVBQTBCQyxLQUExQixDQUFWO0FBQ0EsZ0JBQUksQ0FBQzJCLGdCQUFNbFIsY0FBTixDQUFxQjJHLE9BQXJCLENBQUwsRUFBb0M7QUFDaENBLDBCQUNJO0FBQUE7QUFBQSxzQkFBSyxXQUFjbkQsTUFBZCx1QkFBTDtBQUNLbUQ7QUFETCxpQkFESjtBQUtIO0FBQ0QsbUJBQ0k2MkIsWUFBWWoxQixPQUFaLENBQW9CK0csT0FBT1UsVUFBUCxDQUFwQixJQUEwQyxDQUFDLENBQTNDLEdBQStDO0FBQUE7QUFBQSxrQkFBSSxXQUFjeE0sTUFBZCx1QkFBSixFQUE4QyxvQkFBaUI4TCxPQUFPVSxVQUFQLEtBQXNCVCxLQUF2QyxDQUE5QztBQUMxQ3F1QiwyQkFBV0gsVUFBWCxDQUQwQztBQUUzQztBQUFBO0FBQUEsc0JBQUksU0FBUy9xQixVQUFVaXJCLFdBQXZCO0FBQ0toM0I7QUFETCxpQkFGMkM7QUFLMUNpM0IsMkJBQVdGLFdBQVg7QUFMMEMsYUFBL0MsR0FNUSxJQVBaO0FBU0gsU0EvQ0QsTUErQ087QUFDSCxtQkFBTyxJQUFQO0FBQ0g7QUFDSixLOzswQkFFRDk0QixNLHFCQUFTO0FBQ0w7QUFESyxzQkFFaUMsS0FBS3JCLEtBRnRDO0FBQUEsWUFFRytMLE1BRkgsV0FFR0EsTUFGSDtBQUFBLFlBRVcrQixRQUZYLFdBRVdBLFFBRlg7QUFBQSxZQUVxQmpCLE9BRnJCLFdBRXFCQSxPQUZyQjs7QUFHTCxZQUFJZCxPQUFPMEIsVUFBWCxFQUF1QjtBQUNuQixtQkFBTyxLQUFLcXNCLGlCQUFMLENBQXVCL3RCLE1BQXZCLEVBQStCK0IsUUFBL0IsRUFBeUNqQixRQUFRbE8sTUFBakQsQ0FBUDtBQUNIO0FBQ0QsZUFBUSw4QkFBQyxhQUFELEVBQVMsS0FBS3FCLEtBQWQsQ0FBUjtBQUNILEs7OztFQTlFb0MyTixnQkFBTWxNLFMsVUFDcENDLFMsZ0JBQ0FvTCxjQUFJcEwsUyxVQUdKSyxZLGdCQUNBK0ssY0FBSS9LLFksVUFHSjROLFksR0FBZTtBQUNsQnNxQixpQkFBYXQ0QixvQkFBVWtNLEtBREw7QUFFbEJrc0IsdUJBQW1CcDRCLG9CQUFVaEUsSUFGWDtBQUdsQnE4Qix1QkFBbUJyNEIsb0JBQVVrTSxLQUhYO0FBSWxCWSxjQUFVOU0sb0JBQVVvRSxLQUFWLENBQWdCLENBQUMsTUFBRCxFQUFTLE9BQVQsQ0FBaEI7QUFKUSxDO0FBVEw4ekIsVztrQkFBQUEsVzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMckI7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7OztJQUVxQlMsTzs7Ozs7Ozs7Ozs7OzRKQWNqQnZzQixZLEdBQWUsVUFBQ2hDLE1BQUQsRUFBU0MsS0FBVCxFQUFnQjdLLENBQWhCLEVBQXNCO0FBQUEsZ0JBQ3pCOEssZUFEeUIsR0FDTCxNQUFLeUMsT0FEQSxDQUN6QnpDLGVBRHlCO0FBQUEsZ0JBRXpCOEIsWUFGeUIsR0FFUixNQUFLL04sS0FGRyxDQUV6QitOLFlBRnlCOztBQUdqQzlCLCtCQUFtQkEsZ0JBQWdCRixNQUFoQixFQUF3QkMsS0FBeEIsRUFBK0I3SyxDQUEvQixDQUFuQjtBQUNBNE0seUJBQWFoQyxNQUFiLEVBQXFCQyxLQUFyQixFQUE0QjdLLENBQTVCO0FBQ0gsUyxRQUVEOE0sWSxHQUFlLFVBQUNsQyxNQUFELEVBQVNDLEtBQVQsRUFBZ0I3SyxDQUFoQixFQUFzQjtBQUFBLGdCQUN6QitLLGVBRHlCLEdBQ0wsTUFBS3dDLE9BREEsQ0FDekJ4QyxlQUR5QjtBQUFBLGdCQUV6QitCLFlBRnlCLEdBRVIsTUFBS2pPLEtBRkcsQ0FFekJpTyxZQUZ5Qjs7QUFHakMvQiwrQkFBbUJBLGdCQUFnQkgsTUFBaEIsRUFBd0JDLEtBQXhCLEVBQStCN0ssQ0FBL0IsQ0FBbkI7QUFDQThNLHlCQUFhbEMsTUFBYixFQUFxQkMsS0FBckIsRUFBNEI3SyxDQUE1QjtBQUNILFM7OztzQkFFREUsTSxxQkFBUztBQUNMO0FBQ0EsZUFBUSw4QkFBQyxhQUFELGVBQVMsS0FBS3JCLEtBQWQsSUFBcUIsY0FBYyxLQUFLK04sWUFBeEMsRUFBc0QsY0FBYyxLQUFLRSxZQUF6RSxJQUFSO0FBQ0gsSzs7O0VBL0JnQ04sZ0JBQU1sTSxTLFVBQ2hDQyxTLGdCQUNBb0wsY0FBSXBMLFMsVUFHSmlPLFksR0FBZTtBQUNsQjFELHFCQUFpQnRLLG9CQUFVaEUsSUFEVDtBQUVsQnVPLHFCQUFpQnZLLG9CQUFVaEU7QUFGVCxDLFNBS2ZvRSxZLGdCQUNBK0ssY0FBSS9LLFk7QUFYTXU0QixPO2tCQUFBQSxPOzs7Ozs7Ozs7Ozs7Ozs7OztBQ0pyQjs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTtJQUNxQkMsUzs7Ozs7Ozs7Ozs7OzRKQXlCakJDLFksR0FBZSxZQUFNO0FBQUEsZ0JBQ1RBLFlBRFMsR0FDUSxNQUFLOXJCLE9BRGIsQ0FDVDhyQixZQURTOztBQUVqQkEsNEJBQWdCQSxjQUFoQjtBQUNBLGtCQUFLeDZCLEtBQUwsQ0FBV3k2QixRQUFYO0FBQ0gsUzs7O3dCQVREdnlCLGlCLGdDQUFvQjtBQUFBLFlBQ1J5SSxPQURRLEdBQ0ksS0FBS2pDLE9BRFQsQ0FDUmlDLE9BRFE7O0FBRWhCQSxtQkFBV0EsUUFBUSxNQUFSLEVBQWdCLDJCQUFZLElBQVosQ0FBaEIsQ0FBWDtBQUNILEs7O3dCQVFEdFAsTSxxQkFBUztBQUFBLHFCQUNzQyxLQUFLckIsS0FEM0M7QUFBQSxZQUNHNEYsU0FESCxVQUNHQSxTQURIO0FBQUEsWUFDY3dHLFFBRGQsVUFDY0EsUUFEZDtBQUFBLFlBQzJCckUsTUFEM0I7O0FBQUEsdUJBRWtDLEtBQUsyRyxPQUZ2QztBQUFBLFlBRUdnc0IsYUFGSCxZQUVHQSxhQUZIO0FBQUEsWUFFa0JDLFdBRmxCLFlBRWtCQSxXQUZsQjs7QUFHTCxZQUFNM3ZCLFFBQVEsRUFBZDtBQUNBLFlBQUkydkIsV0FBSixFQUFpQjtBQUNiM3ZCLGtCQUFNNHZCLFNBQU4sR0FBa0JGLGFBQWxCO0FBQ0g7QUFDRCxlQUFRO0FBQUE7QUFBQSxjQUFLLE9BQU8xdkIsS0FBWixFQUFtQixXQUFXcEYsU0FBOUIsRUFBeUMsVUFBVSxLQUFLNDBCLFlBQXhEO0FBQ0o7QUFBQTtBQUFBO0FBQ0twdUIsd0JBREw7QUFFSSw4Q0FBQyxjQUFELGVBQW1CckUsTUFBbkIsSUFBMkIsVUFBVXFFLFFBQXJDO0FBRko7QUFESSxTQUFSO0FBTUgsSzs7O0VBNUNrQ3VCLGdCQUFNbE0sUyxVQUNsQ0MsUyxHQUFZO0FBQ2ZGLGNBQVVHLG9CQUFVaU0sR0FETDtBQUVmM04sWUFBUTBCLG9CQUFVQyxNQUZIO0FBR2ZnRSxlQUFXakUsb0JBQVVDLE1BSE47QUFJZndLLGNBQVV6SyxvQkFBVWlNLEdBSkw7QUFLZjZzQixjQUFVOTRCLG9CQUFVaEU7QUFMTCxDLFNBUVpvRSxZLEdBQWU7QUFDbEIwNEIsY0FBVSxvQkFBTSxDQUFFO0FBREEsQyxTQUlmOXFCLFksR0FBZTtBQUNsQmdyQixpQkFBYWg1QixvQkFBVUUsSUFETDtBQUVsQjY0QixtQkFBZS80QixvQkFBVTZPLFNBQVYsQ0FBb0IsQ0FBQzdPLG9CQUFVdUosTUFBWCxFQUFtQnZKLG9CQUFVQyxNQUE3QixDQUFwQixDQUZHO0FBR2xCNDRCLGtCQUFjNzRCLG9CQUFVaEUsSUFITjtBQUlsQmdULGFBQVNoUCxvQkFBVWhFO0FBSkQsQztBQWJMNDhCLFM7a0JBQUFBLFM7Ozs7Ozs7Ozs7Ozs7OztBQ05yQjs7OztBQUNBOzs7Ozs7Ozs7Ozs7OztBQUVBOzs7O0lBSXFCTSxVOzs7Ozs7Ozs7dUJBeUJqQng1QixNLHFCQUFTO0FBQ0wsV0FBTyxJQUFQO0FBQ0gsRzs7O0VBM0JtQ3NNLGdCQUFNbE0sUyxVQUVuQ0MsUyxHQUFZO0FBQ2Y7OztBQUdBNE4sUUFBTTNOLG9CQUFVNk8sU0FBVixDQUFvQixDQUFDN08sb0JBQVVHLE9BQVgsRUFBb0JILG9CQUFVOE8sSUFBOUIsRUFBb0M5TyxvQkFBVWhFLElBQTlDLENBQXBCLENBSlM7QUFLZjs7O0FBR0FtOUIsd0JBQXNCbjVCLG9CQUFVRSxJQVJqQjtBQVNmOzs7QUFHQWs1QixnQkFBY3A1QixvQkFBVUU7QUFaVCxDLFNBZVpFLFksR0FBZTtBQUNsQnVOLFFBQU07QUFBQSxXQUFNLEVBQU47QUFBQSxHQURZO0FBRWxCeXJCLGdCQUFjLElBRkk7QUFHbEJELHdCQUFzQjtBQUhKLEMsU0FNZjkwQixTLEdBQVksWTtBQXZCRjYwQixVO2tCQUFBQSxVOzs7Ozs7Ozs7Ozs7Ozs7QUNQckI7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7OztJQUlxQkcsVTs7Ozs7Ozs7O3lCQWVqQjM1QixNLHFCQUFTO0FBQ0wsZUFBTyxJQUFQO0FBQ0gsSzs7O0VBakJtQ3NNLGdCQUFNbE0sUyxVQUVuQ0MsUyxHQUFZO0FBQ2Y7OztBQUdBNE4sVUFBTTNOLG9CQUFVNk8sU0FBVixDQUFvQixDQUFDN08sb0JBQVVHLE9BQVgsRUFBb0JILG9CQUFVOE8sSUFBOUIsRUFBb0M5TyxvQkFBVWhFLElBQTlDLENBQXBCO0FBSlMsQyxTQU9ab0UsWSxHQUFlO0FBQ2xCdU4sVUFBTTtBQUFBLGVBQU0sRUFBTjtBQUFBO0FBRFksQyxTQUlmdEosUyxHQUFZLFk7QUFiRmcxQixVO2tCQUFBQSxVOzs7Ozs7Ozs7O0FDUHJCOztBQUNBLHlCOzs7Ozs7Ozs7Ozs7O0FDREE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7OztBQUVBQyxpQkFBT3hrQixLQUFQLEdBQWV5a0IsZUFBZjs7a0JBRWV2N0IseUJBQWVzQyxNQUFmLENBQXNCZzVCLGdCQUF0QixFQUE4QjtBQUN6Q0UsZUFBVyxtQkFBQ243QixLQUFELEVBQVFvN0IsVUFBUixFQUF1QjtBQUM5QixZQUFJLFdBQVdwN0IsS0FBZixFQUFzQjtBQUNsQm83Qix1QkFBVyxPQUFYLEVBQW9CLHdCQUFwQixFQUE4QyxRQUE5Qzs7QUFEa0IseUJBR2lCcDdCLEtBSGpCO0FBQUEsZ0JBR1ZxUyxLQUhVLFVBR1ZBLEtBSFU7QUFBQSxnQkFHSDNNLElBSEcsVUFHSEEsSUFIRztBQUFBLGdCQUdNcUMsTUFITjs7QUFLbEIsZ0JBQUlzekIsVUFBVTMxQixJQUFkO0FBQ0EsZ0JBQUlBLFNBQVMsT0FBVCxJQUFvQkEsU0FBUyxNQUE3QixJQUF3Q0EsU0FBUyxXQUFULElBQXdCMk0sVUFBVSxTQUE5RSxFQUEwRjtBQUN0RmdwQiwwQkFBVSxRQUFWO0FBQ0g7O0FBRUQsZ0JBQUlDLGNBQUo7QUFDQSxnQkFBSWpwQixVQUFVLE9BQWQsRUFBdUI7QUFDbkJpcEIsd0JBQVM7QUFDTEMsNkJBQVMsTUFESjtBQUVMQywrQkFBVyxNQUZOO0FBR0xDLDRCQUFRLE9BSEg7QUFJTEMsMEJBQU0sTUFKRDtBQUtMQywyQkFBTztBQUxGLGlCQUFELENBTUxqMkIsUUFBUXUxQixpQkFBT2w1QixZQUFQLENBQW9CMkQsSUFOdkIsQ0FBUjtBQU9IOztBQUVELGdCQUFNMFEsT0FBTy9ELFVBQVUsTUFBdkI7QUFDQSxnQkFBTWpTLFVBQVVpUyxVQUFVLFNBQTFCOztBQUVBclMsK0JBQVUwRixNQUFNMjFCLE9BQWhCLEVBQXlCQyxZQUF6QixFQUFnQ2xsQixVQUFoQyxFQUFzQ2hXLGdCQUF0QyxJQUFrRDJILE1BQWxEO0FBQ0g7O0FBRUQsZUFBTy9ILEtBQVA7QUFDSDtBQTlCd0MsQ0FBOUIsQzs7Ozs7Ozs7OztBQ05mOztBQUNBLHlCOzs7Ozs7Ozs7Ozs7QUNEQTs7OztBQUNBOzs7Ozs7QUFFQW9zQixrQkFBUXdQLE1BQVIsR0FBaUJBLGdCQUFqQjs7a0JBRWV4UCxpQjs7Ozs7Ozs7Ozs7Ozs7OztBQ0xmOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUE7SUFDTXlQLE87Ozs7Ozs7OztzQkE2REZ4NkIsTSxxQkFBUztBQUFBOztBQUFBLHFCQWNELEtBQUtyQixLQWRKO0FBQUEsWUFFRDg3QixHQUZDLFVBRURBLEdBRkM7QUFBQSxZQUdEdmQsT0FIQyxVQUdEQSxPQUhDO0FBQUEsWUFJRC9jLFFBSkMsVUFJREEsUUFKQztBQUFBLFlBS0RvRSxTQUxDLFVBS0RBLFNBTEM7QUFBQSxZQU1Eb0YsS0FOQyxVQU1EQSxLQU5DO0FBQUEsWUFPRCt3QixTQVBDLFVBT0RBLFNBUEM7QUFBQSxZQVFEQyxLQVJDLFVBUURBLEtBUkM7QUFBQSxZQVNELzdCLE1BVEMsVUFTREEsTUFUQztBQUFBLFlBVURnOEIsVUFWQyxVQVVEQSxVQVZDO0FBQUEsWUFXRDFHLGVBWEMsVUFXREEsZUFYQztBQUFBLFlBWUQyRyxRQVpDLFVBWURBLFFBWkM7QUFBQSxZQWFEdjJCLElBYkMsVUFhREEsSUFiQzs7O0FBZ0JMLFlBQUl3MkIsZUFBZSxJQUFuQjtBQUNBLFlBQU1DLFNBQVluOEIsTUFBWixnQkFBTjs7QUFFQSxZQUFJODdCLFNBQUosRUFBZTtBQUNYSSwyQkFBZUosU0FBZjtBQUNILFNBRkQsTUFFTztBQUFBOztBQUNILGdCQUFNTSxrQkFBa0JMLEtBQXhCO0FBQ0EsZ0JBQU1NLG1CQUFtQix5REFDakJyOEIsTUFEaUIsK0JBQ2dCLElBRGhCLGNBRWpCQSxNQUZpQixzQ0FFdUIwRixTQUFTLFFBRmhDLGVBQXpCO0FBSUF3MkIsMkJBQWdCO0FBQUE7QUFBQSxrQkFBSyxXQUFXRyxnQkFBaEI7QUFDWix3REFBTSxXQUFXRixNQUFqQixFQUF5QixPQUFPLEVBQUNDLGdDQUFELEVBQWhDLEdBRFk7QUFFWix3REFBTSxXQUFXRCxNQUFqQixFQUF5QixPQUFPLEVBQUNDLGdDQUFELEVBQWhDLEdBRlk7QUFHWix3REFBTSxXQUFXRCxNQUFqQixFQUF5QixPQUFPLEVBQUNDLGdDQUFELEVBQWhDLEdBSFk7QUFJWix3REFBTSxXQUFXRCxNQUFqQixFQUF5QixPQUFPLEVBQUNDLGdDQUFELEVBQWhDO0FBSlksYUFBaEI7QUFNSDs7QUFFRCxZQUFNRSxhQUFhLDJEQUNYdDhCLE1BRFcsZ0JBQ08sSUFEUCxlQUVYQSxNQUZXLGFBRUlzZSxPQUZKLGVBR2QzWSxTQUhjLElBR0ZBLFNBSEUsZ0JBQW5COztBQU1BLFlBQU00MkIsU0FBUywyREFDUHY4QixNQURPLG9CQUNlLElBRGYsZUFHUEEsTUFITywwQkFHcUJpOEIsYUFBYSxPQUhsQyxnQkFBZjs7QUFNQSxZQUFNbjBCLFNBQVNsSyxVQUFJMEksVUFBSixDQUFlczFCLFFBQVFuNkIsU0FBdkIsRUFBa0MsS0FBSzFCLEtBQXZDLENBQWY7O0FBRUEsWUFBTXk4QixhQUFhLDJEQUNYeDhCLE1BRFcsMEJBQ2lCc2UsT0FEakIsZUFFWHRlLE1BRlcscUJBRVksSUFGWixnQkFBbkI7O0FBS0EsZUFBT2c4QixhQUNILENBQ0l6NkIsUUFESixFQUVJO0FBQUMsNkJBQUQ7QUFBQSx1QkFBUyxLQUFJLFNBQWIsRUFBdUIsYUFBdkIsRUFBK0IsT0FBTSxPQUFyQyxJQUFpRHVHLE1BQWpEO0FBQ0ksMkJBQVduQyxTQURmO0FBRUksdUJBQU9vRixLQUZYO0FBR0kseUJBQVN1VCxPQUhiO0FBSUksZ0NBQWdCZ1gsZUFKcEI7QUFLSTtBQUFBO0FBQUEsa0JBQUssV0FBV2lILE1BQWhCO0FBQ0k7QUFBQTtBQUFBLHNCQUFLLFdBQWN2OEIsTUFBZCxzQkFBTDtBQUNLazhCO0FBREwsaUJBREo7QUFJSTtBQUFBO0FBQUEsc0JBQUssV0FBY2w4QixNQUFkLHdCQUFMO0FBQ0s2N0I7QUFETCxpQkFKSjtBQVFJO0FBQUE7QUFBQSxzQkFBSyxXQUFjNzdCLE1BQWQsNEJBQUw7QUFDSzY3QjtBQURMO0FBUko7QUFMSixTQUZKLENBREcsR0FzQkM7QUFBQTtBQUFBLHVCQUFLLFdBQVdTLFVBQWhCLEVBQTRCLE9BQU92eEIsS0FBbkMsSUFBOENqRCxNQUE5QztBQUNLd1csc0JBQ0k7QUFBQTtBQUFBLGtCQUFLLFdBQVdpZSxNQUFoQjtBQUNHO0FBQUE7QUFBQSxzQkFBSyxXQUFjdjhCLE1BQWQsc0JBQUw7QUFDS2s4QjtBQURMLGlCQURIO0FBSUc7QUFBQTtBQUFBLHNCQUFLLFdBQWNsOEIsTUFBZCx3QkFBTDtBQUNLNjdCO0FBREwsaUJBSkg7QUFPRztBQUFBO0FBQUEsc0JBQUssV0FBYzc3QixNQUFkLDRCQUFMO0FBQ0s2N0I7QUFETDtBQVBILGFBREosR0FXYSxJQVpsQjtBQWNJO0FBQUE7QUFBQSxrQkFBSyxXQUFXVyxVQUFoQjtBQUNLbGUsMEJBQVUsdUNBQUssV0FBY3RlLE1BQWQsbUJBQUwsR0FBVixHQUE4RCxJQURuRTtBQUVLdUI7QUFGTDtBQWRKLFNBdEJSO0FBMENILEs7OztFQTdKaUJtTSxnQkFBTWxNLFMsVUFDakJDLFMsR0FBWTtBQUNmOzs7QUFHQXpCLFlBQVEwQixvQkFBVUMsTUFKSDtBQUtmOzs7QUFHQWs2QixTQUFLbjZCLG9CQUFVaU0sR0FSQTtBQVNmOzs7O0FBSUFzdUIsY0FBVXY2QixvQkFBVW9FLEtBQVYsQ0FBZ0IsQ0FBQyxPQUFELEVBQVUsUUFBVixDQUFoQixDQWJLO0FBY2Y7OztBQUdBd1ksYUFBUzVjLG9CQUFVRSxJQWpCSjtBQWtCZjB6QixxQkFBaUI1ekIsb0JBQVVoRSxJQWxCWjtBQW1CZjs7O0FBR0FpSSxlQUFXakUsb0JBQVVDLE1BdEJOO0FBdUJmOzs7QUFHQW9KLFdBQU9ySixvQkFBVWpGLE1BMUJGO0FBMkJmOzs7OztBQUtBaUosVUFBTWhFLG9CQUFVb0UsS0FBVixDQUFnQixDQUFDLE9BQUQsRUFBVSxRQUFWLENBQWhCLENBaENTO0FBaUNmOzs7QUFHQWcyQixlQUFXcDZCLG9CQUFVaU0sR0FwQ047QUFxQ2Y7OztBQUdBb3VCLFdBQU9yNkIsb0JBQVVDLE1BeENGO0FBeUNmOzs7QUFHQXE2QixnQkFBWXQ2QixvQkFBVUUsSUE1Q1A7QUE2Q2Y7OztBQUdBTCxjQUFVRyxvQkFBVWlNO0FBaERMLEMsU0FtRFo3TCxZLEdBQWU7QUFDbEI5QixZQUFRLE9BRFU7QUFFbEJzZSxhQUFTLElBRlM7QUFHbEJnWCxxQkFBaUI1M0IsV0FBSzhOLElBSEo7QUFJbEJpeEIsYUFBUyxJQUpTO0FBS2xCUixjQUFVLFFBTFE7QUFNbEJ2MkIsVUFBTTtBQU5ZLEM7QUFwRHBCazJCLE87a0JBZ0tTbDhCLHlCQUFlc0MsTUFBZixDQUFzQjQ1QixPQUF0QixDOzs7Ozs7Ozs7Ozs7OztBQ3hLZjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7QUFFQXpVLGVBQUt1VixPQUFMLEdBQWVBLGlCQUFmO0FBQ0F2VixlQUFLbmYsSUFBTCxHQUFZa0osd0JBQVo7QUFDQWlXLGVBQUt3VixZQUFMLEdBQW9CQSxzQkFBcEI7QUFDQXhWLGVBQUt5VixTQUFMLEdBQWlCQSxtQkFBakI7QUFDQXpWLGVBQUs4TixTQUFMLEdBQWlCQSxtQkFBakI7QUFDQTlOLGVBQUszUSxLQUFMLEdBQWFBLGVBQWI7QUFDQTJRLGVBQUswVixPQUFMLEdBQWVBLGlCQUFmO0FBQ0ExVixlQUFLaUksTUFBTCxHQUFjQSxnQkFBZDs7QUFFQTtBQUNBLElBQU04TCxZQUFZLFNBQVpBLFNBQVksQ0FBQ243QixLQUFELEVBQVFvN0IsVUFBUixFQUF1QjtBQUNyQyxRQUFJLGdCQUFnQnA3QixLQUFwQixFQUEyQjtBQUN2Qm83QixtQkFBVyxZQUFYLEVBQXlCLGNBQXpCLEVBQXlDLE1BQXpDOztBQUR1QixxQkFHV3A3QixLQUhYO0FBQUEsWUFHZis4QixVQUhlLFVBR2ZBLFVBSGU7QUFBQSxZQUdBaDFCLE1BSEE7O0FBSXZCL0gsMkJBQVUySyxjQUFjb3lCLFVBQXhCLElBQXVDaDFCLE1BQXZDO0FBQ0g7O0FBRUQsUUFBSSxnQkFBZ0IvSCxLQUFwQixFQUEyQjtBQUN2Qm83QixtQkFBVyxZQUFYLEVBQXlCLFVBQXpCLEVBQXFDLE1BQXJDO0FBQ0EsWUFBSXA3QixNQUFNZzlCLFVBQVYsRUFBc0I7QUFBQSwwQkFDMEJoOUIsS0FEMUI7QUFBQSxnQkFDVmc5QixVQURVLFdBQ1ZBLFVBRFU7QUFBQSxnQkFDRXZyQixRQURGLFdBQ0VBLFFBREY7QUFBQSxnQkFDZTFKLE9BRGY7O0FBRWxCLGdCQUFNazFCLGNBQWMsU0FBZEEsV0FBYyxDQUFDMXJCLFlBQUQsRUFBZXBPLElBQWYsRUFBcUIrNUIsS0FBckIsRUFBK0I7QUFDL0Msb0JBQUksQ0FBQ0EsTUFBTXBULE1BQVgsRUFBbUI7QUFDZmtULCtCQUFXRSxNQUFNLzlCLEdBQWpCO0FBQ0g7QUFDRCxvQkFBSXNTLFFBQUosRUFBYztBQUNWQSw2QkFBU0YsWUFBVCxFQUF1QnBPLElBQXZCLEVBQTZCKzVCLEtBQTdCO0FBQ0g7QUFDSixhQVBEOztBQVNBbDlCLCtCQUFVeVIsVUFBVXdyQixXQUFwQixJQUFvQ2wxQixPQUFwQztBQUNIO0FBQ0o7O0FBRUQsV0FBTy9ILEtBQVA7QUFDSCxDQTFCRDs7a0JBNEJlTCx5QkFBZXNDLE1BQWYsQ0FBc0JtbEIsY0FBdEIsRUFBNEI7QUFDdkMrVDtBQUR1QyxDQUE1QixDOzs7Ozs7Ozs7O0FDakRmOztBQUNBOztBQUNBOztBQUNBOztBQUNBLHlCOzs7Ozs7Ozs7QUNKQTs7QUFDQTs7QUFDQTs7QUFDQSx5Qjs7Ozs7Ozs7Ozs7OztBQ0hBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7QUFFQSxJQUFNZ0MsYUFBYSxDQUFDQyxlQUFELEVBQVFqdEIsY0FBUixFQUFja3RCLG1CQUFkLEVBQXlCN3ZCLGtCQUF6QixFQUFtQzh2QixjQUFuQyxFQUF5Q0MsaUJBQXpDLEVBQWtEdjZCLGNBQWxELEVBQXdEdzZCLGdCQUF4RCxDQUFuQjtBQUNBLElBQU1wb0IsUUFBUStuQixXQUFXTSxNQUFYLENBQWtCLFVBQUNqMkIsR0FBRCxFQUFNazJCLE9BQU4sRUFBa0I7QUFDOUNsMkIsVUFBTWsyQixRQUFRbDJCLEdBQVIsQ0FBTjtBQUNBLFdBQU9BLEdBQVA7QUFDSCxDQUhhLEVBR1htMkIsY0FIVyxDQUFkO0FBSUF2b0IsTUFBTXVvQixJQUFOLEdBQWFBLGNBQWI7QUFDQXZvQixNQUFNZ29CLEtBQU4sR0FBY0EsZUFBZDtBQUNBaG9CLE1BQU1qRixJQUFOLEdBQWFBLGNBQWI7QUFDQWlGLE1BQU1pb0IsU0FBTixHQUFrQkEsbUJBQWxCO0FBQ0Fqb0IsTUFBTTVILFFBQU4sR0FBaUJBLGtCQUFqQjtBQUNBNEgsTUFBTWtvQixJQUFOLEdBQWFBLGNBQWI7QUFDQWxvQixNQUFNbW9CLE9BQU4sR0FBZ0JBLGlCQUFoQjtBQUNBbm9CLE1BQU1wUyxJQUFOLEdBQWFBLGNBQWI7QUFDQW9TLE1BQU1vb0IsTUFBTixHQUFlQSxnQkFBZjs7QUFFQXBvQixNQUFNd29CLFdBQU4sR0FBb0IvQyxvQkFBcEI7QUFDQXpsQixNQUFNeW9CLFdBQU4sR0FBb0I3QyxvQkFBcEI7O2tCQUVlcjdCLHlCQUFlc0MsTUFBZixDQUFzQm1ULEtBQXRCLEVBQTZCO0FBQ3hDK2QsbUJBQWUsT0FEeUI7QUFFeENnSSxlQUFXLG1CQUFDbjdCLEtBQUQsRUFBUW83QixVQUFSLEVBQXVCO0FBQzlCLFlBQUkscUJBQXFCcDdCLEtBQXpCLEVBQWdDO0FBQzVCbzdCLHVCQUFXLGlCQUFYLEVBQThCLGFBQTlCLEVBQTZDLE9BQTdDOztBQUQ0Qix5QkFHV3A3QixLQUhYO0FBQUEsZ0JBR3BCODlCLGVBSG9CLFVBR3BCQSxlQUhvQjtBQUFBLGdCQUdBLzFCLE1BSEE7O0FBSTVCL0gsK0JBQVVpNkIsYUFBYTZELGVBQXZCLElBQTJDLzFCLE1BQTNDO0FBQ0g7QUFDRCxZQUFJLHNCQUFzQi9ILEtBQTFCLEVBQWlDO0FBQzdCbzdCLHVCQUFXLGtCQUFYLEVBQStCLFdBQS9CLEVBQTRDLE9BQTVDOztBQUQ2QiwwQkFHV3A3QixLQUhYO0FBQUEsZ0JBR3JCKzlCLGdCQUhxQixXQUdyQkEsZ0JBSHFCO0FBQUEsZ0JBR0FoMkIsT0FIQTs7QUFJN0IvSCwrQkFBVWcrQixXQUFXRCxnQkFBckIsSUFBMENoMkIsT0FBMUM7QUFDSDtBQUNELFlBQUksZUFBZS9ILEtBQW5CLEVBQTBCO0FBQ3RCbzdCLHVCQUFXLFdBQVgsRUFBd0IsU0FBeEIsRUFBbUMsT0FBbkM7O0FBRHNCLDBCQUdXcDdCLEtBSFg7QUFBQSxnQkFHZGkrQixTQUhjLFdBR2RBLFNBSGM7QUFBQSxnQkFHQWwyQixRQUhBOztBQUl0Qi9ILCtCQUFVcU0sU0FBUzR4QixTQUFuQixJQUFpQ2wyQixRQUFqQztBQUNIO0FBQ0QsWUFBSSxnQkFBZ0IvSCxLQUFwQixFQUEyQjtBQUN2Qm83Qix1QkFBVyxZQUFYLEVBQXlCLFFBQXpCLEVBQW1DLE9BQW5DOztBQUR1QiwwQkFHV3A3QixLQUhYO0FBQUEsZ0JBR2YrOEIsVUFIZSxXQUdmQSxVQUhlO0FBQUEsZ0JBR0FoMUIsUUFIQTs7QUFJdkIvSCwrQkFBVWsrQixRQUFRbkIsVUFBbEIsSUFBaUNoMUIsUUFBakM7QUFDSDtBQUNELFlBQUksa0JBQWtCL0gsS0FBdEIsRUFBNkI7QUFDekJvN0IsdUJBQVcsY0FBWCxFQUEyQixNQUEzQixFQUFtQyxPQUFuQzs7QUFEeUIsMEJBR1dwN0IsS0FIWDtBQUFBLGdCQUdqQm0rQixZQUhpQixXQUdqQkEsWUFIaUI7QUFBQSxnQkFHQXAyQixRQUhBOztBQUl6Qi9ILCtCQUFVRyxNQUFNZytCLFlBQWhCLElBQWlDcDJCLFFBQWpDO0FBQ0g7QUFDRCxZQUFJLHFCQUFxQi9ILEtBQXpCLEVBQWdDO0FBQzVCbzdCLHVCQUFXLGlCQUFYLEVBQThCLGFBQTlCLEVBQTZDLE9BQTdDOztBQUQ0QiwwQkFHd0JwN0IsS0FIeEI7QUFBQSxnQkFHcEJvK0IsZUFIb0IsV0FHcEJBLGVBSG9CO0FBQUEsZ0JBR0gxeEIsV0FIRyxXQUdIQSxXQUhHO0FBQUEsZ0JBR2EzRSxRQUhiOztBQUk1QixnQkFBSXEyQixlQUFKLEVBQXFCO0FBQ2pCLG9CQUFNQyxpQkFBaUIsU0FBakJBLGNBQWlCLEdBQWE7QUFDaEM7QUFDSXo0QixtQ0FBV3c0QjtBQURmLHVCQUVRMXhCLGNBQWNBLHVDQUFkLEdBQXFDLEVBRjdDO0FBSUgsaUJBTEQ7O0FBT0ExTSxtQ0FBVTBNLGFBQWEyeEIsY0FBdkIsSUFBMEN0MkIsUUFBMUM7QUFDSCxhQVRELE1BU087QUFDSC9ILG1DQUFVME0sd0JBQVYsSUFBMEIzRSxRQUExQjtBQUNIO0FBQ0o7O0FBRUQsZUFBTy9ILEtBQVA7QUFDSDtBQXBEdUMsQ0FBN0IsQzs7Ozs7Ozs7QUMvQmY7Ozs7Ozs7QUFPYTs7OztBQUViLElBQUltMEIsU0FBU3AzQixtQkFBT0EsQ0FBQyxFQUFSLENBQWI7O0FBRUEsSUFBSTZULHVCQUF1QjdULG1CQUFPQSxDQUFDLEVBQVIsQ0FBM0I7QUFDQSxJQUFJdWhDLGlCQUFpQnZoQyxtQkFBT0EsQ0FBQyxFQUFSLENBQXJCOztBQUVBLElBQUl3aEMsZUFBZSx3QkFBVyxDQUFFLENBQWhDOztBQUVBLElBQUlwaUMsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDa2lDLGlCQUFlLHNCQUFTbm9CLElBQVQsRUFBZTtBQUM1QixRQUFJb29CLFVBQVUsY0FBY3BvQixJQUE1QjtBQUNBLFFBQUksT0FBT3FvQixPQUFQLEtBQW1CLFdBQXZCLEVBQW9DO0FBQ2xDQSxjQUFRQyxLQUFSLENBQWNGLE9BQWQ7QUFDRDtBQUNELFFBQUk7QUFDRjtBQUNBO0FBQ0E7QUFDQSxZQUFNLElBQUl4YSxLQUFKLENBQVV3YSxPQUFWLENBQU47QUFDRCxLQUxELENBS0UsT0FBT0csQ0FBUCxFQUFVLENBQUU7QUFDZixHQVhEO0FBWUQ7O0FBRUQsU0FBU0MsNEJBQVQsR0FBd0M7QUFDdEMsU0FBTyxJQUFQO0FBQ0Q7O0FBRUQvaEMsT0FBT0MsT0FBUCxHQUFpQixVQUFTTCxjQUFULEVBQXlCRyxtQkFBekIsRUFBOEM7QUFDN0Q7QUFDQSxNQUFJaWlDLGtCQUFrQixPQUFPdGlDLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0NBLE9BQU91aUMsUUFBN0Q7QUFDQSxNQUFJQyx1QkFBdUIsWUFBM0IsQ0FINkQsQ0FHcEI7O0FBRXpDOzs7Ozs7Ozs7Ozs7OztBQWNBLFdBQVNDLGFBQVQsQ0FBdUJDLGFBQXZCLEVBQXNDO0FBQ3BDLFFBQUlDLGFBQWFELGtCQUFrQkosbUJBQW1CSSxjQUFjSixlQUFkLENBQW5CLElBQXFESSxjQUFjRixvQkFBZCxDQUF2RSxDQUFqQjtBQUNBLFFBQUksT0FBT0csVUFBUCxLQUFzQixVQUExQixFQUFzQztBQUNwQyxhQUFPQSxVQUFQO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQ0EsTUFBSUMsWUFBWSxlQUFoQjs7QUFFQTtBQUNBO0FBQ0EsTUFBSUMsaUJBQWlCO0FBQ25CdnhCLFdBQU93eEIsMkJBQTJCLE9BQTNCLENBRFk7QUFFbkJ4OUIsVUFBTXc5QiwyQkFBMkIsU0FBM0IsQ0FGYTtBQUduQjFoQyxVQUFNMGhDLDJCQUEyQixVQUEzQixDQUhhO0FBSW5CbjBCLFlBQVFtMEIsMkJBQTJCLFFBQTNCLENBSlc7QUFLbkIzaUMsWUFBUTJpQywyQkFBMkIsUUFBM0IsQ0FMVztBQU1uQno5QixZQUFReTlCLDJCQUEyQixRQUEzQixDQU5XO0FBT25CQyxZQUFRRCwyQkFBMkIsUUFBM0IsQ0FQVzs7QUFTbkJ6eEIsU0FBSzJ4QixzQkFUYztBQVVuQm50QixhQUFTb3RCLHdCQVZVO0FBV25CMTlCLGFBQVMyOUIsMEJBWFU7QUFZbkJDLGdCQUFZQyx5QkFaTztBQWFuQmx2QixVQUFNbXZCLG1CQWJhO0FBY25CQyxjQUFVQyx5QkFkUztBQWVuQi81QixXQUFPZzZCLHFCQWZZO0FBZ0JuQnZ2QixlQUFXd3ZCLHNCQWhCUTtBQWlCbkIzdEIsV0FBTzR0QixzQkFqQlk7QUFrQm5CQyxXQUFPQztBQWxCWSxHQUFyQjs7QUFxQkE7Ozs7QUFJQTtBQUNBLFdBQVNDLEVBQVQsQ0FBWXpCLENBQVosRUFBZTBCLENBQWYsRUFBa0I7QUFDaEI7QUFDQSxRQUFJMUIsTUFBTTBCLENBQVYsRUFBYTtBQUNYO0FBQ0E7QUFDQSxhQUFPMUIsTUFBTSxDQUFOLElBQVcsSUFBSUEsQ0FBSixLQUFVLElBQUkwQixDQUFoQztBQUNELEtBSkQsTUFJTztBQUNMO0FBQ0EsYUFBTzFCLE1BQU1BLENBQU4sSUFBVzBCLE1BQU1BLENBQXhCO0FBQ0Q7QUFDRjtBQUNEOztBQUVBOzs7Ozs7O0FBT0EsV0FBU0MsYUFBVCxDQUF1QjlCLE9BQXZCLEVBQWdDO0FBQzlCLFNBQUtBLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUsrQixLQUFMLEdBQWEsRUFBYjtBQUNEO0FBQ0Q7QUFDQUQsZ0JBQWM3NUIsU0FBZCxHQUEwQnVkLE1BQU12ZCxTQUFoQzs7QUFFQSxXQUFTKzVCLDBCQUFULENBQW9DQyxRQUFwQyxFQUE4QztBQUM1QyxRQUFJdGtDLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxVQUFJcWtDLDBCQUEwQixFQUE5QjtBQUNBLFVBQUlDLDZCQUE2QixDQUFqQztBQUNEO0FBQ0QsYUFBUzVKLFNBQVQsQ0FBbUI5RSxVQUFuQixFQUErQmp5QixLQUEvQixFQUFzQzRnQyxRQUF0QyxFQUFnRHpOLGFBQWhELEVBQStEME4sUUFBL0QsRUFBeUVDLFlBQXpFLEVBQXVGQyxNQUF2RixFQUErRjtBQUM3RjVOLHNCQUFnQkEsaUJBQWlCZ00sU0FBakM7QUFDQTJCLHFCQUFlQSxnQkFBZ0JGLFFBQS9COztBQUVBLFVBQUlHLFdBQVdud0Isb0JBQWYsRUFBcUM7QUFDbkMsWUFBSWhVLG1CQUFKLEVBQXlCO0FBQ3ZCO0FBQ0EsY0FBSXNVLE1BQU0sSUFBSThTLEtBQUosQ0FDUix5RkFDQSxpREFEQSxHQUVBLGdEQUhRLENBQVY7QUFLQTlTLGNBQUlxSSxJQUFKLEdBQVcscUJBQVg7QUFDQSxnQkFBTXJJLEdBQU47QUFDRCxTQVRELE1BU08sSUFBSS9VLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QyxPQUFPb2lDLE9BQVAsS0FBbUIsV0FBaEUsRUFBNkU7QUFDbEY7QUFDQSxjQUFJdUMsV0FBVzdOLGdCQUFnQixHQUFoQixHQUFzQnlOLFFBQXJDO0FBQ0EsY0FDRSxDQUFDRix3QkFBd0JNLFFBQXhCLENBQUQ7QUFDQTtBQUNBTCx1Q0FBNkIsQ0FIL0IsRUFJRTtBQUNBcEMseUJBQ0UsMkRBQ0Esb0JBREEsR0FDdUJ1QyxZQUR2QixHQUNzQyxhQUR0QyxHQUNzRDNOLGFBRHRELEdBQ3VFLHdCQUR2RSxHQUVBLHlEQUZBLEdBR0EsZ0VBSEEsR0FJQSwrREFKQSxHQUlrRSxjQUxwRTtBQU9BdU4sb0NBQXdCTSxRQUF4QixJQUFvQyxJQUFwQztBQUNBTDtBQUNEO0FBQ0Y7QUFDRjtBQUNELFVBQUkzZ0MsTUFBTTRnQyxRQUFOLEtBQW1CLElBQXZCLEVBQTZCO0FBQzNCLFlBQUkzTyxVQUFKLEVBQWdCO0FBQ2QsY0FBSWp5QixNQUFNNGdDLFFBQU4sTUFBb0IsSUFBeEIsRUFBOEI7QUFDNUIsbUJBQU8sSUFBSU4sYUFBSixDQUFrQixTQUFTTyxRQUFULEdBQW9CLElBQXBCLEdBQTJCQyxZQUEzQixHQUEwQywwQkFBMUMsSUFBd0UsU0FBUzNOLGFBQVQsR0FBeUIsNkJBQWpHLENBQWxCLENBQVA7QUFDRDtBQUNELGlCQUFPLElBQUltTixhQUFKLENBQWtCLFNBQVNPLFFBQVQsR0FBb0IsSUFBcEIsR0FBMkJDLFlBQTNCLEdBQTBDLDZCQUExQyxJQUEyRSxNQUFNM04sYUFBTixHQUFzQixrQ0FBakcsQ0FBbEIsQ0FBUDtBQUNEO0FBQ0QsZUFBTyxJQUFQO0FBQ0QsT0FSRCxNQVFPO0FBQ0wsZUFBT3NOLFNBQVN6Z0MsS0FBVCxFQUFnQjRnQyxRQUFoQixFQUEwQnpOLGFBQTFCLEVBQXlDME4sUUFBekMsRUFBbURDLFlBQW5ELENBQVA7QUFDRDtBQUNGOztBQUVELFFBQUlHLG1CQUFtQmxLLFVBQVVycEIsSUFBVixDQUFlLElBQWYsRUFBcUIsS0FBckIsQ0FBdkI7QUFDQXV6QixxQkFBaUJoUCxVQUFqQixHQUE4QjhFLFVBQVVycEIsSUFBVixDQUFlLElBQWYsRUFBcUIsSUFBckIsQ0FBOUI7O0FBRUEsV0FBT3V6QixnQkFBUDtBQUNEOztBQUVELFdBQVM1QiwwQkFBVCxDQUFvQzZCLFlBQXBDLEVBQWtEO0FBQ2hELGFBQVNULFFBQVQsQ0FBa0J6Z0MsS0FBbEIsRUFBeUI0Z0MsUUFBekIsRUFBbUN6TixhQUFuQyxFQUFrRDBOLFFBQWxELEVBQTREQyxZQUE1RCxFQUEwRUMsTUFBMUUsRUFBa0Y7QUFDaEYsVUFBSUksWUFBWW5oQyxNQUFNNGdDLFFBQU4sQ0FBaEI7QUFDQSxVQUFJUSxXQUFXQyxZQUFZRixTQUFaLENBQWY7QUFDQSxVQUFJQyxhQUFhRixZQUFqQixFQUErQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxZQUFJSSxjQUFjQyxlQUFlSixTQUFmLENBQWxCOztBQUVBLGVBQU8sSUFBSWIsYUFBSixDQUFrQixhQUFhTyxRQUFiLEdBQXdCLElBQXhCLEdBQStCQyxZQUEvQixHQUE4QyxZQUE5QyxJQUE4RCxNQUFNUSxXQUFOLEdBQW9CLGlCQUFwQixHQUF3Q25PLGFBQXhDLEdBQXdELGNBQXRILEtBQXlJLE1BQU0rTixZQUFOLEdBQXFCLElBQTlKLENBQWxCLENBQVA7QUFDRDtBQUNELGFBQU8sSUFBUDtBQUNEO0FBQ0QsV0FBT1YsMkJBQTJCQyxRQUEzQixDQUFQO0FBQ0Q7O0FBRUQsV0FBU2xCLG9CQUFULEdBQWdDO0FBQzlCLFdBQU9pQiwyQkFBMkI1Qiw0QkFBM0IsQ0FBUDtBQUNEOztBQUVELFdBQVNZLHdCQUFULENBQWtDZ0MsV0FBbEMsRUFBK0M7QUFDN0MsYUFBU2YsUUFBVCxDQUFrQnpnQyxLQUFsQixFQUF5QjRnQyxRQUF6QixFQUFtQ3pOLGFBQW5DLEVBQWtEME4sUUFBbEQsRUFBNERDLFlBQTVELEVBQTBFO0FBQ3hFLFVBQUksT0FBT1UsV0FBUCxLQUF1QixVQUEzQixFQUF1QztBQUNyQyxlQUFPLElBQUlsQixhQUFKLENBQWtCLGVBQWVRLFlBQWYsR0FBOEIsa0JBQTlCLEdBQW1EM04sYUFBbkQsR0FBbUUsaURBQXJGLENBQVA7QUFDRDtBQUNELFVBQUlnTyxZQUFZbmhDLE1BQU00Z0MsUUFBTixDQUFoQjtBQUNBLFVBQUksQ0FBQzdoQyxNQUFNQyxPQUFOLENBQWNtaUMsU0FBZCxDQUFMLEVBQStCO0FBQzdCLFlBQUlDLFdBQVdDLFlBQVlGLFNBQVosQ0FBZjtBQUNBLGVBQU8sSUFBSWIsYUFBSixDQUFrQixhQUFhTyxRQUFiLEdBQXdCLElBQXhCLEdBQStCQyxZQUEvQixHQUE4QyxZQUE5QyxJQUE4RCxNQUFNTSxRQUFOLEdBQWlCLGlCQUFqQixHQUFxQ2pPLGFBQXJDLEdBQXFELHVCQUFuSCxDQUFsQixDQUFQO0FBQ0Q7QUFDRCxXQUFLLElBQUkxMEIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMGlDLFVBQVV4aUMsTUFBOUIsRUFBc0NGLEdBQXRDLEVBQTJDO0FBQ3pDLFlBQUlpZ0MsUUFBUThDLFlBQVlMLFNBQVosRUFBdUIxaUMsQ0FBdkIsRUFBMEIwMEIsYUFBMUIsRUFBeUMwTixRQUF6QyxFQUFtREMsZUFBZSxHQUFmLEdBQXFCcmlDLENBQXJCLEdBQXlCLEdBQTVFLEVBQWlGbVMsb0JBQWpGLENBQVo7QUFDQSxZQUFJOHRCLGlCQUFpQjFhLEtBQXJCLEVBQTRCO0FBQzFCLGlCQUFPMGEsS0FBUDtBQUNEO0FBQ0Y7QUFDRCxhQUFPLElBQVA7QUFDRDtBQUNELFdBQU84QiwyQkFBMkJDLFFBQTNCLENBQVA7QUFDRDs7QUFFRCxXQUFTaEIsd0JBQVQsR0FBb0M7QUFDbEMsYUFBU2dCLFFBQVQsQ0FBa0J6Z0MsS0FBbEIsRUFBeUI0Z0MsUUFBekIsRUFBbUN6TixhQUFuQyxFQUFrRDBOLFFBQWxELEVBQTREQyxZQUE1RCxFQUEwRTtBQUN4RSxVQUFJSyxZQUFZbmhDLE1BQU00Z0MsUUFBTixDQUFoQjtBQUNBLFVBQUksQ0FBQ25rQyxlQUFlMGtDLFNBQWYsQ0FBTCxFQUFnQztBQUM5QixZQUFJQyxXQUFXQyxZQUFZRixTQUFaLENBQWY7QUFDQSxlQUFPLElBQUliLGFBQUosQ0FBa0IsYUFBYU8sUUFBYixHQUF3QixJQUF4QixHQUErQkMsWUFBL0IsR0FBOEMsWUFBOUMsSUFBOEQsTUFBTU0sUUFBTixHQUFpQixpQkFBakIsR0FBcUNqTyxhQUFyQyxHQUFxRCxvQ0FBbkgsQ0FBbEIsQ0FBUDtBQUNEO0FBQ0QsYUFBTyxJQUFQO0FBQ0Q7QUFDRCxXQUFPcU4sMkJBQTJCQyxRQUEzQixDQUFQO0FBQ0Q7O0FBRUQsV0FBU2QseUJBQVQsQ0FBbUM4QixhQUFuQyxFQUFrRDtBQUNoRCxhQUFTaEIsUUFBVCxDQUFrQnpnQyxLQUFsQixFQUF5QjRnQyxRQUF6QixFQUFtQ3pOLGFBQW5DLEVBQWtEME4sUUFBbEQsRUFBNERDLFlBQTVELEVBQTBFO0FBQ3hFLFVBQUksRUFBRTlnQyxNQUFNNGdDLFFBQU4sYUFBMkJhLGFBQTdCLENBQUosRUFBaUQ7QUFDL0MsWUFBSUMsb0JBQW9CRCxjQUFjbG9CLElBQWQsSUFBc0I0bEIsU0FBOUM7QUFDQSxZQUFJd0Msa0JBQWtCQyxhQUFhNWhDLE1BQU00Z0MsUUFBTixDQUFiLENBQXRCO0FBQ0EsZUFBTyxJQUFJTixhQUFKLENBQWtCLGFBQWFPLFFBQWIsR0FBd0IsSUFBeEIsR0FBK0JDLFlBQS9CLEdBQThDLFlBQTlDLElBQThELE1BQU1hLGVBQU4sR0FBd0IsaUJBQXhCLEdBQTRDeE8sYUFBNUMsR0FBNEQsY0FBMUgsS0FBNkksa0JBQWtCdU8saUJBQWxCLEdBQXNDLElBQW5MLENBQWxCLENBQVA7QUFDRDtBQUNELGFBQU8sSUFBUDtBQUNEO0FBQ0QsV0FBT2xCLDJCQUEyQkMsUUFBM0IsQ0FBUDtBQUNEOztBQUVELFdBQVNWLHFCQUFULENBQStCOEIsY0FBL0IsRUFBK0M7QUFDN0MsUUFBSSxDQUFDOWlDLE1BQU1DLE9BQU4sQ0FBYzZpQyxjQUFkLENBQUwsRUFBb0M7QUFDbEMxbEMsY0FBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLEdBQXdDa2lDLGFBQWEsb0VBQWIsQ0FBeEMsR0FBNkgsS0FBSyxDQUFsSTtBQUNBLGFBQU9LLDRCQUFQO0FBQ0Q7O0FBRUQsYUFBUzZCLFFBQVQsQ0FBa0J6Z0MsS0FBbEIsRUFBeUI0Z0MsUUFBekIsRUFBbUN6TixhQUFuQyxFQUFrRDBOLFFBQWxELEVBQTREQyxZQUE1RCxFQUEwRTtBQUN4RSxVQUFJSyxZQUFZbmhDLE1BQU00Z0MsUUFBTixDQUFoQjtBQUNBLFdBQUssSUFBSW5pQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlvakMsZUFBZWxqQyxNQUFuQyxFQUEyQ0YsR0FBM0MsRUFBZ0Q7QUFDOUMsWUFBSTJoQyxHQUFHZSxTQUFILEVBQWNVLGVBQWVwakMsQ0FBZixDQUFkLENBQUosRUFBc0M7QUFDcEMsaUJBQU8sSUFBUDtBQUNEO0FBQ0Y7O0FBRUQsVUFBSXFqQyxlQUFldjlCLEtBQUtDLFNBQUwsQ0FBZXE5QixjQUFmLENBQW5CO0FBQ0EsYUFBTyxJQUFJdkIsYUFBSixDQUFrQixhQUFhTyxRQUFiLEdBQXdCLElBQXhCLEdBQStCQyxZQUEvQixHQUE4QyxjQUE5QyxHQUErREssU0FBL0QsR0FBMkUsSUFBM0UsSUFBbUYsa0JBQWtCaE8sYUFBbEIsR0FBa0MscUJBQWxDLEdBQTBEMk8sWUFBMUQsR0FBeUUsR0FBNUosQ0FBbEIsQ0FBUDtBQUNEO0FBQ0QsV0FBT3RCLDJCQUEyQkMsUUFBM0IsQ0FBUDtBQUNEOztBQUVELFdBQVNYLHlCQUFULENBQW1DMEIsV0FBbkMsRUFBZ0Q7QUFDOUMsYUFBU2YsUUFBVCxDQUFrQnpnQyxLQUFsQixFQUF5QjRnQyxRQUF6QixFQUFtQ3pOLGFBQW5DLEVBQWtEME4sUUFBbEQsRUFBNERDLFlBQTVELEVBQTBFO0FBQ3hFLFVBQUksT0FBT1UsV0FBUCxLQUF1QixVQUEzQixFQUF1QztBQUNyQyxlQUFPLElBQUlsQixhQUFKLENBQWtCLGVBQWVRLFlBQWYsR0FBOEIsa0JBQTlCLEdBQW1EM04sYUFBbkQsR0FBbUUsa0RBQXJGLENBQVA7QUFDRDtBQUNELFVBQUlnTyxZQUFZbmhDLE1BQU00Z0MsUUFBTixDQUFoQjtBQUNBLFVBQUlRLFdBQVdDLFlBQVlGLFNBQVosQ0FBZjtBQUNBLFVBQUlDLGFBQWEsUUFBakIsRUFBMkI7QUFDekIsZUFBTyxJQUFJZCxhQUFKLENBQWtCLGFBQWFPLFFBQWIsR0FBd0IsSUFBeEIsR0FBK0JDLFlBQS9CLEdBQThDLFlBQTlDLElBQThELE1BQU1NLFFBQU4sR0FBaUIsaUJBQWpCLEdBQXFDak8sYUFBckMsR0FBcUQsd0JBQW5ILENBQWxCLENBQVA7QUFDRDtBQUNELFdBQUssSUFBSWgwQixHQUFULElBQWdCZ2lDLFNBQWhCLEVBQTJCO0FBQ3pCLFlBQUlBLFVBQVU3aUMsY0FBVixDQUF5QmEsR0FBekIsQ0FBSixFQUFtQztBQUNqQyxjQUFJdS9CLFFBQVE4QyxZQUFZTCxTQUFaLEVBQXVCaGlDLEdBQXZCLEVBQTRCZzBCLGFBQTVCLEVBQTJDME4sUUFBM0MsRUFBcURDLGVBQWUsR0FBZixHQUFxQjNoQyxHQUExRSxFQUErRXlSLG9CQUEvRSxDQUFaO0FBQ0EsY0FBSTh0QixpQkFBaUIxYSxLQUFyQixFQUE0QjtBQUMxQixtQkFBTzBhLEtBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxhQUFPLElBQVA7QUFDRDtBQUNELFdBQU84QiwyQkFBMkJDLFFBQTNCLENBQVA7QUFDRDs7QUFFRCxXQUFTVCxzQkFBVCxDQUFnQytCLG1CQUFoQyxFQUFxRDtBQUNuRCxRQUFJLENBQUNoakMsTUFBTUMsT0FBTixDQUFjK2lDLG1CQUFkLENBQUwsRUFBeUM7QUFDdkM1bEMsY0FBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLEdBQXdDa2lDLGFBQWEsd0VBQWIsQ0FBeEMsR0FBaUksS0FBSyxDQUF0STtBQUNBLGFBQU9LLDRCQUFQO0FBQ0Q7O0FBRUQsU0FBSyxJQUFJbmdDLElBQUksQ0FBYixFQUFnQkEsSUFBSXNqQyxvQkFBb0JwakMsTUFBeEMsRUFBZ0RGLEdBQWhELEVBQXFEO0FBQ25ELFVBQUl1akMsVUFBVUQsb0JBQW9CdGpDLENBQXBCLENBQWQ7QUFDQSxVQUFJLE9BQU91akMsT0FBUCxLQUFtQixVQUF2QixFQUFtQztBQUNqQ3pELHFCQUNFLHVGQUNBLFdBREEsR0FDYzBELHlCQUF5QkQsT0FBekIsQ0FEZCxHQUNrRCxZQURsRCxHQUNpRXZqQyxDQURqRSxHQUNxRSxHQUZ2RTtBQUlBLGVBQU9tZ0MsNEJBQVA7QUFDRDtBQUNGOztBQUVELGFBQVM2QixRQUFULENBQWtCemdDLEtBQWxCLEVBQXlCNGdDLFFBQXpCLEVBQW1Dek4sYUFBbkMsRUFBa0QwTixRQUFsRCxFQUE0REMsWUFBNUQsRUFBMEU7QUFDeEUsV0FBSyxJQUFJcmlDLElBQUksQ0FBYixFQUFnQkEsSUFBSXNqQyxvQkFBb0JwakMsTUFBeEMsRUFBZ0RGLEdBQWhELEVBQXFEO0FBQ25ELFlBQUl1akMsVUFBVUQsb0JBQW9CdGpDLENBQXBCLENBQWQ7QUFDQSxZQUFJdWpDLFFBQVFoaUMsS0FBUixFQUFlNGdDLFFBQWYsRUFBeUJ6TixhQUF6QixFQUF3QzBOLFFBQXhDLEVBQWtEQyxZQUFsRCxFQUFnRWx3QixvQkFBaEUsS0FBeUYsSUFBN0YsRUFBbUc7QUFDakcsaUJBQU8sSUFBUDtBQUNEO0FBQ0Y7O0FBRUQsYUFBTyxJQUFJMHZCLGFBQUosQ0FBa0IsYUFBYU8sUUFBYixHQUF3QixJQUF4QixHQUErQkMsWUFBL0IsR0FBOEMsZ0JBQTlDLElBQWtFLE1BQU0zTixhQUFOLEdBQXNCLElBQXhGLENBQWxCLENBQVA7QUFDRDtBQUNELFdBQU9xTiwyQkFBMkJDLFFBQTNCLENBQVA7QUFDRDs7QUFFRCxXQUFTYixpQkFBVCxHQUE2QjtBQUMzQixhQUFTYSxRQUFULENBQWtCemdDLEtBQWxCLEVBQXlCNGdDLFFBQXpCLEVBQW1Dek4sYUFBbkMsRUFBa0QwTixRQUFsRCxFQUE0REMsWUFBNUQsRUFBMEU7QUFDeEUsVUFBSSxDQUFDb0IsT0FBT2xpQyxNQUFNNGdDLFFBQU4sQ0FBUCxDQUFMLEVBQThCO0FBQzVCLGVBQU8sSUFBSU4sYUFBSixDQUFrQixhQUFhTyxRQUFiLEdBQXdCLElBQXhCLEdBQStCQyxZQUEvQixHQUE4QyxnQkFBOUMsSUFBa0UsTUFBTTNOLGFBQU4sR0FBc0IsMEJBQXhGLENBQWxCLENBQVA7QUFDRDtBQUNELGFBQU8sSUFBUDtBQUNEO0FBQ0QsV0FBT3FOLDJCQUEyQkMsUUFBM0IsQ0FBUDtBQUNEOztBQUVELFdBQVNSLHNCQUFULENBQWdDa0MsVUFBaEMsRUFBNEM7QUFDMUMsYUFBUzFCLFFBQVQsQ0FBa0J6Z0MsS0FBbEIsRUFBeUI0Z0MsUUFBekIsRUFBbUN6TixhQUFuQyxFQUFrRDBOLFFBQWxELEVBQTREQyxZQUE1RCxFQUEwRTtBQUN4RSxVQUFJSyxZQUFZbmhDLE1BQU00Z0MsUUFBTixDQUFoQjtBQUNBLFVBQUlRLFdBQVdDLFlBQVlGLFNBQVosQ0FBZjtBQUNBLFVBQUlDLGFBQWEsUUFBakIsRUFBMkI7QUFDekIsZUFBTyxJQUFJZCxhQUFKLENBQWtCLGFBQWFPLFFBQWIsR0FBd0IsSUFBeEIsR0FBK0JDLFlBQS9CLEdBQThDLGFBQTlDLEdBQThETSxRQUE5RCxHQUF5RSxJQUF6RSxJQUFpRixrQkFBa0JqTyxhQUFsQixHQUFrQyx1QkFBbkgsQ0FBbEIsQ0FBUDtBQUNEO0FBQ0QsV0FBSyxJQUFJaDBCLEdBQVQsSUFBZ0JnakMsVUFBaEIsRUFBNEI7QUFDMUIsWUFBSUgsVUFBVUcsV0FBV2hqQyxHQUFYLENBQWQ7QUFDQSxZQUFJLENBQUM2aUMsT0FBTCxFQUFjO0FBQ1o7QUFDRDtBQUNELFlBQUl0RCxRQUFRc0QsUUFBUWIsU0FBUixFQUFtQmhpQyxHQUFuQixFQUF3QmcwQixhQUF4QixFQUF1QzBOLFFBQXZDLEVBQWlEQyxlQUFlLEdBQWYsR0FBcUIzaEMsR0FBdEUsRUFBMkV5UixvQkFBM0UsQ0FBWjtBQUNBLFlBQUk4dEIsS0FBSixFQUFXO0FBQ1QsaUJBQU9BLEtBQVA7QUFDRDtBQUNGO0FBQ0QsYUFBTyxJQUFQO0FBQ0Q7QUFDRCxXQUFPOEIsMkJBQTJCQyxRQUEzQixDQUFQO0FBQ0Q7O0FBRUQsV0FBU04sNEJBQVQsQ0FBc0NnQyxVQUF0QyxFQUFrRDtBQUNoRCxhQUFTMUIsUUFBVCxDQUFrQnpnQyxLQUFsQixFQUF5QjRnQyxRQUF6QixFQUFtQ3pOLGFBQW5DLEVBQWtEME4sUUFBbEQsRUFBNERDLFlBQTVELEVBQTBFO0FBQ3hFLFVBQUlLLFlBQVluaEMsTUFBTTRnQyxRQUFOLENBQWhCO0FBQ0EsVUFBSVEsV0FBV0MsWUFBWUYsU0FBWixDQUFmO0FBQ0EsVUFBSUMsYUFBYSxRQUFqQixFQUEyQjtBQUN6QixlQUFPLElBQUlkLGFBQUosQ0FBa0IsYUFBYU8sUUFBYixHQUF3QixJQUF4QixHQUErQkMsWUFBL0IsR0FBOEMsYUFBOUMsR0FBOERNLFFBQTlELEdBQXlFLElBQXpFLElBQWlGLGtCQUFrQmpPLGFBQWxCLEdBQWtDLHVCQUFuSCxDQUFsQixDQUFQO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsVUFBSWlQLFVBQVVqTyxPQUFPLEVBQVAsRUFBV24wQixNQUFNNGdDLFFBQU4sQ0FBWCxFQUE0QnVCLFVBQTVCLENBQWQ7QUFDQSxXQUFLLElBQUloakMsR0FBVCxJQUFnQmlqQyxPQUFoQixFQUF5QjtBQUN2QixZQUFJSixVQUFVRyxXQUFXaGpDLEdBQVgsQ0FBZDtBQUNBLFlBQUksQ0FBQzZpQyxPQUFMLEVBQWM7QUFDWixpQkFBTyxJQUFJMUIsYUFBSixDQUNMLGFBQWFPLFFBQWIsR0FBd0IsSUFBeEIsR0FBK0JDLFlBQS9CLEdBQThDLFNBQTlDLEdBQTBEM2hDLEdBQTFELEdBQWdFLGlCQUFoRSxHQUFvRmcwQixhQUFwRixHQUFvRyxJQUFwRyxHQUNBLGdCQURBLEdBQ21CNXVCLEtBQUtDLFNBQUwsQ0FBZXhFLE1BQU00Z0MsUUFBTixDQUFmLEVBQWdDLElBQWhDLEVBQXNDLElBQXRDLENBRG5CLEdBRUEsZ0JBRkEsR0FFb0JyOEIsS0FBS0MsU0FBTCxDQUFlSyxPQUFPQyxJQUFQLENBQVlxOUIsVUFBWixDQUFmLEVBQXdDLElBQXhDLEVBQThDLElBQTlDLENBSGYsQ0FBUDtBQUtEO0FBQ0QsWUFBSXpELFFBQVFzRCxRQUFRYixTQUFSLEVBQW1CaGlDLEdBQW5CLEVBQXdCZzBCLGFBQXhCLEVBQXVDME4sUUFBdkMsRUFBaURDLGVBQWUsR0FBZixHQUFxQjNoQyxHQUF0RSxFQUEyRXlSLG9CQUEzRSxDQUFaO0FBQ0EsWUFBSTh0QixLQUFKLEVBQVc7QUFDVCxpQkFBT0EsS0FBUDtBQUNEO0FBQ0Y7QUFDRCxhQUFPLElBQVA7QUFDRDs7QUFFRCxXQUFPOEIsMkJBQTJCQyxRQUEzQixDQUFQO0FBQ0Q7O0FBRUQsV0FBU3lCLE1BQVQsQ0FBZ0JmLFNBQWhCLEVBQTJCO0FBQ3pCLG1CQUFlQSxTQUFmLHlDQUFlQSxTQUFmO0FBQ0UsV0FBSyxRQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0EsV0FBSyxXQUFMO0FBQ0UsZUFBTyxJQUFQO0FBQ0YsV0FBSyxTQUFMO0FBQ0UsZUFBTyxDQUFDQSxTQUFSO0FBQ0YsV0FBSyxRQUFMO0FBQ0UsWUFBSXBpQyxNQUFNQyxPQUFOLENBQWNtaUMsU0FBZCxDQUFKLEVBQThCO0FBQzVCLGlCQUFPQSxVQUFVblksS0FBVixDQUFnQmtaLE1BQWhCLENBQVA7QUFDRDtBQUNELFlBQUlmLGNBQWMsSUFBZCxJQUFzQjFrQyxlQUFlMGtDLFNBQWYsQ0FBMUIsRUFBcUQ7QUFDbkQsaUJBQU8sSUFBUDtBQUNEOztBQUVELFlBQUlqQyxhQUFhRixjQUFjbUMsU0FBZCxDQUFqQjtBQUNBLFlBQUlqQyxVQUFKLEVBQWdCO0FBQ2QsY0FBSUosV0FBV0ksV0FBVzkvQixJQUFYLENBQWdCK2hDLFNBQWhCLENBQWY7QUFDQSxjQUFJa0IsSUFBSjtBQUNBLGNBQUluRCxlQUFlaUMsVUFBVW1CLE9BQTdCLEVBQXNDO0FBQ3BDLG1CQUFPLENBQUMsQ0FBQ0QsT0FBT3ZELFNBQVNwcUIsSUFBVCxFQUFSLEVBQXlCNnRCLElBQWpDLEVBQXVDO0FBQ3JDLGtCQUFJLENBQUNMLE9BQU9HLEtBQUt6NkIsS0FBWixDQUFMLEVBQXlCO0FBQ3ZCLHVCQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0YsV0FORCxNQU1PO0FBQ0w7QUFDQSxtQkFBTyxDQUFDLENBQUN5NkIsT0FBT3ZELFNBQVNwcUIsSUFBVCxFQUFSLEVBQXlCNnRCLElBQWpDLEVBQXVDO0FBQ3JDLGtCQUFJQyxRQUFRSCxLQUFLejZCLEtBQWpCO0FBQ0Esa0JBQUk0NkIsS0FBSixFQUFXO0FBQ1Qsb0JBQUksQ0FBQ04sT0FBT00sTUFBTSxDQUFOLENBQVAsQ0FBTCxFQUF1QjtBQUNyQix5QkFBTyxLQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUFDRixTQXBCRCxNQW9CTztBQUNMLGlCQUFPLEtBQVA7QUFDRDs7QUFFRCxlQUFPLElBQVA7QUFDRjtBQUNFLGVBQU8sS0FBUDtBQTFDSjtBQTRDRDs7QUFFRCxXQUFTQyxRQUFULENBQWtCckIsUUFBbEIsRUFBNEJELFNBQTVCLEVBQXVDO0FBQ3JDO0FBQ0EsUUFBSUMsYUFBYSxRQUFqQixFQUEyQjtBQUN6QixhQUFPLElBQVA7QUFDRDs7QUFFRDtBQUNBLFFBQUlELFVBQVUsZUFBVixNQUErQixRQUFuQyxFQUE2QztBQUMzQyxhQUFPLElBQVA7QUFDRDs7QUFFRDtBQUNBLFFBQUksT0FBTzVrQyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDNGtDLHFCQUFxQjVrQyxNQUF6RCxFQUFpRTtBQUMvRCxhQUFPLElBQVA7QUFDRDs7QUFFRCxXQUFPLEtBQVA7QUFDRDs7QUFFRDtBQUNBLFdBQVM4a0MsV0FBVCxDQUFxQkYsU0FBckIsRUFBZ0M7QUFDOUIsUUFBSUMsa0JBQWtCRCxTQUFsQix5Q0FBa0JBLFNBQWxCLENBQUo7QUFDQSxRQUFJcGlDLE1BQU1DLE9BQU4sQ0FBY21pQyxTQUFkLENBQUosRUFBOEI7QUFDNUIsYUFBTyxPQUFQO0FBQ0Q7QUFDRCxRQUFJQSxxQkFBcUJ1QixNQUF6QixFQUFpQztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxhQUFPLFFBQVA7QUFDRDtBQUNELFFBQUlELFNBQVNyQixRQUFULEVBQW1CRCxTQUFuQixDQUFKLEVBQW1DO0FBQ2pDLGFBQU8sUUFBUDtBQUNEO0FBQ0QsV0FBT0MsUUFBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQSxXQUFTRyxjQUFULENBQXdCSixTQUF4QixFQUFtQztBQUNqQyxRQUFJLE9BQU9BLFNBQVAsS0FBcUIsV0FBckIsSUFBb0NBLGNBQWMsSUFBdEQsRUFBNEQ7QUFDMUQsYUFBTyxLQUFLQSxTQUFaO0FBQ0Q7QUFDRCxRQUFJQyxXQUFXQyxZQUFZRixTQUFaLENBQWY7QUFDQSxRQUFJQyxhQUFhLFFBQWpCLEVBQTJCO0FBQ3pCLFVBQUlELHFCQUFxQndCLElBQXpCLEVBQStCO0FBQzdCLGVBQU8sTUFBUDtBQUNELE9BRkQsTUFFTyxJQUFJeEIscUJBQXFCdUIsTUFBekIsRUFBaUM7QUFDdEMsZUFBTyxRQUFQO0FBQ0Q7QUFDRjtBQUNELFdBQU90QixRQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFdBQVNhLHdCQUFULENBQWtDcjZCLEtBQWxDLEVBQXlDO0FBQ3ZDLFFBQUlsQyxPQUFPNjdCLGVBQWUzNUIsS0FBZixDQUFYO0FBQ0EsWUFBUWxDLElBQVI7QUFDRSxXQUFLLE9BQUw7QUFDQSxXQUFLLFFBQUw7QUFDRSxlQUFPLFFBQVFBLElBQWY7QUFDRixXQUFLLFNBQUw7QUFDQSxXQUFLLE1BQUw7QUFDQSxXQUFLLFFBQUw7QUFDRSxlQUFPLE9BQU9BLElBQWQ7QUFDRjtBQUNFLGVBQU9BLElBQVA7QUFUSjtBQVdEOztBQUVEO0FBQ0EsV0FBU2s4QixZQUFULENBQXNCVCxTQUF0QixFQUFpQztBQUMvQixRQUFJLENBQUNBLFVBQVV0NkIsV0FBWCxJQUEwQixDQUFDczZCLFVBQVV0NkIsV0FBVixDQUFzQjBTLElBQXJELEVBQTJEO0FBQ3pELGFBQU80bEIsU0FBUDtBQUNEO0FBQ0QsV0FBT2dDLFVBQVV0NkIsV0FBVixDQUFzQjBTLElBQTdCO0FBQ0Q7O0FBRUQ2bEIsaUJBQWVkLGNBQWYsR0FBZ0NBLGNBQWhDO0FBQ0FjLGlCQUFlejlCLFNBQWYsR0FBMkJ5OUIsY0FBM0I7O0FBRUEsU0FBT0EsY0FBUDtBQUNELENBdmdCRCxDOzs7Ozs7OztBQ25DQTs7Ozs7O0FBTWE7QUFDYjs7OztBQUNBLElBQUl3RCx3QkFBd0IvOUIsT0FBTys5QixxQkFBbkM7QUFDQSxJQUFJdGtDLGlCQUFpQnVHLE9BQU80QixTQUFQLENBQWlCbkksY0FBdEM7QUFDQSxJQUFJdWtDLG1CQUFtQmgrQixPQUFPNEIsU0FBUCxDQUFpQnE4QixvQkFBeEM7O0FBRUEsU0FBU0MsUUFBVCxDQUFrQno5QixHQUFsQixFQUF1QjtBQUN0QixLQUFJQSxRQUFRLElBQVIsSUFBZ0JBLFFBQVEwVixTQUE1QixFQUF1QztBQUN0QyxRQUFNLElBQUlnb0IsU0FBSixDQUFjLHVEQUFkLENBQU47QUFDQTs7QUFFRCxRQUFPbitCLE9BQU9TLEdBQVAsQ0FBUDtBQUNBOztBQUVELFNBQVMyOUIsZUFBVCxHQUEyQjtBQUMxQixLQUFJO0FBQ0gsTUFBSSxDQUFDcCtCLE9BQU9zdkIsTUFBWixFQUFvQjtBQUNuQixVQUFPLEtBQVA7QUFDQTs7QUFFRDs7QUFFQTtBQUNBLE1BQUkrTyxRQUFRLElBQUlDLE1BQUosQ0FBVyxLQUFYLENBQVosQ0FSRyxDQVE2QjtBQUNoQ0QsUUFBTSxDQUFOLElBQVcsSUFBWDtBQUNBLE1BQUlyK0IsT0FBT3UrQixtQkFBUCxDQUEyQkYsS0FBM0IsRUFBa0MsQ0FBbEMsTUFBeUMsR0FBN0MsRUFBa0Q7QUFDakQsVUFBTyxLQUFQO0FBQ0E7O0FBRUQ7QUFDQSxNQUFJRyxRQUFRLEVBQVo7QUFDQSxPQUFLLElBQUk1a0MsSUFBSSxDQUFiLEVBQWdCQSxJQUFJLEVBQXBCLEVBQXdCQSxHQUF4QixFQUE2QjtBQUM1QjRrQyxTQUFNLE1BQU1GLE9BQU9HLFlBQVAsQ0FBb0I3a0MsQ0FBcEIsQ0FBWixJQUFzQ0EsQ0FBdEM7QUFDQTtBQUNELE1BQUk4a0MsU0FBUzErQixPQUFPdStCLG1CQUFQLENBQTJCQyxLQUEzQixFQUFrQ25nQyxHQUFsQyxDQUFzQyxVQUFVc2dDLENBQVYsRUFBYTtBQUMvRCxVQUFPSCxNQUFNRyxDQUFOLENBQVA7QUFDQSxHQUZZLENBQWI7QUFHQSxNQUFJRCxPQUFPbGtDLElBQVAsQ0FBWSxFQUFaLE1BQW9CLFlBQXhCLEVBQXNDO0FBQ3JDLFVBQU8sS0FBUDtBQUNBOztBQUVEO0FBQ0EsTUFBSW9rQyxRQUFRLEVBQVo7QUFDQSx5QkFBdUJwK0IsS0FBdkIsQ0FBNkIsRUFBN0IsRUFBaUNOLE9BQWpDLENBQXlDLFVBQVUyK0IsTUFBVixFQUFrQjtBQUMxREQsU0FBTUMsTUFBTixJQUFnQkEsTUFBaEI7QUFDQSxHQUZEO0FBR0EsTUFBSTcrQixPQUFPQyxJQUFQLENBQVksU0FBYyxFQUFkLEVBQWtCMitCLEtBQWxCLENBQVosRUFBc0Nwa0MsSUFBdEMsQ0FBMkMsRUFBM0MsTUFDRixzQkFERixFQUMwQjtBQUN6QixVQUFPLEtBQVA7QUFDQTs7QUFFRCxTQUFPLElBQVA7QUFDQSxFQXJDRCxDQXFDRSxPQUFPNlIsR0FBUCxFQUFZO0FBQ2I7QUFDQSxTQUFPLEtBQVA7QUFDQTtBQUNEOztBQUVEclUsT0FBT0MsT0FBUCxHQUFpQm1tQyxvQkFBb0JwK0IsT0FBT3N2QixNQUEzQixHQUFvQyxVQUFVcmpCLE1BQVYsRUFBa0I5TSxNQUFsQixFQUEwQjtBQUM5RSxLQUFJMi9CLElBQUo7QUFDQSxLQUFJQyxLQUFLYixTQUFTanlCLE1BQVQsQ0FBVDtBQUNBLEtBQUkreUIsT0FBSjs7QUFFQSxNQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSXBsQyxVQUFVQyxNQUE5QixFQUFzQ21sQyxHQUF0QyxFQUEyQztBQUMxQ0gsU0FBTzkrQixPQUFPbkcsVUFBVW9sQyxDQUFWLENBQVAsQ0FBUDs7QUFFQSxPQUFLLElBQUkza0MsR0FBVCxJQUFnQndrQyxJQUFoQixFQUFzQjtBQUNyQixPQUFJcmxDLGVBQWVjLElBQWYsQ0FBb0J1a0MsSUFBcEIsRUFBMEJ4a0MsR0FBMUIsQ0FBSixFQUFvQztBQUNuQ3lrQyxPQUFHemtDLEdBQUgsSUFBVXdrQyxLQUFLeGtDLEdBQUwsQ0FBVjtBQUNBO0FBQ0Q7O0FBRUQsTUFBSXlqQyxxQkFBSixFQUEyQjtBQUMxQmlCLGFBQVVqQixzQkFBc0JlLElBQXRCLENBQVY7QUFDQSxRQUFLLElBQUlsbEMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJb2xDLFFBQVFsbEMsTUFBNUIsRUFBb0NGLEdBQXBDLEVBQXlDO0FBQ3hDLFFBQUlva0MsaUJBQWlCempDLElBQWpCLENBQXNCdWtDLElBQXRCLEVBQTRCRSxRQUFRcGxDLENBQVIsQ0FBNUIsQ0FBSixFQUE2QztBQUM1Q21sQyxRQUFHQyxRQUFRcGxDLENBQVIsQ0FBSCxJQUFpQmtsQyxLQUFLRSxRQUFRcGxDLENBQVIsQ0FBTCxDQUFqQjtBQUNBO0FBQ0Q7QUFDRDtBQUNEOztBQUVELFFBQU9tbEMsRUFBUDtBQUNBLENBekJELEM7Ozs7Ozs7QUNoRUE7Ozs7Ozs7QUFPYTs7OztBQUViLElBQUlyRixlQUFlLHdCQUFXLENBQUUsQ0FBaEM7O0FBRUEsSUFBSXBpQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsTUFBSXVVLHVCQUF1QjdULG1CQUFPQSxDQUFDLEVBQVIsQ0FBM0I7QUFDQSxNQUFJZ25DLHFCQUFxQixFQUF6Qjs7QUFFQXhGLGlCQUFlLHNCQUFTbm9CLElBQVQsRUFBZTtBQUM1QixRQUFJb29CLFVBQVUsY0FBY3BvQixJQUE1QjtBQUNBLFFBQUksT0FBT3FvQixPQUFQLEtBQW1CLFdBQXZCLEVBQW9DO0FBQ2xDQSxjQUFRQyxLQUFSLENBQWNGLE9BQWQ7QUFDRDtBQUNELFFBQUk7QUFDRjtBQUNBO0FBQ0E7QUFDQSxZQUFNLElBQUl4YSxLQUFKLENBQVV3YSxPQUFWLENBQU47QUFDRCxLQUxELENBS0UsT0FBT0csQ0FBUCxFQUFVLENBQUU7QUFDZixHQVhEO0FBWUQ7O0FBRUQ7Ozs7Ozs7Ozs7O0FBV0EsU0FBU0wsY0FBVCxDQUF3QjBGLFNBQXhCLEVBQW1DelAsTUFBbkMsRUFBMkNzTSxRQUEzQyxFQUFxRDFOLGFBQXJELEVBQW9FOFEsUUFBcEUsRUFBOEU7QUFDNUUsTUFBSTluQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsU0FBSyxJQUFJNm5DLFlBQVQsSUFBeUJGLFNBQXpCLEVBQW9DO0FBQ2xDLFVBQUlBLFVBQVUxbEMsY0FBVixDQUF5QjRsQyxZQUF6QixDQUFKLEVBQTRDO0FBQzFDLFlBQUl4RixLQUFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNGO0FBQ0E7QUFDQSxjQUFJLE9BQU9zRixVQUFVRSxZQUFWLENBQVAsS0FBbUMsVUFBdkMsRUFBbUQ7QUFDakQsZ0JBQUloekIsTUFBTThTLE1BQ1IsQ0FBQ21QLGlCQUFpQixhQUFsQixJQUFtQyxJQUFuQyxHQUEwQzBOLFFBQTFDLEdBQXFELFNBQXJELEdBQWlFcUQsWUFBakUsR0FBZ0YsZ0JBQWhGLEdBQ0EsOEVBREEsV0FDd0ZGLFVBQVVFLFlBQVYsQ0FEeEYsSUFDa0gsSUFGMUcsQ0FBVjtBQUlBaHpCLGdCQUFJcUksSUFBSixHQUFXLHFCQUFYO0FBQ0Esa0JBQU1ySSxHQUFOO0FBQ0Q7QUFDRHd0QixrQkFBUXNGLFVBQVVFLFlBQVYsRUFBd0IzUCxNQUF4QixFQUFnQzJQLFlBQWhDLEVBQThDL1EsYUFBOUMsRUFBNkQwTixRQUE3RCxFQUF1RSxJQUF2RSxFQUE2RWp3QixvQkFBN0UsQ0FBUjtBQUNELFNBWkQsQ0FZRSxPQUFPdXpCLEVBQVAsRUFBVztBQUNYekYsa0JBQVF5RixFQUFSO0FBQ0Q7QUFDRCxZQUFJekYsU0FBUyxFQUFFQSxpQkFBaUIxYSxLQUFuQixDQUFiLEVBQXdDO0FBQ3RDdWEsdUJBQ0UsQ0FBQ3BMLGlCQUFpQixhQUFsQixJQUFtQywwQkFBbkMsR0FDQTBOLFFBREEsR0FDVyxJQURYLEdBQ2tCcUQsWUFEbEIsR0FDaUMsaUNBRGpDLEdBRUEsMkRBRkEsV0FFcUV4RixLQUZyRSx5Q0FFcUVBLEtBRnJFLEtBRTZFLElBRjdFLEdBR0EsaUVBSEEsR0FJQSxnRUFKQSxHQUtBLGlDQU5GO0FBU0Q7QUFDRCxZQUFJQSxpQkFBaUIxYSxLQUFqQixJQUEwQixFQUFFMGEsTUFBTUYsT0FBTixJQUFpQnVGLGtCQUFuQixDQUE5QixFQUFzRTtBQUNwRTtBQUNBO0FBQ0FBLDZCQUFtQnJGLE1BQU1GLE9BQXpCLElBQW9DLElBQXBDOztBQUVBLGNBQUkrQixRQUFRMEQsV0FBV0EsVUFBWCxHQUF3QixFQUFwQzs7QUFFQTFGLHVCQUNFLFlBQVlzQyxRQUFaLEdBQXVCLFNBQXZCLEdBQW1DbkMsTUFBTUYsT0FBekMsSUFBb0QrQixTQUFTLElBQVQsR0FBZ0JBLEtBQWhCLEdBQXdCLEVBQTVFLENBREY7QUFHRDtBQUNGO0FBQ0Y7QUFDRjtBQUNGOztBQUVEMWpDLE9BQU9DLE9BQVAsR0FBaUJ3aEMsY0FBakIsQzs7Ozs7Ozs7QUMxRkE7Ozs7Ozs7QUFPYTs7QUFFYixJQUFJMXRCLHVCQUF1QjdULG1CQUFPQSxDQUFDLEVBQVIsQ0FBM0I7O0FBRUEsU0FBU3FuQyxhQUFULEdBQXlCLENBQUU7O0FBRTNCdm5DLE9BQU9DLE9BQVAsR0FBaUIsWUFBVztBQUMxQixXQUFTdW5DLElBQVQsQ0FBY3JrQyxLQUFkLEVBQXFCNGdDLFFBQXJCLEVBQStCek4sYUFBL0IsRUFBOEMwTixRQUE5QyxFQUF3REMsWUFBeEQsRUFBc0VDLE1BQXRFLEVBQThFO0FBQzVFLFFBQUlBLFdBQVdud0Isb0JBQWYsRUFBcUM7QUFDbkM7QUFDQTtBQUNEO0FBQ0QsUUFBSU0sTUFBTSxJQUFJOFMsS0FBSixDQUNSLHlGQUNBLCtDQURBLEdBRUEsZ0RBSFEsQ0FBVjtBQUtBOVMsUUFBSXFJLElBQUosR0FBVyxxQkFBWDtBQUNBLFVBQU1ySSxHQUFOO0FBQ0Q7QUFDRG16QixPQUFLcFMsVUFBTCxHQUFrQm9TLElBQWxCO0FBQ0EsV0FBU0MsT0FBVCxHQUFtQjtBQUNqQixXQUFPRCxJQUFQO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsTUFBSWpGLGlCQUFpQjtBQUNuQnZ4QixXQUFPdzJCLElBRFk7QUFFbkJ4aUMsVUFBTXdpQyxJQUZhO0FBR25CMW1DLFVBQU0wbUMsSUFIYTtBQUluQm41QixZQUFRbTVCLElBSlc7QUFLbkIzbkMsWUFBUTJuQyxJQUxXO0FBTW5CemlDLFlBQVF5aUMsSUFOVztBQU9uQi9FLFlBQVErRSxJQVBXOztBQVNuQnoyQixTQUFLeTJCLElBVGM7QUFVbkJqeUIsYUFBU2t5QixPQVZVO0FBV25CeGlDLGFBQVN1aUMsSUFYVTtBQVluQjNFLGdCQUFZNEUsT0FaTztBQWFuQjd6QixVQUFNNHpCLElBYmE7QUFjbkJ4RSxjQUFVeUUsT0FkUztBQWVuQnYrQixXQUFPdStCLE9BZlk7QUFnQm5COXpCLGVBQVc4ekIsT0FoQlE7QUFpQm5CanlCLFdBQU9peUIsT0FqQlk7QUFrQm5CcEUsV0FBT29FO0FBbEJZLEdBQXJCOztBQXFCQWxGLGlCQUFlZCxjQUFmLEdBQWdDOEYsYUFBaEM7QUFDQWhGLGlCQUFlejlCLFNBQWYsR0FBMkJ5OUIsY0FBM0I7O0FBRUEsU0FBT0EsY0FBUDtBQUNELENBN0NELEM7Ozs7Ozs7Ozs7Ozs7UUNJZ0I5OEIsVyxHQUFBQSxXO1FBS0FDLFcsR0FBQUEsVztRQU9BQyxTLEdBQUFBLFM7UUFPQUMsWSxHQUFBQSxZO1FBSUFFLFMsR0FBQUEsUztRQUlBRCxXLEdBQUFBLFc7UUFJQUUsWSxHQUFBQSxZO1FBSUFYLE0sR0FBQUEsTTs7QUFwRGhCOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0lBRVFvRSxZLEdBQWlCeEksUyxDQUFqQndJLFk7OztBQUVSLFNBQVNrK0IsY0FBVCxDQUF3QjlpQyxTQUF4QixFQUFtQztBQUMvQixXQUFPQSxVQUFVVyxXQUFWLElBQXlCWCxVQUFVOFgsSUFBbkMsSUFBMkMsV0FBbEQ7QUFDSDs7QUFFRCxJQUFJaXJCLHNCQUFKO0FBQ0EsSUFBSUMsd0JBQXdCLE9BQTVCO0FBQ0EsSUFBSUMsc0JBQXNCLEVBQTFCO0FBQ0EsSUFBSUMsbUJBQW1CLEtBQXZCOztBQUVPLFNBQVNyaUMsV0FBVCxDQUFxQnNpQyxPQUFyQixFQUE4QjtBQUNqQ0osb0JBQWdCSSxPQUFoQjtBQUNBRiwwQkFBc0JFLFFBQVFILHFCQUFSLENBQXRCO0FBQ0g7O0FBRU0sU0FBU2xpQyxXQUFULENBQXFCc2lDLFFBQXJCLEVBQStCO0FBQ2xDLFFBQUlMLGFBQUosRUFBbUI7QUFDZkMsZ0NBQXdCSSxRQUF4QjtBQUNBSCw4QkFBc0JGLGNBQWNLLFFBQWQsQ0FBdEI7QUFDSDtBQUNKOztBQUVNLFNBQVNyaUMsU0FBVCxDQUFtQnRDLE1BQW5CLEVBQTJCO0FBQzlCd2tDLHVDQUNRRixnQkFBZ0JBLGNBQWNDLHFCQUFkLENBQWhCLEdBQXVELEVBRC9ELEVBRU92a0MsTUFGUDtBQUlIOztBQUVNLFNBQVN1QyxZQUFULENBQXNCcUQsR0FBdEIsRUFBMkI7QUFDOUI2K0IsdUJBQW1CNytCLFFBQVEsS0FBM0I7QUFDSDs7QUFFTSxTQUFTbkQsU0FBVCxHQUFxQjtBQUN4QixXQUFPK2hDLG1CQUFQO0FBQ0g7O0FBRU0sU0FBU2hpQyxXQUFULEdBQXVCO0FBQzFCLFdBQU8raEMscUJBQVA7QUFDSDs7QUFFTSxTQUFTN2hDLFlBQVQsR0FBd0I7QUFDM0IsV0FBTytoQyxnQkFBUDtBQUNIOztBQUVNLFNBQVMxaUMsTUFBVCxDQUFnQlIsU0FBaEIsRUFBeUM7QUFBQTs7QUFBQSxRQUFkUyxPQUFjLHVFQUFKLEVBQUk7O0FBQzVDLFFBQUlULFVBQVVnRixTQUFWLENBQW9CeUgscUJBQXBCLEtBQThDOE0sU0FBbEQsRUFBNkQ7QUFDekR2WixrQkFBVWdGLFNBQVYsQ0FBb0J5SCxxQkFBcEIsR0FBNEMsU0FBU0EscUJBQVQsQ0FDeENwTixTQUR3QyxFQUV4QzB3QixTQUZ3QyxFQUcxQztBQUNFLGdCQUFJLEtBQUt4eEIsS0FBTCxDQUFXRyxJQUFmLEVBQXFCO0FBQ2pCLHVCQUNJLENBQUNrRyxhQUFhLEtBQUtyRyxLQUFsQixFQUF5QmMsU0FBekIsQ0FBRCxJQUNBLENBQUN1RixhQUFhLEtBQUsyQyxLQUFsQixFQUF5QndvQixTQUF6QixDQUZMO0FBSUg7O0FBRUQsbUJBQU8sSUFBUDtBQUNILFNBWkQ7QUFhSDs7QUFmMkMsUUFpQnRDc1QsaUJBakJzQztBQUFBOztBQWtDeEMsbUNBQVk5a0MsS0FBWixFQUFtQjBPLE9BQW5CLEVBQTRCO0FBQUE7O0FBQUEseURBQ3hCLDRCQUFNMU8sS0FBTixFQUFhME8sT0FBYixDQUR3Qjs7QUFHeEIsa0JBQUtxMkIsWUFBTCxHQUFvQixNQUFLQSxZQUFMLENBQWtCcjNCLElBQWxCLE9BQXBCO0FBQ0Esa0JBQUtzM0IsV0FBTCxHQUFtQixNQUFLQSxXQUFMLENBQWlCdDNCLElBQWpCLE9BQW5CO0FBSndCO0FBSzNCOztBQXZDdUMsb0NBeUN4Q3EzQixZQXpDd0MseUJBeUMzQjluQixHQXpDMkIsRUF5Q3RCO0FBQUE7O0FBQ2QsaUJBQUtnb0IsU0FBTCxHQUFpQmhvQixHQUFqQjs7QUFFQSxnQkFBSSxLQUFLZ29CLFNBQUwsSUFBa0IvaUMsUUFBUXNKLFdBQTlCLEVBQTJDO0FBQ3ZDdEosd0JBQVFzSixXQUFSLENBQW9CekcsT0FBcEIsQ0FBNEIsZ0JBQVE7QUFDaEMsd0JBQU1LLFFBQVEsT0FBSzYvQixTQUFMLENBQWUxckIsSUFBZixDQUFkO0FBQ0Esd0JBQUksT0FBT25VLEtBQVAsS0FBaUIsVUFBckIsRUFBaUM7QUFDN0IsK0JBQUttVSxJQUFMLElBQWFuVSxNQUFNc0ksSUFBTixDQUFXLE9BQUt1M0IsU0FBaEIsQ0FBYjtBQUNILHFCQUZELE1BRU87QUFDSCwrQkFBSzFyQixJQUFMLElBQWFuVSxLQUFiO0FBQ0g7QUFDSixpQkFQRDtBQVFIO0FBQ0osU0F0RHVDOztBQUFBLG9DQXdEeEM0L0IsV0F4RHdDLDBCQXdEbkI7QUFDakIsZ0JBQUksS0FBS3QyQixPQUFMLENBQWFoTyxXQUFiLEtBQTZCLEtBQWpDLEVBQXdDO0FBQ3BDOUMsMEJBQUl3OUIsVUFBSjtBQUNIO0FBQ0osU0E1RHVDOztBQUFBLG9DQThEeENwWSxXQTlEd0MsMEJBOEQxQjtBQUNWLG1CQUFPLEtBQUtpaUIsU0FBWjtBQUNILFNBaEV1Qzs7QUFBQSxvQ0FrRXhDNWpDLE1BbEV3QyxxQkFrRS9CO0FBQUEseUJBQzRDLEtBQUtyQixLQURqRDtBQUFBLGdCQUNHQyxNQURILFVBQ0dBLE1BREg7QUFBQSxnQkFDV0MsTUFEWCxVQUNXQSxNQURYO0FBQUEsZ0JBQ21CQyxJQURuQixVQUNtQkEsSUFEbkI7QUFBQSxnQkFDeUJFLEdBRHpCLFVBQ3lCQSxHQUR6QjtBQUFBLGdCQUNpQzBILE1BRGpDOztBQUFBLDJCQU9ELEtBQUsyRyxPQVBKO0FBQUEsZ0JBR0RwTyxVQUhDLFlBR0RBLFVBSEM7QUFBQSwrQ0FJREMsVUFKQztBQUFBLGdCQUlEQSxVQUpDLHVDQUlZLEVBSlo7QUFBQSxnQkFLREMsUUFMQyxZQUtEQSxRQUxDO0FBQUEsZ0JBTURDLE9BTkMsWUFNREEsT0FOQzs7O0FBU0wsZ0JBQU0yQixjQUNGRixRQUFRaXhCLGFBQVIsSUFBeUJvUixlQUFlOWlDLFNBQWYsQ0FEN0I7QUFFQSxnQkFBTXlqQyxlQUFlLCtCQUNqQixFQUFFamxDLGNBQUYsRUFBVUMsY0FBVixFQUFrQkMsVUFBbEIsRUFBd0JFLFFBQXhCLEVBRGlCLEVBRWpCO0FBQ0lDLHNDQURKO0FBRUlDLHlDQUFpQm1rQyxtQkFBakIsRUFBeUNua0MsVUFBekMsQ0FGSjtBQUdJQyxrQ0FISjtBQUlJQyx5QkFBUyxPQUFPQSxPQUFQLEtBQW1CLFNBQW5CLEdBQStCQSxPQUEvQixHQUNMa2tDLHFCQUFxQixJQUFyQixHQUE0QixJQUE1QixHQUFtQzNwQjtBQUwzQyxhQUZpQixFQVNqQjVZLFdBVGlCLENBQXJCOztBQVlBLGdCQUFNK2lDLGtCQUFrQixDQUFDLFFBQUQsRUFBVyxRQUFYLEVBQXFCLE1BQXJCLEVBQTZCLEtBQTdCLEVBQW9DMUgsTUFBcEMsQ0FDcEIsVUFBQ2oyQixHQUFELEVBQU0rUixJQUFOLEVBQWU7QUFDWCxvQkFBSSxPQUFPMnJCLGFBQWEzckIsSUFBYixDQUFQLEtBQThCLFdBQWxDLEVBQStDO0FBQzNDL1Isd0JBQUkrUixJQUFKLElBQVkyckIsYUFBYTNyQixJQUFiLENBQVo7QUFDSDtBQUNELHVCQUFPL1IsR0FBUDtBQUNILGFBTm1CLEVBT3BCLEVBUG9CLENBQXhCOztBQVVBLGdCQUFNNDlCLFlBQVlsakMsUUFBUWk1QixTQUFSLEdBQ2RqNUIsUUFBUWk1QixTQUFSLENBQWtCcHpCLE1BQWxCLEVBQTBCLEtBQUtpOUIsV0FBL0IsQ0FEYyxHQUVkajlCLE1BRko7O0FBSUEsbUJBQ0ksOEJBQUMsU0FBRCxlQUNRcTlCLFNBRFIsRUFFUUQsZUFGUjtBQUdJLHFCQUFLLEtBQUtKO0FBSGQsZUFESjtBQU9ILFNBOUd1Qzs7QUFBQTtBQUFBLE1BaUJacDNCLGdCQUFNbE0sU0FqQk0sVUFrQmpDQyxTQWxCaUMsZ0JBbUJoQ0QsVUFBVUMsU0FBVixJQUF1QixFQW5CUztBQW9CcEN6QixnQkFBUTBCLG9CQUFVQyxNQXBCa0I7QUFxQnBDMUIsZ0JBQVF5QixvQkFBVWpGLE1BckJrQjtBQXNCcEN5RCxjQUFNd0Isb0JBQVVFLElBdEJvQjtBQXVCcEN4QixhQUFLc0Isb0JBQVVFO0FBdkJxQixlQXlCakM4TixZQXpCaUMsZ0JBMEJoQ2xPLFVBQVVrTyxZQUFWLElBQTBCLEVBMUJNO0FBMkJwQ3JQLG9CQUFZcUIsb0JBQVVDLE1BM0JjO0FBNEJwQ3JCLG9CQUFZb0Isb0JBQVVqRixNQTVCYztBQTZCcEM4RCxrQkFBVW1CLG9CQUFVRSxJQTdCZ0I7QUE4QnBDcEIsaUJBQVNrQixvQkFBVUUsSUE5QmlCO0FBK0JwQ25CLHFCQUFhaUIsb0JBQVVFO0FBL0JhO0FBaUJ0Q2lqQyxxQkFqQnNDOzs7QUFpSDVDQSxzQkFBa0IxaUMsV0FBbEIsZUFBMENtaUMsZUFBZTlpQyxTQUFmLENBQTFDOztBQUVBLHdDQUFvQnFqQyxpQkFBcEIsRUFBdUNyakMsU0FBdkM7O0FBRUEsV0FBT3FqQyxpQkFBUDtBQUNILEM7Ozs7Ozs7QUMxS1k7O0FBRWI7Ozs7O0FBSUEsSUFBSU8sZ0JBQWdCO0FBQ2hCcmpDLHVCQUFtQixJQURIO0FBRWhCMk4sa0JBQWMsSUFGRTtBQUdoQjVOLGtCQUFjLElBSEU7QUFJaEJLLGlCQUFhLElBSkc7QUFLaEJrakMscUJBQWlCLElBTEQ7QUFNaEJyViw4QkFBMEIsSUFOVjtBQU9oQnNWLFlBQVEsSUFQUTtBQVFoQjdqQyxlQUFXLElBUks7QUFTaEJnRSxVQUFNO0FBVFUsQ0FBcEI7O0FBWUEsSUFBSTgvQixnQkFBZ0I7QUFDaEJqc0IsVUFBTSxJQURVO0FBRWhCNWEsWUFBUSxJQUZRO0FBR2hCOEgsZUFBVyxJQUhLO0FBSWhCZy9CLFlBQVEsSUFKUTtBQUtoQkMsWUFBUSxJQUxRO0FBTWhCaG5DLGVBQVcsSUFOSztBQU9oQmluQyxXQUFPO0FBUFMsQ0FBcEI7O0FBVUEsSUFBSS9XLGlCQUFpQi9wQixPQUFPK3BCLGNBQTVCO0FBQ0EsSUFBSXdVLHNCQUFzQnYrQixPQUFPdStCLG1CQUFqQztBQUNBLElBQUlSLHdCQUF3Qi85QixPQUFPKzlCLHFCQUFuQztBQUNBLElBQUkvVCwyQkFBMkJocUIsT0FBT2dxQix3QkFBdEM7QUFDQSxJQUFJK1csaUJBQWlCL2dDLE9BQU8rZ0MsY0FBNUI7QUFDQSxJQUFJQyxrQkFBa0JELGtCQUFrQkEsZUFBZS9nQyxNQUFmLENBQXhDOztBQUVBLFNBQVNpaEMsb0JBQVQsQ0FBOEJDLGVBQTlCLEVBQStDQyxlQUEvQyxFQUFnRUMsU0FBaEUsRUFBMkU7QUFDdkUsUUFBSSxPQUFPRCxlQUFQLEtBQTJCLFFBQS9CLEVBQXlDO0FBQUU7O0FBRXZDLFlBQUlILGVBQUosRUFBcUI7QUFDakIsZ0JBQUlLLHFCQUFxQk4sZUFBZUksZUFBZixDQUF6QjtBQUNBLGdCQUFJRSxzQkFBc0JBLHVCQUF1QkwsZUFBakQsRUFBa0U7QUFDOURDLHFDQUFxQkMsZUFBckIsRUFBc0NHLGtCQUF0QyxFQUEwREQsU0FBMUQ7QUFDSDtBQUNKOztBQUVELFlBQUluaEMsT0FBT3MrQixvQkFBb0I0QyxlQUFwQixDQUFYOztBQUVBLFlBQUlwRCxxQkFBSixFQUEyQjtBQUN2Qjk5QixtQkFBT0EsS0FBS1osTUFBTCxDQUFZMCtCLHNCQUFzQm9ELGVBQXRCLENBQVosQ0FBUDtBQUNIOztBQUVELGFBQUssSUFBSXZuQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlxRyxLQUFLbkcsTUFBekIsRUFBaUMsRUFBRUYsQ0FBbkMsRUFBc0M7QUFDbEMsZ0JBQUlVLE1BQU0yRixLQUFLckcsQ0FBTCxDQUFWO0FBQ0EsZ0JBQUksQ0FBQzRtQyxjQUFjbG1DLEdBQWQsQ0FBRCxJQUF1QixDQUFDcW1DLGNBQWNybUMsR0FBZCxDQUF4QixLQUErQyxDQUFDOG1DLFNBQUQsSUFBYyxDQUFDQSxVQUFVOW1DLEdBQVYsQ0FBOUQsQ0FBSixFQUFtRjtBQUMvRSxvQkFBSWduQyxhQUFhdFgseUJBQXlCbVgsZUFBekIsRUFBMEM3bUMsR0FBMUMsQ0FBakI7QUFDQSxvQkFBSTtBQUFFO0FBQ0Z5dkIsbUNBQWVtWCxlQUFmLEVBQWdDNW1DLEdBQWhDLEVBQXFDZ25DLFVBQXJDO0FBQ0gsaUJBRkQsQ0FFRSxPQUFPaGxDLENBQVAsRUFBVSxDQUFFO0FBQ2pCO0FBQ0o7O0FBRUQsZUFBTzRrQyxlQUFQO0FBQ0g7O0FBRUQsV0FBT0EsZUFBUDtBQUNIOztBQUVEbHBDLE9BQU9DLE9BQVAsR0FBaUJncEMsb0JBQWpCLEM7Ozs7Ozs7Ozs7UUN0Q2dCL2tCLEUsR0FBQUEsRTtRQW1CQXFsQixJLEdBQUFBLEk7QUFoRGhCOzs7Ozs7O0FBT08sU0FBUzFsQixJQUFULENBQWNqUSxJQUFkLEVBQW9CNDFCLFNBQXBCLEVBQStCNStCLFFBQS9CLEVBQXlDNitCLFVBQXpDLEVBQXFEO0FBQ3hEO0FBQ0EsUUFBSTcxQixLQUFLODFCLG1CQUFULEVBQThCO0FBQzFCOTFCLGFBQUs4MUIsbUJBQUwsQ0FBeUJGLFNBQXpCLEVBQW9DNStCLFFBQXBDLEVBQThDNitCLGNBQWMsS0FBNUQ7QUFDSDtBQUNKOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7O0FBZU8sU0FBU3ZsQixFQUFULENBQWF0USxJQUFiLEVBQW1CNDFCLFNBQW5CLEVBQThCNStCLFFBQTlCLEVBQXdDNitCLFVBQXhDLEVBQW9EO0FBQ3ZEO0FBQ0EsUUFBSTcxQixLQUFLKzFCLGdCQUFULEVBQTJCO0FBQ3ZCLzFCLGFBQUsrMUIsZ0JBQUwsQ0FBc0JILFNBQXRCLEVBQWlDNStCLFFBQWpDLEVBQTJDNitCLGNBQWMsS0FBekQ7QUFDSDs7QUFFRCxXQUFPO0FBQ0g1bEIsYUFBSztBQUFBLG1CQUFNQSxLQUFJalEsSUFBSixFQUFVNDFCLFNBQVYsRUFBcUI1K0IsUUFBckIsRUFBK0I2K0IsVUFBL0IsQ0FBTjtBQUFBO0FBREYsS0FBUDtBQUdIOztBQUVEOzs7Ozs7OztBQVFPLFNBQVNGLElBQVQsQ0FBZTMxQixJQUFmLEVBQXFCNDFCLFNBQXJCLEVBQWdDNStCLFFBQWhDLEVBQTBDNitCLFVBQTFDLEVBQXNEO0FBQ3pELFdBQU92bEIsR0FBR3RRLElBQUgsRUFBUzQxQixTQUFULEVBQW9CLFNBQVNJLElBQVQsR0FBd0I7QUFBQSwwQ0FBTjdtQyxJQUFNO0FBQU5BLGdCQUFNO0FBQUE7O0FBQy9DNkgsaUJBQVN2SSxLQUFULENBQWUsSUFBZixFQUFxQlUsSUFBckI7O0FBRUE7QUFDQThnQixhQUFJalEsSUFBSixFQUFVNDFCLFNBQVYsRUFBcUJJLElBQXJCLEVBQTJCSCxVQUEzQjtBQUNILEtBTE0sRUFLSkEsVUFMSSxDQUFQO0FBTUgsQzs7Ozs7Ozs7Ozs7UUN4Q2U5b0IsUyxHQUFBQSxTO1FBd0JBeFYsTyxHQUFBQSxPO1FBb0JBMCtCLFcsR0FBQUEsVzs7QUEzRGhCOztBQUVBOzs7QUFHTyxJQUFNajdCLHNCQUFPLFNBQVBBLElBQU8sR0FBTSxDQUFFLENBQXJCOztBQUVQOzs7Ozs7OztBQVFPLFNBQVMrUixTQUFULEdBQTRCO0FBQUEsc0NBQUxtcEIsR0FBSztBQUFMQSxXQUFLO0FBQUE7O0FBQy9CLFFBQUlBLElBQUlob0MsTUFBSixLQUFlLENBQW5CLEVBQXNCO0FBQ2xCLGVBQU9nb0MsSUFBSSxDQUFKLENBQVA7QUFDSDs7QUFFRCxXQUFPLFNBQVNDLGVBQVQsR0FBbUM7QUFBQSwyQ0FBTmhuQyxJQUFNO0FBQU5BLGdCQUFNO0FBQUE7O0FBQ3RDLGFBQUssSUFBSW5CLElBQUksQ0FBUixFQUFXZ1IsSUFBSWszQixJQUFJaG9DLE1BQXhCLEVBQWdDRixJQUFJZ1IsQ0FBcEMsRUFBdUNoUixHQUF2QyxFQUE0QztBQUN4QyxnQkFBSWtvQyxJQUFJbG9DLENBQUosS0FBVWtvQyxJQUFJbG9DLENBQUosRUFBT1MsS0FBckIsRUFBNEI7QUFDeEJ5bkMsb0JBQUlsb0MsQ0FBSixFQUFPUyxLQUFQLENBQWEsSUFBYixFQUFtQlUsSUFBbkI7QUFDSDtBQUNKO0FBQ0osS0FORDtBQU9IOztBQUVEOzs7Ozs7Ozs7O0FBVU8sU0FBU29JLE9BQVQsQ0FBa0I2K0IsR0FBbEIsRUFBdUJGLEdBQXZCLEVBQTRCRyxFQUE1QixFQUFnQztBQUNuQyxRQUFJLE9BQU9ILEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUN6QkEsY0FBTSxDQUFDQSxHQUFELENBQU47QUFDSDs7QUFFRDtBQUNBRyxTQUFLQSxNQUFNRCxHQUFYOztBQUVBRixRQUFJNWhDLE9BQUosQ0FBWSxrQkFBVTtBQUNsQjtBQUNBK2hDLFdBQUdDLE1BQUgsSUFBYUQsR0FBR0MsTUFBSCxFQUFXcjVCLElBQVgsQ0FBZ0JtNUIsR0FBaEIsQ0FBYjtBQUNILEtBSEQ7QUFJSDs7QUFFRDs7Ozs7O0FBTU8sU0FBU0gsV0FBVCxDQUFzQmwvQixHQUF0QixFQUEyQncvQixPQUEzQixFQUFvRDtBQUFBLFFBQWhCQyxPQUFnQix1RUFBTng3QixJQUFNOztBQUN2RCxRQUFJLHVCQUFVakUsR0FBVixDQUFKLEVBQW9CO0FBQ2hCLGVBQU9BLElBQUliLElBQUosQ0FBUyxrQkFBVTtBQUN0QnFnQyxvQkFBUTdyQixNQUFSO0FBQ0EsbUJBQU9BLE1BQVA7QUFDSCxTQUhNLEVBR0orckIsS0FISSxDQUdFLGFBQUs7QUFDVkQsb0JBQVE5bEMsQ0FBUjtBQUNBO0FBQ0gsU0FOTSxDQUFQO0FBT0g7O0FBRUQsV0FBT3FHLFFBQVEsS0FBUixHQUFnQncvQixRQUFReC9CLEdBQVIsQ0FBaEIsR0FBK0J5L0IsUUFBUXovQixHQUFSLENBQXRDO0FBQ0gsQzs7Ozs7Ozs7OztRQ3pEZTR6QixVLEdBQUFBLFU7UUFjQWg3QixPLEdBQUFBLE87O0FBNUJoQjs7QUFFQTs7QUFFQTs7Ozs7Ozs7OztBQVVPLFNBQVNnN0IsVUFBVCxDQUFxQnA3QixLQUFyQixFQUE0Qm1uQyxPQUE1QixFQUFxQzE4QixTQUFyQyxFQUFnRDtBQUNuRDtBQUNBLFFBQUksQ0FBQyx3QkFBRCxJQUFtQixPQUFPZzBCLE9BQVAsS0FBbUIsV0FBdEMsSUFBcURBLFFBQVFDLEtBQWpFLEVBQXdFO0FBQ3BFLGVBQU9ELFFBQVFDLEtBQVIsQ0FDSCxnQkFBYzErQixLQUFkLDhCQUE0Q3lLLFNBQTVDLHdCQUNTMDhCLE9BRFQsdUJBREcsQ0FBUDtBQUlIO0FBQ0o7O0FBRUQ7Ozs7QUFJTyxTQUFTL21DLE9BQVQsQ0FBa0JnbkMsR0FBbEIsRUFBdUI7QUFDMUI7QUFDQSxRQUFJLE9BQU8zSSxPQUFQLEtBQW1CLFdBQW5CLElBQWtDQSxRQUFRQyxLQUE5QyxFQUFxRDtBQUNqRCxlQUFPRCxRQUFRQyxLQUFSLGVBQTBCMEksR0FBMUIsQ0FBUDtBQUNIO0FBQ0osQzs7Ozs7Ozs7Ozs7O0FDakNEOztBQUNBOztBQUVBLElBQU1DLHlCQUF5QjtBQUMzQkMscUJBQWlCLG9CQURVO0FBRTNCQyxnQkFBWSxlQUZlO0FBRzNCOW9CLGVBQVc7QUFIZ0IsQ0FBL0I7O0FBTUEsSUFBTStvQix1QkFBdUI7QUFDekJDLHNCQUFrQixxQkFETztBQUV6QkMsaUJBQWEsZ0JBRlk7QUFHekJDLGdCQUFZO0FBSGEsQ0FBN0I7O0FBTUE7Ozs7OztBQU1BLFNBQVNDLFdBQVQsQ0FBc0J0YixLQUF0QixFQUE2QjtBQUN6QjtBQUNBLFFBQUksQ0FBQ2pWLFdBQUwsRUFBYTtBQUNULGVBQU8sS0FBUDtBQUNIOztBQUVELFFBQU13d0IsS0FBSzcyQixTQUFTc0csYUFBVCxDQUF1QixLQUF2QixDQUFYO0FBQ0EsUUFBSTlQLE1BQU0sS0FBVjs7QUFFQSxzQkFBSzhrQixLQUFMLEVBQVksVUFBQ2huQixHQUFELEVBQU1uRyxHQUFOLEVBQWM7QUFDdEI7QUFDQSxZQUFJMG9DLEdBQUc3OEIsS0FBSCxDQUFTN0wsR0FBVCxNQUFrQjZiLFNBQXRCLEVBQWlDO0FBQzdCeFQsa0JBQU0sRUFBQ3daLEtBQUsxYixHQUFOLEVBQU47QUFDQSxtQkFBTyxLQUFQO0FBQ0g7QUFDSixLQU5EOztBQVFBLFdBQU9rQyxHQUFQO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BLFNBQVNzZ0MsV0FBVCxDQUFzQnhiLEtBQXRCLEVBQTZCO0FBQ3pCO0FBQ0EsUUFBSSxDQUFDalYsV0FBTCxFQUFhO0FBQ1QsZUFBTyxLQUFQO0FBQ0g7O0FBRUQsUUFBTXd3QixLQUFLNzJCLFNBQVNzRyxhQUFULENBQXVCLEtBQXZCLENBQVg7QUFDQSxRQUFJOVAsTUFBTSxLQUFWOztBQUVBLHNCQUFLOGtCLEtBQUwsRUFBWSxVQUFDaG5CLEdBQUQsRUFBTW5HLEdBQU4sRUFBYztBQUN0QiwwQkFBS21HLEdBQUwsRUFBVSxnQkFBUTtBQUNkLGdCQUFJO0FBQ0F1aUMsbUJBQUc3OEIsS0FBSCxDQUFTN0wsR0FBVCxJQUFnQmdFLElBQWhCO0FBQ0FxRSxzQkFBTUEsT0FBT3FnQyxHQUFHNzhCLEtBQUgsQ0FBUzdMLEdBQVQsTUFBa0JnRSxJQUEvQjtBQUNILGFBSEQsQ0FHRSxPQUFPaEMsQ0FBUCxFQUFVO0FBQ1I7QUFDSDtBQUNELG1CQUFPLENBQUNxRyxHQUFSLENBUGMsQ0FPRDtBQUNoQixTQVJEOztBQVVBLGVBQU8sQ0FBQ0EsR0FBUjtBQUNILEtBWkQ7O0FBY0EsV0FBT0EsR0FBUDtBQUNIOztBQUVEOzs7OztBQUtPLElBQU1pWCxnQ0FBWW1wQixZQUFZUCxzQkFBWixDQUFsQjs7QUFFUDs7Ozs7QUFLTyxJQUFNTSxrQ0FBYUMsWUFBWUosb0JBQVosQ0FBbkI7O0FBRVA7Ozs7QUFJTyxJQUFNTyxzQkFBT0QsWUFBWTtBQUM1QjNqQixhQUFTLENBQUMsTUFBRCxFQUFTLGNBQVQsRUFBeUIsV0FBekIsRUFBc0MsYUFBdEM7QUFEbUIsQ0FBWixDQUFiLEM7Ozs7Ozs7Ozs7UUNsQ1M3RyxnQixHQUFBQSxnQjtRQXdCQUQsaUIsR0FBQUEsaUI7UUFPQTJxQixrQixHQUFBQSxrQjtRQU9BenFCLGlCLEdBQUFBLGlCO1FBZ0JBMHFCLGEsR0FBQUEsYTs7QUEvR2hCOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUtBOzs7Ozs7QUFNQSxTQUFTQyxVQUFULENBQW9CejNCLElBQXBCLEVBQTBCO0FBQ3RCLFdBQU9BLElBQVAsRUFBYTtBQUNULFlBQUlBLFNBQVNPLFNBQVNnSCxJQUFsQixJQUEwQnZILFNBQVNPLFNBQVM2TSxlQUFoRCxFQUFpRTtBQUM3RDtBQUNIO0FBQ0QsWUFBSXBOLEtBQUt6RixLQUFMLENBQVdtWixPQUFYLEtBQXVCLE1BQXZCLElBQWlDMVQsS0FBS3pGLEtBQUwsQ0FBV205QixVQUFYLEtBQTBCLFFBQS9ELEVBQXlFO0FBQ3JFLG1CQUFPLEtBQVA7QUFDSDtBQUNEMTNCLGVBQU9BLEtBQUtuSSxVQUFaO0FBQ0g7QUFDRCxXQUFPLElBQVA7QUFDSDs7QUFFRDs7Ozs7O0FBTUEsU0FBUzgvQixZQUFULENBQXNCMzNCLElBQXRCLEVBQTRCO0FBQ3hCLFFBQU00M0IsV0FBVzUzQixLQUFLNDNCLFFBQUwsQ0FBY3R2QixXQUFkLEVBQWpCO0FBQ0EsUUFBTWpPLFdBQVd3OUIsU0FBUzczQixLQUFLODNCLFlBQUwsQ0FBa0IsVUFBbEIsQ0FBVCxFQUF3QyxFQUF4QyxDQUFqQjtBQUNBLFFBQU1DLGNBQWMsQ0FBQ0MsTUFBTTM5QixRQUFOLENBQUQsSUFBb0JBLFdBQVcsQ0FBQyxDQUFwRDs7QUFFQSxRQUFJbzlCLFdBQVd6M0IsSUFBWCxDQUFKLEVBQXNCO0FBQ2xCLFlBQUk0M0IsYUFBYSxPQUFqQixFQUEwQjtBQUN0QixtQkFBTyxDQUFDNTNCLEtBQUs3SCxRQUFOLElBQWtCNkgsS0FBSy9LLElBQUwsS0FBYyxRQUF2QztBQUNILFNBRkQsTUFFTyxJQUFJLENBQUMsUUFBRCxFQUFXLFVBQVgsRUFBdUIsUUFBdkIsRUFBaUNWLE9BQWpDLENBQXlDcWpDLFFBQXpDLElBQXFELENBQUMsQ0FBMUQsRUFBNkQ7QUFDaEUsbUJBQU8sQ0FBQzUzQixLQUFLN0gsUUFBYjtBQUNILFNBRk0sTUFFQSxJQUFJeS9CLGFBQWEsR0FBakIsRUFBc0I7QUFDekIsbUJBQVE1M0IsS0FBSzgzQixZQUFMLENBQWtCLE1BQWxCLEtBQTZCQyxXQUFyQztBQUNILFNBRk0sTUFFQTtBQUNILG1CQUFPQSxXQUFQO0FBQ0g7QUFDSjtBQUNELFdBQU8sS0FBUDtBQUNIOztBQUVEOzs7OztBQUtPLFNBQVNsckIsZ0JBQVQsQ0FBMEI3TSxJQUExQixFQUFnQztBQUNuQyxRQUFNaTRCLE1BQU0sRUFBWjtBQUNBLFFBQU1DLFdBQVdsNEIsS0FBS200QixnQkFBTCxDQUFzQixHQUF0QixDQUFqQjs7QUFFQSxzQkFBS0QsUUFBTCxFQUFlLGdCQUFRO0FBQ25CLFlBQUlQLGFBQWFqbEMsSUFBYixDQUFKLEVBQXdCO0FBQ3BCLGdCQUFNMGxDLFNBQVMxbEMsS0FBS29sQyxZQUFMLENBQWtCLGlCQUFsQixJQUF1QyxTQUF2QyxHQUFtRCxNQUFsRTtBQUNBRyxnQkFBSUcsTUFBSixFQUFZMWxDLElBQVo7QUFDSDtBQUNKLEtBTEQ7O0FBT0EsUUFBSWlsQyxhQUFhMzNCLElBQWIsQ0FBSixFQUF3QjtBQUNwQmk0QixZQUFJN2xCLE9BQUosQ0FBWXBTLElBQVo7QUFDSDs7QUFFRCxXQUFPaTRCLEdBQVA7QUFDSDs7QUFFRDtBQUNBLElBQUlJLG1CQUFtQixJQUF2Qjs7QUFFQTs7O0FBR08sU0FBU3pyQixpQkFBVCxHQUE2QjtBQUNoQ3lyQix1QkFBbUI5M0IsU0FBUyszQixhQUE1QjtBQUNIOztBQUVEOzs7QUFHTyxTQUFTZixrQkFBVCxHQUE4QjtBQUNqQ2MsdUJBQW1CLElBQW5CO0FBQ0g7O0FBRUQ7OztBQUdPLFNBQVN2ckIsaUJBQVQsR0FBNkI7QUFDaEMsUUFBSXVyQixnQkFBSixFQUFzQjtBQUNsQixZQUFJO0FBQ0E7QUFDQUEsNkJBQWlCOXFDLEtBQWpCO0FBQ0gsU0FIRCxDQUdFLE9BQU9tRCxDQUFQLEVBQVU7QUFDUjtBQUNIO0FBQ0o7QUFDSjs7QUFFRDs7Ozs7QUFLTyxTQUFTOG1DLGFBQVQsQ0FBdUJ4M0IsSUFBdkIsRUFBNkJ0UCxDQUE3QixFQUFnQztBQUNuQyxRQUFJQSxFQUFFdVEsT0FBRixLQUFjdlQsa0JBQVFrZCxHQUExQixFQUErQjtBQUMzQixZQUFNMnRCLGNBQWMxckIsaUJBQWlCN00sSUFBakIsQ0FBcEI7QUFDQSxZQUFNdzRCLFdBQVdELFlBQVlycUMsTUFBWixHQUFxQixDQUF0QztBQUNBLFlBQU1xTixRQUFRZzlCLFlBQVloa0MsT0FBWixDQUFvQmdNLFNBQVMrM0IsYUFBN0IsQ0FBZDs7QUFFQSxZQUFJLzhCLFFBQVEsQ0FBQyxDQUFiLEVBQWdCO0FBQ1osZ0JBQUkyZSxjQUFjM2UsU0FBUzdLLEVBQUUrbkMsUUFBRixHQUFhLENBQUMsQ0FBZCxHQUFrQixDQUEzQixDQUFsQjtBQUNBdmUsMEJBQWMsQ0FBZCxLQUFvQkEsY0FBY3NlLFFBQWxDO0FBQ0F0ZSwwQkFBY3NlLFFBQWQsS0FBMkJ0ZSxjQUFjLENBQXpDO0FBQ0FxZSx3QkFBWXJlLFdBQVosRUFBeUIzc0IsS0FBekI7QUFDQW1ELGNBQUUySSxjQUFGO0FBQ0g7QUFDSjtBQUNKLEM7Ozs7Ozs7Ozs7O2tCQ2xIYyxVQUFVN0osTUFBVixFQUFrQjtBQUM3QkEsV0FBU0EsVUFBVSxFQUFuQjs7QUFFQSxTQUFPQSxTQUFTLENBQUNrcEMsV0FBRCxFQUFjbG1DLFFBQWQsQ0FBdUIsRUFBdkIsQ0FBaEI7QUFDSCxDOztBQWZELElBQUlrbUMsWUFBWXhHLEtBQUs1dkIsR0FBTCxFQUFoQjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGQTs7Ozs7O0FBRUE7Ozs7Ozs7O0FBUUEsSUFBTXEyQixVQUFVLFNBQVZBLE9BQVUsQ0FBQ3ZyQyxHQUFELEVBQU13ckMsRUFBTixFQUFhO0FBQ3pCLFFBQU1sdUIsU0FBUyxFQUFmO0FBQ0EsU0FBSyxJQUFNaGMsR0FBWCxJQUFrQnRCLEdBQWxCLEVBQXVCO0FBQ25CLFlBQUlnSCxPQUFPNEIsU0FBUCxDQUFpQm5JLGNBQWpCLENBQWdDYyxJQUFoQyxDQUFxQ3ZCLEdBQXJDLEVBQTBDc0IsR0FBMUMsQ0FBSixFQUFvRDtBQUNoRCxnQkFBTXlJLFFBQVEvSixJQUFJc0IsR0FBSixDQUFkO0FBQ0EsZ0JBQU1tcUMsU0FBU0QsR0FBR2xxQyxHQUFILEVBQVF5SSxLQUFSLENBQWY7QUFDQXVULG1CQUFPbXVCLE1BQVAsSUFBaUIxaEMsS0FBakI7QUFDSDtBQUNKOztBQUVELFdBQU91VCxNQUFQO0FBQ0gsQ0FYRDs7QUFhQTs7Ozs7O0FBTUEsSUFBTW91QixhQUFhLFNBQWJBLFVBQWE7QUFBQSxXQUNmcHFDLElBQUl1SCxPQUFKLENBQVksZ0JBQVosRUFBOEIsVUFBQ25CLEtBQUQsRUFBUWlrQyxFQUFSLEVBQVlDLEVBQVo7QUFBQSxlQUFtQkEsR0FBRzF3QixXQUFILEVBQW5CO0FBQUEsS0FBOUIsQ0FEZTtBQUFBLENBQW5COztBQUdBOzs7O0FBSUEsSUFBTTJ3QixtQkFBbUIsU0FBbkJBLGdCQUFtQjtBQUFBLFdBQVVOLFFBQVFwbEMsTUFBUixFQUFnQnVsQyxVQUFoQixDQUFWO0FBQUEsQ0FBekI7O0FBRUE7Ozs7O0FBS0EsSUFBTTFtQyxXQUFXLFNBQVhBLFFBQVcsT0FBZTZMLE9BQWY7QUFBQSxRQUFHbE4sUUFBSCxRQUFHQSxRQUFIO0FBQUEsV0FDYixPQUFPQSxRQUFQLEtBQW9CLFVBQXBCLEdBQWlDQSxTQUFTa29DLGlCQUFpQmg3QixPQUFqQixDQUFULENBQWpDLEdBQXVFLElBRDFEO0FBQUEsQ0FBakI7O0FBR0E7Ozs7O0FBS0E3TCxTQUFTbkIsU0FBVCxHQUFxQjtBQUNqQjtBQUNBO0FBQ0FGLGNBQVVHLG9CQUFVaEU7QUFISCxDQUFyQjs7QUFNQTs7Ozs7QUFLQWtGLFNBQVM4TSxZQUFULEdBQXdCO0FBQ3BCclAsZ0JBQVlxQixvQkFBVUMsTUFERjtBQUVwQnJCLGdCQUFZb0Isb0JBQVVqRixNQUZGO0FBR3BCOEQsY0FBVW1CLG9CQUFVRSxJQUhBO0FBSXBCaVYsWUFBUW5WLG9CQUFVRSxJQUpFO0FBS3BCbkIsaUJBQWFpQixvQkFBVUU7QUFMSCxDQUF4Qjs7a0JBUWVnQixROzs7Ozs7Ozs7Ozs7OztJQ3RFVG5ELEs7QUFDRixxQkFBYztBQUFBOztBQUNWLGFBQUtpcUMsS0FBTCxHQUFhLElBQWI7QUFDQSxhQUFLQyxNQUFMLEdBQWMsSUFBSUMsR0FBSixFQUFkO0FBQ0g7O29CQUVEMzhCLEssb0JBQVE7QUFDSixlQUFPLEtBQUswOEIsTUFBTCxDQUFZamtDLElBQVosS0FBcUIsQ0FBNUI7QUFDSCxLOztvQkFFRG1rQyxHLGdCQUFJM3FDLEcsRUFBSztBQUNMLGVBQU8sS0FBS3lxQyxNQUFMLENBQVlFLEdBQVosQ0FBZ0IzcUMsR0FBaEIsQ0FBUDtBQUNILEs7O29CQUVEVyxHLGdCQUFJWCxHLEVBQUs0cUMsWSxFQUFjO0FBQ25CLFlBQU1yQixNQUFNLEtBQUtvQixHQUFMLENBQVMzcUMsR0FBVCxJQUFnQixLQUFLeXFDLE1BQUwsQ0FBWTlwQyxHQUFaLENBQWdCWCxHQUFoQixDQUFoQixHQUF1QyxLQUFLa0QsSUFBTCxFQUFuRDtBQUNBLGVBQVEsT0FBT3FtQyxHQUFQLEtBQWUsV0FBZixJQUE4QkEsUUFBUSxJQUF2QyxHQUNIcUIsWUFERyxHQUNZckIsR0FEbkI7QUFFSCxLOztvQkFFRDdvQyxHLGdCQUFJVixHLEVBQUt5SSxLLEVBQU87QUFDWixZQUFJLEtBQUtzRixLQUFMLEVBQUosRUFBa0I7QUFDZCxpQkFBS3k4QixLQUFMLEdBQWF4cUMsR0FBYjtBQUNIO0FBQ0QsYUFBS3lxQyxNQUFMLENBQVk5YSxHQUFaLENBQWdCM3ZCLEdBQWhCLEVBQXFCeUksS0FBckI7QUFDSCxLOztvQkFFRG9pQyxNLG1CQUFPN3FDLEcsRUFBS3lJLEssRUFBTztBQUNmLFlBQUksS0FBS2tpQyxHQUFMLENBQVMzcUMsR0FBVCxDQUFKLEVBQW1CO0FBQ2YsaUJBQUt5cUMsTUFBTCxDQUFZOWEsR0FBWixDQUFnQjN2QixHQUFoQixFQUFxQnlJLEtBQXJCO0FBQ0g7QUFDSixLOztvQkFFRDNHLE0sbUJBQU85QixHLEVBQUs7QUFDUixhQUFLeXFDLE1BQUwsQ0FBWUssTUFBWixDQUFtQjlxQyxHQUFuQjtBQUNILEs7O29CQUVEa0QsSSxtQkFBTztBQUNILGVBQU8sS0FBS3VuQyxNQUFMLENBQVk5cEMsR0FBWixDQUFnQixLQUFLNnBDLEtBQXJCLENBQVA7QUFDSCxLOzs7OztrQkFHVWpxQyxLOzs7Ozs7O0FDMUNmLDBDQUEwQywwREFBMEQsNkJBQTZCO0FBQ2pJLCtCOzs7Ozs7Ozs7Ozs7Ozs7O0FDREE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTTRCLFdBQVdxTSxnQkFBTXJNLFFBQXZCO0FBQUEsSUFDSW1LLE9BQU8sU0FBUEEsSUFBTyxHQUFNLENBQUUsQ0FEbkI7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7SUFDcUIySixLOzs7QUF1UWpCLG1CQUFZcFYsS0FBWixFQUFtQjBPLE9BQW5CLEVBQTRCO0FBQUE7O0FBQUEscURBQ3hCLDRCQUFNMU8sS0FBTixFQUFhME8sT0FBYixDQUR3Qjs7QUFBQSxjQVM1QjFGLEtBVDRCLEdBU3BCO0FBQ0owYyxrQkFBTSxNQUFLMWxCLEtBQUwsQ0FBVzBsQixJQUFYLElBQW1CO0FBRHJCLFNBVG9COztBQUFBLGNBd0o1QkYsTUF4SjRCLEdBd0puQixVQUFDN1csU0FBRCxFQUFZOFcsS0FBWixFQUFtQkMsSUFBbkIsRUFBNEI7QUFDakMsZ0JBQUksT0FBTyxNQUFLMWxCLEtBQUwsQ0FBVzBsQixJQUFsQixLQUEyQixXQUEvQixFQUE0QztBQUN4QyxzQkFBS3BHLFFBQUwsQ0FDSTtBQUNJb0csMEJBQU1BO0FBRFYsaUJBREosRUFJSSxZQUFNO0FBQ0YsMEJBQUsxbEIsS0FBTCxDQUFXd2xCLE1BQVgsQ0FBa0I3VyxTQUFsQixFQUE2QjhXLEtBQTdCLEVBQW9DQyxJQUFwQztBQUNILGlCQU5MO0FBUUgsYUFURCxNQVNPO0FBQ0gsc0JBQUsxbEIsS0FBTCxDQUFXd2xCLE1BQVgsQ0FBa0I3VyxTQUFsQixFQUE2QjhXLEtBQTdCLEVBQW9DQyxJQUFwQztBQUNIO0FBQ0osU0FySzJCOztBQUFBLGNBdUs1QkUsUUF2SzRCLEdBdUtqQix3QkFBZ0I7QUFDdkIsa0JBQUs1bEIsS0FBTCxDQUFXNGxCLFFBQVgsQ0FBb0JELFlBQXBCO0FBQ0gsU0F6SzJCOztBQUFBLGNBMks1QkcsY0EzSzRCLEdBMktYLFVBQUNuWCxTQUFELEVBQVkvRyxLQUFaLEVBQXNCO0FBQ25DLGtCQUFLNUgsS0FBTCxDQUFXOGxCLGNBQVgsQ0FBMEJuWCxTQUExQixFQUFxQy9HLEtBQXJDO0FBQ0gsU0E3SzJCOztBQUFBLGNBbVE1QnNpQyxhQW5RNEIsR0FtUVosbUJBQVc7QUFDdkIsZ0JBQUksQ0FBQ0MsT0FBTCxFQUFjO0FBQ1YsdUJBQU8sTUFBS0EsT0FBWjtBQUNIO0FBQ0Qsa0JBQUtBLE9BQUwsR0FBZUEsT0FBZjtBQUNILFNBeFEyQjs7QUFBQSxjQTBRNUJDLFdBMVE0QixHQTBRZCxVQUFDdmtCLFFBQUQsRUFBYztBQUN4QixnQkFBSSxDQUFDQSxRQUFMLEVBQWU7QUFDWCx1QkFBTyxNQUFLQSxRQUFaO0FBQ0g7QUFDRCxrQkFBS0EsUUFBTCxHQUFnQkEsUUFBaEI7QUFDSCxTQS9RMkI7O0FBQUEsY0FpUjVCd2tCLGdCQWpSNEIsR0FpUlQsVUFBQzVyQyxDQUFELEVBQUlnUixDQUFKLEVBQU9ILElBQVAsRUFBZ0I7QUFDL0IsZ0JBQU0xQywyQkFBeUJuTyxDQUF6QixTQUE4QmdSLENBQXBDO0FBQ0EsZ0JBQUksQ0FBQ0gsSUFBTCxFQUFXO0FBQ1AsdUJBQU8sTUFBSzFDLE9BQUwsQ0FBUDtBQUNIO0FBQ0Qsa0JBQUtBLE9BQUwsSUFBZ0IwQyxJQUFoQjtBQUNILFNBdlIyQjs7QUFBQSxjQXlSNUIzRCxTQXpSNEIsR0F5UmhCLFVBQUNsTixDQUFELEVBQUltTixHQUFKLEVBQVk7QUFDcEIsZ0JBQU1DLGtCQUFnQnBOLENBQXRCO0FBQ0EsZ0JBQUksQ0FBQ21OLEdBQUwsRUFBVTtBQUNOLHVCQUFPLE1BQUtDLE1BQUwsQ0FBUDtBQUNIO0FBQ0Qsa0JBQUtBLE1BQUwsSUFBZUQsR0FBZjtBQUNILFNBL1IyQjs7QUFBQSxjQWlTNUIwWixVQWpTNEIsR0FpU2YsVUFBQzdtQixDQUFELEVBQUlnUixDQUFKLEVBQU9ILElBQVAsRUFBZ0I7QUFDekIsZ0JBQU0xQyxvQkFBa0JuTyxDQUFsQixTQUF1QmdSLENBQTdCO0FBQ0EsZ0JBQUksQ0FBQ0gsSUFBTCxFQUFXO0FBQ1AsdUJBQU8sTUFBSzFDLE9BQUwsQ0FBUDtBQUNIO0FBQ0Qsa0JBQUtBLE9BQUwsSUFBZ0IwQyxJQUFoQjtBQUNILFNBdlMyQjs7QUFBQSw0QkFFaUMsTUFBS1osT0FGdEM7QUFBQSxZQUVoQjQ3QixnQkFGZ0IsaUJBRWhCQSxnQkFGZ0I7QUFBQSxZQUVFQywwQkFGRixpQkFFRUEsMEJBRkY7O0FBR3hCRCw0QkFBb0JBLGlCQUFpQnRxQyxNQUFNeU8sUUFBdkIsUUFBcEI7QUFDQTg3QixzQ0FDSUEsMkJBQTJCdnFDLE1BQU15TyxRQUFqQyxRQURKO0FBRUEsY0FBS00sa0JBQUwsR0FBMEIsRUFBMUI7QUFOd0I7QUFPM0I7O29CQU1EaFAsZSw4QkFBa0I7QUFDZCxlQUFPO0FBQ0hnUCxnQ0FBb0IsS0FBS0Esa0JBRHRCO0FBRUhOLHNCQUFVLEtBQUt6TyxLQUFMLENBQVd5TztBQUZsQixTQUFQO0FBSUgsSzs7b0JBRUQ1Tix5QixzQ0FBMEJDLFMsRUFBVztBQUNqQyxZQUFJLE9BQU8sS0FBS2QsS0FBTCxDQUFXMGxCLElBQWxCLEtBQTJCLFdBQS9CLEVBQTRDO0FBQ3hDLGlCQUFLcEcsUUFBTCxDQUFjO0FBQ1ZvRyxzQkFBTTVrQixVQUFVNGtCO0FBRE4sYUFBZDtBQUdIO0FBQ0osSzs7b0JBRUR4WCxxQixrQ0FBc0JwTixTLEVBQVcwd0IsUyxFQUFXcUcsVyxFQUFhO0FBQ3JELFlBQUkvMkIsVUFBVVgsSUFBZCxFQUFvQjtBQUNoQixnQkFBTWdPLFVBQ0Ysb0NBQXFCck4sU0FBckIsRUFBZ0MsS0FBS2QsS0FBckMsS0FDQW5DLFVBQUl3SSxZQUFKLENBQWlCbXJCLFNBQWpCLEVBQTRCLEtBQUt4b0IsS0FBakMsQ0FEQSxJQUVBbkwsVUFBSXdJLFlBQUosQ0FBaUJ3eEIsV0FBakIsRUFBOEIsS0FBS25wQixPQUFuQyxDQUhKO0FBSUEsbUJBQU8sQ0FBQ1AsT0FBUjtBQUNIOztBQUVELGVBQU8sSUFBUDtBQUNILEs7O29CQUVEMFosbUIsa0NBQXNCO0FBQ2xCLGFBQUs5WSxrQkFBTCxHQUEwQixFQUExQjtBQUNILEs7O29CQUVEeTdCLHNCLG1DQUF1QnhxQyxLLEVBQU87QUFDMUIsWUFBSTZNLFVBQVU3TSxNQUFNNk0sT0FBcEI7QUFDQSxZQUFJN00sTUFBTXdCLFFBQVYsRUFBb0I7QUFDaEJxTCxzQkFBVSxLQUFLNDlCLGlCQUFMLENBQXVCenFDLEtBQXZCLENBQVY7QUFDSDtBQUNELGVBQU8sS0FBSzBxQywyQkFBTCxDQUFpQzc5QixPQUFqQyxDQUFQO0FBQ0gsSzs7QUFFRDs7O29CQUNBNDlCLGlCLDhCQUFrQnpxQyxLLEVBQU87QUFBQSxZQUNmNk0sT0FEZSxHQUNIN00sS0FERyxDQUNmNk0sT0FEZTs7QUFFckIsWUFBTTg5QixjQUFjLFNBQWRBLFdBQWMsV0FBWTtBQUM1QixnQkFBTW5qQyxNQUFNLEVBQVo7QUFDQWxHLHFCQUFTeUQsT0FBVCxDQUFpQnZELFFBQWpCLEVBQTJCLGlCQUFTO0FBQ2hDLG9CQUFJNkksS0FBSixFQUFXO0FBQ1Asd0JBQU1ySyxzQkFBYXFLLE1BQU1ySyxLQUFuQixDQUFOOztBQUVBLHdCQUNJLEVBQ0lxSyxTQUNBLE9BQU9BLE1BQU0zRSxJQUFiLEtBQXNCLFVBRHRCLEtBRUMyRSxNQUFNM0UsSUFBTixDQUFXTSxTQUFYLEtBQXlCLFFBQXpCLElBQ0dxRSxNQUFNM0UsSUFBTixDQUFXTSxTQUFYLEtBQXlCLGFBSDdCLENBREosQ0FESixFQU9FO0FBQ0VwSSxrQ0FBSXdDLE9BQUosQ0FDSSxxREFESjtBQUdIO0FBQ0RvSCx3QkFBSTFJLElBQUosQ0FBU2tCLE1BQVQ7QUFDQSx3QkFBSXFLLE1BQU1ySyxLQUFOLENBQVl3QixRQUFoQixFQUEwQjtBQUN0QnhCLCtCQUFNd0IsUUFBTixHQUFpQm1wQyxZQUFZdGdDLE1BQU1ySyxLQUFOLENBQVl3QixRQUF4QixDQUFqQjtBQUNIO0FBQ0o7QUFDSixhQXJCRDtBQXNCQSxtQkFBT2dHLEdBQVA7QUFDSCxTQXpCRDtBQTBCQSxZQUFJeEgsTUFBTXdCLFFBQVYsRUFBb0I7QUFDaEJxTCxzQkFBVTg5QixZQUFZM3FDLE1BQU13QixRQUFsQixDQUFWO0FBQ0g7QUFDRCxlQUFPcUwsT0FBUDtBQUNILEs7O29CQUVENjlCLDJCLHdDQUE0QmxwQyxRLEVBQVU7QUFDbEMsWUFBSW9wQyxpQkFBaUIsS0FBckI7QUFDQSxZQUFNQyxlQUFlLEVBQXJCO0FBQUEsWUFDSUMsZ0JBQWdCLEVBRHBCO0FBQUEsWUFFSUgsY0FBYyxTQUFkQSxXQUFjLENBQUNJLGFBQUQsRUFBZ0J6Z0MsS0FBaEIsRUFBMEI7QUFDcEN3Z0MsMEJBQWN4Z0MsS0FBZCxJQUF1QndnQyxjQUFjeGdDLEtBQWQsS0FBd0IsRUFBL0M7QUFDQXlnQywwQkFBY2htQyxPQUFkLENBQXNCLGlCQUFTO0FBQzNCLG9CQUFJc0YsTUFBTTdJLFFBQVYsRUFBb0I7QUFDaEJvcEMscUNBQWlCLElBQWpCO0FBQ0FELGdDQUFZdGdDLE1BQU03SSxRQUFsQixFQUE0QjhJLFFBQVEsQ0FBcEM7QUFDSCxpQkFIRCxNQUdPO0FBQ0h1Z0MsaUNBQWEvckMsSUFBYixDQUFrQnVMLEtBQWxCO0FBQ0g7QUFDRHlnQyw4QkFBY3hnQyxLQUFkLEVBQXFCeEwsSUFBckIsQ0FBMEJ1TCxLQUExQjtBQUNILGFBUkQ7QUFTSCxTQWJMO0FBQUEsWUFjSTJnQyxhQUFhLFNBQWJBLFVBQWEsQ0FBQ3hwQyxRQUFELEVBQVcyTixPQUFYLEVBQXVCO0FBQ2hDQSxzQkFBVUEsV0FBVyxDQUFyQjtBQUNBM04scUJBQVN1RCxPQUFULENBQWlCLGlCQUFTO0FBQ3RCLG9CQUFJc0YsTUFBTTdJLFFBQVYsRUFBb0I7QUFDaEIyTiw4QkFBVTY3QixXQUFXM2dDLE1BQU03SSxRQUFqQixFQUEyQjJOLE9BQTNCLENBQVY7QUFDSCxpQkFGRCxNQUVPO0FBQ0hBLCtCQUFXLENBQVg7QUFDSDtBQUNKLGFBTkQ7QUFPQSxtQkFBT0EsT0FBUDtBQUNILFNBeEJMOztBQTBCQXc3QixvQkFBWW5wQyxRQUFaLEVBQXNCLENBQXRCOztBQUVBc3BDLHNCQUFjL2xDLE9BQWQsQ0FBc0IsVUFBQ2ttQyxVQUFELEVBQWF4c0MsQ0FBYixFQUFtQjtBQUNyQ3dzQyx1QkFBV2xtQyxPQUFYLENBQW1CLFVBQUNzRixLQUFELEVBQVFvRixDQUFSLEVBQWM7QUFDN0Isb0JBQUlOLGdCQUFKO0FBQ0Esb0JBQU0zTixXQUFXNkksTUFBTTdJLFFBQXZCOztBQUVBLG9CQUFJQSxRQUFKLEVBQWM7QUFDVjJOLDhCQUFVNjdCLFdBQVd4cEMsUUFBWCxDQUFWO0FBQ0E2SSwwQkFBTThFLE9BQU4sR0FBZ0JBLE9BQWhCO0FBQ0EyN0Isa0NBQWNyc0MsQ0FBZCxFQUFpQmdSLENBQWpCLElBQXNCcEYsS0FBdEI7QUFDSDtBQUNKLGFBVEQ7QUFVSCxTQVhEOztBQWFBLGVBQU87QUFDSHdnQyxzQ0FERztBQUVIQyx3Q0FGRztBQUdIRjtBQUhHLFNBQVA7QUFLSCxLOztvQkFFRE0sYywyQkFBZUwsWSxFQUFjO0FBQ3pCLFlBQU14a0IsT0FBT3drQixhQUFhM25DLEdBQWIsQ0FBaUIsVUFBQ29qQixHQUFELEVBQU10YSxLQUFOLEVBQWdCO0FBQzFDLGdCQUFNNkMsUUFBUXlYLElBQUl6WCxLQUFsQjtBQUNBLGdCQUFJN0QsUUFBUSxFQUFaO0FBQ0EsZ0JBQUk2RCxLQUFKLEVBQVc7QUFDUDdELHdCQUFRO0FBQ0o2RCwyQkFBT0E7QUFESCxpQkFBUjtBQUdIOztBQUVELG1CQUFPLHVDQUFLLE9BQU83RCxLQUFaLEVBQW1CLEtBQUtnQixLQUF4QixHQUFQO0FBQ0gsU0FWWSxDQUFiO0FBV0EsZUFBTztBQUFBO0FBQUEsY0FBVSxLQUFJLGdCQUFkO0FBQWdDcWE7QUFBaEMsU0FBUDtBQUNILEs7O0FBeUJEO29CQUNBOGtCLFcsd0JBQVlMLGEsRUFBZUQsWSxFQUFjO0FBQ3JDLFlBQ0lBLGFBQWFsc0MsTUFBYixJQUNDLENBQUNrc0MsYUFBYWxzQyxNQUFkLElBQXdCLENBQUMsS0FBS3FCLEtBQUwsQ0FBV3lPLFFBRnpDLEVBR0U7QUFBQSwwQkFrQk0sS0FBS3pPLEtBbEJYO0FBQUEsZ0JBRU1vckMsU0FGTixXQUVNQSxTQUZOO0FBQUEsZ0JBR003K0IsVUFITixXQUdNQSxVQUhOO0FBQUEsZ0JBSU10TSxNQUpOLFdBSU1BLE1BSk47QUFBQSxnQkFLTXVTLGNBTE4sV0FLTUEsY0FMTjtBQUFBLGdCQU1NbVQsWUFOTixXQU1NQSxZQU5OO0FBQUEsZ0JBT016bEIsTUFQTixXQU9NQSxNQVBOO0FBQUEsZ0JBUU15TSxVQVJOLFdBUU1BLFVBUk47QUFBQSxnQkFTTUwsWUFUTixXQVNNQSxZQVROO0FBQUEsZ0JBVU1ELE9BVk4sV0FVTUEsT0FWTjtBQUFBLGdCQVdNRyxZQVhOLFdBV01BLFlBWE47QUFBQSxnQkFZTUMsVUFaTixXQVlNQSxVQVpOO0FBQUEsZ0JBYU1DLFdBYk4sV0FhTUEsV0FiTjtBQUFBLGdCQWNNWixVQWROLFdBY01BLFVBZE47QUFBQSxnQkFlTUcsZUFmTixXQWVNQSxlQWZOO0FBQUEsZ0JBZ0JNQyxlQWhCTixXQWdCTUEsZUFoQk47QUFBQSxnQkFpQk0vTCxJQWpCTixXQWlCTUEsSUFqQk47QUFBQSxnQkFtQlV1bEIsSUFuQlYsR0FtQm1CLEtBQUsxYyxLQW5CeEIsQ0FtQlUwYyxJQW5CVjtBQUFBLHFDQXdCTW5aLFVBeEJOLENBcUJNOFksTUFyQk47QUFBQSxnQkFxQk1BLE1BckJOLHNDQXFCZWdtQixnQkFyQmY7QUFBQSxzQ0F3Qk05K0IsVUF4Qk4sQ0FzQk0rK0IsT0F0Qk47QUFBQSxnQkFzQk1BLE9BdEJOLHVDQXNCZ0JDLGlCQXRCaEI7QUFBQSxtQ0F3Qk1oL0IsVUF4Qk4sQ0F1Qk1iLElBdkJOO0FBQUEsZ0JBdUJNQSxJQXZCTixvQ0F1QmE4L0IsY0F2QmI7O0FBeUJFLGdCQUFNcC9CLFdBQVcsS0FBSzgrQixjQUFMLENBQW9CTCxZQUFwQixDQUFqQjs7QUFFQSxtQkFDSTtBQUFDLHVCQUFEO0FBQUE7QUFDSSw4QkFBVXorQixRQURkO0FBRUkseUJBQUssS0FBSzg5QixhQUZkO0FBR0ksNEJBQVFqcUM7QUFIWjtBQUtLbXJDLDRCQUNHLDhCQUFDLE1BQUQ7QUFDSSw0QkFBUW5yQyxNQURaO0FBRUksMEJBQU1FLElBRlY7QUFHSSw4QkFBVSxLQUFLaXFDLFdBSG5CO0FBSUksOEJBQVVoK0IsUUFKZDtBQUtJLCtCQUFjbk0sTUFBZCxpQkFMSjtBQU1JLGtDQUFjMGxCLFlBTmxCO0FBT0ksNkJBQVNtbEIsYUFQYjtBQVFJLDRCQUFRNXFDLE1BUlo7QUFTSSxtQ0FBZSxLQUFLbXFDLGdCQVR4QjtBQVVJLGdDQUFZOTlCLFVBVmhCO0FBV0ksOEJBQVUsS0FBS3FaLFFBWG5CO0FBWUksMEJBQU1GLElBWlY7QUFhSSxvQ0FBZ0IsS0FBS0ksY0FiekI7QUFjSSw0QkFBUSxLQUFLTjtBQWRqQixrQkFESCxHQWlCRyxJQXRCUjtBQXVCSSw4Q0FBQyxJQUFEO0FBQ0ksNEJBQVF2bEIsTUFEWjtBQUVJLDBCQUFNRSxJQUZWO0FBR0ksOEJBQVVpTSxRQUhkO0FBSUksK0JBQWNuTSxNQUFkLGVBSko7QUFLSSxnQ0FBWXNNLFVBTGhCO0FBTUksNkJBQVNGLE9BTmI7QUFPSSxrQ0FBY0MsWUFQbEI7QUFRSSxrQ0FBY0UsWUFSbEI7QUFTSSxnQ0FBWUMsVUFUaEI7QUFVSSxpQ0FBYUMsV0FWakI7QUFXSSw2QkFBU20rQixZQVhiO0FBWUksNEJBQVEsS0FBS2wvQixTQVpqQjtBQWFJLDZCQUFTLEtBQUsyWixVQWJsQjtBQWNJLGdDQUFZeFosVUFkaEI7QUFlSSxxQ0FBaUJHLGVBZnJCO0FBZ0JJLHFDQUFpQkMsZUFoQnJCO0FBaUJJLGdDQUFZUyxVQWpCaEI7QUFrQkksNEJBQVF6TTtBQWxCWixrQkF2Qko7QUEyQ0tzUztBQTNDTCxhQURKO0FBK0NILFNBN0VELE1BNkVPO0FBQ0gsbUJBQU8sSUFBUDtBQUNIO0FBQ0osSzs7b0JBd0NEblIsTSxxQkFBUztBQUFBOztBQUNMLFlBQU1tRyxNQUFNLEtBQUtnakMsc0JBQUwsQ0FBNEIsS0FBS3hxQyxLQUFqQyxDQUFaO0FBQ0EsYUFBSzhxQyxhQUFMLEdBQXFCdGpDLElBQUlzakMsYUFBekI7QUFDQSxhQUFLRCxZQUFMLEdBQW9CcmpDLElBQUlxakMsWUFBeEI7QUFDQTtBQUNJLG9CQUFRLEtBQUtNLFdBQUwsQ0FBaUIzakMsSUFBSXNqQyxhQUFyQixFQUFvQ3RqQyxJQUFJcWpDLFlBQXhDLENBQVI7QUFBQSxzQkE4QkksS0FBSzdxQyxLQTlCVDtBQUFBLFlBRUk0RixTQUZKLFdBRUlBLFNBRko7QUFBQSxZQUdJNmxDLFNBSEosV0FHSUEsU0FISjtBQUFBLFlBSUlDLE9BSkosV0FJSUEsT0FKSjtBQUFBLFlBS0lyL0IsT0FMSixXQUtJQSxPQUxKO0FBQUEsWUFNSSsrQixTQU5KLFdBTUlBLFNBTko7QUFBQSxZQU9JbnJDLE1BUEosV0FPSUEsTUFQSjtBQUFBLFlBUUkwTSxVQVJKLFdBUUlBLFVBUko7QUFBQSxZQVNJZy9CLGdCQVRKLFdBU0lBLGdCQVRKO0FBQUEsWUFVSW5tQixNQVZKLFdBVUlBLE1BVko7QUFBQSxZQVdJTSxjQVhKLFdBV0lBLGNBWEo7QUFBQSxZQVlJaGEsVUFaSixXQVlJQSxVQVpKO0FBQUEsWUFhSUcsZUFiSixXQWFJQSxlQWJKO0FBQUEsWUFjSUMsZUFkSixXQWNJQSxlQWRKO0FBQUEsWUFlSTBaLFFBZkosV0FlSUEsUUFmSjtBQUFBLFlBZ0JJbFosV0FoQkosV0FnQklBLFdBaEJKO0FBQUEsWUFpQklGLFlBakJKLFdBaUJJQSxZQWpCSjtBQUFBLFlBa0JJQyxVQWxCSixXQWtCSUEsVUFsQko7QUFBQSxZQW1CSUYsVUFuQkosV0FtQklBLFVBbkJKO0FBQUEsWUFvQklpRyxjQXBCSixXQW9CSUEsY0FwQko7QUFBQSxZQXFCSS9ELFFBckJKLFdBcUJJQSxRQXJCSjtBQUFBLFlBc0JJdk8sTUF0QkosV0FzQklBLE1BdEJKO0FBQUEsWUF1QkkwckMsSUF2QkosV0F1QklBLElBdkJKO0FBQUEsWUF3Qkl6ckMsSUF4QkosV0F3QklBLElBeEJKO0FBQUEsWUF5QklFLEdBekJKLFdBeUJJQSxHQXpCSjtBQUFBLFlBMEJJaU0sWUExQkosV0EwQklBLFlBMUJKO0FBQUEsWUEyQklxWixZQTNCSixXQTJCSUEsWUEzQko7QUFBQSw0Q0E0QklrbUIsZ0JBNUJKO0FBQUEsWUE0QnNCQyxnQkE1QnRCLHlDQTRCeUNqUSxpQkE1QnpDO0FBQUEsWUE2Qk85ekIsTUE3QlA7QUFBQSxZQStCQTJILEdBL0JBLEdBK0JNLHlEQUNFelAsTUFERixjQUNrQixJQURsQixjQUVGLG9CQUZFLElBRW9CLENBQUN3ckMsU0FGckIsY0FHRixXQUhFLElBR1csQ0FBQ0wsU0FIWixjQUlGVyxLQUpFLEdBSUtMLE9BSkwsY0FLRDlsQyxTQUxDLElBS1dBLFNBTFgsZUEvQk47OztBQXVDSixZQUFJdkYsR0FBSixFQUFTO0FBQ0wwSCxtQkFBT2pDLEdBQVAsR0FBYSxLQUFiO0FBQ0g7QUFDRCxZQUFNMUMsVUFDRjtBQUFBO0FBQUEsdUJBQUssV0FBV3NNLEdBQWhCLElBQXlCM0gsTUFBekI7QUFDS2lrQztBQURMLFNBREo7QUFLQSxZQUFJMy9CLE9BQUosRUFBYTtBQUNULGdCQUFNNC9CLG1CQUFzQmhzQyxNQUF0QixrQkFBTjtBQUNBLG1CQUNJO0FBQUMsZ0NBQUQ7QUFBQSxrQkFBa0IsV0FBV2dzQyxnQkFBN0I7QUFDSzdvQztBQURMLGFBREo7QUFLSDtBQUNELGVBQU9BLE9BQVA7QUFDSCxLOzs7RUE3bUI4QnVLLGdCQUFNbE0sUyxVQUM5QjBRLE0sR0FBU0EsZ0IsU0FDVCs1QixXLEdBQWNBLHFCLFNBQ2Q3bUIsTSxHQUFTZ21CLGdCLFNBQ1QzL0IsSSxHQUFPOC9CLGMsU0FDUEYsTyxHQUFVQyxpQixTQUNWeitCLEcsR0FBTUMsYSxTQUNOQyxJLEdBQU9DLGMsU0FDUDhZLE0sR0FBU0MsZ0IsU0FDVEMsSSxHQUFPQyxjLFNBRVB4a0IsUyxHQUFZO0FBQ2Y7OztBQUdBekIsWUFBUTBCLG9CQUFVQyxNQUpIO0FBS2Z6QixVQUFNd0Isb0JBQVVFLElBTEQ7QUFNZnhCLFNBQUtzQixvQkFBVUUsSUFOQTtBQU9mOzs7QUFHQStELGVBQVdqRSxvQkFBVUMsTUFWTjtBQVdmOzs7QUFHQW9KLFdBQU9ySixvQkFBVWpGLE1BZEY7QUFlZjs7O0FBR0FpUSxnQkFBWWhMLG9CQUFVa00sS0FsQlA7QUFtQmY4OUIsc0JBQWtCaHFDLG9CQUFVa00sS0FuQmI7QUFvQmY7Ozs7OztBQU1BL0IsZ0JBQVluSyxvQkFBVWhFLElBMUJQO0FBMkJmOzs7Ozs7QUFNQXNPLHFCQUFpQnRLLG9CQUFVaEUsSUFqQ1o7QUFrQ2Y7Ozs7OztBQU1BdU8scUJBQWlCdkssb0JBQVVoRSxJQXhDWjtBQXlDZjs7Ozs7QUFLQTZuQixZQUFRN2pCLG9CQUFVaEUsSUE5Q0g7QUErQ2Y7Ozs7QUFJQWlvQixjQUFVamtCLG9CQUFVaEUsSUFuREw7QUFvRGY7Ozs7O0FBS0Ftb0Isb0JBQWdCbmtCLG9CQUFVaEUsSUF6RFg7QUEwRGY7Ozs7OztBQU1BK08saUJBQWEvSyxvQkFBVWhFLElBaEVSO0FBaUVmOzs7Ozs7OztBQVFBNk8sa0JBQWM3SyxvQkFBVWhFLElBekVUO0FBMEVmOzs7QUFHQTh0QyxlQUFXOXBDLG9CQUFVRSxJQTdFTjtBQThFZjs7O0FBR0F1cEMsZUFBV3pwQyxvQkFBVUUsSUFqRk47QUFrRmY7OztBQUdBNnBDLGFBQVMvcEMsb0JBQVVFLElBckZKO0FBc0ZmOzs7QUFHQXdLLGFBQVMxSyxvQkFBVUUsSUF6Rko7QUEwRmY7Ozs7QUFJQWdxQyxzQkFBa0JscUMsb0JBQVVoRSxJQTlGYjtBQStGZjs7Ozs7O0FBTUFnb0Isa0JBQWNoa0Isb0JBQVVqRixNQXJHVDtBQXNHZjs7O0FBR0FncEIsVUFBTS9qQixvQkFBVWpGLE1BekdEO0FBMEdmOzs7Ozs7Ozs7Ozs7QUFZQXdELFlBQVF5QixvQkFBVWpGLE1BdEhIO0FBdUhmNlAsZ0JBQVk1SyxvQkFBVWpGLE1BdkhQO0FBd0hmbVEsYUFBU2xMLG9CQUFVa00sS0F4SEo7QUF5SGY7OztBQUdBdkIsa0JBQWMzSyxvQkFBVThPLElBNUhUO0FBNkhmOzs7QUFHQWhFLGdCQUFZOUssb0JBQVVDLE1BaElQO0FBaUlmNk0sY0FBVTlNLG9CQUFVb0UsS0FBVixDQUFnQixDQUFDLE1BQUQsRUFBUyxPQUFULENBQWhCLENBaklLO0FBa0lmeU0sb0JBQWdCN1Esb0JBQVVpTSxHQWxJWDtBQW1JZmcrQixVQUFNanFDLG9CQUFVakYsTUFuSUQ7QUFvSWY7Ozs7OztBQU1BcTlCLHVCQUFtQnA0QixvQkFBVWhFLElBMUlkO0FBMklmOzs7QUFHQXE4Qix1QkFBbUJyNEIsb0JBQVVrTSxLQTlJZDtBQStJZjs7O0FBR0Fvc0IsaUJBQWF0NEIsb0JBQVVrTSxLQWxKUjtBQW1KZjs7O0FBR0FzK0Isd0JBQW9CeHFDLG9CQUFVRSxJQXRKZjtBQXVKZjs7O0FBR0F1cUMseUJBQXFCenFDLG9CQUFVaEUsSUExSmhCO0FBMkpmOzs7Ozs7O0FBT0FxZ0MsZUFBV3I4QixvQkFBVWhFLElBbEtOO0FBbUtmOzs7Ozs7QUFNQTB1Qyx3QkFBb0IxcUMsb0JBQVVoRSxJQXpLZjtBQTBLZjs7O0FBR0FnOUIsaUJBQWFoNUIsb0JBQVVFLElBN0tSO0FBOEtmOzs7QUFHQTY0QixtQkFBZS80QixvQkFBVTZPLFNBQVYsQ0FBb0IsQ0FBQzdPLG9CQUFVdUosTUFBWCxFQUFtQnZKLG9CQUFVQyxNQUE3QixDQUFwQixDQWpMQTtBQWtMZjs7Ozs7Ozs7O0FBU0EwcUMsa0JBQWMzcUMsb0JBQVVqRixNQTNMVDtBQTRMZjs7O0FBR0E2dkMsa0JBQWM1cUMsb0JBQVVFLElBL0xUO0FBZ01mOzs7QUFHQTJILGVBQVc3SCxvQkFBVXVKLE1Bbk1OO0FBb01mOzs7QUFHQXNoQyxnQkFBWTdxQyxvQkFBVWpGLE1Bdk1QO0FBd01mOzs7QUFHQXdoQyxZQUFRdjhCLG9CQUFVdUosTUEzTUg7QUE0TWY7OztBQUdBdWhDLFlBQVE5cUMsb0JBQVVFLElBL01IO0FBZ05mOzs7QUFHQTZxQyxnQkFBWS9xQyxvQkFBVUUsSUFuTlA7QUFvTmY7OztBQUdBOHFDLGVBQVdockMsb0JBQVU2TyxTQUFWLENBQW9CLENBQUM3TyxvQkFBVXVKLE1BQVgsRUFBbUJ2SixvQkFBVWhFLElBQTdCLENBQXBCLENBdk5JO0FBd05mOzs7QUFHQTY4QixrQkFBYzc0QixvQkFBVWhFO0FBM05ULEMsU0E4TlpvRSxZLEdBQWU7QUFDbEI0SyxnQkFBWSxFQURNO0FBRWxCYixnQkFBWUwsSUFGTTtBQUdsQlEscUJBQWlCUixJQUhDO0FBSWxCUyxxQkFBaUJULElBSkM7QUFLbEIrWixZQUFRL1osSUFMVTtBQU1sQm1hLGNBQVVuYSxJQU5RO0FBT2xCcWEsb0JBQWdCcmEsSUFQRTtBQVFsQmlCLGlCQUFhakIsSUFSSztBQVNsQmUsa0JBQWNmLElBVEk7QUFVbEJ4TCxZQUFRLE9BVlU7QUFXbEJ3ckMsZUFBVyxJQVhPO0FBWWxCTCxlQUFXLElBWk87QUFhbEJNLGFBQVMsS0FiUztBQWNsQnIvQixhQUFTLEtBZFM7QUFlbEJJLGdCQUFZLElBZk07QUFnQmxCRixnQkFBWSxFQWhCTTtBQWlCbEJyTSxZQUFRMHNDLGVBQUt4M0I7QUFqQkssQyxTQW9CZnBULGlCLEdBQW9CO0FBQ3ZCK00sd0JBQW9CcE4sb0JBQVVrTSxLQURQO0FBRXZCWSxjQUFVOU0sb0JBQVVvRSxLQUFWLENBQWdCLENBQUMsTUFBRCxFQUFTLE9BQVQsQ0FBaEI7QUFGYSxDLFNBS3BCNEosWSxHQUFlO0FBQ2xCMjZCLHNCQUFrQjNvQyxvQkFBVWhFLElBRFY7QUFFbEI0c0MsZ0NBQTRCNW9DLG9CQUFVaEU7QUFGcEIsQztBQWxRTHlYLEs7a0JBQUFBLEs7Ozs7Ozs7Ozs7OztBQzdCckIsSUFBSTlXLGlCQUFpQnVHLE9BQU80QixTQUFQLENBQWlCbkksY0FBdEM7O0FBRUEsU0FBU3V1QyxtQkFBVCxDQUE2Qmp3QixDQUE3QixFQUFnQ0UsQ0FBaEMsRUFBbUM7QUFDakMsT0FBSyxJQUFJd00sQ0FBVCxJQUFjMU0sQ0FBZCxFQUFpQjtBQUNmLFFBQUl0ZSxlQUFlYyxJQUFmLENBQW9Cd2QsQ0FBcEIsRUFBdUIwTSxDQUF2QixDQUFKLEVBQStCO0FBQzdCLGFBQU8xTSxFQUFFME0sQ0FBRixNQUFTeE0sRUFBRXdNLENBQUYsQ0FBaEI7QUFDRDtBQUNGO0FBQ0QsU0FBTyxLQUFQO0FBQ0Q7O0FBRUQsU0FBU3dqQixjQUFULENBQXdCbHdCLENBQXhCLEVBQTJCRSxDQUEzQixFQUE4QjtBQUM1QixNQUFLLENBQUNGLENBQUQsSUFBTSxDQUFDRSxDQUFSLElBQWVGLE1BQU1FLENBQXpCLEVBQTZCO0FBQzNCLFdBQU8sSUFBUDtBQUNEO0FBQ0QsTUFBSSxDQUFDRixDQUFELEtBQU8sQ0FBQ0UsQ0FBWixFQUFlO0FBQ2IsV0FBTyxLQUFQO0FBQ0Q7QUFDRCxNQUFJRixFQUFFamUsTUFBRixLQUFhbWUsRUFBRW5lLE1BQW5CLEVBQTJCO0FBQ3pCLFdBQU8sS0FBUDtBQUNEO0FBQ0QsT0FBSyxJQUFJRixJQUFJLENBQWIsRUFBZ0JBLElBQUltZSxFQUFFamUsTUFBdEIsRUFBOEJGLEdBQTlCLEVBQW1DO0FBQ2pDLFFBQUksQ0FBQ291QyxvQkFBb0Jqd0IsRUFBRW5lLENBQUYsQ0FBcEIsRUFBMEJxZSxFQUFFcmUsQ0FBRixDQUExQixDQUFMLEVBQXNDO0FBQ3BDLGFBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRCxTQUFPLElBQVA7QUFDRDs7QUFFRCxTQUFTc3VDLG1CQUFULENBQTZCbndCLENBQTdCLEVBQWdDRSxDQUFoQyxFQUFtQztBQUNqQyxNQUFJd00sQ0FBSjtBQUNBLE1BQUk3cUIsSUFBSSxDQUFSO0FBQ0EsTUFBSWdSLElBQUksQ0FBUjtBQUNBLE9BQUs2WixDQUFMLElBQVUxTSxDQUFWLEVBQWE7QUFDWCxRQUFJdGUsZUFBZWMsSUFBZixDQUFvQndkLENBQXBCLEVBQXVCME0sQ0FBdkIsQ0FBSixFQUErQjtBQUM3QixjQUFRQSxDQUFSO0FBQ0UsYUFBSyxXQUFMO0FBQ0UsY0FBSSxDQUFDd2pCLGVBQWVsd0IsRUFBRTBNLENBQUYsQ0FBZixFQUFxQnhNLEVBQUV3TSxDQUFGLENBQXJCLENBQUwsRUFBaUM7QUFDL0IsbUJBQU8sS0FBUDtBQUNEO0FBQ0Q7QUFDRixhQUFLLGNBQUw7QUFDRSxjQUFJLENBQUN5akIsb0JBQW9CbndCLEVBQUUwTSxDQUFGLENBQXBCLEVBQTBCeE0sRUFBRXdNLENBQUYsQ0FBMUIsQ0FBTCxFQUFzQztBQUNwQyxtQkFBTyxLQUFQO0FBQ0Q7QUFDRDtBQUNGO0FBQ0UsY0FBSTFNLEVBQUUwTSxDQUFGLE1BQVN4TSxFQUFFd00sQ0FBRixDQUFiLEVBQW1CO0FBQ2pCLG1CQUFPLEtBQVA7QUFDRDtBQUNEO0FBZko7QUFpQkE3cUI7QUFDRDtBQUNGO0FBQ0QsT0FBSzZxQixDQUFMLElBQVV4TSxDQUFWLEVBQWE7QUFDWCxRQUFJeGUsZUFBZWMsSUFBZixDQUFvQjBkLENBQXBCLEVBQXVCd00sQ0FBdkIsQ0FBSixFQUErQjtBQUM3QjdaO0FBQ0Q7QUFDRjtBQUNELFNBQU9oUixNQUFNZ1IsQ0FBYjtBQUNEOztBQUVELFNBQVNrTixVQUFULENBQW9CQyxDQUFwQixFQUF1QkUsQ0FBdkIsRUFBMEI7QUFDeEIsTUFBSyxDQUFDRixDQUFELElBQU0sQ0FBQ0UsQ0FBUixJQUFlRixNQUFNRSxDQUF6QixFQUE2QjtBQUMzQixXQUFPLElBQVA7QUFDRDtBQUNELE1BQUksQ0FBQ0YsQ0FBRCxLQUFPLENBQUNFLENBQVosRUFBZTtBQUNiLFdBQU8sS0FBUDtBQUNEO0FBQ0QsaUJBQWVGLENBQWYseUNBQWVBLENBQWY7QUFDRSxTQUFLLFFBQUw7QUFDRSxVQUFJQSxhQUFhN2QsS0FBakIsRUFBd0I7QUFDdEIsYUFBSyxJQUFJTixJQUFJLENBQWIsRUFBZ0JBLElBQUltZSxFQUFFamUsTUFBdEIsRUFBOEJGLEdBQTlCLEVBQW1DO0FBQ2pDLGNBQUksQ0FBQ2tlLFdBQVdDLEVBQUVuZSxDQUFGLENBQVgsRUFBaUJxZSxFQUFFcmUsQ0FBRixDQUFqQixDQUFMLEVBQTZCO0FBQzNCLG1CQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0QsZUFBT21lLEVBQUVqZSxNQUFGLEtBQWFtZSxFQUFFbmUsTUFBdEI7QUFDRCxPQVBELE1BT087QUFDTCxlQUFPb3VDLG9CQUFvQm53QixDQUFwQixFQUF1QkUsQ0FBdkIsQ0FBUDtBQUNEO0FBQ0Q7QUFDRixTQUFLLFFBQUw7QUFDQTtBQUNFLGFBQU9GLE1BQU1FLENBQWI7QUFmSjtBQWlCRDs7QUFFRGpnQixPQUFPQyxPQUFQLEdBQWlCNmYsVUFBakIsQzs7Ozs7Ozs7OztBQ3pGQSxJQUFNcUMsaUJBQWlCO0FBQ25CZ3VCLGlCQUFhLEVBRE07O0FBR25CL3RCLGNBSG1CLHNCQUdSNFcsT0FIUSxFQUdDO0FBQ2hCLGFBQUsxVixhQUFMLENBQW1CMFYsT0FBbkI7QUFDQSxhQUFLbVgsV0FBTCxDQUFpQm5xQixPQUFqQixDQUF5QmdULE9BQXpCO0FBQ0gsS0FOa0I7QUFRbkJwVCxvQkFSbUIsNEJBUUZvVCxPQVJFLEVBUU87QUFDdEIsZUFBT0EsV0FBVyxLQUFLbVgsV0FBTCxDQUFpQixDQUFqQixNQUF3Qm5YLE9BQTFDO0FBQ0gsS0FWa0I7QUFZbkIxVixpQkFabUIseUJBWUwwVixPQVpLLEVBWUk7QUFDbkIsWUFBTXAzQixJQUFJLEtBQUt1dUMsV0FBTCxDQUFpQmhvQyxPQUFqQixDQUF5QjZ3QixPQUF6QixDQUFWO0FBQ0EsWUFBSXAzQixJQUFJLENBQUMsQ0FBVCxFQUFZO0FBQ1IsaUJBQUt1dUMsV0FBTCxDQUFpQjk5QixNQUFqQixDQUF3QnpRLENBQXhCLEVBQTJCLENBQTNCO0FBQ0g7QUFDSjtBQWpCa0IsQ0FBdkI7O2tCQW9CZXVnQixjOzs7Ozs7Ozs7Ozs7Ozs7QUNwQmY7Ozs7QUFFQSxJQUFNb0YsV0FBVyxVQUFqQjs7QUFFQTtBQUNBLElBQU02b0IsV0FBVyxTQUFYQSxRQUFXO0FBQUEsV0FBTXp0QyxPQUFPZ2IsV0FBUCxJQUFzQnhKLFNBQVM2TSxlQUFULENBQXlCcXZCLFVBQXJEO0FBQUEsQ0FBakI7QUFDQSxJQUFNQyxXQUFXLFNBQVhBLFFBQVc7QUFBQSxXQUFNM3RDLE9BQU8rYSxXQUFQLElBQXNCdkosU0FBUzZNLGVBQVQsQ0FBeUJ2VSxTQUFyRDtBQUFBLENBQWpCOztBQUVBOzs7OztBQUtBLFNBQVM4akMsZUFBVCxDQUEwQkMsSUFBMUIsRUFBZ0M7QUFDNUIsUUFBSTdqQyxZQUFZLENBQWhCO0FBQUEsUUFDSThqQyxhQUFhLENBRGpCOztBQUdBLFFBQU03akMsZUFBZTRqQyxLQUFLNWpDLFlBQTFCO0FBQ0EsUUFBTXVQLGNBQWNxMEIsS0FBS3IwQixXQUF6Qjs7QUFFQSxPQUFHO0FBQ0MsWUFBSSxDQUFDeXZCLE1BQU00RSxLQUFLN2pDLFNBQVgsQ0FBTCxFQUE0QjtBQUN4QkEseUJBQWE2akMsS0FBSzdqQyxTQUFsQjtBQUNIO0FBQ0QsWUFBSSxDQUFDaS9CLE1BQU00RSxLQUFLQyxVQUFYLENBQUwsRUFBNkI7QUFDekJBLDBCQUFjRCxLQUFLQyxVQUFuQjtBQUNIO0FBQ0osS0FQRCxRQU9TLENBQUNELE9BQU9BLEtBQUtFLFlBQWIsTUFBK0IsSUFQeEM7O0FBU0EsV0FBTztBQUNINTBCLGFBQUtuUCxhQUFhd0gsU0FBUzZNLGVBQVQsQ0FBeUJ2VSxTQUF6QixJQUFzQzBILFNBQVNnSCxJQUFULENBQWMxTyxTQUFqRSxDQURGO0FBRUh5SSxjQUFNdTdCLGNBQWN0OEIsU0FBUzZNLGVBQVQsQ0FBeUJxdkIsVUFBekIsSUFBdUNsOEIsU0FBU2dILElBQVQsQ0FBY2sxQixVQUFuRSxDQUZIO0FBR0h2ekIsZ0JBQVFsUSxZQUhMO0FBSUhvRixlQUFPbUs7QUFKSixLQUFQO0FBTUg7O0FBRUQ7Ozs7QUFJQSxTQUFTdzBCLGdCQUFULEdBQTRCO0FBQ3hCLFdBQU87QUFDSDMrQixlQUFPbUMsU0FBUzZNLGVBQVQsQ0FBeUI5RCxXQUQ3QjtBQUVISixnQkFBUTNJLFNBQVM2TSxlQUFULENBQXlCelU7QUFGOUIsS0FBUDtBQUlIO0lBQ29Ca0MsUTtBQWtCakIsc0JBQVl0TCxLQUFaLEVBQW1CO0FBQUE7O0FBQ2YsYUFBS2tsQixVQUFMLEdBQWtCbGxCLE1BQU1rbEIsVUFBeEI7QUFDQSxhQUFLQyxXQUFMLEdBQW1CbmxCLE1BQU1tbEIsV0FBekI7QUFDQSxhQUFLdlcsS0FBTCxHQUFhNU8sTUFBTTRPLEtBQU4sSUFBZSxPQUE1QjtBQUNBLGFBQUtzVSxNQUFMLEdBQWNsakIsTUFBTWtqQixNQUFOLElBQWdCLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBOUI7QUFDQSxhQUFLNUIsVUFBTCxHQUFrQnRoQixNQUFNc2hCLFVBQU4sSUFBb0IsS0FBdEM7QUFDQSxhQUFLOEQsS0FBTCxHQUFhcGxCLE1BQU1vbEIsS0FBTixJQUFlLEtBQTVCO0FBQ0g7O0FBckJEOzs7Ozs7Ozs7Ozs7O3VCQXVCQVQsVywwQkFBYztBQUNWLFlBQU1PLGFBQWEsS0FBS0EsVUFBeEI7QUFDQSxZQUFNQyxjQUFjLEtBQUtBLFdBQXpCO0FBQ0EsWUFBTXNvQixnQkFBZ0IsS0FBS0MsaUJBQUwsRUFBdEI7QUFDQSxZQUFJQyxtQkFBSjtBQUFBLFlBQWdCQyxvQkFBaEI7QUFBQSxZQUE2QkMsNEJBQTdCO0FBQ0EsWUFBSTNvQixlQUFlZCxRQUFuQixFQUE2QjtBQUN6QjtBQUNIO0FBQ0QsWUFBSTNtQixVQUFJd1osUUFBSixDQUFhaU8sVUFBYixFQUF5QixVQUF6QixNQUF5QyxPQUE3QyxFQUFzRDtBQUNsRHpuQixzQkFBSXlaLFFBQUosQ0FBYWdPLFVBQWIsRUFBeUIsVUFBekIsRUFBcUMsVUFBckM7QUFDQXlvQix5QkFBYSxLQUFiO0FBQ0gsU0FIRCxNQUdPO0FBQ0hBLHlCQUFhLElBQWI7QUFDSDtBQUNELFlBQUl4b0IsZ0JBQWdCZixRQUFoQixJQUE0QjNtQixVQUFJd1osUUFBSixDQUFha08sV0FBYixFQUEwQixVQUExQixNQUEwQyxPQUExRSxFQUFtRjtBQUMvRXlvQiwwQkFBYyxLQUFkO0FBQ0gsU0FGRCxNQUVPO0FBQ0hBLDBCQUFjLElBQWQ7QUFDSDtBQUNEO0FBQ0EsYUFBSyxJQUFJbnZDLElBQUksQ0FBYixFQUFnQkEsSUFBSWd2QyxjQUFjOXVDLE1BQWxDLEVBQTBDRixHQUExQyxFQUErQztBQUMzQyxnQkFBTW1RLFFBQVE2K0IsY0FBY2h2QyxDQUFkLENBQWQ7QUFDQSxnQkFBTXF2QyxtQkFBbUIsS0FBS0Msa0JBQUwsQ0FBd0I3b0IsVUFBeEIsRUFBb0N0VyxNQUFNdkosS0FBTixDQUFZLEdBQVosRUFBaUIsQ0FBakIsQ0FBcEMsRUFBeURzb0MsVUFBekQsQ0FBekI7QUFDQSxnQkFBTUssb0JBQW9CLEtBQUtELGtCQUFMLENBQXdCNW9CLFdBQXhCLEVBQXFDdlcsTUFBTXZKLEtBQU4sQ0FBWSxHQUFaLEVBQWlCLENBQWpCLENBQXJDLEVBQTBEc29DLFVBQTFELENBQTFCO0FBQ0EsZ0JBQU1NLHlCQUF5QixLQUFLQyxnQkFBTCxDQUFzQmhwQixVQUF0QixDQUEvQjtBQUNBLGdCQUFNaXBCLG9CQUFxQlIsY0FBY0MsV0FBZixHQUE4QixLQUFLUSxXQUFMLENBQWlCanBCLFdBQWpCLENBQTlCLEdBQThENm9CLGtCQUFrQjlxQixNQUFsQixFQUF4RjtBQUNBLGdCQUFNdkssTUFBTXcxQixrQkFBa0J4MUIsR0FBbEIsR0FBd0JxMUIsa0JBQWtCM04sQ0FBMUMsR0FBOEM0Tix1QkFBdUJ0MUIsR0FBckUsR0FBMkVtMUIsaUJBQWlCek4sQ0FBeEc7QUFDQSxnQkFBTXR1QixPQUFPbzhCLGtCQUFrQnA4QixJQUFsQixHQUF5Qmk4QixrQkFBa0JyUCxDQUEzQyxHQUErQ3NQLHVCQUF1Qmw4QixJQUF0RSxHQUE4RSs3QixpQkFBaUJuUCxDQUE1RztBQUNBLGlCQUFLMFAscUJBQUwsQ0FBMkJucEIsVUFBM0IsRUFBdUMsRUFBQ25ULFVBQUQsRUFBTzRHLFFBQVAsRUFBdkMsRUFBb0QsS0FBS3VLLE1BQXpEOztBQUVBLGdCQUFJLENBQUMycUIsbUJBQUwsRUFBMEI7QUFDdEJBLHNDQUFzQixFQUFDOTdCLFVBQUQsRUFBTzRHLFFBQVAsRUFBdEI7QUFDSDtBQUNELGdCQUFJLEtBQUsyMUIsYUFBTCxDQUFtQnBwQixVQUFuQixDQUFKLEVBQW9DO0FBQ2hDLHVCQUFPdFcsS0FBUDtBQUNIO0FBQ0o7O0FBRUQsWUFBTTIvQixpQkFBaUIsS0FBS0Msc0JBQUwsQ0FBNEJ0cEIsVUFBNUIsRUFBd0Myb0Isb0JBQW9COTdCLElBQTVELEVBQWtFLE1BQWxFLEVBQTBFNDdCLFVBQTFFLENBQXZCO0FBQ0EsWUFBTWMsZ0JBQWdCLEtBQUtELHNCQUFMLENBQTRCdHBCLFVBQTVCLEVBQXdDMm9CLG9CQUFvQmwxQixHQUE1RCxFQUFpRSxLQUFqRSxFQUF3RWcxQixVQUF4RSxDQUF0Qjs7QUFFQSxhQUFLVSxxQkFBTCxDQUEyQm5wQixVQUEzQixFQUF1QyxFQUFDblQsTUFBTXc4QixjQUFQLEVBQXVCNTFCLEtBQUs4MUIsYUFBNUIsRUFBdkM7QUFDQSxlQUFPaEIsY0FBYyxDQUFkLENBQVA7QUFDSCxLOzt1QkFFRFMsZ0IsNkJBQWlCcHNDLE8sRUFBUztBQUN0QixZQUFNcUosU0FBU3JKLFFBQVF5ckMsWUFBUixJQUF3QnY4QixTQUFTNk0sZUFBaEQ7QUFDQSxZQUFJcUYsZUFBSjtBQUNBLFlBQUkvWCxXQUFXNkYsU0FBU2dILElBQXBCLElBQTRCdmEsVUFBSXdaLFFBQUosQ0FBYTlMLE1BQWIsRUFBcUIsVUFBckIsTUFBcUMsUUFBckUsRUFBK0U7QUFDM0UrWCxxQkFBUztBQUNMdksscUJBQUssQ0FEQTtBQUVMNUcsc0JBQU07QUFGRCxhQUFUO0FBSUgsU0FMRCxNQUtPO0FBQ0htUixxQkFBUyxLQUFLd3JCLGlCQUFMLENBQXVCdmpDLE1BQXZCLENBQVQ7QUFDSDs7QUFFRCtYLGVBQU92SyxHQUFQLElBQWNPLFdBQVd6YixVQUFJd1osUUFBSixDQUFhOUwsTUFBYixFQUFxQixrQkFBckIsQ0FBWCxFQUFxRCxFQUFyRCxDQUFkO0FBQ0ErWCxlQUFPblIsSUFBUCxJQUFlbUgsV0FBV3piLFVBQUl3WixRQUFKLENBQWE5TCxNQUFiLEVBQXFCLG1CQUFyQixDQUFYLEVBQXNELEVBQXRELENBQWY7QUFDQStYLGVBQU9xcUIsWUFBUCxHQUFzQnBpQyxNQUF0QjtBQUNBLGVBQU8rWCxNQUFQO0FBQ0gsSzs7dUJBRURzckIsc0IsbUNBQXVCdHBCLFUsRUFBWWhhLE0sRUFBUXhGLEksRUFBTWlvQyxVLEVBQVk7QUFDekQsWUFBSXh5QixTQUFTalEsTUFBYjtBQUNBLFlBQU15akMsYUFBYTM5QixTQUFTNk0sZUFBNUI7QUFDQSxZQUFNMHZCLGVBQWVyb0IsV0FBV3FvQixZQUFYLElBQTJCdjhCLFNBQVM2TSxlQUF6RDs7QUFFQSxZQUFJMUMsU0FBUyxDQUFiLEVBQWdCO0FBQ1osZ0JBQUl3eUIsVUFBSixFQUFnQjtBQUNaeHlCLHlCQUFTLENBQVQ7QUFDSCxhQUZELE1BRU8sSUFBSW95QixpQkFBaUJ2OEIsU0FBU2dILElBQTFCLElBQWtDdmEsVUFBSXdaLFFBQUosQ0FBYXMyQixZQUFiLEVBQTJCLFVBQTNCLE1BQTJDLFFBQWpGLEVBQTJGO0FBQzlGO0FBQ0FweUIseUJBQVN5ekIsS0FBS0MsR0FBTCxDQUFTRixzQkFBb0JqcEMsSUFBcEIsQ0FBVCxFQUFzQ3NMLFNBQVNnSCxJQUFULFlBQXVCdFMsSUFBdkIsQ0FBdEMsQ0FBVDtBQUNIO0FBQ0o7O0FBRUQsZUFBT3lWLE1BQVA7QUFDSCxLOzt1QkFFRDR5QixrQiwrQkFBbUJqc0MsTyxFQUFTOE0sSyxFQUFPKytCLFUsRUFBWTtBQUMzQyxZQUFNbUIsU0FBUyxLQUFLQyxpQkFBTCxDQUF1Qmp0QyxPQUF2QixFQUFnQzZyQyxVQUFoQyxDQUFmO0FBQ0EsYUFBS3FCLFlBQUwsQ0FBa0JGLE1BQWxCLEVBQTBCbGdDLEtBQTFCOztBQUVBLGVBQU9rZ0MsTUFBUDtBQUNILEs7O3VCQUVERSxZLHlCQUFhRixNLEVBQVFsZ0MsSyxFQUFPO0FBQ3hCLFlBQU0rdkIsSUFBSS92QixNQUFNdkosS0FBTixDQUFZLEVBQVosRUFBZ0IsQ0FBaEIsQ0FBVjtBQUNBLFlBQU1nN0IsSUFBSXp4QixNQUFNdkosS0FBTixDQUFZLEVBQVosRUFBZ0IsQ0FBaEIsQ0FBVjs7QUFFQXlwQyxlQUFPblEsQ0FBUCxHQUFXLEtBQUtzUSxZQUFMLENBQWtCdFEsQ0FBbEIsRUFBcUJtUSxNQUFyQixFQUE2QixPQUE3QixDQUFYO0FBQ0FBLGVBQU96TyxDQUFQLEdBQVcsS0FBSzRPLFlBQUwsQ0FBa0I1TyxDQUFsQixFQUFxQnlPLE1BQXJCLEVBQTZCLFFBQTdCLENBQVg7O0FBRUEsZUFBT0EsTUFBUDtBQUNILEs7O3VCQUVERyxZLHlCQUFhcmdDLEssRUFBT2tnQyxNLEVBQVFwcEMsSSxFQUFNO0FBQzlCLFlBQU1nakMsTUFBTTk1QixNQUFNbEksT0FBTixDQUFjLE9BQWQsRUFBdUIsSUFBdkIsRUFDUEEsT0FETyxDQUNDLEtBREQsRUFDUSxLQURSLEVBRVBBLE9BRk8sQ0FFQyxPQUZELEVBRVUsTUFGVixFQUdQQSxPQUhPLENBR0MsVUFIRCxFQUdhLFVBQVN3b0MsQ0FBVCxFQUFZN1YsQ0FBWixFQUFlO0FBQ2hDLG1CQUFPeVYsT0FBT25wQyxJQUFQLEdBQWNELElBQWQsS0FBdUIyekIsSUFBSSxHQUEzQixDQUFQO0FBQ0gsU0FMTyxDQUFaOztBQU9BLGVBQU9uZ0IsV0FBV3d2QixHQUFYLEVBQWdCLEVBQWhCLEtBQXVCLENBQTlCO0FBQ0gsSzs7dUJBRUQwRixXLHdCQUFZdHNDLE8sRUFBUztBQUNqQixlQUFPO0FBQ0hpUSxrQkFBTW1ILFdBQVd6YixVQUFJd1osUUFBSixDQUFhblYsT0FBYixFQUFzQixNQUF0QixDQUFYLEtBQTZDLENBRGhEO0FBRUg2VyxpQkFBS08sV0FBV3piLFVBQUl3WixRQUFKLENBQWFuVixPQUFiLEVBQXNCLEtBQXRCLENBQVgsS0FBNEM7QUFGOUMsU0FBUDtBQUlILEs7O3VCQUVEaXRDLGlCLDhCQUFrQmp0QyxPLEVBQVM2ckMsVSxFQUFZO0FBQUE7O0FBQ25DLFlBQU14eUIsU0FBUztBQUNQcloscUJBQVNBLE9BREY7QUFFUDY4QixlQUFHLENBRkk7QUFHUDBCLGVBQUc7QUFISSxTQUFmO0FBQUEsWUFJTzhPLGFBQWNydEMsWUFBWXNpQixRQUpqQztBQUFBLFlBSTRDdXFCLGFBQWEzOUIsU0FBUzZNLGVBSmxFOztBQU1BMUMsZUFBTytILE1BQVAsR0FBZ0IsWUFBTTtBQUNsQixnQkFBSXlxQixVQUFKLEVBQWdCO0FBQ1osdUJBQU87QUFDSDU3QiwwQkFBTSxDQURIO0FBRUg0Ryx5QkFBSztBQUZGLGlCQUFQO0FBSUgsYUFMRCxNQUtPLElBQUl3MkIsVUFBSixFQUFnQjtBQUNuQix1QkFBTztBQUNIcDlCLDBCQUFNazdCLFVBREg7QUFFSHQwQix5QkFBS3cwQjtBQUZGLGlCQUFQO0FBSUgsYUFMTSxNQUtBO0FBQ0gsdUJBQU8sTUFBS3VCLGlCQUFMLENBQXVCNXNDLE9BQXZCLENBQVA7QUFDSDtBQUNKLFNBZEQ7O0FBZ0JBcVosZUFBT3hWLElBQVAsR0FBYyxZQUFNO0FBQ2hCLGdCQUFJd3BDLFVBQUosRUFBZ0I7QUFDWix1QkFBTztBQUNIdGdDLDJCQUFPOC9CLFdBQVc1MEIsV0FEZjtBQUVISiw0QkFBUWcxQixXQUFXdmxDO0FBRmhCLGlCQUFQO0FBSUgsYUFMRCxNQUtPO0FBQ0gsdUJBQU87QUFDSHlGLDJCQUFPL00sUUFBUWtYLFdBRFo7QUFFSFcsNEJBQVE3WCxRQUFRMkg7QUFGYixpQkFBUDtBQUlIO0FBQ0osU0FaRDs7QUFjQSxlQUFPMFIsTUFBUDtBQUNILEs7O3VCQUVEdXpCLGlCLDhCQUFrQjVzQyxPLEVBQVM7QUFDdkIsWUFBTW9ZLE9BQU9wWSxRQUFRcVkscUJBQVIsRUFBYjtBQUNBLFlBQU13MEIsYUFBYTM5QixTQUFTNk0sZUFBNUI7QUFDQSxZQUFNN0YsT0FBT2hILFNBQVNnSCxJQUF0QjtBQUNBLFlBQU1vM0IsZ0JBQWlCVCxXQUFXVSxVQUFYLElBQXlCcjNCLEtBQUtxM0IsVUFBOUIsSUFBNEMsQ0FBbkU7QUFDQSxZQUFNQyxlQUFnQlgsV0FBV1ksU0FBWCxJQUF3QnYzQixLQUFLdTNCLFNBQTdCLElBQTBDLENBQWhFOztBQUVBLGVBQU87QUFDSHg5QixrQkFBTW1JLEtBQUtuSSxJQUFMLElBQWFrN0IsYUFBYW1DLGFBQTFCLENBREg7QUFFSHoyQixpQkFBS3VCLEtBQUt2QixHQUFMLElBQVl3MEIsYUFBYW1DLFlBQXpCO0FBRkYsU0FBUDtBQUlILEs7O0FBRUQ7Ozt1QkFDQTVCLGlCLGdDQUFvQjtBQUNoQixZQUFNOStCLFFBQVEsS0FBS3dXLEtBQUwsR0FBYSxLQUFLb3FCLGdCQUFMLENBQXNCLEtBQUs1Z0MsS0FBM0IsRUFBa0MsTUFBbEMsRUFBMEMsRUFBQzZnQyxHQUFHLEdBQUosRUFBU0MsR0FBRyxHQUFaLEVBQTFDLENBQWIsR0FBMkUsS0FBSzlnQyxLQUE5RjtBQUNBLFlBQU02K0IsZ0JBQWdCLENBQUM3K0IsS0FBRCxDQUF0Qjs7QUFFQSxZQUFJLEtBQUswUyxVQUFULEVBQXFCO0FBQ2pCLGdCQUFJLE9BQU9ySSxJQUFQLENBQVlySyxLQUFaLENBQUosRUFBd0I7QUFDcEI2K0IsOEJBQWMzdUMsSUFBZCxDQUFtQixLQUFLMHdDLGdCQUFMLENBQXNCNWdDLEtBQXRCLEVBQTZCLE1BQTdCLEVBQXFDLEVBQUMrZ0MsR0FBRyxHQUFKLEVBQVM3eUIsR0FBRyxHQUFaLEVBQXJDLENBQW5CO0FBQ0g7QUFDRCxnQkFBSSxPQUFPN0QsSUFBUCxDQUFZckssS0FBWixDQUFKLEVBQXdCO0FBQ3BCNitCLDhCQUFjM3VDLElBQWQsQ0FBbUIsS0FBSzB3QyxnQkFBTCxDQUFzQjVnQyxLQUF0QixFQUE2QixNQUE3QixFQUFxQyxFQUFDNmdDLEdBQUcsR0FBSixFQUFTQyxHQUFHLEdBQVosRUFBckMsQ0FBbkI7QUFDSDtBQUNELGdCQUFJLEtBQUt6MkIsSUFBTCxDQUFVckssS0FBVixDQUFKLEVBQXNCO0FBQ2xCNitCLDhCQUFjM3VDLElBQWQsQ0FBbUIsS0FBSzB3QyxnQkFBTCxDQUFzQjVnQyxLQUF0QixFQUE2QixXQUE3QixFQUEwQyxFQUFDZ2hDLEdBQUcsR0FBSixFQUExQyxDQUFuQjtBQUNBbkMsOEJBQWMzdUMsSUFBZCxDQUFtQixLQUFLMHdDLGdCQUFMLENBQXNCNWdDLEtBQXRCLEVBQTZCLFdBQTdCLEVBQTBDLEVBQUNnaEMsR0FBRyxHQUFKLEVBQTFDLENBQW5CO0FBQ0g7QUFDRG5DLDBCQUFjM3VDLElBQWQsQ0FBbUIsS0FBSzB3QyxnQkFBTCxDQUFzQjVnQyxLQUF0QixFQUE2QixVQUE3QixFQUF5QyxFQUFDNmdDLEdBQUcsR0FBSixFQUFTQyxHQUFHLEdBQVosRUFBaUJDLEdBQUcsR0FBcEIsRUFBeUI3eUIsR0FBRyxHQUE1QixFQUF6QyxDQUFuQjtBQUNIO0FBQ0QsZUFBTzJ3QixhQUFQO0FBQ0gsSzs7QUFFRDs7O3VCQUNBK0IsZ0IsNkJBQWlCNWdDLEssRUFBT2loQyxNLEVBQVEzc0MsRyxFQUFLO0FBQ2pDLGVBQU8wTCxNQUFNbEksT0FBTixDQUFjbXBDLE1BQWQsRUFBc0IsZUFBTztBQUNoQyxtQkFBTzNzQyxJQUFJd2xDLEdBQUosQ0FBUDtBQUNILFNBRk0sQ0FBUDtBQUdILEs7O0FBRUQ7Ozt1QkFDQTRGLGEsMEJBQWN4c0MsTyxFQUFTO0FBQ25CLFlBQU1ndUMsZUFBZXRDLGtCQUFyQjtBQUNBO0FBQ0EsWUFBTXVDLGNBQWMzQyxnQkFBZ0J0ckMsT0FBaEIsQ0FBcEI7QUFDQSxlQUFRaXVDLFlBQVloK0IsSUFBWixJQUFvQixDQUFwQixJQUF5QmcrQixZQUFZaCtCLElBQVosR0FBbUJqUSxRQUFRa1gsV0FBM0IsSUFBMEM4MkIsYUFBYWpoQyxLQUFoRixJQUNKa2hDLFlBQVlwM0IsR0FBWixJQUFtQixDQURmLElBQ29CbzNCLFlBQVlwM0IsR0FBWixHQUFrQjdXLFFBQVEySCxZQUExQixJQUEwQ3FtQyxhQUFhbjJCLE1BRG5GO0FBRUgsSztBQUNEOzs7dUJBQ0EwMEIscUIsa0NBQXNCbnBCLFUsRUFBWThxQixPLEVBQTBCO0FBQUEsWUFBakI5c0IsTUFBaUIsdUVBQVIsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFRO0FBQUEsWUFDakR2SyxHQURpRCxHQUNwQ3EzQixPQURvQyxDQUNqRHIzQixHQURpRDtBQUFBLFlBQzVDNUcsSUFENEMsR0FDcENpK0IsT0FEb0MsQ0FDNUNqK0IsSUFENEM7O0FBRXhELFlBQUksQ0FBQyxLQUFLcVQsS0FBVixFQUFpQjtBQUNiM25CLHNCQUFJeVosUUFBSixDQUFhZ08sVUFBYixFQUF5QjtBQUNyQm5ULHNCQUFTQSxPQUFPbVIsT0FBTyxDQUFQLENBQWhCLE9BRHFCO0FBRXJCdksscUJBQVFBLE1BQU11SyxPQUFPLENBQVAsQ0FBZDtBQUZxQixhQUF6QjtBQUlBO0FBQ0g7O0FBRUQ7QUFDQSxZQUFNK3FCLHlCQUF5QixLQUFLQyxnQkFBTCxDQUFzQmhwQixVQUF0QixDQUEvQjs7QUFYd0QsK0JBWXBCa29CLGdCQUFnQmEsdUJBQXVCVixZQUF2QyxDQVpvQjtBQUFBLFlBWTFDMEMsaUJBWjBDLG9CQVlqRHBoQyxLQVppRDs7QUFBQSwrQkFheEN1K0IsZ0JBQWdCbG9CLFVBQWhCLENBYndDO0FBQUEsWUFhakRyVyxLQWJpRCxvQkFhakRBLEtBYmlEOztBQWN4RCxZQUFNK0osUUFBUXEzQixxQkFBcUJsK0IsT0FBT2xELEtBQTVCLENBQWQ7QUFDQXBSLGtCQUFJeVosUUFBSixDQUFhZ08sVUFBYixFQUF5QjtBQUNyQm5ULGtCQUFNLE1BRGU7QUFFckI2RyxtQkFBVUEsUUFBUXNLLE9BQU8sQ0FBUCxDQUFsQixPQUZxQjtBQUdyQnZLLGlCQUFRQSxNQUFNdUssT0FBTyxDQUFQLENBQWQ7QUFIcUIsU0FBekI7QUFLSCxLOzs7WUExUE1rQixRLEdBQVdBLFEsU0FhWE0sSyxHQUFRO0FBQUEsV0FBUyxJQUFJcFosUUFBSixDQUFhdEwsS0FBYixFQUFvQjJrQixXQUFwQixFQUFUO0FBQUEsQztrQkFmRXJaLFE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0NyQjs7OztBQUNBOztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7SUFFUUcsSSxHQUE2QjlOLFUsQ0FBN0I4TixJO0lBQU0rUixTLEdBQXVCN2YsVSxDQUF2QjZmLFM7SUFBV3hWLE8sR0FBWXJLLFUsQ0FBWnFLLE87O0FBRXpCOzs7OztJQUlxQnVELEs7OztBQXFFakIsbUJBQVl2TCxLQUFaLEVBQW1CO0FBQUE7O0FBQUEscURBQ2Ysc0JBQU1BLEtBQU4sQ0FEZTs7QUFHZixjQUFLZ0osS0FBTCxHQUFhO0FBQ1R1VixxQkFBUyxPQUFPdmUsTUFBTXVlLE9BQWIsS0FBeUIsV0FBekIsR0FBdUN2ZSxNQUFNa3dDLGNBQTdDLEdBQThEbHdDLE1BQU11ZTtBQURwRSxTQUFiOztBQUlBdlcsdUJBQWMsQ0FDVixvQkFEVSxFQUNZLHNCQURaLEVBRVYseUJBRlUsRUFFaUIseUJBRmpCLEVBR1Ysb0JBSFUsRUFHWSxtQkFIWixFQUlWLHlCQUpVLEVBSWlCLHlCQUpqQixFQUtWLHdCQUxVLEVBS2dCLG9CQUxoQixFQU1WLHNCQU5VLEVBTWMsc0JBTmQsQ0FBZDtBQVBlO0FBZWxCOztvQkFFRG5ILHlCLHNDQUEwQkMsUyxFQUFXO0FBQ2pDLFlBQUksYUFBYUEsU0FBakIsRUFBNEI7QUFDeEIsaUJBQUt3ZSxRQUFMLENBQWM7QUFDVmYseUJBQVN6ZCxVQUFVeWQ7QUFEVCxhQUFkO0FBR0g7QUFDSixLOztvQkFFRHZkLG9CLG1DQUF1QjtBQUFBOztBQUNuQixTQUFDLFFBQUQsRUFBVyxZQUFYLEVBQXlCLFlBQXpCLEVBQXVDK0QsT0FBdkMsQ0FBK0MsZ0JBQVE7QUFDbkQsbUJBQUtxYyxJQUFMLEtBQWNaLGFBQWEsT0FBS1ksSUFBTCxDQUFiLENBQWQ7QUFDSCxTQUZEO0FBR0gsSzs7b0JBRUQrdUIsbUIsZ0NBQW9CNXhCLE8sRUFBUzdZLEksRUFBTXZFLEMsRUFBRztBQUNsQyxZQUFJLEVBQUUsYUFBYSxLQUFLbkIsS0FBcEIsQ0FBSixFQUFnQztBQUM1QixpQkFBS3NmLFFBQUwsQ0FBYztBQUNWZjtBQURVLGFBQWQ7QUFHSDs7QUFFRCxhQUFLdmUsS0FBTCxDQUFXdTFCLGVBQVgsQ0FBMkJoWCxPQUEzQixFQUFvQzdZLElBQXBDLEVBQTBDdkUsQ0FBMUM7QUFDSCxLOztvQkFFRGl2QyxrQiwrQkFBbUJqdkMsQyxFQUFHO0FBQ2xCLFlBQUksS0FBSzZILEtBQUwsQ0FBV3VWLE9BQVgsSUFBc0IsQ0FBQyxLQUFLdmUsS0FBTCxDQUFXcXdDLGlCQUF0QyxFQUF5RDtBQUNyRDtBQUNIOztBQUVELGFBQUtGLG1CQUFMLENBQXlCLENBQUMsS0FBS25uQyxLQUFMLENBQVd1VixPQUFyQyxFQUE4QyxhQUE5QyxFQUE2RHBkLENBQTdEO0FBQ0gsSzs7b0JBRURtdkMsb0IsaUNBQXFCbnZDLEMsRUFBRztBQUNwQixZQUFJQSxFQUFFdVEsT0FBRixLQUFjdlQsY0FBUXdULEtBQXRCLElBQStCeFEsRUFBRXVRLE9BQUYsS0FBY3ZULGNBQVFtZCxLQUF6RCxFQUFnRTtBQUM1RG5hLGNBQUUySSxjQUFGO0FBQ0EsaUJBQUtzbUMsa0JBQUwsQ0FBd0JqdkMsQ0FBeEI7QUFDSDtBQUNKLEs7O29CQUVEb3ZDLHVCLG9DQUF3QnB2QyxDLEVBQUc7QUFBQTs7QUFDdkIsYUFBS3F2QyxvQkFBTCxHQUE0QixLQUE1Qjs7QUFFQSxZQUFJLEtBQUtDLFVBQVQsRUFBcUI7QUFDakJqd0IseUJBQWEsS0FBS2l3QixVQUFsQjtBQUNBLGlCQUFLQSxVQUFMLEdBQWtCLElBQWxCO0FBQ0g7QUFDRCxZQUFJLEtBQUtDLFVBQVQsRUFBcUI7QUFDakJsd0IseUJBQWEsS0FBS2t3QixVQUFsQjtBQUNBLGlCQUFLQSxVQUFMLEdBQWtCLElBQWxCO0FBQ0g7QUFDRCxZQUFJLENBQUMsS0FBSzFuQyxLQUFMLENBQVd1VixPQUFoQixFQUF5QjtBQUNyQixpQkFBS215QixVQUFMLEdBQWtCNXdCLFdBQVcsWUFBTTtBQUMvQix1QkFBS3F3QixtQkFBTCxDQUF5QixJQUF6QixFQUErQixhQUEvQixFQUE4Q2h2QyxDQUE5QztBQUNILGFBRmlCLEVBRWYsS0FBS25CLEtBQUwsQ0FBVzJ3QyxLQUZJLENBQWxCO0FBR0g7QUFDSixLOztvQkFFREMsdUIsb0NBQXdCenZDLEMsRUFBR3VFLEksRUFBTTtBQUFBOztBQUM3QixZQUFJLEtBQUtnckMsVUFBVCxFQUFxQjtBQUNqQmx3Qix5QkFBYSxLQUFLa3dCLFVBQWxCO0FBQ0EsaUJBQUtBLFVBQUwsR0FBa0IsSUFBbEI7QUFDSDtBQUNELFlBQUksS0FBSzFuQyxLQUFMLENBQVd1VixPQUFmLEVBQXdCO0FBQ3BCLGlCQUFLa3lCLFVBQUwsR0FBa0Izd0IsV0FBVyxZQUFNO0FBQy9CLHVCQUFLcXdCLG1CQUFMLENBQXlCLEtBQXpCLEVBQWdDenFDLFFBQVEsYUFBeEMsRUFBdUR2RSxDQUF2RDtBQUNILGFBRmlCLEVBRWYsS0FBS25CLEtBQUwsQ0FBVzJ3QyxLQUZJLENBQWxCO0FBR0g7QUFDSixLOztvQkFFREUsa0IsK0JBQW1CMXZDLEMsRUFBRztBQUNsQixhQUFLZ3ZDLG1CQUFMLENBQXlCLElBQXpCLEVBQStCLGFBQS9CLEVBQThDaHZDLENBQTlDO0FBQ0gsSzs7b0JBRUQydkMsaUIsOEJBQWtCM3ZDLEMsRUFBRztBQUNqQixZQUFJLENBQUMsS0FBSzR2QyxpQkFBVixFQUE2QjtBQUN6QixpQkFBS1osbUJBQUwsQ0FBeUIsS0FBekIsRUFBZ0MsYUFBaEMsRUFBK0NodkMsQ0FBL0M7QUFDSDtBQUNELGFBQUs0dkMsaUJBQUwsR0FBeUIsS0FBekI7QUFDSCxLOztvQkFFREMsc0IscUNBQXlCO0FBQ3JCLGFBQUtELGlCQUFMLEdBQXlCLElBQXpCO0FBQ0gsSzs7b0JBRURFLHVCLHNDQUEwQjtBQUN0Qnp3QixxQkFBYSxLQUFLaXdCLFVBQWxCO0FBQ0gsSzs7b0JBRURTLHVCLG9DQUF3Qi92QyxDLEVBQUc7QUFDdkIsYUFBS3l2Qyx1QkFBTCxDQUE2Qnp2QyxDQUE3QixFQUFnQyxhQUFoQztBQUNILEs7O29CQUVEZ3dDLG9CLG1DQUF1QjtBQUNuQixZQUFJLENBQUMsS0FBS1gsb0JBQVYsRUFBZ0M7QUFDNUJod0IseUJBQWEsS0FBS2l3QixVQUFsQjtBQUNBLGlCQUFLQSxVQUFMLEdBQWtCLElBQWxCO0FBQ0EsaUJBQUtELG9CQUFMLEdBQTRCLEtBQTVCO0FBQ0g7QUFDSixLOztvQkFFRFksb0IsbUNBQXVCO0FBQ25CLGFBQUtaLG9CQUFMLEdBQTRCLElBQTVCO0FBQ0gsSzs7b0JBRURhLGtCLCtCQUFtQjNyQyxJLEVBQU12RSxDLEVBQUc7QUFDeEIsYUFBS2d2QyxtQkFBTCxDQUF5QixLQUF6QixFQUFnQ3pxQyxJQUFoQyxFQUFzQ3ZFLENBQXRDO0FBQ0gsSzs7b0JBRURtd0MsYSw0QkFBZ0I7QUFBQTs7QUFBQSxxQkFDa0IsS0FBS3R4QyxLQUR2QjtBQUFBLFlBQ0pvMkIsT0FESSxVQUNKQSxPQURJO0FBQUEsWUFDS3h0QixRQURMLFVBQ0tBLFFBREw7O0FBRVosWUFBTTVJLFFBQVE7QUFDVmIsaUJBQUssU0FESztBQUVWLDZCQUFpQixJQUZQO0FBR1YsNkJBQWlCLEtBQUs2SixLQUFMLENBQVd1VjtBQUhsQixTQUFkOztBQU1BLFlBQUksQ0FBQzNWLFFBQUwsRUFBZTtBQUFBLGdCQUNId2dCLFdBREcsR0FDYSxLQUFLcHBCLEtBRGxCLENBQ0hvcEIsV0FERzs7QUFFWCxnQkFBTW1vQixlQUFleHlDLE1BQU1DLE9BQU4sQ0FBY29xQixXQUFkLElBQTZCQSxXQUE3QixHQUEyQyxDQUFDQSxXQUFELENBQWhFO0FBRlcsaUNBR2lFZ04sUUFBUXAyQixLQUh6RTtBQUFBLGdCQUdINkosT0FIRyxrQkFHSEEsT0FIRztBQUFBLGdCQUdNSSxTQUhOLGtCQUdNQSxTQUhOO0FBQUEsZ0JBR2lCOEQsWUFIakIsa0JBR2lCQSxZQUhqQjtBQUFBLGdCQUcrQkUsWUFIL0Isa0JBRytCQSxZQUgvQjtBQUFBLGdCQUc2Q3FxQixPQUg3QyxrQkFHNkNBLE9BSDdDO0FBQUEsZ0JBR3NEdlEsTUFIdEQsa0JBR3NEQSxNQUh0RDs7QUFJWHdwQix5QkFBYXhzQyxPQUFiLENBQXFCLHVCQUFlO0FBQ2hDLHdCQUFRcWtCLFdBQVI7QUFDSSx5QkFBSyxPQUFMO0FBQ0lwcEIsOEJBQU02SixPQUFOLEdBQWdCMlQsVUFBVSxPQUFLNHlCLGtCQUFmLEVBQW1Ddm1DLE9BQW5DLENBQWhCO0FBQ0E3Siw4QkFBTWlLLFNBQU4sR0FBa0J1VCxVQUFVLE9BQUs4eUIsb0JBQWYsRUFBcUNybUMsU0FBckMsQ0FBbEI7QUFDQTtBQUNKLHlCQUFLLE9BQUw7QUFDSWpLLDhCQUFNK04sWUFBTixHQUFxQnlQLFVBQVUsT0FBSyt5Qix1QkFBZixFQUF3Q3hpQyxZQUF4QyxDQUFyQjtBQUNBL04sOEJBQU1pTyxZQUFOLEdBQXFCdVAsVUFBVSxPQUFLb3pCLHVCQUFmLEVBQXdDM2lDLFlBQXhDLENBQXJCO0FBQ0E7QUFDSix5QkFBSyxPQUFMO0FBQ0lqTyw4QkFBTXM0QixPQUFOLEdBQWdCOWEsVUFBVSxPQUFLcXpCLGtCQUFmLEVBQW1DdlksT0FBbkMsQ0FBaEI7QUFDQXQ0Qiw4QkFBTStuQixNQUFOLEdBQWV2SyxVQUFVLE9BQUtzekIsaUJBQWYsRUFBa0Mvb0IsTUFBbEMsQ0FBZjtBQUNBO0FBQ0o7QUFDSTtBQWRSO0FBZ0JILGFBakJEO0FBa0JIOztBQUVELGVBQU9wYSxnQkFBTTJDLFlBQU4sQ0FBbUI4bEIsT0FBbkIsRUFBNEJwMkIsS0FBNUIsQ0FBUDtBQUNILEs7O29CQUVEd3hDLGEsNEJBQWdCO0FBQUE7O0FBQUEsc0JBQ3NCLEtBQUt4eEMsS0FEM0I7QUFBQSxZQUNKd0IsUUFESSxXQUNKQSxRQURJO0FBQUEsWUFDTTRuQixXQUROLFdBQ01BLFdBRE47O0FBRVosWUFBTW1vQixlQUFleHlDLE1BQU1DLE9BQU4sQ0FBY29xQixXQUFkLElBQTZCQSxXQUE3QixHQUEyQyxDQUFDQSxXQUFELENBQWhFO0FBQ0EsWUFBTWhtQixVQUFVOUIsZ0JBQVNDLElBQVQsQ0FBY0MsUUFBZCxDQUFoQjtBQUhZLDZCQUl3QzRCLFFBQVFwRCxLQUpoRDtBQUFBLFlBSUp5eEMsV0FKSSxrQkFJSkEsV0FKSTtBQUFBLFlBSVMxakMsWUFKVCxrQkFJU0EsWUFKVDtBQUFBLFlBSXVCRSxZQUp2QixrQkFJdUJBLFlBSnZCOztBQUtaLFlBQU1qTyxRQUFRO0FBQ1ZiLGlCQUFLO0FBREssU0FBZDs7QUFJQW95QyxxQkFBYXhzQyxPQUFiLENBQXFCLHVCQUFlO0FBQ2hDLG9CQUFRcWtCLFdBQVI7QUFDSSxxQkFBSyxPQUFMO0FBQ0lwcEIsMEJBQU15eEMsV0FBTixHQUFvQmowQixVQUFVLE9BQUt3ekIsc0JBQWYsRUFBdUNTLFdBQXZDLENBQXBCO0FBQ0E7QUFDSixxQkFBSyxPQUFMO0FBQ0l6eEMsMEJBQU0rTixZQUFOLEdBQXFCeVAsVUFBVSxPQUFLeXpCLHVCQUFmLEVBQXdDbGpDLFlBQXhDLENBQXJCO0FBQ0EvTiwwQkFBTWlPLFlBQU4sR0FBcUJ1UCxVQUFVLE9BQUswekIsdUJBQWYsRUFBd0NqakMsWUFBeEMsQ0FBckI7QUFDQTtBQUNKO0FBQ0k7QUFUUjtBQVdILFNBWkQ7O0FBY0EsZUFBT04sZ0JBQU0yQyxZQUFOLENBQW1CbE4sT0FBbkIsRUFBNEJwRCxLQUE1QixDQUFQO0FBQ0gsSzs7b0JBRUQweEMsWSwyQkFBZTtBQUFBOztBQUFBLHNCQUNnRixLQUFLMXhDLEtBRHJGO0FBQUEsWUFDSDhRLE1BREcsV0FDSEEsTUFERztBQUFBLFlBQ0s2UixRQURMLFdBQ0tBLFFBREw7QUFBQSxZQUNlZ3ZCLGFBRGYsV0FDZUEsYUFEZjtBQUFBLFlBQzhCdm9CLFdBRDlCLFdBQzhCQSxXQUQ5QjtBQUFBLFlBQzJDaEcsT0FEM0MsV0FDMkNBLE9BRDNDO0FBQUEsWUFDb0RHLFlBRHBELFdBQ29EQSxZQURwRDtBQUFBLFlBQ3FFeGIsTUFEckU7O0FBQUEsWUFFTm9iLFNBRk0sR0FFTyxLQUFLbmpCLEtBRlosQ0FFTm1qQixTQUZNOztBQUdYLFlBQU15dUIsa0JBQWtCLFNBQWxCQSxlQUFrQjtBQUFBLG1CQUFPLDJCQUFZLE1BQVosS0FBcUIsRUFBNUI7QUFBQSxTQUF4QjtBQUNBLFlBQU1odkIsWUFBWTdqQixNQUFNQyxPQUFOLENBQWMyakIsUUFBZCxjQUE4QkEsUUFBOUIsSUFBMEMsQ0FBQ0EsUUFBRCxDQUE1RDtBQUNBQyxrQkFBVUMsT0FBVixDQUFrQit1QixlQUFsQjs7QUFFQSxZQUFNMXRCLGtCQUFrQlgsZ0JBQWdCLEVBQXhDOztBQUVBLFlBQUlvdUIsYUFBSixFQUFtQjtBQUNmeHVCLHdCQUFZO0FBQUEsdUJBQVdpVCxRQUFROXRCLFVBQW5CO0FBQUEsYUFBWjtBQUNBNGIsNEJBQWdCeEssUUFBaEIsR0FBMkIsVUFBM0I7QUFDSDs7QUFFRCxZQUFJMFAsZ0JBQWdCLE9BQWhCLElBQTJCaEcsT0FBL0IsRUFBd0M7QUFDcENyYixtQkFBTzZiLGdCQUFQLEdBQTBCLEtBQUt1dEIsb0JBQS9CO0FBQ0FwcEMsbUJBQU84YixnQkFBUCxHQUEwQixLQUFLdXRCLG9CQUEvQjtBQUNIOztBQUVELGVBQ0k7QUFBQyw2QkFBRDtBQUFBLHlCQUFhcnBDLE1BQWI7QUFDSSxxQkFBSSxTQURSO0FBRUkscUJBQUs7QUFBQSwyQkFBWSxPQUFLOHRCLE9BQUwsR0FBZUEsT0FBM0I7QUFBQSxpQkFGVDtBQUdJLHlCQUFTLEtBQUs3c0IsS0FBTCxDQUFXdVYsT0FIeEI7QUFJSSx3QkFBUXpOLFVBQVU4Z0MsZUFKdEI7QUFLSSwyQkFBV3p1QixTQUxmO0FBTUksMEJBQVVQLFNBTmQ7QUFPSSw4QkFBY3NCLGVBUGxCO0FBUUksNkJBQWFrRixXQVJqQjtBQVNJLHlCQUFTaEcsT0FUYjtBQVVJLGdDQUFnQixLQUFLaXVCLGtCQVZ6QjtBQVdLLGlCQUFLRyxhQUFMO0FBWEwsU0FESjtBQWVILEs7O29CQUVEbndDLE0scUJBQVM7QUFDTCxlQUFPLENBQ0gsS0FBS2l3QyxhQUFMLEVBREcsRUFFSCxLQUFLSSxZQUFMLEVBRkcsQ0FBUDtBQUlILEs7OztFQXhTOEJqd0MsZ0IsVUFDeEJDLFMsR0FBWTtBQUNmOzs7QUFHQUYsY0FBVUcsb0JBQVU4TyxJQUpMO0FBS2Y7OztBQUdBMmxCLGFBQVN6MEIsb0JBQVVHLE9BUko7QUFTZjs7O0FBR0FzbkIsaUJBQWF6bkIsb0JBQVU2TyxTQUFWLENBQW9CLENBQUM3TyxvQkFBVUMsTUFBWCxFQUFtQkQsb0JBQVVrTSxLQUE3QixDQUFwQixDQVpFO0FBYWY7OztBQUdBMFEsYUFBUzVjLG9CQUFVRSxJQWhCSjtBQWlCZjs7O0FBR0FxdUMsb0JBQWdCdnVDLG9CQUFVRSxJQXBCWDtBQXFCZjs7Ozs7O0FBTUEwekIscUJBQWlCNXpCLG9CQUFVaEUsSUEzQlo7QUE0QmY7OztBQUdBaUwsY0FBVWpILG9CQUFVRSxJQS9CTDtBQWdDZjs7O0FBR0E4dUMsV0FBT2h2QyxvQkFBVXVKLE1BbkNGO0FBb0NmOzs7QUFHQW1sQyx1QkFBbUIxdUMsb0JBQVVFLElBdkNkO0FBd0NmOzs7O0FBSUFpUCxZQUFRblAsb0JBQVVpTSxHQTVDSDtBQTZDZitVLGNBQVVoaEIsb0JBQVVpTSxHQTdDTDtBQThDZjs7O0FBR0ErakMsbUJBQWVod0Msb0JBQVVFLElBakRWO0FBa0Rmc2hCLGVBQVd4aEIsb0JBQVVpTSxHQWxETjtBQW1EZndWLGFBQVN6aEIsb0JBQVVFLElBbkRKO0FBb0RmMGhCLGtCQUFjNWhCLG9CQUFVakYsTUFwRFQ7QUFxRGYyRCxTQUFLc0Isb0JBQVVFO0FBckRBLEMsU0F3RFpFLFksR0FBZTtBQUNsQnFuQixpQkFBYSxPQURLO0FBRWxCOG1CLG9CQUFnQixLQUZFO0FBR2xCM2EscUJBQWlCOXBCLElBSEM7QUFJbEI3QyxjQUFVLEtBSlE7QUFLbEIrbkMsV0FBTyxHQUxXO0FBTWxCTix1QkFBbUIsSUFORDtBQU9sQnNCLG1CQUFlLEtBUEc7QUFRbEJ4dUIsZUFBVztBQUFBLGVBQU1uUyxTQUFTZ0gsSUFBZjtBQUFBLEtBUk87QUFTbEIzWCxTQUFLO0FBVGEsQztBQXpETGtMLEs7a0JBQUFBLEs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNackI7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0lBRU9FLEksR0FBNEI5TixVLENBQTVCOE4sSTtJQUFNK1IsUyxHQUFzQjdmLFUsQ0FBdEI2ZixTO0lBQVd4VixPLEdBQVdySyxVLENBQVhxSyxPOztBQUN4QixJQUFNdUQsUUFBUUgsa0JBQVFHLEtBQXRCOztBQUVBOzs7O0lBSU1zbUMsUTs7O0FBa0ZGLG9CQUFZN3hDLEtBQVosRUFBbUI7QUFBQTs7QUFBQSxpREFDZixzQkFBTUEsS0FBTixDQURlOztBQUdmLFVBQUtnSixLQUFMLEdBQWE7QUFDVHVWLGVBQVMsYUFBYXZlLEtBQWIsR0FBcUJBLE1BQU11ZSxPQUEzQixHQUFzQ3ZlLE1BQU1rd0MsY0FBTixJQUF3QjtBQUQ5RCxLQUFiOztBQUlBbG9DLG1CQUFjLENBQ1YsYUFEVSxFQUVWLGlCQUZVLENBQWQ7QUFQZTtBQVdsQjs7cUJBRUQ4cEMsVSx5QkFBK0I7QUFBQSxRQUFwQjl4QyxLQUFvQix1RUFBWixLQUFLQSxLQUFPOztBQUMzQixXQUFPLGFBQWFBLEtBQWIsR0FBcUJBLE1BQU11ZSxPQUEzQixHQUFxQyxLQUFLdlYsS0FBTCxDQUFXdVYsT0FBdkQ7QUFDSCxHOztxQkFFRHd6QixXLDBCQUFjO0FBQ1YsU0FBS3hjLGVBQUwsQ0FBcUIsS0FBckIsRUFBNEIsYUFBNUI7QUFDSCxHOztxQkFFREEsZSw0QkFBZ0JoWCxPLEVBQVNvbEIsSSxFQUFNO0FBQzNCLFNBQUtya0IsUUFBTCxDQUFjLEVBQUNmLGdCQUFELEVBQWQ7O0FBRUEsU0FBS3ZlLEtBQUwsQ0FBV3UxQixlQUFYLENBQTJCaFgsT0FBM0IsRUFBb0NvbEIsSUFBcEM7QUFDSCxHOztxQkFFRHRpQyxNLHFCQUFTO0FBQ0wsUUFBSWdKLFFBQVEvSSxnQkFBU0MsSUFBVCxDQUFjLEtBQUt2QixLQUFMLENBQVd3QixRQUF6QixDQUFaO0FBQ0EsUUFBSSxPQUFPNkksTUFBTTNFLElBQWIsS0FBc0IsVUFBdEIsSUFBb0MyRSxNQUFNM0UsSUFBTixDQUFXOGxCLFVBQW5ELEVBQStEO0FBQzNEbmhCLGNBQVFzRCxnQkFBTTJDLFlBQU4sQ0FBbUJqRyxLQUFuQixFQUEwQjtBQUM5QmdnQixxQkFBYTdNLFVBQVUsS0FBS3UwQixXQUFmLEVBQTRCMW5DLE1BQU1ySyxLQUFOLENBQVlxcUIsV0FBeEM7QUFEaUIsT0FBMUIsQ0FBUjtBQUdIOztBQUVELFdBQ0k7QUFBQyxXQUFEO0FBQUEsbUJBQVcsS0FBS3JxQixLQUFoQjtBQUNJLGlCQUFTLEtBQUs4eEMsVUFBTCxFQURiO0FBRUkseUJBQWlCLEtBQUt2YyxlQUYxQjtBQUdJLG9DQUhKO0FBRzRCbHJCO0FBSDVCLEtBREo7QUFNSCxHOzs7RUEzSGtCNUksZ0IsVUFDWkMsUyxHQUFZO0FBQ2Z6QixVQUFRMEIsb0JBQVVDLE1BREg7QUFFZnpCLFFBQU13QixvQkFBVUUsSUFGRDtBQUdmK0QsYUFBV2pFLG9CQUFVQyxNQUhOO0FBSWY7OztBQUdBSixZQUFVRyxvQkFBVThPLElBUEw7QUFRZjs7O0FBR0E4TixXQUFTNWMsb0JBQVVFLElBWEo7QUFZZjs7O0FBR0FxdUMsa0JBQWdCdnVDLG9CQUFVRSxJQWZYO0FBZ0JmOzs7Ozs7QUFNQTB6QixtQkFBaUI1ekIsb0JBQVVoRSxJQXRCWjtBQXVCZjs7O0FBR0F5NEIsV0FBU3owQixvQkFBVThPLElBMUJKO0FBMkJmOzs7QUFHQTJZLGVBQWF6bkIsb0JBQVVvRSxLQUFWLENBQWdCLENBQUMsT0FBRCxFQUFVLE9BQVYsRUFBbUIsT0FBbkIsQ0FBaEIsQ0E5QkU7QUErQmY7OztBQUdBNkMsWUFBVWpILG9CQUFVRSxJQWxDTDtBQW1DZjs7O0FBR0ErTSxTQUFPak4sb0JBQVVDLE1BdENGO0FBdUNmOzs7QUFHQXNoQixVQUFRdmhCLG9CQUFVa00sS0ExQ0g7QUEyQ2Y7OztBQUdBOGlDLFNBQU9odkMsb0JBQVV1SixNQTlDRjtBQStDZjs7O0FBR0E0VyxhQUFXbmdCLG9CQUFVRSxJQWxETjtBQW1EZjs7O0FBR0F1aEIsV0FBU3poQixvQkFBVUUsSUF0REo7QUF1RGY7OztBQUdBNmhCLFNBQU8vaEIsb0JBQVVFLElBMURGO0FBMkRmOzs7O0FBSUE0YyxhQUFXOWMsb0JBQVU2TyxTQUFWLENBQW9CLENBQUM3TyxvQkFBVWpGLE1BQVgsRUFBbUJpRixvQkFBVUUsSUFBN0IsQ0FBcEI7QUEvREksQyxTQWlFWkUsWSxHQUFlO0FBQ2xCOUIsVUFBUSxPQURVO0FBRWxCRSxRQUFNLEtBRlk7QUFHbEIrdkMsa0JBQWdCLEtBSEU7QUFJbEIzYSxtQkFBaUI5cEIsSUFKQztBQUtsQjJkLGVBQWEsT0FMSztBQU1sQnhnQixZQUFVLEtBTlE7QUFPbEJnRyxTQUFPLE9BUFc7QUFRbEJzVSxVQUFRLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FSVTtBQVNsQnl0QixTQUFPLEdBVFc7QUFVbEI3dUIsYUFBVyxJQVZPO0FBV2xCc0IsV0FBUyxLQVhTO0FBWWxCTSxTQUFPLEtBWlc7QUFhbEJKLGNBQVk3WDtBQWJNLEM7QUFsRXBCb21DLFE7a0JBOEhTbHlDLHlCQUFlc0MsTUFBZixDQUFzQjR2QyxRQUF0QixDOzs7Ozs7Ozs7Ozs7Ozs7OztBQzNJZjs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0lBRVFqVyxNLEdBQVd4UCxpQixDQUFYd1AsTTtJQUNBNXpCLE8sR0FBWXJLLFUsQ0FBWnFLLE87O0FBRVI7Ozs7O0lBSXFCMjBCLE87OztBQXNDakIscUJBQVkzOEIsS0FBWixFQUFtQjtBQUFBOztBQUFBLHFEQUNmLHNCQUFNQSxLQUFOLENBRGU7O0FBR2ZnSSx1QkFBYyxDQUNWLGtCQURVLEVBQ1Usa0JBRFYsRUFDOEIsYUFEOUIsRUFFVixZQUZVLEVBRUksWUFGSixDQUFkO0FBSGU7QUFPbEI7O3NCQUVERSxpQixnQ0FBb0I7QUFDaEIsYUFBS0MsUUFBTCxHQUFnQiwyQkFBWSxJQUFaLENBQWhCO0FBQ0gsSzs7c0JBRURrbEIsVSx5QkFBYTtBQUFBLHFCQUNpQixLQUFLcnRCLEtBRHRCO0FBQUEsWUFDRGlKLE9BREMsVUFDREEsT0FEQztBQUFBLFlBQ1E1RyxJQURSLFVBQ1FBLElBRFI7QUFBQSxZQUVEc0csU0FGQyxHQUVhdEcsS0FBS3JDLEtBRmxCLENBRUQySSxTQUZDOztBQUdULFlBQUlBLGFBQWFNLE9BQWpCLEVBQTBCO0FBQ3RCLGlCQUFLZCxRQUFMLENBQWNuSyxLQUFkO0FBQ0g7QUFDSixLOztzQkFFRHEzQixPLHNCQUFVO0FBQUEsc0JBQ2lCLEtBQUtyMUIsS0FEdEI7QUFBQSxZQUNFOEksSUFERixXQUNFQSxJQURGO0FBQUEsWUFDUXpHLElBRFIsV0FDUUEsSUFEUjtBQUFBLFlBRUVvbEIsUUFGRixHQUVlcGxCLEtBQUsyRyxLQUZwQixDQUVFeWUsUUFGRjs7O0FBSU4sZUFBT0EsU0FBU3ppQixPQUFULENBQWlCOEQsSUFBakIsSUFBeUIsQ0FBQyxDQUFqQztBQUNILEs7O3NCQUVEa3BDLGdCLDZCQUFpQjd3QyxDLEVBQUc7QUFDaEIsYUFBS2dvQixVQUFMLENBQWdCLElBQWhCOztBQUVBLGFBQUtucEIsS0FBTCxDQUFXK04sWUFBWCxJQUEyQixLQUFLL04sS0FBTCxDQUFXK04sWUFBWCxDQUF3QjVNLENBQXhCLENBQTNCO0FBQ0gsSzs7c0JBRUQ4d0MsZ0IsNkJBQWlCOXdDLEMsRUFBRztBQUNoQixhQUFLZ29CLFVBQUwsQ0FBZ0IsS0FBaEI7O0FBRUEsYUFBS25wQixLQUFMLENBQVdpTyxZQUFYLElBQTJCLEtBQUtqTyxLQUFMLENBQVdpTyxZQUFYLENBQXdCOU0sQ0FBeEIsQ0FBM0I7QUFDSCxLOztzQkFFRHVJLFcsd0JBQVl2SSxDLEVBQUc7QUFBQSxzQkFDa0IsS0FBS25CLEtBRHZCO0FBQUEsWUFDSHFDLElBREcsV0FDSEEsSUFERztBQUFBLFlBQ0cyekIsVUFESCxXQUNHQSxVQURIO0FBQUEsWUFFSDFrQixVQUZHLEdBRVlqUCxLQUFLckMsS0FGakIsQ0FFSHNSLFVBRkc7O0FBR1gsWUFBSUEsY0FBYzBrQixVQUFsQixFQUE4QjtBQUMxQjcwQixjQUFFd0ksZUFBRjtBQUNIOztBQUVELFlBQU04VixPQUFPLEtBQUs0VixPQUFMLEVBQWI7QUFDQSxhQUFLbE0sVUFBTCxDQUFnQixDQUFDMUosSUFBakI7QUFDSCxLOztzQkFFRDBKLFUsdUJBQVcxSixJLEVBQU0ySixXLEVBQWFqb0IsQyxFQUFHO0FBQUEsc0JBQ04sS0FBS25CLEtBREM7QUFBQSxZQUNyQjhJLElBRHFCLFdBQ3JCQSxJQURxQjtBQUFBLFlBQ2Z6RyxJQURlLFdBQ2ZBLElBRGU7O0FBRTdCQSxhQUFLOG1CLFVBQUwsQ0FBZ0JyZ0IsSUFBaEIsRUFBc0IyVyxJQUF0QixFQUE0QjJKLFdBQTVCLEVBQXlDam9CLENBQXpDO0FBQ0gsSzs7c0JBRUQrd0Msb0IsaUNBQXFCMXdDLFEsRUFBVTtBQUFBOztBQUFBLHNCQUNKLEtBQUt4QixLQUREO0FBQUEsWUFDbkJtb0IsSUFEbUIsV0FDbkJBLElBRG1CO0FBQUEsWUFDYjlsQixJQURhLFdBQ2JBLElBRGE7OztBQUczQixlQUFPZixnQkFBUzRCLEdBQVQsQ0FBYTFCLFFBQWIsRUFBdUIsaUJBQVM7QUFDbkMsbUJBQU8seUJBQWE2SSxLQUFiLEVBQW9CO0FBQ3ZCYyx3QkFBUSxNQURlO0FBRXZCL0MsNEJBQVkrZixRQUFROWxCLEtBQUtyQyxLQUFMLENBQVdtb0I7QUFGUixhQUFwQixDQUFQO0FBSUgsU0FMTSxDQUFQO0FBTUgsSzs7c0JBRURncUIsWSwyQkFBZTtBQUFBOztBQUFBLHNCQUNvSixLQUFLbnlDLEtBRHpKO0FBQUEsWUFDSDhJLElBREcsV0FDSEEsSUFERztBQUFBLFlBQ0d3QixLQURILFdBQ0dBLEtBREg7QUFBQSxZQUNVakksSUFEVixXQUNVQSxJQURWO0FBQUEsWUFDZ0J1RCxTQURoQixXQUNnQkEsU0FEaEI7QUFBQSxZQUN1QzJ3QixtQkFEdkMsV0FDMkJQLFVBRDNCO0FBQUEsWUFDNEQxakIsS0FENUQsV0FDNERBLEtBRDVEO0FBQUEsWUFDbUU5USxRQURuRSxXQUNtRUEsUUFEbkU7QUFBQSxZQUM2RTR3Qyx1QkFEN0UsV0FDNkVBLHVCQUQ3RTtBQUFBLFlBQ21IQyxnQkFEbkgsV0FDc0dqcEIsV0FEdEc7QUFBQSxZQUNxSWhoQixVQURySSxXQUNxSUEsVUFEckk7QUFBQSwwQkFFOEYvRixLQUFLckMsS0FGbkc7QUFBQSxZQUVIQyxNQUZHLGVBRUhBLE1BRkc7QUFBQSxZQUVLcVIsVUFGTCxlQUVLQSxVQUZMO0FBQUEsWUFFOEJrbEIsZUFGOUIsZUFFaUJwTixXQUZqQjtBQUFBLFlBRStDcUMsb0JBRi9DLGVBRStDQSxvQkFGL0M7QUFBQSxZQUVxRU8sZUFGckUsZUFFcUVBLGVBRnJFO0FBQUEsWUFFc0YzckIsR0FGdEYsZUFFc0ZBLEdBRnRGOztBQUdYLFlBQU0rb0IsY0FBY2lwQixvQkFBb0I3YixlQUF4QztBQUNBLFlBQU0vVyxPQUFPLEtBQUs0VixPQUFMLEVBQWI7QUFDQSxZQUFNdHRCLFNBQVNsSyxVQUFJMEksVUFBSixDQUFlMUIsT0FBT0MsSUFBUCxDQUFZNjNCLFFBQVFqN0IsU0FBcEIsQ0FBZixFQUErQyxLQUFLMUIsS0FBcEQsQ0FBZjs7QUFFQSxZQUFNc3lDLFVBQVU7QUFDWjFzQyx1QkFBVyx5Q0FDSDNGLE1BREcsOEJBQzZCLElBRDdCLE1BRU4yRixTQUZNLElBRU0sQ0FBQyxDQUFDQSxTQUZSO0FBREMsU0FBaEI7QUFNQSxZQUFNc3dCLFlBQVk7QUFDZCw2QkFBaUJ6VyxJQURIO0FBRWQzVyxzQkFGYztBQUdkd0Isd0JBSGM7QUFJZGpJLHNCQUpjO0FBS2RxRCxrQkFBTSxTQUxRO0FBTWQrRSx1QkFBVyxLQU5HO0FBT2RyQztBQVBjLFNBQWxCO0FBU0EsWUFBTW1xQyxhQUFhO0FBQ2Y3c0Msa0JBQU0rbEIseUJBQXlCLE9BQXpCLEdBQW1DLGFBQW5DLEdBQW1ELFlBRDFDO0FBRWY3bEIsdUJBQVcsMkNBQ0gzRixNQURHLHdCQUN1QixJQUR2QixPQUVIQSxNQUZHLDZCQUU0QndyQix5QkFBeUIsTUFGckQsT0FHSHhyQixNQUhHLDhCQUc2QndyQix5QkFBeUIsT0FIdEQsT0FJSHhyQixNQUpHLGFBSVl3ZixJQUpaO0FBRkksU0FBbkI7O0FBVUEsWUFBTXVXLGFBQWEsQ0FBQyxDQUFDMWtCLFVBQUYsSUFBZ0JpbEIsbUJBQW5DO0FBQ0EsWUFBTU4sVUFBVUQsYUFBYXdjLHdCQUFiLEdBQThCdnFDLGNBQTlDOztBQUVBLFlBQUltaEIsZ0JBQWdCLE9BQXBCLEVBQTZCO0FBQ3pCa3BCLG9CQUFRdmtDLFlBQVIsR0FBdUIsS0FBS2lrQyxnQkFBNUI7QUFDQU0sb0JBQVFya0MsWUFBUixHQUF1QixLQUFLZ2tDLGdCQUE1QjtBQUNILFNBSEQsTUFHTyxJQUFJamMsVUFBSixFQUFnQjtBQUNuQnVjLHVCQUFXMW9DLE9BQVgsR0FBcUIsS0FBS0gsV0FBMUI7QUFDSCxTQUZNLE1BRUE7QUFDSHdzQixzQkFBVXJzQixPQUFWLEdBQW9CLEtBQUtILFdBQXpCO0FBQ0g7QUFDRCxZQUFJK1YsSUFBSixFQUFVO0FBQ055VyxzQkFBVXR3QixTQUFWLEdBQXlCM0YsTUFBekI7QUFDSDs7QUFFRCxZQUFNd3lDLDZCQUE2QiwyQ0FDM0J4eUMsTUFEMkIsc0JBQ0gsSUFERyxPQUU5Qm15Qyx1QkFGOEIsSUFFSixDQUFDLENBQUNBLHVCQUZFLFFBQW5DOztBQUtBLFlBQU1NLFVBQVVqekIsT0FDWjtBQUFBO0FBQUEsY0FBSSxNQUFLLE1BQVQsRUFBZ0IsS0FBS3BmLE1BQU0sS0FBTixHQUFjMmEsU0FBbkMsRUFBOEMsS0FBSSxTQUFsRCxFQUE0RCxXQUFXeTNCLDBCQUF2RTtBQUNLLGlCQUFLUCxvQkFBTCxDQUEwQjF3QyxRQUExQjtBQURMLFNBRFksR0FJWixJQUpKOztBQU1BLGVBQ0k7QUFBQTtBQUFBLHlCQUFRdUcsTUFBUixFQUFvQnVxQyxPQUFwQjtBQUNJO0FBQUMsdUJBQUQ7QUFBYXBjLHlCQUFiO0FBQ0k7QUFBQTtBQUFBLHNCQUFNLFdBQWNqMkIsTUFBZCxtQkFBTjtBQUE2Q3FTO0FBQTdDLGlCQURKO0FBRUksOENBQUMsY0FBRCxFQUFVaWdDLFVBQVY7QUFGSixhQURKO0FBS0t2bUIsOEJBQ0c7QUFBQyxzQkFBRDtBQUFBLGtCQUFRLGlCQUFpQixLQUF6QixFQUFnQyxZQUFZLEtBQUtxQixVQUFqRDtBQUNLcWxCO0FBREwsYUFESCxHQUlHQTtBQVRSLFNBREo7QUFjSCxLOztzQkFFRHZjLFcsMEJBQWM7QUFBQTs7QUFBQSxzQkFDK0MsS0FBS24yQixLQURwRDtBQUFBLFlBQ0Z3QixRQURFLFdBQ0ZBLFFBREU7QUFBQSxZQUNRNHdDLHVCQURSLFdBQ1FBLHVCQURSO0FBQUEsWUFDb0NycUMsTUFEcEM7O0FBRVYsWUFBTTFGLE9BQU8sS0FBS3JDLEtBQUwsQ0FBV3FDLElBQXhCO0FBRlUsMkJBRzBDQSxLQUFLckMsS0FIL0M7QUFBQSxZQUdGQyxNQUhFLGdCQUdGQSxNQUhFO0FBQUEsWUFHTTRyQixjQUhOLGdCQUdNQSxjQUhOO0FBQUEsWUFHc0JDLFVBSHRCLGdCQUdzQkEsVUFIdEI7QUFBQSxZQUdrQ3pyQixHQUhsQyxnQkFHa0NBLEdBSGxDOzs7QUFLVixZQUFNd0ssZUFBZSwyQ0FDYjVLLE1BRGEsYUFDRSxJQURGLE9BRWJBLE1BRmEsWUFFQyxJQUZELE9BR2hCNHJCLGNBSGdCLElBR0MsQ0FBQyxDQUFDQSxjQUhILE9BSWhCdW1CLHVCQUpnQixJQUlVLENBQUMsQ0FBQ0EsdUJBSlosUUFBckI7O0FBT0FycUMsZUFBTzFILEdBQVAsR0FBYUEsR0FBYjs7QUFFQSxlQUNJO0FBQUMsK0JBQUQ7QUFBQSx5QkFBZTBILE1BQWYsSUFBdUIsZ0JBQXZCO0FBQ0k7QUFBQTtBQUFBLGtCQUFJLE1BQUssTUFBVCxFQUFnQixLQUFLMUgsTUFBTSxLQUFOLEdBQWMyYSxTQUFuQyxFQUE4QyxXQUFXblEsWUFBekQsRUFBdUUsT0FBT2loQixVQUE5RTtBQUNLLHFCQUFLb21CLG9CQUFMLENBQTBCMXdDLFFBQTFCO0FBREw7QUFESixTQURKO0FBT0gsSzs7c0JBRURILE0scUJBQVM7QUFBQSxzQkFDa0IsS0FBS3JCLEtBRHZCO0FBQUEsWUFDR21vQixJQURILFdBQ0dBLElBREg7QUFBQSxZQUNTOWxCLElBRFQsV0FDU0EsSUFEVDs7QUFFTCxZQUFNc3dDLFVBQVV4cUIsUUFBUTlsQixLQUFLckMsS0FBTCxDQUFXbW9CLElBQW5DOztBQUVBLGVBQU93cUIsWUFBWSxPQUFaLEdBQ0gsS0FBS3hjLFdBQUwsRUFERyxHQUVILEtBQUtnYyxZQUFMLEVBRko7QUFHSCxLOzs7RUFqTmdDMXdDLGdCLFVBQzFCeVEsYSxHQUFnQixTLFNBRWhCeFEsUyxHQUFZO0FBQ2ZvSCxVQUFNbkgsb0JBQVVDLE1BREQ7QUFFZlMsVUFBTVYsb0JBQVVqRixNQUZEO0FBR2Y0TixXQUFPM0ksb0JBQVV1SixNQUhGO0FBSWZWLGlCQUFhN0ksb0JBQVV1SixNQUpSO0FBS2Y7OztBQUdBb0gsV0FBTzNRLG9CQUFVOE8sSUFSRjtBQVNmOzs7QUFHQXVsQixnQkFBWXIwQixvQkFBVUUsSUFaUDtBQWFmOzs7O0FBSUFzbUIsVUFBTXhtQixvQkFBVW9FLEtBQVYsQ0FBZ0IsQ0FBQyxRQUFELEVBQVcsT0FBWCxDQUFoQixDQWpCUztBQWtCZjs7O0FBR0F2RSxjQUFVRyxvQkFBVThPLElBckJMO0FBc0JmMUMsa0JBQWNwTSxvQkFBVWhFLElBdEJUO0FBdUJmc1Esa0JBQWN0TSxvQkFBVWhFLElBdkJUO0FBd0JmeTBDLDZCQUF5Qnp3QyxvQkFBVUMsTUF4QnBCO0FBeUJmd25CLGlCQUFhem5CLG9CQUFVb0UsS0FBVixDQUFnQixDQUFDLE9BQUQsRUFBVSxPQUFWLENBQWhCLENBekJFO0FBMEJmNkksV0FBT2pOLG9CQUFVb0UsS0FBVixDQUFnQixDQUFDLFNBQUQsRUFBWSxRQUFaLENBQWhCLENBMUJRO0FBMkJmcUMsZ0JBQVl6RyxvQkFBVW9FLEtBQVYsQ0FBZ0IsQ0FBQyxRQUFELEVBQVcsT0FBWCxDQUFoQjtBQTNCRyxDLFNBOEJaaEUsWSxHQUFlO0FBQ2xCeUksaUJBQWEsQ0FESztBQUVsQndyQixnQkFBWTtBQUZNLEM7QUFqQ0wyRyxPO2tCQUFBQSxPOzs7Ozs7OztBQ2xCckIsK0NBQWE7Ozs7QUFFYjcvQixRQUFROHdCLFVBQVIsR0FBcUIsSUFBckI7QUFDQTl3QixRQUFRd0MsT0FBUixHQUFrQixLQUFLLENBQXZCOztBQUVBLElBQUlxQyxZQUFZMnNCLHdCQUF3QnZ4QixtQkFBT0EsQ0FBQyxDQUFSLENBQXhCLENBQWhCOztBQUVBLElBQUk2MUMsWUFBWXBsQix1QkFBdUJ6d0IsbUJBQU9BLENBQUMsR0FBUixDQUF2QixDQUFoQjs7QUFFQSxJQUFJODFDLGVBQWVybEIsdUJBQXVCendCLG1CQUFPQSxDQUFDLEdBQVIsQ0FBdkIsQ0FBbkI7O0FBRUEsSUFBSXd4QixTQUFTZix1QkFBdUJ6d0IsbUJBQU9BLENBQUMsQ0FBUixDQUF2QixDQUFiOztBQUVBLElBQUk0d0IsY0FBY0gsdUJBQXVCendCLG1CQUFPQSxDQUFDLEVBQVIsQ0FBdkIsQ0FBbEI7O0FBRUEsSUFBSTJ4QixhQUFhM3hCLG1CQUFPQSxDQUFDLEVBQVIsQ0FBakI7O0FBRUEsU0FBU3l3QixzQkFBVCxDQUFnQzN2QixHQUFoQyxFQUFxQztBQUFFLFNBQU9BLE9BQU9BLElBQUkrdkIsVUFBWCxHQUF3Qi92QixHQUF4QixHQUE4QixFQUFFeUIsU0FBU3pCLEdBQVgsRUFBckM7QUFBd0Q7O0FBRS9GLFNBQVN5d0IsdUJBQVQsQ0FBaUN6d0IsR0FBakMsRUFBc0M7QUFBRSxNQUFJQSxPQUFPQSxJQUFJK3ZCLFVBQWYsRUFBMkI7QUFBRSxXQUFPL3ZCLEdBQVA7QUFBYSxHQUExQyxNQUFnRDtBQUFFLFFBQUk4d0IsU0FBUyxFQUFiLENBQWlCLElBQUk5d0IsT0FBTyxJQUFYLEVBQWlCO0FBQUUsV0FBSyxJQUFJc0IsR0FBVCxJQUFnQnRCLEdBQWhCLEVBQXFCO0FBQUUsWUFBSWdILE9BQU80QixTQUFQLENBQWlCbkksY0FBakIsQ0FBZ0NjLElBQWhDLENBQXFDdkIsR0FBckMsRUFBMENzQixHQUExQyxDQUFKLEVBQW9EO0FBQUUsY0FBSW9XLE9BQU8xUSxPQUFPK3BCLGNBQVAsSUFBeUIvcEIsT0FBT2dxQix3QkFBaEMsR0FBMkRocUIsT0FBT2dxQix3QkFBUCxDQUFnQ2h4QixHQUFoQyxFQUFxQ3NCLEdBQXJDLENBQTNELEdBQXVHLEVBQWxILENBQXNILElBQUlvVyxLQUFLelYsR0FBTCxJQUFZeVYsS0FBS3VaLEdBQXJCLEVBQTBCO0FBQUVqcUIsbUJBQU8rcEIsY0FBUCxDQUFzQkQsTUFBdEIsRUFBOEJ4dkIsR0FBOUIsRUFBbUNvVyxJQUFuQztBQUEyQyxXQUF2RSxNQUE2RTtBQUFFb1osbUJBQU94dkIsR0FBUCxJQUFjdEIsSUFBSXNCLEdBQUosQ0FBZDtBQUF5QjtBQUFFO0FBQUU7QUFBRSxLQUFDd3ZCLE9BQU9ydkIsT0FBUCxHQUFpQnpCLEdBQWpCLENBQXNCLE9BQU84d0IsTUFBUDtBQUFnQjtBQUFFOztBQUV4ZCxTQUFTTyxjQUFULENBQXdCQyxRQUF4QixFQUFrQ0MsVUFBbEMsRUFBOEM7QUFBRUQsV0FBUzFvQixTQUFULEdBQXFCNUIsT0FBT3dxQixNQUFQLENBQWNELFdBQVczb0IsU0FBekIsQ0FBckIsQ0FBMEQwb0IsU0FBUzFvQixTQUFULENBQW1CSSxXQUFuQixHQUFpQ3NvQixRQUFqQztBQUE1RCxZQUF1R0EsUUFBdkcsRUFBNEhDLFVBQTVIO0FBQXlJOztBQUV2TCxTQUFTOEUsUUFBVCxHQUFvQjtBQUFFQSxhQUFXcnZCLE9BQU9zdkIsTUFBUCxJQUFpQixVQUFVcmpCLE1BQVYsRUFBa0I7QUFBRSxTQUFLLElBQUlyUyxJQUFJLENBQWIsRUFBZ0JBLElBQUlDLFVBQVVDLE1BQTlCLEVBQXNDRixHQUF0QyxFQUEyQztBQUFFLFVBQUl1RixTQUFTdEYsVUFBVUQsQ0FBVixDQUFiLENBQTJCLEtBQUssSUFBSVUsR0FBVCxJQUFnQjZFLE1BQWhCLEVBQXdCO0FBQUUsWUFBSWEsT0FBTzRCLFNBQVAsQ0FBaUJuSSxjQUFqQixDQUFnQ2MsSUFBaEMsQ0FBcUM0RSxNQUFyQyxFQUE2QzdFLEdBQTdDLENBQUosRUFBdUQ7QUFBRTJSLGlCQUFPM1IsR0FBUCxJQUFjNkUsT0FBTzdFLEdBQVAsQ0FBZDtBQUE0QjtBQUFFO0FBQUUsS0FBQyxPQUFPMlIsTUFBUDtBQUFnQixHQUE1UCxDQUE4UCxPQUFPb2pCLFNBQVNoMUIsS0FBVCxDQUFlLElBQWYsRUFBcUJSLFNBQXJCLENBQVA7QUFBeUM7O0FBRTdULElBQUk0UCxXQUFXLFNBQVNBLFFBQVQsQ0FBa0JtQyxJQUFsQixFQUF3QmpTLE9BQXhCLEVBQWlDO0FBQzlDLFNBQU9pUyxRQUFRalMsT0FBUixJQUFtQkEsUUFBUTZHLEtBQVIsQ0FBYyxHQUFkLEVBQW1CTixPQUFuQixDQUEyQixVQUFVNnFDLENBQVYsRUFBYTtBQUNoRSxXQUFPLENBQUMsR0FBR2dELFVBQVV0ekMsT0FBZCxFQUF1Qm1SLElBQXZCLEVBQTZCbS9CLENBQTdCLENBQVA7QUFDRCxHQUZ5QixDQUExQjtBQUdELENBSkQ7O0FBTUEsSUFBSXJoQyxjQUFjLFNBQVNBLFdBQVQsQ0FBcUJrQyxJQUFyQixFQUEyQmpTLE9BQTNCLEVBQW9DO0FBQ3BELFNBQU9pUyxRQUFRalMsT0FBUixJQUFtQkEsUUFBUTZHLEtBQVIsQ0FBYyxHQUFkLEVBQW1CTixPQUFuQixDQUEyQixVQUFVNnFDLENBQVYsRUFBYTtBQUNoRSxXQUFPLENBQUMsR0FBR2lELGFBQWF2ekMsT0FBakIsRUFBMEJtUixJQUExQixFQUFnQ20vQixDQUFoQyxDQUFQO0FBQ0QsR0FGeUIsQ0FBMUI7QUFHRCxDQUpEOztBQU1BLElBQUlsdUMsWUFBWXZGLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixHQUF3QzYzQixTQUFTLEVBQVQsRUFBYXZHLFlBQVlydUIsT0FBWixDQUFvQm9DLFNBQWpDLEVBQTRDO0FBQ2xHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2Q0FuRCxjQUFZbXdCLFdBQVcrRSxlQTlDMkU7O0FBZ0RsRzs7Ozs7O0FBTUF4RyxXQUFTdHJCLFVBQVVoRSxJQXREK0U7O0FBd0RsRzs7Ozs7O0FBTUE4akIsY0FBWTlmLFVBQVVoRSxJQTlENEU7O0FBZ0VsRzs7Ozs7O0FBTUE2akIsYUFBVzdmLFVBQVVoRSxJQXRFNkU7O0FBd0VsRzs7Ozs7O0FBTUEyekIsVUFBUTN2QixVQUFVaEUsSUE5RWdGOztBQWdGbEc7Ozs7O0FBS0E0ekIsYUFBVzV2QixVQUFVaEUsSUFyRjZFOztBQXVGbEc7Ozs7OztBQU1BMHpCLFlBQVUxdkIsVUFBVWhFO0FBN0Y4RSxDQUE1QyxDQUF4QyxHQThGWCxFQTlGTCxDQThGUTtBQUNSOzs7Ozs7Ozs7Ozs7OztBQWNBLElBQUlxd0I7QUFDSjtBQUNBLFVBQVVzQixnQkFBVixFQUE0QjtBQUMxQkosaUJBQWVsQixhQUFmLEVBQThCc0IsZ0JBQTlCOztBQUVBLFdBQVN0QixhQUFULEdBQXlCO0FBQ3ZCLFFBQUl1QixLQUFKOztBQUVBLFNBQUssSUFBSTZDLE9BQU8xekIsVUFBVUMsTUFBckIsRUFBNkJpQixPQUFPLElBQUliLEtBQUosQ0FBVXF6QixJQUFWLENBQXBDLEVBQXFEdHBCLE9BQU8sQ0FBakUsRUFBb0VBLE9BQU9zcEIsSUFBM0UsRUFBaUZ0cEIsTUFBakYsRUFBeUY7QUFDdkZsSixXQUFLa0osSUFBTCxJQUFhcEssVUFBVW9LLElBQVYsQ0FBYjtBQUNEOztBQUVEeW1CLFlBQVFELGlCQUFpQmx3QixJQUFqQixDQUFzQkYsS0FBdEIsQ0FBNEJvd0IsZ0JBQTVCLEVBQThDLENBQUMsSUFBRCxFQUFPcHJCLE1BQVAsQ0FBY3RFLElBQWQsQ0FBOUMsS0FBc0UsSUFBOUU7O0FBRUEydkIsVUFBTXRDLE9BQU4sR0FBZ0IsVUFBVXhjLElBQVYsRUFBZ0J1Z0IsU0FBaEIsRUFBMkI7QUFDekMsVUFBSThoQixzQkFBc0J2akIsTUFBTXdqQixhQUFOLENBQW9CL2hCLFlBQVksUUFBWixHQUF1QixPQUEzQyxDQUExQjtBQUFBLFVBQ0lwckIsWUFBWWt0QyxvQkFBb0JsdEMsU0FEcEM7O0FBR0EycEIsWUFBTXlqQixhQUFOLENBQW9CdmlDLElBQXBCLEVBQTBCLE1BQTFCOztBQUVBbkMsZUFBU21DLElBQVQsRUFBZTdLLFNBQWY7O0FBRUEsVUFBSTJwQixNQUFNdnZCLEtBQU4sQ0FBWWl0QixPQUFoQixFQUF5QjtBQUN2QnNDLGNBQU12dkIsS0FBTixDQUFZaXRCLE9BQVosQ0FBb0J4YyxJQUFwQixFQUEwQnVnQixTQUExQjtBQUNEO0FBQ0YsS0FYRDs7QUFhQXpCLFVBQU05TixVQUFOLEdBQW1CLFVBQVVoUixJQUFWLEVBQWdCdWdCLFNBQWhCLEVBQTJCO0FBQzVDLFVBQUlpaUIsdUJBQXVCMWpCLE1BQU13akIsYUFBTixDQUFvQi9oQixZQUFZLFFBQVosR0FBdUIsT0FBM0MsQ0FBM0I7QUFBQSxVQUNJa2lCLGtCQUFrQkQscUJBQXFCQyxlQUQzQzs7QUFHQTNqQixZQUFNNGpCLGlCQUFOLENBQXdCMWlDLElBQXhCLEVBQThCeWlDLGVBQTlCOztBQUVBLFVBQUkzakIsTUFBTXZ2QixLQUFOLENBQVl5aEIsVUFBaEIsRUFBNEI7QUFDMUI4TixjQUFNdnZCLEtBQU4sQ0FBWXloQixVQUFaLENBQXVCaFIsSUFBdkIsRUFBNkJ1Z0IsU0FBN0I7QUFDRDtBQUNGLEtBVEQ7O0FBV0F6QixVQUFNL04sU0FBTixHQUFrQixVQUFVL1EsSUFBVixFQUFnQnVnQixTQUFoQixFQUEyQjtBQUMzQyxVQUFJb2lCLHVCQUF1QjdqQixNQUFNd2pCLGFBQU4sQ0FBb0IsT0FBcEIsQ0FBM0I7QUFBQSxVQUNJTSxnQkFBZ0JELHFCQUFxQkMsYUFEekM7O0FBR0E5akIsWUFBTXlqQixhQUFOLENBQW9CdmlDLElBQXBCLEVBQTBCdWdCLFlBQVksUUFBWixHQUF1QixPQUFqRDs7QUFFQTFpQixlQUFTbUMsSUFBVCxFQUFlNGlDLGFBQWY7O0FBRUEsVUFBSTlqQixNQUFNdnZCLEtBQU4sQ0FBWXdoQixTQUFoQixFQUEyQjtBQUN6QitOLGNBQU12dkIsS0FBTixDQUFZd2hCLFNBQVosQ0FBc0IvUSxJQUF0QixFQUE0QnVnQixTQUE1QjtBQUNEO0FBQ0YsS0FYRDs7QUFhQXpCLFVBQU0rQixNQUFOLEdBQWUsVUFBVTdnQixJQUFWLEVBQWdCO0FBQzdCLFVBQUk2aUMsdUJBQXVCL2pCLE1BQU13akIsYUFBTixDQUFvQixNQUFwQixDQUEzQjtBQUFBLFVBQ0ludEMsWUFBWTB0QyxxQkFBcUIxdEMsU0FEckM7O0FBR0EycEIsWUFBTXlqQixhQUFOLENBQW9CdmlDLElBQXBCLEVBQTBCLFFBQTFCOztBQUVBOGUsWUFBTXlqQixhQUFOLENBQW9CdmlDLElBQXBCLEVBQTBCLE9BQTFCOztBQUVBbkMsZUFBU21DLElBQVQsRUFBZTdLLFNBQWY7O0FBRUEsVUFBSTJwQixNQUFNdnZCLEtBQU4sQ0FBWXN4QixNQUFoQixFQUF3QjtBQUN0Qi9CLGNBQU12dkIsS0FBTixDQUFZc3hCLE1BQVosQ0FBbUI3Z0IsSUFBbkI7QUFDRDtBQUNGLEtBYkQ7O0FBZUE4ZSxVQUFNZ0MsU0FBTixHQUFrQixVQUFVOWdCLElBQVYsRUFBZ0I7QUFDaEMsVUFBSThpQyx1QkFBdUJoa0IsTUFBTXdqQixhQUFOLENBQW9CLE1BQXBCLENBQTNCO0FBQUEsVUFDSUcsa0JBQWtCSyxxQkFBcUJMLGVBRDNDOztBQUdBM2pCLFlBQU00akIsaUJBQU4sQ0FBd0IxaUMsSUFBeEIsRUFBOEJ5aUMsZUFBOUI7O0FBRUEsVUFBSTNqQixNQUFNdnZCLEtBQU4sQ0FBWXV4QixTQUFoQixFQUEyQjtBQUN6QmhDLGNBQU12dkIsS0FBTixDQUFZdXhCLFNBQVosQ0FBc0I5Z0IsSUFBdEI7QUFDRDtBQUNGLEtBVEQ7O0FBV0E4ZSxVQUFNOEIsUUFBTixHQUFpQixVQUFVNWdCLElBQVYsRUFBZ0I7QUFDL0IsVUFBSStpQyx1QkFBdUJqa0IsTUFBTXdqQixhQUFOLENBQW9CLE1BQXBCLENBQTNCO0FBQUEsVUFDSU0sZ0JBQWdCRyxxQkFBcUJILGFBRHpDOztBQUdBOWpCLFlBQU15akIsYUFBTixDQUFvQnZpQyxJQUFwQixFQUEwQixNQUExQjs7QUFFQW5DLGVBQVNtQyxJQUFULEVBQWU0aUMsYUFBZjs7QUFFQSxVQUFJOWpCLE1BQU12dkIsS0FBTixDQUFZcXhCLFFBQWhCLEVBQTBCO0FBQ3hCOUIsY0FBTXZ2QixLQUFOLENBQVlxeEIsUUFBWixDQUFxQjVnQixJQUFyQjtBQUNEO0FBQ0YsS0FYRDs7QUFhQThlLFVBQU13akIsYUFBTixHQUFzQixVQUFVcnRDLElBQVYsRUFBZ0I7QUFDcEMsVUFBSW5ILGFBQWFneEIsTUFBTXZ2QixLQUFOLENBQVl6QixVQUE3QjtBQUNBLFVBQUlxSCxZQUFZLE9BQU9ySCxVQUFQLEtBQXNCLFFBQXRCLEdBQWlDQSxXQUFXbUgsSUFBWCxDQUFqQyxHQUFvRG5ILGFBQWEsR0FBYixHQUFtQm1ILElBQXZGO0FBQ0EsVUFBSXd0QyxrQkFBa0IsT0FBTzMwQyxVQUFQLEtBQXNCLFFBQXRCLEdBQWlDQSxXQUFXbUgsT0FBTyxRQUFsQixDQUFqQyxHQUErREUsWUFBWSxTQUFqRztBQUNBLFVBQUl5dEMsZ0JBQWdCLE9BQU85MEMsVUFBUCxLQUFzQixRQUF0QixHQUFpQ0EsV0FBV21ILE9BQU8sTUFBbEIsQ0FBakMsR0FBNkRFLFlBQVksT0FBN0Y7QUFDQSxhQUFPO0FBQ0xBLG1CQUFXQSxTQUROO0FBRUxzdEMseUJBQWlCQSxlQUZaO0FBR0xHLHVCQUFlQTtBQUhWLE9BQVA7QUFLRCxLQVZEOztBQVlBLFdBQU85akIsS0FBUDtBQUNEOztBQUVELE1BQUlTLFNBQVNoQyxjQUFjdm5CLFNBQTNCOztBQUVBdXBCLFNBQU9nakIsYUFBUCxHQUF1QixTQUFTQSxhQUFULENBQXVCdmlDLElBQXZCLEVBQTZCL0ssSUFBN0IsRUFBbUM7QUFDeEQsUUFBSSt0Qyx1QkFBdUIsS0FBS1YsYUFBTCxDQUFtQnJ0QyxJQUFuQixDQUEzQjtBQUFBLFFBQ0lFLFlBQVk2dEMscUJBQXFCN3RDLFNBRHJDO0FBQUEsUUFFSXN0QyxrQkFBa0JPLHFCQUFxQlAsZUFGM0M7QUFBQSxRQUdJRyxnQkFBZ0JJLHFCQUFxQkosYUFIekM7O0FBS0F6dEMsaUJBQWEySSxZQUFZa0MsSUFBWixFQUFrQjdLLFNBQWxCLENBQWI7QUFDQXN0Qyx1QkFBbUIza0MsWUFBWWtDLElBQVosRUFBa0J5aUMsZUFBbEIsQ0FBbkI7QUFDQUcscUJBQWlCOWtDLFlBQVlrQyxJQUFaLEVBQWtCNGlDLGFBQWxCLENBQWpCO0FBQ0QsR0FURDs7QUFXQXJqQixTQUFPbWpCLGlCQUFQLEdBQTJCLFNBQVNBLGlCQUFULENBQTJCMWlDLElBQTNCLEVBQWlDN0ssU0FBakMsRUFBNEM7QUFDckU7QUFDQTtBQUNBLFFBQUlBLFNBQUosRUFBZTtBQUNiO0FBQ0E2SyxjQUFRQSxLQUFLbkgsU0FBYjtBQUNBOztBQUVBZ0YsZUFBU21DLElBQVQsRUFBZTdLLFNBQWY7QUFDRDtBQUNGLEdBVkQ7O0FBWUFvcUIsU0FBTzN1QixNQUFQLEdBQWdCLFNBQVNBLE1BQVQsR0FBa0I7QUFDaEMsUUFBSXJCLFFBQVFrMEIsU0FBUyxFQUFULEVBQWEsS0FBS2wwQixLQUFsQixDQUFaOztBQUVBLFdBQU9BLE1BQU16QixVQUFiO0FBQ0EsV0FBT2d3QixPQUFPanZCLE9BQVAsQ0FBZWdZLGFBQWYsQ0FBNkJxVyxZQUFZcnVCLE9BQXpDLEVBQWtENDBCLFNBQVMsRUFBVCxFQUFhbDBCLEtBQWIsRUFBb0I7QUFDM0VpdEIsZUFBUyxLQUFLQSxPQUQ2RDtBQUUzRXpMLGlCQUFXLEtBQUtBLFNBRjJEO0FBRzNFQyxrQkFBWSxLQUFLQSxVQUgwRDtBQUkzRTZQLGNBQVEsS0FBS0EsTUFKOEQ7QUFLM0VDLGlCQUFXLEtBQUtBLFNBTDJEO0FBTTNFRixnQkFBVSxLQUFLQTtBQU40RCxLQUFwQixDQUFsRCxDQUFQO0FBUUQsR0FaRDs7QUFjQSxTQUFPckQsYUFBUDtBQUNELENBL0lELENBK0lFTyxPQUFPanZCLE9BQVAsQ0FBZW1DLFNBL0lqQixDQUZBOztBQW1KQXVzQixjQUFjdHNCLFNBQWQsR0FBMEJ2RixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsR0FBd0NxRixTQUF4QyxHQUFvRCxFQUE5RTtBQUNBLElBQUkyd0IsV0FBV3JFLGFBQWY7QUFDQWx4QixRQUFRd0MsT0FBUixHQUFrQit5QixRQUFsQjtBQUNBeDFCLE9BQU9DLE9BQVAsR0FBaUJBLFFBQVEsU0FBUixDQUFqQixDOzs7Ozs7OztBQ3hTYTs7QUFFYixJQUFJMHdCLHlCQUF5Qnp3QixtQkFBT0EsQ0FBQyxHQUFSLENBQTdCOztBQUVBRCxRQUFROHdCLFVBQVIsR0FBcUIsSUFBckI7QUFDQTl3QixRQUFRd0MsT0FBUixHQUFrQmdQLFFBQWxCOztBQUVBLElBQUlvbEMsWUFBWWxtQix1QkFBdUJ6d0IsbUJBQU9BLENBQUMsR0FBUixDQUF2QixDQUFoQjs7QUFFQSxTQUFTdVIsUUFBVCxDQUFrQnhNLE9BQWxCLEVBQTJCOEQsU0FBM0IsRUFBc0M7QUFDcEMsTUFBSTlELFFBQVF5VixTQUFaLEVBQXVCelYsUUFBUXlWLFNBQVIsQ0FBa0IxWCxHQUFsQixDQUFzQitGLFNBQXRCLEVBQXZCLEtBQTZELElBQUksQ0FBQyxDQUFDLEdBQUc4dEMsVUFBVXAwQyxPQUFkLEVBQXVCd0MsT0FBdkIsRUFBZ0M4RCxTQUFoQyxDQUFMLEVBQWlELElBQUksT0FBTzlELFFBQVE4RCxTQUFmLEtBQTZCLFFBQWpDLEVBQTJDOUQsUUFBUThELFNBQVIsR0FBb0I5RCxRQUFROEQsU0FBUixHQUFvQixHQUFwQixHQUEwQkEsU0FBOUMsQ0FBM0MsS0FBd0c5RCxRQUFRNnhDLFlBQVIsQ0FBcUIsT0FBckIsRUFBOEIsQ0FBQzd4QyxRQUFROEQsU0FBUixJQUFxQjlELFFBQVE4RCxTQUFSLENBQWtCZ3VDLE9BQXZDLElBQWtELEVBQW5ELElBQXlELEdBQXpELEdBQStEaHVDLFNBQTdGO0FBQ3ZOOztBQUVEL0ksT0FBT0MsT0FBUCxHQUFpQkEsUUFBUSxTQUFSLENBQWpCLEM7Ozs7Ozs7OztBQ2JBLFNBQVMwd0Isc0JBQVQsQ0FBZ0MzdkIsR0FBaEMsRUFBcUM7QUFDbkMsU0FBT0EsT0FBT0EsSUFBSSt2QixVQUFYLEdBQXdCL3ZCLEdBQXhCLEdBQThCO0FBQ25DeUIsYUFBU3pCO0FBRDBCLEdBQXJDO0FBR0Q7O0FBRURoQixPQUFPQyxPQUFQLEdBQWlCMHdCLHNCQUFqQixDOzs7Ozs7O0FDTmE7O0FBRWIxd0IsUUFBUTh3QixVQUFSLEdBQXFCLElBQXJCO0FBQ0E5d0IsUUFBUXdDLE9BQVIsR0FBa0J5WCxRQUFsQjs7QUFFQSxTQUFTQSxRQUFULENBQWtCalYsT0FBbEIsRUFBMkI4RCxTQUEzQixFQUFzQztBQUNwQyxNQUFJOUQsUUFBUXlWLFNBQVosRUFBdUIsT0FBTyxDQUFDLENBQUMzUixTQUFGLElBQWU5RCxRQUFReVYsU0FBUixDQUFrQkMsUUFBbEIsQ0FBMkI1UixTQUEzQixDQUF0QixDQUF2QixLQUF3RixPQUFPLENBQUMsT0FBTzlELFFBQVE4RCxTQUFSLENBQWtCZ3VDLE9BQWxCLElBQTZCOXhDLFFBQVE4RCxTQUE1QyxJQUF5RCxHQUExRCxFQUErRFosT0FBL0QsQ0FBdUUsTUFBTVksU0FBTixHQUFrQixHQUF6RixNQUFrRyxDQUFDLENBQTFHO0FBQ3pGOztBQUVEL0ksT0FBT0MsT0FBUCxHQUFpQkEsUUFBUSxTQUFSLENBQWpCLEM7Ozs7Ozs7QUNUYTs7QUFFYixTQUFTeU4sZ0JBQVQsQ0FBMEJzcEMsU0FBMUIsRUFBcUNDLGFBQXJDLEVBQW9EO0FBQ2xELFNBQU9ELFVBQVVudEMsT0FBVixDQUFrQixJQUFJZzhCLE1BQUosQ0FBVyxZQUFZb1IsYUFBWixHQUE0QixXQUF2QyxFQUFvRCxHQUFwRCxDQUFsQixFQUE0RSxJQUE1RSxFQUFrRnB0QyxPQUFsRixDQUEwRixNQUExRixFQUFrRyxHQUFsRyxFQUF1R0EsT0FBdkcsQ0FBK0csWUFBL0csRUFBNkgsRUFBN0gsQ0FBUDtBQUNEOztBQUVEN0osT0FBT0MsT0FBUCxHQUFpQixTQUFTeVIsV0FBVCxDQUFxQnpNLE9BQXJCLEVBQThCOEQsU0FBOUIsRUFBeUM7QUFDeEQsTUFBSTlELFFBQVF5VixTQUFaLEVBQXVCelYsUUFBUXlWLFNBQVIsQ0FBa0J0VyxNQUFsQixDQUF5QjJFLFNBQXpCLEVBQXZCLEtBQWdFLElBQUksT0FBTzlELFFBQVE4RCxTQUFmLEtBQTZCLFFBQWpDLEVBQTJDOUQsUUFBUThELFNBQVIsR0FBb0IyRSxpQkFBaUJ6SSxRQUFROEQsU0FBekIsRUFBb0NBLFNBQXBDLENBQXBCLENBQTNDLEtBQW1IOUQsUUFBUTZ4QyxZQUFSLENBQXFCLE9BQXJCLEVBQThCcHBDLGlCQUFpQnpJLFFBQVE4RCxTQUFSLElBQXFCOUQsUUFBUThELFNBQVIsQ0FBa0JndUMsT0FBdkMsSUFBa0QsRUFBbkUsRUFBdUVodUMsU0FBdkUsQ0FBOUI7QUFDcEwsQ0FGRCxDOzs7Ozs7O0FDTkEsK0NBQWE7Ozs7QUFFYjlJLFFBQVE4d0IsVUFBUixHQUFxQixJQUFyQjtBQUNBOXdCLFFBQVF3QyxPQUFSLEdBQWtCLEtBQUssQ0FBdkI7O0FBRUEsSUFBSW8wQixhQUFhbEcsdUJBQXVCendCLG1CQUFPQSxDQUFDLENBQVIsQ0FBdkIsQ0FBakI7O0FBRUEsSUFBSXd4QixTQUFTZix1QkFBdUJ6d0IsbUJBQU9BLENBQUMsQ0FBUixDQUF2QixDQUFiOztBQUVBLElBQUl5eEIsWUFBWXp4QixtQkFBT0EsQ0FBQyxDQUFSLENBQWhCOztBQUVBLElBQUkyd0IsbUJBQW1CRix1QkFBdUJ6d0IsbUJBQU9BLENBQUMsRUFBUixDQUF2QixDQUF2Qjs7QUFFQSxTQUFTeXdCLHNCQUFULENBQWdDM3ZCLEdBQWhDLEVBQXFDO0FBQUUsU0FBT0EsT0FBT0EsSUFBSSt2QixVQUFYLEdBQXdCL3ZCLEdBQXhCLEdBQThCLEVBQUV5QixTQUFTekIsR0FBWCxFQUFyQztBQUF3RDs7QUFFL0YsU0FBU2t4Qiw2QkFBVCxDQUF1Qy9xQixNQUF2QyxFQUErQ2dyQixRQUEvQyxFQUF5RDtBQUFFLE1BQUlockIsVUFBVSxJQUFkLEVBQW9CLE9BQU8sRUFBUCxDQUFXLElBQUk4TSxTQUFTLEVBQWIsQ0FBaUIsSUFBSW1lLGFBQWFwcUIsT0FBT0MsSUFBUCxDQUFZZCxNQUFaLENBQWpCLENBQXNDLElBQUk3RSxHQUFKLEVBQVNWLENBQVQsQ0FBWSxLQUFLQSxJQUFJLENBQVQsRUFBWUEsSUFBSXd3QixXQUFXdHdCLE1BQTNCLEVBQW1DRixHQUFuQyxFQUF3QztBQUFFVSxVQUFNOHZCLFdBQVd4d0IsQ0FBWCxDQUFOLENBQXFCLElBQUl1d0IsU0FBU2hxQixPQUFULENBQWlCN0YsR0FBakIsS0FBeUIsQ0FBN0IsRUFBZ0MsU0FBVTJSLE9BQU8zUixHQUFQLElBQWM2RSxPQUFPN0UsR0FBUCxDQUFkO0FBQTRCLEdBQUMsT0FBTzJSLE1BQVA7QUFBZ0I7O0FBRW5ULFNBQVNvZSxjQUFULENBQXdCQyxRQUF4QixFQUFrQ0MsVUFBbEMsRUFBOEM7QUFBRUQsV0FBUzFvQixTQUFULEdBQXFCNUIsT0FBT3dxQixNQUFQLENBQWNELFdBQVczb0IsU0FBekIsQ0FBckIsQ0FBMEQwb0IsU0FBUzFvQixTQUFULENBQW1CSSxXQUFuQixHQUFpQ3NvQixRQUFqQztBQUE1RCxZQUF1R0EsUUFBdkcsRUFBNEhDLFVBQTVIO0FBQXlJOztBQUV2TCxJQUFJMXRCLFlBQVl2RixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsR0FBd0M7QUFDdER1a0IsTUFBSThTLFdBQVdwMEIsT0FBWCxDQUFtQnVDLElBQW5CLENBQXdCb3dCLFVBRDBCO0FBRXREendCLFlBQVUsU0FBU0EsUUFBVCxDQUFrQnhCLEtBQWxCLEVBQXlCNGdDLFFBQXpCLEVBQW1DO0FBQzNDLFFBQUlyUyxPQUFPanZCLE9BQVAsQ0FBZWdDLFFBQWYsQ0FBd0J5eUMsS0FBeEIsQ0FBOEIvekMsTUFBTTRnQyxRQUFOLENBQTlCLE1BQW1ELENBQXZELEVBQTBELE9BQU8sSUFBSTVjLEtBQUosQ0FBVSxPQUFPNGMsUUFBUCxHQUFrQiwrQ0FBNUIsQ0FBUDtBQUMxRCxXQUFPLElBQVA7QUFDRDtBQUxxRCxDQUF4QyxHQU1aLEVBTkosQ0FNTztBQUNQOzs7Ozs7Ozs7Ozs7QUFZQSxJQUFJN1M7QUFDSjtBQUNBLFVBQVV1QixnQkFBVixFQUE0QjtBQUMxQkosaUJBQWVuQixpQkFBZixFQUFrQ3VCLGdCQUFsQzs7QUFFQSxXQUFTdkIsaUJBQVQsR0FBNkI7QUFDM0IsUUFBSXdCLEtBQUo7O0FBRUEsU0FBSyxJQUFJNkMsT0FBTzF6QixVQUFVQyxNQUFyQixFQUE2QnExQyxRQUFRLElBQUlqMUMsS0FBSixDQUFVcXpCLElBQVYsQ0FBckMsRUFBc0R0cEIsT0FBTyxDQUFsRSxFQUFxRUEsT0FBT3NwQixJQUE1RSxFQUFrRnRwQixNQUFsRixFQUEwRjtBQUN4RmtyQyxZQUFNbHJDLElBQU4sSUFBY3BLLFVBQVVvSyxJQUFWLENBQWQ7QUFDRDs7QUFFRHltQixZQUFRRCxpQkFBaUJsd0IsSUFBakIsQ0FBc0JGLEtBQXRCLENBQTRCb3dCLGdCQUE1QixFQUE4QyxDQUFDLElBQUQsRUFBT3ByQixNQUFQLENBQWM4dkMsS0FBZCxDQUE5QyxLQUF1RSxJQUEvRTs7QUFFQXprQixVQUFNaEUsV0FBTixHQUFvQixZQUFZO0FBQzlCLFdBQUssSUFBSTBvQixRQUFRdjFDLFVBQVVDLE1BQXRCLEVBQThCaUIsT0FBTyxJQUFJYixLQUFKLENBQVVrMUMsS0FBVixDQUFyQyxFQUF1REMsUUFBUSxDQUFwRSxFQUF1RUEsUUFBUUQsS0FBL0UsRUFBc0ZDLE9BQXRGLEVBQStGO0FBQzdGdDBDLGFBQUtzMEMsS0FBTCxJQUFjeDFDLFVBQVV3MUMsS0FBVixDQUFkO0FBQ0Q7O0FBRUQsYUFBTzNrQixNQUFNNGtCLGVBQU4sQ0FBc0IsU0FBdEIsRUFBaUMsQ0FBakMsRUFBb0N2MEMsSUFBcEMsQ0FBUDtBQUNELEtBTkQ7O0FBUUEydkIsVUFBTTZrQixjQUFOLEdBQXVCLFlBQVk7QUFDakMsV0FBSyxJQUFJQyxRQUFRMzFDLFVBQVVDLE1BQXRCLEVBQThCaUIsT0FBTyxJQUFJYixLQUFKLENBQVVzMUMsS0FBVixDQUFyQyxFQUF1REMsUUFBUSxDQUFwRSxFQUF1RUEsUUFBUUQsS0FBL0UsRUFBc0ZDLE9BQXRGLEVBQStGO0FBQzdGMTBDLGFBQUswMEMsS0FBTCxJQUFjNTFDLFVBQVU0MUMsS0FBVixDQUFkO0FBQ0Q7O0FBRUQsYUFBTy9rQixNQUFNNGtCLGVBQU4sQ0FBc0IsWUFBdEIsRUFBb0MsQ0FBcEMsRUFBdUN2MEMsSUFBdkMsQ0FBUDtBQUNELEtBTkQ7O0FBUUEydkIsVUFBTWdsQixhQUFOLEdBQXNCLFlBQVk7QUFDaEMsV0FBSyxJQUFJQyxRQUFROTFDLFVBQVVDLE1BQXRCLEVBQThCaUIsT0FBTyxJQUFJYixLQUFKLENBQVV5MUMsS0FBVixDQUFyQyxFQUF1REMsUUFBUSxDQUFwRSxFQUF1RUEsUUFBUUQsS0FBL0UsRUFBc0ZDLE9BQXRGLEVBQStGO0FBQzdGNzBDLGFBQUs2MEMsS0FBTCxJQUFjLzFDLFVBQVUrMUMsS0FBVixDQUFkO0FBQ0Q7O0FBRUQsYUFBT2xsQixNQUFNNGtCLGVBQU4sQ0FBc0IsV0FBdEIsRUFBbUMsQ0FBbkMsRUFBc0N2MEMsSUFBdEMsQ0FBUDtBQUNELEtBTkQ7O0FBUUEydkIsVUFBTW1sQixVQUFOLEdBQW1CLFlBQVk7QUFDN0IsV0FBSyxJQUFJQyxRQUFRajJDLFVBQVVDLE1BQXRCLEVBQThCaUIsT0FBTyxJQUFJYixLQUFKLENBQVU0MUMsS0FBVixDQUFyQyxFQUF1REMsUUFBUSxDQUFwRSxFQUF1RUEsUUFBUUQsS0FBL0UsRUFBc0ZDLE9BQXRGLEVBQStGO0FBQzdGaDFDLGFBQUtnMUMsS0FBTCxJQUFjbDJDLFVBQVVrMkMsS0FBVixDQUFkO0FBQ0Q7O0FBRUQsYUFBT3JsQixNQUFNNGtCLGVBQU4sQ0FBc0IsUUFBdEIsRUFBZ0MsQ0FBaEMsRUFBbUN2MEMsSUFBbkMsQ0FBUDtBQUNELEtBTkQ7O0FBUUEydkIsVUFBTXNsQixhQUFOLEdBQXNCLFlBQVk7QUFDaEMsV0FBSyxJQUFJQyxRQUFRcDJDLFVBQVVDLE1BQXRCLEVBQThCaUIsT0FBTyxJQUFJYixLQUFKLENBQVUrMUMsS0FBVixDQUFyQyxFQUF1REMsUUFBUSxDQUFwRSxFQUF1RUEsUUFBUUQsS0FBL0UsRUFBc0ZDLE9BQXRGLEVBQStGO0FBQzdGbjFDLGFBQUttMUMsS0FBTCxJQUFjcjJDLFVBQVVxMkMsS0FBVixDQUFkO0FBQ0Q7O0FBRUQsYUFBT3hsQixNQUFNNGtCLGVBQU4sQ0FBc0IsV0FBdEIsRUFBbUMsQ0FBbkMsRUFBc0N2MEMsSUFBdEMsQ0FBUDtBQUNELEtBTkQ7O0FBUUEydkIsVUFBTWtGLFlBQU4sR0FBcUIsWUFBWTtBQUMvQixXQUFLLElBQUl1Z0IsUUFBUXQyQyxVQUFVQyxNQUF0QixFQUE4QmlCLE9BQU8sSUFBSWIsS0FBSixDQUFVaTJDLEtBQVYsQ0FBckMsRUFBdURDLFFBQVEsQ0FBcEUsRUFBdUVBLFFBQVFELEtBQS9FLEVBQXNGQyxPQUF0RixFQUErRjtBQUM3RnIxQyxhQUFLcTFDLEtBQUwsSUFBY3YyQyxVQUFVdTJDLEtBQVYsQ0FBZDtBQUNEOztBQUVELGFBQU8xbEIsTUFBTTRrQixlQUFOLENBQXNCLFVBQXRCLEVBQWtDLENBQWxDLEVBQXFDdjBDLElBQXJDLENBQVA7QUFDRCxLQU5EOztBQVFBLFdBQU8ydkIsS0FBUDtBQUNEOztBQUVELE1BQUlTLFNBQVNqQyxrQkFBa0J0bkIsU0FBL0I7O0FBRUF1cEIsU0FBT21rQixlQUFQLEdBQXlCLFNBQVNBLGVBQVQsQ0FBeUJ0aUIsT0FBekIsRUFBa0NxakIsR0FBbEMsRUFBdUNDLFlBQXZDLEVBQXFEO0FBQzVFLFFBQUlDLFlBQUo7O0FBRUEsUUFBSTV6QyxXQUFXLEtBQUt4QixLQUFMLENBQVd3QixRQUExQjs7QUFFQSxRQUFJNkksUUFBUWtrQixPQUFPanZCLE9BQVAsQ0FBZWdDLFFBQWYsQ0FBd0I2cUIsT0FBeEIsQ0FBZ0MzcUIsUUFBaEMsRUFBMEMwekMsR0FBMUMsQ0FBWjs7QUFFQSxRQUFJN3FDLE1BQU1ySyxLQUFOLENBQVk2eEIsT0FBWixDQUFKLEVBQTBCLENBQUN1akIsZUFBZS9xQyxNQUFNckssS0FBdEIsRUFBNkI2eEIsT0FBN0IsRUFBc0MzeUIsS0FBdEMsQ0FBNENrMkMsWUFBNUMsRUFBMERELFlBQTFEO0FBQzFCLFFBQUksS0FBS24xQyxLQUFMLENBQVc2eEIsT0FBWCxDQUFKLEVBQXlCLEtBQUs3eEIsS0FBTCxDQUFXNnhCLE9BQVgsRUFBb0IsQ0FBQyxHQUFHckQsVUFBVW9DLFdBQWQsRUFBMkIsSUFBM0IsQ0FBcEI7QUFDMUIsR0FURDs7QUFXQVosU0FBTzN1QixNQUFQLEdBQWdCLFNBQVNBLE1BQVQsR0FBa0I7QUFDaEMsUUFBSTB3QixjQUFjLEtBQUsveEIsS0FBdkI7QUFBQSxRQUNJd0IsV0FBV3V3QixZQUFZdndCLFFBRDNCO0FBQUEsUUFFSTZ6QyxTQUFTdGpCLFlBQVluUixFQUZ6QjtBQUFBLFFBR0k1Z0IsUUFBUSt1Qiw4QkFBOEJnRCxXQUE5QixFQUEyQyxDQUFDLFVBQUQsRUFBYSxJQUFiLENBQTNDLENBSFo7O0FBS0EsUUFBSXVqQix3QkFBd0IvbUIsT0FBT2p2QixPQUFQLENBQWVnQyxRQUFmLENBQXdCNnFCLE9BQXhCLENBQWdDM3FCLFFBQWhDLENBQTVCO0FBQUEsUUFDSThMLFFBQVFnb0Msc0JBQXNCLENBQXRCLENBRFo7QUFBQSxRQUVJamhDLFNBQVNpaEMsc0JBQXNCLENBQXRCLENBRmI7O0FBSUEsV0FBT3QxQyxNQUFNaXRCLE9BQWI7QUFDQSxXQUFPanRCLE1BQU15aEIsVUFBYjtBQUNBLFdBQU96aEIsTUFBTXdoQixTQUFiO0FBQ0EsV0FBT3hoQixNQUFNc3hCLE1BQWI7QUFDQSxXQUFPdHhCLE1BQU11eEIsU0FBYjtBQUNBLFdBQU92eEIsTUFBTXF4QixRQUFiO0FBQ0EsV0FBTzlDLE9BQU9qdkIsT0FBUCxDQUFlZ1ksYUFBZixDQUE2Qm9XLGlCQUFpQnB1QixPQUE5QyxFQUF1RFUsS0FBdkQsRUFBOERxMUMsU0FBUzltQixPQUFPanZCLE9BQVAsQ0FBZWdSLFlBQWYsQ0FBNEJoRCxLQUE1QixFQUFtQztBQUMvR25PLFdBQUssT0FEMEc7QUFFL0c4dEIsZUFBUyxLQUFLMUIsV0FGaUc7QUFHL0c5SixrQkFBWSxLQUFLMnlCLGNBSDhGO0FBSS9HNXlCLGlCQUFXLEtBQUsreUI7QUFKK0YsS0FBbkMsQ0FBVCxHQUtoRWhtQixPQUFPanZCLE9BQVAsQ0FBZWdSLFlBQWYsQ0FBNEIrRCxNQUE1QixFQUFvQztBQUN2Q2xWLFdBQUssUUFEa0M7QUFFdkM4dEIsZUFBUyxLQUFLeW5CLFVBRnlCO0FBR3ZDanpCLGtCQUFZLEtBQUtvekIsYUFIc0I7QUFJdkNyekIsaUJBQVcsS0FBS2lUO0FBSnVCLEtBQXBDLENBTEUsQ0FBUDtBQVdELEdBM0JEOztBQTZCQSxTQUFPMUcsaUJBQVA7QUFDRCxDQTFHRCxDQTBHRVEsT0FBT2p2QixPQUFQLENBQWVtQyxTQTFHakIsQ0FGQTs7QUE4R0Fzc0Isa0JBQWtCcnNCLFNBQWxCLEdBQThCdkYsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLEdBQXdDcUYsU0FBeEMsR0FBb0QsRUFBbEY7QUFDQSxJQUFJMndCLFdBQVd0RSxpQkFBZjtBQUNBanhCLFFBQVF3QyxPQUFSLEdBQWtCK3lCLFFBQWxCO0FBQ0F4MUIsT0FBT0MsT0FBUCxHQUFpQkEsUUFBUSxTQUFSLENBQWpCLEM7Ozs7Ozs7O0FDdkphOztBQUViQSxRQUFROHdCLFVBQVIsR0FBcUIsSUFBckI7QUFDQTl3QixRQUFRbTRCLGVBQVIsR0FBMEJBLGVBQTFCO0FBQ0FuNEIsUUFBUXk0QyxrQkFBUixHQUE2QkEsa0JBQTdCO0FBQ0F6NEMsUUFBUWc0QixzQkFBUixHQUFpQ0Esc0JBQWpDO0FBQ0FoNEIsUUFBUWk0QixtQkFBUixHQUE4QkEsbUJBQTlCOztBQUVBLElBQUl4RyxTQUFTeHhCLG1CQUFPQSxDQUFDLENBQVIsQ0FBYjs7QUFFQTs7Ozs7O0FBTUEsU0FBU2s0QixlQUFULENBQXlCenpCLFFBQXpCLEVBQW1DZzBDLEtBQW5DLEVBQTBDO0FBQ3hDLE1BQUlDLFNBQVMsU0FBU0EsTUFBVCxDQUFnQnByQyxLQUFoQixFQUF1QjtBQUNsQyxXQUFPbXJDLFNBQVMsQ0FBQyxHQUFHam5CLE9BQU85eEIsY0FBWCxFQUEyQjROLEtBQTNCLENBQVQsR0FBNkNtckMsTUFBTW5yQyxLQUFOLENBQTdDLEdBQTREQSxLQUFuRTtBQUNELEdBRkQ7O0FBSUEsTUFBSThRLFNBQVN0VyxPQUFPd3FCLE1BQVAsQ0FBYyxJQUFkLENBQWI7QUFDQSxNQUFJN3RCLFFBQUosRUFBYytzQixPQUFPanRCLFFBQVAsQ0FBZ0I0QixHQUFoQixDQUFvQjFCLFFBQXBCLEVBQThCLFVBQVVvdUMsQ0FBVixFQUFhO0FBQ3ZELFdBQU9BLENBQVA7QUFDRCxHQUZhLEVBRVg3cUMsT0FGVyxDQUVILFVBQVVzRixLQUFWLEVBQWlCO0FBQzFCO0FBQ0E4USxXQUFPOVEsTUFBTWxMLEdBQWIsSUFBb0JzMkMsT0FBT3ByQyxLQUFQLENBQXBCO0FBQ0QsR0FMYTtBQU1kLFNBQU84USxNQUFQO0FBQ0Q7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBLFNBQVNvNkIsa0JBQVQsQ0FBNEI5Z0MsSUFBNUIsRUFBa0NDLElBQWxDLEVBQXdDO0FBQ3RDRCxTQUFPQSxRQUFRLEVBQWY7QUFDQUMsU0FBT0EsUUFBUSxFQUFmOztBQUVBLFdBQVNnaEMsY0FBVCxDQUF3QnYyQyxHQUF4QixFQUE2QjtBQUMzQixXQUFPQSxPQUFPdVYsSUFBUCxHQUFjQSxLQUFLdlYsR0FBTCxDQUFkLEdBQTBCc1YsS0FBS3RWLEdBQUwsQ0FBakM7QUFDRCxHQU5xQyxDQU1wQztBQUNGOzs7QUFHQSxNQUFJdzJDLGtCQUFrQjl3QyxPQUFPd3FCLE1BQVAsQ0FBYyxJQUFkLENBQXRCO0FBQ0EsTUFBSXVtQixjQUFjLEVBQWxCOztBQUVBLE9BQUssSUFBSXpyQixPQUFULElBQW9CMVYsSUFBcEIsRUFBMEI7QUFDeEIsUUFBSTBWLFdBQVd6VixJQUFmLEVBQXFCO0FBQ25CLFVBQUlraEMsWUFBWWozQyxNQUFoQixFQUF3QjtBQUN0QmczQyx3QkFBZ0J4ckIsT0FBaEIsSUFBMkJ5ckIsV0FBM0I7QUFDQUEsc0JBQWMsRUFBZDtBQUNEO0FBQ0YsS0FMRCxNQUtPO0FBQ0xBLGtCQUFZOTJDLElBQVosQ0FBaUJxckIsT0FBakI7QUFDRDtBQUNGOztBQUVELE1BQUkxckIsQ0FBSjtBQUNBLE1BQUlvM0MsZUFBZSxFQUFuQjs7QUFFQSxPQUFLLElBQUl6ckIsT0FBVCxJQUFvQjFWLElBQXBCLEVBQTBCO0FBQ3hCLFFBQUlpaEMsZ0JBQWdCdnJCLE9BQWhCLENBQUosRUFBOEI7QUFDNUIsV0FBSzNyQixJQUFJLENBQVQsRUFBWUEsSUFBSWszQyxnQkFBZ0J2ckIsT0FBaEIsRUFBeUJ6ckIsTUFBekMsRUFBaURGLEdBQWpELEVBQXNEO0FBQ3BELFlBQUlxM0MsaUJBQWlCSCxnQkFBZ0J2ckIsT0FBaEIsRUFBeUIzckIsQ0FBekIsQ0FBckI7QUFDQW8zQyxxQkFBYUYsZ0JBQWdCdnJCLE9BQWhCLEVBQXlCM3JCLENBQXpCLENBQWIsSUFBNENpM0MsZUFBZUksY0FBZixDQUE1QztBQUNEO0FBQ0Y7O0FBRURELGlCQUFhenJCLE9BQWIsSUFBd0JzckIsZUFBZXRyQixPQUFmLENBQXhCO0FBQ0QsR0FwQ3FDLENBb0NwQzs7O0FBR0YsT0FBSzNyQixJQUFJLENBQVQsRUFBWUEsSUFBSW0zQyxZQUFZajNDLE1BQTVCLEVBQW9DRixHQUFwQyxFQUF5QztBQUN2Q28zQyxpQkFBYUQsWUFBWW4zQyxDQUFaLENBQWIsSUFBK0JpM0MsZUFBZUUsWUFBWW4zQyxDQUFaLENBQWYsQ0FBL0I7QUFDRDs7QUFFRCxTQUFPbzNDLFlBQVA7QUFDRDs7QUFFRCxTQUFTRSxPQUFULENBQWlCMXJDLEtBQWpCLEVBQXdCMnJDLElBQXhCLEVBQThCaDJDLEtBQTlCLEVBQXFDO0FBQ25DLFNBQU9BLE1BQU1nMkMsSUFBTixLQUFlLElBQWYsR0FBc0JoMkMsTUFBTWcyQyxJQUFOLENBQXRCLEdBQW9DM3JDLE1BQU1ySyxLQUFOLENBQVlnMkMsSUFBWixDQUEzQztBQUNEOztBQUVELFNBQVNsaEIsc0JBQVQsQ0FBZ0M5MEIsS0FBaEMsRUFBdUNxeEIsUUFBdkMsRUFBaUQ7QUFDL0MsU0FBTzRELGdCQUFnQmoxQixNQUFNd0IsUUFBdEIsRUFBZ0MsVUFBVTZJLEtBQVYsRUFBaUI7QUFDdEQsV0FBTyxDQUFDLEdBQUdra0IsT0FBT2plLFlBQVgsRUFBeUJqRyxLQUF6QixFQUFnQztBQUNyQ2duQixnQkFBVUEsU0FBUzNqQixJQUFULENBQWMsSUFBZCxFQUFvQnJELEtBQXBCLENBRDJCO0FBRXJDdVcsVUFBSSxJQUZpQztBQUdyQzJMLGNBQVF3cEIsUUFBUTFyQyxLQUFSLEVBQWUsUUFBZixFQUF5QnJLLEtBQXpCLENBSDZCO0FBSXJDOGUsYUFBT2kzQixRQUFRMXJDLEtBQVIsRUFBZSxPQUFmLEVBQXdCckssS0FBeEIsQ0FKOEI7QUFLckMwd0IsWUFBTXFsQixRQUFRMXJDLEtBQVIsRUFBZSxNQUFmLEVBQXVCckssS0FBdkI7QUFMK0IsS0FBaEMsQ0FBUDtBQU9ELEdBUk0sQ0FBUDtBQVNEOztBQUVELFNBQVMrMEIsbUJBQVQsQ0FBNkJqMEIsU0FBN0IsRUFBd0MrekIsZ0JBQXhDLEVBQTBEeEQsUUFBMUQsRUFBb0U7QUFDbEUsTUFBSTRrQixtQkFBbUJoaEIsZ0JBQWdCbjBCLFVBQVVVLFFBQTFCLENBQXZCO0FBQ0EsTUFBSUEsV0FBVyt6QyxtQkFBbUIxZ0IsZ0JBQW5CLEVBQXFDb2hCLGdCQUFyQyxDQUFmO0FBQ0FweEMsU0FBT0MsSUFBUCxDQUFZdEQsUUFBWixFQUFzQnVELE9BQXRCLENBQThCLFVBQVU1RixHQUFWLEVBQWU7QUFDM0MsUUFBSWtMLFFBQVE3SSxTQUFTckMsR0FBVCxDQUFaO0FBQ0EsUUFBSSxDQUFDLENBQUMsR0FBR292QixPQUFPOXhCLGNBQVgsRUFBMkI0TixLQUEzQixDQUFMLEVBQXdDO0FBQ3hDLFFBQUk2ckMsVUFBVS8yQyxPQUFPMDFCLGdCQUFyQjtBQUNBLFFBQUlzaEIsVUFBVWgzQyxPQUFPODJDLGdCQUFyQjtBQUNBLFFBQUlHLFlBQVl2aEIsaUJBQWlCMTFCLEdBQWpCLENBQWhCO0FBQ0EsUUFBSWszQyxZQUFZLENBQUMsR0FBRzluQixPQUFPOXhCLGNBQVgsRUFBMkIyNUMsU0FBM0IsS0FBeUMsQ0FBQ0EsVUFBVXAyQyxLQUFWLENBQWdCNGdCLEVBQTFFLENBTjJDLENBTW1DOztBQUU5RSxRQUFJdTFCLFlBQVksQ0FBQ0QsT0FBRCxJQUFZRyxTQUF4QixDQUFKLEVBQXdDO0FBQ3RDO0FBQ0E3MEMsZUFBU3JDLEdBQVQsSUFBZ0IsQ0FBQyxHQUFHb3ZCLE9BQU9qZSxZQUFYLEVBQXlCakcsS0FBekIsRUFBZ0M7QUFDOUNnbkIsa0JBQVVBLFNBQVMzakIsSUFBVCxDQUFjLElBQWQsRUFBb0JyRCxLQUFwQixDQURvQztBQUU5Q3VXLFlBQUksSUFGMEM7QUFHOUM4UCxjQUFNcWxCLFFBQVExckMsS0FBUixFQUFlLE1BQWYsRUFBdUJ2SixTQUF2QixDQUh3QztBQUk5Q2dlLGVBQU9pM0IsUUFBUTFyQyxLQUFSLEVBQWUsT0FBZixFQUF3QnZKLFNBQXhCO0FBSnVDLE9BQWhDLENBQWhCO0FBTUQsS0FSRCxNQVFPLElBQUksQ0FBQ3ExQyxPQUFELElBQVlELE9BQVosSUFBdUIsQ0FBQ0csU0FBNUIsRUFBdUM7QUFDNUM7QUFDQTtBQUNBNzBDLGVBQVNyQyxHQUFULElBQWdCLENBQUMsR0FBR292QixPQUFPamUsWUFBWCxFQUF5QmpHLEtBQXpCLEVBQWdDO0FBQzlDdVcsWUFBSTtBQUQwQyxPQUFoQyxDQUFoQjtBQUdELEtBTk0sTUFNQSxJQUFJdTFCLFdBQVdELE9BQVgsSUFBc0IsQ0FBQyxHQUFHM25CLE9BQU85eEIsY0FBWCxFQUEyQjI1QyxTQUEzQixDQUExQixFQUFpRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTUwQyxlQUFTckMsR0FBVCxJQUFnQixDQUFDLEdBQUdvdkIsT0FBT2plLFlBQVgsRUFBeUJqRyxLQUF6QixFQUFnQztBQUM5Q2duQixrQkFBVUEsU0FBUzNqQixJQUFULENBQWMsSUFBZCxFQUFvQnJELEtBQXBCLENBRG9DO0FBRTlDdVcsWUFBSXcxQixVQUFVcDJDLEtBQVYsQ0FBZ0I0Z0IsRUFGMEI7QUFHOUM4UCxjQUFNcWxCLFFBQVExckMsS0FBUixFQUFlLE1BQWYsRUFBdUJ2SixTQUF2QixDQUh3QztBQUk5Q2dlLGVBQU9pM0IsUUFBUTFyQyxLQUFSLEVBQWUsT0FBZixFQUF3QnZKLFNBQXhCO0FBSnVDLE9BQWhDLENBQWhCO0FBTUQ7QUFDRixHQWpDRDtBQWtDQSxTQUFPVSxRQUFQO0FBQ0QsQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3JKRDs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTWlLLE9BQU8sU0FBUEEsSUFBTyxHQUFNLENBQUUsQ0FBckI7SUFDUXNWLEUsR0FBWXJqQixZLENBQVpxakIsRTtJQUFJTCxHLEdBQVFoakIsWSxDQUFSZ2pCLEc7SUFDSnBTLFEsR0FBMEI3USxTLENBQTFCNlEsUTtJQUFVQyxXLEdBQWdCOVEsUyxDQUFoQjhRLFc7O0FBQ2xCLElBQU11UCxXQUFXLENBQUMsVUFBRCxFQUFhLE9BQWIsRUFBc0IsS0FBdEIsRUFBNkIsS0FBN0IsRUFBb0MsRUFBcEMsQ0FBakI7O0FBRUEsU0FBU0MsZ0JBQVQsQ0FBMEJ0TixJQUExQixFQUFnQzhJLElBQWhDLEVBQXNDO0FBQ2xDLFFBQU12TyxRQUFReEwsT0FBT2daLGdCQUFQLENBQXdCL0gsSUFBeEIsQ0FBZDtBQUNBLFFBQUlqSixNQUFNLEVBQVY7QUFDQSxTQUFLLElBQUkvSSxJQUFJLENBQWIsRUFBZ0JBLElBQUlxZixTQUFTbmYsTUFBN0IsRUFBcUNGLEdBQXJDLEVBQTBDO0FBQ3RDK0ksY0FBTXdELE1BQU13TyxnQkFBTixDQUF1QnNFLFNBQVNyZixDQUFULElBQWM4YSxJQUFyQyxDQUFOO0FBQ0EsWUFBSS9SLEdBQUosRUFBUztBQUNMO0FBQ0g7QUFDSjtBQUNELFdBQU9BLEdBQVA7QUFDSDs7SUFFb0I4dUMsWTs7O0FBMEJqQiwwQkFBWXQyQyxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsc0RBQ2Ysc0JBQU1BLEtBQU4sQ0FEZTs7QUFFZnJDLG1CQUFLcUssT0FBTCxTQUFtQixDQUNmLGFBRGUsRUFDQSxnQkFEQSxFQUNrQixlQURsQixFQUVmLFlBRmUsRUFFRCxlQUZDLEVBRWdCLGNBRmhCLEVBR2YsZ0JBSGUsQ0FBbkI7QUFLQSxlQUFLdXVDLFlBQUwsR0FBb0I7QUFDaEJDLDJCQUFlLEVBREM7QUFFaEJDLDBCQUFjO0FBRkUsU0FBcEI7QUFJQSxlQUFLNzNCLFVBQUwsR0FBa0IsRUFBbEI7QUFYZTtBQVlsQjs7MkJBRUQ1ZCxvQixtQ0FBdUI7QUFBQTs7QUFDbkI2RCxlQUFPQyxJQUFQLENBQVksS0FBS3l4QyxZQUFqQixFQUErQnh4QyxPQUEvQixDQUF1QyxxQkFBYTtBQUNoRCxtQkFBS3d4QyxZQUFMLENBQWtCbFEsU0FBbEIsRUFBNkJ0aEMsT0FBN0IsQ0FBcUMsb0JBQVk7QUFDN0MyYixvQkFBSSxPQUFLalEsSUFBVCxFQUFlNDFCLFNBQWYsRUFBMEJxUSxRQUExQjtBQUNILGFBRkQ7QUFHSCxTQUpEO0FBS0EsYUFBS0gsWUFBTCxHQUFvQjtBQUNoQkMsMkJBQWUsRUFEQztBQUVoQkMsMEJBQWM7QUFGRSxTQUFwQjtBQUlILEs7OzJCQUVERSxtQixnQ0FBb0JsbUMsSSxFQUFNOHhCLEksRUFBTThELFMsRUFBVzVpQyxFLEVBQUk7QUFDM0MsWUFBTThyQixRQUFRLElBQWQ7QUFDQSxlQUFPLFNBQVNxbkIsV0FBVCxDQUFxQnoxQyxDQUFyQixFQUF3Qjs7QUFFM0IsZ0JBQUlBLEtBQUtBLEVBQUUyUCxNQUFGLEtBQWFMLElBQXRCLEVBQTRCO0FBQ3hCLG9CQUFJOGUsTUFBTTNRLFVBQU4sQ0FBaUJuYixFQUFqQixDQUFKLEVBQTBCO0FBQ3RCK2MsaUNBQWErTyxNQUFNM1EsVUFBTixDQUFpQm5iLEVBQWpCLENBQWI7QUFDQSwyQkFBTzhyQixNQUFNM1EsVUFBTixDQUFpQm5iLEVBQWpCLENBQVA7QUFDSDs7QUFFRDgrQjtBQUNBN2hCLG9CQUFJalEsSUFBSixFQUFVNDFCLFNBQVYsRUFBcUJ1USxXQUFyQjtBQUNBLG9CQUFNQyxZQUFZdG5CLE1BQU1nbkIsWUFBTixDQUFtQmxRLFNBQW5CLENBQWxCO0FBQ0Esb0JBQU1yNkIsUUFBUTZxQyxVQUFVN3hDLE9BQVYsQ0FBa0I0eEMsV0FBbEIsQ0FBZDtBQUNBNXFDLHdCQUFRLENBQUMsQ0FBVCxJQUFjNnFDLFVBQVUzbkMsTUFBVixDQUFpQmxELEtBQWpCLEVBQXdCLENBQXhCLENBQWQ7QUFDSDtBQUNKLFNBZEQ7QUFlSCxLOzsyQkFFRDhsQixjLDJCQUFlcmhCLEksRUFBTTh4QixJLEVBQU07QUFBQTs7QUFDdkIsWUFBSXhrQyxjQUFRNHBDLFVBQVIsSUFBc0I1cEMsY0FBUTBnQixTQUFsQyxFQUE2QztBQUN6QyxnQkFBTWhiLEtBQUssaUJBQVg7O0FBRUEsaUJBQUtnTixJQUFMLEdBQVlBLElBQVo7QUFDQSxnQkFBSTFTLGNBQVE0cEMsVUFBWixFQUF3QjtBQUNwQixvQkFBTW1QLHdCQUF3QixLQUFLSCxtQkFBTCxDQUF5QmxtQyxJQUF6QixFQUErQjh4QixJQUEvQixFQUFxQyxlQUFyQyxFQUFzRDkrQixFQUF0RCxDQUE5QjtBQUNBc2QsbUJBQUd0USxJQUFILEVBQVMsZUFBVCxFQUEwQnFtQyxxQkFBMUI7QUFDQSxxQkFBS1AsWUFBTCxDQUFrQkMsYUFBbEIsQ0FBZ0MxM0MsSUFBaEMsQ0FBcUNnNEMscUJBQXJDO0FBQ0g7QUFDRCxnQkFBSS80QyxjQUFRMGdCLFNBQVosRUFBdUI7QUFDbkIsb0JBQU1zNEIsdUJBQXVCLEtBQUtKLG1CQUFMLENBQXlCbG1DLElBQXpCLEVBQStCOHhCLElBQS9CLEVBQXFDLGNBQXJDLEVBQXFEOStCLEVBQXJELENBQTdCO0FBQ0FzZCxtQkFBR3RRLElBQUgsRUFBUyxjQUFULEVBQXlCc21DLG9CQUF6QjtBQUNBLHFCQUFLUixZQUFMLENBQWtCRSxZQUFsQixDQUErQjMzQyxJQUEvQixDQUFvQ2k0QyxvQkFBcEM7QUFDSDs7QUFFRGozQix1QkFBVyxZQUFNO0FBQ2Isb0JBQU1rM0Isa0JBQWtCOTlCLFdBQVc2RSxpQkFBaUJ0TixJQUFqQixFQUF1QixrQkFBdkIsQ0FBWCxLQUEwRCxDQUFsRjtBQUNBLG9CQUFNd21DLHFCQUFxQi85QixXQUFXNkUsaUJBQWlCdE4sSUFBakIsRUFBdUIscUJBQXZCLENBQVgsS0FBNkQsQ0FBeEY7QUFDQSxvQkFBTXlRLGlCQUFpQmhJLFdBQVc2RSxpQkFBaUJ0TixJQUFqQixFQUF1QixpQkFBdkIsQ0FBWCxLQUF5RCxDQUFoRjtBQUNBLG9CQUFNMFEsb0JBQW9CakksV0FBVzZFLGlCQUFpQnROLElBQWpCLEVBQXVCLG9CQUF2QixDQUFYLEtBQTRELENBQXRGO0FBQ0Esb0JBQU0yUSxPQUFPd3RCLEtBQUtDLEdBQUwsQ0FBU29JLHFCQUFxQkQsZUFBOUIsRUFBK0M3MUIsb0JBQW9CRCxjQUFuRSxDQUFiO0FBQ0Esb0JBQUlFLElBQUosRUFBVTtBQUNOLDJCQUFLeEMsVUFBTCxDQUFnQm5iLEVBQWhCLElBQXNCcWMsV0FBVyxZQUFNO0FBQ25DeWlCO0FBQ0gscUJBRnFCLEVBRW5CbmhCLE9BQU8sSUFBUCxHQUFjLEdBRkssQ0FBdEI7QUFHSDtBQUNKLGFBWEQsRUFXRyxFQVhIO0FBYUgsU0E1QkQsTUE0Qk87QUFDSG1oQjtBQUNIO0FBQ0osSzs7MkJBRUQyVSxrQixpQ0FBcUI7QUFDakIsYUFBS0MsYUFBTCxJQUFzQixLQUFLQSxhQUFMLEVBQXRCO0FBQ0EsYUFBS0MsWUFBTCxJQUFxQixLQUFLQSxZQUFMLEVBQXJCO0FBQ0gsSzs7MkJBRURDLGdCLDZCQUFpQjVtQyxJLEVBQU02YixLLEVBQU87QUFDMUJ6bkIsZUFBT0MsSUFBUCxDQUFZd25CLEtBQVosRUFBbUJ2bkIsT0FBbkIsQ0FBMkIsZUFBTztBQUM5QndKLHdCQUFZa0MsSUFBWixFQUFrQjZiLE1BQU1udEIsR0FBTixDQUFsQjtBQUNILFNBRkQ7QUFHSCxLOzsyQkFFRG9zQixXLHdCQUFZOWEsSSxFQUFNNm1DLFcsRUFBYTtBQUFBLFlBQ25CaHJCLEtBRG1CLEdBQ1QsS0FBS3RzQixLQURJLENBQ25Cc3NCLEtBRG1COztBQUUzQixZQUFJQSxLQUFKLEVBQVc7QUFDUCxpQkFBSytxQixnQkFBTCxDQUFzQjVtQyxJQUF0QixFQUE0QjZiLEtBQTVCO0FBQ0EsZ0JBQU0xbUIsWUFBWTB4QyxjQUFjLFFBQWQsR0FBeUIsT0FBM0M7QUFDQWhwQyxxQkFBU21DLElBQVQsRUFBZTZiLE1BQU0xbUIsU0FBTixDQUFmO0FBQ0g7O0FBRUQsWUFBTTJ4QyxPQUFPRCxjQUFjLEtBQUt0M0MsS0FBTCxDQUFXOHNCLFFBQXpCLEdBQW9DLEtBQUs5c0IsS0FBTCxDQUFXaXRCLE9BQTVEO0FBQ0FzcUIsYUFBSzltQyxJQUFMO0FBQ0gsSzs7MkJBRUQyakMsYywyQkFBZTNqQyxJLEVBQU02bUMsVyxFQUFhO0FBQUE7O0FBQzlCeDNCLG1CQUFXLFlBQU07QUFBQSxnQkFDTHdNLEtBREssR0FDSyxPQUFLdHNCLEtBRFYsQ0FDTHNzQixLQURLOztBQUViLGdCQUFJQSxLQUFKLEVBQVc7QUFDUCxvQkFBTTFtQixZQUFZMHhDLGNBQWMsY0FBZCxHQUErQixhQUFqRDtBQUNBaHBDLHlCQUFTbUMsSUFBVCxFQUFlNmIsTUFBTTFtQixTQUFOLENBQWY7QUFDSDs7QUFFRCxnQkFBTTJ4QyxPQUFPRCxjQUFjLE9BQUt0M0MsS0FBTCxDQUFXdzNDLFdBQXpCLEdBQXVDLE9BQUt4M0MsS0FBTCxDQUFXeWhCLFVBQS9EO0FBQ0E4MUIsaUJBQUs5bUMsSUFBTDtBQUNILFNBVEQsRUFTRyxFQVRIO0FBVUgsSzs7MkJBRUQ4akMsYSwwQkFBYzlqQyxJLEVBQU02bUMsVyxFQUFhO0FBQUEsWUFDckJockIsS0FEcUIsR0FDWCxLQUFLdHNCLEtBRE0sQ0FDckJzc0IsS0FEcUI7O0FBRTdCLFlBQUlBLEtBQUosRUFBVztBQUNQLGdCQUFNL3RCLGFBQWErNEMsY0FDZixDQUFDaHJCLE1BQU1DLE1BQVAsRUFBZUQsTUFBTUUsWUFBckIsQ0FEZSxHQUVmLENBQUNGLE1BQU14TixLQUFQLEVBQWN3TixNQUFNRyxXQUFwQixDQUZKO0FBR0FsdUIsdUJBQVd3RyxPQUFYLENBQW1CLHFCQUFhO0FBQzVCd0osNEJBQVlrQyxJQUFaLEVBQWtCN0ssU0FBbEI7QUFDSCxhQUZEO0FBR0g7O0FBRUQsWUFBTTJ4QyxPQUFPRCxjQUFjLEtBQUt0M0MsS0FBTCxDQUFXeTNDLFVBQXpCLEdBQXNDLEtBQUt6M0MsS0FBTCxDQUFXd2hCLFNBQTlEO0FBQ0ErMUIsYUFBSzltQyxJQUFMO0FBQ0gsSzs7MkJBRURpa0MsVSx1QkFBV2prQyxJLEVBQU07QUFBQSxZQUNMNmIsS0FESyxHQUNLLEtBQUt0c0IsS0FEVixDQUNMc3NCLEtBREs7O0FBRWIsWUFBSUEsS0FBSixFQUFXO0FBQ1AsaUJBQUsrcUIsZ0JBQUwsQ0FBc0I1bUMsSUFBdEIsRUFBNEI2YixLQUE1QjtBQUNBaGUscUJBQVNtQyxJQUFULEVBQWU2YixNQUFNL00sS0FBckI7QUFDSDs7QUFFRCxhQUFLdmYsS0FBTCxDQUFXc3hCLE1BQVgsQ0FBa0I3Z0IsSUFBbEI7QUFDSCxLOzsyQkFFRG9rQyxhLDBCQUFjcGtDLEksRUFBTTtBQUFBOztBQUNoQnFQLG1CQUFXLFlBQU07QUFBQSxnQkFDTHdNLEtBREssR0FDSyxPQUFLdHNCLEtBRFYsQ0FDTHNzQixLQURLOztBQUViLGdCQUFJQSxLQUFKLEVBQVc7QUFDUGhlLHlCQUFTbUMsSUFBVCxFQUFlNmIsTUFBTUksV0FBckI7QUFDSDtBQUNELG1CQUFLMXNCLEtBQUwsQ0FBV3V4QixTQUFYLENBQXFCOWdCLElBQXJCO0FBQ0gsU0FORCxFQU1HLEVBTkg7QUFPSCxLOzsyQkFFRGdrQixZLHlCQUFhaGtCLEksRUFBTTtBQUFBLFlBQ1A2YixLQURPLEdBQ0csS0FBS3RzQixLQURSLENBQ1Bzc0IsS0FETzs7QUFFZixZQUFJQSxLQUFKLEVBQVc7QUFDUCxhQUFDQSxNQUFNL00sS0FBUCxFQUFjK00sTUFBTUksV0FBcEIsRUFBaUMzbkIsT0FBakMsQ0FBeUMscUJBQWE7QUFDbER3Siw0QkFBWWtDLElBQVosRUFBa0I3SyxTQUFsQjtBQUNILGFBRkQ7QUFHSDs7QUFFRCxhQUFLNUYsS0FBTCxDQUFXcXhCLFFBQVgsQ0FBb0I1Z0IsSUFBcEI7QUFDSCxLOzsyQkFFRHBQLE0scUJBQVM7QUFDTDtBQURLLHFCQU9ELEtBQUtyQixLQVBKO0FBQUEsWUFFR3NzQixLQUZILFVBRUdBLEtBRkg7QUFBQSxZQUdEUSxRQUhDLFVBR0RBLFFBSEM7QUFBQSxZQUdTMnFCLFVBSFQsVUFHU0EsVUFIVDtBQUFBLFlBR3FCRCxXQUhyQixVQUdxQkEsV0FIckI7QUFBQSxZQUlEdnFCLE9BSkMsVUFJREEsT0FKQztBQUFBLFlBSVF4TCxVQUpSLFVBSVFBLFVBSlI7QUFBQSxZQUlvQkQsU0FKcEIsVUFJb0JBLFNBSnBCO0FBQUEsWUFLRDhQLE1BTEMsVUFLREEsTUFMQztBQUFBLFlBS09DLFNBTFAsVUFLT0EsU0FMUDtBQUFBLFlBS2tCRixRQUxsQixVQUtrQkEsUUFMbEI7QUFBQSxZQU1FdHBCLE1BTkY7QUFRTDs7QUFFQSxlQUNJLDhCQUFDLGdDQUFELGVBQWdCQSxNQUFoQjtBQUNJLHFCQUFTLEtBQUt3akIsV0FEbEI7QUFFSSx3QkFBWSxLQUFLNm9CLGNBRnJCO0FBR0ksdUJBQVcsS0FBS0csYUFIcEI7QUFJSSxvQkFBUSxLQUFLRyxVQUpqQjtBQUtJLHVCQUFXLEtBQUtHLGFBTHBCO0FBTUksc0JBQVUsS0FBS3BnQixZQU5uQjtBQU9JLDRCQUFnQixLQUFLM0MsY0FQekIsSUFESjtBQVVILEs7OztFQS9NcUNyd0IsZ0IsVUFDL0JDLFMsR0FBWTtBQUNmNHFCLFdBQU8zcUIsb0JBQVU2TyxTQUFWLENBQW9CLENBQUM3TyxvQkFBVUMsTUFBWCxFQUFtQkQsb0JBQVVqRixNQUE3QixDQUFwQixDQURRO0FBRWZvd0IsY0FBVW5yQixvQkFBVWhFLElBRkw7QUFHZjY1QyxpQkFBYTcxQyxvQkFBVWhFLElBSFI7QUFJZjg1QyxnQkFBWTkxQyxvQkFBVWhFLElBSlA7QUFLZnN2QixhQUFTdHJCLG9CQUFVaEUsSUFMSjtBQU1mOGpCLGdCQUFZOWYsb0JBQVVoRSxJQU5QO0FBT2Y2akIsZUFBVzdmLG9CQUFVaEUsSUFQTjtBQVFmMnpCLFlBQVEzdkIsb0JBQVVoRSxJQVJIO0FBU2Y0ekIsZUFBVzV2QixvQkFBVWhFLElBVE47QUFVZjB6QixjQUFVMXZCLG9CQUFVaEU7QUFWTCxDLFNBYVpvRSxZLEdBQWU7QUFDbEIrcUIsY0FBVXJoQixJQURRO0FBRWxCK3JDLGlCQUFhL3JDLElBRks7QUFHbEJnc0MsZ0JBQVloc0MsSUFITTtBQUlsQndoQixhQUFTeGhCLElBSlM7QUFLbEJnVyxnQkFBWWhXLElBTE07QUFNbEIrVixlQUFXL1YsSUFOTztBQU9sQjZsQixZQUFRN2xCLElBUFU7QUFRbEI4bEIsZUFBVzlsQixJQVJPO0FBU2xCNGxCLGNBQVU1bEI7QUFUUSxDO0FBZEw2cUMsWTtrQkFBQUEsWTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0QnJCOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLElBQU03cUMsT0FBTyxTQUFQQSxJQUFPLEdBQU0sQ0FBRSxDQUFyQjtJQUNRd0wsUSxHQUFheFosUyxDQUFid1osUTtJQUVhMmtCLE07OztBQW9CakIsb0JBQVk1N0IsS0FBWixFQUFtQjtBQUFBOztBQUFBLHFEQUNmLHNCQUFNQSxLQUFOLENBRGU7O0FBRWZyQyxtQkFBS3FLLE9BQUwsUUFBbUIsQ0FDZixhQURlLEVBQ0EsU0FEQSxFQUNXLFlBRFgsRUFFZixhQUZlLEVBRUEsU0FGQSxFQUVXLFlBRlgsQ0FBbkI7QUFGZTtBQU1sQjs7cUJBRURnbEIsVyx3QkFBWXZjLEksRUFBTTtBQUNkLFlBQUksS0FBS2luQyxPQUFULEVBQWtCO0FBQ2QsaUJBQUtycUIsVUFBTCxDQUFnQjVjLElBQWhCO0FBQ0g7O0FBRUQsYUFBS2tuQyxpQkFBTCxDQUF1QmxuQyxJQUF2QjtBQUNBLGFBQUttbkMsa0JBQUwsQ0FBd0JubkMsSUFBeEI7QUFDQSxhQUFLb25DLHFCQUFMLENBQTJCcG5DLElBQTNCOztBQUVBLGFBQUt6USxLQUFMLENBQVdndEIsV0FBWCxDQUF1QnZjLElBQXZCO0FBQ0gsSzs7cUJBRUR3YyxPLG9CQUFReGMsSSxFQUFNO0FBQ1YsYUFBS3FuQyw4QkFBTCxDQUFvQ3JuQyxJQUFwQzs7QUFFQSxhQUFLelEsS0FBTCxDQUFXaXRCLE9BQVgsQ0FBbUJ4YyxJQUFuQjtBQUNILEs7O3FCQUVEeWMsVSx1QkFBV3pjLEksRUFBTTtBQUNiLGFBQUtzbkMsbUJBQUwsQ0FBeUJ0bkMsSUFBekI7O0FBRUEsYUFBS3pRLEtBQUwsQ0FBV2t0QixVQUFYLENBQXNCemMsSUFBdEI7QUFDSCxLOztxQkFFRDBjLFcsd0JBQVkxYyxJLEVBQU07QUFDZCxhQUFLaW5DLE9BQUwsR0FBZSxJQUFmOztBQUVBLGFBQUtDLGlCQUFMLENBQXVCbG5DLElBQXZCO0FBQ0EsYUFBS21uQyxrQkFBTCxDQUF3Qm5uQyxJQUF4QjtBQUNBLGFBQUtxbkMsOEJBQUwsQ0FBb0NybkMsSUFBcEM7O0FBRUEsYUFBS3pRLEtBQUwsQ0FBV210QixXQUFYLENBQXVCMWMsSUFBdkI7QUFDSCxLOztxQkFFRDJjLE8sb0JBQVEzYyxJLEVBQU07QUFDVixhQUFLb25DLHFCQUFMLENBQTJCcG5DLElBQTNCOztBQUVBLGFBQUt6USxLQUFMLENBQVdvdEIsT0FBWCxDQUFtQjNjLElBQW5CO0FBQ0gsSzs7cUJBRUQ0YyxVLHVCQUFXNWMsSSxFQUFNO0FBQ2IsYUFBS2luQyxPQUFMLEdBQWUsS0FBZjs7QUFFQSxhQUFLSyxtQkFBTCxDQUF5QnRuQyxJQUF6Qjs7QUFFQSxhQUFLelEsS0FBTCxDQUFXcXRCLFVBQVgsQ0FBc0I1YyxJQUF0QjtBQUNILEs7O3FCQUVEa25DLGlCLDhCQUFrQmxuQyxJLEVBQU07QUFDcEIsYUFBS3VuQyxtQkFBTCxHQUEyQnZuQyxLQUFLekYsS0FBTCxDQUFXaXRDLGNBQXRDO0FBQ0EsYUFBS0MsZUFBTCxHQUF1QnpuQyxLQUFLekYsS0FBTCxDQUFXbXRDLFVBQWxDO0FBQ0EsYUFBS0MsV0FBTCxHQUFtQjNuQyxLQUFLekYsS0FBTCxDQUFXMk8sTUFBOUI7QUFDQSxhQUFLMCtCLGtCQUFMLEdBQTBCNW5DLEtBQUt6RixLQUFMLENBQVdzdEMsYUFBckM7QUFDQSxhQUFLQyxzQkFBTCxHQUE4QjluQyxLQUFLekYsS0FBTCxDQUFXd3RDLGlCQUF6QztBQUNILEs7O3FCQUVEWixrQiwrQkFBbUJubkMsSSxFQUFNO0FBQ3JCLGFBQUt3bkMsY0FBTCxHQUFzQmhoQyxTQUFTeEcsSUFBVCxFQUFlLGdCQUFmLENBQXRCO0FBQ0EsYUFBSzBuQyxVQUFMLEdBQWtCbGhDLFNBQVN4RyxJQUFULEVBQWUsWUFBZixDQUFsQjtBQUNBLGFBQUtrSixNQUFMLEdBQWNsSixLQUFLaEgsWUFBbkI7QUFDQSxhQUFLNnVDLGFBQUwsR0FBcUJyaEMsU0FBU3hHLElBQVQsRUFBZSxlQUFmLENBQXJCO0FBQ0EsYUFBSytuQyxpQkFBTCxHQUF5QnZoQyxTQUFTeEcsSUFBVCxFQUFlLG1CQUFmLENBQXpCO0FBQ0gsSzs7cUJBRURvbkMscUIsa0NBQXNCcG5DLEksRUFBTTtBQUN4QkEsYUFBS3pGLEtBQUwsQ0FBV2l0QyxjQUFYLEdBQTRCLEtBQTVCO0FBQ0F4bkMsYUFBS3pGLEtBQUwsQ0FBV210QyxVQUFYLEdBQXdCLEtBQXhCO0FBQ0ExbkMsYUFBS3pGLEtBQUwsQ0FBVzJPLE1BQVgsR0FBb0IsS0FBcEI7QUFDQWxKLGFBQUt6RixLQUFMLENBQVdzdEMsYUFBWCxHQUEyQixLQUEzQjtBQUNBN25DLGFBQUt6RixLQUFMLENBQVd3dEMsaUJBQVgsR0FBK0IsS0FBL0I7QUFDSCxLOztxQkFFRFYsOEIsMkNBQStCcm5DLEksRUFBTTtBQUNqQ0EsYUFBS3pGLEtBQUwsQ0FBV2l0QyxjQUFYLEdBQStCLEtBQUtBLGNBQXBDO0FBQ0F4bkMsYUFBS3pGLEtBQUwsQ0FBV210QyxVQUFYLEdBQTJCLEtBQUtBLFVBQWhDO0FBQ0ExbkMsYUFBS3pGLEtBQUwsQ0FBVzJPLE1BQVgsR0FBdUIsS0FBS0EsTUFBNUI7QUFDQWxKLGFBQUt6RixLQUFMLENBQVdzdEMsYUFBWCxHQUE4QixLQUFLQSxhQUFuQztBQUNBN25DLGFBQUt6RixLQUFMLENBQVd3dEMsaUJBQVgsR0FBa0MsS0FBS0EsaUJBQXZDO0FBQ0gsSzs7cUJBRURULG1CLGdDQUFvQnRuQyxJLEVBQU07QUFDdEJBLGFBQUt6RixLQUFMLENBQVdpdEMsY0FBWCxHQUE0QixLQUFLRCxtQkFBakM7QUFDQXZuQyxhQUFLekYsS0FBTCxDQUFXbXRDLFVBQVgsR0FBd0IsS0FBS0QsZUFBN0I7QUFDQXpuQyxhQUFLekYsS0FBTCxDQUFXMk8sTUFBWCxHQUFvQixLQUFLeStCLFdBQXpCO0FBQ0EzbkMsYUFBS3pGLEtBQUwsQ0FBV3N0QyxhQUFYLEdBQTJCLEtBQUtELGtCQUFoQztBQUNBNW5DLGFBQUt6RixLQUFMLENBQVd3dEMsaUJBQVgsR0FBK0IsS0FBS0Qsc0JBQXBDO0FBQ0gsSzs7cUJBRURsM0MsTSxxQkFBUztBQUFBLHFCQUM0QixLQUFLckIsS0FEakM7QUFBQSxZQUNHeWUsU0FESCxVQUNHQSxTQURIO0FBQUEsWUFDaUIxVyxNQURqQjs7QUFFTCxZQUFNMHdDLGVBQWVoNkIsYUFBYSxRQUFsQzs7QUFFQSxlQUNJLDhCQUFDLGlCQUFELGVBQWExVyxNQUFiO0FBQ0ksdUJBQVcwd0MsWUFEZjtBQUVJLHlCQUFhLEtBQUt6ckIsV0FGdEI7QUFHSSxxQkFBUyxLQUFLQyxPQUhsQjtBQUlJLHdCQUFZLEtBQUtDLFVBSnJCO0FBS0kseUJBQWEsS0FBS0MsV0FMdEI7QUFNSSxxQkFBUyxLQUFLQyxPQU5sQjtBQU9JLHdCQUFZLEtBQUtDLFVBUHJCLElBREo7QUFVSCxLOzs7RUFsSStCNXJCLGdCLFVBQ3pCQyxTLEdBQVk7QUFDZitjLGVBQVc5YyxvQkFBVTZPLFNBQVYsQ0FBb0IsQ0FBQzdPLG9CQUFVQyxNQUFYLEVBQW1CRCxvQkFBVWpGLE1BQTdCLENBQXBCLENBREk7QUFFZnN3QixpQkFBYXJyQixvQkFBVWhFLElBRlI7QUFHZnN2QixhQUFTdHJCLG9CQUFVaEUsSUFISjtBQUlmdXZCLGdCQUFZdnJCLG9CQUFVaEUsSUFKUDtBQUtmd3ZCLGlCQUFheHJCLG9CQUFVaEUsSUFMUjtBQU1meXZCLGFBQVN6ckIsb0JBQVVoRSxJQU5KO0FBT2YwdkIsZ0JBQVkxckIsb0JBQVVoRTtBQVBQLEMsU0FVWm9FLFksR0FBZTtBQUNsQmlyQixpQkFBYXZoQixJQURLO0FBRWxCd2hCLGFBQVN4aEIsSUFGUztBQUdsQnloQixnQkFBWXpoQixJQUhNO0FBSWxCMGhCLGlCQUFhMWhCLElBSks7QUFLbEIyaEIsYUFBUzNoQixJQUxTO0FBTWxCNGhCLGdCQUFZNWhCO0FBTk0sQztBQVhMbXdCLE07a0JBQUFBLE07Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUnJCOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7OztJQUtxQmdCLFk7Ozs7Ozs7Ozt5QkF5Q2pCdjdCLE0scUJBQVM7QUFBQSxpQkFDbUMsS0FBS3JCLEtBRHhDO0FBQUEsUUFDRzA0QyxnQkFESCxVQUNHQSxnQkFESDtBQUFBLFFBQ3dCM3dDLE1BRHhCOztBQUVMLFdBQU8sOEJBQUMsdUJBQUQsYUFBZSxNQUFLLGtCQUFwQixFQUF1QyxXQUFVLFVBQWpELEVBQTRELGVBQWUyd0MsZ0JBQTNFLElBQWlHM3dDLE1BQWpHLEVBQVA7QUFDSCxHOzs7RUE1Q3FDdEcsZ0IsVUFDL0J5USxhLEdBQWdCLE0sU0FFaEJ4USxTLEdBQVk7QUFDZjs7O0FBR0FzMUIsV0FBU3IxQixvQkFBVUUsSUFKSjtBQUtmOzs7QUFHQXUxQixpQkFBZXoxQixvQkFBVUUsSUFSVjtBQVNmOzs7QUFHQStHLFlBQVVqSCxvQkFBVUUsSUFaTDtBQWFmOzs7OztBQUtBbzFCLFlBQVV0MUIsb0JBQVVoRSxJQWxCTDtBQW1CZjs7O0FBR0FxVSxVQUFRclEsb0JBQVU4TyxJQXRCSDtBQXVCZjs7O0FBR0FqUCxZQUFVRyxvQkFBVThPLElBMUJMO0FBMkJmaW9DLG9CQUFrQi8yQyxvQkFBVUU7QUEzQmIsQyxTQThCWkUsWSxHQUFlO0FBQ2xCaTFCLFdBQVMsS0FEUztBQUVsQkksaUJBQWUsS0FGRztBQUdsQnh1QixZQUFVLEtBSFE7QUFJbEJxdUIsWUFBVSxvQkFBTSxDQUFFLENBSkE7QUFLbEJ5aEIsb0JBQWtCO0FBTEEsQztBQWpDTDliLFk7a0JBQUFBLFk7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1RyQjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7OztJQUVRcjJCLFUsR0FBZTFJLFMsQ0FBZjBJLFU7O0FBRVI7O0lBQ01veUMsYTs7O0FBa0VGLDJCQUFZMzRDLEtBQVosRUFBbUI7QUFBQTs7QUFBQSxxREFDZixzQkFBTUEsS0FBTixDQURlOztBQUdmLFlBQUk0SCxRQUFRLEVBQVo7QUFDQSxZQUFJLFdBQVc1SCxLQUFmLEVBQXNCO0FBQ2xCNEgsb0JBQVE1SCxNQUFNNEgsS0FBZDtBQUNILFNBRkQsTUFFTyxJQUFJLGtCQUFrQjVILEtBQXRCLEVBQTZCO0FBQ2hDNEgsb0JBQVE1SCxNQUFNK3BDLFlBQWQ7QUFDSDtBQUNELFlBQUksQ0FBQ2hyQyxNQUFNQyxPQUFOLENBQWM0SSxLQUFkLENBQUwsRUFBMkI7QUFDdkIsZ0JBQUlBLFVBQVUsSUFBVixJQUFrQkEsVUFBVW9ULFNBQWhDLEVBQTJDO0FBQ3ZDcFQsd0JBQVEsRUFBUjtBQUNILGFBRkQsTUFFTztBQUNIQSx3QkFBUSxDQUFDQSxLQUFELENBQVI7QUFDSDtBQUNKO0FBQ0QsY0FBS29CLEtBQUwsR0FBYTtBQUNUcEIsNkJBQVdBLEtBQVg7QUFEUyxTQUFiOztBQUlBLGNBQUtxdkIsUUFBTCxHQUFnQixNQUFLQSxRQUFMLENBQWN2cEIsSUFBZCxPQUFoQjtBQXBCZTtBQXFCbEI7OzRCQUVEM04sZSw4QkFBa0I7QUFDZCxlQUFPO0FBQ0gyM0IsdUJBQVcsSUFEUjtBQUVIVCxzQkFBVSxLQUFLQSxRQUZaO0FBR0hRLDJCQUFlLEtBQUt6dUIsS0FBTCxDQUFXcEIsS0FIdkI7QUFJSGdCLHNCQUFVLEtBQUs1SSxLQUFMLENBQVc0STtBQUpsQixTQUFQO0FBTUgsSzs7NEJBRUQvSCx5QixzQ0FBMEJDLFMsRUFBVztBQUNqQyxZQUFJLFdBQVdBLFNBQWYsRUFBMEI7QUFBQSxnQkFDakI4RyxLQURpQixHQUNSOUcsU0FEUSxDQUNqQjhHLEtBRGlCOztBQUV0QixnQkFBSSxDQUFDN0ksTUFBTUMsT0FBTixDQUFjNEksS0FBZCxDQUFMLEVBQTJCO0FBQ3ZCLG9CQUFJQSxVQUFVLElBQVYsSUFBa0JBLFVBQVVvVCxTQUFoQyxFQUEyQztBQUN2Q3BULDRCQUFRLEVBQVI7QUFDSCxpQkFGRCxNQUVPO0FBQ0hBLDRCQUFRLENBQUNBLEtBQUQsQ0FBUjtBQUNIO0FBQ0o7QUFDRCxpQkFBSzBYLFFBQUwsQ0FBYztBQUNWMVg7QUFEVSxhQUFkO0FBR0g7QUFDSixLOzs0QkFFRHF2QixRLHFCQUFTMmhCLFksRUFBY3ozQyxDLEVBQUc7QUFBQSxZQUNmeUcsS0FEZSxHQUNOLEtBQUtvQixLQURDLENBQ2ZwQixLQURlOztBQUV0QixZQUFNb0UsUUFBUXBFLE1BQU01QyxPQUFOLENBQWM0ekMsWUFBZCxDQUFkO0FBQ0EsWUFBTUMsb0JBQWNqeEMsS0FBZCxDQUFOOztBQUVBLFlBQUlvRSxVQUFVLENBQUMsQ0FBZixFQUFrQjtBQUNkNnNDLG9CQUFRLzVDLElBQVIsQ0FBYTg1QyxZQUFiO0FBQ0gsU0FGRCxNQUVPO0FBQ0hDLG9CQUFRM3BDLE1BQVIsQ0FBZWxELEtBQWYsRUFBc0IsQ0FBdEI7QUFDSDs7QUFFRCxZQUFJLEVBQUUsV0FBVyxLQUFLaE0sS0FBbEIsQ0FBSixFQUE4QjtBQUMxQixpQkFBS3NmLFFBQUwsQ0FBYyxFQUFDMVgsT0FBT2l4QyxPQUFSLEVBQWQ7QUFDSDtBQUNELGFBQUs3NEMsS0FBTCxDQUFXaTNCLFFBQVgsQ0FBb0I0aEIsT0FBcEIsRUFBNkIxM0MsQ0FBN0I7QUFDSCxLOzs0QkFFREUsTSxxQkFBUztBQUFBO0FBQUE7O0FBQUEscUJBQ3lELEtBQUtyQixLQUQ5RDtBQUFBLFlBQ0c0RixTQURILFVBQ0dBLFNBREg7QUFBQSxZQUNjb0YsS0FEZCxVQUNjQSxLQURkO0FBQUEsWUFDcUIvSyxNQURyQixVQUNxQkEsTUFEckI7QUFBQSxZQUM2QjJJLFFBRDdCLFVBQzZCQSxRQUQ3QjtBQUFBLFlBQ3VDa3dDLGFBRHZDLFVBQ3VDQSxhQUR2Qzs7QUFFTCxZQUFNL3dDLFNBQVN4QixXQUFXb3lDLGNBQWNqM0MsU0FBekIsRUFBb0MsS0FBSzFCLEtBQXpDLENBQWY7O0FBRUE7QUFDQSxZQUFJd0IsaUJBQUo7QUFDQSxZQUFJLEtBQUt4QixLQUFMLENBQVd3QixRQUFmLEVBQXlCO0FBQ3JCQSx1QkFBVyxLQUFLeEIsS0FBTCxDQUFXd0IsUUFBdEI7QUFDSCxTQUZELE1BRU87QUFDSEEsdUJBQVcsS0FBS3hCLEtBQUwsQ0FBVzJNLFVBQVgsQ0FBc0J6SixHQUF0QixDQUEwQixVQUFDQyxJQUFELEVBQU82SSxLQUFQLEVBQWlCO0FBQ2xELG9CQUFJK3NDLFNBQVM1MUMsSUFBYjtBQUNBLG9CQUFJLFFBQU9BLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBcEIsRUFBOEI7QUFDMUI0MUMsNkJBQVM7QUFDTHptQywrQkFBT25QLElBREY7QUFFTHlFLCtCQUFPekUsSUFGRjtBQUdMeUY7QUFISyxxQkFBVDtBQUtIO0FBQ0Qsb0JBQU1vdUIsVUFBVSxPQUFLaHVCLEtBQUwsQ0FBV3BCLEtBQVgsSUFBb0IsT0FBS29CLEtBQUwsQ0FBV3BCLEtBQVgsQ0FBaUI1QyxPQUFqQixDQUF5Qit6QyxPQUFPbnhDLEtBQWhDLElBQXlDLENBQUMsQ0FBOUU7O0FBRUEsdUJBQ0ksOEJBQUMsa0JBQUQsSUFBVSxLQUFLb0UsS0FBZjtBQUNJLDJCQUFPK3NDLE9BQU9ueEMsS0FEbEI7QUFFSSw2QkFBU292QixPQUZiO0FBR0ksOEJBQVVwdUIsWUFBWW13QyxPQUFPbndDLFFBSGpDO0FBSUksMkJBQU9td0MsT0FBT3ptQztBQUpsQixrQkFESjtBQVFILGFBbkJVLENBQVg7QUFvQkg7O0FBRUQsWUFBTTVDLE1BQU0seURBQ0p6UCxNQURJLHVCQUNxQixJQURyQixjQUVKQSxNQUZJLHVCQUVvQjY0QyxhQUZwQixJQUVzQyxJQUZ0QyxjQUdQbHpDLFNBSE8sSUFHSyxDQUFDLENBQUNBLFNBSFAsY0FJUmdELFFBSlEsR0FJUkEsUUFKUSxlQUFaOztBQU9BLGVBQU87QUFBQTtBQUFBLHlCQUFVYixNQUFWLElBQWtCLFdBQVcySCxHQUE3QixFQUFrQyxPQUFPMUUsS0FBekM7QUFBaUR4SjtBQUFqRCxTQUFQO0FBQ0gsSzs7O0VBMUt1QkMsZ0IsVUFFakJDLFMsR0FBWTtBQUNmekIsWUFBUTBCLG9CQUFVQyxNQURIO0FBRWZ2QixTQUFLc0Isb0JBQVVFLElBRkE7QUFHZjs7O0FBR0ErRCxlQUFXakUsb0JBQVVDLE1BTk47QUFPZjs7O0FBR0FvSixXQUFPckosb0JBQVVqRixNQVZGO0FBV2Y7OztBQUdBa00sY0FBVWpILG9CQUFVRSxJQWRMO0FBZWY7OztBQUdBOEssZ0JBQVloTCxvQkFBVXlRLE9BQVYsQ0FBa0J6USxvQkFBVWlNLEdBQTVCLENBbEJHO0FBbUJmOzs7QUFHQWhHLFdBQU9qRyxvQkFBVTZPLFNBQVYsQ0FBb0IsQ0FBQzdPLG9CQUFVa00sS0FBWCxFQUFrQmxNLG9CQUFVQyxNQUE1QixFQUFvQ0Qsb0JBQVV1SixNQUE5QyxDQUFwQixDQXRCUTtBQXVCZjs7O0FBR0E2K0Isa0JBQWNwb0Msb0JBQVU2TyxTQUFWLENBQW9CLENBQUM3TyxvQkFBVWtNLEtBQVgsRUFBa0JsTSxvQkFBVUMsTUFBNUIsRUFBb0NELG9CQUFVdUosTUFBOUMsQ0FBcEIsQ0ExQkM7QUEyQmY7OztBQUdBMUosY0FBVUcsb0JBQVV5USxPQUFWLENBQWtCelEsb0JBQVVHLE9BQTVCLENBOUJLO0FBK0JmOzs7OztBQUtBbTFCLGNBQVV0MUIsb0JBQVVoRSxJQXBDTDs7QUFzQ2Y7Ozs7O0FBS0FtN0MsbUJBQWVuM0Msb0JBQVVvRSxLQUFWLENBQWdCLENBQzNCLEtBRDJCLEVBRTNCLEtBRjJCLENBQWhCO0FBM0NBLEMsU0FpRFpoRSxZLEdBQWU7QUFDbEI0SyxnQkFBWSxFQURNO0FBRWxCc3FCLGNBQVUsb0JBQU0sQ0FDZixDQUhpQjtBQUlsQmgzQixZQUFRLE9BSlU7QUFLbEI2NEMsbUJBQWU7QUFMRyxDLFNBUWY5MkMsaUIsR0FBb0I7QUFDdkJpMUIsY0FBVXQxQixvQkFBVWhFLElBREc7QUFFdkIrNUIsZUFBVy8xQixvQkFBVUUsSUFGRTtBQUd2QjQxQixtQkFBZTkxQixvQkFBVWtNLEtBSEY7QUFJdkJqRixjQUFVakgsb0JBQVVFO0FBSkcsQztBQTNEekI4MkMsYTtrQkE2S1NoNUMseUJBQWVzQyxNQUFmLENBQXNCMDJDLGFBQXRCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZMZjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7OztJQUVRcHlDLFUsR0FBZTFJLFMsQ0FBZjBJLFU7O0FBRVI7Ozs7O0lBSU1teUIsVTs7O0FBcUZGLHdCQUFZMTRCLEtBQVosRUFBbUI7QUFBQTs7QUFBQSxxREFDZixzQkFBTUEsS0FBTixDQURlOztBQUVmLFlBQUk0SCxRQUFRLEVBQVo7QUFDQSxZQUFJLFdBQVc1SCxLQUFmLEVBQXNCO0FBQ2xCNEgsb0JBQVE1SCxNQUFNNEgsS0FBZDtBQUNILFNBRkQsTUFFTyxJQUFJLGtCQUFrQjVILEtBQXRCLEVBQTZCO0FBQ2hDNEgsb0JBQVE1SCxNQUFNK3BDLFlBQWQ7QUFDSDtBQUNELGNBQUsvZ0MsS0FBTCxHQUFhLEVBQUNwQixZQUFELEVBQWI7QUFDQSxjQUFLcXZCLFFBQUwsR0FBZ0IsTUFBS0EsUUFBTCxDQUFjdnBCLElBQWQsT0FBaEI7QUFUZTtBQVVsQjs7eUJBRUQzTixlLDhCQUFrQjtBQUNkLGVBQU87QUFDSDIzQix1QkFBVyxJQURSO0FBRUhpQixzQkFBVSxLQUFLMzRCLEtBQUwsQ0FBV3FTLEtBQVgsS0FBcUIsUUFGNUI7QUFHSDRrQixzQkFBVSxLQUFLQSxRQUhaO0FBSUhRLDJCQUFlLEtBQUt6dUIsS0FBTCxDQUFXcEIsS0FKdkI7QUFLSGdCLHNCQUFVLEtBQUs1SSxLQUFMLENBQVc0STtBQUxsQixTQUFQO0FBT0gsSzs7eUJBRUQvSCx5QixzQ0FBMEJDLFMsRUFBVztBQUFBLFlBQzVCOEcsS0FENEIsR0FDbkI5RyxTQURtQixDQUM1QjhHLEtBRDRCOztBQUVqQyxZQUFJLFdBQVc5RyxTQUFmLEVBQTBCO0FBQ3RCLGdCQUFJOEcsVUFBVW9ULFNBQWQsRUFBeUI7QUFDckJwVCx3QkFBUSxFQUFSO0FBQ0g7QUFDRCxpQkFBSzBYLFFBQUwsQ0FBYztBQUNWMVg7QUFEVSxhQUFkO0FBR0g7QUFDSixLOzt5QkFFRHF2QixRLHFCQUFTMmhCLFksRUFBY3ozQyxDLEVBQUc7QUFDdEIsWUFBSSxFQUFFLFdBQVcsS0FBS25CLEtBQWxCLENBQUosRUFBOEI7QUFDMUIsaUJBQUtzZixRQUFMLENBQWMsRUFBQzFYLE9BQU9neEMsWUFBUixFQUFkO0FBQ0g7QUFDRCxZQUFJQSxpQkFBaUIsS0FBSzV2QyxLQUFMLENBQVdwQixLQUFoQyxFQUF1QztBQUNuQyxpQkFBSzVILEtBQUwsQ0FBV2kzQixRQUFYLENBQW9CMmhCLFlBQXBCLEVBQWtDejNDLENBQWxDO0FBQ0g7QUFDSixLOzt5QkFFREUsTSxxQkFBUztBQUFBO0FBQUE7O0FBQUEscUJBQ2lFLEtBQUtyQixLQUR0RTtBQUFBLFlBQ0dLLEdBREgsVUFDR0EsR0FESDtBQUFBLFlBQ1F1RixTQURSLFVBQ1FBLFNBRFI7QUFBQSxZQUNtQnlNLEtBRG5CLFVBQ21CQSxLQURuQjtBQUFBLFlBQzBCMU0sSUFEMUIsVUFDMEJBLElBRDFCO0FBQUEsWUFDZ0NxRixLQURoQyxVQUNnQ0EsS0FEaEM7QUFBQSxZQUN1Qy9LLE1BRHZDLFVBQ3VDQSxNQUR2QztBQUFBLFlBQytDNjRDLGFBRC9DLFVBQytDQSxhQUQvQzs7QUFFTCxZQUFNL3dDLFNBQVN4QixXQUFXMUIsT0FBT0MsSUFBUCxDQUFZNHpCLFdBQVdoM0IsU0FBdkIsQ0FBWCxFQUE4QyxLQUFLMUIsS0FBbkQsQ0FBZjtBQUNBLFlBQU00SSxXQUFXLEtBQUs1SSxLQUFMLENBQVc0SSxRQUE1Qjs7QUFFQSxZQUFJdkksR0FBSixFQUFTO0FBQ0wwSCxtQkFBT2pDLEdBQVAsR0FBYSxLQUFiO0FBQ0g7O0FBRUQsWUFBSXRFLGlCQUFKO0FBQ0EsWUFBSSxLQUFLeEIsS0FBTCxDQUFXd0IsUUFBZixFQUF5QjtBQUNyQkEsdUJBQVcsS0FBS3hCLEtBQUwsQ0FBV3dCLFFBQXRCO0FBQ0gsU0FGRCxNQUVPO0FBQ0hBLHVCQUFXLEtBQUt4QixLQUFMLENBQVcyTSxVQUFYLENBQXNCekosR0FBdEIsQ0FBMEIsVUFBQ0MsSUFBRCxFQUFPNkksS0FBUCxFQUFpQjtBQUNsRCxvQkFBSStzQyxTQUFTNTFDLElBQWI7QUFDQSxvQkFBSSxRQUFPQSxJQUFQLHlDQUFPQSxJQUFQLE9BQWdCLFFBQXBCLEVBQThCO0FBQzFCNDFDLDZCQUFTO0FBQ0x6bUMsK0JBQU9uUCxJQURGO0FBRUx5RSwrQkFBT3pFLElBRkY7QUFHTHlGO0FBSEsscUJBQVQ7QUFLSDtBQUNELG9CQUFNb3VCLFVBQVUsT0FBS2h1QixLQUFMLENBQVdwQixLQUFYLEtBQXFCbXhDLE9BQU9ueEMsS0FBNUM7QUFDQSx1QkFBUSw4QkFBQyxlQUFEO0FBQ0oseUJBQUtvRSxLQUREO0FBRUosOEJBQVlBLFVBQVUsQ0FBVixJQUFlLENBQUMsT0FBS2hELEtBQUwsQ0FBV3BCLEtBQTVCLElBQXNDb3ZCLE9BQXZDLEdBQWtELENBQWxELEdBQXNELENBQUMsQ0FGN0Q7QUFHSiwyQkFBTytoQixPQUFPbnhDLEtBSFY7QUFJSiw2QkFBU292QixPQUpMO0FBS0osMkJBQU8raEIsT0FBT3ptQyxLQUxWO0FBTUosOEJBQVUxSixZQUFZbXdDLE9BQU9ud0M7QUFOekIsa0JBQVI7QUFRSCxhQWxCVSxDQUFYO0FBbUJIOztBQUVELFlBQU1vd0MsZ0JBQWdCM21DLFVBQVUsUUFBaEM7O0FBRUEsWUFBTTNDLE1BQU0seURBQ0p6UCxNQURJLG9CQUNrQixJQURsQixjQUVKQSxNQUZJLG9CQUVpQjY0QyxhQUZqQixJQUVtQyxDQUFDRSxhQUZwQyxjQUdKLzRDLE1BSEkscUJBR21CKzRDLGFBSG5CLGNBSUovNEMsTUFKSSxxQkFJa0IwRixJQUpsQixJQUkyQnF6QyxhQUozQixjQUtQcHpDLFNBTE8sSUFLSyxDQUFDLENBQUNBLFNBTFAsY0FNUmdELFFBTlEsR0FNUkEsUUFOUSxlQUFaOztBQVNBLGVBQU87QUFBQTtBQUFBLHlCQUFTYixNQUFULElBQWlCLGlCQUFlYSxRQUFoQyxFQUEwQyxNQUFLLFlBQS9DLEVBQTRELFdBQVc4RyxHQUF2RSxFQUE0RSxPQUFPMUUsS0FBbkY7QUFBMkZ4SjtBQUEzRixTQUFQO0FBQ0gsSzs7O0VBOUtvQkMsZ0IsVUFFZEMsUyxHQUFZO0FBQ2Y7OztBQUdBekIsWUFBUTBCLG9CQUFVQyxNQUpIO0FBS2Z2QixTQUFLc0Isb0JBQVVFLElBTEE7QUFNZjs7O0FBR0ErRCxlQUFXakUsb0JBQVVDLE1BVE47QUFVZjs7O0FBR0FvSixXQUFPckosb0JBQVVqRixNQWJGO0FBY2Y7OztBQUdBNmMsVUFBTTVYLG9CQUFVQyxNQWpCRDtBQWtCZjs7O0FBR0FnRyxXQUFPakcsb0JBQVU2TyxTQUFWLENBQW9CLENBQUM3TyxvQkFBVUMsTUFBWCxFQUFtQkQsb0JBQVV1SixNQUE3QixFQUFxQ3ZKLG9CQUFVRSxJQUEvQyxDQUFwQixDQXJCUTtBQXNCZjs7O0FBR0Frb0Msa0JBQWNwb0Msb0JBQVU2TyxTQUFWLENBQW9CLENBQUM3TyxvQkFBVUMsTUFBWCxFQUFtQkQsb0JBQVV1SixNQUE3QixFQUFxQ3ZKLG9CQUFVRSxJQUEvQyxDQUFwQixDQXpCQztBQTBCZjs7Ozs7QUFLQW8xQixjQUFVdDFCLG9CQUFVaEUsSUEvQkw7QUFnQ2Y7OztBQUdBaUwsY0FBVWpILG9CQUFVRSxJQW5DTDtBQW9DZjs7OztBQUlBd1EsV0FBTzFRLG9CQUFVb0UsS0FBVixDQUFnQixDQUFDLFFBQUQsQ0FBaEIsQ0F4Q1E7QUF5Q2Y7Ozs7QUFJQUosVUFBTWhFLG9CQUFVb0UsS0FBVixDQUFnQixDQUFDLE9BQUQsRUFBVSxRQUFWLEVBQW9CLE9BQXBCLENBQWhCLENBN0NTO0FBOENmOzs7QUFHQTRHLGdCQUFZaEwsb0JBQVV5USxPQUFWLENBQWtCelEsb0JBQVVpTSxHQUE1QixDQWpERztBQWtEZjs7O0FBR0FwTSxjQUFVRyxvQkFBVTZPLFNBQVYsQ0FBb0IsQ0FBQzdPLG9CQUFVeVEsT0FBVixDQUFrQnpRLG9CQUFVRyxPQUE1QixDQUFELEVBQXVDSCxvQkFBVUcsT0FBakQsQ0FBcEIsQ0FyREs7O0FBdURmOzs7OztBQUtBZzNDLG1CQUFlbjNDLG9CQUFVb0UsS0FBVixDQUFnQixDQUMzQixLQUQyQixFQUUzQixLQUYyQixDQUFoQjtBQTVEQSxDLFNBa0VaaEUsWSxHQUFlO0FBQ2xCNEssZ0JBQVksRUFETTtBQUVsQmhILFVBQU0sUUFGWTtBQUdsQnN4QixjQUFVLG9CQUFNLENBQ2YsQ0FKaUI7QUFLbEJoM0IsWUFBUSxPQUxVO0FBTWxCNjRDLG1CQUFlO0FBTkcsQyxTQVNmOTJDLGlCLEdBQW9CO0FBQ3ZCaTFCLGNBQVV0MUIsb0JBQVVoRSxJQURHO0FBRXZCKzVCLGVBQVcvMUIsb0JBQVVFLElBRkU7QUFHdkI4MkIsY0FBVWgzQixvQkFBVUUsSUFIRztBQUl2QjQxQixtQkFBZTkxQixvQkFBVTZPLFNBQVYsQ0FBb0IsQ0FBQzdPLG9CQUFVQyxNQUFYLEVBQW1CRCxvQkFBVXVKLE1BQTdCLEVBQXFDdkosb0JBQVVFLElBQS9DLENBQXBCLENBSlE7QUFLdkIrRyxjQUFVakgsb0JBQVVFO0FBTEcsQztBQTdFekI2MkIsVTtrQkFpTFMvNEIseUJBQWVzQyxNQUFmLENBQXNCeTJCLFVBQXRCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUxmOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7SUFLcUJtRSxTOzs7Ozs7Ozs7c0JBa0NqQng3QixNLHFCQUFTO0FBQ0wsV0FBTyw4QkFBQyx1QkFBRCxhQUFlLE1BQUssZUFBcEIsRUFBb0MsV0FBVSxPQUE5QyxJQUEwRCxLQUFLckIsS0FBL0QsRUFBUDtBQUNILEc7OztFQXBDa0N5QixnQixVQUM1QnlRLGEsR0FBZ0IsTSxTQUVoQnhRLFMsR0FBWTtBQUNmOzs7QUFHQXMxQixXQUFTcjFCLG9CQUFVRSxJQUpKO0FBS2Y7OztBQUdBK0csWUFBVWpILG9CQUFVRSxJQVJMO0FBU2Y7Ozs7O0FBS0FvMUIsWUFBVXQxQixvQkFBVWhFLElBZEw7QUFlZjs7O0FBR0FxVSxVQUFRclEsb0JBQVU4TyxJQWxCSDtBQW1CZjs7O0FBR0FqUCxZQUFVRyxvQkFBVThPO0FBdEJMLEMsU0F5QloxTyxZLEdBQWU7QUFDbEJpMUIsV0FBUyxLQURTO0FBRWxCcHVCLFlBQVUsS0FGUTtBQUdsQnF1QixZQUFVLG9CQUFNLENBQUU7QUFIQSxDO0FBNUJMNEYsUztrQkFBQUEsUzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNUckI7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7OztJQUlxQnBtQixLOzs7Ozs7Ozs7b0JBaUJqQnBWLE0scUJBQVM7QUFBQTs7QUFBQSxxQkFDK0QsS0FBS3JCLEtBRHBFO0FBQUEsWUFDR3FDLElBREgsVUFDR0EsSUFESDtBQUFBLFlBQ1N1RCxTQURULFVBQ1NBLFNBRFQ7QUFBQSxZQUNvQjBNLEtBRHBCLFVBQ29CQSxLQURwQjtBQUFBLFlBQzJCOVEsUUFEM0IsVUFDMkJBLFFBRDNCO0FBQUEsWUFDcUM0RyxVQURyQyxVQUNxQ0EsVUFEckM7QUFBQSxZQUNvREwsTUFEcEQ7O0FBQUEsWUFFRzlILE1BRkgsR0FFY29DLEtBQUtyQyxLQUZuQixDQUVHQyxNQUZIOzs7QUFJTCxZQUFNNEssZUFBZSx5Q0FDYjVLLE1BRGEseUJBQ2MsSUFEZCxNQUVoQjJGLFNBRmdCLElBRUosQ0FBQyxDQUFDQSxTQUZFLE9BQXJCOztBQUtBLFlBQU0waEIsY0FBYzlsQixTQUFTMEIsR0FBVCxDQUFhLGlCQUFTO0FBQUE7O0FBQUEsZ0JBQzlCMEMsU0FEOEIsR0FDaEJ5RSxNQUFNckssS0FEVSxDQUM5QjRGLFNBRDhCOztBQUV0QyxnQkFBTXF6QyxvQkFBb0IsMkNBQ2xCaDVDLE1BRGtCLHdCQUNRLElBRFIsT0FFckIyRixTQUZxQixJQUVULENBQUMsQ0FBQ0EsU0FGTyxRQUExQjs7QUFLQSxtQkFBTyx5QkFBYXlFLEtBQWIsRUFBb0I7QUFDdkJqQyxzQ0FEdUI7QUFFdkJ4QywyQkFBV3F6QztBQUZZLGFBQXBCLENBQVA7QUFJSCxTQVhtQixDQUFwQjs7QUFhQSxnQkFDSTtBQUFDLDBCQUFEO0FBQUE7QUFDSSxxQkFBSSxrQkFEUjtBQUVJLDJCQUFXcHVDLFlBRmY7QUFHSSxzQ0FISjtBQUlJLHNCQUFNeEksSUFKVjtBQUtJLDRCQUFZK0Y7QUFMaEIsZUFNUUwsTUFOUjtBQU1pQnVLO0FBTmpCLFNBREosU0FRT2dWLFdBUlA7QUFVSCxLOzs7RUFqRDhCN2xCLGdCLFVBQ3hCeVEsYSxHQUFnQixPLFNBRWhCeFEsUyxHQUFZO0FBQ2ZXLFVBQU1WLG9CQUFVakYsTUFERDtBQUVma0osZUFBV2pFLG9CQUFVQyxNQUZOO0FBR2Y7OztBQUdBMFEsV0FBTzNRLG9CQUFVOE8sSUFORjtBQU9mOzs7QUFHQWpQLGNBQVVHLG9CQUFVOE8sSUFWTDtBQVdmckksZ0JBQVl6RyxvQkFBVW9FLEtBQVYsQ0FBZ0IsQ0FBQyxRQUFELEVBQVcsT0FBWCxDQUFoQjtBQVhHLEM7QUFIRjBRLEs7a0JBQUFBLEs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVHJCOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7O0lBSXFCcW1CLE87Ozs7Ozs7OztzQkFRakJ6N0IsTSxxQkFBUztBQUFBOztBQUFBLHFCQUNrQyxLQUFLckIsS0FEdkM7QUFBQSxZQUNHcUMsSUFESCxVQUNHQSxJQURIO0FBQUEsWUFDU3VELFNBRFQsVUFDU0EsU0FEVDtBQUFBLFlBQ3VCbUMsTUFEdkI7O0FBQUEsWUFFRzlILE1BRkgsR0FFY29DLEtBQUtyQyxLQUZuQixDQUVHQyxNQUZIOzs7QUFJTCxZQUFNNEssZUFBZSx5Q0FDYjVLLE1BRGEscUJBQ1UsSUFEVixNQUVoQjJGLFNBRmdCLElBRUosQ0FBQyxDQUFDQSxTQUZFLE9BQXJCOztBQUtBLGVBQ0ksK0NBQUksTUFBSyxXQUFULEVBQXFCLFdBQVdpRixZQUFoQyxJQUFrRDlDLE1BQWxELEVBREo7QUFHSCxLOzs7RUFwQmdDdEcsZ0IsVUFDMUJ5USxhLEdBQWdCLFMsU0FFaEJ4USxTLEdBQVk7QUFDZlcsVUFBTVYsb0JBQVVqRixNQUREO0FBRWZrSixlQUFXakUsb0JBQVVDO0FBRk4sQztBQUhGazdCLE87a0JBQUFBLE87Ozs7Ozs7Ozs7Ozs7Ozs7a0JDdUhHek4sTTs7QUEvSHhCOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztJQUVRcm5CLE8sR0FBWXJLLFUsQ0FBWnFLLE87SUFDQTdGLGUsR0FBb0J4Qyx3QixDQUFwQndDLGU7O0FBQ1IsSUFBTWlsQixPQUFPem5CLHlCQUFlc0MsTUFBZixDQUFzQmkzQyxjQUF0QixDQUFiOztBQUVBLElBQUlDLHFCQUFKOztJQUVNQyxXOzs7QUFvQkYseUJBQVlwNUMsS0FBWixFQUFtQjtBQUFBOztBQUFBLHFEQUNmLHNCQUFNQSxLQUFOLENBRGU7O0FBR2YsY0FBS2dKLEtBQUwsR0FBYTtBQUNUdVYscUJBQVM7QUFEQSxTQUFiOztBQUlBdlcsdUJBQWMsQ0FBQyxvQkFBRCxFQUF1QixtQkFBdkIsRUFBNEMsaUJBQTVDLEVBQStELFlBQS9ELENBQWQ7QUFQZTtBQVFsQjs7MEJBRURxeEMsVSx1QkFBV3A4QixHLEVBQUs7QUFDWixhQUFLNFksT0FBTCxHQUFlNVksR0FBZjtBQUNILEs7OzBCQUVEeUMsSyxvQkFBUTtBQUNKLGFBQUtKLFFBQUwsQ0FBYztBQUNWZixxQkFBUztBQURDLFNBQWQ7QUFHQTQ2Qix1QkFBZSxJQUFmO0FBQ0gsSzs7MEJBRURHLGtCLCtCQUFtQmx3QixXLEVBQWFqb0IsQyxFQUFjO0FBQzFDLFlBQU1vNEMsbUJBQW1CbndCLGdCQUFnQixVQUFoQixJQUNyQixLQUFLeEIsVUFBTCxDQUFnQjJCLElBQWhCLENBQXFCO0FBQUEsbUJBQVE5WSxLQUFLK0csUUFBTCxDQUFjclcsRUFBRTJQLE1BQWhCLENBQVI7QUFBQSxTQUFyQixDQURKO0FBRUEsWUFBSSxDQUFDeW9DLGdCQUFMLEVBQXVCO0FBQ25CLGlCQUFLNzVCLEtBQUw7QUFEbUIsZ0JBRVg4NUIsWUFGVyxHQUVNLEtBQUt4NUMsS0FGWCxDQUVYdzVDLFlBRlc7O0FBR25CLGdCQUFJQSxnQkFBZ0JBLGFBQWE5MkIsY0FBakMsRUFBaUQ7QUFBQSxrREFObkIzYSxNQU1tQjtBQU5uQkEsMEJBTW1CO0FBQUE7O0FBQzdDeXhDLDZCQUFhOTJCLGNBQWIsc0JBQTRCMEcsV0FBNUIsRUFBeUNqb0IsQ0FBekMsU0FBK0M0RyxNQUEvQztBQUNIO0FBQ0o7QUFDSixLOzswQkFFRDB4QyxpQixnQ0FBb0I7QUFDaEIsYUFBSzd4QixVQUFMLEdBQWtCLEtBQUtpTyxPQUFMLENBQWE3UyxXQUFiLEdBQTJCZixVQUEzQixHQUF3Q2UsV0FBeEMsR0FBc0Q0RSxVQUF4RTtBQURnQixZQUVSNHhCLFlBRlEsR0FFUyxLQUFLeDVDLEtBRmQsQ0FFUnc1QyxZQUZROztBQUdoQixZQUFJQSxnQkFBZ0JBLGFBQWF6NUIsTUFBakMsRUFBeUM7QUFDckN5NUIseUJBQWF6NUIsTUFBYjtBQUNIO0FBRUosSzs7MEJBRURuVyxlLDhCQUF5QjtBQUFBOztBQUNyQixhQUFLOFYsS0FBTDs7QUFFQSxhQUFLMWYsS0FBTCxDQUFXcXFCLFdBQVgsSUFBMEIsZUFBS3JxQixLQUFMLEVBQVdxcUIsV0FBWCx5QkFBMUI7QUFDSCxLOzswQkFFRGhwQixNLHFCQUFTO0FBQUE7O0FBQUEsc0JBQ2tHLEtBQUtyQixLQUR2RztBQUFBLFlBQ0c0RixTQURILFdBQ0dBLFNBREg7QUFBQSxZQUNjaW1CLGNBRGQsV0FDY0EsY0FEZDtBQUFBLFlBQzhCL2EsTUFEOUIsV0FDOEJBLE1BRDlCO0FBQUEsWUFDc0NsQyxLQUR0QyxXQUNzQ0EsS0FEdEM7QUFBQSxZQUM2Q3NVLE1BRDdDLFdBQzZDQSxNQUQ3QztBQUFBLFlBQ3FEaEQsVUFEckQsV0FDcURBLFVBRHJEO0FBQUEsMkNBQ2lFczVCLFlBRGpFO0FBQUEsWUFDaUVBLFlBRGpFLHdDQUNnRixFQURoRjtBQUFBLFlBQ3VGenhDLE1BRHZGOztBQUVMLFlBQU1tOUIsZUFBZS9pQyxnQkFBZ0IsS0FBS25DLEtBQXJCLENBQXJCO0FBRkssWUFHR0MsTUFISCxHQUdjaWxDLFlBSGQsQ0FHR2psQyxNQUhIO0FBQUEsWUFJR3NlLE9BSkgsR0FJZSxLQUFLdlYsS0FKcEIsQ0FJR3VWLE9BSkg7OztBQU1MLFlBQU1tN0IsK0JBQ0N4VSxZQURELEVBRUNzVSxZQUZEO0FBR0Yxb0MsMEJBSEUsRUFHTWxDLFlBSE4sRUFHYXNVLGNBSGIsRUFHcUJoRCxzQkFIckIsRUFHaUMzQixnQkFIakM7QUFJRm1FLDRCQUFnQixLQUFLNDJCLGtCQUpuQjtBQUtGdjVCLG9CQUFRLEtBQUswNUIsaUJBTFg7QUFNRng4QixpQkFBSyxLQUFLbzhCO0FBTlIsVUFBTjtBQVFBLFlBQU1NLHlCQUNDelUsWUFERDtBQUVGOWIseUJBQWE7QUFGWCxXQUdDcmhCLE1BSEQ7QUFJRm5DLHVCQUFXLHlDQUNIM0YsTUFERyxnQkFDZSxJQURmLE1BRU4yRixTQUZNLElBRU0sQ0FBQyxDQUFDQSxTQUZSLE9BSlQ7QUFRRmltQiw0QkFBZ0IsMkNBQ1I1ckIsTUFEUSxnQkFDVSxJQURWLE9BRVg0ckIsY0FGVyxJQUVNLENBQUMsQ0FBQ0EsY0FGUixRQVJkO0FBWUZ4Qix5QkFBYSxLQUFLemdCO0FBWmhCLFVBQU47O0FBZUE4dkMsd0JBQWdCcjVDLEdBQWhCLEdBQXNCLEtBQXRCOztBQUVBLGVBQ0k7QUFBQyw2QkFBRDtBQUFhcTVDLDJCQUFiO0FBQ0ksMENBQUMsSUFBRCxFQUFVQyxTQUFWO0FBREosU0FESjtBQUtILEs7OztFQXhHcUJsNEMsZ0IsVUFDZkMsUyxHQUFZO0FBQ2ZrRSxlQUFXakUsb0JBQVVDLE1BRE47QUFFZmlxQixvQkFBZ0JscUIsb0JBQVVDLE1BRlg7QUFHZmtQLFlBQVFuUCxvQkFBVWlNLEdBSEg7QUFJZmdCLFdBQU9qTixvQkFBVUMsTUFKRjtBQUtmc2hCLFlBQVF2aEIsb0JBQVVrTSxLQUxIO0FBTWYyckMsa0JBQWM3M0Msb0JBQVVqRixNQU5UO0FBT2Z3akIsZ0JBQVl2ZSxvQkFBVWhFLElBUFA7QUFRZndxQixVQUFNeG1CLG9CQUFVb0UsS0FBVixDQUFnQixDQUFDLFFBQUQsRUFBVyxPQUFYLENBQWhCLENBUlM7QUFTZmdhLFlBQVFwZSxvQkFBVWhFLElBVEg7QUFVZjBzQixpQkFBYTFvQixvQkFBVWhFO0FBVlIsQyxTQWFab0UsWSxHQUFlO0FBQ2xCOUIsWUFBUSxPQURVO0FBRWxCMk8sV0FBTyxPQUZXO0FBR2xCdVosVUFBTTtBQUhZLEM7O0FBNkYxQjs7Ozs7O0FBM0dNaXhCLFc7QUFnSFMsU0FBUy9wQixNQUFULENBQWdCcnZCLEtBQWhCLEVBQXVCO0FBQ2xDLFFBQUltNUMsWUFBSixFQUFrQjtBQUNkQSxxQkFBYVMsT0FBYjtBQUNIOztBQUVEOztBQUxrQyxRQU0xQjE1QixVQU4wQixHQU1BbGdCLEtBTkEsQ0FNMUJrZ0IsVUFOMEI7QUFBQSxRQU1YblksTUFOVyw0QkFNQS9ILEtBTkE7QUFPbEM7O0FBRUEsUUFBTTY1QyxNQUFNN29DLFNBQVNzRyxhQUFULENBQXVCLEtBQXZCLENBQVo7QUFDQXRHLGFBQVNnSCxJQUFULENBQWM2QixXQUFkLENBQTBCZ2dDLEdBQTFCOztBQUVBLFFBQU1DLGFBQWEsU0FBYkEsVUFBYSxHQUFNO0FBQ3JCLDhDQUF1QkQsR0FBdkI7QUFDQTdvQyxpQkFBU2dILElBQVQsQ0FBY2lDLFdBQWQsQ0FBMEI0L0IsR0FBMUI7O0FBRUEzNUIsc0JBQWNBLFlBQWQ7QUFDSCxLQUxEOztBQU9BLFFBQU02NUIsYUFBYXA2Qyx5QkFBZW1ELFVBQWYsRUFBbkI7O0FBRUEsUUFBSW8yQyxhQUFKO0FBQ0EsMEJBQ0k7QUFBQyxnQ0FBRDtBQUFvQmEsa0JBQXBCO0FBQ0ksc0NBQUMsV0FBRCxhQUFhLEtBQUssbUJBQU87QUFDckJiLHVCQUFPajhCLElBQVA7QUFDSCxhQUZELEVBRUcsWUFBWTY4QixVQUZmLElBRStCL3hDLE1BRi9CO0FBREosS0FESixFQU1NOHhDLEdBTk47O0FBU0FWLG1CQUFlO0FBQ1hTLGlCQUFTLG1CQUFNO0FBQ1gsZ0JBQUlWLElBQUosRUFBVTtBQUNOQSxxQkFBS3g1QixLQUFMO0FBQ0g7QUFDSjtBQUxVLEtBQWY7O0FBUUEsV0FBT3k1QixZQUFQO0FBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdktEOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLFNBQVNhLFdBQVQsQ0FBcUJyMEMsSUFBckIsRUFBMkI7QUFDdkIsV0FBUTtBQUNKczBDLGVBQU8sT0FESDtBQUVKQyxnQkFBUSxJQUZKO0FBR0pDLGVBQU87QUFISCxLQUFELENBSUp4MEMsSUFKSSxDQUFQO0FBS0g7O0FBRUQ7SUFDcUJzMUIsTTs7Ozs7Ozs7Ozs7O2dKQW9FakJtZixTLEdBQVksVUFBQ2o1QyxDQUFELEVBQU87QUFDZixrQkFBS2s1QyxNQUFMLENBQVlDLElBQVo7O0FBRUEsZ0JBQUksTUFBS3Q2QyxLQUFMLENBQVdvNkMsU0FBZixFQUEwQjtBQUN0QixzQkFBS3A2QyxLQUFMLENBQVdvNkMsU0FBWCxDQUFxQmo1QyxDQUFyQjtBQUNIO0FBQ0osUyxRQUVEbzVDLGdCLEdBQW1CLFVBQUNGLE1BQUQsRUFBWTtBQUMzQixrQkFBS0EsTUFBTCxHQUFjQSxNQUFkO0FBQ0gsUzs7O3FCQUVEaDVDLE0scUJBQVM7QUFBQTs7QUFBQSxxQkFDNkgsS0FBS3JCLEtBRGxJO0FBQUEsWUFDR0MsTUFESCxVQUNHQSxNQURIO0FBQUEsWUFDVzJGLFNBRFgsVUFDV0EsU0FEWDtBQUFBLFlBQ3NCRixJQUR0QixVQUNzQkEsSUFEdEI7QUFBQSxZQUM0QkMsSUFENUIsVUFDNEJBLElBRDVCO0FBQUEsWUFDa0M2MEMsUUFEbEMsVUFDa0NBLFFBRGxDO0FBQUEsWUFDNENudUMsT0FENUMsVUFDNENBLE9BRDVDO0FBQUEsWUFDcUQrSixJQURyRCxVQUNxREEsSUFEckQ7QUFBQSxZQUMyRGhXLE9BRDNELFVBQzJEQSxPQUQzRDtBQUFBLFlBQ29FazdCLEtBRHBFLFVBQ29FQSxLQURwRTtBQUFBLFlBQzJFN3dCLFNBRDNFLFVBQzJFQSxTQUQzRTtBQUFBLFlBQ3NGZ3dDLFFBRHRGLFVBQ3NGQSxRQUR0RjtBQUFBLFlBQ2dHajVDLFFBRGhHLFVBQ2dHQSxRQURoRztBQUFBLFlBQzBHbkIsR0FEMUcsVUFDMEdBLEdBRDFHO0FBQUEsWUFDa0gwSCxNQURsSDs7QUFFTCxZQUFNMnlDLFlBQVksQ0FBQyxPQUFELEVBQVUsTUFBVixFQUFrQjExQyxPQUFsQixDQUEwQnMyQixLQUExQixLQUFvQyxDQUFwQyxHQUF3Q0EsS0FBeEMsR0FBZ0QsTUFBbEU7O0FBRUEsWUFBTXFmLFNBQVMseURBQ1AxNkMsTUFETyxZQUNPLElBRFAsbUJBRVBBLE1BRk8sR0FFRTBGLElBRkYsSUFFV0EsSUFGWCxjQUdQMUYsTUFITyxZQUdNeUYsSUFITixJQUdlQSxRQUFRLENBQUM0MUIsS0FIeEIsY0FJUHI3QixNQUpPLGlCQUlZbVcsSUFKWixjQUtQblcsTUFMTyxvQkFLZUcsT0FMZixjQU1QSCxNQU5PLG9CQU1lb00sT0FOZixjQU9QcE0sTUFQTyxrQkFPYXE3QixLQVBiLGNBUVByN0IsTUFSTyxZQVFNeTZDLFNBUk4sSUFRb0JwZixLQVJwQixjQVNWMTFCLFNBVFUsSUFTRUEsU0FURixlQUFmOztBQVlBLFlBQU1tdUMsUUFBUXp5QyxnQkFBU3l5QyxLQUFULENBQWV2eUMsUUFBZixDQUFkO0FBQ0EsWUFBTW81QyxpQkFBaUJ0NUMsZ0JBQVM0QixHQUFULENBQWExQixRQUFiLEVBQXVCLFVBQUM2SSxLQUFELEVBQVEyQixLQUFSLEVBQWtCO0FBQzVELGdCQUFJM0IsU0FBUyxPQUFPQSxNQUFNM0UsSUFBYixLQUFzQixVQUEvQixJQUE2QzJFLE1BQU0zRSxJQUFOLENBQVdNLFNBQVgsS0FBeUIsTUFBMUUsRUFBa0Y7QUFBQTs7QUFDOUUsb0JBQU02MEMsVUFBVSwyREFDUjU2QyxNQURRLGlCQUNXLENBQUN3NkMsUUFEWixlQUVSeDZDLE1BRlEsbUJBRWE4ekMsUUFBUSxDQUFSLElBQWEvbkMsVUFBVSxDQUZwQyxlQUdSL0wsTUFIUSxrQkFHWTh6QyxRQUFRLENBQVIsSUFBYS9uQyxVQUFVK25DLFFBQVEsQ0FIM0MsZUFJUjl6QyxNQUpRLG1CQUlhOHpDLFVBQVUsQ0FKdkIsZUFLWDFwQyxNQUFNckssS0FBTixDQUFZNEYsU0FMRCxJQUthLENBQUMsQ0FBQ3lFLE1BQU1ySyxLQUFOLENBQVk0RixTQUwzQixnQkFBaEI7QUFPQSx1QkFBTytILGdCQUFNMkMsWUFBTixDQUFtQmpHLEtBQW5CLEVBQTBCO0FBQzdCekUsK0JBQVdpMUMsT0FEa0I7QUFFN0JsMUMsMEJBQU04MEMsWUFBWVQsWUFBWXIwQyxJQUFaO0FBRlcsaUJBQTFCLENBQVA7QUFJSDs7QUFFRCxtQkFBTzBFLEtBQVA7QUFDSCxTQWhCc0IsQ0FBdkI7O0FBa0JBLFlBQU1ZLFVBQVVSLFNBQWhCO0FBQ0EsWUFBTXF3Qyx3QkFDQy95QyxNQUREO0FBRUZyQyxrQkFBTTgwQyxRQUZKO0FBR0Y1MEMsdUJBQVcrMEM7QUFIVCxVQUFOOztBQU1BLFlBQUkxdkMsWUFBWSxHQUFoQixFQUFxQjtBQUNqQixtQkFBTzZ2QyxTQUFTcDFDLElBQWhCOztBQUVBLGdCQUFJbzFDLFNBQVNseUMsUUFBYixFQUF1QjtBQUNuQix1QkFBT2t5QyxTQUFTanhDLE9BQWhCLENBRG1CLENBQ007QUFDekJpeEMseUJBQVNDLElBQVQsSUFBaUIsT0FBT0QsU0FBU0MsSUFBakMsQ0FGbUIsQ0FFb0I7QUFDMUM7QUFDSjs7QUFFRCxlQUNJO0FBQUMsbUJBQUQ7QUFBQSx5QkFBYUQsUUFBYixJQUF1QixLQUFLejZDLE1BQU0sS0FBTixHQUFjMmEsU0FBMUMsRUFBcUQsV0FBVyxLQUFLby9CLFNBQXJFLEVBQWdGLEtBQUssS0FBS0csZ0JBQTFGLEVBQTRHLE1BQUssUUFBakg7QUFDS0s7QUFETCxTQURKO0FBS0gsSzs7O0VBeEkrQm41QyxnQixVQUN6QkMsUyxHQUFZO0FBQ2Z6QixZQUFRMEIsb0JBQVVDLE1BREg7QUFFZnZCLFNBQUtzQixvQkFBVUUsSUFGQTtBQUdmOzs7QUFHQTZELFVBQU0vRCxvQkFBVW9FLEtBQVYsQ0FBZ0IsQ0FBQyxTQUFELEVBQVksV0FBWixFQUF5QixRQUF6QixDQUFoQixDQU5TO0FBT2Y7OztBQUdBSixVQUFNaEUsb0JBQVVvRSxLQUFWLENBQWdCLENBQUMsT0FBRCxFQUFVLFFBQVYsRUFBb0IsT0FBcEIsQ0FBaEIsQ0FWUztBQVdmOzs7QUFHQTAwQyxjQUFVOTRDLG9CQUFVb0UsS0FBVixDQUFnQixDQUFDLEtBQUQsRUFBUSxJQUFSLEVBQWMsT0FBZCxFQUF1QixRQUF2QixFQUFpQyxPQUFqQyxFQUEwQyxJQUExQyxFQUFnRCxLQUFoRCxFQUF1RCxNQUF2RCxDQUFoQixDQWRLO0FBZWY7OztBQUdBeTBDLGNBQVU3NEMsb0JBQVVvRSxLQUFWLENBQWdCLENBQUMsUUFBRCxFQUFXLE9BQVgsRUFBb0IsUUFBcEIsQ0FBaEIsQ0FsQks7QUFtQmY7OztBQUdBMEUsZUFBVzlJLG9CQUFVb0UsS0FBVixDQUFnQixDQUFDLFFBQUQsRUFBVyxHQUFYLENBQWhCLENBdEJJO0FBdUJmOzs7QUFHQXNHLGFBQVMxSyxvQkFBVUUsSUExQko7QUEyQmY7OztBQUdBeTVCLFdBQU8zNUIsb0JBQVVvRSxLQUFWLENBQWdCLENBQUMsSUFBRCxFQUFPLEtBQVAsRUFBYyxPQUFkLEVBQXVCLE1BQXZCLENBQWhCLENBOUJRO0FBK0JmOzs7QUFHQXFRLFVBQU16VSxvQkFBVUUsSUFsQ0Q7QUFtQ2Y7OztBQUdBekIsYUFBU3VCLG9CQUFVRSxJQXRDSjtBQXVDZjs7O0FBR0ErRyxjQUFVakgsb0JBQVVFLElBMUNMO0FBMkNmOzs7O0FBSUFnSSxhQUFTbEksb0JBQVVoRSxJQS9DSjtBQWdEZmlJLGVBQVdqRSxvQkFBVUMsTUFoRE47QUFpRGZ3NEMsZUFBV3o0QyxvQkFBVWhFLElBakROO0FBa0RmNkQsY0FBVUcsb0JBQVU4TztBQWxETCxDLFNBcURaMU8sWSxHQUFlO0FBQ2xCOUIsWUFBUSxPQURVO0FBRWxCeUYsVUFBTSxRQUZZO0FBR2xCQyxVQUFNLFFBSFk7QUFJbEI2MEMsY0FBVSxRQUpRO0FBS2xCL3ZDLGVBQVcsUUFMTztBQU1sQjRCLGFBQVMsS0FOUztBQU9sQml2QixXQUFPLEtBUFc7QUFRbEJsbEIsVUFBTSxLQVJZO0FBU2xCaFcsYUFBUyxLQVRTO0FBVWxCd0ksY0FBVSxLQVZRO0FBV2xCaUIsYUFBUyxtQkFBTSxDQUFFO0FBWEMsQztBQXRETG94QixNO2tCQUFBQSxNOzs7Ozs7Ozs7Ozs7Ozs7O0FDYnJCOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7OztJQUdNQyxXOzs7Ozs7Ozs7MEJBaUJGNzVCLE0scUJBQVM7QUFBQTs7QUFBQSxxQkFDeUQsS0FBS3JCLEtBRDlEO0FBQUEsWUFDR0MsTUFESCxVQUNHQSxNQURIO0FBQUEsWUFDVzJGLFNBRFgsVUFDV0EsU0FEWDtBQUFBLFlBQ3NCRCxJQUR0QixVQUNzQkEsSUFEdEI7QUFBQSxZQUM0Qm5FLFFBRDVCLFVBQzRCQSxRQUQ1QjtBQUFBLFlBQ3NDbkIsR0FEdEMsVUFDc0NBLEdBRHRDO0FBQUEsWUFDOEMwSCxNQUQ5Qzs7QUFHTCxZQUFNaXpDLFdBQVcseURBQ1QvNkMsTUFEUyxrQkFDVyxJQURYLGNBRVoyRixTQUZZLElBRUFBLFNBRkEsZUFBakI7O0FBS0EsWUFBTXExQyxnQkFBZ0IzNUMsZ0JBQVM0QixHQUFULENBQWExQixRQUFiLEVBQXVCLFVBQUM2SSxLQUFELEVBQVc7QUFDcEQsZ0JBQUlBLEtBQUosRUFBVztBQUNQLHVCQUFPc0QsZ0JBQU0yQyxZQUFOLENBQW1CakcsS0FBbkIsRUFBMEI7QUFDN0IxRSwwQkFBTUE7QUFEdUIsaUJBQTFCLENBQVA7QUFHSDtBQUNKLFNBTnFCLENBQXRCOztBQVFBLFlBQUl0RixHQUFKLEVBQVM7QUFDTDBILG1CQUFPakMsR0FBUCxHQUFhLEtBQWI7QUFDSDs7QUFFRCxlQUNJO0FBQUE7QUFBQSx5QkFBU2lDLE1BQVQsSUFBaUIsV0FBV2l6QyxRQUE1QjtBQUNLQztBQURMLFNBREo7QUFLSCxLOzs7RUExQ3FCeDVDLGdCLFVBQ2ZDLFMsR0FBWTtBQUNmckIsU0FBS3NCLG9CQUFVRSxJQURBO0FBRWY1QixZQUFRMEIsb0JBQVVDLE1BRkg7QUFHZjs7O0FBR0ErRCxVQUFNaEUsb0JBQVVDLE1BTkQ7QUFPZmdFLGVBQVdqRSxvQkFBVUMsTUFQTjtBQVFmSixjQUFVRyxvQkFBVThPO0FBUkwsQyxTQVdaMU8sWSxHQUFlO0FBQ2xCOUIsWUFBUSxPQURVO0FBRWxCMEYsVUFBTTtBQUZZLEM7QUFacEJ1MUIsVztrQkE2Q1N2N0IseUJBQWVzQyxNQUFmLENBQXNCaTVCLFdBQXRCLEM7Ozs7Ozs7Ozs7Ozs7O0FDckRmOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0lBRU0vVSxNOzs7Ozs7Ozs7Ozs7NEpBWUZzckIsVyxHQUFjLFVBQUN0d0MsQ0FBRCxFQUFPO0FBQ2pCLGtCQUFLKzVDLFNBQUwsR0FBaUIvNUMsRUFBRWc2QyxLQUFuQjtBQUNBejlDLHlCQUFPcWpCLEVBQVAsQ0FBVS9QLFFBQVYsRUFBb0IsV0FBcEIsRUFBaUMsTUFBS29xQyxXQUF0QztBQUNBMTlDLHlCQUFPcWpCLEVBQVAsQ0FBVS9QLFFBQVYsRUFBb0IsU0FBcEIsRUFBK0IsTUFBS29wQyxTQUFwQztBQUNBLGtCQUFLaUIsUUFBTDtBQUNILFMsUUFDREQsVyxHQUFjLFVBQUNqNkMsQ0FBRCxFQUFPO0FBQ2pCLGdCQUFNZzZDLFFBQVFoNkMsRUFBRWc2QyxLQUFoQjtBQUNBLGdCQUFNRyxlQUFlSCxRQUFRLE1BQUtELFNBQWxDO0FBQ0Esa0JBQUtsN0MsS0FBTCxDQUFXaTNCLFFBQVgsQ0FBb0IsTUFBS2ozQixLQUFMLENBQVcyTyxTQUEvQixFQUEwQzJzQyxZQUExQztBQUNBLGtCQUFLSixTQUFMLEdBQWlCQyxLQUFqQjtBQUNILFMsUUFDRGYsUyxHQUFZLFlBQU07QUFDZCxrQkFBS21CLE9BQUw7QUFDSCxTOzs7cUJBakJEdjZDLG9CLG1DQUF1QjtBQUNuQixhQUFLdTZDLE9BQUw7QUFDSCxLOztxQkFnQkRBLE8sc0JBQVU7QUFDTjc5QyxxQkFBT2dqQixHQUFQLENBQVcxUCxRQUFYLEVBQXFCLFdBQXJCLEVBQWtDLEtBQUtvcUMsV0FBdkM7QUFDQTE5QyxxQkFBT2dqQixHQUFQLENBQVcxUCxRQUFYLEVBQXFCLFNBQXJCLEVBQWdDLEtBQUtvcUMsV0FBckM7QUFDQSxhQUFLdHhCLE1BQUw7QUFDSCxLOztxQkFDRHV4QixRLHVCQUFXO0FBQ1A1OUMsa0JBQUl5WixRQUFKLENBQWFsRyxTQUFTZ0gsSUFBdEIsRUFBNEI7QUFDeEJ3akMsd0JBQVksTUFEWTtBQUV4QkMsb0JBQVE7QUFGZ0IsU0FBNUI7QUFJQXpxQyxpQkFBU2dILElBQVQsQ0FBYzI3QixZQUFkLENBQTJCLGNBQTNCLEVBQTJDLElBQTNDO0FBQ0gsSzs7cUJBQ0Q3cEIsTSxxQkFBUztBQUNMcnNCLGtCQUFJeVosUUFBSixDQUFhbEcsU0FBU2dILElBQXRCLEVBQTRCO0FBQ3hCd2pDLHdCQUFZLEVBRFk7QUFFeEJDLG9CQUFRO0FBRmdCLFNBQTVCO0FBSUF6cUMsaUJBQVNnSCxJQUFULENBQWMwakMsZUFBZCxDQUE4QixjQUE5QjtBQUNILEs7O3FCQUNEcjZDLE0scUJBQVM7QUFBQSxZQUNHcEIsTUFESCxHQUNjLEtBQUtELEtBRG5CLENBQ0dDLE1BREg7O0FBRUwsZUFBTyxxQ0FBRyxXQUFjQSxNQUFkLHlCQUFILEVBQStDLGFBQWEsS0FBS3d4QyxXQUFqRSxHQUFQO0FBQ0gsSzs7O0VBakRnQjlqQyxnQkFBTWxNLFMsVUFDaEJDLFMsR0FBWTtBQUNmekIsWUFBUTA3QyxvQkFBRS81QyxNQURLO0FBRWZxMUIsY0FBVTBrQixvQkFBRWgrQyxJQUZHO0FBR2ZnUixlQUFXZ3RDLG9CQUFFLzVDO0FBSEUsQyxTQUtaRyxZLEdBQWU7QUFDbEJrMUIsY0FBVSxvQkFBTSxDQUFFO0FBREEsQztBQU5wQjlRLE07a0JBb0RTQSxNOzs7Ozs7Ozs7Ozs7O0FDeERmOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBRUE7SUFDcUJtbEIsTzs7Ozs7Ozs7O3NCQUNqQmpxQyxNLHFCQUFTO0FBQUEscUJBQ3dDLEtBQUtyQixLQUQ3QztBQUFBLFlBQ0VvTSxRQURGLFVBQ0VBLFFBREY7QUFBQSxZQUNZNUssUUFEWixVQUNZQSxRQURaO0FBQUEsWUFDaUMySyxHQURqQyxVQUNzQjFCLFNBRHRCOztBQUVMLGVBQVE7QUFBQyxlQUFEO0FBQUEsY0FBSyxNQUFLLE9BQVY7QUFDSDJCLG9CQURHO0FBRUg1SztBQUZHLFNBQVI7QUFJSCxLOzs7RUFQZ0NDLGdCOztBQUFoQjZwQyxPO2tCQUFBQSxPOzs7QUFVckJBLFFBQVF2cEMsWUFBUixHQUF1QjtBQUNuQjBJLGVBQVc7QUFEUSxDQUF2Qjs7QUFJQTZnQyxRQUFRNXBDLFNBQVIsR0FBb0I7QUFDaEJGLGNBQVVHLG9CQUFVaU0sR0FESjtBQUVoQjNOLFlBQVEwQixvQkFBVUMsTUFGRjtBQUdoQndLLGNBQVV6SyxvQkFBVWlNLEdBSEo7QUFJaEJuRCxlQUFXOUksb0JBQVVDO0FBSkwsQ0FBcEI7Ozs7Ozs7Ozs7Ozs7OztBQ2xCQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7OztBQUVBOzs7O0lBSXFCc3FDLFc7Ozs7Ozs7OzswQkFtQmpCbnNDLGUsOEJBQWtCO0FBQ2QsZUFBTztBQUNIb0wsb0JBQVE7QUFETCxTQUFQO0FBR0gsSzs7MEJBRUQ5SixNLHFCQUFTO0FBQ0wsZUFBTyxJQUFQO0FBQ0gsSzs7O0VBM0JvQ3NNLGdCQUFNbE0sUyxVQUVwQ0MsUyxHQUFZO0FBQ2Y7OztBQUdBbU8sV0FBT2xPLG9CQUFVNk8sU0FBVixDQUFvQixDQUFDN08sb0JBQVVHLE9BQVgsRUFBb0JILG9CQUFVOE8sSUFBOUIsRUFBb0M5TyxvQkFBVWhFLElBQTlDLENBQXBCO0FBSlEsQyxTQU9acUUsaUIsR0FBb0I7QUFDdkJtSixZQUFReEosb0JBQVVpTTtBQURLLEMsU0FJcEI3TCxZLEdBQWU7QUFDbEI4TixXQUFPO0FBRFcsQyxTQUlmN0osUyxHQUFZLGE7QUFqQkZrbUMsVztrQkFBQUEsVzs7Ozs7Ozs7Ozs7Ozs7a0JDQ0c1TyxJOztBQVJ4Qjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7OztBQUVBLElBQU03eEIsT0FBTyxTQUFQQSxJQUFPLEdBQU0sQ0FBRyxDQUF0Qjs7QUFFZSxTQUFTNnhCLElBQVQsQ0FBY3NlLGFBQWQsRUFBNkI7QUFBQTs7QUFBQSxRQUNsQ0MsU0FEa0M7QUFBQTs7QUFpRHBDLDJCQUFZNzdDLEtBQVosRUFBbUIwTyxPQUFuQixFQUE0QjtBQUFBOztBQUFBLHlEQUN4Qiw0QkFBTTFPLEtBQU4sRUFBYTBPLE9BQWIsQ0FEd0I7O0FBQUEsa0JBNkQ1Qm90QyxlQTdENEIsR0E2RFYsVUFBQy92QyxNQUFELEVBQVk7QUFDcEIsb0JBQUVVLFVBQUYsR0FBaUIsTUFBS3pNLEtBQXRCLENBQUV5TSxVQUFGO0FBQUEsb0JBQ0ZoSixFQURFLEdBQ0dzSSxPQUFPVSxVQUFQLENBREg7QUFBQSxvQkFFRkUsVUFGRSxHQUVXLE1BQUtvdkMsRUFGaEI7QUFBQSxvQkFHRjloQixXQUhFLGFBR2dCLE1BQUtqeEIsS0FBTCxDQUFXaXhCLFdBSDNCO0FBQUEsb0JBSUZqdUIsS0FKRSxHQUlNaXVCLFlBQVlqMUIsT0FBWixDQUFvQnZCLEVBQXBCLENBSk47QUFBQSxvQkFLRnU0QyxrQkFMRSxHQUttQixTQUFyQkEsa0JBQXFCLENBQVV2NEMsRUFBVixFQUFjO0FBQy9CLHdCQUFNK0QsTUFBTSxDQUFDL0QsRUFBRCxDQUFaO0FBQ0Esd0JBQU0yRyxPQUFPLFNBQVBBLElBQU8sQ0FBQzNGLElBQUQsRUFBVTtBQUNuQkEsNkJBQUtNLE9BQUwsQ0FBYSxnQkFBUTtBQUNqQnlDLGdDQUFJMUksSUFBSixDQUFTcUUsS0FBS3NKLFVBQUwsQ0FBVDtBQUNBLGdDQUFJdEosS0FBSzNCLFFBQVQsRUFBbUI7QUFDZjRJLHFDQUFLakgsS0FBSzNCLFFBQVY7QUFDSDtBQUNKLHlCQUxEO0FBTUgscUJBUEQ7QUFRQW1MLCtCQUFXNUgsT0FBWCxDQUFtQixnQkFBUTtBQUN2Qiw0QkFBSTVCLEtBQUtzSixVQUFMLE1BQXFCaEosRUFBekIsRUFBNkI7QUFDekIsZ0NBQUlOLEtBQUszQixRQUFULEVBQW1CO0FBQ2Y0SSxxQ0FBS2pILEtBQUszQixRQUFWO0FBQ0g7QUFDSjtBQUNKLHFCQU5EO0FBT0EsMkJBQU9nRyxHQUFQO0FBQ0gsaUJBdkJDOzs7QUF5Qk4sb0JBQUl3RSxRQUFRLENBQUMsQ0FBYixFQUFnQjtBQUNaO0FBQ0Esd0JBQU1pd0MsTUFBTUQsbUJBQW1CdjRDLEVBQW5CLENBQVo7QUFDQXc0Qyx3QkFBSWwzQyxPQUFKLENBQVksY0FBTTtBQUNkLDRCQUFNdEcsSUFBSXc3QixZQUFZajFCLE9BQVosQ0FBb0J2QixFQUFwQixDQUFWO0FBQ0EsNEJBQUloRixJQUFJLENBQUMsQ0FBVCxFQUFZO0FBQ1J3N0Isd0NBQVkvcUIsTUFBWixDQUFtQnpRLENBQW5CLEVBQXNCLENBQXRCO0FBQ0g7QUFDSixxQkFMRDtBQU1ILGlCQVRELE1BU087QUFDSHc3QixnQ0FBWW43QixJQUFaLENBQWlCMkUsRUFBakI7QUFDSDs7QUFFRCxvQkFBSSxFQUFFLGlCQUFpQixNQUFLekQsS0FBeEIsQ0FBSixFQUFvQztBQUNoQywwQkFBS3NmLFFBQUwsQ0FBYztBQUNWMmE7QUFEVSxxQkFBZDtBQUdIO0FBQ0Qsc0JBQUtqNkIsS0FBTCxDQUFXZytCLFNBQVgsQ0FBcUIvRCxXQUFyQixFQUFrQ3gyQixFQUFsQyxFQUFzQ3VJLFVBQVUsQ0FBQyxDQUFqRCxFQUFvREQsTUFBcEQ7QUFDSCxhQTFHMkI7O0FBRXhCLGtCQUFLL0MsS0FBTCxHQUFhO0FBQ1RpeEIsNkJBQWFqNkIsTUFBTWk2QixXQUFOLElBQXFCO0FBRHpCLGFBQWI7QUFGd0I7QUFLM0I7O0FBdERtQyw0QkF3RHBDbDZCLGVBeERvQyw4QkF3RGxCO0FBQ2QsbUJBQU87QUFDSG04QyxpQ0FBaUIsS0FBS2x6QyxLQUFMLENBQVdpeEIsV0FEekI7QUFFSGlFLHdCQUFRLEtBQUtsK0IsS0FBTCxDQUFXaytCLE1BRmhCO0FBR0hpZSw0QkFBWSxLQUFLQyxpQkFBTCxDQUF1QixLQUFLTCxFQUE1QixDQUhUO0FBSUhELGlDQUFpQixLQUFLQSxlQUpuQjtBQUtIclAsd0JBQVEsS0FBS3pzQyxLQUFMLENBQVd5c0M7QUFMaEIsYUFBUDtBQU9ILFNBaEVtQzs7QUFBQSw0QkFrRXBDNXJDLHlCQWxFb0Msc0NBa0VWQyxTQWxFVSxFQWtFQztBQUNqQyxnQkFBSSxpQkFBaUJBLFNBQXJCLEVBQWdDO0FBQUEsb0JBQ3BCbTVCLFdBRG9CLEdBQ0puNUIsU0FESSxDQUNwQm01QixXQURvQjs7QUFFNUIscUJBQUszYSxRQUFMLENBQWM7QUFDVjJhO0FBRFUsaUJBQWQ7QUFHSDtBQUNKLFNBekVtQzs7QUFBQSw0QkEyRXBDb2lCLG1CQTNFb0MsZ0NBMkVoQjF2QyxVQTNFZ0IsRUEyRUo7QUFDNUIsZ0JBQU1uRixNQUFNLEVBQVo7QUFBQSxnQkFDSTRDLE9BQU8sU0FBUEEsSUFBTyxDQUFVdUMsVUFBVixFQUFzQnJDLEtBQXRCLEVBQTZCO0FBQ2hDcUMsMkJBQVc1SCxPQUFYLENBQW1CLGdCQUFRO0FBQ3ZCNUIseUJBQUttNUMsT0FBTCxHQUFlaHlDLEtBQWY7QUFDQTlDLHdCQUFJMUksSUFBSixDQUFTcUUsSUFBVDtBQUNBLHdCQUFJQSxLQUFLM0IsUUFBVCxFQUFtQjtBQUNmNEksNkJBQUtqSCxLQUFLM0IsUUFBVixFQUFvQjhJLFFBQVEsQ0FBNUI7QUFDSDtBQUNKLGlCQU5EO0FBT0gsYUFUTDtBQVVBRixpQkFBS3VDLFVBQUwsRUFBaUIsQ0FBakI7QUFDQSxpQkFBS292QyxFQUFMLEdBQVV2MEMsR0FBVjtBQUNBLG1CQUFPQSxHQUFQO0FBQ0gsU0F6Rm1DOztBQUFBLDRCQTJGcEM0MEMsaUJBM0ZvQyxnQ0EyRkQ7QUFBQSxnQkFBakJ6dkMsVUFBaUIsdUVBQUosRUFBSTtBQUN6QixnQkFBRXN0QixXQUFGLEdBQWtCLEtBQUtqeEIsS0FBdkIsQ0FBRWl4QixXQUFGO0FBQUEsZ0JBQ0F4dEIsVUFEQSxHQUNlLEtBQUt6TSxLQURwQixDQUNBeU0sVUFEQTtBQUFBLGdCQUVGakYsR0FGRSxHQUVJLEVBRko7OztBQUlOeXlCLHdCQUFZbDFCLE9BQVosQ0FBb0IsbUJBQVc7QUFDM0I0SCwyQkFBVzVILE9BQVgsQ0FBbUIsZ0JBQVE7QUFDdkIsd0JBQUk1QixLQUFLc0osVUFBTCxNQUFxQjh2QyxPQUF6QixFQUFrQztBQUM5Qiw0QkFBSXA1QyxLQUFLM0IsUUFBVCxFQUFtQjtBQUNmMkIsaUNBQUszQixRQUFMLENBQWN1RCxPQUFkLENBQXNCLGlCQUFTO0FBQzNCeUMsb0NBQUkxSSxJQUFKLENBQVN1TCxNQUFNb0MsVUFBTixDQUFUO0FBQ0gsNkJBRkQ7QUFHSDtBQUNKO0FBQ0osaUJBUkQ7QUFTSCxhQVZEO0FBV0EsbUJBQU9qRixHQUFQO0FBQ0gsU0E1R21DOztBQUFBLDRCQTZKcENuRyxNQTdKb0MscUJBNkozQjtBQUNMO0FBREsseUJBRXVELEtBQUtyQixLQUY1RDtBQUFBLGdCQUVDdU0sVUFGRCxVQUVDQSxVQUZEO0FBQUEsZ0JBRWFrZ0MsTUFGYixVQUVhQSxNQUZiO0FBQUEsZ0JBRXFCOS9CLFVBRnJCLFVBRXFCQSxVQUZyQjtBQUFBLGdCQUVpQ3V4QixNQUZqQyxVQUVpQ0EsTUFGakM7QUFBQSxnQkFFNENuMkIsTUFGNUM7O0FBSUwsZ0JBQUkwa0MsTUFBSixFQUFZO0FBQ1JsZ0MsMENBQWlCQSxVQUFqQjtBQUNBLG9CQUFJLENBQUNBLFdBQVdPLEdBQWhCLEVBQXFCO0FBQ2pCUCwrQkFBV08sR0FBWCxHQUFpQkMsYUFBakI7QUFDSDtBQUNELG9CQUFJLENBQUNSLFdBQVdTLElBQWhCLEVBQXNCO0FBQ2xCVCwrQkFBV1MsSUFBWCxHQUFrQkMsY0FBbEI7QUFDSDs7QUFFRE4sNkJBQWEsS0FBSzB2QyxtQkFBTCxDQUF5QjF2QyxVQUF6QixDQUFiO0FBQ0g7QUFDRCxtQkFBUSw4QkFBQyxhQUFELGVBQW1CNUUsTUFBbkIsSUFBMkIsWUFBWTRFLFVBQXZDLEVBQW1ELFlBQVlKLFVBQS9ELElBQVI7QUFDSCxTQTdLbUM7O0FBQUE7QUFBQSxNQUNoQm9CLGdCQUFNbE0sU0FEVSxVQUU3Qis2QyxPQUY2QixHQUVuQnp2QyxhQUZtQixTQUc3QjB2QyxRQUg2QixHQUdsQnh2QyxjQUhrQixTQUk3QnZMLFNBSjZCO0FBS2hDOzs7QUFHQXU0QixxQkFBYXQ0QixvQkFBVWtNLEtBUlM7QUFTaEM7Ozs7Ozs7QUFPQW13QixtQkFBV3I4QixvQkFBVWhFLElBaEJXO0FBaUJoQzs7O0FBR0E4TyxvQkFBWTlLLG9CQUFVQyxNQXBCVTtBQXFCaEM7OztBQUdBczhCLGdCQUFRdjhCLG9CQUFVdUosTUF4QmM7QUF5QmhDOzs7QUFHQXVoQyxnQkFBUTlxQyxvQkFBVUUsSUE1QmM7QUE2QmhDM0IsZ0JBQVF5QixvQkFBVWpGO0FBN0JjLE9BOEI3QmsvQyxjQUFjbDZDLFNBOUJlLFVBaUM3QkssWUFqQzZCLGdCQWtDN0I2NUMsY0FBYzc1QyxZQWxDZTtBQW1DaEMwSyxvQkFBWSxJQW5Db0I7QUFvQ2hDdXhCLG1CQUFXdnlCLElBcENxQjtBQXFDaENjLG9CQUFZLEVBckNvQjtBQXNDaEMyeEIsZ0JBQVE7QUF0Q3dCLGVBeUM3Qmw4QixpQkF6QzZCLEdBeUNUO0FBQ3ZCazZDLHlCQUFpQnY2QyxvQkFBVWtNLEtBREo7QUFFdkJxd0IsZ0JBQVF2OEIsb0JBQVV1SixNQUZLO0FBR3ZCaXhDLG9CQUFZeDZDLG9CQUFVa00sS0FIQztBQUl2Qml1Qyx5QkFBaUJuNkMsb0JBQVVoRSxJQUpKO0FBS3ZCOHVDLGdCQUFROXFDLG9CQUFVRTtBQUxLLEtBekNTO0FBQ2xDZzZDLGFBRGtDOztBQStLeEMsdUJBQVFBLFNBQVIsRUFBbUJELGFBQW5CO0FBQ0EsV0FBT0MsU0FBUDtBQUNIOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3pMRDs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztJQUVxQlcsTzs7Ozs7Ozs7O3NCQWNqQm43QyxNLHFCQUFTO0FBQUE7O0FBQ0w7QUFESyxxQkFFd0QsS0FBS3JCLEtBRjdEO0FBQUEsWUFFRzRGLFNBRkgsVUFFR0EsU0FGSDtBQUFBLFlBRWNtRyxNQUZkLFVBRWNBLE1BRmQ7QUFBQSxZQUVzQlUsVUFGdEIsVUFFc0JBLFVBRnRCO0FBQUEsWUFFa0N4TSxNQUZsQyxVQUVrQ0EsTUFGbEM7QUFBQSxZQUU2QzhILE1BRjdDOztBQUFBLHVCQUcrQixLQUFLMkcsT0FIcEM7QUFBQSxZQUdHeXRDLFVBSEgsWUFHR0EsVUFISDtBQUFBLFlBR2VsaUIsV0FIZixZQUdlQSxXQUhmOztBQUlMLFlBQU12cUIsTUFBTTtBQUNSZ3RDLG9CQUFRLEVBQUVQLFdBQVduM0MsT0FBWCxDQUFtQitHLE9BQU9VLFVBQVAsQ0FBbkIsSUFBeUMsQ0FBQyxDQUE1QyxLQUFrRFYsT0FBT3V3QyxPQUFQLEtBQW1CO0FBRHJFLHVCQUVKcjhDLE1BRkksd0JBRXFCOEwsT0FBT3V3QyxPQUY1QixJQUV3QyxJQUZ4QyxjQUdSSyxNQUhRLEdBR0ExaUIsWUFBWWoxQixPQUFaLENBQW9CK0csT0FBT1UsVUFBUCxDQUFwQixJQUEwQyxDQUFDLENBSDNDLGVBQVo7QUFLQSxlQUFRLDhCQUFDLGFBQUQsZUFBUzFFLE1BQVQsSUFBaUIsUUFBUWdFLE1BQXpCLEVBQWlDLFdBQVcyRCxHQUE1QyxFQUFpRCxZQUFZakQsVUFBN0QsRUFBeUUsUUFBUXhNLE1BQWpGLElBQVI7QUFDSCxLOzs7RUF4QmdDME4sZ0JBQU1sTSxTLFVBQ2hDQyxTLGdCQUNBb0wsY0FBSXBMLFMsVUFHSkssWSxnQkFDQStLLGNBQUkvSyxZLFVBR0o0TixZLEdBQWU7QUFDbEJ3c0MsZ0JBQVl4NkMsb0JBQVVrTSxLQURKO0FBRWxCb3NCLGlCQUFhdDRCLG9CQUFVa007QUFGTCxDO0FBVEwydUMsTztrQkFBQUEsTzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMckI7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBRXFCQyxROzs7Ozs7Ozs7Ozs7NEpBcUJqQlgsZSxHQUFrQixVQUFDL3ZDLE1BQUQsRUFBUzVLLENBQVQsRUFBZTtBQUM3QkEsY0FBRXdJLGVBQUY7QUFDQSxrQkFBSytFLE9BQUwsQ0FBYW90QyxlQUFiLENBQTZCL3ZDLE1BQTdCO0FBQ0gsUyxRQUVENndDLGUsR0FBa0IsVUFBQzd3QyxNQUFELEVBQVM1SyxDQUFULEVBQWU7QUFDN0JBLGNBQUUySSxjQUFGO0FBQ0EzSSxjQUFFd0ksZUFBRjs7QUFFQSxnQkFBSXhJLEVBQUV1USxPQUFGLEtBQWN2VCxjQUFRbWQsS0FBMUIsRUFBaUM7QUFDN0Isc0JBQUt3Z0MsZUFBTCxDQUFxQi92QyxNQUFyQixFQUE2QjVLLENBQTdCO0FBQ0g7QUFDSixTOzs7dUJBRURFLE0scUJBQVM7QUFBQTs7QUFBQSxxQkFDb0QsS0FBS3JCLEtBRHpEO0FBQUEsWUFDR3dGLFFBREgsVUFDR0EsUUFESDtBQUFBLFlBQ2F1RyxNQURiLFVBQ2FBLE1BRGI7QUFBQSxZQUNxQjlMLE1BRHJCLFVBQ3FCQSxNQURyQjtBQUFBLFlBQzZCd00sVUFEN0IsVUFDNkJBLFVBRDdCO0FBQUEsWUFDeUN2TSxNQUR6QyxVQUN5Q0EsTUFEekM7QUFBQSx1QkFFa0UsS0FBS3dPLE9BRnZFO0FBQUEsWUFFb0J1ckIsV0FGcEIsWUFFR2lpQixlQUZIO0FBQUEsWUFFaUNoZSxNQUZqQyxZQUVpQ0EsTUFGakM7QUFBQSxZQUV5Q3VPLE1BRnpDLFlBRXlDQSxNQUZ6QztBQUFBLFlBRWlESCxZQUZqRCxZQUVpREEsWUFGakQ7O0FBR0wsWUFBTXVRLHFCQUFxQnZRLGVBQWUsQ0FBZixHQUFtQixDQUE5QztBQUNBLFlBQUl3USx1QkFBSjtBQUFBLFlBQW9CQyxzQkFBcEI7QUFDQSxZQUFJdjNDLGFBQWFxM0Msa0JBQWpCLEVBQXFDO0FBQ2pDLGdCQUFJRyxzQkFBSjtBQUNBLGdCQUFJdlEsTUFBSixFQUFZO0FBQ1JxUSxpQ0FBaUI7QUFDYkcsaUNBQWEvZSxVQUFVbnlCLE9BQU91d0MsT0FBUCxHQUFpQixDQUEzQjtBQURBLGlCQUFqQjtBQUdBUyxnQ0FBZ0IsOEJBQUMsY0FBRCxJQUFNLE1BQUssSUFBWCxFQUFnQixXQUFjOThDLE1BQWQsMkJBQWhCLEdBQWhCO0FBQ0Esb0JBQUk4TCxPQUFPdkssUUFBUCxJQUFtQnVLLE9BQU92SyxRQUFQLENBQWdCN0MsTUFBdkMsRUFBK0M7QUFDM0Msd0JBQU11K0MsY0FBY2pqQixZQUFZajFCLE9BQVosQ0FBb0IrRyxPQUFPVSxVQUFQLENBQXBCLElBQTBDLENBQUMsQ0FBL0Q7O0FBRUF1d0Msb0NBQWdCRSxjQUFjLFlBQWQsR0FBNkIsYUFBN0M7O0FBRUFILG9DQUNLLDhCQUFDLGNBQUQ7QUFDRyxtQ0FBYzk4QyxNQUFkLHFCQURIO0FBRUcsOEJBQU0rOEMsYUFGVDtBQUdHLDhCQUFLLElBSFI7QUFJRyxpQ0FBUztBQUFBLG1DQUFLLE9BQUtsQixlQUFMLENBQXFCL3ZDLE1BQXJCLEVBQTZCNUssQ0FBN0IsQ0FBTDtBQUFBLHlCQUpaO0FBS0csbUNBQVc7QUFBQSxtQ0FBSyxPQUFLeTdDLGVBQUwsQ0FBcUI3d0MsTUFBckIsRUFBNkI1SyxDQUE3QixDQUFMO0FBQUEseUJBTGQ7QUFNRyw4QkFBSyxRQU5SO0FBT0csa0NBQVMsR0FQWjtBQVFHLHlDQUFlKzdDLFdBUmxCO0FBU0csc0NBQVlBLGNBQWNoOUMsT0FBT3NOLFFBQXJCLEdBQWdDdE4sT0FBT3NWLE1BVHRELEdBREw7QUFXSDtBQUNKO0FBQ0o7QUFDRCxlQUFRO0FBQUMsMEJBQUQ7QUFBQSx5QkFBbUIsS0FBS3hWLEtBQXhCLElBQStCLFlBQVk4OEMsY0FBM0M7QUFDSEM7QUFERyxTQUFSO0FBR0gsSzs7O0VBckVpQ3B2QyxnQkFBTWxNLFMsVUFDakNDLFM7QUFDSHc4QixZQUFRdjhCLG9CQUFVdUosTTtBQUNsQmhMLFlBQVF5QixvQkFBVWpGO0dBQ2Z1USxlQUFjdkwsUyxVQUdkSyxZLGdCQUNBa0wsZUFBY2xMLFk7QUFDakIwSSxlQUFXLEk7QUFDWHl6QixZQUFRO1dBR0x2dUIsWSxHQUFlO0FBQ2xCdXNDLHFCQUFpQnY2QyxvQkFBVWtNLEtBRFQ7QUFFbEJxd0IsWUFBUXY4QixvQkFBVXVKLE1BRkE7QUFHbEI0d0MscUJBQWlCbjZDLG9CQUFVaEUsSUFIVDtBQUlsQjh1QyxZQUFROXFDLG9CQUFVRSxJQUpBO0FBS2xCeXFDLGtCQUFjM3FDLG9CQUFVakY7QUFMTixDO0FBYkwrL0MsUTtrQkFBQUEsUTs7Ozs7Ozs7Ozs7Ozs7a0JDR0dyZixLOztBQVR4Qjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFZSxTQUFTQSxLQUFULENBQWV3ZSxhQUFmLEVBQThCO0FBQUE7O0FBQ3pDO0FBRHlDLFFBRW5DdUIsVUFGbUM7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQSxnS0FtRXJDeHNDLE9BbkVxQyxHQW1FM0IsVUFBQ2pMLElBQUQsRUFBTytLLElBQVAsRUFBYWhDLFFBQWIsRUFBMEI7QUFDaENBLDJCQUFXQSxXQUFXQSxTQUFTMnVDLE1BQVQsQ0FBZ0IsQ0FBaEIsRUFBbUJ2aUMsV0FBbkIsS0FBbUNwTSxTQUFTNHVDLE1BQVQsQ0FBZ0IsQ0FBaEIsQ0FBOUMsR0FBbUUsRUFBOUU7QUFDQSwyQkFBUTMzQyxJQUFSLEdBQWUrSSxRQUFmLGFBQWlDZ0MsSUFBakM7QUFDQSxvQkFBSS9LLFNBQVMsUUFBVCxJQUFxQixDQUFDK0ksUUFBMUIsRUFBb0M7QUFDaEMsMEJBQUs2dUMsZUFBTCxHQUF1QixNQUFLQyxVQUFMLENBQWdCOTBDLGFBQWhCLENBQThCLEtBQTlCLENBQXZCO0FBQ0g7QUFDSixhQXpFb0MsUUEyRXJDK3hCLFlBM0VxQyxHQTJFdEIsWUFBTTtBQUNqQixzQkFBS2dqQixRQUFMLENBQWMsTUFBS0MsUUFBTCxDQUFjdlEsVUFBNUIsRUFBd0MsTUFBS3VRLFFBQUwsQ0FBY24wQyxTQUF0RDtBQUNILGFBN0VvQztBQUFBOztBQUFBLDZCQXVDckN2SixlQXZDcUMsOEJBdUNuQjtBQUNkLG1CQUFPO0FBQ0g0NkIsNkJBQWEsS0FBSzM2QixLQUFMLENBQVcyNkIsV0FEckI7QUFFSEQsK0JBQWUsS0FBSzE2QixLQUFMLENBQVcwNkIsYUFGdkI7QUFHSEYsOEJBQWMsS0FBS0EsWUFIaEI7QUFJSDdwQix5QkFBUyxLQUFLQTtBQUpYLGFBQVA7QUFNSCxTQTlDb0M7O0FBQUEsNkJBZ0RyQ3pJLGlCQWhEcUMsZ0NBZ0RqQjtBQUNoQixpQkFBS3cxQyxxQkFBTDtBQUNILFNBbERvQzs7QUFBQSw2QkFvRHJDMzhDLGtCQXBEcUMsaUNBb0RoQjtBQUNqQixpQkFBSzI4QyxxQkFBTDtBQUNILFNBdERvQzs7QUFBQSw2QkF3RHJDQSxxQkF4RHFDLG9DQXdEYjtBQUFBLHlCQUM4QixLQUFLMTlDLEtBRG5DO0FBQUEsZ0JBQ1pvckMsU0FEWSxVQUNaQSxTQURZO0FBQUEsZ0JBQ0R6USxXQURDLFVBQ0RBLFdBREM7QUFBQSxnQkFDWUQsYUFEWixVQUNZQSxhQURaOztBQUVwQixnQkFBSTBRLGFBQWF6USxXQUFiLElBQTRCLENBQUMsS0FBSzM2QixLQUFMLENBQVd5TyxRQUE1QyxFQUFzRDtBQUNsRCxvQkFBSSxLQUFLZ3ZDLFFBQUwsQ0FBY3QwQyxZQUFkLElBQThCdXhCLGFBQWxDLEVBQWlEO0FBQzdDajlCLDhCQUFJeVosUUFBSixDQUFhLEtBQUtxbUMsVUFBbEIsRUFBOEIsY0FBOUIsRUFBOEMsQ0FBOUM7QUFDSCxpQkFGRCxNQUVPO0FBQ0g5L0MsOEJBQUl5WixRQUFKLENBQWEsS0FBS3FtQyxVQUFsQixFQUE4QixjQUE5QixFQUE4QzkvQyxVQUFJMFosU0FBSixHQUFnQnRJLEtBQTlEO0FBQ0g7QUFDSjtBQUNKLFNBakVvQzs7QUFBQSw2QkErRXJDMnVDLFFBL0VxQyxxQkErRTVCN2UsQ0EvRTRCLEVBK0V6QjtBQUNSLGdCQUFJLEtBQUsyZSxlQUFULEVBQTBCO0FBQ3RCLHFCQUFLQSxlQUFMLENBQXFCcFEsVUFBckIsR0FBa0N2TyxDQUFsQztBQUNIO0FBQ0osU0FuRm9DOztBQUFBLDZCQXFGckN0OUIsTUFyRnFDLHFCQXFGNUI7QUFDTDtBQURLLDBCQUUwRSxLQUFLckIsS0FGL0U7QUFBQSxnQkFFQ3VNLFVBRkQsV0FFQ0EsVUFGRDtBQUFBLGdCQUVhM0csU0FGYixXQUVhQSxTQUZiO0FBQUEsZ0JBRXdCM0YsTUFGeEIsV0FFd0JBLE1BRnhCO0FBQUEsZ0JBRWdDMDZCLFdBRmhDLFdBRWdDQSxXQUZoQztBQUFBLGdCQUU2Q0QsYUFGN0MsV0FFNkNBLGFBRjdDO0FBQUEsZ0JBRStEM3lCLE1BRi9EOztBQUdMLGdCQUFJNHlCLFdBQUosRUFBaUI7QUFBQTs7QUFDYnB1QiwwQ0FBaUJBLFVBQWpCO0FBQ0Esb0JBQUksQ0FBQ0EsV0FBVzhZLE1BQWhCLEVBQXdCO0FBQ3BCOVksK0JBQVc4WSxNQUFYLEdBQW9CZ21CLGdCQUFwQjtBQUNIO0FBQ0Qsb0JBQUksQ0FBQzkrQixXQUFXYixJQUFoQixFQUFzQjtBQUNsQmEsK0JBQVdiLElBQVgsR0FBa0I4L0IsY0FBbEI7QUFDSDtBQUNELG9CQUFJLENBQUNqL0IsV0FBVysrQixPQUFoQixFQUF5QjtBQUNyQi8rQiwrQkFBVysrQixPQUFYLEdBQXFCQyxpQkFBckI7QUFDSDtBQUNEM2xDLDRCQUFZLHlEQUNKM0YsTUFESSxvQkFDa0IsSUFEbEIsY0FFUDJGLFNBRk8sSUFFS0EsU0FGTCxlQUFaO0FBSUg7QUFDRCxtQkFBUSw4QkFBQyxhQUFELGVBQW9CbUMsTUFBcEIsSUFBNEIsWUFBWXdFLFVBQXhDLEVBQW9ELFdBQVczRyxTQUEvRCxFQUEwRSxRQUFRM0YsTUFBbEYsSUFBUjtBQUNILFNBekdvQzs7QUFBQTtBQUFBLE1BRWhCME4sZ0JBQU1sTSxTQUZVLFVBRzlCaVAsV0FIOEIsR0FHaEIyNkIsZ0JBSGdCLFNBSTlCOVEsU0FKOEIsR0FJbEJpUixjQUprQixTQUs5Qmo1QixZQUw4QixHQUtmZzVCLGlCQUxlLFNBTTlCN3BDLFNBTjhCO0FBT2pDOzs7QUFHQTBwQyxtQkFBV3pwQyxvQkFBVUUsSUFWWTtBQVdqQzs7O0FBR0E4NEIscUJBQWFoNUIsb0JBQVVFLElBZFU7QUFlakM7OztBQUdBNjRCLHVCQUFlLzRCLG9CQUFVNk8sU0FBVixDQUFvQixDQUFDN08sb0JBQVV1SixNQUFYLEVBQW1Cdkosb0JBQVVDLE1BQTdCLENBQXBCO0FBbEJrQixPQW1COUJnNkMsY0FBY2w2QyxTQW5CZ0IsVUFzQjlCSyxZQXRCOEIsZ0JBdUI5QjY1QyxjQUFjNzVDLFlBdkJnQjtBQXdCakNxcEMsbUJBQVcsSUF4QnNCO0FBeUJqQ3pRLHFCQUFhLEtBekJvQjtBQTBCakNELHVCQUFlLEdBMUJrQjtBQTJCakNudUIsb0JBQVksRUEzQnFCO0FBNEJqQ3EvQixjQUFNLEVBNUIyQjtBQTZCakMzckMsZ0JBQVE7QUE3QnlCLGVBZ0M5QitCLGlCQWhDOEIsR0FnQ1Y7QUFDdkIyNEIscUJBQWFoNUIsb0JBQVVFLElBREE7QUFFdkI2NEIsdUJBQWUvNEIsb0JBQVU2TyxTQUFWLENBQW9CLENBQUM3TyxvQkFBVXVKLE1BQVgsRUFBbUJ2SixvQkFBVUMsTUFBN0IsQ0FBcEIsQ0FGUTtBQUd2QjQ0QixzQkFBYzc0QixvQkFBVWhFLElBSEQ7QUFJdkJnVCxpQkFBU2hQLG9CQUFVaEU7QUFKSSxLQWhDVTtBQUVuQ3cvQyxjQUZtQzs7QUEyR3pDLHdCQUFRQSxVQUFSLEVBQW9CdkIsYUFBcEI7QUFDQSxXQUFPdUIsVUFBUDtBQUNIOzs7Ozs7Ozs7Ozs7OztrQkN6RnVCOWYsUzs7QUE3QnhCOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBRVE3ZixTLEdBQWM3ZixVLENBQWQ2ZixTOzs7QUFFUixJQUFNbWdDLFNBQVMsU0FBVEEsTUFBUyxDQUFDQyxHQUFELEVBQXVCO0FBQUEsUUFBakJ6K0MsR0FBaUIsdUVBQVgsTUFBVzs7QUFDbEMsUUFBTTArQyxPQUFPLEVBQWI7QUFBQSxRQUFpQnIyQyxNQUFNLEVBQXZCO0FBQ0FvMkMsUUFBSTc0QyxPQUFKLENBQVksZ0JBQVE7QUFDaEIsWUFBSTZDLGNBQUo7QUFDQSxZQUFJekksUUFBUSxNQUFaLEVBQW9CO0FBQ2hCeUksb0JBQVF6RSxJQUFSO0FBQ0gsU0FGRCxNQUVPO0FBQ0h5RSxvQkFBUXpFLEtBQUtoRSxHQUFMLENBQVI7QUFDSDtBQUNELFlBQUksQ0FBQzArQyxLQUFLajJDLEtBQUwsQ0FBTCxFQUFrQjtBQUNkSixnQkFBSTFJLElBQUosQ0FBU3FFLElBQVQ7QUFDQTA2QyxpQkFBS2oyQyxLQUFMLElBQWMsSUFBZDtBQUNIO0FBQ0osS0FYRDtBQVlBLFdBQU9KLEdBQVA7QUFDSCxDQWZEOztBQWlCZSxTQUFTNjFCLFNBQVQsQ0FBbUJ1ZSxhQUFuQixFQUFrQztBQUFBOztBQUM3QztBQUQ2QyxRQUV2Q2tDLGNBRnVDO0FBQUE7O0FBcUN6QyxnQ0FBWTk5QyxLQUFaLEVBQW1CME8sT0FBbkIsRUFBNEI7QUFBQTs7QUFBQSx5REFDeEIsNEJBQU0xTyxLQUFOLEVBQWEwTyxPQUFiLENBRHdCOztBQUFBLGtCQXNDNUJxdkMscUJBdEM0QixHQXNDSixZQUFNO0FBQ3BCLCtCQUFXLE1BQUtDLFlBQWhCO0FBQUEsb0JBQThCbHZDLEtBQTlCLEdBQXNDLEVBQXRDO0FBQUEsa0NBQ2lELE1BQUs5TyxLQUR0RDtBQUFBLG9CQUNBc3NDLFlBREEsZUFDQUEsWUFEQTtBQUFBLG9CQUNjNy9CLFVBRGQsZUFDY0EsVUFEZDtBQUFBLG9CQUMwQkUsVUFEMUIsZUFDMEJBLFVBRDFCO0FBQUEsb0JBQ3NDek0sTUFEdEMsZUFDc0NBLE1BRHRDO0FBQUEsb0JBRUEwNUIsZUFGQSxHQUVvQixNQUFLNXdCLEtBRnpCLENBRUE0d0IsZUFGQTtBQUFBLG9CQUdGelIsSUFIRSxHQUdLbWtCLGFBQWFua0IsSUFBYixHQUFvQm1rQixhQUFhbmtCLElBQWpDLEdBQXdDLFVBSDdDOztBQUtOLG9CQUFJNk8sVUFBVSxDQUFDLENBQUM0QyxnQkFBZ0JqN0IsTUFBaEM7QUFDQSxvQkFBSXk0QixnQkFBZ0IsS0FBcEI7QUFDQSxzQkFBSzZtQixjQUFMLENBQW9CdHhDLFVBQXBCLEVBQ0s4SSxNQURMLENBQ1ksVUFBQzFKLE1BQUQsRUFBU0MsS0FBVCxFQUFtQjtBQUN2Qix3QkFBSSxDQUFDc2dDLGFBQWE0UixRQUFsQixFQUE0QjtBQUN4QiwrQkFBTyxJQUFQO0FBQ0gscUJBRkQsTUFFTztBQUNILCtCQUFPLENBQUMsQ0FBQzVSLGFBQWE0UixRQUFiLENBQXNCbnlDLE1BQXRCLEVBQThCQyxLQUE5QixLQUF3QyxFQUF6QyxFQUE2Q3BELFFBQXJEO0FBQ0g7QUFDSixpQkFQTCxFQVFLMUYsR0FSTCxDQVFTO0FBQUEsMkJBQVU2SSxPQUFPVSxVQUFQLENBQVY7QUFBQSxpQkFSVCxFQVNLMUgsT0FUTCxDQVNhLGNBQU07QUFDWCx3QkFBSTYwQixnQkFBZ0I1MEIsT0FBaEIsQ0FBd0J2QixFQUF4QixNQUFnQyxDQUFDLENBQXJDLEVBQXdDO0FBQ3BDdXpCLGtDQUFVLEtBQVY7QUFDSCxxQkFGRCxNQUVPO0FBQ0hJLHdDQUFnQixJQUFoQjtBQUNIO0FBQ0osaUJBZkw7QUFnQkF0b0Isc0JBQU1qRixPQUFOLEdBQWdCMlQsVUFBVSxVQUFDcmMsQ0FBRCxFQUFPO0FBQzdCQSxzQkFBRXdJLGVBQUY7QUFDSCxpQkFGZSxFQUVibUYsTUFBTWpGLE9BRk8sQ0FBaEI7O0FBSUEsb0JBQUltdEIsT0FBSixFQUFhO0FBQ1RJLG9DQUFnQixLQUFoQjtBQUNIO0FBQ0QsdUJBQU9qUCxTQUFTLFVBQVQsR0FBc0IsOEJBQUMsa0JBQUQsYUFBVSxlQUFlaVAsYUFBekIsRUFBd0MsY0FBWWwzQixPQUFPd1YsU0FBM0QsRUFBc0UsU0FBU3NoQixPQUEvRSxFQUF3RixVQUFVQyxRQUFsRyxJQUFnSG5vQixLQUFoSCxFQUF0QixHQUFrSixJQUF6SjtBQUNILGFBdEUyQjs7QUFBQSxrQkF3RTVCcXZDLG1CQXhFNEIsR0F3RU4sVUFBQ3YyQyxLQUFELEVBQVFvRSxLQUFSLEVBQWVELE1BQWYsRUFBMEI7QUFBQSxtQ0FDUCxNQUFLL0wsS0FERTtBQUFBLG9CQUNwQ3NzQyxZQURvQyxnQkFDcENBLFlBRG9DO0FBQUEsb0JBQ3RCNy9CLFVBRHNCLGdCQUN0QkEsVUFEc0I7QUFBQSxvQkFFcENtdEIsZUFGb0MsR0FFaEIsTUFBSzV3QixLQUZXLENBRXBDNHdCLGVBRm9DOztBQUc1QyxvQkFBTXpSLE9BQU9ta0IsYUFBYW5rQixJQUFiLEdBQW9CbWtCLGFBQWFua0IsSUFBakMsR0FBd0MsVUFBckQ7QUFDQSxvQkFBTTZPLFVBQVU0QyxnQkFBZ0I1MEIsT0FBaEIsQ0FBd0IrRyxPQUFPVSxVQUFQLENBQXhCLElBQThDLENBQUMsQ0FBL0Q7QUFDQSxvQkFBTXdxQixXQUFXLE1BQUttbkIsWUFBTCxDQUFrQjF3QyxJQUFsQixRQUE2QjFCLEtBQTdCLEVBQW9DRCxNQUFwQyxDQUFqQjtBQUNBLG9CQUFNK0MsUUFBUXc5QixhQUFhNFIsUUFBYixHQUF5QjVSLGFBQWE0UixRQUFiLENBQXNCbnlDLE1BQXRCLEVBQThCQyxLQUE5QixLQUF3QyxFQUFqRSxHQUF1RSxFQUFyRjs7QUFFQThDLHNCQUFNakYsT0FBTixHQUFnQjJULFVBQVUsVUFBQ3JjLENBQUQsRUFBTztBQUM3QkEsc0JBQUV3SSxlQUFGO0FBQ0gsaUJBRmUsRUFFYm1GLE1BQU1qRixPQUZPLENBQWhCO0FBR0EsdUJBQU9zZSxTQUFTLFVBQVQsR0FBc0IsOEJBQUMsa0JBQUQsYUFBVSxTQUFTNk8sT0FBbkIsRUFBNEIsVUFBVUMsUUFBdEMsSUFBb0Rub0IsS0FBcEQsRUFBdEIsR0FDSCw4QkFBQyxlQUFELGFBQU8sU0FBU2tvQixPQUFoQixFQUF5QixVQUFVQyxRQUFuQyxJQUFpRG5vQixLQUFqRCxFQURKO0FBRUgsYUFyRjJCOztBQUFBLGtCQXVGNUJrdkMsWUF2RjRCLEdBdUZiLFVBQUNobkIsT0FBRCxFQUFVNzFCLENBQVYsRUFBZ0I7QUFDckIsb0NBQVUsTUFBSzZILEtBQUwsQ0FBVzR3QixlQUFyQjtBQUFBLG1DQUMyRCxNQUFLNTVCLEtBRGhFO0FBQUEsb0JBQ0Fzc0MsWUFEQSxnQkFDQUEsWUFEQTtBQUFBLG9CQUNjNy9CLFVBRGQsZ0JBQ2NBLFVBRGQ7QUFBQSxvQkFDMEJFLFVBRDFCLGdCQUMwQkEsVUFEMUI7QUFBQSxvQkFDc0NnL0IsZ0JBRHRDLGdCQUNzQ0EsZ0JBRHRDO0FBQUEsb0JBRUEvUixlQUZBLEdBRW9CLE1BQUs1d0IsS0FGekIsQ0FFQTR3QixlQUZBO0FBQUEsb0JBR0Zza0IsUUFIRSxHQUdTNVIsYUFBYTRSLFFBSHRCOztBQUlOLG9CQUFJcHZDLFFBQVEsRUFBWjtBQUFBLG9CQUFnQnV2QyxVQUFVLEVBQTFCOztBQUVBLG9CQUFNcjZDLFNBQVMybkMsbUJBQW1CQSxnQkFBbkIsR0FBc0NoL0IsVUFBckQ7O0FBRUEsc0JBQUtzeEMsY0FBTCxDQUFvQmo2QyxNQUFwQixFQUE0QmUsT0FBNUIsQ0FBb0MsVUFBQ2dILE1BQUQsRUFBU0MsS0FBVCxFQUFtQjtBQUNuRCx3QkFBTXZJLEtBQUtzSSxPQUFPVSxVQUFQLENBQVg7QUFDQSx3QkFBSXl4QyxRQUFKLEVBQWM7QUFDVnB2QyxnQ0FBUW92QyxTQUFTbnlDLE1BQVQsRUFBaUJDLEtBQWpCLEtBQTJCLEVBQW5DO0FBQ0g7QUFDRDtBQUNBLHdCQUFJZ3JCLFlBQVksQ0FBQ2xvQixNQUFNbEcsUUFBUCxJQUFtQmd4QixnQkFBZ0I1MEIsT0FBaEIsQ0FBd0J2QixFQUF4QixJQUE4QixDQUFDLENBQTlELENBQUosRUFBc0U7QUFDbEUrRCw0QkFBSTFJLElBQUosQ0FBUzJFLEVBQVQ7QUFDQTQ2QyxnQ0FBUXYvQyxJQUFSLENBQWFpTixNQUFiO0FBQ0gscUJBSEQsTUFHTyxJQUFJK0MsTUFBTWxHLFFBQU4sSUFBa0JneEIsZ0JBQWdCNTBCLE9BQWhCLENBQXdCdkIsRUFBeEIsSUFBOEIsQ0FBQyxDQUFyRCxFQUF3RDtBQUMzRCtELDRCQUFJMUksSUFBSixDQUFTMkUsRUFBVDtBQUNBNDZDLGdDQUFRdi9DLElBQVIsQ0FBYWlOLE1BQWI7QUFDSCxxQkFITSxNQUdBO0FBQ0gsNEJBQU10TixJQUFJK0ksSUFBSXhDLE9BQUosQ0FBWXZCLEVBQVosQ0FBVjtBQUNBaEYsNEJBQUksQ0FBQyxDQUFMLElBQVUrSSxJQUFJMEgsTUFBSixDQUFXelEsQ0FBWCxFQUFjLENBQWQsQ0FBVjtBQUNIO0FBQ0osaUJBaEJEOztBQWtCQTQvQywwQkFBVVYsT0FBT1UsT0FBUCxFQUFnQjV4QyxVQUFoQixDQUFWO0FBQ0Esb0JBQUksT0FBTzYvQixhQUFhZ1MsV0FBcEIsS0FBb0MsVUFBeEMsRUFBb0Q7QUFDaERoUyxpQ0FBYWdTLFdBQWIsQ0FBeUJ0bkIsT0FBekIsRUFBa0NxbkIsT0FBbEM7QUFDSDtBQUNELHNCQUFLRSxnQkFBTCxDQUFzQmpTLFlBQXRCLEVBQW9DcVIsT0FBT24yQyxHQUFQLENBQXBDLEVBQWlENjJDLE9BQWpEO0FBQ0FsOUMsa0JBQUV3SSxlQUFGO0FBQ0gsYUF4SDJCOztBQUV4QixrQkFBS1gsS0FBTCxHQUFhO0FBQ1Q0d0IsaUNBQWlCNTVCLE1BQU1zc0MsWUFBTixJQUFzQixxQkFBcUJ0c0MsTUFBTXNzQyxZQUFqRCxHQUFpRXRzQyxNQUFNc3NDLFlBQU4sQ0FBbUIxUyxlQUFuQixJQUFzQyxFQUF2RyxHQUE2RztBQURySCxhQUFiO0FBRndCO0FBSzNCOztBQTFDd0MsaUNBNEN6Qzc1QixlQTVDeUMsOEJBNEN2QjtBQUNkLG1CQUFPO0FBQ0h1c0MsOEJBQWMsS0FBS3RzQyxLQUFMLENBQVdzc0MsWUFEdEI7QUFFSDFTLGlDQUFpQixLQUFLNXdCLEtBQUwsQ0FBVzR3QjtBQUZ6QixhQUFQO0FBSUgsU0FqRHdDOztBQUFBLGlDQW1EekMvNEIseUJBbkR5QyxzQ0FtRGZDLFNBbkRlLEVBbURKO0FBQ2pDLGdCQUFJQSxVQUFVd3JDLFlBQVYsSUFBMEIscUJBQXFCeHJDLFVBQVV3ckMsWUFBN0QsRUFBMkU7QUFDdkUsb0JBQU0xUyxrQkFBa0I5NEIsVUFBVXdyQyxZQUFWLENBQXVCMVMsZUFBdkIsSUFBMEMsRUFBbEU7QUFDQSxxQkFBS3RhLFFBQUwsQ0FBYztBQUNWc2E7QUFEVSxpQkFBZDtBQUdIO0FBQ0osU0ExRHdDOztBQUFBLGlDQTREekM2USxpQkE1RHlDLDhCQTREdkJqcEMsUUE1RHVCLEVBNERiO0FBQUEseUJBQ1MsS0FBS3hCLEtBRGQ7QUFBQSxnQkFDaEJDLE1BRGdCLFVBQ2hCQSxNQURnQjtBQUFBLGdCQUNScXNDLFlBRFEsVUFDUkEsWUFEUTs7QUFFeEIsZ0JBQUlBLFlBQUosRUFBa0I7QUFDZDlxQywyQkFBV0YsZ0JBQVM0QixHQUFULENBQWExQixRQUFiLEVBQXVCLFVBQUM2SSxLQUFELEVBQVEyQixLQUFSO0FBQUEsMkJBQWtCMkIsZ0JBQU0yQyxZQUFOLENBQW1CakcsS0FBbkIsRUFBMEI7QUFDMUVsTCw2QkFBSzZNO0FBRHFFLHFCQUExQixDQUFsQjtBQUFBLGlCQUF2QixDQUFYO0FBR0F4Syx5QkFBU3FoQixPQUFULENBQWlCLDhCQUFDLGdCQUFELElBQUssS0FBSSxXQUFULEVBQXFCLE9BQU8sS0FBS2s3QixxQkFBTCxDQUEyQnJ3QyxJQUEzQixDQUFnQyxJQUFoQyxDQUE1QjtBQUNiLDBCQUFNLEtBQUt5d0MsbUJBQUwsQ0FBeUJ6d0MsSUFBekIsQ0FBOEIsSUFBOUIsQ0FETztBQUViLDJCQUFPLEVBRk07QUFHYiwrQkFBY3pOLE1BQWQsb0JBSGEsRUFHMEIsa0JBSDFCLEdBQWpCO0FBSUEsdUJBQU91QixRQUFQO0FBQ0g7QUFDRCxtQkFBT0EsUUFBUDtBQUNILFNBekV3Qzs7QUFBQSxpQ0ErSnpDNDhDLFlBL0p5Qyx5QkErSjVCcHlDLEtBL0o0QixFQStKckJELE1BL0pxQixFQStKYmlyQixPQS9KYSxFQStKSjcxQixDQS9KSSxFQStKRDtBQUNwQyxnQkFBSXk0Qiw0QkFBc0IsS0FBSzV3QixLQUFMLENBQVc0d0IsZUFBakMsQ0FBSjtBQUFBLGdCQUF1RG43QixVQUF2RDtBQURvQywwQkFFYSxLQUFLdUIsS0FGbEI7QUFBQSxnQkFFNUJ5TSxVQUY0QixXQUU1QkEsVUFGNEI7QUFBQSxnQkFFaEI2L0IsWUFGZ0IsV0FFaEJBLFlBRmdCO0FBQUEsZ0JBRUYzL0IsVUFGRSxXQUVGQSxVQUZFO0FBQUEsZ0JBR2hDd2IsSUFIZ0MsR0FHekJta0IsYUFBYW5rQixJQUFiLEdBQW9CbWtCLGFBQWFua0IsSUFBakMsR0FBd0MsVUFIZjtBQUFBLGdCQUloQzFrQixFQUpnQyxHQUkzQnNJLE9BQU9VLFVBQVAsQ0FKMkI7O0FBS3BDLGdCQUFJLENBQUNoSixFQUFMLEVBQVM7QUFDTDdGLDBCQUFJd0MsT0FBSiwrQ0FBdURxTSxVQUF2RDtBQUNIO0FBQ0QsZ0JBQUkwYixTQUFTLFVBQWIsRUFBeUI7QUFDckIsb0JBQUk2TyxPQUFKLEVBQWE7QUFDVDRDLG9DQUFnQjk2QixJQUFoQixDQUFxQjJFLEVBQXJCO0FBQ0gsaUJBRkQsTUFFTztBQUNIaEYsd0JBQUltN0IsZ0JBQWdCNTBCLE9BQWhCLENBQXdCdkIsRUFBeEIsQ0FBSjtBQUNBbTJCLG9DQUFnQjFxQixNQUFoQixDQUF1QnpRLENBQXZCLEVBQTBCLENBQTFCO0FBQ0g7QUFDSixhQVBELE1BT08sSUFBSXU0QixPQUFKLEVBQWE7QUFDaEI0QyxrQ0FBa0IsQ0FBQ24yQixFQUFELENBQWxCO0FBQ0g7QUFDRCxnQkFBTTQ2QyxVQUFVVixPQUFPaHhDLFdBQVc4SSxNQUFYLENBQWtCO0FBQUEsdUJBQVFta0IsZ0JBQWdCNTBCLE9BQWhCLENBQXdCN0IsS0FBS3NKLFVBQUwsQ0FBeEIsSUFBNEMsQ0FBQyxDQUFyRDtBQUFBLGFBQWxCLENBQVAsRUFBa0ZBLFVBQWxGLENBQWhCO0FBQ0EsZ0JBQUksT0FBTzYvQixhQUFhNzZCLFFBQXBCLEtBQWlDLFVBQXJDLEVBQWlEO0FBQzdDNjZCLDZCQUFhNzZCLFFBQWIsQ0FBc0J1bEIsT0FBdEIsRUFBK0JqckIsTUFBL0IsRUFBdUNzeUMsT0FBdkM7QUFDSDs7QUFFRCxpQkFBS0UsZ0JBQUwsQ0FBc0JqUyxZQUF0QixFQUFvQzFTLGVBQXBDLEVBQXFEeWtCLE9BQXJEOztBQUVBbDlDLGNBQUV3SSxlQUFGO0FBQ0gsU0F6THdDOztBQUFBLGlDQTBMekM0MEMsZ0JBMUx5Qyw2QkEwTHhCalMsWUExTHdCLEVBMExWMVMsZUExTFUsRUEwTE95a0IsT0ExTFAsRUEwTGdCO0FBQ3JELGdCQUFJLEVBQUUscUJBQXFCL1IsWUFBdkIsQ0FBSixFQUEwQztBQUN0QyxxQkFBS2h0QixRQUFMLENBQWM7QUFDVnNhO0FBRFUsaUJBQWQ7QUFHSDtBQUNELGdCQUFJLE9BQU8wUyxhQUFhclYsUUFBcEIsS0FBaUMsVUFBckMsRUFBaUQ7QUFDN0NxViw2QkFBYXJWLFFBQWIsQ0FBc0IyQyxlQUF0QixFQUF1Q3lrQixPQUF2QztBQUNIO0FBQ0osU0FuTXdDOztBQUFBLGlDQXFNekNKLGNBck15QywyQkFxTTFCdHhDLFVBck0wQixFQXFNZDtBQUN2QixnQkFBSW5GLE1BQU1tRixVQUFWO0FBRHVCLGdCQUVmNnhDLFVBRmUsR0FFQSxLQUFLOXZDLE9BRkwsQ0FFZjh2QyxVQUZlOzs7QUFJdkIsZ0JBQUlBLFVBQUosRUFBZ0I7QUFDWmgzQyxzQkFBTSxFQUFOO0FBRFksb0JBRUpzekIsb0JBRkksR0FFbUMwakIsVUFGbkMsQ0FFSjFqQixvQkFGSTtBQUFBLG9CQUVrQkMsWUFGbEIsR0FFbUN5akIsVUFGbkMsQ0FFa0J6akIsWUFGbEI7O0FBR1pwdUIsMkJBQVc1SCxPQUFYLENBQW1CLGdCQUFRO0FBQ3ZCLHdCQUFNdkQsV0FBVzJCLEtBQUszQixRQUF0QjtBQUNBO0FBQ0E7QUFDQSx3QkFBSXU1QixZQUFKLEVBQWtCO0FBQ2R2ekIsNEJBQUkxSSxJQUFKLENBQVNxRSxJQUFUO0FBQ0g7QUFDRCx3QkFBSTNCLFlBQVlzNUIsb0JBQWhCLEVBQXNDO0FBQ2xDdHpCLDhCQUFNQSxJQUFJdEQsTUFBSixDQUFXMUMsUUFBWCxDQUFOO0FBQ0g7QUFDSixpQkFWRDtBQVdIO0FBQ0QsbUJBQU9nRyxHQUFQO0FBQ0gsU0F6TndDOztBQUFBLGlDQTJOekNuRyxNQTNOeUMscUJBMk5oQztBQUNMO0FBREssMEJBRW1ELEtBQUtyQixLQUZ4RDtBQUFBLGdCQUVDc3NDLFlBRkQsV0FFQ0EsWUFGRDtBQUFBLGdCQUVlLy9CLFVBRmYsV0FFZUEsVUFGZjtBQUFBLGdCQUUyQi9LLFFBRjNCLFdBRTJCQSxRQUYzQjtBQUFBLGdCQUV3Q3VHLE1BRnhDOztBQUlMLGdCQUFJdWtDLFlBQUosRUFBa0I7QUFDZDlxQywyQkFBVyxLQUFLaXBDLGlCQUFMLENBQXVCanBDLFFBQXZCLENBQVg7QUFDQStLLDBDQUFrQkEsVUFBbEI7QUFDQUEsMkJBQVdPLEdBQVgsR0FBaUJQLFdBQVdPLEdBQVgsSUFBa0I2c0IsYUFBbkM7QUFDSDtBQUNELG1CQUFRO0FBQUMsNkJBQUQ7QUFBQSw2QkFBbUI1eEIsTUFBbkIsSUFBMkIsWUFBWXdFLFVBQXZDO0FBQ0gvSztBQURHLGFBQVI7QUFHSCxTQXZPd0M7O0FBQUE7QUFBQSxNQUVoQm1NLGdCQUFNbE0sU0FGVSxVQUdsQ2s0QixZQUhrQyxHQUduQkEsYUFIbUIsU0FJbENqNEIsU0FKa0M7QUFLckM7Ozs7Ozs7OztBQVNBNHFDLHNCQUFjM3FDLG9CQUFVakYsTUFkYTtBQWVyQytQLG9CQUFZOUssb0JBQVVDLE1BZmU7QUFnQnJDK0ssb0JBQVloTCxvQkFBVWtNLEtBaEJlO0FBaUJyQzg5QiwwQkFBa0JocUMsb0JBQVVrTTtBQWpCUyxPQWtCbEMrdEMsY0FBY2w2QyxTQWxCb0IsVUFxQmxDSyxZQXJCa0MsZ0JBc0JsQzY1QyxjQUFjNzVDLFlBdEJvQjtBQXVCckM3QixnQkFBUTBzQyxlQUFLeDNCLEtBdkJ3QjtBQXdCckMzSSxvQkFBWSxJQXhCeUI7QUF5QnJDeE0sZ0JBQVE7QUF6QjZCLGVBNEJsQzBQLFlBNUJrQyxHQTRCbkI7QUFDbEI2dUMsb0JBQVk3OEMsb0JBQVVpTTtBQURKLEtBNUJtQixTQWdDbEM1TCxpQkFoQ2tDLEdBZ0NkO0FBQ3ZCc3FDLHNCQUFjM3FDLG9CQUFVakYsTUFERDtBQUV2Qms5Qix5QkFBaUJqNEIsb0JBQVVrTTtBQUZKLEtBaENjO0FBRXZDaXdDLGtCQUZ1Qzs7QUF5TzdDLHdCQUFRQSxjQUFSLEVBQXdCbEMsYUFBeEI7QUFDQSxXQUFPa0MsY0FBUDtBQUNIOzs7Ozs7Ozs7Ozs7OztrQkM3UHVCdHdDLFE7O0FBWHhCOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7OztBQUVBLElBQU0vQixPQUFPLFNBQVBBLElBQU8sR0FBTSxDQUFHLENBQXRCOztBQUVlLFNBQVMrQixRQUFULENBQWtCb3VDLGFBQWxCLEVBQWlDO0FBQUE7O0FBQzVDO0FBRDRDLFFBRXRDNkMsYUFGc0M7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQSxnS0ErRHhDejFDLEtBL0R3QyxHQStEaEM7QUFDSml4Qiw2QkFBYSxNQUFLajZCLEtBQUwsQ0FBV2k2QixXQUFYLElBQTBCO0FBRG5DLGFBL0RnQyxRQW9GeEMyaUIsZUFwRndDLEdBb0Z0QixVQUFDaDFDLEtBQUQsRUFBUW1FLE1BQVIsRUFBZ0JDLEtBQWhCLEVBQXVCN0ssQ0FBdkIsRUFBNkI7QUFDM0NBLGtCQUFFMkksY0FBRjtBQUNBM0ksa0JBQUV3SSxlQUFGOztBQUVBLG9CQUFJeEksRUFBRXVRLE9BQUYsS0FBY3ZULGNBQVFtZCxLQUExQixFQUFpQztBQUM3QiwwQkFBS29qQyxlQUFMLENBQXFCOTJDLEtBQXJCLEVBQTRCbUUsTUFBNUIsRUFBb0NDLEtBQXBDLEVBQTJDN0ssQ0FBM0M7QUFDSDtBQUNKLGFBM0Z1QyxRQTZGeEN3OUMsa0JBN0Z3QyxHQTZGbkIsVUFBQy8yQyxLQUFELEVBQVFvRSxLQUFSLEVBQWVELE1BQWYsRUFBMEI7QUFBQTs7QUFBQSxrQ0FDSyxNQUFLL0wsS0FEVjtBQUFBLG9CQUNuQ29zQyxtQkFEbUMsZUFDbkNBLG1CQURtQztBQUFBLG9CQUNkbnNDLE1BRGMsZUFDZEEsTUFEYztBQUFBLG9CQUNOQyxNQURNLGVBQ05BLE1BRE07QUFFckMsb0JBQUUrNUIsV0FBRixHQUFrQixNQUFLanhCLEtBQXZCLENBQUVpeEIsV0FBRjtBQUFBLG9CQUNBeHRCLFVBREEsR0FDZSxNQUFLek0sS0FEcEIsQ0FDQXlNLFVBREE7QUFBQSxvQkFFRnl3QyxXQUZFLEdBRVlqakIsWUFBWWoxQixPQUFaLENBQW9CK0csT0FBT1UsVUFBUCxDQUFwQixJQUEwQyxDQUFDLENBRnZEO0FBQUEsb0JBR0ZteUMsVUFIRSxHQUdXMUIsY0FDVCw4QkFBQyxjQUFELElBQU0sTUFBSyxPQUFYLEVBQW1CLE1BQUssSUFBeEIsR0FEUyxHQUN5Qiw4QkFBQyxjQUFELElBQU0sTUFBSyxLQUFYLEVBQWlCLE1BQUssSUFBdEIsR0FKcEM7QUFBQSxvQkFNRnB1QyxLQU5FLEdBTU1zOUIsb0JBQW9CcmdDLE1BQXBCLEVBQTRCQyxLQUE1QixLQUFzQyxFQU41Qzs7QUFPTixvQkFBTTBELE1BQU0seURBQ0p6UCxNQURJLDRCQUMwQixJQUQxQixjQUVSMkksUUFGUSxHQUVFa0csTUFBTWxHLFFBRlIsY0FHUGtHLE1BQU1sSixTQUhDLElBR1drSixNQUFNbEosU0FIakIsZUFBWjs7QUFNQSxvQkFBSSxDQUFDa0osTUFBTWxHLFFBQVgsRUFBcUI7QUFDakJrRywwQkFBTWpGLE9BQU4sR0FBZ0IsTUFBSzYwQyxlQUFMLENBQXFCaHhDLElBQXJCLFFBQWdDOUYsS0FBaEMsRUFBdUNtRSxNQUF2QyxFQUErQ0MsS0FBL0MsQ0FBaEI7QUFDSDtBQUNELHVCQUNJO0FBQUE7QUFBQSxpQ0FBVThDLEtBQVY7QUFDSSw4QkFBSyxRQURUO0FBRUksa0NBQVMsR0FGYjtBQUdJLG1DQUFXLE1BQUs4dEMsZUFBTCxDQUFxQmx2QyxJQUFyQixRQUFnQzlGLEtBQWhDLEVBQXVDbUUsTUFBdkMsRUFBK0NDLEtBQS9DLENBSGY7QUFJSSxzQ0FBWWt4QyxjQUFjaDlDLE9BQU9zTixRQUFyQixHQUFnQ3ROLE9BQU9zVixNQUp2RDtBQUtJLHlDQUFlMG5DLFdBTG5CO0FBTUksbUNBQVd4dEMsR0FOZjtBQU9La3ZDO0FBUEwsaUJBREo7QUFXSCxhQTFIdUM7QUFBQTs7QUFBQSxnQ0FtRXhDNytDLGVBbkV3Qyw4QkFtRXRCO0FBQ2QsbUJBQU87QUFDSGs2Qiw2QkFBYSxLQUFLanhCLEtBQUwsQ0FBV2l4QixXQURyQjtBQUVIRixtQ0FBbUIsS0FBSy81QixLQUFMLENBQVcrNUIsaUJBRjNCO0FBR0hDLG1DQUFtQixLQUFLaDZCLEtBQUwsQ0FBV2c2QjtBQUgzQixhQUFQO0FBS0gsU0F6RXVDOztBQUFBLGdDQTJFeENuNUIseUJBM0V3QyxzQ0EyRWRDLFNBM0VjLEVBMkVIO0FBQ2pDLGdCQUFJLGlCQUFpQkEsU0FBckIsRUFBZ0M7QUFBQSxvQkFDcEJtNUIsV0FEb0IsR0FDSm41QixTQURJLENBQ3BCbTVCLFdBRG9COztBQUU1QixxQkFBSzNhLFFBQUwsQ0FBYztBQUNWMmE7QUFEVSxpQkFBZDtBQUdIO0FBQ0osU0FsRnVDOztBQUFBLGdDQTRIeEN5a0IsZUE1SHdDLDRCQTRIeEI5MkMsS0E1SHdCLEVBNEhqQm1FLE1BNUhpQixFQTRIVHROLENBNUhTLEVBNEhOMEMsQ0E1SE0sRUE0SEg7QUFDM0Isd0NBQWtCLEtBQUs2SCxLQUFMLENBQVdpeEIsV0FBN0I7QUFBQSxnQkFDQXh0QixVQURBLEdBQ2UsS0FBS3pNLEtBRHBCLENBQ0F5TSxVQURBO0FBQUEsZ0JBRUZoSixFQUZFLEdBRUdzSSxPQUFPVSxVQUFQLENBRkg7QUFBQSxnQkFHRlQsS0FIRSxHQUdNaXVCLFlBQVlqMUIsT0FBWixDQUFvQnZCLEVBQXBCLENBSE47O0FBSU4sZ0JBQUl1SSxRQUFRLENBQUMsQ0FBYixFQUFnQjtBQUNaaXVCLDRCQUFZL3FCLE1BQVosQ0FBbUJsRCxLQUFuQixFQUEwQixDQUExQjtBQUNILGFBRkQsTUFFTztBQUNIaXVCLDRCQUFZbjdCLElBQVosQ0FBaUIyRSxFQUFqQjtBQUNIO0FBQ0QsZ0JBQUksRUFBRSxpQkFBaUIsS0FBS3pELEtBQXhCLENBQUosRUFBb0M7QUFDaEMscUJBQUtzZixRQUFMLENBQWM7QUFDVjJhLGlDQUFhQTtBQURILGlCQUFkO0FBR0g7QUFDRCxpQkFBS2o2QixLQUFMLENBQVdnK0IsU0FBWCxDQUFxQi9ELFdBQXJCLEVBQWtDeDJCLEVBQWxDLEVBQXNDdUksVUFBVSxDQUFDLENBQWpELEVBQW9ERCxNQUFwRDtBQUNBNUssY0FBRXdJLGVBQUY7QUFDSCxTQTdJdUM7O0FBQUEsZ0NBK0l4QzhnQyxpQkEvSXdDLDhCQStJdEJqcEMsUUEvSXNCLEVBK0laO0FBQ3hCLGdCQUFNcTlDLGtCQUFrQnY5QyxnQkFBUzRCLEdBQVQsQ0FBYTFCLFFBQWIsRUFBdUIsVUFBQzZJLEtBQUQsRUFBUTJCLEtBQVI7QUFBQSx1QkFBa0IyQixnQkFBTTJDLFlBQU4sQ0FBbUJqRyxLQUFuQixFQUEwQjtBQUN2RmxMLHlCQUFLNk07QUFEa0YsaUJBQTFCLENBQWxCO0FBQUEsYUFBdkIsQ0FBeEI7QUFEd0IsZ0JBSWpCL0wsTUFKaUIsR0FJUCxLQUFLRCxLQUpFLENBSWpCQyxNQUppQjs7QUFLeEI0K0MsNEJBQWdCaDhCLE9BQWhCLENBQXdCLDhCQUFDLGdCQUFELElBQUssT0FBTSxFQUFYLEVBQWMsS0FBSSxVQUFsQixFQUE2QixNQUFNLEtBQUs4N0Isa0JBQUwsQ0FBd0JqeEMsSUFBeEIsQ0FBNkIsSUFBN0IsQ0FBbkMsRUFBdUUsT0FBTyxFQUE5RSxFQUFrRixXQUFjek4sTUFBZCxtQkFBbEYsRUFBd0gsa0JBQXhILEdBQXhCO0FBQ0EsbUJBQU80K0MsZUFBUDtBQUNILFNBdEp1Qzs7QUFBQSxnQ0F3SnhDeEMsbUJBeEp3QyxnQ0F3SnBCTixFQXhKb0IsRUF3SmhCO0FBQ3BCLGdCQUFNdjBDLE1BQU0sRUFBWjtBQUNBdTBDLGVBQUdoM0MsT0FBSCxDQUFXLGdCQUFRO0FBQ2Ysb0JBQU0rNUMsd0JBQWdCMzdDLElBQWhCLENBQU47QUFDQTI3Qyx5QkFBU3J4QyxVQUFULEdBQXNCLElBQXRCO0FBQ0FqRyxvQkFBSTFJLElBQUosQ0FBU3FFLElBQVQsRUFBZTI3QyxRQUFmO0FBQ0gsYUFKRDtBQUtBLG1CQUFPdDNDLEdBQVA7QUFDSCxTQWhLdUM7O0FBQUEsZ0NBa0t4Q25HLE1BbEt3QyxxQkFrSy9CO0FBQ0w7QUFESyx5QkFFNEssS0FBS3JCLEtBRmpMO0FBQUEsZ0JBRUN1TSxVQUZELFVBRUNBLFVBRkQ7QUFBQSxnQkFFYTB0QixXQUZiLFVBRWFBLFdBRmI7QUFBQSxnQkFFMEJGLGlCQUYxQixVQUUwQkEsaUJBRjFCO0FBQUEsZ0JBRTZDb1Msa0JBRjdDLFVBRTZDQSxrQkFGN0M7QUFBQSxnQkFFaUUzcUMsUUFGakUsVUFFaUVBLFFBRmpFO0FBQUEsZ0JBRTJFbUwsVUFGM0UsVUFFMkVBLFVBRjNFO0FBQUEsZ0JBRXVGeS9CLG1CQUZ2RixVQUV1RkEsbUJBRnZGO0FBQUEsZ0JBRTRHcFMsaUJBRjVHLFVBRTRHQSxpQkFGNUc7QUFBQSxnQkFFK0hnRSxTQUYvSCxVQUUrSEEsU0FGL0g7QUFBQSxnQkFFMElxTyxrQkFGMUksVUFFMElBLGtCQUYxSTtBQUFBLGdCQUVpS3RrQyxNQUZqSzs7QUFHTCxnQkFBSWd5QixxQkFBcUIsQ0FBQ3h0QixXQUFXTyxHQUFyQyxFQUEwQztBQUN0Q1AsMENBQWlCQSxVQUFqQjtBQUNBQSwyQkFBV08sR0FBWCxHQUFpQkMsYUFBakI7QUFDQUosNkJBQWEsS0FBSzB2QyxtQkFBTCxDQUF5QjF2QyxVQUF6QixDQUFiO0FBQ0g7QUFDRCxnQkFBSW90QixxQkFBcUJvUyxrQkFBekIsRUFBNkM7QUFDekMzcUMsMkJBQVcsS0FBS2lwQyxpQkFBTCxDQUF1QmpwQyxRQUF2QixDQUFYO0FBQ0g7O0FBRUQsbUJBQVE7QUFBQyw2QkFBRDtBQUFBLDZCQUFtQnVHLE1BQW5CLElBQTJCLFlBQVk0RSxVQUF2QyxFQUFvRCxZQUFZSixVQUFoRTtBQUNIL0s7QUFERyxhQUFSO0FBR0gsU0FqTHVDOztBQUFBO0FBQUEsTUFFaEJtTSxnQkFBTWxNLFNBRlUsVUFHakNvNEIsV0FIaUMsR0FHbkI5c0IsYUFIbUIsU0FJakNyTCxTQUppQztBQUtwQzs7Ozs7O0FBTUFxNEIsMkJBQW1CcDRCLG9CQUFVaEUsSUFYTztBQVlwQzs7O0FBR0FxOEIsMkJBQW1CcjRCLG9CQUFVa00sS0FmTztBQWdCcEM7OztBQUdBb3NCLHFCQUFhdDRCLG9CQUFVa00sS0FuQmE7QUFvQnBDOzs7QUFHQXMrQiw0QkFBb0J4cUMsb0JBQVVFLElBdkJNO0FBd0JwQzs7O0FBR0F1cUMsNkJBQXFCenFDLG9CQUFVaEUsSUEzQks7QUE0QnBDOzs7Ozs7O0FBT0FxZ0MsbUJBQVdyOEIsb0JBQVVoRSxJQW5DZTtBQW9DcEM7Ozs7OztBQU1BMHVDLDRCQUFvQjFxQyxvQkFBVWhFLElBMUNNO0FBMkNwQ3VDLGdCQUFReUIsb0JBQVVqRjtBQTNDa0IsT0E0Q2pDay9DLGNBQWNsNkMsU0E1Q21CLFVBK0NqQ0ssWUEvQ2lDLGdCQWdEakM2NUMsY0FBYzc1QyxZQWhEbUI7QUFpRHBDcXFDLDZCQUFxQjNnQyxJQWpEZTtBQWtEcEN1eUIsbUJBQVd2eUIsSUFsRHlCO0FBbURwQzBnQyw0QkFBb0IsSUFuRGdCO0FBb0RwQzUvQixvQkFBWSxFQXBEd0I7QUFxRHBDeXRCLDJCQUFtQixDQUFDLENBQUQsRUFBSSxDQUFKLENBckRpQjtBQXNEcEMvNUIsZ0JBQVE7QUF0RDRCLGVBeURqQytCLGlCQXpEaUMsR0F5RGI7QUFDdkJpNEIscUJBQWF0NEIsb0JBQVVrTSxLQURBO0FBRXZCa3NCLDJCQUFtQnA0QixvQkFBVWhFLElBRk47QUFHdkJxOEIsMkJBQW1CcjRCLG9CQUFVa007QUFITixLQXpEYTtBQUV0QzR3QyxpQkFGc0M7O0FBbUw1Qyx3QkFBUUEsYUFBUixFQUF1QjdDLGFBQXZCO0FBQ0EsV0FBTzZDLGFBQVA7QUFDSDs7Ozs7Ozs7Ozs7Ozs7a0JDeEx1QmxoQixPOztBQVJ4Qjs7OztBQUNBOztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNOXhCLE9BQU8sU0FBUEEsSUFBTyxHQUFNLENBQUcsQ0FBdEI7QUFDZSxTQUFTOHhCLE9BQVQsQ0FBaUJxZSxhQUFqQixFQUFnQztBQUFBOztBQUFBLFFBQ3JDbUQsWUFEcUM7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQSxnS0F5Q3ZDLzFDLEtBekN1QyxHQXlDL0I7QUFDSjJqQywyQkFBVyxNQUFLM3NDLEtBQUwsQ0FBVzJzQyxTQURsQjtBQUVKcVMsNkJBQWEsTUFBS2gvQyxLQUFMLENBQVdnL0MsV0FGcEI7QUFHSnJsQyx3QkFBUSxNQUFLM1osS0FBTCxDQUFXMDZCO0FBSGYsYUF6QytCLFFBd012Q0QsUUF4TXVDLEdBd001QixZQUFNO0FBQ2I7QUFDQSxvQkFBTW54QixZQUFZLE1BQUttMEMsUUFBTCxDQUFjbjBDLFNBQWhDO0FBQ0Esb0JBQUlBLGNBQWMsTUFBSzIxQyxhQUF2QixFQUFzQztBQUNsQztBQUNIO0FBQ0Qsb0JBQU1DLFFBQVEsTUFBS0Msa0JBQUwsQ0FBd0I3MUMsU0FBeEIsQ0FBZDtBQUNBLG9CQUFJLEVBQUUsaUJBQWlCLE1BQUt0SixLQUF4QixDQUFKLEVBQW9DO0FBQ2hDLDBCQUFLc2YsUUFBTCxDQUFjO0FBQ1YwL0IscUNBQWFFO0FBREgscUJBQWQ7QUFHSDtBQUNELHNCQUFLbC9DLEtBQUwsQ0FBV3c2QixZQUFYLENBQXdCMGtCLEtBQXhCO0FBQ0Esc0JBQUtELGFBQUwsR0FBcUIzMUMsU0FBckI7QUFDSCxhQXROc0MsUUErTnZDODFDLFdBL051QyxHQStOekIsVUFBQzN1QyxJQUFELEVBQU9oQyxRQUFQLEVBQW9CO0FBQzlCQSwyQkFBV0EsV0FBV0EsU0FBUzJ1QyxNQUFULENBQWdCLENBQWhCLEVBQW1CdmlDLFdBQW5CLEtBQW1DcE0sU0FBUzR1QyxNQUFULENBQWdCLENBQWhCLENBQTlDLEdBQW1FLEVBQTlFO0FBQ0EsK0JBQVk1dUMsUUFBWixhQUE4QmdDLElBQTlCO0FBQ0gsYUFsT3NDLFFBb092QzY1QixnQkFwT3VDLEdBb09wQixVQUFDNWtDLElBQUQsRUFBTzI1QyxRQUFQLEVBQW9CO0FBQ25DMzVDLHVCQUFPQSxPQUFPQSxLQUFLMDNDLE1BQUwsQ0FBWSxDQUFaLEVBQWV2aUMsV0FBZixLQUErQm5WLEtBQUsyM0MsTUFBTCxDQUFZLENBQVosQ0FBdEMsR0FBdUQsRUFBOUQ7QUFDQSxnQ0FBYTMzQyxJQUFiLFlBQTBCMjVDLFFBQTFCO0FBQ0gsYUF2T3NDO0FBQUE7O0FBQUEsK0JBK0N2Q3QvQyxlQS9DdUMsOEJBK0NyQjtBQUNkLG1CQUFPO0FBQ0h1L0MsaUNBQWlCLEtBQUs3a0IsUUFEbkI7QUFFSDhrQiw0QkFBWSxLQUFLQyxpQkFBTCxFQUZUO0FBR0hDLDBCQUFVLEtBQUtDLGVBQUwsRUFIUDtBQUlITiw2QkFBYSxLQUFLQSxXQUpmO0FBS0g3VSw0Q0FBNEIsS0FBS0QsZ0JBTDlCO0FBTUhnQyw4QkFBYyxLQUFLQTtBQU5oQixhQUFQO0FBUUgsU0F4RHNDOztBQUFBLCtCQTBEdkMzckMsa0JBMUR1QyxpQ0EwRGxCO0FBQUEseUJBQ2tCLEtBQUtYLEtBRHZCO0FBQUEsZ0JBQ1Qwc0MsVUFEUyxVQUNUQSxVQURTO0FBQUEsZ0JBQ0cvL0IsVUFESCxVQUNHQSxVQURIOzs7QUFHakIsaUJBQUtnekMsY0FBTCxHQUF1QmpULGNBQWMvL0IsVUFBZCxJQUE0QkEsV0FBV2hPLE1BQVgsR0FBb0IsQ0FBdkU7QUFDSCxTQTlEc0M7O0FBQUEsK0JBZ0V2Q3VKLGlCQWhFdUMsZ0NBZ0VuQjs7QUFFaEIsZ0JBQUksS0FBS3kzQyxjQUFULEVBQXlCO0FBQ3JCLHFCQUFLVixhQUFMLEdBQXFCLEtBQUt4QixRQUFMLENBQWNuMEMsU0FBbkM7QUFDSDs7QUFFRCxpQkFBS3MyQyxlQUFMO0FBQ0EsaUJBQUtDLFVBQUw7QUFDQSxpQkFBS0MsYUFBTDtBQUNILFNBekVzQzs7QUFBQSwrQkEyRXZDai9DLHlCQTNFdUMsc0NBMkViQyxTQTNFYSxFQTJFRjtBQUFBLGdCQUN6QjRyQyxVQUR5QixHQUNFNXJDLFNBREYsQ0FDekI0ckMsVUFEeUI7QUFBQSxnQkFDYi8vQixVQURhLEdBQ0U3TCxTQURGLENBQ2I2TCxVQURhOzs7QUFHakMsaUJBQUtnekMsY0FBTCxHQUF1QmpULGNBQWMvL0IsVUFBZCxJQUE0QkEsV0FBV2hPLE1BQVgsR0FBb0IsQ0FBdkU7O0FBRUEsZ0JBQUksbUJBQW1CbUMsU0FBdkIsRUFBa0M7QUFDOUIsb0JBQUksS0FBS2tJLEtBQUwsQ0FBVzJRLE1BQVgsS0FBc0I3WSxVQUFVNDVCLGFBQXBDLEVBQW1EO0FBQy9DLHlCQUFLcGIsUUFBTCxDQUFjO0FBQ1YzRixnQ0FBUTdZLFVBQVU0NUI7QUFEUixxQkFBZDtBQUdIO0FBQ0o7O0FBRUQsZ0JBQUksaUJBQWlCNTVCLFNBQXJCLEVBQWdDO0FBQzVCLHFCQUFLd2UsUUFBTCxDQUFjO0FBQ1YwL0IsaUNBQWFsK0MsVUFBVWsrQztBQURiLGlCQUFkO0FBR0g7O0FBRUQsZ0JBQUksS0FBS2gyQyxLQUFMLENBQVcyakMsU0FBWCxJQUF3QixlQUFlN3JDLFNBQTNDLEVBQXNEO0FBQ2xELG9CQUFNOEssTUFBTSxLQUFLbTBDLFVBQUwsRUFBWjtBQUNBLG9CQUFNQyxrQkFBa0JwMEMsT0FBT0EsSUFBSXhDLFlBQW5DO0FBQ0Esb0JBQUk0MkMsbUJBQW1CQSxvQkFBb0IsS0FBS2gzQyxLQUFMLENBQVcyakMsU0FBdEQsRUFBaUU7QUFDN0QseUJBQUtydEIsUUFBTCxDQUFjO0FBQ1ZxdEIsbUNBQVdxVDtBQURELHFCQUFkO0FBR0g7QUFDSjtBQUVKLFNBeEdzQzs7QUFBQSwrQkEwR3ZDai9DLGtCQTFHdUMsaUNBMEdsQjtBQUNqQixpQkFBSzYrQyxlQUFMO0FBQ0EsaUJBQUtDLFVBQUw7QUFDQSxpQkFBS0MsYUFBTDtBQUNILFNBOUdzQzs7QUFBQSwrQkFnSHZDQSxhQWhIdUMsNEJBZ0h2QjtBQUFBLGdCQUNKblQsU0FESSxHQUNVLEtBQUszakMsS0FEZixDQUNKMmpDLFNBREk7O0FBRVosZ0JBQUksT0FBT0EsU0FBUCxLQUFxQixVQUFyQixJQUFtQyxLQUFLZ1QsY0FBNUMsRUFBNEQ7QUFDeEQsb0JBQU0vekMsTUFBTSxLQUFLbTBDLFVBQUwsRUFBWjtBQUNBLG9CQUFNQyxrQkFBa0JwMEMsT0FBT0EsSUFBSXhDLFlBQW5DO0FBQ0Esb0JBQUk0MkMsb0JBQW9CLEtBQUtoM0MsS0FBTCxDQUFXMmpDLFNBQW5DLEVBQThDO0FBQzFDLHlCQUFLcnRCLFFBQUwsQ0FBYztBQUNWcXRCLG1DQUFXcVQ7QUFERCxxQkFBZDtBQUdIO0FBQ0o7QUFDSixTQTNIc0M7O0FBQUEsK0JBNkh2Q1IsaUJBN0h1QyxnQ0E2SG5CO0FBQUEsZ0JBQ1I3UyxTQURRLEdBQ00sS0FBSzNqQyxLQURYLENBQ1IyakMsU0FEUTtBQUFBLGdCQUVSaGdDLFVBRlEsR0FFTyxLQUFLM00sS0FGWixDQUVSMk0sVUFGUTs7QUFHaEIsZ0JBQUksT0FBT2dnQyxTQUFQLEtBQXFCLFVBQXpCLEVBQXFDO0FBQ2pDLHVCQUFPLENBQVA7QUFDSDtBQUNELG1CQUFPaGdDLFdBQVdoTyxNQUFYLEdBQW9CZ3VDLFNBQTNCO0FBQ0gsU0FwSXNDOztBQUFBLCtCQXNJdkMrUyxlQXRJdUMsOEJBc0lyQjtBQUFBLGdCQUNOL1MsU0FETSxHQUNRLEtBQUszakMsS0FEYixDQUNOMmpDLFNBRE07O0FBRWQsZ0JBQUksT0FBT0EsU0FBUCxLQUFxQixVQUF6QixFQUFxQztBQUNqQyx1QkFBTyxDQUFQO0FBQ0g7QUFDRCxtQkFBUSxLQUFLdVMsS0FBTCxHQUFhdlMsU0FBckI7QUFDSCxTQTVJc0M7O0FBQUEsK0JBOEl2Q3NULGVBOUl1Qyw0QkE4SXZCQyxXQTlJdUIsRUE4SVY7QUFBQSx5QkFDSyxLQUFLbDNDLEtBRFY7QUFBQSxnQkFDakIyUSxNQURpQixVQUNqQkEsTUFEaUI7QUFBQSxnQkFDVGd6QixTQURTLFVBQ1RBLFNBRFM7O0FBRXpCLGdCQUFNdmxDLE1BQU0sS0FBS3BILEtBQUwsQ0FBVzJNLFVBQVgsQ0FBc0JoTyxNQUFsQzs7QUFFQSxnQkFBSXFpQixZQUFKO0FBQUEsZ0JBQVNtL0IsZUFBZSxDQUF4QjtBQUNBLGdCQUFJakIsUUFBUSxDQUFaO0FBQ0EsZ0JBQUksT0FBT3ZTLFNBQVAsS0FBcUIsVUFBekIsRUFBcUM7QUFDakM7QUFDQTNyQixzQkFBTSxDQUFOO0FBQ0gsYUFIRCxNQUdPO0FBQ0htL0IsK0JBQWU3WCxTQUFTM3VCLFNBQVNnekIsU0FBbEIsRUFBNkIsRUFBN0IsQ0FBZjs7QUFFQSxvQkFBSSxhQUFhLE9BQU91VCxXQUF4QixFQUFxQztBQUNqQ2hCLDRCQUFRZ0IsY0FBYzk0QyxHQUFkLEdBQW9CODRDLFdBQXBCLEdBQWtDLENBQTFDO0FBQ0g7O0FBRURsL0Isc0JBQU00dEIsS0FBS3dSLEdBQUwsQ0FBUyxDQUFDbEIsS0FBRCxHQUFTLENBQVQsR0FBYWlCLFlBQWIsR0FBNEIsRUFBckMsRUFBeUMvNEMsR0FBekMsQ0FBTjtBQUNIO0FBQ0QsaUJBQUs0WixHQUFMLEdBQVdBLEdBQVg7QUFDQSxpQkFBS20vQixZQUFMLEdBQW9CQSxZQUFwQjtBQUNBLG1CQUFPO0FBQ0hqQiw0QkFERztBQUVIbCtCO0FBRkcsYUFBUDtBQUlILFNBdEtzQzs7QUFBQSwrQkF3S3ZDNCtCLGVBeEt1Qyw4QkF3S3JCO0FBQ2QsZ0JBQUksS0FBS0QsY0FBVCxFQUF5QjtBQUNyQixxQkFBS2xDLFFBQUwsQ0FBY24wQyxTQUFkLEdBQTBCLEtBQUsyMUMsYUFBTCxHQUFxQixLQUFLajJDLEtBQUwsQ0FBVzJqQyxTQUFoQyxHQUE0QyxLQUFLM2pDLEtBQUwsQ0FBVzJqQyxTQUFYLEdBQXVCLEtBQUszakMsS0FBTCxDQUFXZzJDLFdBQXhHO0FBQ0g7QUFDSixTQTVLc0M7O0FBQUEsK0JBOEt2Q2EsVUE5S3VDLHlCQThLMUI7QUFDVCxnQkFBSSxLQUFLRixjQUFULEVBQXlCO0FBQ3JCLG9CQUFNM25DLE9BQU8sS0FBS3lsQyxRQUFsQjtBQUNBLG9CQUFNNEMsb0JBQW9Ccm9DLEtBQUt2UCxhQUFMLENBQW1CLEtBQW5CLENBQTFCO0FBRnFCLG9CQUdiVyxZQUhhLEdBR2lCNE8sSUFIakIsQ0FHYjVPLFlBSGE7QUFBQSxvQkFHQzJRLFdBSEQsR0FHaUIvQixJQUhqQixDQUdDK0IsV0FIRDs7O0FBS3JCLG9CQUFNdW1DLFdBQVcsS0FBS0EsUUFBdEI7QUFDQSxvQkFBTUMsWUFBWSwyQkFBWUQsUUFBWixDQUFsQjtBQU5xQixvQkFPYnJnRCxNQVBhLEdBT0YsS0FBS0QsS0FQSCxDQU9iQyxNQVBhOztBQVFyQixvQkFBTXM5QyxhQUFhZ0QsVUFBVTkzQyxhQUFWLE9BQTRCeEksTUFBNUIsd0JBQW5CO0FBQ0Esb0JBQU11Z0Qsb0JBQW9CakQsY0FBY0EsV0FBV3hqQyxXQUFuRDs7QUFFQSxvQkFBSUEsY0FBY3ltQyxpQkFBbEIsRUFBcUM7QUFDakMvaUQsOEJBQUl5WixRQUFKLENBQWFtcEMsaUJBQWIsRUFBZ0MsV0FBaEMsRUFBNkNHLGlCQUE3QztBQUNBLHdCQUFNQyxXQUFXLEtBQUtDLFlBQXRCO0FBQ0Esd0JBQU1DLFlBQVksS0FBS0MsYUFBdkI7QUFDQUgsZ0NBQVloakQsVUFBSXlaLFFBQUosQ0FBYXVwQyxRQUFiLEVBQXVCLFlBQXZCLEVBQXFDcjNDLFlBQXJDLENBQVo7QUFDQXUzQyxpQ0FBYWxqRCxVQUFJeVosUUFBSixDQUFheXBDLFNBQWIsRUFBd0IsWUFBeEIsRUFBc0N2M0MsWUFBdEMsQ0FBYjtBQUNBLHlCQUFLeTNDLFlBQUwsR0FBb0IsSUFBcEI7QUFDSCxpQkFQRCxNQU9PO0FBQ0gseUJBQUtBLFlBQUwsR0FBb0IsS0FBcEI7QUFDSDtBQUNKO0FBRUosU0F0TXNDOztBQUFBLCtCQXdOdkMxQixrQkF4TnVDLCtCQXdOcEJqOEIsTUF4Tm9CLEVBd05aO0FBQUEsZ0JBQ2Z5cEIsU0FEZSxHQUNELEtBQUszakMsS0FESixDQUNmMmpDLFNBRGU7O0FBRXZCLGdCQUFNdVMsUUFBUTVXLFNBQVNwbEIsU0FBU3lwQixTQUFsQixDQUFkO0FBQ0EsaUJBQUt1UyxLQUFMLEdBQWFBLEtBQWI7QUFDQSxtQkFBT0EsS0FBUDtBQUNILFNBN05zQzs7QUFBQSwrQkF5T3ZDYSxVQXpPdUMseUJBeU8xQjtBQUNULGdCQUFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQU8sMkJBQVksS0FBS08sUUFBTCxDQUFjMzBDLFNBQWQsQ0FBd0IsQ0FBeEIsQ0FBWixDQUFQO0FBQ0gsYUFMRCxDQUtFLE9BQU8reUIsS0FBUCxFQUFjO0FBQ1osdUJBQU8sSUFBUDtBQUNIO0FBQ0osU0FsUHNDOztBQUFBLCtCQW9QdkNyOUIsTUFwUHVDLHFCQW9QOUI7QUFDTDtBQURLLDBCQUVzRyxLQUFLckIsS0FGM0c7QUFBQSxnQkFFQzBzQyxVQUZELFdBRUNBLFVBRkQ7QUFBQSxnQkFFYW5nQyxVQUZiLFdBRWFBLFVBRmI7QUFBQSxnQkFFeUJJLFVBRnpCLFdBRXlCQSxVQUZ6QjtBQUFBLGdCQUVxQ2d1QixXQUZyQyxXQUVxQ0EsV0FGckM7QUFBQSxnQkFFa0RnUyxTQUZsRCxXQUVrREEsU0FGbEQ7QUFBQSxnQkFFNkRxUyxXQUY3RCxXQUU2REEsV0FGN0Q7QUFBQSxnQkFFMEV4a0IsWUFGMUUsV0FFMEVBLFlBRjFFO0FBQUEsZ0JBRTJGenlCLE1BRjNGOztBQUlMLGdCQUFNNGpDLG1CQUFtQmgvQixVQUF6Qjs7QUFFQSxpQkFBSzIvQixZQUFMLEdBQW9CLEtBQUt0c0MsS0FBTCxDQUFXc3NDLFlBQS9CO0FBQ0EsZ0JBQUksS0FBS3FULGNBQVQsRUFBeUI7QUFDckJwekMsMENBQWtCQSxVQUFsQjs7QUFEcUIsdUNBRUUsS0FBSzB6QyxlQUFMLENBQXFCLEtBQUtqM0MsS0FBTCxDQUFXZzJDLFdBQWhDLENBRkY7QUFBQSxvQkFFYkUsS0FGYSxvQkFFYkEsS0FGYTtBQUFBLG9CQUVObCtCLEdBRk0sb0JBRU5BLEdBRk07O0FBR3JCclUsNkJBQWFBLFdBQVdtYyxLQUFYLENBQWlCbzJCLEtBQWpCLEVBQXdCbCtCLEdBQXhCLENBQWI7O0FBRUEsb0JBQUksQ0FBQ3pVLFdBQVdiLElBQWhCLEVBQXNCO0FBQ2xCYSwrQkFBV2IsSUFBWCxHQUFrQm8xQyxjQUFsQjtBQUNIO0FBQ0RubUIsOEJBQWMsSUFBZDtBQUNIOztBQUVELG1CQUFRLDhCQUFDLGFBQUQsZUFBbUI1eUIsTUFBbkIsSUFBMkIsWUFBWTRFLFVBQXZDLEVBQW1ELGtCQUFrQmcvQixnQkFBckUsRUFBdUYsWUFBWXAvQixVQUFuRyxFQUErRyxhQUFhb3VCLFdBQTVILElBQVI7QUFDSCxTQXZRc0M7O0FBQUE7QUFBQSxNQUNoQmh0QixnQkFBTWxNLFNBRFUsVUFFaENxL0MsV0FGZ0MsR0FFbEJBLGNBRmtCLFNBR2hDcC9DLFNBSGdDO0FBSW5DOzs7QUFHQWdyQyxvQkFBWS9xQyxvQkFBVUUsSUFQYTtBQVFuQzs7O0FBR0E4cUMsbUJBQVdockMsb0JBQVU2TyxTQUFWLENBQW9CLENBQUM3TyxvQkFBVXVKLE1BQVgsRUFBbUJ2SixvQkFBVWhFLElBQTdCLENBQXBCLENBWHdCO0FBWW5DKzhCLHVCQUFlLzRCLG9CQUFVNk8sU0FBVixDQUFvQixDQUFDN08sb0JBQVV1SixNQUFYLEVBQW1Cdkosb0JBQVVDLE1BQTdCLENBQXBCLENBWm9CO0FBYW5DNkssb0JBQVk5SyxvQkFBVUMsTUFiYTtBQWNuQytLLG9CQUFZaEwsb0JBQVVrTSxLQWRhO0FBZW5DOzs7QUFHQTJzQixzQkFBYzc0QixvQkFBVWhFO0FBbEJXLE9BbUJoQ2krQyxjQUFjbDZDLFNBbkJrQixVQXNCaENLLFlBdEJnQyxnQkF1QmhDNjVDLGNBQWM3NUMsWUF2QmtCO0FBd0JuQzBLLG9CQUFZLElBeEJ1QjtBQXlCbkNrZ0MsbUJBQVdsaEMsSUF6QndCO0FBMEJuQ2l2Qix1QkFBZSxHQTFCb0I7QUEyQm5DbnVCLG9CQUFZLEVBM0J1QjtBQTRCbkN0TSxnQkFBUSxPQTVCMkI7QUE2Qm5DdTZCLHNCQUFjL3VCO0FBN0JxQixlQWdDaEN6SixpQkFoQ2dDLEdBZ0NaO0FBQ3ZCczlDLHlCQUFpQjM5QyxvQkFBVWhFLElBREo7QUFFdkI0aEQsb0JBQVk1OUMsb0JBQVV1SixNQUZDO0FBR3ZCdTBDLGtCQUFVOTlDLG9CQUFVdUosTUFIRztBQUl2QmswQyxxQkFBYXo5QyxvQkFBVWhFLElBSkE7QUFLdkI0c0Msb0NBQTRCNW9DLG9CQUFVaEUsSUFMZjtBQU12QjJ1QyxzQkFBYzNxQyxvQkFBVWpGO0FBTkQsS0FoQ1k7QUFDckNxaUQsZ0JBRHFDOztBQXlRM0Msd0JBQVFBLFlBQVIsRUFBc0JuRCxhQUF0QjtBQUNBLFdBQU9tRCxZQUFQO0FBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDblJEOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQUVBO0lBQ3FCK0IsVzs7Ozs7Ozs7Ozs7OzRKQStCakJDLFEsR0FBVyxVQUFDL1UsS0FBRCxFQUFXO0FBQ2xCLGtCQUFLdVUsU0FBTCxHQUFpQnZVLEtBQWpCO0FBQ0gsUyxRQUVEZ1YsZ0IsR0FBbUIsVUFBQ0MsYUFBRCxFQUFtQjtBQUNsQyxrQkFBS1osaUJBQUwsR0FBeUJZLGFBQXpCO0FBQ0gsUyxRQUVEeG1CLFEsR0FBVyxZQUFNO0FBQ2I7QUFDQSxrQkFBSy9yQixPQUFMLENBQWE4ckIsWUFBYjtBQUNBO0FBQ0Esa0JBQUs5ckIsT0FBTCxDQUFhd3lDLGdCQUFiO0FBQ0E7QUFDQSxrQkFBS3h5QyxPQUFMLENBQWE0d0MsZUFBYjtBQUNILFM7OzswQkF6QkRwM0MsaUIsZ0NBQW9CO0FBQ2hCLFlBQU11MUMsV0FBVywyQkFBWSxJQUFaLENBQWpCO0FBQ0E7QUFDQSxhQUFLL3VDLE9BQUwsQ0FBYWlDLE9BQWIsQ0FBcUIsTUFBckIsRUFBNkI4c0MsUUFBN0I7QUFDQTtBQUNBLGFBQUsvdUMsT0FBTCxDQUFhMHdDLFdBQWIsQ0FBeUIzQixRQUF6QixFQUFtQyxLQUFLL3VDLE9BQUwsQ0FBYUQsUUFBaEQ7QUFDQTtBQUNBLGFBQUtDLE9BQUwsQ0FBYXl5QyxXQUFiLENBQXlCLE1BQXpCLEVBQWlDMUQsUUFBakMsRUFBMkMsS0FBSy91QyxPQUFMLENBQWFELFFBQXhEO0FBQ0gsSzs7MEJBbUJEcE4sTSxxQkFBUztBQUFBLHFCQUM4QyxLQUFLckIsS0FEbkQ7QUFBQSxZQUNHQyxNQURILFVBQ0dBLE1BREg7QUFBQSxZQUNXMkYsU0FEWCxVQUNXQSxTQURYO0FBQUEsWUFDc0J3RyxRQUR0QixVQUNzQkEsUUFEdEI7QUFBQSxZQUNtQ3JFLE1BRG5DOztBQUFBLHVCQUV5QyxLQUFLMkcsT0FGOUM7QUFBQSxZQUVFZ3NCLGFBRkYsWUFFRUEsYUFGRjtBQUFBLFlBRWlCNmtCLFVBRmpCLFlBRWlCQSxVQUZqQjtBQUFBLFlBRTZCRSxRQUY3QixZQUU2QkEsUUFGN0I7O0FBR0wsZUFBUTtBQUFBO0FBQUEsY0FBSyxPQUFPLEVBQUM3a0IsV0FBV0YsYUFBWixFQUFaLEVBQXdDLFdBQVc5MEIsU0FBbkQsRUFBOEQsVUFBVSxLQUFLNjBCLFFBQTdFO0FBQ0o7QUFBQTtBQUFBLGtCQUFLLE9BQU8sRUFBQzlnQixRQUFRNGxDLFVBQVQsRUFBcUIzbEMsVUFBVSxRQUEvQixFQUF5Q0YsVUFBVSxVQUFuRCxFQUFaLEVBQTRFLEtBQUssS0FBS3NuQyxnQkFBdEY7QUFDSTtBQUFBO0FBQUEsc0JBQUssT0FBTyxFQUFDcm5DLFFBQVEsTUFBVCxFQUFpQkQsVUFBVSxVQUEzQixFQUF1Q3loQiwyQkFBeUJza0IsUUFBekIsUUFBdkMsRUFBWjtBQUNJO0FBQUE7QUFBQSwwQkFBTyxLQUFLLEtBQUtzQixRQUFqQjtBQUNLMzBDLGdDQURMO0FBRUksc0RBQUMsY0FBRCxlQUFtQnJFLE1BQW5CLElBQTJCLFFBQVE5SCxNQUFuQztBQUZKO0FBREo7QUFESjtBQURJLFNBQVI7QUFVSCxLOzs7RUE3RG9DME4sZ0JBQU1sTSxTLFVBQ3BDQyxTLEdBQVk7QUFDZkYsY0FBVUcsb0JBQVVpTSxHQURMO0FBRWYzTixZQUFRMEIsb0JBQVVDLE1BRkg7QUFHZmdFLGVBQVdqRSxvQkFBVUMsTUFITjtBQUlmd0ssY0FBVXpLLG9CQUFVaU07QUFKTCxDLFNBT1orQixZLEdBQWU7QUFDbEIrcUIsbUJBQWUvNEIsb0JBQVU2TyxTQUFWLENBQW9CLENBQUM3TyxvQkFBVXVKLE1BQVgsRUFBbUJ2SixvQkFBVUMsTUFBN0IsQ0FBcEIsQ0FERztBQUVsQjQ0QixrQkFBYzc0QixvQkFBVWhFLElBRk47QUFHbEIyaEQscUJBQWlCMzlDLG9CQUFVaEUsSUFIVDtBQUlsQnVqRCxzQkFBa0J2L0Msb0JBQVVoRSxJQUpWO0FBS2xCNGhELGdCQUFZNTlDLG9CQUFVdUosTUFMSjtBQU1sQnUwQyxjQUFVOTlDLG9CQUFVdUosTUFORjtBQU9sQnlGLGFBQVNoUCxvQkFBVWhFLElBUEQ7QUFRbEJ5aEQsaUJBQWF6OUMsb0JBQVVoRSxJQVJMO0FBU2xCd2pELGlCQUFheC9DLG9CQUFVaEUsSUFUTDtBQVVsQjhRLGNBQVU5TSxvQkFBVW9FLEtBQVYsQ0FBZ0IsQ0FBQyxNQUFELEVBQVMsT0FBVCxDQUFoQjtBQVZRLEM7QUFSTCs2QyxXO2tCQUFBQSxXOzs7Ozs7Ozs7Ozs7OztrQkNNRzN3QyxJOztBQVp4Qjs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBRWUsU0FBU0EsSUFBVCxDQUFjeXJDLGFBQWQsRUFBNkI7QUFBQTs7QUFDeEM7QUFEd0MsUUFFbEN3RixTQUZrQztBQUFBOztBQTRCcEMsMkJBQVlwaEQsS0FBWixFQUFtQjBPLE9BQW5CLEVBQTRCO0FBQUE7O0FBQUEseURBQ3hCLDRCQUFNMU8sS0FBTixFQUFhME8sT0FBYixDQUR3Qjs7QUFBQSxrQkFvSjVCNDdCLGdCQXBKNEIsR0FvSlQsVUFBQzVrQyxJQUFELEVBQU8yNUMsUUFBUCxFQUFvQjtBQUNuQzM1Qyx1QkFBT0EsT0FBT0EsS0FBSzAzQyxNQUFMLENBQVksQ0FBWixFQUFldmlDLFdBQWYsS0FBK0JuVixLQUFLMjNDLE1BQUwsQ0FBWSxDQUFaLENBQXRDLEdBQXVELEVBQTlEO0FBQ0EsZ0NBQWEzM0MsSUFBYixZQUEwQjI1QyxRQUExQjtBQUNILGFBdkoyQjs7QUFBQSxrQkF5SjVCMXVDLE9Beko0QixHQXlKbEIsVUFBQ2pMLElBQUQsRUFBTytLLElBQVAsRUFBYWhDLFFBQWIsRUFBMEI7QUFDaENBLDJCQUFXQSxXQUFXQSxTQUFTMnVDLE1BQVQsQ0FBZ0IsQ0FBaEIsRUFBbUJ2aUMsV0FBbkIsS0FBbUNwTSxTQUFTNHVDLE1BQVQsQ0FBZ0IsQ0FBaEIsQ0FBOUMsR0FBbUUsRUFBOUU7QUFDQSwyQkFBUTMzQyxJQUFSLEdBQWUrSSxRQUFmLGFBQWlDZ0MsSUFBakM7QUFDQSxvQkFBSS9LLFNBQVMsUUFBVCxJQUFxQixDQUFDLE1BQUs0M0MsZUFBM0IsSUFBOEMsQ0FBQzd1QyxRQUFuRCxFQUE2RDtBQUN6RCwwQkFBSzZ1QyxlQUFMLEdBQXVCLE1BQUtDLFVBQUwsQ0FBZ0I5MEMsYUFBaEIsQ0FBOEIsS0FBOUIsQ0FBdkI7QUFDSDtBQUNKLGFBL0oyQjs7QUFBQSxrQkFpSzVCd0QsZUFqSzRCLEdBaUtWLFVBQUNGLE1BQUQsRUFBU0MsS0FBVCxFQUFtQjtBQUNqQyxvQkFBSSxNQUFLcTFDLE1BQUwsRUFBSixFQUFtQjtBQUNmLHdCQUFNejFDLE1BQU0sTUFBS20wQyxVQUFMLENBQWdCL3pDLEtBQWhCLENBQVo7QUFDQSx3QkFBTXMxQyxVQUFVLE1BQUt2QixVQUFMLENBQWdCL3pDLEtBQWhCLEVBQXVCLE1BQXZCLENBQWhCO0FBQ0Esd0JBQU11MUMsV0FBVyxNQUFLeEIsVUFBTCxDQUFnQi96QyxLQUFoQixFQUF1QixPQUF2QixDQUFqQjtBQUNBLHFCQUFDSixHQUFELEVBQU0wMUMsT0FBTixFQUFlQyxRQUFmLEVBQXlCeDhDLE9BQXpCLENBQWlDLGVBQU87QUFDcEM2RywrQkFBT25PLFVBQUk2USxRQUFKLENBQWExQyxHQUFiLEVBQWtCLFNBQWxCLENBQVA7QUFDSCxxQkFGRDtBQUdIO0FBQ0osYUExSzJCOztBQUFBLGtCQTRLNUJNLGVBNUs0QixHQTRLVixVQUFDSCxNQUFELEVBQVNDLEtBQVQsRUFBbUI7QUFDakMsb0JBQUksTUFBS3ExQyxNQUFMLEVBQUosRUFBbUI7QUFDZix3QkFBTXoxQyxNQUFNLE1BQUttMEMsVUFBTCxDQUFnQi96QyxLQUFoQixDQUFaO0FBQ0Esd0JBQU1zMUMsVUFBVSxNQUFLdkIsVUFBTCxDQUFnQi96QyxLQUFoQixFQUF1QixNQUF2QixDQUFoQjtBQUNBLHdCQUFNdTFDLFdBQVcsTUFBS3hCLFVBQUwsQ0FBZ0IvekMsS0FBaEIsRUFBdUIsT0FBdkIsQ0FBakI7QUFDQSxxQkFBQ0osR0FBRCxFQUFNMDFDLE9BQU4sRUFBZUMsUUFBZixFQUF5Qng4QyxPQUF6QixDQUFpQyxlQUFPO0FBQ3BDNkcsK0JBQU9uTyxVQUFJOFEsV0FBSixDQUFnQjNDLEdBQWhCLEVBQXFCLFNBQXJCLENBQVA7QUFDSCxxQkFGRDtBQUdIO0FBQ0osYUFyTDJCOztBQUFBLGtCQTJNNUI0MUMsZUEzTTRCLEdBMk1WLFVBQUNyZ0QsQ0FBRCxFQUFPO0FBQ3JCLG9CQUFNay9CLElBQUlsL0IsRUFBRXNnRCxNQUFaO0FBQ0Esb0JBQUksTUFBS0osTUFBTCxFQUFKLEVBQW1CO0FBQ1Qsd0NBQWdCLE1BQUtULGFBQXJCO0FBQUEsd0JBQ0ZjLFlBREUsR0FDYSxNQUFLaEIsWUFEbEI7QUFBQSx3QkFFRmlCLFVBRkUsR0FFVyxNQUFLbEUsUUFGaEI7QUFBQSx3QkFHQW4wQyxTQUhBLEdBRzBDcTRDLFVBSDFDLENBR0FyNEMsU0FIQTtBQUFBLHdCQUdXRixZQUhYLEdBRzBDdTRDLFVBSDFDLENBR1d2NEMsWUFIWDtBQUFBLHdCQUd5QkQsWUFIekIsR0FHMEN3NEMsVUFIMUMsQ0FHeUJ4NEMsWUFIekI7OztBQUtOLHdCQUFJdTRDLFlBQUosRUFBa0I7QUFDZEEscUNBQWFwNEMsU0FBYixHQUF5QisyQixDQUF6QjtBQUNIO0FBQ0Qsd0JBQUl1aEIsYUFBSixFQUFtQjtBQUNmQSxzQ0FBY3Q0QyxTQUFkLEdBQTBCKzJCLENBQTFCO0FBQ0g7QUFDRHNoQiwrQkFBV3I0QyxTQUFYLEdBQXVCQSxZQUFZKzJCLENBQW5DO0FBWmUsd0JBYUl3aEIsWUFiSixHQWFxQkYsVUFickIsQ0FhUHI0QyxTQWJPOztBQWNmLHdCQUFJdTRDLGVBQWV6NEMsWUFBZixHQUE4QkQsWUFBOUIsSUFBOEMwNEMsWUFBbEQsRUFBZ0U7QUFDNUQxZ0QsMEJBQUUySSxjQUFGO0FBQ0g7QUFDSjtBQUNKLGFBL04yQjs7QUFBQSxrQkFpTzVCbzNDLGdCQWpPNEIsR0FpT1QsWUFBTTtBQUNyQixvQkFBSSxNQUFLRyxNQUFMLEVBQUosRUFBbUI7QUFDZix3QkFBTU8sZ0JBQWdCLE1BQUtoQixhQUEzQjtBQUFBLHdCQUNJYyxlQUFlLE1BQUtoQixZQUR4QjtBQUFBLHdCQUVJb0IsaUJBQWlCLE1BQUtqaUMsY0FBTCxDQUFvQixPQUFwQixDQUZyQjtBQUFBLHdCQUdJa2lDLGdCQUFnQixNQUFLbGlDLGNBQUwsQ0FBb0IsTUFBcEIsQ0FIcEI7QUFBQSx3QkFJSW1pQyxrQkFBa0IsUUFKdEI7O0FBTUEsd0JBQU1yakIsSUFBSSxNQUFLOGUsUUFBTCxDQUFjdlEsVUFBeEI7QUFBQSx3QkFBb0M3TSxJQUFJLE1BQUtvZCxRQUFMLENBQWNuMEMsU0FBdEQ7O0FBRUEsd0JBQUlvNEMsWUFBSixFQUFrQjtBQUNkQSxxQ0FBYXA0QyxTQUFiLEdBQXlCKzJCLENBQXpCO0FBQ0g7QUFDRCx3QkFBSXVoQixhQUFKLEVBQW1CO0FBQ2ZBLHNDQUFjdDRDLFNBQWQsR0FBMEIrMkIsQ0FBMUI7QUFDSDtBQUNELHdCQUFJMUIsTUFBTSxDQUFWLEVBQWE7QUFDVG9qQix5Q0FBaUJ0a0QsVUFBSThRLFdBQUosQ0FBZ0J3ekMsYUFBaEIsRUFBK0JDLGVBQS9CLENBQWpCO0FBQ0FGLDBDQUFrQnJrRCxVQUFJNlEsUUFBSixDQUFhd3pDLGNBQWIsRUFBNkJFLGVBQTdCLENBQWxCO0FBQ0gscUJBSEQsTUFHTyxJQUFJcmpCLE1BQU8sTUFBSzhlLFFBQUwsQ0FBY3dFLFdBQWQsR0FBNEIsTUFBS3hFLFFBQUwsQ0FBYzFqQyxXQUFyRCxFQUFtRTtBQUN0RWdvQyx5Q0FBaUJ0a0QsVUFBSTZRLFFBQUosQ0FBYXl6QyxhQUFiLEVBQTRCQyxlQUE1QixDQUFqQjtBQUNBRiwwQ0FBa0Jya0QsVUFBSThRLFdBQUosQ0FBZ0J1ekMsY0FBaEIsRUFBZ0NFLGVBQWhDLENBQWxCO0FBQ0gscUJBSE0sTUFHQTtBQUNIRCx5Q0FBaUJ0a0QsVUFBSTZRLFFBQUosQ0FBYXl6QyxhQUFiLEVBQTRCQyxlQUE1QixDQUFqQjtBQUNBRiwwQ0FBa0Jya0QsVUFBSTZRLFFBQUosQ0FBYXd6QyxjQUFiLEVBQTZCRSxlQUE3QixDQUFsQjtBQUNIO0FBQ0o7QUFDSixhQTVQMkI7O0FBRXhCLGtCQUFLRSxnQkFBTCxHQUF3QixFQUF4QjtBQUNBLGtCQUFLQyxpQkFBTCxHQUF5QixFQUF6QjtBQUh3QjtBQUkzQjs7QUFoQ21DLDRCQWtDcENwaUQsZUFsQ29DLDhCQWtDbEI7QUFDZCxtQkFBTztBQUNIdXFDLGtDQUFrQixLQUFLQSxnQkFEcEI7QUFFSDZXLDZCQUFhLEtBQUt4d0MsT0FGZjtBQUdINndDLGlDQUFpQixLQUFLQSxlQUhuQjtBQUlITixrQ0FBa0IsS0FBS0EsZ0JBSnBCO0FBS0hqMUMsaUNBQWlCLEtBQUtBLGVBTG5CO0FBTUhDLGlDQUFpQixLQUFLQTtBQU5uQixhQUFQO0FBUUgsU0EzQ21DOztBQUFBLDRCQTZDcENoRSxpQkE3Q29DLGdDQTZDaEI7QUFDaEIsaUJBQUsyM0MsVUFBTCxHQUFrQixLQUFLQSxVQUFMLENBQWdCbnlDLElBQWhCLENBQXFCLElBQXJCLENBQWxCOztBQUVBLGlCQUFLbXlDLFVBQUw7QUFDQSxpQkFBS3VDLE1BQUw7O0FBRUExa0QseUJBQU9xakIsRUFBUCxDQUFVdmhCLE1BQVYsRUFBa0IsUUFBbEIsRUFBNEIsS0FBS3FnRCxVQUFqQztBQUNILFNBcERtQzs7QUFBQSw0QkFzRHBDM3hDLHFCQXREb0Msa0NBc0RkcE4sU0F0RGMsRUFzREgwd0IsU0F0REcsRUFzRFFxRyxXQXREUixFQXNEcUI7QUFDckQsZ0JBQUkvMkIsVUFBVVgsSUFBZCxFQUFvQjtBQUNoQixvQkFBTWdPLFVBQVUsb0NBQXFCck4sU0FBckIsRUFBZ0MsS0FBS2QsS0FBckMsQ0FBaEI7QUFDQSx1QkFBTyxFQUFFbU8sV0FBV3RRLFVBQUl3SSxZQUFKLENBQWlCd3hCLFdBQWpCLEVBQThCLEtBQUtucEIsT0FBbkMsQ0FBYixDQUFQO0FBQ0g7O0FBRUQsbUJBQU8sSUFBUDtBQUNILFNBN0RtQzs7QUFBQSw0QkErRHBDbVosbUJBL0RvQyxrQ0ErRGQ7QUFDbEIsaUJBQUt3NkIsT0FBTCxHQUFlLEtBQWY7QUFDSCxTQWpFbUM7O0FBQUEsNEJBbUVwQ3RoRCxrQkFuRW9DLGlDQW1FZjtBQUNqQixpQkFBSzgrQyxVQUFMO0FBQ0gsU0FyRW1DOztBQUFBLDRCQXVFcEM3K0Msb0JBdkVvQyxtQ0F1RWI7QUFDbkJ0RCx5QkFBT2dqQixHQUFQLENBQVdsaEIsTUFBWCxFQUFtQixRQUFuQixFQUE2QixLQUFLcWdELFVBQWxDO0FBQ0gsU0F6RW1DOztBQUFBLDRCQTJFcENyVixzQkEzRW9DLG1DQTJFYnhxQyxLQTNFYSxFQTJFTjtBQUFBLGdCQUNwQndCLFFBRG9CLEdBQ1B4QixLQURPLENBQ3BCd0IsUUFEb0I7O0FBRTFCQSx1QkFBVyxLQUFLaXBDLGlCQUFMLENBQXVCanBDLFFBQXZCLENBQVg7QUFDQSxnQkFBTThnRCxnQkFBZ0IsS0FBS0MsMEJBQUwsQ0FBZ0MvZ0QsUUFBaEMsQ0FBdEI7QUFIMEIsZ0JBSWxCMGdELGdCQUprQixHQUlzQkksYUFKdEIsQ0FJbEJKLGdCQUprQjtBQUFBLGdCQUlBQyxpQkFKQSxHQUlzQkcsYUFKdEIsQ0FJQUgsaUJBSkE7O0FBSzFCLG1CQUFPO0FBQ0hELGtEQURHO0FBRUhDLG9EQUZHO0FBR0gzZ0QsMEJBQVUsS0FBS2doRCwwQkFBTCxDQUFnQ0YsYUFBaEM7QUFIUCxhQUFQO0FBS0gsU0FyRm1DOztBQXVGcEM7OztBQXZGb0MsNEJBd0ZwQzdYLGlCQXhGb0MsOEJBd0ZsQmpwQyxRQXhGa0IsRUF3RlI7QUFDeEIsZ0JBQUk2L0MsU0FBUyxLQUFiO0FBQ0EsZ0JBQU0xVyxjQUFjLFNBQWRBLFdBQWMsQ0FBQ25wQyxRQUFELEVBQWM7QUFDOUIsb0JBQU1nRyxNQUFNLEVBQVo7QUFDQWxHLGdDQUFTeUQsT0FBVCxDQUFpQnZELFFBQWpCLEVBQTJCLGlCQUFTO0FBQ2hDLHdCQUFJNkksS0FBSixFQUFXO0FBQ1AsNEJBQU1ySyxxQkFBYXFLLE1BQU1ySyxLQUFuQixDQUFOO0FBQ0EsNEJBQUksQ0FBQyxJQUFELEVBQU8sTUFBUCxFQUFlLE9BQWYsRUFBd0JnRixPQUF4QixDQUFnQ2hGLE1BQU1tUSxJQUF0QyxJQUE4QyxDQUFDLENBQW5ELEVBQXNEO0FBQ2xEa3hDLHFDQUFTLElBQVQ7QUFDQSxnQ0FBSSxFQUFFLFdBQVdyaEQsS0FBYixDQUFKLEVBQXlCO0FBQ3JCcEMsMENBQUl3QyxPQUFKLGtEQUEyREosTUFBTTJPLFNBQWpFO0FBQ0g7QUFDSjtBQUNEbkgsNEJBQUkxSSxJQUFKLENBQVNrQixLQUFUO0FBQ0EsNEJBQUlxSyxNQUFNckssS0FBTixDQUFZd0IsUUFBaEIsRUFBMEI7QUFDdEJ4QixrQ0FBTXdCLFFBQU4sR0FBaUJtcEMsWUFBWXRnQyxNQUFNckssS0FBTixDQUFZd0IsUUFBeEIsQ0FBakI7QUFDSDtBQUNKO0FBQ0osaUJBZEQ7QUFlQSx1QkFBT2dHLEdBQVA7QUFDSCxhQWxCRDtBQW1CQSxnQkFBTUEsTUFBTW1qQyxZQUFZbnBDLFFBQVosQ0FBWjtBQUNBZ0csZ0JBQUl6QyxPQUFKLENBQVksaUJBQVM7QUFDakI7QUFDQSxvQkFBSXNGLE1BQU0wRixZQUFOLElBQXNCc3hDLE1BQTFCLEVBQWtDO0FBQzlCaDNDLDBCQUFNOEYsSUFBTixHQUFhLE1BQWI7QUFDQSwyQkFBTzlGLE1BQU0wRixZQUFiO0FBQ0g7QUFDSixhQU5EO0FBT0EsaUJBQUtzeUMsT0FBTCxHQUFlaEIsTUFBZjtBQUNBLG1CQUFPNzVDLEdBQVA7QUFDSCxTQXZIbUM7O0FBeUhwQzs7O0FBekhvQyw0QkEwSHBDKzZDLDBCQTFIb0MsdUNBMEhUL2dELFFBMUhTLEVBMEhDO0FBQ2pDLGdCQUFNaWhELGlCQUFpQkMsU0FBU2xoRCxRQUFULENBQXZCO0FBQ0EsZ0JBQU0wZ0QsbUJBQW1CUSxTQUFTbGhELFFBQVQsQ0FBekI7QUFDQSxnQkFBTTJnRCxvQkFBb0JPLFNBQVNsaEQsUUFBVCxDQUExQjtBQUNBLGdCQUFNNEksT0FBTyxTQUFQQSxJQUFPLENBQUN1NEMsWUFBRCxFQUFlQyxTQUFmLEVBQTZCO0FBQ3RDLG9CQUFNcDdDLE1BQU0sRUFBWjtBQUNBbTdDLDZCQUFhNTlDLE9BQWIsQ0FBcUIsVUFBQ3NGLEtBQUQsRUFBVztBQUM1Qix3QkFBSUEsTUFBTTdJLFFBQVYsRUFBb0I7QUFDaEIsNEJBQU1rbkMsTUFBTXQrQixLQUFLQyxNQUFNN0ksUUFBWCxFQUFxQm9oRCxTQUFyQixDQUFaO0FBQ0EsNEJBQUksQ0FBQ2xhLElBQUkvcEMsTUFBVCxFQUFpQjtBQUNiNkksZ0NBQUkxSSxJQUFKLENBQVN1TCxLQUFUO0FBQ0g7QUFDSixxQkFMRCxNQUtPO0FBQ0gsNEJBQU1vYixRQUFRbTlCLFVBQVV2NEMsS0FBVixDQUFkO0FBQ0EsNEJBQUksQ0FBQ29iLEtBQUwsRUFBWTtBQUNSamUsZ0NBQUkxSSxJQUFKLENBQVN1TCxLQUFUO0FBQ0g7QUFDSjtBQUNKLGlCQVpEO0FBYUE3QyxvQkFBSXpDLE9BQUosQ0FBWSxlQUFPO0FBQ2Ysd0JBQU1pSCxRQUFRMjJDLGFBQWEzOUMsT0FBYixDQUFxQjBqQyxHQUFyQixDQUFkO0FBQ0FpYSxpQ0FBYXp6QyxNQUFiLENBQW9CbEQsS0FBcEIsRUFBMkIsQ0FBM0I7QUFDSCxpQkFIRDtBQUlBLHVCQUFPMjJDLFlBQVA7QUFDSCxhQXBCRDtBQXFCQXY0QyxpQkFBSzgzQyxnQkFBTCxFQUF1QixVQUFDNzNDLEtBQUQsRUFBVztBQUM5QixvQkFBSUEsTUFBTThGLElBQU4sS0FBZSxJQUFmLElBQXVCOUYsTUFBTThGLElBQU4sS0FBZSxNQUExQyxFQUFrRDtBQUM5QywyQkFBTyxNQUFQO0FBQ0g7QUFDSixhQUpEO0FBS0EvRixpQkFBSyszQyxpQkFBTCxFQUF3QixVQUFDOTNDLEtBQUQsRUFBVztBQUMvQixvQkFBSUEsTUFBTThGLElBQU4sS0FBZSxPQUFuQixFQUE0QjtBQUN4QiwyQkFBTyxPQUFQO0FBQ0g7QUFDSixhQUpEO0FBS0EvRixpQkFBS3E0QyxjQUFMLEVBQXFCLFVBQUNwNEMsS0FBRCxFQUFXO0FBQzVCLHVCQUFPQSxNQUFNOEYsSUFBTixLQUFlLElBQWYsSUFBdUI5RixNQUFNOEYsSUFBTixLQUFlLE1BQXRDLElBQWdEOUYsTUFBTThGLElBQU4sS0FBZSxPQUF0RTtBQUNILGFBRkQ7QUFHQSxtQkFBTztBQUNIK3hDLGtEQURHO0FBRUhDLG9EQUZHO0FBR0hNO0FBSEcsYUFBUDtBQUtILFNBckttQzs7QUF1S3BDOzs7QUF2S29DLDRCQXdLcENELDBCQXhLb0MsdUNBd0tURixhQXhLUyxFQXdLTTtBQUFBLGdCQUM5QkosZ0JBRDhCLEdBQ1VJLGFBRFYsQ0FDOUJKLGdCQUQ4QjtBQUFBLGdCQUNaQyxpQkFEWSxHQUNVRyxhQURWLENBQ1pILGlCQURZO0FBQUEsZ0JBRWhDTSxjQUZnQyxHQUViSCxhQUZhLENBRWhDRyxjQUZnQzs7QUFHdEMxakQsa0JBQU0wSCxTQUFOLENBQWdCb2MsT0FBaEIsQ0FBd0IzakIsS0FBeEIsQ0FBOEJ1akQsY0FBOUIsRUFBOENQLGdCQUE5QztBQUNBTyw2QkFBaUJBLGVBQWV2K0MsTUFBZixDQUFzQmkrQyxpQkFBdEIsQ0FBakI7QUFDQSxtQkFBT00sY0FBUDtBQUNILFNBOUttQzs7QUFBQSw0QkFtTnBDTCxNQW5Ob0MscUJBbU4zQjtBQUFBLHlCQUN3QyxLQUFLcGlELEtBRDdDO0FBQUEsNENBQ0c2aUQsV0FESDtBQUFBLGdCQUNHQSxXQURILHNDQUNpQixDQURqQjtBQUFBLDRDQUNvQjdELFdBRHBCO0FBQUEsZ0JBQ29CQSxXQURwQixzQ0FDa0MsQ0FEbEM7O0FBRUwsZ0JBQUksQ0FBQzZELFdBQUQsSUFBZ0IsQ0FBQzdELFdBQXJCLEVBQWtDO0FBQzlCO0FBQ0g7QUFDRCxnQkFBTThELGNBQWMsS0FBS0MsV0FBTCxDQUFpQixDQUFqQixFQUFvQkYsV0FBcEIsQ0FBcEI7QUFDQSxnQkFBTUcsY0FBYyxLQUFLRCxXQUFMLENBQWlCL0QsV0FBakIsRUFBOEIsQ0FBOUIsQ0FBcEI7QUFDQSxnQkFBTWlFLGlCQUFpQixLQUFLeEYsUUFBTCxDQUFjdGpDLHFCQUFkLEVBQXZCO0FBQ0EsZ0JBQUkyb0MsV0FBSixFQUFpQjtBQUNiLG9CQUFNSSxpQkFBaUJKLFlBQVkzb0MscUJBQVosRUFBdkI7QUFDQSxvQkFBTSt5QixhQUFhZ1csZUFBZW54QyxJQUFmLEdBQXNCa3hDLGVBQWVseEMsSUFBeEQ7QUFDQSxxQkFBSzByQyxRQUFMLENBQWN2USxVQUFkLEdBQTJCQSxVQUEzQjtBQUNIO0FBQ0QsZ0JBQUk4VixXQUFKLEVBQWlCO0FBQ2Isb0JBQU1FLGtCQUFpQkYsWUFBWTdvQyxxQkFBWixFQUF2QjtBQUNBLG9CQUFNN1EsWUFBWTQ1QyxnQkFBZXZxQyxHQUFmLEdBQXFCc3FDLGVBQWV0cUMsR0FBdEQ7QUFDQSxxQkFBSzhrQyxRQUFMLENBQWNuMEMsU0FBZCxHQUEwQkEsU0FBMUI7QUFDSDtBQUNKLFNBck9tQzs7QUEwUnBDO0FBMVJvQyw0QkEyUnBDKzNDLE1BM1JvQyxxQkEyUjNCO0FBQ0wsbUJBQU8sS0FBS2EsZ0JBQUwsQ0FBc0J2akQsTUFBdEIsSUFBZ0MsS0FBS3dqRCxpQkFBTCxDQUF1QnhqRCxNQUE5RDtBQUNILFNBN1JtQzs7QUErUnBDOzs7QUEvUm9DLDRCQWdTcEN3a0QsWUFoU29DLDJCQWdTckI7QUFDWCxtQkFBTyxLQUFLZCxPQUFaO0FBQ0gsU0FsU21DOztBQUFBLDRCQW9TcEN4QyxVQXBTb0MseUJBb1N2QjtBQUNULGdCQUFJLENBQUMsS0FBS3VELHdCQUFMLEVBQUwsRUFBc0M7QUFDbEMscUJBQUtDLGdCQUFMO0FBQ0EscUJBQUtDLGNBQUw7QUFDQSxxQkFBS0MsY0FBTDtBQUNBLHFCQUFLckMsZ0JBQUw7QUFDSDtBQUNKLFNBM1NtQzs7QUFBQSw0QkE2U3BDa0Msd0JBN1NvQyx1Q0E2U1Q7QUFBQTs7QUFDdkIsZ0JBQUksS0FBS0QsWUFBTCxNQUF1QixLQUFLN0MsUUFBTCxDQUFjdGdELEtBQWQsQ0FBb0IyTSxVQUFwQixDQUErQmhPLE1BQTFELEVBQWtFO0FBQzlELG9CQUFNNmtELGVBQWUsS0FBS2xELFFBQUwsQ0FBY3pWLFlBQWQsQ0FBMkIzbkMsR0FBM0IsQ0FBK0IsVUFBQ0MsSUFBRCxFQUFPNkksS0FBUCxFQUFpQjtBQUNqRSx3QkFBTUosTUFBTSxPQUFLbTNDLFdBQUwsQ0FBaUIsQ0FBakIsRUFBb0IvMkMsS0FBcEIsQ0FBWjtBQUNBLDJCQUFRSixPQUFPQSxJQUFJbU8sV0FBWixJQUE0QixDQUFuQztBQUNILGlCQUhvQixFQUdsQjBqQixNQUhrQixDQUdYLFVBQUM3Z0IsQ0FBRCxFQUFJRSxDQUFKO0FBQUEsMkJBQVVGLElBQUlFLENBQWQ7QUFBQSxpQkFIVyxFQUdNLENBSE4sQ0FBckI7O0FBS0Esb0JBQU1yTSxPQUFPLDJCQUFZLElBQVosQ0FBYjtBQUNBLG9CQUFNNUIsUUFBUTRCLEtBQUtzSixXQUFuQjtBQUNBLG9CQUFNMHBDLGNBQWMsS0FBS3ZCLGdCQUFMLENBQXNCdmpELE1BQTFDO0FBQ0Esb0JBQU0ra0QsZUFBZSxLQUFLdkIsaUJBQUwsQ0FBdUJ4akQsTUFBNUM7O0FBRUEsb0JBQUk2a0QsZ0JBQWdCMzBDLEtBQWhCLElBQXlCMjBDLGVBQWUsQ0FBNUMsRUFBK0M7QUFDM0Msd0JBQUlDLFdBQUosRUFBaUI7QUFDYiw2QkFBS0Usc0JBQUwsR0FBOEIsSUFBOUI7QUFDSDtBQUNELHdCQUFJRCxZQUFKLEVBQWtCO0FBQ2QsNkJBQUtFLHVCQUFMLEdBQStCLElBQS9CO0FBQ0g7QUFDRCx3QkFBSUYsZ0JBQWdCRCxXQUFwQixFQUFpQztBQUM3Qiw2QkFBS2ovQixXQUFMO0FBQ0EsK0JBQU8sSUFBUDtBQUNIO0FBQ0osaUJBWEQsTUFXTyxJQUFJLEtBQUttL0Isc0JBQUwsSUFBK0IsS0FBS0MsdUJBQXhDLEVBQWlFO0FBQ3BFLHlCQUFLRCxzQkFBTCxHQUE4QixLQUFLQyx1QkFBTCxHQUErQixLQUE3RDtBQUNBLHlCQUFLcC9CLFdBQUw7QUFDSCxpQkFITSxNQUdBO0FBQ0gseUJBQUttL0Isc0JBQUwsR0FBOEIsS0FBS0MsdUJBQUwsR0FBK0IsS0FBN0Q7QUFDQSwyQkFBTyxLQUFQO0FBQ0g7QUFDSjs7QUFFRCxtQkFBTyxLQUFQO0FBQ0gsU0E5VW1DOztBQUFBLDRCQWdWcENOLGNBaFZvQyw2QkFnVm5CO0FBQ2IsZ0JBQUksS0FBS2pDLE1BQUwsRUFBSixFQUFtQjtBQUNmLG9CQUFNcnBDLE9BQU8sS0FBS3lsQyxRQUFsQjtBQUFBLG9CQUNJaUUsZUFBZSxLQUFLaEIsWUFEeEI7QUFBQSxvQkFFSWtCLGdCQUFnQixLQUFLaEIsYUFGekI7QUFBQSxvQkFHSWlELHVCQUF1QixLQUFLaGtDLGNBQUwsQ0FBb0IsT0FBcEIsQ0FIM0I7QUFBQSxvQkFJSTFJLFlBQVkxWixVQUFJMFosU0FBSixFQUpoQjtBQUFBLG9CQUtJb29DLGFBQWF2bkMsS0FBS3ZPLFlBTHRCO0FBQUEsb0JBTUlxNkMsZUFBZTlyQyxLQUFLaXFDLFdBQUwsR0FBbUJqcUMsS0FBSytCLFdBTjNDO0FBQUEsb0JBT0lncUMsZUFBZS9yQyxLQUFLN08sWUFBTCxHQUFvQjZPLEtBQUs1TyxZQVA1QztBQUFBLG9CQVFJeUYsUUFBUWsxQyxlQUFlNXNDLFVBQVV0SSxLQUF6QixHQUFpQyxDQVI3QztBQUFBLG9CQVNJbTFDLGlCQUFpQnpFLGNBQWN1RSxlQUFlM3NDLFVBQVV3QyxNQUF6QixHQUFrQyxDQUFoRCxDQVRyQjs7QUFXQStuQyxnQ0FBZ0Jqa0QsVUFBSXlaLFFBQUosQ0FBYXdxQyxZQUFiLEVBQTJCLFlBQTNCLEVBQXlDc0MsY0FBekMsQ0FBaEI7QUFDQXBDLGlDQUFpQm5rRCxVQUFJeVosUUFBSixDQUFhMHFDLGFBQWIsRUFBNEIsWUFBNUIsRUFBMENvQyxjQUExQyxDQUFqQjtBQUNBSCx3Q0FBd0JwbUQsVUFBSXlaLFFBQUosQ0FBYTJzQyxvQkFBYixFQUFtQyxPQUFuQyxFQUE0Q2gxQyxLQUE1QyxDQUF4QjtBQUNIO0FBQ0osU0FqV21DOztBQUFBLDRCQW1XcEN3MEMsZ0JBbldvQywrQkFtV2pCO0FBQUE7O0FBQ2YsZ0JBQUksS0FBS2hDLE1BQUwsRUFBSixFQUFtQjtBQUNmLHFCQUFLZixRQUFMLENBQWN4VixhQUFkLENBQTRCL2xDLE9BQTVCLENBQW9DLFVBQUNzRixLQUFELEVBQVEyQixLQUFSLEVBQWtCO0FBQ2xELHdCQUFNaTRDLFlBQVksT0FBSzNELFFBQUwsQ0FBY3hWLGFBQWQsQ0FBNEI5K0IsS0FBNUIsRUFBbUNyTixNQUFuQyxHQUE0QyxDQUE5RDtBQUNBLHdCQUNJdWxELGlCQUFpQixPQUFLQyxpQkFBTCxDQUF1Qm40QyxLQUF2QixFQUE4Qmk0QyxTQUE5QixDQURyQjtBQUFBLHdCQUVJRyxnQkFBZ0IsT0FBS0QsaUJBQUwsQ0FBdUJuNEMsS0FBdkIsRUFBOEIsQ0FBOUIsQ0FGcEI7QUFBQSx3QkFHSXE0QyxxQkFBcUIsT0FBS0YsaUJBQUwsQ0FBdUJuNEMsS0FBdkIsRUFBOEIsQ0FBOUIsRUFBaUMsT0FBakMsQ0FIekI7QUFBQSx3QkFJSXM0QyxvQkFBb0IsT0FBS0gsaUJBQUwsQ0FBdUJuNEMsS0FBdkIsRUFBOEIsQ0FBOUIsRUFBaUMsTUFBakMsQ0FKeEI7O0FBTUEsd0JBQUlrNEMsa0JBQWtCRyxrQkFBdEIsRUFBMEM7QUFDdEMsNEJBQU1FLG9CQUFvQkwsZUFBZXo2QyxZQUF6Qzs7QUFFQWhNLGtDQUFJeVosUUFBSixDQUFhbXRDLGtCQUFiLEVBQWlDLFFBQWpDLEVBQTJDRSxpQkFBM0M7O0FBRUF6a0MsbUNBQVcsWUFBTTtBQUNiLG1DQUFLMGtDLGFBQUwsQ0FBbUIzK0IsUUFBbkIsSUFBK0IsT0FBSzIrQixhQUFMLENBQW1CMytCLFFBQW5CLENBQTRCN0MsV0FBNUIsR0FBMEN5aEMsY0FBMUMsRUFBL0I7QUFDSCx5QkFGRDtBQUdIOztBQUVELHdCQUFJTCxpQkFBaUJFLGlCQUFyQixFQUF3QztBQUNwQyw0QkFBTUksbUJBQW1CTixjQUFjMzZDLFlBQXZDOztBQUVBaE0sa0NBQUl5WixRQUFKLENBQWFvdEMsaUJBQWIsRUFBZ0MsUUFBaEMsRUFBMENJLGdCQUExQzs7QUFFQTVrQyxtQ0FBVyxZQUFNO0FBQ2IsbUNBQUs2a0MsWUFBTCxDQUFrQjkrQixRQUFsQixJQUE4QixPQUFLOCtCLFlBQUwsQ0FBa0I5K0IsUUFBbEIsQ0FBMkI3QyxXQUEzQixHQUF5Q3loQyxjQUF6QyxFQUE5QjtBQUNILHlCQUZEO0FBR0g7QUFFSixpQkE1QkQ7QUE2Qkg7QUFDSixTQW5ZbUM7O0FBQUEsNEJBcVlwQ2xCLGNBcllvQyw2QkFxWW5CO0FBQUE7O0FBQ2IsZ0JBQUksS0FBS2xDLE1BQUwsRUFBSixFQUFtQjtBQUNmLHFCQUFLZixRQUFMLENBQWN0Z0QsS0FBZCxDQUFvQjJNLFVBQXBCLENBQStCNUgsT0FBL0IsQ0FBdUMsVUFBQzVCLElBQUQsRUFBTzZJLEtBQVAsRUFBaUI7QUFDcEQsd0JBQU00NEMsY0FBYyxPQUFLN0IsV0FBTCxDQUFpQi8yQyxLQUFqQixFQUF3QixDQUF4QixFQUEyQixNQUEzQixDQUFwQjtBQUFBLHdCQUNJNjRDLGVBQWUsT0FBSzlCLFdBQUwsQ0FBaUIvMkMsS0FBakIsRUFBd0IsQ0FBeEIsRUFBMkIsT0FBM0IsQ0FEbkI7QUFBQSx3QkFFSUosTUFBTSxPQUFLazVDLHNCQUFMLENBQTRCOTRDLEtBQTVCLENBRlY7QUFBQSx3QkFHSTJnQyxZQUFZL2dDLE9BQU9zTixXQUFXVixpQkFBaUI1TSxHQUFqQixFQUFzQitOLE1BQWpDLENBQVAsSUFBbUQsQ0FIbkU7QUFJQSx3QkFBSW9yQyxpQkFBaUIsQ0FBckI7QUFBQSx3QkFBd0JDLGtCQUFrQixDQUExQzs7QUFFQSx3QkFBSUosV0FBSixFQUFpQjtBQUNiRyx5Q0FBaUJILFlBQVluN0MsWUFBN0I7QUFDSDtBQUNELHdCQUFJbzdDLFlBQUosRUFBa0I7QUFDZEcsMENBQWtCSCxhQUFhcDdDLFlBQS9CO0FBQ0g7QUFDRCx3QkFBSW03QyxlQUFlalksY0FBY29ZLGNBQWpDLEVBQWlEO0FBQzdDdG5ELGtDQUFJeVosUUFBSixDQUFhMHRDLFdBQWIsRUFBMEIsUUFBMUIsRUFBb0NqWSxTQUFwQztBQUNIO0FBQ0Qsd0JBQUlrWSxnQkFBZ0JsWSxjQUFjcVksZUFBbEMsRUFBbUQ7QUFDL0N2bkQsa0NBQUl5WixRQUFKLENBQWEydEMsWUFBYixFQUEyQixRQUEzQixFQUFxQ2xZLFNBQXJDO0FBQ0g7QUFDSixpQkFuQkQ7QUFvQkg7QUFDSixTQTVabUM7O0FBQUEsNEJBOFpwQzlzQixjQTlab0MsMkJBOFpyQm5hLElBOVpxQixFQThaZjtBQUNqQkEsbUJBQU9BLE9BQU9BLEtBQUswM0MsTUFBTCxDQUFZLENBQVosRUFBZXZpQyxXQUFmLEtBQStCblYsS0FBSzIzQyxNQUFMLENBQVksQ0FBWixDQUF0QyxHQUF1RCxFQUE5RDtBQUNBLGdCQUFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQU8sMkJBQVksS0FBS3pSLElBQUwsVUFBaUJsbUMsSUFBakIsQ0FBWixDQUFQO0FBQ0gsYUFMRCxDQUtFLE9BQU9nNUIsS0FBUCxFQUFjO0FBQ1osdUJBQU8sSUFBUDtBQUNIO0FBQ0osU0F4YW1DOztBQUFBLDRCQTBhcENvbUIsc0JBMWFvQyxtQ0EwYWI5NEMsS0ExYWEsRUEwYU47QUFDMUIsZ0JBQUl2TixJQUFJLENBQVI7QUFDQSxnQkFBSW1OLFlBQUo7QUFDQSxlQUFHO0FBQ0NBLHNCQUFNLEtBQUttM0MsV0FBTCxDQUFpQi8yQyxLQUFqQixFQUF3QnZOLENBQXhCLENBQU47QUFDQUE7QUFDSCxhQUhELFFBR1MsQ0FBQyxDQUFDbU4sR0FBRCxJQUFRQSxPQUFPQSxJQUFJd0QsT0FBWCxJQUFzQnhELElBQUl3RCxPQUFKLEdBQWMsQ0FBN0MsS0FBbUQsS0FBS2t4QyxRQUFMLENBQWN6VixZQUFkLENBQTJCbHNDLE1BQTNCLEdBQW9DRixDQUhoRzs7QUFLQSxtQkFBT21OLEdBQVA7QUFDSCxTQW5ibUM7O0FBQUEsNEJBcWJwQ20wQyxVQXJib0MsdUJBcWJ6Qi96QyxLQXJieUIsRUFxYmxCdEcsSUFyYmtCLEVBcWJaO0FBQ3BCQSxtQkFBT0EsT0FBT0EsS0FBSzAzQyxNQUFMLENBQVksQ0FBWixFQUFldmlDLFdBQWYsS0FBK0JuVixLQUFLMjNDLE1BQUwsQ0FBWSxDQUFaLENBQXRDLEdBQXVELEVBQTlEO0FBQ0EsZ0JBQU1yUixRQUFRLGVBQWF0bUMsSUFBYixTQUFkOztBQUVBLGdCQUFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQU8sMkJBQVlzbUMsTUFBTXJnQyxTQUFOLENBQWdCSyxLQUFoQixDQUFaLENBQVA7QUFDSCxhQUxELENBS0UsT0FBTzB5QixLQUFQLEVBQWM7QUFDWix1QkFBTyxJQUFQO0FBQ0g7QUFDSixTQWpjbUM7O0FBQUEsNEJBbWNwQ3lsQixpQkFuY29DLDhCQW1jbEJuNEMsS0FuY2tCLEVBbWNYdk4sQ0FuY1csRUFtY1JpSCxJQW5jUSxFQW1jRjtBQUM5QkEsbUJBQU9BLE9BQU9BLEtBQUswM0MsTUFBTCxDQUFZLENBQVosRUFBZXZpQyxXQUFmLEtBQStCblYsS0FBSzIzQyxNQUFMLENBQVksQ0FBWixDQUF0QyxHQUF1RCxFQUE5RDtBQUNBLGdCQUFNclIsUUFBUSxlQUFhdG1DLElBQWIsU0FBZDs7QUFFQSxnQkFBSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFPLDJCQUFZc21DLE1BQU0zQixnQkFBTixDQUF1QnIrQixLQUF2QixFQUE4QnZOLENBQTlCLENBQVosQ0FBUDtBQUNILGFBTEQsQ0FLRSxPQUFPaWdDLEtBQVAsRUFBYztBQUNaLHVCQUFPLElBQVA7QUFDSDtBQUNKLFNBL2NtQzs7QUFBQSw0QkFpZHBDcWtCLFdBamRvQyx3QkFpZHhCLzJDLEtBamR3QixFQWlkakJ2TixDQWpkaUIsRUFpZGRpSCxJQWpkYyxFQWlkUjtBQUN4QkEsbUJBQU9BLE9BQU9BLEtBQUswM0MsTUFBTCxDQUFZLENBQVosRUFBZXZpQyxXQUFmLEtBQStCblYsS0FBSzIzQyxNQUFMLENBQVksQ0FBWixDQUF0QyxHQUF1RCxFQUE5RDtBQUNBLGdCQUFNclIsUUFBUSxlQUFhdG1DLElBQWIsU0FBZDs7QUFFQSxnQkFBSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFPLDJCQUFZc21DLE1BQU0xbUIsVUFBTixDQUFpQnRaLEtBQWpCLEVBQXdCdk4sQ0FBeEIsQ0FBWixDQUFQO0FBQ0gsYUFMRCxDQUtFLE9BQU9pZ0MsS0FBUCxFQUFjO0FBQ1osdUJBQU8sSUFBUDtBQUNIO0FBQ0osU0E3ZG1DOztBQUFBLDRCQStkcENyOUIsTUEvZG9DLHFCQStkM0I7QUFDTDtBQURLLDBCQUV3RCxLQUFLckIsS0FGN0Q7QUFBQSxnQkFFQ3dCLFFBRkQsV0FFQ0EsUUFGRDtBQUFBLGdCQUVXdkIsTUFGWCxXQUVXQSxNQUZYO0FBQUEsZ0JBRW1Cc00sVUFGbkIsV0FFbUJBLFVBRm5CO0FBQUEsZ0JBRStCM0csU0FGL0IsV0FFK0JBLFNBRi9CO0FBQUEsZ0JBRTZDbUMsTUFGN0M7O0FBQUEsd0NBR3VFLEtBQUt5aUMsc0JBQUwsQ0FBNEIsS0FBS3hxQyxLQUFqQyxDQUh2RTtBQUFBLGdCQUdDa2lELGdCQUhELHlCQUdDQSxnQkFIRDtBQUFBLGdCQUdtQkMsaUJBSG5CLHlCQUdtQkEsaUJBSG5CO0FBQUEsZ0JBR2dEOEMsa0JBSGhELHlCQUdzQ3pqRCxRQUh0Qzs7QUFJTCxnQkFBSSxLQUFLbWlELHNCQUFULEVBQWlDO0FBQzdCekIsbUNBQW1CLEVBQW5CO0FBQ0g7QUFDRCxnQkFBSSxLQUFLMEIsdUJBQVQsRUFBa0M7QUFDOUJ6QixvQ0FBb0IsRUFBcEI7QUFDSDtBQUNELGlCQUFLRCxnQkFBTCxHQUF3QkEsZ0JBQXhCO0FBQ0EsaUJBQUtDLGlCQUFMLEdBQXlCQSxpQkFBekI7O0FBRUEsZ0JBQUksS0FBS2dCLFlBQUwsRUFBSixFQUF5QjtBQUFBOztBQUNyQjUyQywwQ0FBa0JBLFVBQWxCO0FBQ0FBLDJCQUFXYixJQUFYLEdBQWtCYSxXQUFXYixJQUFYLElBQW1CdzVDLGNBQXJDO0FBQ0EzNEMsMkJBQVc4WSxNQUFYLEdBQW9COVksV0FBVzhZLE1BQVgsSUFBcUI4L0IsZ0JBQXpDO0FBQ0E1NEMsMkJBQVcrK0IsT0FBWCxHQUFxQi8rQixXQUFXKytCLE9BQVgsSUFBc0I4WixpQkFBM0M7QUFDQTc0QywyQkFBV08sR0FBWCxHQUFpQlAsV0FBV08sR0FBWCxJQUFrQnd0QixhQUFuQztBQUNBMTBCLDRCQUFZLHlEQUNKM0YsTUFESSxtQkFDaUIsSUFEakIsY0FFUDJGLFNBRk8sSUFFS0EsU0FGTCxlQUFaO0FBSUEsb0JBQU14QyxVQUFVLENBQ1osOEJBQUMsYUFBRCxlQUFtQjJFLE1BQW5CLElBQTJCLEtBQUksV0FBL0IsRUFBMkMsU0FBU202QyxnQkFBcEQsRUFBc0UsV0FBY2ppRCxNQUFkLG9CQUF0RSxFQUE2RyxRQUFRQSxNQUFySCxFQUE2SCxVQUFTLE1BQXRJLEVBQTZJLFlBQVlzTSxVQUF6SixFQUFxSyxLQUFJLFVBQXpLLEVBQW9MLFNBQVMsS0FBN0wsSUFEWSxFQUVaLDhCQUFDLGFBQUQsZUFBbUJ4RSxNQUFuQixJQUEyQixLQUFJLFlBQS9CLEVBQTRDLFNBQVNvNkMsaUJBQXJELEVBQXdFLFdBQWNsaUQsTUFBZCxxQkFBeEUsRUFBZ0gsUUFBUUEsTUFBeEgsRUFBZ0ksVUFBUyxPQUF6SSxFQUFpSixZQUFZc00sVUFBN0osRUFBeUssS0FBSSxXQUE3SyxFQUF5TCxTQUFTLEtBQWxNLElBRlksQ0FBaEI7QUFJQSx1QkFBTyw4QkFBQyxhQUFELGVBQW1CeEUsTUFBbkIsSUFBMkIsU0FBU2s5QyxrQkFBcEMsRUFBd0QsUUFBUWhsRCxNQUFoRSxFQUF3RSxnQkFBZ0JtRCxPQUF4RixFQUFpRyxZQUFZbUosVUFBN0csRUFBeUgsV0FBVzNHLFNBQXBJLElBQVA7QUFDSDtBQUNELG1CQUFRLDhCQUFDLGFBQUQsRUFBbUIsS0FBSzVGLEtBQXhCLENBQVI7QUFDSCxTQTdmbUM7O0FBQUE7QUFBQSxNQUVoQjJOLGdCQUFNbE0sU0FGVSxVQUc3QjY0QixPQUg2QixHQUduQkEsYUFIbUIsU0FJN0I0cUIsUUFKNkIsR0FJbEJBLGNBSmtCLFNBSzdCQyxVQUw2QixHQUtoQkEsZ0JBTGdCLFNBTTdCempELFNBTjZCO0FBT2hDbWhELHFCQUFhbGhELG9CQUFVdUosTUFQUztBQVFoQzs7O0FBR0E4ekMscUJBQWFyOUMsb0JBQVV1SjtBQVhTLE9BWTdCMHdDLGNBQWNsNkMsU0FaZSxVQWU3QkssWUFmNkIsZ0JBZ0I3QjY1QyxjQUFjNzVDLFlBaEJlLFVBbUI3QkMsaUJBbkI2QixHQW1CVDtBQUN2QnNvQywwQkFBa0Izb0Msb0JBQVVoRSxJQURMO0FBRXZCd2pELHFCQUFheC9DLG9CQUFVaEUsSUFGQTtBQUd2QnVqRCwwQkFBa0J2L0Msb0JBQVVoRSxJQUhMO0FBSXZCNmpELHlCQUFpQjcvQyxvQkFBVWhFLElBSko7QUFLdkJzTyx5QkFBaUJ0SyxvQkFBVWhFLElBTEo7QUFNdkJ1Tyx5QkFBaUJ2SyxvQkFBVWhFO0FBTkosS0FuQlM7QUFFbEN5akQsYUFGa0M7O0FBK2Z4Qyx3QkFBUUEsU0FBUixFQUFtQnhGLGFBQW5CO0FBQ0EsV0FBT3dGLFNBQVA7QUFDSDs7QUFHRCxTQUFTc0IsUUFBVCxDQUFrQjlFLEdBQWxCLEVBQXVCO0FBQ25CLFFBQUl5SCxPQUFPLFNBQVBBLElBQU8sQ0FBQ3pILEdBQUQsRUFBUztBQUNoQixlQUFPQSxJQUFJMTZDLEdBQUosQ0FBUSxnQkFBUTtBQUNuQixnQkFBTW9pRCx1QkFBZW5pRCxJQUFmLENBQU47QUFDQSxnQkFBSUEsS0FBSzNCLFFBQVQsRUFBbUI7QUFDZjJCLHFCQUFLM0IsUUFBTCxHQUFnQjZqRCxLQUFLbGlELEtBQUszQixRQUFWLENBQWhCO0FBQ0g7QUFDRCxtQkFBTzhqRCxPQUFQO0FBQ0gsU0FOTSxDQUFQO0FBT0gsS0FSRDtBQVNBLFdBQU9ELEtBQUt6SCxHQUFMLENBQVA7QUFDSDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzaEJEOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFQTtJQUNxQnNILFE7Ozs7Ozs7Ozs7Ozs0SkFpQmpCMXFCLFksR0FBZSxZQUFNO0FBQ2pCLGtCQUFLOXJCLE9BQUwsQ0FBYXd5QyxnQkFBYjtBQUNILFMsUUFFRHFFLFcsR0FBYyxVQUFDcGtELENBQUQsRUFBTztBQUNqQixrQkFBS3VOLE9BQUwsQ0FBYTh5QyxlQUFiLENBQTZCcmdELENBQTdCO0FBQ0gsUzs7O3VCQVZEK0csaUIsZ0NBQW9CO0FBQ2hCLGFBQUt3RyxPQUFMLENBQWF5eUMsV0FBYixDQUF5QixNQUF6QixFQUFpQywyQkFBWSxJQUFaLENBQWpDLEVBQW9ELEtBQUt6eUMsT0FBTCxDQUFhRCxRQUFqRTtBQUNILEs7O3VCQVVEcE4sTSxxQkFBUztBQUNMLGVBQU8sOEJBQUMsY0FBRCxlQUFlLEtBQUtyQixLQUFwQixJQUEyQixVQUFVLEtBQUt3NkIsWUFBMUMsRUFBd0QsU0FBUyxLQUFLK3FCLFdBQXRFLElBQVA7QUFDSCxLOzs7RUEzQmlDNTNDLGdCQUFNbE0sUyxVQUNqQ0MsUyxnQkFDQTY0QixlQUFVNzRCLFMsVUFHVmlPLFksZ0JBQ0E0cUIsZUFBVTVxQixZO0FBQ2J3eEMsaUJBQWF4L0Msb0JBQVVoRSxJO0FBQ3ZCdWpELHNCQUFrQnYvQyxvQkFBVWhFLEk7QUFDNUI2akQscUJBQWlCNy9DLG9CQUFVaEUsSTtBQUMzQjhRLGNBQVU5TSxvQkFBVW9FLEtBQVYsQ0FBZ0IsQ0FBQyxNQUFELEVBQVMsT0FBVCxDQUFoQjs7QUFWR20vQyxRO2tCQUFBQSxROzs7Ozs7Ozs7Ozs7Ozs7OztBQ05yQjs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7OztJQUVxQkMsVTs7Ozs7Ozs7O3lCQVdqQmo5QyxpQixnQ0FBb0I7QUFBQSx1QkFDZSxLQUFLd0csT0FEcEI7QUFBQSxZQUNUaUMsT0FEUyxZQUNUQSxPQURTO0FBQUEsWUFDQXd3QyxXQURBLFlBQ0FBLFdBREE7O0FBRWhCeHdDLG1CQUFXQSxRQUFRLFFBQVIsRUFBa0IsMkJBQVksSUFBWixDQUFsQixFQUFxQyxLQUFLakMsT0FBTCxDQUFhRCxRQUFsRCxDQUFYO0FBQ0EweUMsdUJBQWVBLFlBQVksUUFBWixFQUFzQiwyQkFBWSxJQUFaLENBQXRCLEVBQXlDLEtBQUt6eUMsT0FBTCxDQUFhRCxRQUF0RCxDQUFmO0FBQ0gsSzs7O0VBZm1DaUMsZ0IsVUFDN0JoUCxTLGdCQUNBZ1AsaUJBQVloUCxTLFVBR1ppTyxZLGdCQUNBZSxpQkFBWWYsWTtBQUNmd3hDLGlCQUFheC9DLG9CQUFVaEUsSTtBQUN2QjhRLGNBQVU5TSxvQkFBVW9FLEtBQVYsQ0FBZ0IsQ0FBQyxNQUFELEVBQVMsT0FBVCxDQUFoQjs7a0JBUkdvL0MsVTs7Ozs7Ozs7Ozs7Ozs7a0JDT0duaUQsSTs7QUFYeEI7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBRWUsU0FBU0EsSUFBVCxDQUFjNDRDLGFBQWQsRUFBNkI7QUFBQTs7QUFBQSxRQUNsQzRKLFNBRGtDO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBLDRCQW1CcEN6bEQsZUFuQm9DLDhCQW1CbEI7QUFDZCxtQkFBTztBQUNIeStDLDRCQUFZLEtBQUtBLFVBRGQ7QUFFSGlILDRCQUFZLEtBQUtBLFVBRmQ7QUFHSG5aLDhCQUFjLEtBQUtBO0FBSGhCLGFBQVA7QUFLSCxTQXpCbUM7O0FBQUEsNEJBMkJwQytQLG1CQTNCb0MsZ0NBMkJoQjF2QyxVQTNCZ0IsRUEyQko7QUFDNUIsZ0JBQU1uRixNQUFNLEVBQVo7QUFDQSxnQkFBTTRDLE9BQU8sU0FBUEEsSUFBTyxDQUFVdUMsVUFBVixFQUFzQnJDLEtBQXRCLEVBQTZCO0FBQ3RDcUMsMkJBQVc1SCxPQUFYLENBQW1CLGdCQUFRO0FBQ3ZCNUIseUJBQUttNUMsT0FBTCxHQUFlaHlDLEtBQWY7QUFDQTlDLHdCQUFJMUksSUFBSixDQUFTcUUsSUFBVDtBQUNBLHdCQUFJQSxLQUFLM0IsUUFBVCxFQUFtQjtBQUNmNEksNkJBQUtqSCxLQUFLM0IsUUFBVixFQUFvQjhJLFFBQVEsQ0FBNUI7QUFDSDtBQUNKLGlCQU5EO0FBT0gsYUFSRDtBQVNBRixpQkFBS3VDLFVBQUwsRUFBaUIsQ0FBakI7QUFDQSxpQkFBS292QyxFQUFMLEdBQVV2MEMsR0FBVjtBQUNBLG1CQUFPQSxHQUFQO0FBQ0gsU0F6Q21DOztBQUFBLDRCQTJDcENuRyxNQTNDb0MscUJBMkMzQjtBQUFBOztBQUNMO0FBREsseUJBRXdELEtBQUtyQixLQUY3RDtBQUFBLGdCQUVDdU0sVUFGRCxVQUVDQSxVQUZEO0FBQUEsZ0JBRWEvSyxRQUZiLFVBRWFBLFFBRmI7QUFBQSxnQkFFdUJvRSxTQUZ2QixVQUV1QkEsU0FGdkI7QUFBQSxnQkFFa0MzRixNQUZsQyxVQUVrQ0EsTUFGbEM7QUFBQSxnQkFFNkM4SCxNQUY3Qzs7QUFHTCxnQkFBSTI5QyxTQUFTLEtBQWI7QUFBQSxnQkFBb0JsK0MsTUFBTSxFQUExQjtBQUNBbEcsNEJBQVN5RCxPQUFULENBQWlCdkQsUUFBakIsRUFBMkIsaUJBQVM7QUFDaEMsb0JBQUk2SSxLQUFKLEVBQVc7QUFDUCx3QkFBSSxPQUFPQSxNQUFNM0UsSUFBYixLQUFzQixVQUExQixFQUFzQztBQUNsQyw0QkFBSTJFLE1BQU0zRSxJQUFOLENBQVdNLFNBQVgsS0FBeUIsWUFBN0IsRUFBMkM7QUFDdkMsbUNBQUt3NEMsVUFBTCxHQUFrQm4wQyxNQUFNckssS0FBeEI7QUFDQTBsRCxxQ0FBUyxJQUFUO0FBQ0gseUJBSEQsTUFHTyxJQUFJcjdDLE1BQU0zRSxJQUFOLENBQVdNLFNBQVgsS0FBeUIsWUFBN0IsRUFBMkM7QUFDOUMsbUNBQUt5L0MsVUFBTCxHQUFrQnA3QyxNQUFNckssS0FBeEI7QUFDSCx5QkFGTSxNQUVBO0FBQ0h3SCxnQ0FBSTFJLElBQUosQ0FBU3VMLEtBQVQ7QUFDSDtBQUNKLHFCQVRELE1BU087QUFDSDdDLDRCQUFJMUksSUFBSixDQUFTdUwsS0FBVDtBQUNIO0FBQ0o7QUFDSixhQWZEO0FBZ0JBLGlCQUFLaWlDLFlBQUwsR0FBb0IsS0FBS3RzQyxLQUFMLENBQVdzc0MsWUFBL0I7QUFDQSxnQkFBSW9aLE1BQUosRUFBWTtBQUFBOztBQUNSbjVDLDBDQUFrQkEsVUFBbEI7QUFDQUEsMkJBQVdPLEdBQVgsR0FBaUJQLFdBQVdPLEdBQVgsSUFBa0JDLGFBQW5DO0FBQ0FSLDJCQUFXYixJQUFYLEdBQWtCYSxXQUFXYixJQUFYLElBQW1COC9CLGNBQXJDO0FBQ0FqL0IsMkJBQVc4WSxNQUFYLEdBQW9COVksV0FBVzhZLE1BQVgsSUFBcUJnbUIsZ0JBQXpDO0FBQ0E5K0IsMkJBQVcrK0IsT0FBWCxHQUFxQi8rQixXQUFXKytCLE9BQVgsSUFBc0JDLGlCQUEzQztBQUNBM2xDLDRCQUFZLHlEQUNKM0YsTUFESSxvQkFDa0IsSUFEbEIsY0FFUDJGLFNBRk8sSUFFS0EsU0FGTCxlQUFaO0FBSUg7QUFDRCxtQkFBUSw4QkFBQyxhQUFELGVBQW1CbUMsTUFBbkIsSUFBMkIsWUFBWXdFLFVBQXZDLEVBQW1ELFVBQVUvRSxHQUE3RCxFQUFrRSxXQUFXNUIsU0FBN0UsRUFBd0YsUUFBUTNGLE1BQWhHLElBQVI7QUFDSCxTQTVFbUM7O0FBQUE7QUFBQSxNQUNoQjBOLGdCQUFNbE0sU0FEVSxVQUU3Qm81QixVQUY2QixHQUVoQkEsb0JBRmdCLFNBRzdCRyxVQUg2QixHQUdoQkEsb0JBSGdCLFNBSTdCMnFCLE9BSjZCLEdBSW5CNTRDLGFBSm1CLFNBSzdCNjRDLFFBTDZCLEdBS2xCcGEsY0FMa0IsU0FNN0I5cEMsU0FONkIsZ0JBTzdCazZDLGNBQWNsNkMsU0FQZSxVQVM3QkssWUFUNkIsZ0JBVTdCNjVDLGNBQWM3NUMsWUFWZSxVQWE3QkMsaUJBYjZCLEdBYVQ7QUFDdkJ3OEMsb0JBQVk3OEMsb0JBQVVpTSxHQURDO0FBRXZCNjNDLG9CQUFZOWpELG9CQUFVaU0sR0FGQztBQUd2QjArQixzQkFBYzNxQyxvQkFBVWpGO0FBSEQsS0FiUztBQUNsQzhvRCxhQURrQzs7QUE4RXhDLHVCQUFRQSxTQUFSLEVBQW1CNUosYUFBbkI7QUFDQSxXQUFPNEosU0FBUDtBQUNIOzs7Ozs7Ozs7Ozs7Ozs7OztBQzNGRDs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztJQUVxQkssWTs7Ozs7Ozs7OzJCQVVqQnhrRCxNLHFCQUFTO0FBQUE7O0FBQ0w7QUFESyxxQkFFaUssS0FBS3JCLEtBRnRLO0FBQUEsWUFFR0MsTUFGSCxVQUVHQSxNQUZIO0FBQUEsWUFFVzJGLFNBRlgsVUFFV0EsU0FGWDtBQUFBLFlBRXNCaUUsT0FGdEIsVUFFc0JBLE9BRnRCO0FBQUEsWUFFK0JrRSxZQUYvQixVQUUrQkEsWUFGL0I7QUFBQSxZQUU2Q0UsWUFGN0MsVUFFNkNBLFlBRjdDO0FBQUEsWUFFMkRwQixPQUYzRCxVQUUyREEsT0FGM0Q7QUFBQSxZQUVvRUcsSUFGcEUsVUFFb0VBLElBRnBFO0FBQUEsWUFFMEVjLFFBRjFFLFVBRTBFQSxRQUYxRTtBQUFBLFlBRW9GL0IsTUFGcEYsVUFFb0ZBLE1BRnBGO0FBQUEsWUFFNEZ2SyxRQUY1RixVQUU0RkEsUUFGNUY7QUFBQSxZQUVzR2lMLFVBRnRHLFVBRXNHQSxVQUZ0RztBQUFBLFlBRWtITCxRQUZsSCxVQUVrSEEsUUFGbEg7QUFBQSxZQUU0SFEsT0FGNUgsVUFFNEhBLE9BRjVIO0FBQUEsWUFFcUlKLFlBRnJJLFVBRXFJQSxZQUZySTtBQUFBLFlBRXNKekUsTUFGdEo7O0FBR0wsWUFBTTJILE1BQU0seURBQ0p6UCxNQURJLGtCQUNnQixJQURoQixjQUVQMkYsU0FGTyxJQUVLQSxTQUZMLGVBQVo7QUFJQSxlQUFRO0FBQUE7QUFBQSx1QkFBTyxXQUFXOEosR0FBbEIsRUFBdUIsTUFBSyxLQUE1QixJQUFzQzNILE1BQXRDO0FBQ0oseUJBQVMsS0FBSzhCLE9BRFYsRUFDbUIsY0FBYyxLQUFLa0UsWUFEdEMsRUFDb0QsY0FBYyxLQUFLRSxZQUR2RTtBQUVIN0Isb0JBRkc7QUFHSjtBQUFBO0FBQUE7QUFDSyxxQkFBS29sQyxhQUFMLENBQW1CLFFBQW5CLENBREw7QUFFSyxxQkFBS3NVLGNBQUwsRUFGTDtBQUdLLHFCQUFLdFUsYUFBTCxDQUFtQixRQUFuQjtBQUhMO0FBSEksU0FBUjtBQVNILEs7OzJCQUVEdVUsbUIsa0NBQXNCO0FBQ2xCLGVBQU8sS0FBS3IzQyxPQUFMLENBQWE4dkMsVUFBYixJQUEyQixLQUFLOXZDLE9BQUwsQ0FBYTh2QyxVQUFiLENBQXdCMWpCLG9CQUExRDtBQUNILEs7OzJCQUVEa3JCLFcsMEJBQWM7QUFDVixlQUFPLEtBQUt0M0MsT0FBTCxDQUFhOHZDLFVBQWIsSUFBMkIsS0FBSzl2QyxPQUFMLENBQWE4dkMsVUFBYixDQUF3QnpqQixZQUExRDtBQUNILEs7OzJCQUVEK3FCLGMsNkJBQWlCO0FBQUE7O0FBQUEsc0JBQ2tCLEtBQUs5bEQsS0FEdkI7QUFBQSxZQUNMK0wsTUFESyxXQUNMQSxNQURLO0FBQUEsWUFDR1UsVUFESCxXQUNHQSxVQURIO0FBQUEsWUFFTGpMLFFBRkssR0FFUXVLLE1BRlIsQ0FFTHZLLFFBRks7O0FBR2IsWUFBSUEsUUFBSixFQUFjO0FBQ1YsbUJBQU9BLFNBQVMwQixHQUFULENBQWEsVUFBQ21ILEtBQUQsRUFBUTJCLEtBQVIsRUFBa0I7QUFDbEMsb0JBQU1pNkMsUUFBUSxPQUFLejNDLFdBQUwsQ0FBaUJuRSxLQUFqQixDQUFkO0FBQ0Esb0JBQUksT0FBSzA3QyxtQkFBTCxFQUFKLEVBQWdDO0FBQzVCLHdCQUFJLENBQUMxN0MsTUFBTW9DLFVBQU4sQ0FBTCxFQUF3QjtBQUNwQjdPLGtDQUFJd0MsT0FBSixDQUFZLDRFQUFaO0FBQ0g7QUFDRCwyQkFBTztBQUFBO0FBQUEsMEJBQUksS0FBS2lLLE1BQU1vQyxVQUFOLENBQVQ7QUFBNkJ3NUM7QUFBN0IscUJBQVA7QUFDSDtBQUNELG9CQUFJLE9BQUt2M0MsT0FBTCxDQUFhNDlCLFlBQWpCLEVBQStCO0FBQzNCMlosMEJBQU1DLEtBQU47QUFDQUQsMEJBQU0sQ0FBTixJQUFXdDRDLGdCQUFNMkMsWUFBTixDQUFtQjIxQyxNQUFNLENBQU4sQ0FBbkI7QUFDUDkyQyxpQ0FBUztBQURGLHVCQUVKODJDLE1BQU0sQ0FBTixFQUFTam1ELEtBRkwsRUFBWDtBQUlIO0FBQ0QsdUJBQU87QUFBQTtBQUFBLHNCQUFJLEtBQUtnTSxLQUFUO0FBQWlCaTZDO0FBQWpCLGlCQUFQO0FBQ0gsYUFoQk0sQ0FBUDtBQWlCSDtBQUNELGVBQU8sSUFBUDtBQUNILEs7OzJCQUNEelUsYSwwQkFBYzlyQyxJLEVBQU07QUFBQSxzQkFDOEIsS0FBSzFGLEtBRG5DO0FBQUEsWUFDUjZNLE9BRFEsV0FDUkEsT0FEUTtBQUFBLFlBQ0M1TSxNQURELFdBQ0NBLE1BREQ7QUFBQSxZQUNTOEwsTUFEVCxXQUNTQSxNQURUO0FBQUEsWUFDaUIrQixRQURqQixXQUNpQkEsUUFEakI7O0FBRWhCLFlBQU1xNEMsV0FBV3pnRCxLQUFLMDNDLE1BQUwsQ0FBWSxDQUFaLEVBQWV2aUMsV0FBZixLQUErQm5WLEtBQUsyM0MsTUFBTCxDQUFZLENBQVosQ0FBaEQ7QUFDQSxZQUFNcjZDLE9BQU8sS0FBSzBMLE9BQUwsVUFBb0J5M0MsUUFBcEIsQ0FBYjtBQUNBLFlBQUlDLGlCQUFKO0FBQ0EsWUFBSXBqRCxJQUFKLEVBQVU7QUFDTixnQkFBSTJLLGdCQUFNbFIsY0FBTixDQUFxQnVHLEtBQUtzTSxJQUExQixDQUFKLEVBQXFDO0FBQ2pDODJDLDJCQUFXejRDLGdCQUFNMkMsWUFBTixDQUFtQnROLEtBQUtzTSxJQUF4QixFQUE4QixFQUFFdkQsY0FBRixFQUFVQyxPQUFPOEIsUUFBakIsRUFBOUIsQ0FBWDtBQUNILGFBRkQsTUFFTyxJQUFJLE9BQU85SyxLQUFLc00sSUFBWixLQUFxQixVQUF6QixFQUFxQztBQUN4QzgyQywyQkFBV3BqRCxLQUFLc00sSUFBTCxDQUFVdkQsTUFBVixFQUFrQitCLFFBQWxCLENBQVg7QUFDSDtBQUNELGdCQUFJczRDLFFBQUosRUFBYztBQUNWLG9CQUFJSCxRQUFRLEtBQUt6M0MsV0FBTCxDQUFpQnpDLE1BQWpCLENBQVo7QUFDQSxvQkFBSXJHLFNBQVMsUUFBVCxJQUFxQixLQUFLZ0osT0FBTCxDQUFhNDlCLFlBQWxDLElBQWtELEtBQUswWixXQUFMLEVBQXRELEVBQTBFO0FBQ3RFQyw0QkFBUUEsTUFBTW45QixLQUFOLENBQVksQ0FBWixFQUFlLENBQWYsQ0FBUjtBQUNBbTlCLDBCQUFNbm5ELElBQU4sQ0FDSTtBQUFBO0FBQUEsMEJBQUksU0FBUytOLFFBQVFsTyxNQUFSLEdBQWlCLENBQTlCLEVBQWlDLEtBQUksVUFBckM7QUFDSTtBQUFBO0FBQUEsOEJBQUssV0FBY3NCLE1BQWQsdUJBQUw7QUFDS21tRDtBQURMO0FBREoscUJBREo7QUFPQUEsK0JBQ0k7QUFBQTtBQUFBLDBCQUFJLFdBQWNubUQsTUFBZCxvQkFBbUN5RixJQUF2QztBQUNLdWdEO0FBREwscUJBREo7QUFLSCxpQkFkRCxNQWNPO0FBQ0hHLCtCQUFZO0FBQUE7QUFBQSwwQkFBSSxXQUFjbm1ELE1BQWQsb0JBQW1DeUYsSUFBdkM7QUFDUjtBQUFBO0FBQUEsOEJBQUksU0FBU21ILFFBQVFsTyxNQUFyQjtBQUNJO0FBQUE7QUFBQSxrQ0FBSyxXQUFjc0IsTUFBZCx1QkFBTDtBQUNLbW1EO0FBREw7QUFESjtBQURRLHFCQUFaO0FBT0g7QUFDSjtBQUNKO0FBQ0QsZUFBT0EsUUFBUDtBQUNILEs7OztFQW5HcUN0NUMsYSxVQUUvQjZDLFksR0FBZTtBQUNsQjZ1QyxnQkFBWTc4QyxvQkFBVWlNLEdBREo7QUFFbEI2M0MsZ0JBQVk5akQsb0JBQVVpTSxHQUZKO0FBR2xCMCtCLGtCQUFjM3FDLG9CQUFVakYsTUFITjtBQUlsQnFTLHdCQUFvQnBOLG9CQUFVa00sS0FKWjtBQUtsQlksY0FBVTlNLG9CQUFVb0UsS0FBVixDQUFnQixDQUFDLE1BQUQsRUFBUyxPQUFULENBQWhCO0FBTFEsQztrQkFGTDgvQyxZOzs7Ozs7Ozs7Ozs7OztrQkNIR0QsUTs7QUFIeEI7Ozs7QUFDQTs7Ozs7O0FBRWUsU0FBU0EsUUFBVCxDQUFrQjVsRCxLQUFsQixFQUF5QjtBQUNwQyxXQUFPLDhCQUFDLGNBQUQsYUFBZSxXQUFVLEtBQXpCLElBQW1DQSxLQUFuQyxFQUFQO0FBQ0g7Ozs7Ozs7Ozs7Ozs7O2tCQ0N1Qnc5QixNOztBQU54Qjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7OztBQUVlLFNBQVNBLE1BQVQsQ0FBZ0JvZSxhQUFoQixFQUErQjtBQUFBOztBQUMxQztBQUQwQyxRQUVwQ3lLLFdBRm9DO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBLDhCQWdDdEN0bUQsZUFoQ3NDLDhCQWdDcEI7QUFDZCxtQkFBTztBQUNIc2xCLHdCQUFTLEtBQUtybEIsS0FBTCxDQUFXdU0sVUFBWCxDQUFzQjhZLE1BQXRCLElBQWdDQSxnQkFEdEM7QUFFSDdiLDJCQUFXLEtBQUt4SixLQUFMLENBQVd3SixTQUZuQjtBQUdIZ2pDLDRCQUFZLEtBQUt4c0MsS0FBTCxDQUFXd3NDO0FBSHBCLGFBQVA7QUFLSCxTQXRDcUM7O0FBQUEsOEJBd0N0Q25yQyxNQXhDc0MscUJBd0M3QjtBQUNMO0FBREsseUJBRXNELEtBQUtyQixLQUYzRDtBQUFBLGdCQUVHdXNDLFlBRkgsVUFFR0EsWUFGSDtBQUFBLGdCQUVpQi9pQyxTQUZqQixVQUVpQkEsU0FGakI7QUFBQSxnQkFFNEJnakMsVUFGNUIsVUFFNEJBLFVBRjVCO0FBQUEsZ0JBRTJDemtDLE1BRjNDOztBQUFBLDBCQUc0QyxLQUFLL0gsS0FIakQ7QUFBQSxnQkFHQ3VNLFVBSEQsV0FHQ0EsVUFIRDtBQUFBLGdCQUdhbXVCLGFBSGIsV0FHYUEsYUFIYjtBQUFBLGdCQUc0QkMsV0FINUIsV0FHNEJBLFdBSDVCOztBQUlMLGdCQUFJNFIsWUFBSixFQUFrQjtBQUNkaGdDLDBDQUFpQkEsVUFBakI7QUFDQUEsMkJBQVc4WSxNQUFYLEdBQW9CaWhDLGdCQUFwQjtBQUNBM3JCLDhCQUFjLElBQWQ7QUFDQUQsZ0NBQWdCa1UsS0FBS0MsR0FBTCxDQUFTblUsYUFBVCxFQUF3QixLQUF4QixDQUFoQjtBQUNIO0FBQ0QsbUJBQU8sOEJBQUMsYUFBRCxlQUFtQjN5QixNQUFuQixJQUEyQixZQUFZd0UsVUFBdkMsRUFBbUQsYUFBYW91QixXQUFoRSxFQUE2RSxlQUFlRCxhQUE1RixJQUFQO0FBQ0gsU0FuRHFDOztBQUFBO0FBQUEsTUFFaEIvc0IsZ0JBQU1sTSxTQUZVLFVBRy9CNmtELFlBSCtCLEdBR2hCQSxnQkFIZ0IsU0FJL0I1a0QsU0FKK0I7QUFLbEM7OztBQUdBNnFDLHNCQUFjNXFDLG9CQUFVRSxJQVJVO0FBU2xDOzs7QUFHQTJILG1CQUFXN0gsb0JBQVV1SixNQVphO0FBYWxDOzs7QUFHQXNoQyxvQkFBWTdxQyxvQkFBVWpGLE1BaEJZO0FBaUJsQzZQLG9CQUFZNUssb0JBQVVqRjtBQWpCWSxPQWtCL0JrL0MsY0FBY2w2QyxTQWxCaUIsVUFxQi9CSyxZQXJCK0I7QUFzQmxDd0ssb0JBQVk7QUF0QnNCLE9BdUIvQnF2QyxjQUFjNzVDLFlBdkJpQixVQTBCL0JDLGlCQTFCK0IsR0EwQlg7QUFDdkJxakIsZ0JBQVExakIsb0JBQVVpTSxHQURLO0FBRXZCcEUsbUJBQVc3SCxvQkFBVXVKLE1BRkU7QUFHdkJzaEMsb0JBQVk3cUMsb0JBQVVqRjtBQUhDLEtBMUJXO0FBRXBDMnBELGVBRm9DOztBQXFEMUMsdUJBQVFBLFdBQVIsRUFBcUJ6SyxhQUFyQjtBQUNBLFdBQU95SyxXQUFQO0FBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0REOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7SUFDcUJFLFc7Ozs7Ozs7Ozs7Ozs0SkFVakJuYyxXLEdBQWMsVUFBQ250QixHQUFELEVBQVM7QUFDbkIsa0JBQUtqZCxLQUFMLENBQVc2bEIsUUFBWCxJQUF1QixNQUFLN2xCLEtBQUwsQ0FBVzZsQixRQUFYLENBQW9CNUksR0FBcEIsQ0FBdkI7QUFDSCxTOzs7MEJBRUQ1YixNLHFCQUFTO0FBQUE7O0FBQUEsWUFDR3BCLE1BREgsR0FDYyxLQUFLRCxLQURuQixDQUNHQyxNQURIO0FBQUEsdUJBRXFDLEtBQUt5TyxPQUYxQztBQUFBLFlBRUcyVyxNQUZILFlBRUdBLE1BRkg7QUFBQSxZQUVXN2IsU0FGWCxZQUVXQSxTQUZYO0FBQUEsWUFFc0JnakMsVUFGdEIsWUFFc0JBLFVBRnRCOzs7QUFJTCxZQUFNZ2EsZ0JBQWdCaGEsY0FBYyxFQUFwQzs7QUFKSyxZQUtHNW1DLFNBTEgsR0FLNEI0Z0QsYUFMNUIsQ0FLRzVnRCxTQUxIO0FBQUEsWUFLaUJtQyxNQUxqQiw0QkFLNEJ5K0MsYUFMNUI7O0FBTUwsWUFBTTkyQyxNQUFNLHlEQUNKelAsTUFESSxvQkFDa0IsSUFEbEIsY0FFUjJGLFNBRlEsR0FFUkEsU0FGUSxlQUFaOztBQUtBLGVBQVE7QUFBQywyQkFBRDtBQUFBLHVCQUFPLEtBQUssS0FBS3drQyxXQUFqQixJQUFrQ3JpQyxNQUFsQyxJQUEwQyxXQUFXMkgsR0FBckQsRUFBMEQsV0FBV2xHLFNBQXJFO0FBQ0osMENBQUMsTUFBRCxFQUFZLEtBQUt4SixLQUFqQjtBQURJLFNBQVI7QUFHSCxLOzs7RUE1Qm9DMk4sZ0JBQU1sTSxTLFVBQ3BDQyxTLEdBQVk7QUFDZnpCLFlBQVEwQixvQkFBVUM7QUFESCxDLFNBR1orTixZLEdBQWU7QUFDbEIwVixZQUFRMWpCLG9CQUFVaU0sR0FEQTtBQUVsQnBFLGVBQVc3SCxvQkFBVXVKLE1BRkg7QUFHbEJzaEMsZ0JBQVk3cUMsb0JBQVVqRjtBQUhKLEM7QUFKTDZwRCxXO2tCQUFBQSxXOzs7Ozs7Ozs7Ozs7Ozs7O0FDTnJCOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBO0lBQ01FLEs7OztBQXFDRixtQkFBWXptRCxLQUFaLEVBQW1CME8sT0FBbkIsRUFBNEI7QUFBQTs7QUFBQSxxREFDeEIsNEJBQU0xTyxLQUFOLEVBQWEwTyxPQUFiLENBRHdCOztBQUFBLGNBNEM1QisxQyxjQTVDNEIsR0E0Q1gsWUFBTTtBQUNuQixrQkFBS2lDLG1CQUFMO0FBQ0gsU0E5QzJCOztBQUFBLGNBZ0Q1QkEsbUJBaEQ0QixHQWdETixZQUFNO0FBQUEsOEJBQ1csTUFBSzFtRCxLQURoQjtBQUFBLGdCQUNoQm1qQixTQURnQixlQUNoQkEsU0FEZ0I7QUFBQSxnQkFDTHdqQyxXQURLLGVBQ0xBLFdBREs7O0FBRXhCLGdCQUFNQyxpQkFBaUJ6akMsV0FBdkI7O0FBRUEsZ0JBQUksQ0FBQ3lqQyxjQUFMLEVBQXFCO0FBQ2pCLHVCQUFPLEtBQVA7QUFDSDtBQUNELGdCQUFNQyxxQkFBcUIsc0JBQVVELGNBQVYsRUFBMEIsSUFBMUIsQ0FBM0IsQ0FQd0IsQ0FPdUM7QUFDL0QsZ0JBQU1FLGNBQWMsTUFBS0MsVUFBTCxDQUFnQixNQUFLQyxTQUFyQixFQUFnQ0osY0FBaEMsQ0FBcEIsQ0FSd0IsQ0FRNkM7QUFDckUsZ0JBQU1LLGtCQUFrQiwwQkFBY0wsY0FBZCxDQUF4QixDQVR3QixDQVN1QztBQUMvRCxnQkFBTU0sY0FBYyxNQUFLRixTQUFMLENBQWV2OUMsWUFBbkM7QUFDQSxnQkFBTTA5QyxnQkFBZ0Isb0JBQVFQLGNBQVIsQ0FBdEI7O0FBRUEsZ0JBQU1RLG1CQUFtQixNQUFLQyxjQUFMLENBQW9CNTlDLFlBQTdDOztBQUVBLGdCQUFNNjlDLFlBQVksTUFBS0EsU0FBdkI7QUFDQSxnQkFBTUMsYUFBYTtBQUNmMTRDLHVCQUFPaTRDLFlBQVlqNEM7QUFESixhQUFuQjtBQUdBLGdCQUFNMjRDLGlCQUFpQjtBQUNuQjM0Qyx1QkFBT2k0QyxZQUFZajRDLEtBREE7QUFFbkI4Syx3QkFBUXl0QztBQUZXLGFBQXZCOztBQUtBLGdCQUFJRSxVQUFVM3VDLEdBQVYsSUFBaUJrdUMscUJBQXFCQyxZQUFZbnVDLEdBQVosR0FBa0IydUMsVUFBVXBrQyxNQUF0RSxFQUE4RTtBQUMxRTtBQUNBLG9CQUFJeWpDLFdBQUosRUFBaUI7QUFDYlksK0JBQVc3dEMsUUFBWCxHQUFzQixVQUF0QjtBQUNBNnRDLCtCQUFXNXVDLEdBQVgsR0FBaUJrdUMsc0JBQXNCQyxZQUFZbnVDLEdBQVosR0FBa0IydUMsVUFBVXBrQyxNQUFsRCxDQUFqQjtBQUNBc2tDLG1DQUFlOXRDLFFBQWYsR0FBMEIsVUFBMUI7QUFDSCxpQkFKRCxNQUlPO0FBQ0g2dEMsK0JBQVc3dEMsUUFBWCxHQUFzQixPQUF0QjtBQUNBNnRDLCtCQUFXNXVDLEdBQVgsR0FBaUIydUMsVUFBVXBrQyxNQUFWLEdBQW1CaWtDLGNBQWN4dUMsR0FBbEQ7QUFDSDtBQUNELHNCQUFLOHVDLGNBQUwsQ0FBb0JGLFVBQXBCLEVBQWdDLElBQWhDO0FBQ0Esc0JBQUtHLGtCQUFMLENBQXdCRixjQUF4QjtBQUNILGFBWkQsTUFZTyxJQUFJRixVQUFVenVDLE1BQVYsSUFBb0JndUMscUJBQXFCQyxZQUFZbnVDLEdBQVosR0FBa0J1dUMsV0FBbEIsR0FBZ0NJLFVBQVVwa0MsTUFBMUMsR0FBbUQrakMsZUFBaEcsRUFBaUg7QUFDcEg7QUFDQU0sMkJBQVc1dEMsTUFBWCxHQUFvQnV0QyxXQUFwQjtBQUNBLG9CQUFJUCxXQUFKLEVBQWlCO0FBQ2JZLCtCQUFXN3RDLFFBQVgsR0FBc0IsVUFBdEI7QUFDQTZ0QywrQkFBVzV1QyxHQUFYLEdBQWlCa3VDLHNCQUFzQkMsWUFBWW51QyxHQUFaLEdBQWtCdXVDLFdBQWxCLEdBQWdDSSxVQUFVcGtDLE1BQTFDLEdBQW1EK2pDLGVBQXpFLENBQWpCO0FBQ0FPLG1DQUFlOXRDLFFBQWYsR0FBMEIsVUFBMUI7QUFDSCxpQkFKRCxNQUlPO0FBQ0g2dEMsK0JBQVc3dEMsUUFBWCxHQUFzQixPQUF0QjtBQUNBNnRDLCtCQUFXMXVDLE1BQVgsR0FBb0J5dUMsVUFBVXBrQyxNQUE5QjtBQUNIO0FBQ0Qsc0JBQUt1a0MsY0FBTCxDQUFvQkYsVUFBcEIsRUFBZ0MsSUFBaEM7QUFDQSxzQkFBS0csa0JBQUwsQ0FBd0JGLGNBQXhCO0FBQ0gsYUFiTSxNQWFBO0FBQ0gsc0JBQUtDLGNBQUwsQ0FBb0IsSUFBcEI7QUFDQSxzQkFBS0Msa0JBQUwsQ0FBd0IsSUFBeEI7QUFDSDtBQUNKLFNBckcyQjs7QUFBQSxjQW9LNUJDLG9CQXBLNEIsR0FvS0wsVUFBQzFxQyxHQUFELEVBQVM7QUFDNUIsa0JBQUsrcEMsU0FBTCxHQUFpQiwyQkFBWS9wQyxHQUFaLENBQWpCO0FBQ0gsU0F0SzJCOztBQUFBLGNBd0s1QjJxQyx5QkF4SzRCLEdBd0tBLFVBQUMzcUMsR0FBRCxFQUFTO0FBQ2pDLGtCQUFLb3FDLGNBQUwsR0FBc0IsMkJBQVlwcUMsR0FBWixDQUF0QjtBQUNILFNBMUsyQjs7QUFFeEIsY0FBS2pVLEtBQUwsR0FBYTtBQUNUZ0MsbUJBQU8sSUFERTtBQUVUdzhDLDRCQUFnQjtBQUZQLFNBQWI7QUFJQSxjQUFLRixTQUFMLEdBQWlCLE1BQUtPLGFBQUwsQ0FBbUI3bkQsS0FBbkIsQ0FBakI7QUFOd0I7QUFPM0I7O29CQUVEa0ksaUIsZ0NBQW9CO0FBQUE7O0FBQUEsWUFDUmliLFNBRFEsR0FDTSxLQUFLbmpCLEtBRFgsQ0FDUm1qQixTQURROztBQUVoQixhQUFLdWpDLG1CQUFMO0FBQ0E7QUFDQSxhQUFLajJCLE9BQUwsR0FBZTNRLFdBQVcsWUFBTTtBQUM1QixtQkFBS2dvQyw0QkFBTCxDQUFrQzNrQyxTQUFsQztBQUNILFNBRmMsQ0FBZjtBQUdILEs7O29CQUVEbmlCLG9CLG1DQUF1QjtBQUNuQixZQUFJLEtBQUt5dkIsT0FBVCxFQUFrQjtBQUNkalEseUJBQWEsS0FBS2lRLE9BQWxCO0FBQ0EsaUJBQUtBLE9BQUwsR0FBZSxJQUFmO0FBQ0g7QUFKa0IsWUFLWHROLFNBTFcsR0FLRyxLQUFLbmpCLEtBTFIsQ0FLWG1qQixTQUxXOztBQU1uQixhQUFLNGtDLCtCQUFMLENBQXFDNWtDLFNBQXJDO0FBQ0gsSzs7b0JBRUQya0MsNEIseUNBQTZCRSxZLEVBQWM7QUFDdkMsWUFBTTdrQyxZQUFZNmtDLGNBQWxCO0FBQ0EsWUFBSSxDQUFDN2tDLFNBQUwsRUFBZ0I7QUFDWjtBQUNIO0FBQ0R6bEIscUJBQU9xakIsRUFBUCxDQUFVb0MsU0FBVixFQUFxQixRQUFyQixFQUErQixLQUFLdWpDLG1CQUFwQyxFQUF5RCxLQUF6RDtBQUNBaHBELHFCQUFPcWpCLEVBQVAsQ0FBVW9DLFNBQVYsRUFBcUIsUUFBckIsRUFBK0IsS0FBS3VqQyxtQkFBcEMsRUFBeUQsS0FBekQ7QUFDSCxLOztvQkFFRHFCLCtCLDRDQUFnQ0MsWSxFQUFjO0FBQzFDLFlBQU03a0MsWUFBWTZrQyxjQUFsQjtBQUNBLFlBQUk3a0MsU0FBSixFQUFlO0FBQ1h6bEIseUJBQU9nakIsR0FBUCxDQUFXeUMsU0FBWCxFQUFzQixRQUF0QixFQUFnQyxLQUFLdWpDLG1CQUFyQztBQUNBaHBELHlCQUFPZ2pCLEdBQVAsQ0FBV3lDLFNBQVgsRUFBc0IsUUFBdEIsRUFBZ0MsS0FBS3VqQyxtQkFBckM7QUFDSDtBQUNKLEs7O29CQTZERG1CLGEsNEJBQWdCO0FBQUEscUJBQ3dCLEtBQUs3bkQsS0FEN0I7QUFBQSxZQUNKd0osU0FESSxVQUNKQSxTQURJO0FBQUEsWUFDT3krQyxZQURQLFVBQ09BLFlBRFA7O0FBRVosWUFBTVgsWUFBWTtBQUNkM3VDLGlCQUFLLEtBRFM7QUFFZEUsb0JBQVEsS0FGTTtBQUdkcUssb0JBQVE7QUFITSxTQUFsQjs7QUFNQSxZQUFJLE9BQU8xWixTQUFQLEtBQXFCLFFBQXJCLElBQWlDLE9BQU95K0MsWUFBUCxLQUF3QixRQUE3RCxFQUF1RTtBQUNuRTtBQUNBWCxzQkFBVTN1QyxHQUFWLEdBQWdCLElBQWhCO0FBQ0gsU0FIRCxNQUdPLElBQUksT0FBT25QLFNBQVAsS0FBcUIsUUFBekIsRUFBbUM7QUFDdEM4OUMsc0JBQVUzdUMsR0FBVixHQUFnQixJQUFoQjtBQUNBMnVDLHNCQUFVcGtDLE1BQVYsR0FBbUIxWixTQUFuQjtBQUNILFNBSE0sTUFHQSxJQUFJLE9BQU95K0MsWUFBUCxLQUF3QixRQUE1QixFQUFzQztBQUN6Q1gsc0JBQVV6dUMsTUFBVixHQUFtQixJQUFuQjtBQUNBeXVDLHNCQUFVcGtDLE1BQVYsR0FBbUIra0MsWUFBbkI7QUFDSDs7QUFFRCxlQUFPWCxTQUFQO0FBQ0gsSzs7b0JBRURHLGMsMkJBQWVGLFUsRUFBNkI7QUFBQSxZQUFqQlcsT0FBaUIsdUVBQVAsS0FBTzs7QUFDeEMsWUFBSXJxRCxVQUFJd0ksWUFBSixDQUFpQmtoRCxVQUFqQixFQUE2QixLQUFLditDLEtBQUwsQ0FBV2dDLEtBQXhDLENBQUosRUFBb0Q7QUFDaEQ7QUFDSDs7QUFFRCxhQUFLc1UsUUFBTCxDQUFjO0FBQ1Z0VSxtQkFBT3U4QztBQURHLFNBQWQ7O0FBTHdDLFlBU2hDWSxPQVRnQyxHQVNwQixLQUFLbm9ELEtBVGUsQ0FTaENtb0QsT0FUZ0M7OztBQVd4QyxZQUFJRCxPQUFKLEVBQWE7QUFDVEMsb0JBQVEsSUFBUjtBQUNILFNBRkQsTUFFTyxJQUFJLENBQUNaLFVBQUwsRUFBaUI7QUFDcEJZLG9CQUFRLEtBQVI7QUFDSDtBQUNKLEs7O29CQUVEVCxrQiwrQkFBbUJGLGMsRUFBZ0I7QUFDL0IsWUFBSTNwRCxVQUFJd0ksWUFBSixDQUFpQm1oRCxjQUFqQixFQUFpQyxLQUFLeCtDLEtBQUwsQ0FBV3crQyxjQUE1QyxDQUFKLEVBQWlFO0FBQzdEO0FBQ0g7QUFDRCxhQUFLbG9DLFFBQUwsQ0FBYyxFQUFFa29DLDhCQUFGLEVBQWQ7QUFDSCxLOztvQkFFRFQsVSx1QkFBV0MsUyxFQUFXSixjLEVBQWdCO0FBQ2xDLFlBQU13QixZQUFZcEIsVUFBVTdzQyxxQkFBVixFQUFsQixDQURrQyxDQUNvQjtBQUN0RCxZQUFNZ3RDLGdCQUFnQixvQkFBUVAsY0FBUixDQUF0QixDQUZrQyxDQUVhO0FBQy9DLFlBQU1DLHFCQUFxQixzQkFBVUQsY0FBVixFQUEwQixJQUExQixDQUEzQjtBQUNBLFlBQU15QixzQkFBc0Isc0JBQVV6QixjQUFWLEVBQTBCLEtBQTFCLENBQTVCOztBQUVBLGVBQU87QUFDSGp1QyxpQkFBS3l2QyxVQUFVenZDLEdBQVYsR0FBZ0J3dUMsY0FBY3h1QyxHQUE5QixHQUFvQ2t1QyxrQkFEdEM7QUFFSDkwQyxrQkFBTXEyQyxVQUFVcjJDLElBQVYsR0FBaUJvMUMsY0FBY3AxQyxJQUEvQixHQUFzQ3MyQyxtQkFGekM7QUFHSHg1QyxtQkFBT3U1QyxVQUFVdjVDLEtBSGQ7QUFJSDhLLG9CQUFReXVDLFVBQVV6dUM7QUFKZixTQUFQO0FBTUgsSzs7b0JBVUR0WSxNLHFCQUFTO0FBQUE7O0FBQUEsc0JBQzBDLEtBQUtyQixLQUQvQztBQUFBLFlBQ0dDLE1BREgsV0FDR0EsTUFESDtBQUFBLFlBQ1cyRixTQURYLFdBQ1dBLFNBRFg7QUFBQSxZQUNzQm9GLEtBRHRCLFdBQ3NCQSxLQUR0QjtBQUFBLFlBQzZCeEosUUFEN0IsV0FDNkJBLFFBRDdCOztBQUVMLFlBQU13SCxRQUFRLEtBQUtBLEtBQW5CO0FBQ0EsWUFBTXpLLGFBQWEseURBQ1gwQixNQURXLGNBQ0srSSxNQUFNZ0MsS0FEWCxjQUVYL0ssTUFGVyxrQkFFUyxDQUFDK0ksTUFBTWdDLEtBQVAsSUFBZ0IsS0FBS3M4QyxTQUFMLENBQWUzdUMsR0FGeEMsY0FHWDFZLE1BSFcscUJBR1ksQ0FBQytJLE1BQU1nQyxLQUFQLElBQWdCLEtBQUtzOEMsU0FBTCxDQUFlenVDLE1BSDNDLGNBSWRqVCxTQUpjLElBSUZBLFNBSkUsZUFBbkI7QUFNQSxZQUFNMGlELDZCQUFxQnQvQyxNQUFNdytDLGNBQTNCLEVBQThDeDhDLEtBQTlDLENBQU47O0FBRUEsZUFDSTtBQUFBO0FBQUEsY0FBSyxLQUFLLEtBQUsyOEMsb0JBQWYsRUFBcUMsT0FBT1csYUFBNUM7QUFDSTtBQUFBO0FBQUEsa0JBQUssS0FBSyxLQUFLVix5QkFBZixFQUEwQyxXQUFXcnBELFVBQXJELEVBQWlFLE9BQU95SyxNQUFNZ0MsS0FBOUU7QUFDS3hKO0FBREw7QUFESixTQURKO0FBT0gsSzs7O0VBbk9lbU0sZ0JBQU1sTSxTLFVBQ2ZDLFMsR0FBWTtBQUNmekIsWUFBUTBCLG9CQUFVQyxNQURIO0FBRWY7Ozs7QUFJQXVoQixlQUFXeGhCLG9CQUFVaEUsSUFOTjtBQU9mOzs7QUFHQTZMLGVBQVc3SCxvQkFBVXVKLE1BVk47QUFXZjs7O0FBR0ErOEMsa0JBQWN0bUQsb0JBQVV1SixNQWRUO0FBZWY7Ozs7QUFJQWk5QyxhQUFTeG1ELG9CQUFVaEUsSUFuQko7QUFvQmY7Ozs7QUFJQWdwRCxpQkFBYWhsRCxvQkFBVUUsSUF4QlI7QUF5QmYrRCxlQUFXakUsb0JBQVVDLE1BekJOO0FBMEJmb0osV0FBT3JKLG9CQUFVakYsTUExQkY7QUEyQmY4RSxjQUFVRyxvQkFBVWlNO0FBM0JMLEMsU0E4Qlo3TCxZLEdBQWU7QUFDbEI5QixZQUFRLE9BRFU7QUFFbEJrakIsZUFBVztBQUFBLGVBQU0zakIsTUFBTjtBQUFBLEtBRk87QUFHbEIyb0QsYUFBU3hxRCxXQUFLOE47QUFISSxDO0FBL0JwQmc3QyxLO2tCQXNPUzltRCx5QkFBZXNDLE1BQWYsQ0FBc0J3a0QsS0FBdEIsQzs7Ozs7Ozs7Ozs7UUMvT0M4QixTLEdBQUFBLFM7UUFTQUMsTyxHQUFBQSxPO1FBSUFDLGEsR0FBQUEsYTtBQWJULFNBQVNGLFNBQVQsQ0FBbUI5M0MsSUFBbkIsRUFBeUJpNEMsVUFBekIsRUFBcUM7QUFDeEMsUUFBSSxPQUFPbHBELE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7QUFDL0IsZUFBTyxDQUFQO0FBQ0g7QUFDRCxRQUFNbXBELGFBQWFELGFBQWEsYUFBYixHQUE2QixhQUFoRDtBQUNBLFFBQU1FLGNBQWNGLGFBQWEsV0FBYixHQUEyQixZQUEvQztBQUNBLFdBQU9qNEMsU0FBU2pSLE1BQVQsR0FBa0JpUixLQUFLazRDLFVBQUwsQ0FBbEIsR0FBcUNsNEMsS0FBS200QyxXQUFMLENBQTVDO0FBQ0g7O0FBRU0sU0FBU0osT0FBVCxDQUFpQi8zQyxJQUFqQixFQUF1QjtBQUMxQixXQUFPQSxTQUFTalIsTUFBVCxHQUFrQmlSLEtBQUswSixxQkFBTCxFQUFsQixHQUFpRCxFQUFFeEIsS0FBSyxDQUFQLEVBQVU1RyxNQUFNLENBQWhCLEVBQW1COEcsUUFBUSxDQUEzQixFQUF4RDtBQUNIOztBQUVNLFNBQVM0dkMsYUFBVCxDQUF1Qmg0QyxJQUF2QixFQUE2QjtBQUNoQyxRQUFJLENBQUNBLElBQUwsRUFBVztBQUNQLGVBQU8sQ0FBUDtBQUNIO0FBQ0QsUUFBSUEsU0FBU2pSLE1BQWIsRUFBcUI7QUFDakIsZUFBT0EsT0FBT3FwRCxXQUFkO0FBQ0g7QUFDRCxXQUFPcDRDLEtBQUtySCxZQUFaO0FBQ0gsQzs7Ozs7Ozs7O0FDckJEOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBLHlCOzs7Ozs7Ozs7QUNQQTs7QUFFQTtBQUNBLElBQUloRyxVQUFVckcsbUJBQU9BLENBQUMsRUFBUixDQUFkO0FBQ0EsSUFBRyxPQUFPcUcsT0FBUCxLQUFtQixRQUF0QixFQUFnQ0EsVUFBVSxDQUFDLENBQUN2RyxRQUFELEVBQVl1RyxPQUFaLEVBQXFCLEVBQXJCLENBQUQsQ0FBVjtBQUNoQztBQUNBLElBQUkrM0IsU0FBSjs7QUFFQSxJQUFJajVCLFVBQVUsRUFBZDtBQUNBQSxRQUFRaTVCLFNBQVIsR0FBb0JBLFNBQXBCO0FBQ0E7QUFDQSxJQUFJNk8sU0FBU2p0QyxtQkFBT0EsQ0FBQyxDQUFSLEVBQWtGcUcsT0FBbEYsRUFBMkZsQixPQUEzRixDQUFiO0FBQ0EsSUFBR2tCLFFBQVEwbEQsTUFBWCxFQUFtQmpzRCxPQUFPQyxPQUFQLEdBQWlCc0csUUFBUTBsRCxNQUF6QjtBQUNuQjtBQUNBLElBQUdqc0QsSUFBSCxFQUFlO0FBQ2Q7QUFDQSxLQUFHLENBQUN1RyxRQUFRMGxELE1BQVosRUFBb0I7QUFDbkJqc0QsU0FBT2tzRCxHQUFQLENBQVdDLE1BQVgsQ0FBa0IsRUFBbEIsRUFBZ1EsWUFBVztBQUMxUSxPQUFJQyxhQUFhbHNELG1CQUFPQSxDQUFDLEVBQVIsQ0FBakI7QUFDQSxPQUFHLE9BQU9rc0QsVUFBUCxLQUFzQixRQUF6QixFQUFtQ0EsYUFBYSxDQUFDLENBQUNwc0QsUUFBRCxFQUFZb3NELFVBQVosRUFBd0IsRUFBeEIsQ0FBRCxDQUFiO0FBQ25DamYsVUFBT2lmLFVBQVA7QUFDQSxHQUpEO0FBS0E7QUFDRDtBQUNBcHNELFFBQU9rc0QsR0FBUCxDQUFXRyxPQUFYLENBQW1CLFlBQVc7QUFBRWxmO0FBQVcsRUFBM0M7QUFDQSxDOzs7Ozs7Ozs7QUN4QkQ7Ozs7Ozs7Ozs7Ozs7QUFhQW50QyxPQUFPQyxPQUFQLEdBQWlCLFVBQVVxc0QsR0FBVixFQUFlO0FBQzlCO0FBQ0EsS0FBSXRvQixXQUFXLE9BQU9yaEMsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsT0FBT3FoQyxRQUF2RDs7QUFFQSxLQUFJLENBQUNBLFFBQUwsRUFBZTtBQUNiLFFBQU0sSUFBSTdjLEtBQUosQ0FBVSxrQ0FBVixDQUFOO0FBQ0Q7O0FBRUY7QUFDQSxLQUFJLENBQUNtbEMsR0FBRCxJQUFRLE9BQU9BLEdBQVAsS0FBZSxRQUEzQixFQUFxQztBQUNuQyxTQUFPQSxHQUFQO0FBQ0E7O0FBRUQsS0FBSUMsVUFBVXZvQixTQUFTd29CLFFBQVQsR0FBb0IsSUFBcEIsR0FBMkJ4b0IsU0FBU3lvQixJQUFsRDtBQUNBLEtBQUlDLGFBQWFILFVBQVV2b0IsU0FBUzJvQixRQUFULENBQWtCOWlELE9BQWxCLENBQTBCLFdBQTFCLEVBQXVDLEdBQXZDLENBQTNCOztBQUVEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBLEtBQUkraUQsV0FBV04sSUFBSXppRCxPQUFKLENBQVkscURBQVosRUFBbUUsVUFBU2dqRCxTQUFULEVBQW9CQyxPQUFwQixFQUE2QjtBQUM5RztBQUNBLE1BQUlDLGtCQUFrQkQsUUFDcEJqeUMsSUFEb0IsR0FFcEJoUixPQUZvQixDQUVaLFVBRlksRUFFQSxVQUFTbWpELENBQVQsRUFBWWp2QyxFQUFaLEVBQWU7QUFBRSxVQUFPQSxFQUFQO0FBQVksR0FGN0IsRUFHcEJsVSxPQUhvQixDQUdaLFVBSFksRUFHQSxVQUFTbWpELENBQVQsRUFBWWp2QyxFQUFaLEVBQWU7QUFBRSxVQUFPQSxFQUFQO0FBQVksR0FIN0IsQ0FBdEI7O0FBS0E7QUFDQSxNQUFJLCtDQUErQzNCLElBQS9DLENBQW9EMndDLGVBQXBELENBQUosRUFBMEU7QUFDeEUsVUFBT0YsU0FBUDtBQUNEOztBQUVEO0FBQ0EsTUFBSUksTUFBSjs7QUFFQSxNQUFJRixnQkFBZ0I1a0QsT0FBaEIsQ0FBd0IsSUFBeEIsTUFBa0MsQ0FBdEMsRUFBeUM7QUFDdEM7QUFDRjhrRCxZQUFTRixlQUFUO0FBQ0EsR0FIRCxNQUdPLElBQUlBLGdCQUFnQjVrRCxPQUFoQixDQUF3QixHQUF4QixNQUFpQyxDQUFyQyxFQUF3QztBQUM5QztBQUNBOGtELFlBQVNWLFVBQVVRLGVBQW5CLENBRjhDLENBRVY7QUFDcEMsR0FITSxNQUdBO0FBQ047QUFDQUUsWUFBU1AsYUFBYUssZ0JBQWdCbGpELE9BQWhCLENBQXdCLE9BQXhCLEVBQWlDLEVBQWpDLENBQXRCLENBRk0sQ0FFc0Q7QUFDNUQ7O0FBRUQ7QUFDQSxTQUFPLFNBQVNuQyxLQUFLQyxTQUFMLENBQWVzbEQsTUFBZixDQUFULEdBQWtDLEdBQXpDO0FBQ0EsRUE1QmMsQ0FBZjs7QUE4QkE7QUFDQSxRQUFPTCxRQUFQO0FBQ0EsQ0ExRUQsQzs7Ozs7Ozs7O0FDZEE7O0FBRUE7QUFDQSxJQUFJcm1ELFVBQVVyRyxtQkFBT0EsQ0FBQyxFQUFSLENBQWQ7QUFDQSxJQUFHLE9BQU9xRyxPQUFQLEtBQW1CLFFBQXRCLEVBQWdDQSxVQUFVLENBQUMsQ0FBQ3ZHLFFBQUQsRUFBWXVHLE9BQVosRUFBcUIsRUFBckIsQ0FBRCxDQUFWO0FBQ2hDO0FBQ0EsSUFBSSszQixTQUFKOztBQUVBLElBQUlqNUIsVUFBVSxFQUFkO0FBQ0FBLFFBQVFpNUIsU0FBUixHQUFvQkEsU0FBcEI7QUFDQTtBQUNBLElBQUk2TyxTQUFTanRDLG1CQUFPQSxDQUFDLENBQVIsRUFBa0ZxRyxPQUFsRixFQUEyRmxCLE9BQTNGLENBQWI7QUFDQSxJQUFHa0IsUUFBUTBsRCxNQUFYLEVBQW1CanNELE9BQU9DLE9BQVAsR0FBaUJzRyxRQUFRMGxELE1BQXpCO0FBQ25CO0FBQ0EsSUFBR2pzRCxJQUFILEVBQWU7QUFDZDtBQUNBLEtBQUcsQ0FBQ3VHLFFBQVEwbEQsTUFBWixFQUFvQjtBQUNuQmpzRCxTQUFPa3NELEdBQVAsQ0FBV0MsTUFBWCxDQUFrQixFQUFsQixFQUFnUSxZQUFXO0FBQzFRLE9BQUlDLGFBQWFsc0QsbUJBQU9BLENBQUMsRUFBUixDQUFqQjtBQUNBLE9BQUcsT0FBT2tzRCxVQUFQLEtBQXNCLFFBQXpCLEVBQW1DQSxhQUFhLENBQUMsQ0FBQ3BzRCxRQUFELEVBQVlvc0QsVUFBWixFQUF3QixFQUF4QixDQUFELENBQWI7QUFDbkNqZixVQUFPaWYsVUFBUDtBQUNBLEdBSkQ7QUFLQTtBQUNEO0FBQ0Fwc0QsUUFBT2tzRCxHQUFQLENBQVdHLE9BQVgsQ0FBbUIsWUFBVztBQUFFbGY7QUFBVyxFQUEzQztBQUNBLEM7Ozs7Ozs7OztBQ3pCRDs7QUFFQTtBQUNBLElBQUk1bUMsVUFBVXJHLG1CQUFPQSxDQUFDLEVBQVIsQ0FBZDtBQUNBLElBQUcsT0FBT3FHLE9BQVAsS0FBbUIsUUFBdEIsRUFBZ0NBLFVBQVUsQ0FBQyxDQUFDdkcsUUFBRCxFQUFZdUcsT0FBWixFQUFxQixFQUFyQixDQUFELENBQVY7QUFDaEM7QUFDQSxJQUFJKzNCLFNBQUo7O0FBRUEsSUFBSWo1QixVQUFVLEVBQWQ7QUFDQUEsUUFBUWk1QixTQUFSLEdBQW9CQSxTQUFwQjtBQUNBO0FBQ0EsSUFBSTZPLFNBQVNqdEMsbUJBQU9BLENBQUMsQ0FBUixFQUFrRnFHLE9BQWxGLEVBQTJGbEIsT0FBM0YsQ0FBYjtBQUNBLElBQUdrQixRQUFRMGxELE1BQVgsRUFBbUJqc0QsT0FBT0MsT0FBUCxHQUFpQnNHLFFBQVEwbEQsTUFBekI7QUFDbkI7QUFDQSxJQUFHanNELElBQUgsRUFBZTtBQUNkO0FBQ0EsS0FBRyxDQUFDdUcsUUFBUTBsRCxNQUFaLEVBQW9CO0FBQ25CanNELFNBQU9rc0QsR0FBUCxDQUFXQyxNQUFYLENBQWtCLEVBQWxCLEVBQWdRLFlBQVc7QUFDMVEsT0FBSUMsYUFBYWxzRCxtQkFBT0EsQ0FBQyxFQUFSLENBQWpCO0FBQ0EsT0FBRyxPQUFPa3NELFVBQVAsS0FBc0IsUUFBekIsRUFBbUNBLGFBQWEsQ0FBQyxDQUFDcHNELFFBQUQsRUFBWW9zRCxVQUFaLEVBQXdCLEVBQXhCLENBQUQsQ0FBYjtBQUNuQ2pmLFVBQU9pZixVQUFQO0FBQ0EsR0FKRDtBQUtBO0FBQ0Q7QUFDQXBzRCxRQUFPa3NELEdBQVAsQ0FBV0csT0FBWCxDQUFtQixZQUFXO0FBQUVsZjtBQUFXLEVBQTNDO0FBQ0EsQzs7Ozs7Ozs7O0FDekJEOztBQUVBO0FBQ0EsSUFBSTVtQyxVQUFVckcsbUJBQU9BLENBQUMsRUFBUixDQUFkO0FBQ0EsSUFBRyxPQUFPcUcsT0FBUCxLQUFtQixRQUF0QixFQUFnQ0EsVUFBVSxDQUFDLENBQUN2RyxRQUFELEVBQVl1RyxPQUFaLEVBQXFCLEVBQXJCLENBQUQsQ0FBVjtBQUNoQztBQUNBLElBQUkrM0IsU0FBSjs7QUFFQSxJQUFJajVCLFVBQVUsRUFBZDtBQUNBQSxRQUFRaTVCLFNBQVIsR0FBb0JBLFNBQXBCO0FBQ0E7QUFDQSxJQUFJNk8sU0FBU2p0QyxtQkFBT0EsQ0FBQyxDQUFSLEVBQWtGcUcsT0FBbEYsRUFBMkZsQixPQUEzRixDQUFiO0FBQ0EsSUFBR2tCLFFBQVEwbEQsTUFBWCxFQUFtQmpzRCxPQUFPQyxPQUFQLEdBQWlCc0csUUFBUTBsRCxNQUF6QjtBQUNuQjtBQUNBLElBQUdqc0QsSUFBSCxFQUFlO0FBQ2Q7QUFDQSxLQUFHLENBQUN1RyxRQUFRMGxELE1BQVosRUFBb0I7QUFDbkJqc0QsU0FBT2tzRCxHQUFQLENBQVdDLE1BQVgsQ0FBa0IsRUFBbEIsRUFBZ1EsWUFBVztBQUMxUSxPQUFJQyxhQUFhbHNELG1CQUFPQSxDQUFDLEVBQVIsQ0FBakI7QUFDQSxPQUFHLE9BQU9rc0QsVUFBUCxLQUFzQixRQUF6QixFQUFtQ0EsYUFBYSxDQUFDLENBQUNwc0QsUUFBRCxFQUFZb3NELFVBQVosRUFBd0IsRUFBeEIsQ0FBRCxDQUFiO0FBQ25DamYsVUFBT2lmLFVBQVA7QUFDQSxHQUpEO0FBS0E7QUFDRDtBQUNBcHNELFFBQU9rc0QsR0FBUCxDQUFXRyxPQUFYLENBQW1CLFlBQVc7QUFBRWxmO0FBQVcsRUFBM0M7QUFDQSxDOzs7Ozs7Ozs7QUN6QkQ7O0FBRUE7QUFDQSxJQUFJNW1DLFVBQVVyRyxtQkFBT0EsQ0FBQyxFQUFSLENBQWQ7QUFDQSxJQUFHLE9BQU9xRyxPQUFQLEtBQW1CLFFBQXRCLEVBQWdDQSxVQUFVLENBQUMsQ0FBQ3ZHLFFBQUQsRUFBWXVHLE9BQVosRUFBcUIsRUFBckIsQ0FBRCxDQUFWO0FBQ2hDO0FBQ0EsSUFBSSszQixTQUFKOztBQUVBLElBQUlqNUIsVUFBVSxFQUFkO0FBQ0FBLFFBQVFpNUIsU0FBUixHQUFvQkEsU0FBcEI7QUFDQTtBQUNBLElBQUk2TyxTQUFTanRDLG1CQUFPQSxDQUFDLENBQVIsRUFBa0ZxRyxPQUFsRixFQUEyRmxCLE9BQTNGLENBQWI7QUFDQSxJQUFHa0IsUUFBUTBsRCxNQUFYLEVBQW1CanNELE9BQU9DLE9BQVAsR0FBaUJzRyxRQUFRMGxELE1BQXpCO0FBQ25CO0FBQ0EsSUFBR2pzRCxJQUFILEVBQWU7QUFDZDtBQUNBLEtBQUcsQ0FBQ3VHLFFBQVEwbEQsTUFBWixFQUFvQjtBQUNuQmpzRCxTQUFPa3NELEdBQVAsQ0FBV0MsTUFBWCxDQUFrQixFQUFsQixFQUFnUSxZQUFXO0FBQzFRLE9BQUlDLGFBQWFsc0QsbUJBQU9BLENBQUMsRUFBUixDQUFqQjtBQUNBLE9BQUcsT0FBT2tzRCxVQUFQLEtBQXNCLFFBQXpCLEVBQW1DQSxhQUFhLENBQUMsQ0FBQ3BzRCxRQUFELEVBQVlvc0QsVUFBWixFQUF3QixFQUF4QixDQUFELENBQWI7QUFDbkNqZixVQUFPaWYsVUFBUDtBQUNBLEdBSkQ7QUFLQTtBQUNEO0FBQ0Fwc0QsUUFBT2tzRCxHQUFQLENBQVdHLE9BQVgsQ0FBbUIsWUFBVztBQUFFbGY7QUFBVyxFQUEzQztBQUNBLEM7Ozs7Ozs7OztBQ3pCRDs7QUFFQTtBQUNBLElBQUk1bUMsVUFBVXJHLG1CQUFPQSxDQUFDLEVBQVIsQ0FBZDtBQUNBLElBQUcsT0FBT3FHLE9BQVAsS0FBbUIsUUFBdEIsRUFBZ0NBLFVBQVUsQ0FBQyxDQUFDdkcsUUFBRCxFQUFZdUcsT0FBWixFQUFxQixFQUFyQixDQUFELENBQVY7QUFDaEM7QUFDQSxJQUFJKzNCLFNBQUo7O0FBRUEsSUFBSWo1QixVQUFVLEVBQWQ7QUFDQUEsUUFBUWk1QixTQUFSLEdBQW9CQSxTQUFwQjtBQUNBO0FBQ0EsSUFBSTZPLFNBQVNqdEMsbUJBQU9BLENBQUMsQ0FBUixFQUFrRnFHLE9BQWxGLEVBQTJGbEIsT0FBM0YsQ0FBYjtBQUNBLElBQUdrQixRQUFRMGxELE1BQVgsRUFBbUJqc0QsT0FBT0MsT0FBUCxHQUFpQnNHLFFBQVEwbEQsTUFBekI7QUFDbkI7QUFDQSxJQUFHanNELElBQUgsRUFBZTtBQUNkO0FBQ0EsS0FBRyxDQUFDdUcsUUFBUTBsRCxNQUFaLEVBQW9CO0FBQ25CanNELFNBQU9rc0QsR0FBUCxDQUFXQyxNQUFYLENBQWtCLEVBQWxCLEVBQWdRLFlBQVc7QUFDMVEsT0FBSUMsYUFBYWxzRCxtQkFBT0EsQ0FBQyxFQUFSLENBQWpCO0FBQ0EsT0FBRyxPQUFPa3NELFVBQVAsS0FBc0IsUUFBekIsRUFBbUNBLGFBQWEsQ0FBQyxDQUFDcHNELFFBQUQsRUFBWW9zRCxVQUFaLEVBQXdCLEVBQXhCLENBQUQsQ0FBYjtBQUNuQ2pmLFVBQU9pZixVQUFQO0FBQ0EsR0FKRDtBQUtBO0FBQ0Q7QUFDQXBzRCxRQUFPa3NELEdBQVAsQ0FBV0csT0FBWCxDQUFtQixZQUFXO0FBQUVsZjtBQUFXLEVBQTNDO0FBQ0EsQzs7Ozs7Ozs7O0FDekJEOztBQUNBLHlCOzs7Ozs7Ozs7QUNEQTs7QUFFQTtBQUNBLElBQUk1bUMsVUFBVXJHLG1CQUFPQSxDQUFDLEVBQVIsQ0FBZDtBQUNBLElBQUcsT0FBT3FHLE9BQVAsS0FBbUIsUUFBdEIsRUFBZ0NBLFVBQVUsQ0FBQyxDQUFDdkcsUUFBRCxFQUFZdUcsT0FBWixFQUFxQixFQUFyQixDQUFELENBQVY7QUFDaEM7QUFDQSxJQUFJKzNCLFNBQUo7O0FBRUEsSUFBSWo1QixVQUFVLEVBQWQ7QUFDQUEsUUFBUWk1QixTQUFSLEdBQW9CQSxTQUFwQjtBQUNBO0FBQ0EsSUFBSTZPLFNBQVNqdEMsbUJBQU9BLENBQUMsQ0FBUixFQUFrRnFHLE9BQWxGLEVBQTJGbEIsT0FBM0YsQ0FBYjtBQUNBLElBQUdrQixRQUFRMGxELE1BQVgsRUFBbUJqc0QsT0FBT0MsT0FBUCxHQUFpQnNHLFFBQVEwbEQsTUFBekI7QUFDbkI7QUFDQSxJQUFHanNELElBQUgsRUFBZTtBQUNkO0FBQ0EsS0FBRyxDQUFDdUcsUUFBUTBsRCxNQUFaLEVBQW9CO0FBQ25CanNELFNBQU9rc0QsR0FBUCxDQUFXQyxNQUFYLENBQWtCLEVBQWxCLEVBQWdRLFlBQVc7QUFDMVEsT0FBSUMsYUFBYWxzRCxtQkFBT0EsQ0FBQyxFQUFSLENBQWpCO0FBQ0EsT0FBRyxPQUFPa3NELFVBQVAsS0FBc0IsUUFBekIsRUFBbUNBLGFBQWEsQ0FBQyxDQUFDcHNELFFBQUQsRUFBWW9zRCxVQUFaLEVBQXdCLEVBQXhCLENBQUQsQ0FBYjtBQUNuQ2pmLFVBQU9pZixVQUFQO0FBQ0EsR0FKRDtBQUtBO0FBQ0Q7QUFDQXBzRCxRQUFPa3NELEdBQVAsQ0FBV0csT0FBWCxDQUFtQixZQUFXO0FBQUVsZjtBQUFXLEVBQTNDO0FBQ0EsQzs7Ozs7Ozs7O0FDekJEOztBQUVBO0FBQ0EsSUFBSTVtQyxVQUFVckcsbUJBQU9BLENBQUMsRUFBUixDQUFkO0FBQ0EsSUFBRyxPQUFPcUcsT0FBUCxLQUFtQixRQUF0QixFQUFnQ0EsVUFBVSxDQUFDLENBQUN2RyxRQUFELEVBQVl1RyxPQUFaLEVBQXFCLEVBQXJCLENBQUQsQ0FBVjtBQUNoQztBQUNBLElBQUkrM0IsU0FBSjs7QUFFQSxJQUFJajVCLFVBQVUsRUFBZDtBQUNBQSxRQUFRaTVCLFNBQVIsR0FBb0JBLFNBQXBCO0FBQ0E7QUFDQSxJQUFJNk8sU0FBU2p0QyxtQkFBT0EsQ0FBQyxDQUFSLEVBQWtGcUcsT0FBbEYsRUFBMkZsQixPQUEzRixDQUFiO0FBQ0EsSUFBR2tCLFFBQVEwbEQsTUFBWCxFQUFtQmpzRCxPQUFPQyxPQUFQLEdBQWlCc0csUUFBUTBsRCxNQUF6QjtBQUNuQjtBQUNBLElBQUdqc0QsSUFBSCxFQUFlO0FBQ2Q7QUFDQSxLQUFHLENBQUN1RyxRQUFRMGxELE1BQVosRUFBb0I7QUFDbkJqc0QsU0FBT2tzRCxHQUFQLENBQVdDLE1BQVgsQ0FBa0IsRUFBbEIsRUFBZ1EsWUFBVztBQUMxUSxPQUFJQyxhQUFhbHNELG1CQUFPQSxDQUFDLEVBQVIsQ0FBakI7QUFDQSxPQUFHLE9BQU9rc0QsVUFBUCxLQUFzQixRQUF6QixFQUFtQ0EsYUFBYSxDQUFDLENBQUNwc0QsUUFBRCxFQUFZb3NELFVBQVosRUFBd0IsRUFBeEIsQ0FBRCxDQUFiO0FBQ25DamYsVUFBT2lmLFVBQVA7QUFDQSxHQUpEO0FBS0E7QUFDRDtBQUNBcHNELFFBQU9rc0QsR0FBUCxDQUFXRyxPQUFYLENBQW1CLFlBQVc7QUFBRWxmO0FBQVcsRUFBM0M7QUFDQSxDOzs7Ozs7Ozs7QUN6QkQ7O0FBRUE7QUFDQSxJQUFJNW1DLFVBQVVyRyxtQkFBT0EsQ0FBQyxFQUFSLENBQWQ7QUFDQSxJQUFHLE9BQU9xRyxPQUFQLEtBQW1CLFFBQXRCLEVBQWdDQSxVQUFVLENBQUMsQ0FBQ3ZHLFFBQUQsRUFBWXVHLE9BQVosRUFBcUIsRUFBckIsQ0FBRCxDQUFWO0FBQ2hDO0FBQ0EsSUFBSSszQixTQUFKOztBQUVBLElBQUlqNUIsVUFBVSxFQUFkO0FBQ0FBLFFBQVFpNUIsU0FBUixHQUFvQkEsU0FBcEI7QUFDQTtBQUNBLElBQUk2TyxTQUFTanRDLG1CQUFPQSxDQUFDLENBQVIsRUFBa0ZxRyxPQUFsRixFQUEyRmxCLE9BQTNGLENBQWI7QUFDQSxJQUFHa0IsUUFBUTBsRCxNQUFYLEVBQW1CanNELE9BQU9DLE9BQVAsR0FBaUJzRyxRQUFRMGxELE1BQXpCO0FBQ25CO0FBQ0EsSUFBR2pzRCxJQUFILEVBQWU7QUFDZDtBQUNBLEtBQUcsQ0FBQ3VHLFFBQVEwbEQsTUFBWixFQUFvQjtBQUNuQmpzRCxTQUFPa3NELEdBQVAsQ0FBV0MsTUFBWCxDQUFrQixFQUFsQixFQUFnUSxZQUFXO0FBQzFRLE9BQUlDLGFBQWFsc0QsbUJBQU9BLENBQUMsRUFBUixDQUFqQjtBQUNBLE9BQUcsT0FBT2tzRCxVQUFQLEtBQXNCLFFBQXpCLEVBQW1DQSxhQUFhLENBQUMsQ0FBQ3BzRCxRQUFELEVBQVlvc0QsVUFBWixFQUF3QixFQUF4QixDQUFELENBQWI7QUFDbkNqZixVQUFPaWYsVUFBUDtBQUNBLEdBSkQ7QUFLQTtBQUNEO0FBQ0Fwc0QsUUFBT2tzRCxHQUFQLENBQVdHLE9BQVgsQ0FBbUIsWUFBVztBQUFFbGY7QUFBVyxFQUEzQztBQUNBLEM7Ozs7Ozs7OztBQ3pCRDs7QUFFQTtBQUNBLElBQUk1bUMsVUFBVXJHLG1CQUFPQSxDQUFDLEVBQVIsQ0FBZDtBQUNBLElBQUcsT0FBT3FHLE9BQVAsS0FBbUIsUUFBdEIsRUFBZ0NBLFVBQVUsQ0FBQyxDQUFDdkcsUUFBRCxFQUFZdUcsT0FBWixFQUFxQixFQUFyQixDQUFELENBQVY7QUFDaEM7QUFDQSxJQUFJKzNCLFNBQUo7O0FBRUEsSUFBSWo1QixVQUFVLEVBQWQ7QUFDQUEsUUFBUWk1QixTQUFSLEdBQW9CQSxTQUFwQjtBQUNBO0FBQ0EsSUFBSTZPLFNBQVNqdEMsbUJBQU9BLENBQUMsQ0FBUixFQUFrRnFHLE9BQWxGLEVBQTJGbEIsT0FBM0YsQ0FBYjtBQUNBLElBQUdrQixRQUFRMGxELE1BQVgsRUFBbUJqc0QsT0FBT0MsT0FBUCxHQUFpQnNHLFFBQVEwbEQsTUFBekI7QUFDbkI7QUFDQSxJQUFHanNELElBQUgsRUFBZTtBQUNkO0FBQ0EsS0FBRyxDQUFDdUcsUUFBUTBsRCxNQUFaLEVBQW9CO0FBQ25CanNELFNBQU9rc0QsR0FBUCxDQUFXQyxNQUFYLENBQWtCLEVBQWxCLEVBQWdRLFlBQVc7QUFDMVEsT0FBSUMsYUFBYWxzRCxtQkFBT0EsQ0FBQyxFQUFSLENBQWpCO0FBQ0EsT0FBRyxPQUFPa3NELFVBQVAsS0FBc0IsUUFBekIsRUFBbUNBLGFBQWEsQ0FBQyxDQUFDcHNELFFBQUQsRUFBWW9zRCxVQUFaLEVBQXdCLEVBQXhCLENBQUQsQ0FBYjtBQUNuQ2pmLFVBQU9pZixVQUFQO0FBQ0EsR0FKRDtBQUtBO0FBQ0Q7QUFDQXBzRCxRQUFPa3NELEdBQVAsQ0FBV0csT0FBWCxDQUFtQixZQUFXO0FBQUVsZjtBQUFXLEVBQTNDO0FBQ0EsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QkQsMkJBQTJCLG1CQUFPLENBQUMsQ0FBc0U7QUFDekc7OztBQUdBO0FBQ0EsY0FBYyxRQUFTLFdBQVcsd0JBQXdCLEdBQUc7O0FBRTdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKQTs7OztBQUNBOztBQUdBOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBUkFqdEMsbUJBQU9BLENBQVBBOztBQVdBLElBQU00UCxhQUFhLFNBQWJBLFVBQWEsR0FBTTtBQUNqQixRQUFNd08sU0FBTjtBQUNBLFNBQUssSUFBSTFjLElBQVQsR0FBZ0JBLElBQWhCLFFBQTRCO0FBQ3hCMGMsb0JBQVk7QUFDUnRMLGlEQUFrQyxJQUFsQ0EsS0FEUTtBQUVScE0sZ0JBQUksZUFGSTtBQUdSMmQsa0JBQU0sT0FBTzNpQjtBQUhMLFNBQVowYztBQUtIO0FBQ0Q7QUFUUjtBQUFBLElBV0k5WixVQUFTLFNBQVRBLE9BQVMsdUJBQTBCO0FBQy9CLFdBQU8sMENBQVcwSyxPQUFYLFFBQVA7QUFaUjs7SUFlTWcrQyxNOzs7QUFDRix3QkFBbUI7QUFBQTs7QUFBQSxxREFDZiw0QkFEZSxLQUNmLENBRGU7O0FBRWYsc0JBQWE7QUFDVHA5Qyx3QkFEUztBQUVUL0csdUJBRlM7QUFHVGdKLG1CQUFPO0FBSEUsU0FBYjtBQUZlO0FBT2xCOztrQkFDRG83QyxXLDBCQUFjO0FBQ1Ysc0JBQWM7QUFDVnRlLHFCQUFTLENBQUMsV0FBV0E7QUFEWCxTQUFkOzs7a0JBSUp1ZSxZLDJCQUFlO0FBQ1gsc0JBQWM7QUFDVnhlLHVCQUFXLENBQUMsV0FBV0E7QUFEYixTQUFkOzs7a0JBSUp5ZSxVLHlCQUFhO0FBQ1Qsc0JBQWM7QUFDVnRrRCx1QkFBVztBQURELFNBQWQ7OztrQkFJSnVrRCxTLHdCQUFZO0FBQ1Isc0JBQWM7QUFDVnY3QyxtQkFBTztBQURHLFNBQWQ7OztrQkFJSnZOLE0scUJBQVM7QUFDTCxlQUFRLGtDQUNKLCtCQUNJLG9CQUFDLFNBQUQsV0FBUSxTQUFTLHNCQUFqQixJQUFpQixDQUFqQixxQkFESixXQUVJLG9CQUFDLFNBQUQsV0FBUSxTQUFTLHVCQUFqQixJQUFpQixDQUFqQixxQkFGSixXQUdJLG9CQUFDLFNBQUQsV0FBUSxTQUFTLHFCQUFqQixJQUFpQixDQUFqQixrQ0FISixXQUlJLG9CQUFDLFNBQUQsV0FBUSxTQUFTLG9CQUFqQixJQUFpQixDQUFqQixzQ0FKSixVQURJLEVBT0osb0JBQUMsUUFBRCxXQUFPLFlBQVksV0FBbkI7QUFDSSxxQkFBUyxXQURiO0FBRUksdUJBQVcsV0FGZixhQUdJLG9CQUFDLFFBQUQsT0FBQyxDQUFELFVBQWMsT0FBZCxNQUF5QixXQUF6QixNQUF5QyxPQUFPLFdBSHBELEtBR0ksR0FISixFQUlJLG9CQUFDLFFBQUQsT0FBQyxDQUFELFVBQWMsT0FBZCxTQUE0QixXQUE1QixTQUE4QyxXQUFXLFdBSjdELFNBSUksR0FKSixFQUtJLG9CQUFDLFFBQUQsT0FBQyxDQUFELFVBQWMsT0FBZCxRQUEyQixXQUwvQixNQUtJLEdBTEosRUFNSSxvQkFBQyxRQUFELE9BQUMsQ0FBRCxVQUFjLE1BQWQsU0FBNEIsT0FBNUIsTUFOSixDQVBJLENBQVI7Ozs7RUE5QlVzTSxNQUFNbE0sUzs7QUFBbEJzb0QsSSxXQUFBQSxHLEtBQUFBOztBQWlETkssZ0JBQWdCLHlCQUFoQkEsSUFBZ0IsQ0FBaEJBOztBQUdBO0FBQ0EsSUFBTUMsZ0JBQWdCcjVDLHVCQUF0QixpQkFBc0JBLENBQXRCO0FBQ0FxNUM7QUFDQSxJQUFNQyxnQkFBZ0J0NUMsdUJBQXRCLGlCQUFzQkEsQ0FBdEI7QUFDQXM1QywwQkFBMEIsbTNJQUExQkEsR0FBMEIsQ0FBMUJBOztBQTBFQSxJQUFJenRELElBQUosRUFBZ0I7QUFDZEE7O0FBRUEsUUFBTTB0RCxZQUFZdjVDLHVCQUFsQixzQkFBa0JBLENBQWxCOztBQUVBLFFBQUksQ0FBQ3hSLE9BQUwscUJBQWlDO0FBQy9CM0Msb0NBQTRCLGtCQUFVO0FBQ3BDMkM7QUFDQSxnQkFBSWdmLFdBQUosU0FBd0I7QUFDdEIrckM7QUFERixtQkFFTyxJQUFJL3JDLFdBQUosUUFBdUI7QUFDNUIrckM7QUFDRDtBQU5IMXREO0FBUUQ7QUFDRixDOzs7Ozs7QUMzS0Q7O0FBRUE7QUFDQSxjQUFjLG1CQUFPLENBQUMsR0FBNkg7QUFDbkosNENBQTRDLFFBQVM7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsQ0FBMkU7QUFDaEc7QUFDQTtBQUNBLEdBQUcsSUFBVTtBQUNiO0FBQ0E7QUFDQSxvQkFBb0IsR0FBNkg7QUFDakosb0JBQW9CLG1CQUFPLENBQUMsR0FBNkg7QUFDekoscURBQXFELFFBQVM7QUFDOUQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMsQyIsImZpbGUiOiIvVXNlcnMvemhhb2d1b3lhbi9naXRodWIvcHViL2RvY3MvdGFibGUvZGVtby9zdHlsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gd2luZG93LlJlYWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwid2luZG93LlJlYWN0XCJcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIDEyIDEzIDE0IDE1IDE2IDE3IDE4IDE5IDIwIDIxIDIyIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICBTeW1ib2wuZm9yICYmXG4gICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgIDB4ZWFjNztcblxuICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH07XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19wcm9wLXR5cGVzQDE1LjYuMkBwcm9wLXR5cGVzL2luZGV4LmpzIiwiaW1wb3J0ICogYXMgX2RvbSBmcm9tICcuL2RvbSc7XG5pbXBvcnQgKiBhcyBfZW52IGZyb20gJy4vZW52JztcbmltcG9ydCAqIGFzIF9ldmVudHMgZnJvbSAnLi9ldmVudHMnO1xuaW1wb3J0ICogYXMgX2Z1bmMgZnJvbSAnLi9mdW5jJztcbmltcG9ydCAqIGFzIF9sb2cgZnJvbSAnLi9sb2cnO1xuaW1wb3J0ICogYXMgX29iamVjdCBmcm9tICcuL29iamVjdCc7XG5pbXBvcnQgKiBhcyBfc3RyaW5nIGZyb20gJy4vc3RyaW5nJztcbmltcG9ydCAqIGFzIF9zdXBwb3J0IGZyb20gJy4vc3VwcG9ydCc7XG5pbXBvcnQgKiBhcyBfZm9jdXMgZnJvbSAnLi9mb2N1cyc7XG5pbXBvcnQgX2d1aWQgZnJvbSAnLi9ndWlkJztcbmltcG9ydCBfS0VZQ09ERSBmcm9tICcuL2tleWNvZGUnO1xuXG5leHBvcnQgY29uc3QgZG9tID0gX2RvbTtcbmV4cG9ydCBjb25zdCBlbnYgPSBfZW52O1xuZXhwb3J0IGNvbnN0IGV2ZW50cyA9IF9ldmVudHM7XG5leHBvcnQgY29uc3QgZnVuYyA9IF9mdW5jO1xuZXhwb3J0IGNvbnN0IGxvZyA9IF9sb2c7XG5leHBvcnQgY29uc3Qgb2JqID0gX29iamVjdDtcbmV4cG9ydCBjb25zdCBzdHIgPSBfc3RyaW5nO1xuZXhwb3J0IGNvbnN0IHN1cHBvcnQgPSBfc3VwcG9ydDtcbmV4cG9ydCBjb25zdCBmb2N1cyA9IF9mb2N1cztcbmV4cG9ydCBjb25zdCBndWlkID0gX2d1aWQ7XG5leHBvcnQgY29uc3QgS0VZQ09ERSA9IF9LRVlDT0RFO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWwvaW5kZXguanMiLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE3IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpICYmIGFyZy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGlubmVyID0gY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdFx0XHRpZiAoaW5uZXIpIHtcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goaW5uZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRjbGFzc05hbWVzLmRlZmF1bHQgPSBjbGFzc05hbWVzO1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX2NsYXNzbmFtZXNAMi4yLjZAY2xhc3NuYW1lcy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gd2luZG93LlJlYWN0RE9NO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwid2luZG93LlJlYWN0RE9NXCJcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIDEyIDEzIDE0IDE1IDE2IDE3IDE4IDE5IDIwIDIxIDIyIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgZ2V0Q29udGV4dFByb3BzIGZyb20gJy4vZ2V0LWNvbnRleHQtcHJvcHMnO1xuaW1wb3J0IHtcbiAgICBjb25maWcsXG4gICAgaW5pdExvY2FsZXMsXG4gICAgc2V0TGFuZ3VhZ2UsXG4gICAgc2V0TG9jYWxlLFxuICAgIHNldERpcmVjdGlvbixcbiAgICBnZXRMb2NhbGUsXG4gICAgZ2V0TGFuZ3VhZ2UsXG4gICAgZ2V0RGlyZWN0aW9uXG59IGZyb20gJy4vY29uZmlnJztcbmltcG9ydCBDb25zdW1lciBmcm9tICcuL2NvbnN1bWVyJztcbmltcG9ydCBDYWNoZSBmcm9tICcuL2NhY2hlJztcblxuY29uc3QgY2hpbGRDb250ZXh0Q2FjaGUgPSBuZXcgQ2FjaGUoKTtcblxuLyoqXG4gKiBDb25maWdQcm92aWRlclxuICogQHByb3BzRXh0ZW5kcyBmYWxzZVxuICovXG5jbGFzcyBDb25maWdQcm92aWRlciBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOagt+W8j+exu+WQjeeahOWTgeeJjOWJjee8gFxuICAgICAgICAgKi9cbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu96ZmF5YyW5paH5qGI5a+56LGh77yM5bGe5oCn5Li657uE5Lu255qEIGRpc3BsYXlOYW1lXG4gICAgICAgICAqL1xuICAgICAgICBsb2NhbGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblvIDlkK8gUHVyZSBSZW5kZXIg5qih5byP77yM5Lya5o+Q6auY5oCn6IO977yM5L2G5piv5Lmf5Lya5bim5p2l5Ymv5L2c55SoXG4gICAgICAgICAqL1xuICAgICAgICBwdXJlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuWcqOW8gOWPkeaooeW8j+S4i+aYvuekuue7hOS7tuWxnuaAp+iiq+W6n+W8g+eahCB3YXJuaW5nIOaPkOekulxuICAgICAgICAgKi9cbiAgICAgICAgd2FybmluZzogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblvIDlkK8gcnRsIOaooeW8j1xuICAgICAgICAgKi9cbiAgICAgICAgcnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe7hOS7tuagkVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5lbGVtZW50XG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHdhcm5pbmc6IHRydWVcbiAgICB9O1xuXG4gICAgc3RhdGljIGNoaWxkQ29udGV4dFR5cGVzID0ge1xuICAgICAgICBuZXh0UHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBuZXh0TG9jYWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBuZXh0UHVyZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIG5leHRSdGw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBuZXh0V2FybmluZzogUHJvcFR5cGVzLmJvb2xcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5Lyg5YWl57uE5Lu277yM55Sf5oiQ5Y+XIENvbmZpZ1Byb3ZpZGVyIOaOp+WItueahCBIT0Mg57uE5Lu2XG4gICAgICogQHBhcmFtIHtDb21wb25lbnR9IENvbXBvbmVudCDnu4Tku7bnsbtcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyDlj6/pgInpoblcbiAgICAgKiBAcmV0dXJucyB7Q29tcG9uZW50fSBIT0NcbiAgICAgKi9cbiAgICBzdGF0aWMgY29uZmlnID0gKENvbXBvbmVudCwgb3B0aW9ucykgPT4ge1xuICAgICAgICByZXR1cm4gY29uZmlnKENvbXBvbmVudCwgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOS8oOWFpee7hOS7tueahCBwcm9wcyDlkowgZGlzcGxheU5hbWXvvIzlvpfliLDlkowgY2hpbGRDb250ZXh0IOiuoeeul+i/h+eahOWMheWQq+aciSBwcmVpZngvbG9jYWxlL3B1cmUg55qE5a+56LGh77yM5LiA6Iis55So5LqO6YCa6L+H6Z2Z5oCB5pa55rOV55Sf5oiQ6ISx56a757uE5Lu25qCR55qE57uE5Lu2XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIOe7hOS7tueahCBwcm9wc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkaXNwbGF5TmFtZSDnu4Tku7bnmoQgZGlzcGxheU5hbWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSDmlrDnmoQgY29udGV4dCBwcm9wc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDb250ZXh0UHJvcHMgPSAocHJvcHMsIGRpc3BsYXlOYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0UHJvcHMocHJvcHMsIGNoaWxkQ29udGV4dENhY2hlLnJvb3QoKSB8fCB7fSwgZGlzcGxheU5hbWUpO1xuICAgIH07XG5cbiAgICBzdGF0aWMgaW5pdExvY2FsZXMgPSBpbml0TG9jYWxlcztcbiAgICBzdGF0aWMgc2V0TGFuZ3VhZ2UgPSBzZXRMYW5ndWFnZTtcbiAgICBzdGF0aWMgc2V0TG9jYWxlID0gc2V0TG9jYWxlO1xuICAgIHN0YXRpYyBzZXREaXJlY3Rpb24gPSBzZXREaXJlY3Rpb247XG4gICAgc3RhdGljIGdldExhbmd1YWdlID0gZ2V0TGFuZ3VhZ2U7XG4gICAgc3RhdGljIGdldExvY2FsZSA9IGdldExvY2FsZTtcbiAgICBzdGF0aWMgZ2V0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uO1xuICAgIHN0YXRpYyBDb25zdW1lciA9IENvbnN1bWVyO1xuXG4gICAgc3RhdGljIGdldENvbnRleHQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbmV4dFByZWZpeCwgbmV4dExvY2FsZSwgbmV4dFB1cmUsIG5leHRSdGwsIG5leHRXYXJuaW5nIH0gPSBjaGlsZENvbnRleHRDYWNoZS5yb290KCkgfHwge307XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByZWZpeDogbmV4dFByZWZpeCxcbiAgICAgICAgICAgIGxvY2FsZTogbmV4dExvY2FsZSxcbiAgICAgICAgICAgIHB1cmU6IG5leHRQdXJlLFxuICAgICAgICAgICAgcnRsOiBuZXh0UnRsLFxuICAgICAgICAgICAgd2FybmluZzogbmV4dFdhcm5pbmdcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgY2hpbGRDb250ZXh0Q2FjaGUuYWRkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIGNoaWxkQ29udGV4dENhY2hlLmdldCh0aGlzLCB7fSksIHRoaXMuZ2V0Q2hpbGRDb250ZXh0KCkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgbG9jYWxlLCBwdXJlLCB3YXJuaW5nLCBydGwgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHRQcmVmaXg6IHByZWZpeCxcbiAgICAgICAgICAgIG5leHRMb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgIG5leHRQdXJlOiBwdXJlLFxuICAgICAgICAgICAgbmV4dFJ0bDogcnRsLFxuICAgICAgICAgICAgbmV4dFdhcm5pbmc6IHdhcm5pbmdcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgIHRoaXMuc2V0TW9tZW50TG9jYWxlKHRoaXMucHJvcHMubG9jYWxlKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5sb2NhbGUgIT09IG5leHRQcm9wcy5sb2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TW9tZW50TG9jYWxlKG5leHRQcm9wcy5sb2NhbGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICBjaGlsZENvbnRleHRDYWNoZS5hZGQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgY2hpbGRDb250ZXh0Q2FjaGUuZ2V0KHRoaXMsIHt9KSwgdGhpcy5nZXRDaGlsZENvbnRleHQoKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgY2hpbGRDb250ZXh0Q2FjaGUucmVtb3ZlKHRoaXMpO1xuICAgIH1cblxuICAgIHNldE1vbWVudExvY2FsZShsb2NhbGUpIHtcbiAgICAgICAgbGV0IG1vbWVudDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnQgJiYgbG9jYWxlKSB7XG4gICAgICAgICAgICBtb21lbnQubG9jYWxlKGxvY2FsZS5tb21lbnRMb2NhbGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZ1Byb3ZpZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbmZpZy1wcm92aWRlci9pbmRleC5qc3giLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdGlmICh0eXBlb2YgbWVtb1tzZWxlY3Rvcl0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdG1lbW9bc2VsZWN0b3JdID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdH07XG59KShmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldClcbn0pO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcblx0aWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAwLjE4LjJAc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIDEyIDEzIDE0IDE1IDE2IDE3IDE4IDE5IDIwIDIxIDIyIiwiY29uc3QgYmxhY2tMaXN0ID0gWydkZWZhdWx0UHJvcHMnLCAncHJvcFR5cGVzJywgJ2NvbnRleHRUeXBlcycsICdjaGlsZENvbnRleHRUeXBlcycsICdkaXNwbGF5TmFtZSddO1xuXG5leHBvcnQgY29uc3Qgc3RhdGljcyA9IChUYXJnZXQsIENvbXBvbmVudCkgPT4ge1xuICAgIE9iamVjdC5rZXlzKENvbXBvbmVudCkuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgICAgIGlmIChibGFja0xpc3QuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xKSB7XG4gICAgICAgICAgICBUYXJnZXRbcHJvcGVydHldID0gQ29tcG9uZW50W3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGZldGNoRGF0YUJ5UGF0aCA9IChvYmplY3QsIHBhdGgpID0+IHtcbiAgICBpZiAoIW9iamVjdCB8fCAhcGF0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHBhdGggPSBwYXRoLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgZmllbGQgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgbGV0IHZhbCwga2V5O1xuICAgIGlmIChmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAga2V5ID0gZmllbGRbMF07XG4gICAgICAgIC8vIGxpc3RzWzFdLm5hbWVcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKCdbJykgPj0gMCkge1xuICAgICAgICAgICAga2V5ID0ga2V5Lm1hdGNoKC8oLiopXFxbKC4qKVxcXS8pO1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIHZhbCA9IG9iamVjdFtrZXlbMV1dW2tleVsyXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWwgPSBvYmplY3RbZmllbGRbMF1dO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbEluZGV4ID0gMTsgY29sSW5kZXggPCBmaWVsZC5sZW5ndGg7IGNvbEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB2YWxbZmllbGRbY29sSW5kZXhdXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL3V0aWwuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBDb25maWdQcm92aWRlciBmcm9tICcuLi9jb25maWctcHJvdmlkZXInO1xuXG4vKipcbiAqIEljb25cbiAqL1xuY2xhc3MgSWNvbiBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBydGw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5oyH5a6a5pi+56S65ZOq56eN5Zu+5qCHXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog5oyH5a6a5Zu+5qCH5aSn5bCPXG4gICAgICAgICAqL1xuICAgICAgICBzaXplOiBQcm9wVHlwZXMub25lT2YoWyd4eHMnLCAneHMnLCAnc21hbGwnLCAnbWVkaXVtJywgJ2xhcmdlJywgJ3hsJywgJ3h4bCcsICd4eHhsJ10pLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHByZWZpeDogJ25leHQtJyxcbiAgICAgICAgc2l6ZTogJ21lZGl1bSdcbiAgICB9O1xuXG4gICAgc3RhdGljIF90eXBlTWFyayA9ICdpY29uJztcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMqL1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgdHlwZSwgc2l6ZSwgY2xhc3NOYW1lLCBydGwsIC4uLm90aGVyIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBjeCh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fWljb25gXTogdHJ1ZSxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9aWNvbi0ke3R5cGV9YF06ICEhdHlwZSxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9JHtzaXplfWBdOiAhIXNpemUsXG4gICAgICAgICAgICBbY2xhc3NOYW1lXTogISFjbGFzc05hbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJ0bCAmJiBbJ2Fycm93LWxlZnQnLCAnYXJyb3ctcmlnaHQnLCAnYXJyb3ctZG91YmxlLWxlZnQnLCAnYXJyb3ctZG91YmxlLXJpZ2h0JywgJ3N3aXRjaCcsICdzb3J0aW5nJywgJ2Rlc2NlbmRpbmcnLCAnYXNjZW5kaW5nJ10uaW5kZXhPZih0eXBlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIG90aGVyLmRpciA9ICdydGwnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDxpIHsuLi5vdGhlcn0gY2xhc3NOYW1lPXtjbGFzc2VzfSAvPjtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZ1Byb3ZpZGVyLmNvbmZpZyhJY29uKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pY29uL2luZGV4LmpzeCIsImltcG9ydCAnLi9tYWluLnNjc3MnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2ljb24vc3R5bGUuanMiLCJpbXBvcnQgJy4vbWFpbi5zY3NzJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hbmltYXRlL3N0eWxlLmpzIiwiLyoqXG4gKiDojrflj5blr7nosaHnmoTnsbvlnotcbiAqIEBwYXJhbSAgeyp9IG9ialxuICogQHJldHVybiB7U3RyaW5nfVxuICpcbiAqIEBleGFtcGxlXG4gKiB0eXBlT2YoW10pID09PSAnQXJyYXknXG4gKiB0eXBlT2YoKSA9PT0gJ1VuZGVmaW5lZCdcbiAqIHR5cGVPZigxKSA9PT0gJ051bWJlcidcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR5cGVPZiAob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopLnJlcGxhY2UoL1xcW29iamVjdFxcc3xdL2csICcnKTtcbn1cblxuLyoqXG4gKiDliKTmlq3mmK/lkKbmmK/mlbDnu4TmiJbnsbvmlbDnu4Tlr7nosaFcbiAqIEBwYXJhbSAgeyp9ICBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICogQGV4YW1wbGVcbiAqIGlzQXJyYXlMaWtlKFtdKSA9PT0gdHJ1ZVxuICogaXNBcnJheUxpa2UoYXJndW1lbnRzKSA9PT0gdHJ1ZVxuICogaXNBcnJheUxpa2UodGhpcy5wcm9wcy5jaGlsZHJlbikgPT09IHRydWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlMaWtlIChvYmopIHtcbiAgICBjb25zdCBsZW5ndGggPSAhIW9iaiAmJiAnbGVuZ3RoJyBpbiBvYmogJiYgb2JqLmxlbmd0aDtcbiAgICBjb25zdCB0eXBlID0gdHlwZU9mKG9iaik7XG5cbiAgICByZXR1cm4gdHlwZSA9PT0gJ0FycmF5JyB8fCBsZW5ndGggPT09IDAgfHxcbiAgICAgICAgKHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInICYmIGxlbmd0aCA+IDAgJiYgKGxlbmd0aCAtIDEpIGluIG9iaik7XG59XG5cbi8qKlxuICog5Yik5pat5a+56LGh5piv5ZCm5piv5LiA5LiqcHJvbWlzZe+8jOWNs+aYr+WQpuWPr+S7peeUqC50aGVuXG4gKiBAcGFyYW0gIHsqfSAgb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNQcm9taXNlIChvYmopIHtcbiAgICByZXR1cm4gISFvYmogJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiDmmK/lkKbmmK/kuIDkuKrnuq/lh4DnmoTlr7nosaFcbiAqIEBwYXJhbSAgeyp9ICBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAcmVmZXJlbmNlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLXBsYWluLW9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gICAgaWYgKHR5cGVPZihvYmopICE9PSAnT2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgY3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcblxuICAgIGlmICh0eXBlb2YgY3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvdCA9IGN0b3IucHJvdG90eXBlO1xuXG4gICAgaWYgKHR5cGVPZihwcm90KSAhPT0gJ09iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghcHJvdC5oYXNPd25Qcm9wZXJ0eSgnaXNQcm90b3R5cGVPZicpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiDlr7nosaHmtYXmr5TovoNcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqQVxuICogQHBhcmFtICB7T2JqZWN0fSBvYmpCXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gIFtjb21wYXJlXSDmiYvliqjosIPnlKjmlrnms5Xmr5TovoNcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAg5a+56LGh5rWF5q+U6L6D5piv5ZCm55u4562JXG4gKlxuICogQGV4YW1wbGVcbiAqIG9iamVjdC5zaGFsbG93RXF1YWwoe2E6IDEwMH0sIHthOiAxMDB9KTsgLy8gdHJ1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0VxdWFsIChvYmpBLCBvYmpCLCBjb21wYXJlKSB7XG4gICAgaWYgKG9iakEgPT09IG9iakIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8g5YW25Lit5LiA5Liq5LiN5pivb2JqZWN077yM5YiZ5LiN55u4562JXG4gICAgaWYgKCFvYmpBIHx8ICFvYmpCIHx8ICh0eXBlb2Ygb2JqQSArIHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0b2JqZWN0JykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGtleUEgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgICBjb25zdCBrZXlCID0gT2JqZWN0LmtleXMob2JqQik7XG4gICAgY29uc3QgbGVuID0ga2V5QS5sZW5ndGg7XG5cbiAgICAvLyBrZXkg5pWw6YeP5LiN5LiA6Ie05YiZ5LiN55u4562JXG4gICAgaWYgKGxlbiAhPT0ga2V5Qi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGhhc0NhbGxiYWNrID0gdHlwZW9mIGNvbXBhcmUgPT09ICdmdW5jdGlvbic7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleUFbaV07XG5cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmFsQSA9IG9iakFba2V5XTtcbiAgICAgICAgY29uc3QgdmFsQiA9IG9iakJba2V5XTtcblxuICAgICAgICBjb25zdCByZXQgPSBoYXNDYWxsYmFjayA/IGNvbXBhcmUodmFsQSwgdmFsQiwga2V5KSA6IHZvaWQgMDtcblxuICAgICAgICBpZiAocmV0ID09PSBmYWxzZSB8fCByZXQgPT09IHZvaWQgMCAmJiB2YWxBICE9PSB2YWxCKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiDpgY3ljoblr7nosaHmiJbmlbDnu4TvvIzmiJbogIXnsbvmlbDnu4TvvIzkvovlpoJSZWFjdOS4reeahGNoaWxkcmVu5a+56LGh44CBYXJndW1lbnRz562JXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9ICAgb2JqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgZm4obiwgaSkgb3IgZm4odmFsLCBrZXkpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgW2RpcmVjdGlvbiA9IDFdIOaYr+WQpuWAkuW6j+mBjeWOhu+8jOWPquWvueaVsOe7hOacieaViFxuICogQHJldHVybiB7T2JqZWN0fEFycmF5fVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyDpgY3ljobmlbDnu4RcbiAqIG9iamVjdC5lYWNoKFsxMDAsIDIwMCwgMzAwXSwgKG4sIGkpID0+IGNvbnNvbGUubG9nKG4sIGkpKTtcbiAqIC8vIOmBjeWOhmpzb27lr7nosaFcbiAqIG9iamVjdC5lYWNoKHthOiAxMDAsIGI6IDIwMH0sICh2YWx1ZSwga2V5KSA9PiBjb25zb2xlLmxvZyhrZXksIHZhbHVlKSk7XG4gKiAvLyDpgY3ljoZSZWFjdOWtkOiKgueCuVxuICogb2JqZWN0LmVhY2godGhpcy5wcm9wcy5jaGlsZHJlbiwgKGNoaWxkLCBpbmRleCkgPT4gY29uc29sZS5sb2coY2hpbGQpKTtcbiAqIC8vIOmBjeWOhmFyZ3VtZW50c1xuICogb2JqZWN0LmVhY2goYXJndW1lbnRzLCAoYXJnLCBpKSA9PiBjb25zb2xlLmxvZyhhcmcpKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2ggKG9iaiwgY2FsbGJhY2ssIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHJldmVyc2VkID0gZGlyZWN0aW9uID09PSAtMTtcbiAgICBjb25zdCBsZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgIGxldCB2YWx1ZSxcbiAgICAgICAgaSA9IHJldmVyc2VkID8gbGVuZ3RoIC0gMSA6IDA7XG5cbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aCAmJiBpID49IDA7IHJldmVyc2VkID8gaS0tIDogaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqW2ldLCBvYmpbaV0sIGkpO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmpbaV0sIG9ialtpXSwgaSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59XG5cbi8vIEBwcml2YXRlIOWIpOaWrWtleeaYr+WQpuWcqOaVsOe7hOaIluWvueixoeS4rVxuY29uc3QgX2lzSW5PYmogPSAoa2V5LCBvYmosIGlzQXJyYXkpID0+IGlzQXJyYXkgPyAob2JqLmluZGV4T2Yoa2V5KSA+IC0xKSAgOiAoa2V5IGluIG9iaik7XG5cbi8qKlxuICog6L+H5ruk5Ye65YW25a6D5bGe5oCnXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9IGhvbGRQcm9wcyDov4fmu6TnmoTlj4Lnhaflr7nosaHvvIzmnIDnu4jnmoTnu5Pmnpzlj6rkv53nlZnkuI3lnKjlj4Lnhaflr7nosaHkuK3nmoRrZXlcbiAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMgICAgIOiiq+i/h+a7pOeahOWvueixoVxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgb3RoZXJzXG4gKlxuICogQGV4YW1wbGVcbiAqIG9iamVjdC5waWNrT3RoZXJzKEZvb0NvbXBvbmVudC5wcm9wVHlwZXMsIHRoaXMucHJvcHMpO1xuICogb2JqZWN0LnBpY2tPdGhlcnMoWydjbGFzc05hbWUnLCAnb25DaGFuZ2UnXSwgdGhpcy5wcm9wcyk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwaWNrT3RoZXJzIChob2xkUHJvcHMsIHByb3BzKSB7XG4gICAgY29uc3Qgb3RoZXJzID0ge307XG4gICAgY29uc3QgaXNBcnJheSA9IHR5cGVPZihob2xkUHJvcHMpID09PSAnQXJyYXknO1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKCFfaXNJbk9iaihrZXksIGhvbGRQcm9wcywgaXNBcnJheSkpIHtcbiAgICAgICAgICAgIG90aGVyc1trZXldID0gcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdGhlcnM7XG59XG5cbi8qKlxuICog6L+H5ruk5Ye65bimcHJlZml455qE5bGe5oCnXG4gKiBAcGFyYW0gIHtPYmplY3R9IGhvbGRQcm9wcyDov4fmu6TnmoTlj4Lnhaflr7nosaHvvIzmnIDnu4jnmoTnu5Pmnpzlj6rkv53nlZnkuI3lnKjlj4Lnhaflr7nosaHkuK3nmoRrZXlcbiAqIEBwYXJhbSAge3N0cmluZ30gcHJlZml4ICAgIOWMheWQq+eahOWtl+espuS4slxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgb3RoZXJzXG4gKlxuICogQGV4YW1wbGVcbiAqIG9iamVjdC5waWNrQXR0cnNXaXRoKEZvb0NvbXBvbmVudC5wcm9wVHlwZXMsICdkYXRhLScpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGlja0F0dHJzV2l0aCAoaG9sZFByb3BzLCBwcmVmaXgpIHtcbiAgICBjb25zdCBvdGhlcnMgPSB7fTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIGhvbGRQcm9wcykge1xuICAgICAgICBpZiAoa2V5Lm1hdGNoKHByZWZpeCkpIHtcbiAgICAgICAgICAgIG90aGVyc1trZXldID0gaG9sZFByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3RoZXJzO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWwvb2JqZWN0LmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgQ2hpbGRyZW4sIGlzVmFsaWRFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IGZ1bmMsIG9iaiB9IGZyb20gJy4uLy4uL3V0aWwnO1xuXG5jb25zdCB7IGJpbmRDdHggfSA9IGZ1bmM7XG5jb25zdCB7IHBpY2tPdGhlcnMgfSA9IG9iajtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSXRlbSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgX2tleTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgbGV2ZWw6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGdyb3VwSW5kZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICByb290OiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBwYXJlbnQ6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIHBhcmVudE1vZGU6IFByb3BUeXBlcy5vbmVPZihbJ2lubGluZScsICdwb3B1cCddKSxcbiAgICAgICAgdHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnc3VibWVudScsICdpdGVtJ10pLFxuICAgICAgICBjb21wb25lbnQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25LZXlEb3duOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgbmVlZEluZGVudDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHJlcGxhY2VDbGFzc05hbWU6IFByb3BUeXBlcy5ib29sXG4gICAgfVxuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgY29tcG9uZW50OiAnbGknLFxuICAgICAgICBncm91cEluZGVudDogMCxcbiAgICAgICAgcmVwbGFjZUNsYXNzTmFtZTogZmFsc2UsXG4gICAgICAgIG5lZWRJbmRlbnQ6IHRydWVcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIGJpbmRDdHgodGhpcywgWydoYW5kbGVDbGljaycsICdoYW5kbGVLZXlEb3duJ10pO1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLml0ZW1Ob2RlID0gZmluZERPTU5vZGUodGhpcyk7XG5cbiAgICAgICAgY29uc3QgeyBwYXJlbnRNb2RlLCByb290IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAocGFyZW50TW9kZSA9PT0gJ3BvcHVwJykge1xuICAgICAgICAgICAgdGhpcy5tZW51Tm9kZSA9IHRoaXMuaXRlbU5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWVudU5vZGUgPSBmaW5kRE9NTm9kZShyb290KTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJlZml4LCBoZWFkZXIsIGZvb3RlciB9ID0gcm9vdC5wcm9wcztcbiAgICAgICAgICAgIGlmIChoZWFkZXIgfHwgZm9vdGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZW51Tm9kZSA9IHRoaXMubWVudU5vZGUucXVlcnlTZWxlY3RvcihgLiR7cHJlZml4fW1lbnUtY29udGVudGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRGb2N1cygpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5zZXRGb2N1cygpO1xuICAgIH1cblxuICAgIGZvY3VzYWJsZSgpIHtcbiAgICAgICAgY29uc3QgeyByb290LCB0eXBlLCBkaXNhYmxlZCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBmb2N1c2FibGUgfSA9IHJvb3QucHJvcHM7XG4gICAgICAgIHJldHVybiBmb2N1c2FibGUgJiYgKHR5cGUgPT09ICdzdWJtZW51JyB8fCAhZGlzYWJsZWQpO1xuICAgIH1cblxuICAgIGdldEZvY3VzZWQoKSB7XG4gICAgICAgIGNvbnN0IHsgX2tleSwgcm9vdCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBmb2N1c2VkS2V5IH0gPSByb290LnN0YXRlO1xuICAgICAgICByZXR1cm4gZm9jdXNlZEtleSA9PT0gX2tleTtcbiAgICB9XG5cbiAgICBzZXRGb2N1cygpIHtcbiAgICAgICAgY29uc3QgZm9jdXNlZCA9IHRoaXMuZ2V0Rm9jdXNlZCgpO1xuICAgICAgICBpZiAoZm9jdXNlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9jdXNhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1Ob2RlLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1lbnVOb2RlICYmIHRoaXMubWVudU5vZGUuc2Nyb2xsSGVpZ2h0ID4gdGhpcy5tZW51Tm9kZS5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JvbGxCb3R0b20gPSB0aGlzLm1lbnVOb2RlLmNsaWVudEhlaWdodCArIHRoaXMubWVudU5vZGUuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1Cb3R0b20gPSB0aGlzLml0ZW1Ob2RlLm9mZnNldFRvcCArIHRoaXMuaXRlbU5vZGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChpdGVtQm90dG9tID4gc2Nyb2xsQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVudU5vZGUuc2Nyb2xsVG9wID0gaXRlbUJvdHRvbSAtIHRoaXMubWVudU5vZGUuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pdGVtTm9kZS5vZmZzZXRUb3AgPCB0aGlzLm1lbnVOb2RlLnNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbnVOb2RlLnNjcm9sbFRvcCA9IHRoaXMuaXRlbU5vZGUub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZUNsaWNrKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICBjb25zdCB7IF9rZXksIHJvb3QsIGRpc2FibGVkIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJvb3QuaGFuZGxlSXRlbUNsaWNrKF9rZXksIHRoaXMsIGUpO1xuXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2xpY2sgJiYgdGhpcy5wcm9wcy5vbkNsaWNrKGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlS2V5RG93bihlKSB7XG4gICAgICAgIGNvbnN0IHsgX2tleSwgcm9vdCwgdHlwZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKHRoaXMuZm9jdXNhYmxlKCkpIHtcbiAgICAgICAgICAgIHJvb3QuaGFuZGxlSXRlbUtleURvd24oX2tleSwgdHlwZSwgdGhpcywgZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3BzLm9uS2V5RG93biAmJiB0aGlzLnByb3BzLm9uS2V5RG93bihlKTtcbiAgICB9XG5cbiAgICBnZXRUaXRsZShjaGlsZHJlbikge1xuICAgICAgICBsZXQgbGFiZWxTdHJpbmcgPSAnJztcblxuICAgICAgICBjb25zdCBsb29wID0gY2hpbGRyZW4gPT4ge1xuICAgICAgICAgICAgQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkgJiYgIGNoaWxkLnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvb3AoY2hpbGQucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbFN0cmluZyArPSBjaGlsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBsb29wKGNoaWxkcmVuKTtcblxuICAgICAgICByZXR1cm4gbGFiZWxTdHJpbmc7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGxldmVsLCByb290LCByZXBsYWNlQ2xhc3NOYW1lLCBncm91cEluZGVudCwgY29tcG9uZW50LCBkaXNhYmxlZCwgY2xhc3NOYW1lLCBjaGlsZHJlbiwgbmVlZEluZGVudCwgcGFyZW50TW9kZSwgX2tleSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gcGlja090aGVycyhPYmplY3Qua2V5cyhJdGVtLnByb3BUeXBlcyksIHRoaXMucHJvcHMpO1xuXG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBmb2N1c2FibGUsIGlubGluZUluZGVudCwgaXRlbUNsYXNzTmFtZSwgcnRsIH0gPSByb290LnByb3BzO1xuICAgICAgICBjb25zdCBmb2N1c2VkID0gdGhpcy5nZXRGb2N1c2VkKCk7XG5cbiAgICAgICAgY29uc3QgbmV3Q2xhc3NOYW1lID0gcmVwbGFjZUNsYXNzTmFtZSA/IGNsYXNzTmFtZSA6IGN4KHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9bWVudS1pdGVtYF06IHRydWUsXG4gICAgICAgICAgICBbYCR7cHJlZml4fWRpc2FibGVkYF06IGRpc2FibGVkLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1mb2N1c2VkYF06ICFmb2N1c2FibGUgJiYgZm9jdXNlZCxcbiAgICAgICAgICAgIFtpdGVtQ2xhc3NOYW1lXTogISFpdGVtQ2xhc3NOYW1lLFxuICAgICAgICAgICAgW2NsYXNzTmFtZV06ICEhY2xhc3NOYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIG90aGVyc1snYXJpYS1kaXNhYmxlZCddID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVycy50YWJJbmRleCA9IHJvb3QudGFiYmFibGVLZXkgPT09IF9rZXkgPyAnMCcgOiAnLTEnO1xuXG4gICAgICAgIGlmIChwYXJlbnRNb2RlID09PSAnaW5saW5lJyAmJiBsZXZlbCA+IDEgJiYgaW5saW5lSW5kZW50ID4gMCAmJiBuZWVkSW5kZW50KSB7XG4gICAgICAgICAgICBvdGhlcnMuc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgLi4uKG90aGVycy5zdHlsZSB8fCB7fSksXG4gICAgICAgICAgICAgICAgW3J0bCA/ICdwYWRkaW5nUmlnaHQnIDogJ3BhZGRpbmdMZWZ0J106IGAkeyhsZXZlbCAqIGlubGluZUluZGVudCkgLSAoKGdyb3VwSW5kZW50IHx8IDApICogMC40ICogaW5saW5lSW5kZW50KX1weGBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgVGFnTmFtZSA9IGNvbXBvbmVudDtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPFRhZ05hbWUgcm9sZT1cIm1lbnVpdGVtXCJcbiAgICAgICAgICAgICAgICB0aXRsZT17dGhpcy5nZXRUaXRsZShjaGlsZHJlbil9XG4gICAgICAgICAgICAgICAgey4uLm90aGVyc31cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e25ld0NsYXNzTmFtZX1cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfVxuICAgICAgICAgICAgICAgIG9uS2V5RG93bj17dGhpcy5oYW5kbGVLZXlEb3dufT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fW1lbnUtaXRlbS1pbm5lcmB9PntjaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgICAgIDwvVGFnTmFtZT5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWVudS92aWV3L2l0ZW0uanN4IiwiaW1wb3J0IENvbmZpZ1Byb3ZpZGVyIGZyb20gJy4uL2NvbmZpZy1wcm92aWRlcic7XG5pbXBvcnQgT3ZlcmxheSBmcm9tICcuL292ZXJsYXknO1xuaW1wb3J0IEdhdGV3YXkgZnJvbSAnLi9nYXRld2F5JztcbmltcG9ydCBQb3NpdGlvbiBmcm9tICcuL3Bvc2l0aW9uJztcbmltcG9ydCBQb3B1cCBmcm9tICcuL3BvcHVwJztcblxuT3ZlcmxheS5HYXRld2F5ID0gR2F0ZXdheTtcbk92ZXJsYXkuUG9zaXRpb24gPSBQb3NpdGlvbjtcbk92ZXJsYXkuUG9wdXAgPSBDb25maWdQcm92aWRlci5jb25maWcoUG9wdXAsIHtcbiAgICBleHBvcnROYW1lczogWydvdmVybGF5J11cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBDb25maWdQcm92aWRlci5jb25maWcoT3ZlcmxheSwge1xuICAgIGV4cG9ydE5hbWVzOiBbJ2dldENvbnRlbnQnLCAnZ2V0Q29udGVudE5vZGUnXVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvb3ZlcmxheS9pbmRleC5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFJvd0NvbXBvbmVudCBmcm9tICcuL3Jvdyc7XG5pbXBvcnQgQ2VsbENvbXBvbmVudCBmcm9tICcuL2NlbGwnO1xuXG5jb25zdCBub29wID0gKCkgPT4geyB9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCb2R5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBsb2FkaW5nOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgZW1wdHlDb250ZW50OiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHB1cmU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBjb21wb25lbnRzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBnZXRDZWxsUHJvcHM6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBjZWxsUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgcHJpbWFyeUtleTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgZ2V0Um93UHJvcHM6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICByb3dSZWY6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBkYXRhU291cmNlOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNvbXBvbmVudDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY29sR3JvdXA6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIGNvbHVtbnM6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgb25Sb3dDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uUm93TW91c2VFbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uUm93TW91c2VMZWF2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGxvY2FsZTogUHJvcFR5cGVzLm9iamVjdFxuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgICAgICBjb21wb25lbnRzOiB7fSxcbiAgICAgICAgZ2V0Q2VsbFByb3BzOiBub29wLFxuICAgICAgICBjZWxsUmVmOiBub29wLFxuICAgICAgICBwcmltYXJ5S2V5OiAnaWQnLFxuICAgICAgICBnZXRSb3dQcm9wczogbm9vcCxcbiAgICAgICAgcm93UmVmOiBub29wLFxuICAgICAgICBkYXRhU291cmNlOiBbXSxcbiAgICAgICAgY29tcG9uZW50OiAndGJvZHknLFxuICAgICAgICBjb2x1bW5zOiBbXVxuICAgIH1cblxuICAgIGdldFJvd1JlZiA9IChpLCByb3cpID0+IHtcbiAgICAgICAgdGhpcy5wcm9wcy5yb3dSZWYoaSwgcm93KTtcbiAgICB9XG5cbiAgICBvblJvd0NsaWNrID0gKHJlY29yZCwgaW5kZXgsIGUpID0+IHtcbiAgICAgICAgdGhpcy5wcm9wcy5vblJvd0NsaWNrKHJlY29yZCwgaW5kZXgsIGUpO1xuICAgIH1cblxuICAgIG9uUm93TW91c2VFbnRlciA9IChyZWNvcmQsIGluZGV4LCBlKSA9PiB7XG4gICAgICAgIHRoaXMucHJvcHMub25Sb3dNb3VzZUVudGVyKHJlY29yZCwgaW5kZXgsIGUpO1xuICAgIH1cblxuICAgIG9uUm93TW91c2VMZWF2ZSA9IChyZWNvcmQsIGluZGV4LCBlKSA9PiB7XG4gICAgICAgIHRoaXMucHJvcHMub25Sb3dNb3VzZUxlYXZlKHJlY29yZCwgaW5kZXgsIGUpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLyplc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgY2xhc3NOYW1lLCBjaGlsZHJlbiwgY29tcG9uZW50OiBUYWcsIGNvbEdyb3VwLCBsb2FkaW5nLCBlbXB0eUNvbnRlbnQsIGNvbXBvbmVudHMsIGdldENlbGxQcm9wcyxcbiAgICAgICAgICAgIHByaW1hcnlLZXksIGdldFJvd1Byb3BzLCBkYXRhU291cmNlLCBjZWxsUmVmLCBjb2x1bW5zLCByb3dSZWYsIG9uUm93Q2xpY2ssIG9uUm93TW91c2VFbnRlciwgb25Sb3dNb3VzZUxlYXZlLCBsb2NhbGUsIHB1cmUsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBjb25zdCB7IFJvdyA9IFJvd0NvbXBvbmVudCwgQ2VsbCA9IENlbGxDb21wb25lbnQgfSA9IGNvbXBvbmVudHM7XG4gICAgICAgIGNvbnN0IGVtcHR5ID0gbG9hZGluZyA/IDxzcGFuPiZuYnNwOzwvc3Bhbj4gOiBlbXB0eUNvbnRlbnQgfHwgbG9jYWxlLmVtcHR5O1xuICAgICAgICBsZXQgcm93cyA9ICg8dHI+XG4gICAgICAgICAgICA8dGQgY29sU3Bhbj17Y29sdW1ucy5sZW5ndGh9PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtZW1wdHlgfT57ZW1wdHl9PC9kaXY+XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICA8L3RyPik7XG4gICAgICAgIGlmIChUYWcgPT09ICdkaXYnKSB7XG4gICAgICAgICAgICByb3dzID0gKDx0YWJsZSByb2xlPVwidGFibGVcIj48dGJvZHk+e3Jvd3N9PC90Ym9keT48L3RhYmxlPik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFTb3VyY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICByb3dzID0gZGF0YVNvdXJjZS5tYXAoKHJlY29yZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3dQcm9wcyA9IGdldFJvd1Byb3BzKHJlY29yZCwgaW5kZXgpIHx8IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvd0NsYXNzID0gcm93UHJvcHMuY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgICAgICBmaXJzdDogaW5kZXggPT09IDAsXG4gICAgICAgICAgICAgICAgICAgIGxhc3Q6IGluZGV4ID09PSBkYXRhU291cmNlLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgICAgIFtyb3dDbGFzc106IHJvd0NsYXNzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwYW5kZWQgPSByZWNvcmQuX19leHBhbmRlZCA/ICdleHBhbmRlZCcgOiAnJztcbiAgICAgICAgICAgICAgICByZXR1cm4gKDxSb3cga2V5PXtgJHtyZWNvcmRbcHJpbWFyeUtleV0gfHwgaW5kZXh9JHtleHBhbmRlZH1gfVxuICAgICAgICAgICAgICAgICAgICB7Li4ucm93UHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIHJlZj17dGhpcy5nZXRSb3dSZWYuYmluZCh0aGlzLCBpbmRleCl9XG4gICAgICAgICAgICAgICAgICAgIGNvbEdyb3VwPXtjb2xHcm91cH1cbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucz17Y29sdW1uc31cbiAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleT17cHJpbWFyeUtleX1cbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkPXtyZWNvcmR9XG4gICAgICAgICAgICAgICAgICAgIHJvd0luZGV4PXtpbmRleH1cbiAgICAgICAgICAgICAgICAgICAgcHJlZml4PXtwcmVmaXh9XG4gICAgICAgICAgICAgICAgICAgIHB1cmU9e3B1cmV9XG4gICAgICAgICAgICAgICAgICAgIGNlbGxSZWY9e2NlbGxSZWZ9XG4gICAgICAgICAgICAgICAgICAgIGdldENlbGxQcm9wcz17Z2V0Q2VsbFByb3BzfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgICAgICAgICAgICAgICAgQ2VsbD17Q2VsbH1cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5vblJvd0NsaWNrfVxuICAgICAgICAgICAgICAgICAgICBsb2NhbGU9e2xvY2FsZX1cbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyPXt0aGlzLm9uUm93TW91c2VFbnRlcn1cbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXt0aGlzLm9uUm93TW91c2VMZWF2ZX1cbiAgICAgICAgICAgICAgICAvPik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDxUYWcgY2xhc3NOYW1lPXtjbGFzc05hbWV9IHsuLi5vdGhlcnN9PlxuICAgICAgICAgICAge3Jvd3N9XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvVGFnPik7XG4gICAgfVxufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvYmFzZS9ib2R5LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmaW5kRE9NTm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBvYmosIGRvbSB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgZmV0Y2hEYXRhQnlQYXRoIH0gZnJvbSAnLi4vdXRpbCc7XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvdyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBwdXJlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgcHJpbWFyeUtleTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjb2x1bW5zOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIHJlY29yZDogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgQ2VsbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIHJvd0luZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBnZXRDZWxsUHJvcHM6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25Nb3VzZUVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gICAgICAgIGNlbGxSZWY6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBjb2xHcm91cDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgbG9jYWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIH1cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHByZWZpeDogJ25leHQtJyxcbiAgICAgICAgcHJpbWFyeUtleTogJ2lkJyxcbiAgICAgICAgY29sdW1uczogW10sXG4gICAgICAgIHJlY29yZDoge30sXG4gICAgICAgIGdldENlbGxQcm9wczogbm9vcCxcbiAgICAgICAgb25DbGljazogbm9vcCxcbiAgICAgICAgb25Nb3VzZUVudGVyOiBub29wLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IG5vb3AsXG4gICAgICAgIGNlbGxSZWY6IG5vb3AsXG4gICAgICAgIGNvbEdyb3VwOiB7fVxuICAgIH1cblxuICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIG5vdFJlbmRlckNlbGxJbmRleDogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBsb2NrVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsICdyaWdodCddKVxuICAgIH1cblxuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wcy5wdXJlKSB7XG4gICAgICAgICAgICBjb25zdCBpc0VxdWFsID0gb2JqLnNoYWxsb3dFcXVhbCh0aGlzLnByb3BzLCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuICFpc0VxdWFsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgb25DbGljayA9IChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVjb3JkLCByb3dJbmRleCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNsaWNrKHJlY29yZCwgcm93SW5kZXgsIGUpO1xuICAgIH1cblxuICAgIG9uTW91c2VFbnRlciA9IChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVjb3JkLCByb3dJbmRleCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy5vblJvd0hvdmVyKHJlY29yZCwgcm93SW5kZXgsIHRydWUsIGUpO1xuICAgIH1cblxuICAgIG9uTW91c2VMZWF2ZSA9IChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVjb3JkLCByb3dJbmRleCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy5vblJvd0hvdmVyKHJlY29yZCwgcm93SW5kZXgsIGZhbHNlLCBlKTtcbiAgICB9XG5cbiAgICBvblJvd0hvdmVyKHJlY29yZCwgaW5kZXgsIGlzRW50ZXIsIGUpIHtcbiAgICAgICAgY29uc3QgeyBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGN1cnJlbnRSb3cgPSBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgICAgaWYgKGlzRW50ZXIpIHtcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcihyZWNvcmQsIGluZGV4LCBlKTtcbiAgICAgICAgICAgIGN1cnJlbnRSb3cgJiYgZG9tLmFkZENsYXNzKGN1cnJlbnRSb3csICdob3ZlcmVkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvbk1vdXNlTGVhdmUocmVjb3JkLCBpbmRleCwgZSk7XG4gICAgICAgICAgICBjdXJyZW50Um93ICYmIGRvbS5yZW1vdmVDbGFzcyhjdXJyZW50Um93LCAnaG92ZXJlZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyQ2VsbHMocmVjb3JkKSB7XG4gICAgICAgIGNvbnN0IHsgQ2VsbCwgY29sdW1ucywgZ2V0Q2VsbFByb3BzLCBjZWxsUmVmLCBwcmVmaXgsIHJvd0luZGV4LCBwcmltYXJ5S2V5LCBwdXJlLCBsb2NhbGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgbG9ja1R5cGUgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKChjaGlsZCwgY29sSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YUluZGV4LCBhbGlnbiwgd2lkdGgsIC4uLm90aGVycyB9ID0gY2hpbGQ7XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmV0Y2hEYXRhQnlQYXRoKHJlY29yZCwgZGF0YUluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gZ2V0Q2VsbFByb3BzKHJvd0luZGV4LCBjb2xJbmRleCwgZGF0YUluZGV4LCByZWNvcmQpIHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0Lm5vdFJlbmRlckNlbGxJbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoQ2VsbEluZGV4ID0gdGhpcy5jb250ZXh0Lm5vdFJlbmRlckNlbGxJbmRleC5tYXAoY2VsbEluZGV4ID0+IGNlbGxJbmRleC50b1N0cmluZygpKS5pbmRleE9mKFtyb3dJbmRleCwgY29sSW5kZXhdLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaENlbGxJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5ub3RSZW5kZXJDZWxsSW5kZXguc3BsaWNlKG1hdGNoQ2VsbEluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF0dHJzLmNvbFNwYW4gJiYgYXR0cnMuY29sU3BhbiA+IDEgfHwgYXR0cnMucm93U3BhbiAmJiBhdHRycy5yb3dTcGFuID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldE5vdFJlbmRlckNlbGxJbmRleChjb2xJbmRleCwgcm93SW5kZXgsIGF0dHJzLmNvbFNwYW4gfHwgMSwgYXR0cnMucm93U3BhbiB8fCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICAgICAgZmlyc3Q6IGxvY2tUeXBlICE9PSAncmlnaHQnICYmIGNvbEluZGV4ID09PSAwLFxuICAgICAgICAgICAgICAgIGxhc3Q6IGxvY2tUeXBlICE9PSAnbGVmdCcgJiYgKGNvbEluZGV4ID09PSBjb2x1bW5zLmxlbmd0aCAtIDEgfHwgY29sSW5kZXggKyBhdHRycy5jb2xTcGFuID09PSBjb2x1bW5zLmxlbmd0aCksIC8vIOiAg+iZkeWQiOW5tuWNleWFg+agvOeahOaDheWGtVxuICAgICAgICAgICAgICAgIFtjaGlsZC5jbGFzc05hbWVdOiBjaGlsZC5jbGFzc05hbWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gKDxDZWxsIGtleT17Y29sSW5kZXh9XG4gICAgICAgICAgICAgICAgey4uLm90aGVyc31cbiAgICAgICAgICAgICAgICB7Li4uYXR0cnN9XG4gICAgICAgICAgICAgICAgcmVmPXsoY2VsbCkgPT4gY2VsbFJlZihyb3dJbmRleCwgY29sSW5kZXgsIGNlbGwpfVxuICAgICAgICAgICAgICAgIHByZWZpeD17cHJlZml4fVxuICAgICAgICAgICAgICAgIHB1cmU9e3B1cmV9XG4gICAgICAgICAgICAgICAgcHJpbWFyeUtleT17cHJpbWFyeUtleX1cbiAgICAgICAgICAgICAgICByZWNvcmQ9e3JlY29yZH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgICAgICAgY29sSW5kZXg9e2NvbEluZGV4fVxuICAgICAgICAgICAgICAgIHJvd0luZGV4PXtyb3dJbmRleH1cbiAgICAgICAgICAgICAgICBhbGlnbj17YWxpZ259XG4gICAgICAgICAgICAgICAgbG9jYWxlPXtsb2NhbGV9XG4gICAgICAgICAgICAgICAgd2lkdGg9e3dpZHRofVxuICAgICAgICAgICAgLz4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfZ2V0Tm90UmVuZGVyQ2VsbEluZGV4KGNvbEluZGV4LCByb3dJbmRleCwgY29sU3Bhbiwgcm93U3Bhbikge1xuICAgICAgICBjb25zdCBtYXhDb2xJbmRleCA9IGNvbFNwYW47XG4gICAgICAgIGNvbnN0IG1heFJvd0luZGV4ID0gcm93U3BhbjtcbiAgICAgICAgY29uc3Qgbm90UmVuZGVyQ2VsbEluZGV4ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4Q29sSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXhSb3dJbmRleDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbm90UmVuZGVyQ2VsbEluZGV4LnB1c2goW3Jvd0luZGV4ICsgaiwgY29sSW5kZXggKyBpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgW10ucHVzaC5hcHBseSh0aGlzLmNvbnRleHQubm90UmVuZGVyQ2VsbEluZGV4LCBub3RSZW5kZXJDZWxsSW5kZXgpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMqL1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgY2xhc3NOYW1lLCBvbkNsaWNrLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSwgY29sdW1ucywgQ2VsbCwgZ2V0Q2VsbFByb3BzLCByb3dJbmRleCwgcmVjb3JkLCBjaGlsZHJlbiwgcHJpbWFyeUtleSwgY2VsbFJlZiwgY29sR3JvdXAsIHB1cmUsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgY2xzID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fXRhYmxlLXJvd2BdOiB0cnVlLFxuICAgICAgICAgICAgW2NsYXNzTmFtZV06IGNsYXNzTmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICg8dHIgY2xhc3NOYW1lPXtjbHN9IHJvbGU9XCJyb3dcIiB7Li4ub3RoZXJzfVxuICAgICAgICAgICAgb25DbGljaz17dGhpcy5vbkNsaWNrfSBvbk1vdXNlRW50ZXI9e3RoaXMub25Nb3VzZUVudGVyfSBvbk1vdXNlTGVhdmU9e3RoaXMub25Nb3VzZUxlYXZlfT5cbiAgICAgICAgICAgIHt0aGlzLnJlbmRlckNlbGxzKHJlY29yZCl9XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvdHI+KTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvYmFzZS9yb3cuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IG9iaiB9IGZyb20gJy4uLy4uL3V0aWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDZWxsIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHB1cmU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBwcmltYXJ5S2V5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHJlY29yZDogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgdmFsdWU6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIGNvbEluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICByb3dJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgdGl0bGU6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIHdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gICAgICAgIGNvbnRleHQ6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIGNlbGw6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5lbGVtZW50LCBQcm9wVHlwZXMubm9kZSwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICAgICAgYWxpZ246IFByb3BUeXBlcy5vbmVPZihbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J10pLFxuICAgICAgICBjb21wb25lbnQ6IFByb3BUeXBlcy5vbmVPZihbJ3RkJywgJ3RoJywgJ2RpdiddKSxcbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gICAgICAgIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBpbm5lclN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBmaWx0ZXJNb2RlOiBQcm9wVHlwZXMub25lT2YoWydzaW5nbGUnLCAnbXVsdGlwbGUnXSksXG4gICAgICAgIGZpbHRlcnM6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgc29ydGFibGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBsb2NrOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICB0eXBlOiBQcm9wVHlwZXMub25lT2YoWydoZWFkZXInLCAnYm9keSddKSxcbiAgICAgICAgcmVzaXphYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgX19ub3JtYWxpemVkOiBQcm9wVHlwZXMuYm9vbFxuICAgIH1cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGNvbXBvbmVudDogJ3RkJyxcbiAgICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAgICBjZWxsOiAodmFsdWUpID0+IHZhbHVlLFxuICAgICAgICBwcmVmaXg6ICduZXh0LSdcbiAgICB9XG5cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcHMucHVyZSkge1xuICAgICAgICAgICAgY29uc3QgaXNFcXVhbCA9IG9iai5zaGFsbG93RXF1YWwodGhpcy5wcm9wcywgbmV4dFByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiAhaXNFcXVhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICAgIGNvbnN0IHtwcmVmaXgsIGNsYXNzTmFtZSwgY2VsbCwgdmFsdWUsIHJlc2l6YWJsZSwgY29sSW5kZXgsIHJvd0luZGV4LCByZWNvcmQsIGNvbnRleHQsIGFsaWduLCBzdHlsZSA9IHt9LCBjb21wb25lbnQ6IFRhZyxcbiAgICAgICAgICAgIGNoaWxkcmVuLCB0aXRsZSwgd2lkdGgsIGlubmVyU3R5bGUsIHByaW1hcnlLZXksIF9fbm9ybWFsaXplZCwgZmlsdGVyTW9kZSwgZmlsdGVycywgc29ydGFibGUsIGxvY2ssIHB1cmUsIC4uLm90aGVyc30gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB0YWdTdHlsZSA9IHsuLi5zdHlsZX07XG4gICAgICAgIGNvbnN0IGNlbGxQcm9wcyA9IHt2YWx1ZSwgaW5kZXg6IHJvd0luZGV4LCByZWNvcmQsIGNvbnRleHR9O1xuICAgICAgICBsZXQgY29udGVudCA9IGNlbGw7XG4gICAgICAgIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChjb250ZW50KSkge1xuICAgICAgICAgICAgY29udGVudCA9IFJlYWN0LmNsb25lRWxlbWVudChjb250ZW50LCBjZWxsUHJvcHMpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudCh2YWx1ZSwgcm93SW5kZXgsIHJlY29yZCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsaWduKSB7XG4gICAgICAgICAgICB0YWdTdHlsZS50ZXh0QWxpZ24gPSBhbGlnbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbHMgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9dGFibGUtY2VsbGBdOiB0cnVlLFxuICAgICAgICAgICAgW2NsYXNzTmFtZV06IGNsYXNzTmFtZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gKDxUYWcgey4uLm90aGVyc30gY2xhc3NOYW1lPXtjbHN9IHN0eWxlPXt0YWdTdHlsZX0gcm9sZT1cImdyaWRjZWxsXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLWNlbGwtd3JhcHBlcmB9IHN0eWxlPXtpbm5lclN0eWxlfT5cbiAgICAgICAgICAgICAgICB7Y29udGVudH1cbiAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9UYWc+KTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvYmFzZS9jZWxsLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmaW5kRE9NTm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEhlYWRlckNvbXBvbmVudCBmcm9tICcuLi9iYXNlL2hlYWRlcic7XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3ByZWZlci1zdGF0ZWxlc3MtZnVuY3Rpb24gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpeGVkSGVhZGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNvbEdyb3VwOiBQcm9wVHlwZXMuYW55XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgZ2V0Tm9kZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGxvY2tUeXBlOiBQcm9wVHlwZXMub25lT2YoWydsZWZ0JywgJ3JpZ2h0J10pXG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5nZXROb2RlKCdoZWFkZXInLCBmaW5kRE9NTm9kZSh0aGlzKSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgY2xhc3NOYW1lLCBjb2xHcm91cCwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1oZWFkZXItaW5uZXJgfT5cbiAgICAgICAgICAgICAgICA8dGFibGU+XG4gICAgICAgICAgICAgICAgICAgIHtjb2xHcm91cH1cbiAgICAgICAgICAgICAgICAgICAgPEhlYWRlckNvbXBvbmVudCB7Li4ub3RoZXJzfSBwcmVmaXg9e3ByZWZpeH0vPlxuICAgICAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+KTtcbiAgICB9XG59XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9maXhlZC9oZWFkZXIuanN4IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX3Byb3AtdHlwZXNAMTUuNi4yQHByb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwiaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaW5kTm9kZSh0YXJnZXQsIHBhcmFtKSB7XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXQpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldChwYXJhbSk7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZpbmRET01Ob2RlKHRhcmdldCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL292ZXJsYXkvdXRpbHMvZmluZC1ub2RlLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgSWNvbiBmcm9tICcuLi8uLi9pY29uJztcbmltcG9ydCB7IGZ1bmMsIG9iaiwgS0VZQ09ERSB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IEl0ZW0gZnJvbSAnLi9pdGVtJztcblxuY29uc3QgeyBiaW5kQ3R4IH0gPSBmdW5jO1xuY29uc3QgeyBwaWNrT3RoZXJzIH0gPSBvYmo7XG5cbi8qKlxuICogTWVudS5JdGVtXG4gKiBAb3JkZXIgMFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWxlY3RhYmxlSXRlbSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIG1lbnVDaGlsZFR5cGUgPSAnaXRlbSc7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBfa2V5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICByb290OiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBzZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIG9uU2VsZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgaW5saW5lSW5kZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm56aB55SoXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDluK7liqnmlofmnKxcbiAgICAgICAgICovXG4gICAgICAgIGhlbHBlcjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoj5zljZXpobnmoIfnrb7lhoXlrrlcbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBvbktleURvd246IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgbmVlZEluZGVudDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGhhc1NlbGVjdGVkSWNvbjogUHJvcFR5cGVzLmJvb2xcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBuZWVkSW5kZW50OiB0cnVlXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICBiaW5kQ3R4KHRoaXMsIFsnaGFuZGxlS2V5RG93bicsICdoYW5kbGVDbGljayddKTtcbiAgICB9XG5cbiAgICBnZXRTZWxlY3RlZCgpIHtcbiAgICAgICAgY29uc3QgeyBfa2V5LCByb290LCBzZWxlY3RlZCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBzZWxlY3RNb2RlIH0gPSByb290LnByb3BzO1xuICAgICAgICBjb25zdCB7IHNlbGVjdGVkS2V5cyB9ID0gcm9vdC5zdGF0ZTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkIHx8ICghIXNlbGVjdE1vZGUgJiYgc2VsZWN0ZWRLZXlzLmluZGV4T2YoX2tleSkgPiAtMSk7XG4gICAgfVxuXG4gICAgaGFuZGxlU2VsZWN0KGUpIHtcbiAgICAgICAgY29uc3QgeyBfa2V5LCByb290LCBvblNlbGVjdCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKG9uU2VsZWN0KSB7XG4gICAgICAgICAgICBvblNlbGVjdCghdGhpcy5nZXRTZWxlY3RlZCgpLCB0aGlzLCBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvb3QuaGFuZGxlU2VsZWN0KF9rZXksICF0aGlzLmdldFNlbGVjdGVkKCksIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlS2V5RG93bihlKSB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IEtFWUNPREUuU1BBQ0UpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0KGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vbktleURvd24gJiYgdGhpcy5wcm9wcy5vbktleURvd24oZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlQ2xpY2soZSkge1xuICAgICAgICB0aGlzLmhhbmRsZVNlbGVjdChlKTtcblxuICAgICAgICB0aGlzLnByb3BzLm9uQ2xpY2sgJiYgdGhpcy5wcm9wcy5vbkNsaWNrKGUpO1xuICAgIH1cblxuICAgIHJlbmRlclNlbGVjdGVkSWNvbihzZWxlY3RlZCkge1xuICAgICAgICBjb25zdCB7IHJvb3QsIGlubGluZUluZGVudCwgbmVlZEluZGVudCwgaGFzU2VsZWN0ZWRJY29uIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgaGFzU2VsZWN0ZWRJY29uOiByb290U2VsZWN0ZWRJY29uIH0gPSByb290LnByb3BzO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoJ2hhc1NlbGVjdGVkSWNvbicgaW4gdGhpcy5wcm9wcyA/IGhhc1NlbGVjdGVkSWNvbiA6IHJvb3RTZWxlY3RlZEljb24pICYmIHNlbGVjdGVkID9cbiAgICAgICAgICAgICAgICA8SWNvbiBzdHlsZT17bmVlZEluZGVudCAmJiBpbmxpbmVJbmRlbnQgPiAwID8geyBsZWZ0OiBgJHtpbmxpbmVJbmRlbnR9cHhgIH0gOiBudWxsfSBjbGFzc05hbWU9e2Ake3ByZWZpeH1tZW51LWljb24tc2VsZWN0ZWRgfSB0eXBlPVwic2VsZWN0XCIgLz4gOlxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgX2tleSwgcm9vdCwgY2xhc3NOYW1lLCBkaXNhYmxlZCwgaGVscGVyLCBjaGlsZHJlbiwgbmVlZEluZGVudCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBwcmVmaXggfSA9IHJvb3QucHJvcHM7XG4gICAgICAgIGNvbnN0IG90aGVycyA9IHBpY2tPdGhlcnMoT2JqZWN0LmtleXMoU2VsZWN0YWJsZUl0ZW0ucHJvcFR5cGVzKSwgdGhpcy5wcm9wcyk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkID0gdGhpcy5nZXRTZWxlY3RlZCgpO1xuXG4gICAgICAgIGNvbnN0IG5ld1Byb3BzID0ge1xuICAgICAgICAgICAgX2tleSxcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgICAgIHR5cGU6ICdpdGVtJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY3goe1xuICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9c2VsZWN0ZWRgXTogc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgW2NsYXNzTmFtZV06ICEhY2xhc3NOYW1lXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9uS2V5RG93bjogdGhpcy5oYW5kbGVLZXlEb3duLFxuICAgICAgICAgICAgb25DbGljazogIWRpc2FibGVkID8gdGhpcy5oYW5kbGVDbGljayA6IHRoaXMucHJvcHMub25DbGljayxcbiAgICAgICAgICAgIG5lZWRJbmRlbnQsXG4gICAgICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IHNlbGVjdGVkLFxuICAgICAgICAgICAgLi4ub3RoZXJzXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxJdGVtIHsuLi5uZXdQcm9wc30+XG4gICAgICAgICAgICAgICAge3RoaXMucmVuZGVyU2VsZWN0ZWRJY29uKHNlbGVjdGVkKX1cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Ake3ByZWZpeH1tZW51LWl0ZW0tdGV4dGB9PntjaGlsZHJlbn08L3NwYW4+XG4gICAgICAgICAgICAgICAge2hlbHBlciA/IDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9bWVudS1pdGVtLWhlbHBlcmB9PntoZWxwZXJ9PC9kaXY+IDogbnVsbH1cbiAgICAgICAgICAgIDwvSXRlbT5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWVudS92aWV3L3NlbGVjdGFibGUtaXRlbS5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuLyoqXG4gKiBUYWJsZS5Db2x1bW5cbiAqIEBvcmRlciAwXG4gKiovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2x1bW4gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaMh+WumuWIl+WvueW6lOeahOWtl+aute+8jOaUr+aMgWBhLmJg5b2i5byP55qE5b+r6YCf5Y+W5YC8XG4gICAgICAgICAqL1xuICAgICAgICBkYXRhSW5kZXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDooYzmuLLmn5PnmoTpgLvovpFcbiAgICAgICAgICogdmFsdWUsIHJvd0luZGV4LCByZWNvcmQsIGNvbnRleHTlm5vkuKrlsZ7mgKflj6rlj6/or7vkuI3lj6/ooqvmm7TmlLlcbiAgICAgICAgICogRnVuY3Rpb24odmFsdWUsIGluZGV4LCByZWNvcmQpID0+IEVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGNlbGw6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5lbGVtZW50LCBQcm9wVHlwZXMubm9kZSwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOihqOWktOaYvuekuueahOWGheWuuVxuICAgICAgICAgKiB2YWx1ZSwgcm93SW5kZXgsIHJlY29yZCwgY29udGV4dOWbm+S4quWxnuaAp+WPquWPr+ivu+S4jeWPr+iiq+abtOaUuVxuICAgICAgICAgKi9cbiAgICAgICAgdGl0bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5lbGVtZW50LCBQcm9wVHlwZXMubm9kZSwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuaUr+aMgeaOkuW6j1xuICAgICAgICAgKi9cbiAgICAgICAgc29ydGFibGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5YiX5a6977yM5rOo5oSP5Zyo6ZSB5YiX55qE5oOF5Ya15LiL5LiA5a6a6ZyA6KaB6YWN572u5a695bqmXG4gICAgICAgICAqL1xuICAgICAgICB3aWR0aDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5Y2V5YWD5qC855qE5a+56b2Q5pa55byPXG4gICAgICAgICAqL1xuICAgICAgICBhbGlnbjogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnlJ/miJDmoIfpopjov4fmu6TnmoToj5zljZUsIOagvOW8j+S4umBbe2xhYmVsOid4eHgnLCB2YWx1ZToneHh4J31dYFxuICAgICAgICAgKi9cbiAgICAgICAgZmlsdGVyczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgICAgICAgIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAgICAgdmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ub2RlLCBQcm9wVHlwZXMuc3RyaW5nXSlcbiAgICAgICAgfSkpLFxuICAgICAgICAvKipcbiAgICAgICAgICog6L+H5ruk55qE5qih5byP5piv5Y2V6YCJ6L+Y5piv5aSa6YCJXG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXJNb2RlOiBQcm9wVHlwZXMub25lT2YoWydzaW5nbGUnLCAnbXVsdGlwbGUnXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbmlK/mjIHplIHliJcs5Y+v6YCJ5YC85Li6YGxlZnRgLGByaWdodGAsIGB0cnVlYFxuICAgICAgICAgKi9cbiAgICAgICAgbG9jazogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuaUr+aMgeWIl+Wuveiwg+aVtCwg5b2T6K+l5YC86K6+5Li6dHJ1Ze+8jHRhYmxl55qE5biD5bGA5pa55byP5Lya5L+u5pS55Li6Zml4ZWQuXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemFibGU6IFByb3BUeXBlcy5ib29sXG4gICAgfVxuXG4gICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgcGFyZW50OiBQcm9wVHlwZXMuYW55XG4gICAgfVxuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgY2VsbDogKHZhbHVlKSA9PiB2YWx1ZSxcbiAgICAgICAgZmlsdGVyTW9kZTogJ211bHRpcGxlJyxcbiAgICAgICAgcmVzaXphYmxlOiBmYWxzZVxuICAgIH1cblxuICAgIHN0YXRpYyBfdHlwZU1hcmsgPSAnY29sdW1uJztcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2NvbHVtbi5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcHJlZmVyLXN0YXRlbGVzcy1mdW5jdGlvbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRml4ZWRXcmFwcGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjb2xHcm91cDogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgd3JhcHBlckNvbnRlbnQ6IFByb3BUeXBlcy5hbnlcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuLCB3cmFwcGVyQ29udGVudCwgcHJlZml4IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtaW5uZXJgfT5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgIHt3cmFwcGVyQ29udGVudH1cbiAgICAgICAgPC9kaXY+KTtcbiAgICB9XG59XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9maXhlZC93cmFwcGVyLmpzeCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAY2hhcnNldCBcXFwiVVRGLThcXFwiO1xcbi8qKlxcbiAqIOWwuuWvuCDln7rnoYDlsLrlr7hcXG4gKiDlkb3lkI3og73lnKjor63kuYnnmoTliY3mj5DkuIvnroDljZXlsLHlsL3ph4/nroDljZUsIOi/memHjOWPr+S7peaYryBzaXplLTJ4LCBzcGFjZS0yeCwgc2l6ZS1iYXNlIC4uLlxcbiAqIOS4jei/h+WPr+S7peWcqOivreS5ieeahOWJjeaPkOS4i+WBmueahOabtOeyvueugOS4gOS6mywg5LqO5piv55So5LqGczIsIHMx562JXFxuICog5Y+v55So5Y+Y6YePOiBgJHMxIC0gJHM4YFxcbiAqIEBleGFtcGxlIHNjc3MgLSDkvb/nlKhcXG4gKiAgIC5lbGVtZW50IHtcXG4gKiAgICAgcGFkZGluZzogJHMxICFkZWZhdWx0O1xcbiAqICAgfVxcbiAqXFxuICogQGV4YW1wbGUgY3NzIC0gQ1NTIOi+k+WHulxcbiAqICAgLmVsZW1lbnQge1xcbiAqICAgICBwYWRkaW5nOiA0cHggIWRlZmF1bHQ7XFxuICogICB9XFxuICovXFxuLm5leHQtaWNvbltkaXI9XFxcInJ0bFxcXCJdOjpiZWZvcmUge1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZVkoMTgwZGVnKTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGVZKDE4MGRlZyk7IH1cXG5cXG5AZm9udC1mYWNlIHtcXG4gIGZvbnQtZmFtaWx5OiBOZXh0SWNvbjtcXG4gIHNyYzogdXJsKFxcXCIvL2F0LmFsaWNkbi5jb20vdC9mb250XzUxNTc3MV9lbWNuczUwNTR4M3doZnIuZW90XFxcIik7XFxuICBzcmM6IHVybChcXFwiLy9hdC5hbGljZG4uY29tL3QvZm9udF81MTU3NzFfZW1jbnM1MDU0eDN3aGZyLmVvdD8jaWVmaXhcXFwiKSBmb3JtYXQoXFxcImVtYmVkZGVkLW9wZW50eXBlXFxcIiksIHVybChcXFwiLy9hdC5hbGljZG4uY29tL3QvZm9udF81MTU3NzFfZW1jbnM1MDU0eDN3aGZyLndvZmZcXFwiKSBmb3JtYXQoXFxcIndvZmZcXFwiKSwgdXJsKFxcXCIvL2F0LmFsaWNkbi5jb20vdC9mb250XzUxNTc3MV9lbWNuczUwNTR4M3doZnIudHRmXFxcIikgZm9ybWF0KFxcXCJ0cnVldHlwZVxcXCIpLCB1cmwoXFxcIi8vYXQuYWxpY2RuLmNvbS90L2ZvbnRfNTE1NzcxX2VtY25zNTA1NHgzd2hmci5zdmcjTmV4dEljb25cXFwiKSBmb3JtYXQoXFxcInN2Z1xcXCIpOyB9XFxuXFxuLm5leHQtaWNvbiB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBmb250LWZhbWlseTogTmV4dEljb247XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4gIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGU7IH1cXG4gIC5uZXh0LWljb246YmVmb3JlIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IH1cXG4gIC5uZXh0LWljb24tc21pbGU6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjVGXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1jcnk6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjVEXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1zdWNjZXNzOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYwQVxcXCI7IH1cXG4gIC5uZXh0LWljb24td2FybmluZzpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MEJcXFwiOyB9XFxuICAubmV4dC1pY29uLXByb21wdDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MENcXFwiOyB9XFxuICAubmV4dC1pY29uLWVycm9yOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYwRFxcXCI7IH1cXG4gIC5uZXh0LWljb24taGVscDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2NzNcXFwiOyB9XFxuICAubmV4dC1pY29uLWNsb2NrOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYyMVxcXCI7IH1cXG4gIC5uZXh0LWljb24tc3VjY2Vzcy1maWxsaW5nOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYzQVxcXCI7IH1cXG4gIC5uZXh0LWljb24tZGVsZXRlLWZpbGxpbmc6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjIzXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1mYXZvcml0ZXMtZmlsbGluZzpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MEVcXFwiOyB9XFxuICAubmV4dC1pY29uLWFkZDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2NTVcXFwiOyB9XFxuICAubmV4dC1pY29uLW1pbnVzOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYwMVxcXCI7IH1cXG4gIC5uZXh0LWljb24tYXJyb3ctdXA6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjI1XFxcIjsgfVxcbiAgLm5leHQtaWNvbi1hcnJvdy1kb3duOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYzRFxcXCI7IH1cXG4gIC5uZXh0LWljb24tYXJyb3ctbGVmdDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MURcXFwiOyB9XFxuICAubmV4dC1pY29uLWFycm93LXJpZ2h0OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYxOVxcXCI7IH1cXG4gIC5uZXh0LWljb24tYXJyb3ctZG91YmxlLWxlZnQ6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjU5XFxcIjsgfVxcbiAgLm5leHQtaWNvbi1hcnJvdy1kb3VibGUtcmlnaHQ6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjVFXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1zd2l0Y2g6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNkIzXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1zb3J0aW5nOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYzNFxcXCI7IH1cXG4gIC5uZXh0LWljb24tZGVzY2VuZGluZzpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MUZcXFwiOyB9XFxuICAubmV4dC1pY29uLWFzY2VuZGluZzpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MUVcXFwiOyB9XFxuICAubmV4dC1pY29uLXNlbGVjdDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MzJcXFwiOyB9XFxuICAubmV4dC1pY29uLXNlbWktc2VsZWN0OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYzM1xcXCI7IH1cXG4gIC5uZXh0LWljb24tc2VhcmNoOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTY1NlxcXCI7IH1cXG4gIC5uZXh0LWljb24tY2xvc2U6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjI2XFxcIjsgfVxcbiAgLm5leHQtaWNvbi1lbGxpcHNpczpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2NTRcXFwiOyB9XFxuICAubmV4dC1pY29uLXBpY3R1cmU6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjMxXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1jYWxlbmRhcjpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MDdcXFwiOyB9XFxuICAubmV4dC1pY29uLWFzaGJpbjpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MzlcXFwiOyB9XFxuICAubmV4dC1pY29uLXVwbG9hZDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU3RUVcXFwiOyB9XFxuICAubmV4dC1pY29uLWRvd25sb2FkOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYyOFxcXCI7IH1cXG4gIC5uZXh0LWljb24tc2V0OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTY4M1xcXCI7IH1cXG4gIC5uZXh0LWljb24tZWRpdDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2M0JcXFwiOyB9XFxuICAubmV4dC1pY29uLXJlZnJlc2g6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjc3XFxcIjsgfVxcbiAgLm5leHQtaWNvbi1maWx0ZXI6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjI3XFxcIjsgfVxcbiAgLm5leHQtaWNvbi1hdHRhY2htZW50OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTY2NVxcXCI7IH1cXG4gIC5uZXh0LWljb24tYWNjb3VudDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MDhcXFwiOyB9XFxuICAubmV4dC1pY29uLWVtYWlsOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYwNVxcXCI7IH1cXG4gIC5uZXh0LWljb24tYXRtOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYwNlxcXCI7IH1cXG4gIC5uZXh0LWljb24tbG9hZGluZzpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2NDZcXFwiO1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbjogbG9hZGluZ0NpcmNsZSAxcyBpbmZpbml0ZSBsaW5lYXI7XFxuICAgICAgICAgICAgYW5pbWF0aW9uOiBsb2FkaW5nQ2lyY2xlIDFzIGluZmluaXRlIGxpbmVhcjsgfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBsb2FkaW5nQ2lyY2xlIHtcXG4gIDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7IH1cXG4gIDEwMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XFxuICAgICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogNTAlIDUwJTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH0gfVxcblxcbkBrZXlmcmFtZXMgbG9hZGluZ0NpcmNsZSB7XFxuICAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogNTAlIDUwJTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpOyB9XFxuICAxMDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpOyB9IH1cXG5cXG4ubmV4dC1pY29uLm5leHQteHhzOmJlZm9yZSB7XFxuICB3aWR0aDogOHB4O1xcbiAgZm9udC1zaXplOiA4cHg7XFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcblxcbkBtZWRpYSBhbGwgYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDApIGFuZCAobWluLXJlc29sdXRpb246IDAuMDAxZHBjbSkge1xcbiAgLm5leHQtaWNvbi5uZXh0LXh4cyB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLjUpO1xcbiAgICAgICAgLW1zLXRyYW5zZm9ybTogc2NhbGUoMC41KTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNSk7XFxuICAgIG1hcmdpbi1sZWZ0OiAtNHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IC00cHg7IH1cXG4gICAgLm5leHQtaWNvbi5uZXh0LXh4czpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTZweDsgfSB9XFxuXFxuLm5leHQtaWNvbi5uZXh0LXhzOmJlZm9yZSB7XFxuICB3aWR0aDogMTJweDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuXFxuLm5leHQtaWNvbi5uZXh0LXNtYWxsOmJlZm9yZSB7XFxuICB3aWR0aDogMTZweDtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuXFxuLm5leHQtaWNvbi5uZXh0LW1lZGl1bTpiZWZvcmUge1xcbiAgd2lkdGg6IDIwcHg7XFxuICBmb250LXNpemU6IDIwcHg7XFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcblxcbi5uZXh0LWljb24ubmV4dC1sYXJnZTpiZWZvcmUge1xcbiAgd2lkdGg6IDI0cHg7XFxuICBmb250LXNpemU6IDI0cHg7XFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcblxcbi5uZXh0LWljb24ubmV4dC14bDpiZWZvcmUge1xcbiAgd2lkdGg6IDMycHg7XFxuICBmb250LXNpemU6IDMycHg7XFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcblxcbi5uZXh0LWljb24ubmV4dC14eGw6YmVmb3JlIHtcXG4gIHdpZHRoOiA0OHB4O1xcbiAgZm9udC1zaXplOiA0OHB4O1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG5cXG4ubmV4dC1pY29uLm5leHQteHh4bDpiZWZvcmUge1xcbiAgd2lkdGg6IDY0cHg7XFxuICBmb250LXNpemU6IDY0cHg7XFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlcj8/cmVmLS0yLTEhLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYj8/cmVmLS0yLTIhLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIhLi9zcmMvaWNvbi9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUgNiA3IDggOSAxMCAxMSAxMiAxMyAxNCAxNSAxNiAxNyAxOCAxOSAyMCAyMSAyMiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJALXdlYmtpdC1rZXlmcmFtZXMgZmFkZUluIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDE7IH0gfVxcblxcbkBrZXlmcmFtZXMgZmFkZUluIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDE7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBmYWRlSW5Eb3duIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwMHB4KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMTAwcHgpO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwMHB4KTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7IH0gfVxcblxcbkBrZXlmcmFtZXMgZmFkZUluRG93biB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDBweCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwMHB4KTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDBweCk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApOyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZmFkZUluTGVmdCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0yMHB4KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMjBweCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMjBweCk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIGZhZGVJbkxlZnQge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMjBweCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTIwcHgpO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTIwcHgpOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIGZhZGVJblJpZ2h0IHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjBweCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjBweCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgyMHB4KTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7IH0gfVxcblxcbkBrZXlmcmFtZXMgZmFkZUluUmlnaHQge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgyMHB4KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgyMHB4KTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDIwcHgpOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIGZhZGVJblVwIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMjBweCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMjBweCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgyMHB4KTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7IH0gfVxcblxcbkBrZXlmcmFtZXMgZmFkZUluVXAge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgyMHB4KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWSgyMHB4KTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDIwcHgpOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIGZhZGVPdXQge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAxOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMDsgfSB9XFxuXFxuQGtleWZyYW1lcyBmYWRlT3V0IHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDA7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBmYWRlT3V0RG93biB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgyMHB4KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWSgyMHB4KTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDIwcHgpOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIGZhZGVPdXREb3duIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDIwcHgpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDIwcHgpO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMjBweCk7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBmYWRlT3V0TGVmdCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMjBweCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTIwcHgpO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTIwcHgpOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIGZhZGVPdXRMZWZ0IHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0yMHB4KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMjBweCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMjBweCk7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBmYWRlT3V0UmlnaHQge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjBweCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjBweCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgyMHB4KTsgfSB9XFxuXFxuQGtleWZyYW1lcyBmYWRlT3V0UmlnaHQge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjBweCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjBweCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgyMHB4KTsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIGZhZGVPdXRVcCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMTAwcHgpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDBweCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMTAwcHgpOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIGZhZGVPdXRVcCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMTAwcHgpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDBweCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMTAwcHgpOyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgem9vbUluIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlM2QoMC4zLCAwLjMsIDAuMyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlM2QoMC4zLCAwLjMsIDAuMyk7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUzZCgwLjMsIDAuMywgMC4zKTsgfVxcbiAgNTAlIHtcXG4gICAgb3BhY2l0eTogMTsgfSB9XFxuXFxuQGtleWZyYW1lcyB6b29tSW4ge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUzZCgwLjMsIDAuMywgMC4zKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGUzZCgwLjMsIDAuMywgMC4zKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZTNkKDAuMywgMC4zLCAwLjMpOyB9XFxuICA1MCUge1xcbiAgICBvcGFjaXR5OiAxOyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgem9vbU91dCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDE7IH1cXG4gIDUwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZTNkKDAuMywgMC4zLCAwLjMpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZTNkKDAuMywgMC4zLCAwLjMpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlM2QoMC4zLCAwLjMsIDAuMyk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAwOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIHpvb21PdXQge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAxOyB9XFxuICA1MCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUzZCgwLjMsIDAuMywgMC4zKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGUzZCgwLjMsIDAuMywgMC4zKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZTNkKDAuMywgMC4zLCAwLjMpOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMDsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIGV4cGFuZEluRG93biB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDtcXG4gICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7XFxuICAgIC1tcy10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwO1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIGV4cGFuZEluRG93biB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDtcXG4gICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7XFxuICAgIC1tcy10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwO1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwOyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZXhwYW5kSW5VcCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDtcXG4gICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7XFxuICAgIC1tcy10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwO1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIGV4cGFuZEluVXAge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7XFxuICAgIC1tcy10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwO1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwO1xcbiAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIGV4cGFuZEluV2l0aEZhZGUge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwOyB9XFxuICA0MCUge1xcbiAgICBvcGFjaXR5OiAuMTsgfVxcbiAgNTAlIHtcXG4gICAgb3BhY2l0eTogLjk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIGV4cGFuZEluV2l0aEZhZGUge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwOyB9XFxuICA0MCUge1xcbiAgICBvcGFjaXR5OiAuMTsgfVxcbiAgNTAlIHtcXG4gICAgb3BhY2l0eTogLjk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxOyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZXhwYW5kT3V0VXAge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7XFxuICAgIC1tcy10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwO1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwO1xcbiAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDsgfSB9XFxuXFxuQGtleWZyYW1lcyBleHBhbmRPdXRVcCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDtcXG4gICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7XFxuICAgIC1tcy10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwO1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwOyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZXhwYW5kT3V0RG93biB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDtcXG4gICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7XFxuICAgIC1tcy10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwO1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIGV4cGFuZE91dERvd24ge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7XFxuICAgIC1tcy10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwO1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwO1xcbiAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIGV4cGFuZE91dFdpdGhGYWRlIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMTsgfVxcbiAgNzAlIHtcXG4gICAgb3BhY2l0eTogMDsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDA7IH0gfVxcblxcbkBrZXlmcmFtZXMgZXhwYW5kT3V0V2l0aEZhZGUge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAxOyB9XFxuICA3MCUge1xcbiAgICBvcGFjaXR5OiAwOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMDsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIHB1bHNlIHtcXG4gIGZyb20ge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpOyB9XFxuICAyMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMS4yKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGUoMS4yKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjIpOyB9XFxuICB0byB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7IH0gfVxcblxcbkBrZXlmcmFtZXMgcHVsc2Uge1xcbiAgZnJvbSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7IH1cXG4gIDIwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxLjIpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgxLjIpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMik7IH1cXG4gIHRvIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxKTsgfSB9XFxuXFxuLmZhZGVJbiB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBmYWRlSW47XFxuICBhbmltYXRpb24tbmFtZTogZmFkZUluO1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXFxuLmZhZGVJbkRvd24ge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogZmFkZUluRG93bjtcXG4gIGFuaW1hdGlvbi1uYW1lOiBmYWRlSW5Eb3duO1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXFxuLmZhZGVJbkxlZnQge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogZmFkZUluTGVmdDtcXG4gIGFuaW1hdGlvbi1uYW1lOiBmYWRlSW5MZWZ0O1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXFxuLmZhZGVJblJpZ2h0IHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGZhZGVJblJpZ2h0O1xcbiAgYW5pbWF0aW9uLW5hbWU6IGZhZGVJblJpZ2h0O1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXFxuLmZhZGVJblVwIHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGZhZGVJblVwO1xcbiAgYW5pbWF0aW9uLW5hbWU6IGZhZGVJblVwO1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXFxuLmZhZGVPdXQge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogZmFkZU91dDtcXG4gIGFuaW1hdGlvbi1uYW1lOiBmYWRlT3V0O1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNik7XFxuICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC43NTUsIDAuMDUsIDAuODU1LCAwLjA2KTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblxcbi5mYWRlT3V0RG93biB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBmYWRlT3V0RG93bjtcXG4gIGFuaW1hdGlvbi1uYW1lOiBmYWRlT3V0RG93bjtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIGFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjc1NSwgMC4wNSwgMC44NTUsIDAuMDYpO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNik7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cXG4uZmFkZU91dExlZnQge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogZmFkZU91dExlZnQ7XFxuICBhbmltYXRpb24tbmFtZTogZmFkZU91dExlZnQ7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogMHM7XFxuICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC43NTUsIDAuMDUsIDAuODU1LCAwLjA2KTtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjc1NSwgMC4wNSwgMC44NTUsIDAuMDYpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXFxuLmZhZGVPdXRSaWdodCB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBmYWRlT3V0UmlnaHQ7XFxuICBhbmltYXRpb24tbmFtZTogZmFkZU91dFJpZ2h0O1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNik7XFxuICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC43NTUsIDAuMDUsIDAuODU1LCAwLjA2KTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblxcbi5mYWRlT3V0VXAge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogZmFkZU91dFVwO1xcbiAgYW5pbWF0aW9uLW5hbWU6IGZhZGVPdXRVcDtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4ycztcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4ycztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIGFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjc1NSwgMC4wNSwgMC44NTUsIDAuMDYpO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNik7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cXG4uem9vbUluIHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IHpvb21JbjtcXG4gIGFuaW1hdGlvbi1uYW1lOiB6b29tSW47XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogMHM7XFxuICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cXG4uem9vbU91dCB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiB6b29tT3V0O1xcbiAgYW5pbWF0aW9uLW5hbWU6IHpvb21PdXQ7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogMHM7XFxuICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC43NTUsIDAuMDUsIDAuODU1LCAwLjA2KTtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjc1NSwgMC4wNSwgMC44NTUsIDAuMDYpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXFxuLmV4cGFuZEluRG93biB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBleHBhbmRJbkRvd247XFxuICBhbmltYXRpb24tbmFtZTogZXhwYW5kSW5Eb3duO1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXFxuLmV4cGFuZE91dFVwIHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGV4cGFuZE91dFVwO1xcbiAgYW5pbWF0aW9uLW5hbWU6IGV4cGFuZE91dFVwO1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjE1cztcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4xNXM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogMHM7XFxuICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cXG4uZXhwYW5kSW5VcCB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBleHBhbmRJblVwO1xcbiAgYW5pbWF0aW9uLW5hbWU6IGV4cGFuZEluVXA7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogMHM7XFxuICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cXG4uZXhwYW5kT3V0RG93biB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBleHBhbmRPdXREb3duO1xcbiAgYW5pbWF0aW9uLW5hbWU6IGV4cGFuZE91dERvd247XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuMTVzO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjE1cztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIGFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblxcbi5wdWxzZSB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBwdWxzZTtcXG4gIGFuaW1hdGlvbi1uYW1lOiBwdWxzZTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIGFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblxcbi5leHBhbmQtZW50ZXIge1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjsgfVxcblxcbi5leHBhbmQtZW50ZXItYWN0aXZlIHtcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYWxsIC4zcyBlYXNlLW91dDtcXG4gIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZS1vdXQ7IH1cXG4gIC5leHBhbmQtZW50ZXItYWN0aXZlID4gKiB7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGV4cGFuZEluV2l0aEZhZGU7XFxuICAgIGFuaW1hdGlvbi1uYW1lOiBleHBhbmRJbldpdGhGYWRlO1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAgIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjJzO1xcbiAgICBhbmltYXRpb24tZHVyYXRpb246IDAuMnM7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gICAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gICAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gICAgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOiBcXFwiZm9yd2FyZHNcXFwiO1xcbiAgICBhbmltYXRpb24tZmlsbC1tb2RlOiBcXFwiZm9yd2FyZHNcXFwiO1xcbiAgICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXG4gICAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXFxuLmV4cGFuZC1sZWF2ZSB7XFxuICBvdmVyZmxvdzogaGlkZGVuOyB9XFxuXFxuLmV4cGFuZC1sZWF2ZS1hY3RpdmUge1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgLjJzIGVhc2Utb3V0O1xcbiAgdHJhbnNpdGlvbjogYWxsIC4ycyBlYXNlLW91dDsgfVxcbiAgLmV4cGFuZC1sZWF2ZS1hY3RpdmUgPiAqIHtcXG4gICAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogZXhwYW5kT3V0V2l0aEZhZGU7XFxuICAgIGFuaW1hdGlvbi1uYW1lOiBleHBhbmRPdXRXaXRoRmFkZTtcXG4gICAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4ycztcXG4gICAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjJzO1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAgIGFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogXFxcImZvcndhcmRzXFxcIjtcXG4gICAgYW5pbWF0aW9uLWZpbGwtbW9kZTogXFxcImZvcndhcmRzXFxcIjtcXG4gICAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICAgIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlcj8/cmVmLS0yLTEhLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYj8/cmVmLS0yLTIhLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIhLi9zcmMvYW5pbWF0ZS9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUgNiA3IDggOSAxMCAxMSAxMiAxMyAxNCAxNSAxNiAxNyAxOCAxOSAyMCAyMSAyMiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAY2hhcnNldCBcXFwiVVRGLThcXFwiO1xcbi8qKlxcbiAqIOWwuuWvuCDln7rnoYDlsLrlr7hcXG4gKiDlkb3lkI3og73lnKjor63kuYnnmoTliY3mj5DkuIvnroDljZXlsLHlsL3ph4/nroDljZUsIOi/memHjOWPr+S7peaYryBzaXplLTJ4LCBzcGFjZS0yeCwgc2l6ZS1iYXNlIC4uLlxcbiAqIOS4jei/h+WPr+S7peWcqOivreS5ieeahOWJjeaPkOS4i+WBmueahOabtOeyvueugOS4gOS6mywg5LqO5piv55So5LqGczIsIHMx562JXFxuICog5Y+v55So5Y+Y6YePOiBgJHMxIC0gJHM4YFxcbiAqIEBleGFtcGxlIHNjc3MgLSDkvb/nlKhcXG4gKiAgIC5lbGVtZW50IHtcXG4gKiAgICAgcGFkZGluZzogJHMxICFkZWZhdWx0O1xcbiAqICAgfVxcbiAqXFxuICogQGV4YW1wbGUgY3NzIC0gQ1NTIOi+k+WHulxcbiAqICAgLmVsZW1lbnQge1xcbiAqICAgICBwYWRkaW5nOiA0cHggIWRlZmF1bHQ7XFxuICogICB9XFxuICovXFxuLyogc3R5bGVsaW50LWRpc2FibGUgbWF4LW5lc3RpbmctZGVwdGggKi9cXG4ubmV4dC1jaGVja2JveC13cmFwcGVyIHtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDsgfVxcbiAgLm5leHQtY2hlY2tib3gtd3JhcHBlciAqLFxcbiAgLm5leHQtY2hlY2tib3gtd3JhcHBlciAqOmJlZm9yZSxcXG4gIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIgKjphZnRlciB7XFxuICAgIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XFxuICAubmV4dC1jaGVja2JveC13cmFwcGVyIC5uZXh0LWNoZWNrYm94IHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxpbmUtaGVpZ2h0OiAxO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB9XFxuICAubmV4dC1jaGVja2JveC13cmFwcGVyIGlucHV0W3R5cGU9XFxcImNoZWNrYm94XFxcIl0ge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgd2lkdGg6IDE2cHg7XFxuICAgIGhlaWdodDogMTZweDtcXG4gICAgbWFyZ2luOiAwOyB9XFxuICAubmV4dC1jaGVja2JveC13cmFwcGVyIC5uZXh0LWNoZWNrYm94LWlubmVyIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHdpZHRoOiAxNnB4O1xcbiAgICBoZWlnaHQ6IDE2cHg7XFxuICAgIGJhY2tncm91bmQ6ICNGRkZGRkY7XFxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI0M0QzZDRjtcXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBlYXNlIGFsbCAuM3MgMHM7XFxuICAgIHRyYW5zaXRpb246IGVhc2UgYWxsIC4zcyAwcztcXG4gICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgLyog6Ziy5q2i57un5om/54i257qnICovXFxuICAgIC13ZWJraXQtYm94LXNoYWRvdzogbm9uZTtcXG4gICAgICAgICAgICBib3gtc2hhZG93OiBub25lO1xcbiAgICAvKiBib3gtc2l6aW5nOiBjb250ZW50LWJveDsgKi8gfVxcbiAgICAubmV4dC1jaGVja2JveC13cmFwcGVyIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbiB7XFxuICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDApO1xcbiAgICAgICAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgwKTtcXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgIHRvcDogMDtcXG4gICAgICBvcGFjaXR5OiAwO1xcbiAgICAgIGxpbmUtaGVpZ2h0OiAxNnB4O1xcbiAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjogYWxsIDAuM3MgY3ViaWMtYmV6aWVyKDAuNzgsIDAuMTQsIDAuMTUsIDAuODYpO1xcbiAgICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGN1YmljLWJlemllcigwLjc4LCAwLjE0LCAwLjE1LCAwLjg2KTtcXG4gICAgICBjb2xvcjogI0ZGRkZGRjtcXG4gICAgICBsZWZ0OiA0cHg7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDA7IH1cXG4gICAgICAubmV4dC1jaGVja2JveC13cmFwcGVyIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbjpiZWZvcmUge1xcbiAgICAgICAgd2lkdGg6IDhweDtcXG4gICAgICAgIGZvbnQtc2l6ZTogOHB4O1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgICBAbWVkaWEgYWxsIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAwKSBhbmQgKG1pbi1yZXNvbHV0aW9uOiAwLjAwMWRwY20pIHtcXG4gICAgICAgIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uIHtcXG4gICAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuNSk7XFxuICAgICAgICAgICAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgwLjUpO1xcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC41KTtcXG4gICAgICAgICAgbWFyZ2luLWxlZnQ6IC00cHg7XFxuICAgICAgICAgIG1hcmdpbi1yaWdodDogLTRweDsgfVxcbiAgICAgICAgICAubmV4dC1jaGVja2JveC13cmFwcGVyIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbjpiZWZvcmUge1xcbiAgICAgICAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTZweDsgfSB9XFxuICAgIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uOjpiZWZvcmUge1xcbiAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxuICAgICAgbWFyZ2luLXRvcDogMDsgfVxcbiAgLm5leHQtY2hlY2tib3gtd3JhcHBlci5jaGVja2VkIC5uZXh0LWNoZWNrYm94LWlubmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzU1ODRGRjsgfVxcbiAgICAubmV4dC1jaGVja2JveC13cmFwcGVyLmNoZWNrZWQgLm5leHQtY2hlY2tib3gtaW5uZXI6aG92ZXIsIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuY2hlY2tlZCAubmV4dC1jaGVja2JveC1pbm5lci5ob3ZlcmVkIHtcXG4gICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuICAgIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuY2hlY2tlZCAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb24ge1xcbiAgICAgIG9wYWNpdHk6IDE7XFxuICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICAgICAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgICAgLyogZm9udC1zaXplIDwgMTJweOeahOaXtuWAmei/m+ihjOimhuebluOAgiAqLyB9XFxuICAgICAgLm5leHQtY2hlY2tib3gtd3JhcHBlci5jaGVja2VkIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbjpiZWZvcmUge1xcbiAgICAgICAgd2lkdGg6IDhweDtcXG4gICAgICAgIGZvbnQtc2l6ZTogOHB4O1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgICBAbWVkaWEgYWxsIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAwKSBhbmQgKG1pbi1yZXNvbHV0aW9uOiAwLjAwMWRwY20pIHtcXG4gICAgICAgIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuY2hlY2tlZCAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb24ge1xcbiAgICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC41KTtcXG4gICAgICAgICAgICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDAuNSk7XFxuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjUpO1xcbiAgICAgICAgICBtYXJnaW4tbGVmdDogLTRweDtcXG4gICAgICAgICAgbWFyZ2luLXJpZ2h0OiAtNHB4OyB9XFxuICAgICAgICAgIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuY2hlY2tlZCAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb246YmVmb3JlIHtcXG4gICAgICAgICAgICB3aWR0aDogMTZweDtcXG4gICAgICAgICAgICBmb250LXNpemU6IDE2cHg7IH0gfVxcbiAgLm5leHQtY2hlY2tib3gtd3JhcHBlci5pbmRldGVybWluYXRlIC5uZXh0LWNoZWNrYm94LWlubmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzU1ODRGRjsgfVxcbiAgICAubmV4dC1jaGVja2JveC13cmFwcGVyLmluZGV0ZXJtaW5hdGUgLm5leHQtY2hlY2tib3gtaW5uZXI6aG92ZXIsIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuaW5kZXRlcm1pbmF0ZSAubmV4dC1jaGVja2JveC1pbm5lci5ob3ZlcmVkIHtcXG4gICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuICAgIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuaW5kZXRlcm1pbmF0ZSAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb24ge1xcbiAgICAgIG9wYWNpdHk6IDE7XFxuICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlM2QoMSwgMSwgMSk7XFxuICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlM2QoMSwgMSwgMSk7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgICAgLyogZm9udC1zaXplIDwgMTJweOeahOaXtuWAmei/m+ihjOimhuebluOAgiAqLyB9XFxuICAgICAgLm5leHQtY2hlY2tib3gtd3JhcHBlci5pbmRldGVybWluYXRlIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbjpiZWZvcmUge1xcbiAgICAgICAgd2lkdGg6IDhweDtcXG4gICAgICAgIGZvbnQtc2l6ZTogOHB4O1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgICBAbWVkaWEgYWxsIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAwKSBhbmQgKG1pbi1yZXNvbHV0aW9uOiAwLjAwMWRwY20pIHtcXG4gICAgICAgIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuaW5kZXRlcm1pbmF0ZSAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb24ge1xcbiAgICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC41KTtcXG4gICAgICAgICAgICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDAuNSk7XFxuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjUpO1xcbiAgICAgICAgICBtYXJnaW4tbGVmdDogLTRweDtcXG4gICAgICAgICAgbWFyZ2luLXJpZ2h0OiAtNHB4OyB9XFxuICAgICAgICAgIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuaW5kZXRlcm1pbmF0ZSAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb246YmVmb3JlIHtcXG4gICAgICAgICAgICB3aWR0aDogMTZweDtcXG4gICAgICAgICAgICBmb250LXNpemU6IDE2cHg7IH0gfVxcbiAgLm5leHQtY2hlY2tib3gtd3JhcHBlci5kaXNhYmxlZCBpbnB1dFt0eXBlPVxcXCJjaGVja2JveFxcXCJdIHtcXG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDsgfVxcbiAgLm5leHQtY2hlY2tib3gtd3JhcHBlci5kaXNhYmxlZCAubmV4dC1jaGVja2JveC1pbm5lciB7XFxuICAgIGJvcmRlci1jb2xvcjogI0U2RTdFQjtcXG4gICAgYmFja2dyb3VuZDogI0Y3RjhGQTsgfVxcbiAgLm5leHQtY2hlY2tib3gtd3JhcHBlci5kaXNhYmxlZC5jaGVja2VkIC5uZXh0LWNoZWNrYm94LWlubmVyOmhvdmVyLCAubmV4dC1jaGVja2JveC13cmFwcGVyLmRpc2FibGVkLmNoZWNrZWQgLm5leHQtY2hlY2tib3gtaW5uZXIuaG92ZXJlZCwgLm5leHQtY2hlY2tib3gtd3JhcHBlci5kaXNhYmxlZC5pbmRldGVybWluYXRlIC5uZXh0LWNoZWNrYm94LWlubmVyOmhvdmVyLCAubmV4dC1jaGVja2JveC13cmFwcGVyLmRpc2FibGVkLmluZGV0ZXJtaW5hdGUgLm5leHQtY2hlY2tib3gtaW5uZXIuaG92ZXJlZCB7XFxuICAgIGJvcmRlci1jb2xvcjogI0U2RTdFQjsgfVxcbiAgLm5leHQtY2hlY2tib3gtd3JhcHBlci5kaXNhYmxlZC5jaGVja2VkIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbiwgLm5leHQtY2hlY2tib3gtd3JhcHBlci5kaXNhYmxlZC5pbmRldGVybWluYXRlIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbiB7XFxuICAgIGNvbG9yOiAjQ0NDQ0NDO1xcbiAgICBvcGFjaXR5OiAxOyB9XFxuICAubmV4dC1jaGVja2JveC13cmFwcGVyOm5vdCguZGlzYWJsZWQpOmhvdmVyIC5uZXh0LWNoZWNrYm94LWlubmVyLCAubmV4dC1jaGVja2JveC13cmFwcGVyLmhvdmVyZWQgLm5leHQtY2hlY2tib3gtaW5uZXIsIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuZm9jdXNlZCAubmV4dC1jaGVja2JveC1pbm5lciB7XFxuICAgIGJvcmRlci1jb2xvcjogIzU1ODRGRjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0RFRThGRjsgfVxcbiAgLm5leHQtY2hlY2tib3gtd3JhcHBlci5pbmRldGVybWluYXRlOm5vdCguZGlzYWJsZWQpOmhvdmVyIC5uZXh0LWNoZWNrYm94LWlubmVyLCAubmV4dC1jaGVja2JveC13cmFwcGVyLmluZGV0ZXJtaW5hdGU6bm90KC5kaXNhYmxlZCkuaG92ZXJlZCAubmV4dC1jaGVja2JveC1pbm5lciwgLm5leHQtY2hlY2tib3gtd3JhcHBlci5pbmRldGVybWluYXRlLmZvY3VzZWQgLm5leHQtY2hlY2tib3gtaW5uZXIsIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuY2hlY2tlZDpub3QoLmRpc2FibGVkKTpob3ZlciAubmV4dC1jaGVja2JveC1pbm5lciwgLm5leHQtY2hlY2tib3gtd3JhcHBlci5jaGVja2VkOm5vdCguZGlzYWJsZWQpLmhvdmVyZWQgLm5leHQtY2hlY2tib3gtaW5uZXIsIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuY2hlY2tlZC5mb2N1c2VkIC5uZXh0LWNoZWNrYm94LWlubmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzNFNzFGNzsgfVxcbiAgICAubmV4dC1jaGVja2JveC13cmFwcGVyLmluZGV0ZXJtaW5hdGU6bm90KC5kaXNhYmxlZCk6aG92ZXIgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uLCAubmV4dC1jaGVja2JveC13cmFwcGVyLmluZGV0ZXJtaW5hdGU6bm90KC5kaXNhYmxlZCkuaG92ZXJlZCAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb24sIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuaW5kZXRlcm1pbmF0ZS5mb2N1c2VkIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbiwgLm5leHQtY2hlY2tib3gtd3JhcHBlci5jaGVja2VkOm5vdCguZGlzYWJsZWQpOmhvdmVyIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbiwgLm5leHQtY2hlY2tib3gtd3JhcHBlci5jaGVja2VkOm5vdCguZGlzYWJsZWQpLmhvdmVyZWQgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uLCAubmV4dC1jaGVja2JveC13cmFwcGVyLmNoZWNrZWQuZm9jdXNlZCAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb24ge1xcbiAgICAgIGNvbG9yOiAjRkZGRkZGO1xcbiAgICAgIG9wYWNpdHk6IDE7IH1cXG5cXG4ubmV4dC1jaGVja2JveC1ncm91cCAubmV4dC1jaGVja2JveC13cmFwcGVyIHtcXG4gIG1hcmdpbi1sZWZ0OiA4cHg7IH1cXG4gIC5uZXh0LWNoZWNrYm94LWdyb3VwIC5uZXh0LWNoZWNrYm94LXdyYXBwZXI6Zmlyc3QtY2hpbGQge1xcbiAgICBtYXJnaW4tbGVmdDogMDsgfVxcblxcbi5uZXh0LWNoZWNrYm94LWdyb3VwLXZlciAubmV4dC1jaGVja2JveC13cmFwcGVyIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgbWFyZ2luLWxlZnQ6IDA7XFxuICBtYXJnaW4tYm90dG9tOiA4cHg7IH1cXG5cXG4ubmV4dC1jaGVja2JveC1sYWJlbCB7XFxuICBmb250LXNpemU6IDEycHg7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgbWFyZ2luOiAwO1xcbiAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gIGxpbmUtaGVpZ2h0OiAxOyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyPz9yZWYtLTItMSEuL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliPz9yZWYtLTItMiEuL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYiEuL3NyYy9jaGVja2JveC9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUgNiA3IDggOSAxMCAxMSAxMiAxMyAxNCAxNSAxNiAxNyAxOCAxOSAyMCAyMSAyMiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAY2hhcnNldCBcXFwiVVRGLThcXFwiO1xcbi8qKlxcbiAqIOWwuuWvuCDln7rnoYDlsLrlr7hcXG4gKiDlkb3lkI3og73lnKjor63kuYnnmoTliY3mj5DkuIvnroDljZXlsLHlsL3ph4/nroDljZUsIOi/memHjOWPr+S7peaYryBzaXplLTJ4LCBzcGFjZS0yeCwgc2l6ZS1iYXNlIC4uLlxcbiAqIOS4jei/h+WPr+S7peWcqOivreS5ieeahOWJjeaPkOS4i+WBmueahOabtOeyvueugOS4gOS6mywg5LqO5piv55So5LqGczIsIHMx562JXFxuICog5Y+v55So5Y+Y6YePOiBgJHMxIC0gJHM4YFxcbiAqIEBleGFtcGxlIHNjc3MgLSDkvb/nlKhcXG4gKiAgIC5lbGVtZW50IHtcXG4gKiAgICAgcGFkZGluZzogJHMxICFkZWZhdWx0O1xcbiAqICAgfVxcbiAqXFxuICogQGV4YW1wbGUgY3NzIC0gQ1NTIOi+k+WHulxcbiAqICAgLmVsZW1lbnQge1xcbiAqICAgICBwYWRkaW5nOiA0cHggIWRlZmF1bHQ7XFxuICogICB9XFxuICovXFxuLm5leHQtcmFkaW8tYnV0dG9uLWxhcmdlW2Rpcj0ncnRsJ10gPiBsYWJlbDpmaXJzdC1jaGlsZCB7XFxuICBtYXJnaW4tbGVmdDogLTFweDtcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAzcHg7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogM3B4O1xcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7IH1cXG5cXG4ubmV4dC1yYWRpby1idXR0b24tbGFyZ2VbZGlyPSdydGwnXSA+IGxhYmVsOmxhc3QtY2hpbGQge1xcbiAgbWFyZ2luLWxlZnQ6IDA7XFxuICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogM3B4O1xcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogM3B4OyB9XFxuXFxuLm5leHQtcmFkaW8tYnV0dG9uLWxhcmdlW2Rpcj0ncnRsJ10gLm5leHQtcmFkaW8tbGFiZWwge1xcbiAgaGVpZ2h0OiAzOHB4O1xcbiAgbGluZS1oZWlnaHQ6IDM4cHg7XFxuICBmb250LXNpemU6IDE2cHg7IH1cXG5cXG4ubmV4dC1yYWRpby1idXR0b24tbWVkaXVtW2Rpcj0ncnRsJ10gPiBsYWJlbDpmaXJzdC1jaGlsZCB7XFxuICBtYXJnaW4tbGVmdDogLTFweDtcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDA7XFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDNweDtcXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAzcHg7IH1cXG5cXG4ubmV4dC1yYWRpby1idXR0b24tbWVkaXVtW2Rpcj0ncnRsJ10gPiBsYWJlbDpsYXN0LWNoaWxkIHtcXG4gIG1hcmdpbi1sZWZ0OiAwO1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMDtcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDNweDtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDNweDsgfVxcblxcbi5uZXh0LXJhZGlvLWJ1dHRvbi1zbWFsbFtkaXI9J3J0bCddID4gbGFiZWw6Zmlyc3QtY2hpbGQge1xcbiAgbWFyZ2luLWxlZnQ6IC0xcHg7XFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMDtcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAzcHg7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogM3B4OyB9XFxuXFxuLm5leHQtcmFkaW8tYnV0dG9uLXNtYWxsW2Rpcj0ncnRsJ10gPiBsYWJlbDpsYXN0LWNoaWxkIHtcXG4gIG1hcmdpbi1sZWZ0OiAwO1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMDtcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDNweDtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDNweDsgfVxcblxcbi5uZXh0LXJhZGlvLXdyYXBwZXJbZGlyPSdydGwnXSAubmV4dC1yYWRpby1sYWJlbCB7XFxuICBtYXJnaW4tbGVmdDogMDtcXG4gIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuXFxuLm5leHQtcmFkaW8tZ3JvdXBbZGlyPSdydGwnXSAubmV4dC1yYWRpby1sYWJlbCB7XFxuICBtYXJnaW4tcmlnaHQ6IDRweDtcXG4gIG1hcmdpbi1sZWZ0OiAxNnB4OyB9XFxuXFxuLm5leHQtcmFkaW8tYnV0dG9uW2Rpcj0ncnRsJ10gPiBsYWJlbCAubmV4dC1yYWRpby1sYWJlbCB7XFxuICBtYXJnaW46IDA7IH1cXG5cXG4ubmV4dC1yYWRpby13cmFwcGVyIHtcXG4gIG91dGxpbmU6IDA7IH1cXG4gIC5uZXh0LXJhZGlvLXdyYXBwZXIgLm5leHQtcmFkaW8ge1xcbiAgICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxpbmUtaGVpZ2h0OiAxOyB9XFxuICAgIC5uZXh0LXJhZGlvLXdyYXBwZXIgLm5leHQtcmFkaW8gKixcXG4gICAgLm5leHQtcmFkaW8td3JhcHBlciAubmV4dC1yYWRpbyAqOmJlZm9yZSxcXG4gICAgLm5leHQtcmFkaW8td3JhcHBlciAubmV4dC1yYWRpbyAqOmFmdGVyIHtcXG4gICAgICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XFxuICAgIC5uZXh0LXJhZGlvLXdyYXBwZXIgLm5leHQtcmFkaW8gaW5wdXRbdHlwZT1cXFwicmFkaW9cXFwiXSB7XFxuICAgICAgb3BhY2l0eTogMDtcXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgICB0b3A6IDA7XFxuICAgICAgbGVmdDogMDtcXG4gICAgICB3aWR0aDogMTZweDtcXG4gICAgICBoZWlnaHQ6IDE2cHg7XFxuICAgICAgbWFyZ2luOiAwOyB9XFxuICAubmV4dC1yYWRpby13cmFwcGVyIC5uZXh0LXJhZGlvLWlubmVyIHtcXG4gICAgLyog5Yqo55S75b6F5a6aICovXFxuICAgIC8qICYubW91c2VEb3duIHsgKi9cXG4gICAgLyogICAgIHRyYW5zZm9ybTogc2NhbGUzZCguNywgLjcsIC43KTsgKi9cXG4gICAgLyogICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAuMnMgbGluZWFyOyAqL1xcbiAgICAvKiB9ICovXFxuICAgIC8qICYubW91c2VVcCB7ICovXFxuICAgIC8qICAgICB0cmFuc2Zvcm06IHNjYWxlM2QoMSwgMSwgMSk7ICovXFxuICAgIC8qICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gLjJzIGxpbmVhcjsgKi9cXG4gICAgLyogfSAqL1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgd2lkdGg6IDE2cHg7XFxuICAgIGhlaWdodDogMTZweDtcXG4gICAgYmFja2dyb3VuZDogI0ZGRkZGRjtcXG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjQzRDNkNGO1xcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGVhc2UgYWxsIC4zNnMgMHM7XFxuICAgIHRyYW5zaXRpb246IGVhc2UgYWxsIC4zNnMgMHM7XFxuICAgIC13ZWJraXQtYm94LXNoYWRvdzogbm9uZTtcXG4gICAgICAgICAgICBib3gtc2hhZG93OiBub25lOyB9XFxuICAgIC5uZXh0LXJhZGlvLXdyYXBwZXIgLm5leHQtcmFkaW8taW5uZXI6YWZ0ZXIge1xcbiAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwKTtcXG4gICAgICAgICAgLW1zLXRyYW5zZm9ybTogc2NhbGUoMCk7XFxuICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICAgICAgdG9wOiA1MCU7XFxuICAgICAgbWFyZ2luLXRvcDogLTJweDtcXG4gICAgICBsZWZ0OiA1MCU7XFxuICAgICAgbWFyZ2luLWxlZnQ6IC0ycHg7XFxuICAgICAgYmFja2dyb3VuZDogI0ZGRkZGRjtcXG4gICAgICBjb250ZW50OiAnICc7XFxuICAgICAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgMC4zcyBjdWJpYy1iZXppZXIoMC43OCwgMC4xNCwgMC4xNSwgMC44Nik7XFxuICAgICAgdHJhbnNpdGlvbjogYWxsIDAuM3MgY3ViaWMtYmV6aWVyKDAuNzgsIDAuMTQsIDAuMTUsIDAuODYpOyB9XFxuICAubmV4dC1yYWRpby13cmFwcGVyLmNoZWNrZWQgLm5leHQtcmFkaW8taW5uZXIge1xcbiAgICBib3JkZXItY29sb3I6ICM1NTg0RkY7XFxuICAgIGJhY2tncm91bmQ6ICM1NTg0RkY7IH1cXG4gICAgLm5leHQtcmFkaW8td3JhcHBlci5jaGVja2VkIC5uZXh0LXJhZGlvLWlubmVyOmFmdGVyIHtcXG4gICAgICB3aWR0aDogNHB4O1xcbiAgICAgIGhlaWdodDogNHB4O1xcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICAgIGJhY2tncm91bmQ6ICNGRkZGRkY7XFxuICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICAgICAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7IH1cXG4gIC5uZXh0LXJhZGlvLXdyYXBwZXIuY2hlY2tlZDpob3ZlciAubmV4dC1yYWRpby1pbm5lciwgLm5leHQtcmFkaW8td3JhcHBlci5jaGVja2VkLmhvdmVyZWQgLm5leHQtcmFkaW8taW5uZXIge1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuICAubmV4dC1yYWRpby13cmFwcGVyLmRpc2FibGVkIGlucHV0W3R5cGU9XFxcInJhZGlvXFxcIl0ge1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkOyB9XFxuICAubmV4dC1yYWRpby13cmFwcGVyLmRpc2FibGVkIC5uZXh0LXJhZGlvLWlubmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjRTZFN0VCO1xcbiAgICBiYWNrZ3JvdW5kOiAjRjdGOEZBOyB9XFxuICAgIC5uZXh0LXJhZGlvLXdyYXBwZXIuZGlzYWJsZWQgLm5leHQtcmFkaW8taW5uZXI6aG92ZXIsIC5uZXh0LXJhZGlvLXdyYXBwZXIuZGlzYWJsZWQgLm5leHQtcmFkaW8taW5uZXIuaG92ZXJlZCB7XFxuICAgICAgYm9yZGVyLWNvbG9yOiAjRTZFN0VCOyB9XFxuICAubmV4dC1yYWRpby13cmFwcGVyLmRpc2FibGVkLmNoZWNrZWQgLm5leHQtcmFkaW8taW5uZXI6YWZ0ZXIge1xcbiAgICBiYWNrZ3JvdW5kOiAjQ0NDQ0NDOyB9XFxuICAubmV4dC1yYWRpby13cmFwcGVyOm5vdCguZGlzYWJsZWQpOmhvdmVyIC5uZXh0LXJhZGlvLWlubmVyLCAubmV4dC1yYWRpby13cmFwcGVyOm5vdCguZGlzYWJsZWQpLmhvdmVyZWQgLm5leHQtcmFkaW8taW5uZXIsIC5uZXh0LXJhZGlvLXdyYXBwZXI6bm90KC5kaXNhYmxlZCk6Zm9jdXMgLm5leHQtcmFkaW8taW5uZXIsIC5uZXh0LXJhZGlvLXdyYXBwZXI6bm90KC5kaXNhYmxlZCkuZm9jdXNlZCAubmV4dC1yYWRpby1pbm5lciB7XFxuICAgIGJvcmRlci1jb2xvcjogIzU1ODRGRjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0RFRThGRjsgfVxcbiAgLm5leHQtcmFkaW8td3JhcHBlci5jaGVja2VkOm5vdCguZGlzYWJsZWQpOmhvdmVyIC5uZXh0LXJhZGlvLWlubmVyLCAubmV4dC1yYWRpby13cmFwcGVyLmNoZWNrZWQ6bm90KC5kaXNhYmxlZCkuaG92ZXJlZCAubmV4dC1yYWRpby1pbm5lciwgLm5leHQtcmFkaW8td3JhcHBlci5jaGVja2VkOm5vdCguZGlzYWJsZWQpOmZvY3VzIC5uZXh0LXJhZGlvLWlubmVyLCAubmV4dC1yYWRpby13cmFwcGVyLmNoZWNrZWQuZm9jdXNlZCAubmV4dC1yYWRpby1pbm5lciB7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGJhY2tncm91bmQ6ICMzRTcxRjc7IH1cXG4gICAgLm5leHQtcmFkaW8td3JhcHBlci5jaGVja2VkOm5vdCguZGlzYWJsZWQpOmhvdmVyIC5uZXh0LXJhZGlvLWlubmVyOmFmdGVyLCAubmV4dC1yYWRpby13cmFwcGVyLmNoZWNrZWQ6bm90KC5kaXNhYmxlZCkuaG92ZXJlZCAubmV4dC1yYWRpby1pbm5lcjphZnRlciwgLm5leHQtcmFkaW8td3JhcHBlci5jaGVja2VkOm5vdCguZGlzYWJsZWQpOmZvY3VzIC5uZXh0LXJhZGlvLWlubmVyOmFmdGVyLCAubmV4dC1yYWRpby13cmFwcGVyLmNoZWNrZWQuZm9jdXNlZCAubmV4dC1yYWRpby1pbm5lcjphZnRlciB7XFxuICAgICAgYmFja2dyb3VuZDogI0ZGRkZGRjsgfVxcblxcbi5uZXh0LXJhZGlvLWJ1dHRvbiAubmV4dC1yYWRpbyB7XFxuICB3aWR0aDogMDtcXG4gIGhlaWdodDogMDsgfVxcblxcbi5uZXh0LXJhZGlvLWJ1dHRvbiBpbnB1dFt0eXBlPVxcXCJyYWRpb1xcXCJdIHtcXG4gIHdpZHRoOiAwO1xcbiAgaGVpZ2h0OiAwOyB9XFxuXFxuLm5leHQtcmFkaW8tYnV0dG9uID4gbGFiZWwge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgei1pbmRleDogMTtcXG4gIG1hcmdpbjogMCAwIDAgLTFweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNDNEM2Q0Y7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGO1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBlYXNlIGFsbCAuM3MgMHM7XFxuICB0cmFuc2l0aW9uOiBlYXNlIGFsbCAuM3MgMHM7IH1cXG4gIC5uZXh0LXJhZGlvLWJ1dHRvbiA+IGxhYmVsIC5uZXh0LXJhZGlvLWxhYmVsIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIGNvbG9yOiAjMzMzMzMzO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIC13ZWJraXQtdHJhbnNpdGlvbjogZWFzZSBhbGwgLjNzIDBzO1xcbiAgICB0cmFuc2l0aW9uOiBlYXNlIGFsbCAuM3MgMHM7IH1cXG4gIC5uZXh0LXJhZGlvLWJ1dHRvbiA+IGxhYmVsOmhvdmVyLCAubmV4dC1yYWRpby1idXR0b24gPiBsYWJlbDpmb2N1cywgLm5leHQtcmFkaW8tYnV0dG9uID4gbGFiZWwuaG92ZXJlZCB7XFxuICAgIHotaW5kZXg6IDEwO1xcbiAgICBib3JkZXItY29sb3I6ICNBMEEyQUQ7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGMkYzRjc7IH1cXG4gICAgLm5leHQtcmFkaW8tYnV0dG9uID4gbGFiZWw6aG92ZXIgLm5leHQtcmFkaW8tbGFiZWwsIC5uZXh0LXJhZGlvLWJ1dHRvbiA+IGxhYmVsOmZvY3VzIC5uZXh0LXJhZGlvLWxhYmVsLCAubmV4dC1yYWRpby1idXR0b24gPiBsYWJlbC5ob3ZlcmVkIC5uZXh0LXJhZGlvLWxhYmVsIHtcXG4gICAgICBjb2xvcjogIzMzMzMzMzsgfVxcbiAgLm5leHQtcmFkaW8tYnV0dG9uID4gbGFiZWwuY2hlY2tlZCB7XFxuICAgIHotaW5kZXg6IDEwO1xcbiAgICBib3JkZXItY29sb3I6ICM1NTg0RkY7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkY7IH1cXG4gICAgLm5leHQtcmFkaW8tYnV0dG9uID4gbGFiZWwuY2hlY2tlZCAubmV4dC1yYWRpby1sYWJlbCB7XFxuICAgICAgY29sb3I6ICM1NTg0RkY7IH1cXG4gIC5uZXh0LXJhZGlvLWJ1dHRvbiA+IGxhYmVsLmRpc2FibGVkIHtcXG4gICAgei1pbmRleDogMDtcXG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXG4gICAgYm9yZGVyLWNvbG9yOiAjRTZFN0VCO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGOEZBOyB9XFxuICAgIC5uZXh0LXJhZGlvLWJ1dHRvbiA+IGxhYmVsLmRpc2FibGVkIC5uZXh0LXJhZGlvLWxhYmVsIHtcXG4gICAgICBjb2xvcjogI0NDQ0NDQzsgfVxcbiAgLm5leHQtcmFkaW8tYnV0dG9uID4gbGFiZWwuY2hlY2tlZC5kaXNhYmxlZCB7XFxuICAgIHotaW5kZXg6IDA7XFxuICAgIGJvcmRlci1jb2xvcjogI0U2RTdFQjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0YyRjNGNzsgfVxcbiAgICAubmV4dC1yYWRpby1idXR0b24gPiBsYWJlbC5jaGVja2VkLmRpc2FibGVkIC5uZXh0LXJhZGlvLWxhYmVsIHtcXG4gICAgICBjb2xvcjogI0NDQ0NDQzsgfVxcblxcbi5uZXh0LXJhZGlvLWJ1dHRvbi1sYXJnZSA+IGxhYmVsIHtcXG4gIHBhZGRpbmc6IDAgOHB4O1xcbiAgaGVpZ2h0OiA0MHB4O1xcbiAgbGluZS1oZWlnaHQ6IDQwcHg7IH1cXG4gIC5uZXh0LXJhZGlvLWJ1dHRvbi1sYXJnZSA+IGxhYmVsOmZpcnN0LWNoaWxkIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDNweDtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogM3B4OyB9XFxuICAubmV4dC1yYWRpby1idXR0b24tbGFyZ2UgPiBsYWJlbDpsYXN0LWNoaWxkIHtcXG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDNweDtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDNweDsgfVxcblxcbi5uZXh0LXJhZGlvLWJ1dHRvbi1sYXJnZSAubmV4dC1yYWRpby1sYWJlbCB7XFxuICBoZWlnaHQ6IDM4cHg7XFxuICBsaW5lLWhlaWdodDogMzhweDtcXG4gIGZvbnQtc2l6ZTogMTZweDsgfVxcblxcbi5uZXh0LXJhZGlvLWJ1dHRvbi1tZWRpdW0gPiBsYWJlbCB7XFxuICBwYWRkaW5nOiAwIDhweDtcXG4gIGhlaWdodDogMjhweDtcXG4gIGxpbmUtaGVpZ2h0OiAyOHB4OyB9XFxuICAubmV4dC1yYWRpby1idXR0b24tbWVkaXVtID4gbGFiZWw6Zmlyc3QtY2hpbGQge1xcbiAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogM3B4O1xcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAzcHg7IH1cXG4gIC5uZXh0LXJhZGlvLWJ1dHRvbi1tZWRpdW0gPiBsYWJlbDpsYXN0LWNoaWxkIHtcXG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDNweDtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDNweDsgfVxcblxcbi5uZXh0LXJhZGlvLWJ1dHRvbi1tZWRpdW0gLm5leHQtcmFkaW8tbGFiZWwge1xcbiAgaGVpZ2h0OiAyNnB4O1xcbiAgbGluZS1oZWlnaHQ6IDI2cHg7XFxuICBmb250LXNpemU6IDEycHg7IH1cXG5cXG4ubmV4dC1yYWRpby1idXR0b24tc21hbGwgPiBsYWJlbCB7XFxuICBwYWRkaW5nOiAwIDhweDtcXG4gIGhlaWdodDogMjBweDtcXG4gIGxpbmUtaGVpZ2h0OiAyMHB4OyB9XFxuICAubmV4dC1yYWRpby1idXR0b24tc21hbGwgPiBsYWJlbDpmaXJzdC1jaGlsZCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAzcHg7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDNweDsgfVxcbiAgLm5leHQtcmFkaW8tYnV0dG9uLXNtYWxsID4gbGFiZWw6bGFzdC1jaGlsZCB7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAzcHg7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAzcHg7IH1cXG5cXG4ubmV4dC1yYWRpby1idXR0b24tc21hbGwgLm5leHQtcmFkaW8tbGFiZWwge1xcbiAgaGVpZ2h0OiAxOHB4O1xcbiAgbGluZS1oZWlnaHQ6IDE4cHg7XFxuICBmb250LXNpemU6IDEycHg7IH1cXG5cXG4ubmV4dC1yYWRpby1zaW5nbGUtaW5wdXQgaW5wdXRbdHlwZT1cXFwicmFkaW9cXFwiXSB7XFxuICBvcGFjaXR5OiAwO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIG1hcmdpbjogMDsgfVxcblxcbi5uZXh0LXJhZGlvLWdyb3VwIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jazsgfVxcbiAgLm5leHQtcmFkaW8tZ3JvdXAgLm5leHQtcmFkaW8tbGFiZWwge1xcbiAgICBjb2xvcjogIzMzMzMzMztcXG4gICAgbWFyZ2luLXJpZ2h0OiAxNnB4OyB9XFxuICAubmV4dC1yYWRpby1ncm91cC5kaXNhYmxlZCAubmV4dC1yYWRpby1sYWJlbCB7XFxuICAgIGNvbG9yOiAjQ0NDQ0NDOyB9XFxuXFxuLm5leHQtcmFkaW8tZ3JvdXAtdmVyIC5uZXh0LXJhZGlvLXdyYXBwZXIge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBtYXJnaW4tYm90dG9tOiA4cHg7IH1cXG5cXG4ubmV4dC1yYWRpby1sYWJlbCB7XFxuICBtYXJnaW46IDA7XFxuICBtYXJnaW4tbGVmdDogNHB4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIGxpbmUtaGVpZ2h0OiAxOyB9XFxuXFxuQC1tb3otZG9jdW1lbnQgdXJsLXByZWZpeCgpIHtcXG4gIC5uZXh0LXJhZGlvIHtcXG4gICAgbWFyZ2luLXRvcDogLTFweDsgfVxcbiAgQHN1cHBvcnRzICgoLXdlYmtpdC1hbmltYXRpb246IGNhbGMoMHMpKSBvciAoYW5pbWF0aW9uOiBjYWxjKDBzKSkpIHtcXG4gICAgLyogZmlyZWZveCA1NysgKi9cXG4gICAgLm5leHQtcmFkaW8ge1xcbiAgICAgIG1hcmdpbi10b3A6IC0zcHg7IH0gfSB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyPz9yZWYtLTItMSEuL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliPz9yZWYtLTItMiEuL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYiEuL3NyYy9yYWRpby9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUgNiA3IDggOSAxMCAxMSAxMiAxMyAxNCAxNSAxNiAxNyAxOCAxOSAyMCAyMSAyMiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAY2hhcnNldCBcXFwiVVRGLThcXFwiO1xcbi8qKlxcbiAqIOWwuuWvuCDln7rnoYDlsLrlr7hcXG4gKiDlkb3lkI3og73lnKjor63kuYnnmoTliY3mj5DkuIvnroDljZXlsLHlsL3ph4/nroDljZUsIOi/memHjOWPr+S7peaYryBzaXplLTJ4LCBzcGFjZS0yeCwgc2l6ZS1iYXNlIC4uLlxcbiAqIOS4jei/h+WPr+S7peWcqOivreS5ieeahOWJjeaPkOS4i+WBmueahOabtOeyvueugOS4gOS6mywg5LqO5piv55So5LqGczIsIHMx562JXFxuICog5Y+v55So5Y+Y6YePOiBgJHMxIC0gJHM4YFxcbiAqIEBleGFtcGxlIHNjc3MgLSDkvb/nlKhcXG4gKiAgIC5lbGVtZW50IHtcXG4gKiAgICAgcGFkZGluZzogJHMxICFkZWZhdWx0O1xcbiAqICAgfVxcbiAqXFxuICogQGV4YW1wbGUgY3NzIC0gQ1NTIOi+k+WHulxcbiAqICAgLmVsZW1lbnQge1xcbiAqICAgICBwYWRkaW5nOiA0cHggIWRlZmF1bHQ7XFxuICogICB9XFxuICovXFxuLm5leHQtbWVudVtkaXI9XFxcInJ0bFxcXCJdIC5uZXh0LW1lbnUtaXRlbS1oZWxwZXIge1xcbiAgZmxvYXQ6IGxlZnQ7IH1cXG5cXG4ubmV4dC1tZW51W2Rpcj1cXFwicnRsXFxcIl0gLm5leHQtbWVudS1pdGVtIC5uZXh0LWNoZWNrYm94LFxcbi5uZXh0LW1lbnVbZGlyPVxcXCJydGxcXFwiXSAubmV4dC1tZW51LWl0ZW0gLm5leHQtcmFkaW8ge1xcbiAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gIG1hcmdpbi1yaWdodDogMDsgfVxcblxcbi5uZXh0LW1lbnVbZGlyPVxcXCJydGxcXFwiXSAubmV4dC1tZW51LWhvei1yaWdodCB7XFxuICBmbG9hdDogcmlnaHQ7IH1cXG5cXG4ubmV4dC1tZW51W2Rpcj1cXFwicnRsXFxcIl0gLm5leHQtbWVudS1pY29uLWFycm93Lm5leHQtaWNvbiB7XFxuICBsZWZ0OiAxMHB4O1xcbiAgcmlnaHQ6IGF1dG87IH1cXG5cXG4ubmV4dC1tZW51W2Rpcj1cXFwicnRsXFxcIl0gLm5leHQtbWVudS1ob3otaWNvbi1hcnJvdy5uZXh0LWljb24ge1xcbiAgbGVmdDogNnB4O1xcbiAgcmlnaHQ6IGF1dG87IH1cXG5cXG4ubmV4dC1tZW51W2Rpcj1cXFwicnRsXFxcIl0gLm5leHQtbWVudS1pY29uLXNlbGVjdGVkLm5leHQtaWNvbiB7XFxuICBtYXJnaW4tbGVmdDogMDtcXG4gIG1hcmdpbi1yaWdodDogLTE2cHg7IH1cXG4gIC5uZXh0LW1lbnVbZGlyPVxcXCJydGxcXFwiXSAubmV4dC1tZW51LWljb24tc2VsZWN0ZWQubmV4dC1pY29uOmJlZm9yZSB7XFxuICAgIHdpZHRoOiAxMnB4O1xcbiAgICBmb250LXNpemU6IDEycHg7XFxuICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuXFxuLm5leHQtbWVudVtkaXI9XFxcInJ0bFxcXCJdIC5uZXh0LW1lbnUtaWNvbi1hcnJvdy5uZXh0LWljb24ge1xcbiAgbGVmdDogMTBweDtcXG4gIHJpZ2h0OiBhdXRvOyB9XFxuXFxuLm5leHQtbWVudSB7XFxuICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBtaW4td2lkdGg6IDEwMHB4O1xcbiAgcGFkZGluZzogOHB4IDA7XFxuICBtYXJnaW46IDA7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI0RDREVFMztcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogbm9uZTtcXG4gICAgICAgICAgYm94LXNoYWRvdzogbm9uZTtcXG4gIGJhY2tncm91bmQ6ICNGRkZGRkY7XFxuICBsaW5lLWhlaWdodDogMzJweDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIC8qICYtcG9wdXAtY29udGVudC5uZXh0LWhpZGUgeyAqL1xcbiAgLyogICAgIGRpc3BsYXk6IG5vbmU7ICovXFxuICAvKiB9ICovIH1cXG4gIC5uZXh0LW1lbnUgKixcXG4gIC5uZXh0LW1lbnUgKjpiZWZvcmUsXFxuICAubmV4dC1tZW51ICo6YWZ0ZXIge1xcbiAgICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDsgfVxcbiAgLm5leHQtbWVudTpmb2N1cyxcXG4gIC5uZXh0LW1lbnUgKjpmb2N1cyB7XFxuICAgIG91dGxpbmU6IDA7IH1cXG4gIC5uZXh0LW1lbnUtY29udGVudCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBsaXN0LXN0eWxlOiBub25lOyB9XFxuICAubmV4dC1tZW51LXN1Yi1tZW51IHtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBsaXN0LXN0eWxlOiBub25lOyB9XFxuICAgIC5uZXh0LW1lbnUtc3ViLW1lbnUubmV4dC1leHBhbmQtZW50ZXIge1xcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47IH1cXG4gICAgLm5leHQtbWVudS1zdWItbWVudS5uZXh0LWV4cGFuZC1lbnRlci1hY3RpdmUge1xcbiAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjogaGVpZ2h0IC4zcyBlYXNlLW91dDtcXG4gICAgICB0cmFuc2l0aW9uOiBoZWlnaHQgLjNzIGVhc2Utb3V0OyB9XFxuICAgIC5uZXh0LW1lbnUtc3ViLW1lbnUubmV4dC1leHBhbmQtbGVhdmUge1xcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47IH1cXG4gICAgLm5leHQtbWVudS1zdWItbWVudS5uZXh0LWV4cGFuZC1sZWF2ZS1hY3RpdmUge1xcbiAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjogaGVpZ2h0IC4zcyBlYXNlLW91dDtcXG4gICAgICB0cmFuc2l0aW9uOiBoZWlnaHQgLjNzIGVhc2Utb3V0OyB9XFxuICAubmV4dC1tZW51LWl0ZW0ge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIHBhZGRpbmc6IDAgMjBweDtcXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIC4ycyBlYXNlO1xcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIC4ycyBlYXNlO1xcbiAgICBjb2xvcjogIzMzMzMzMztcXG4gICAgY3Vyc29yOiBwb2ludGVyOyB9XFxuICAgIC5uZXh0LW1lbnUtaXRlbS1oZWxwZXIge1xcbiAgICAgIGZsb2F0OiByaWdodDtcXG4gICAgICBjb2xvcjogIzk5OTk5OTtcXG4gICAgICBmb250LXN0eWxlOiBub3JtYWw7XFxuICAgICAgZm9udC1zaXplOiAxMnB4OyB9XFxuICAgIC5uZXh0LW1lbnUtaXRlbSAubmV4dC1jaGVja2JveCxcXG4gICAgLm5leHQtbWVudS1pdGVtIC5uZXh0LXJhZGlvIHtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgICAubmV4dC1tZW51LWl0ZW0ubmV4dC1zZWxlY3RlZCB7XFxuICAgICAgY29sb3I6ICMzMzMzMzM7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRjsgfVxcbiAgICAgIC5uZXh0LW1lbnUtaXRlbS5uZXh0LXNlbGVjdGVkIC5uZXh0LW1lbnUtaWNvbi1hcnJvdyB7XFxuICAgICAgICBjb2xvcjogIzY2NjY2NjsgfVxcbiAgICAgIC5uZXh0LW1lbnUtaXRlbS5uZXh0LXNlbGVjdGVkIC5uZXh0LW1lbnUtaWNvbi1zZWxlY3RlZCB7XFxuICAgICAgICBjb2xvcjogIzU1ODRGRjsgfVxcbiAgICAubmV4dC1tZW51LWl0ZW0ubmV4dC1kaXNhYmxlZCxcXG4gICAgLm5leHQtbWVudS1pdGVtLm5leHQtZGlzYWJsZWQgLm5leHQtbWVudS1pdGVtLXRleHQgPiBhIHtcXG4gICAgICBjb2xvcjogI0NDQ0NDQztcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGO1xcbiAgICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7IH1cXG4gICAgICAubmV4dC1tZW51LWl0ZW0ubmV4dC1kaXNhYmxlZCAubmV4dC1tZW51LWljb24tYXJyb3csXFxuICAgICAgLm5leHQtbWVudS1pdGVtLm5leHQtZGlzYWJsZWQgLm5leHQtbWVudS1pdGVtLXRleHQgPiBhIC5uZXh0LW1lbnUtaWNvbi1hcnJvdyB7XFxuICAgICAgICBjb2xvcjogI0NDQ0NDQzsgfVxcbiAgICAgIC5uZXh0LW1lbnUtaXRlbS5uZXh0LWRpc2FibGVkIC5uZXh0LW1lbnUtaWNvbi1zZWxlY3RlZCxcXG4gICAgICAubmV4dC1tZW51LWl0ZW0ubmV4dC1kaXNhYmxlZCAubmV4dC1tZW51LWl0ZW0tdGV4dCA+IGEgLm5leHQtbWVudS1pY29uLXNlbGVjdGVkIHtcXG4gICAgICAgIGNvbG9yOiAjQ0NDQ0NDOyB9XFxuICAgIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpOmhvdmVyLCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKS5uZXh0LXNlbGVjdGVkOmhvdmVyLCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKS5uZXh0LXNlbGVjdGVkLm5leHQtZm9jdXNlZDpob3ZlciwgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCkubmV4dC1zZWxlY3RlZDpmb2N1czpob3ZlciwgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCkubmV4dC1mb2N1c2VkLCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKTpmb2N1cywgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCkubmV4dC1zZWxlY3RlZC5uZXh0LWZvY3VzZWQsIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpLm5leHQtc2VsZWN0ZWQ6Zm9jdXMge1xcbiAgICAgIGNvbG9yOiAjMzMzMzMzO1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNGMkYzRjc7IH1cXG4gICAgICAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKTpob3ZlciAubmV4dC1tZW51LWljb24tYXJyb3csIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpLm5leHQtc2VsZWN0ZWQ6aG92ZXIgLm5leHQtbWVudS1pY29uLWFycm93LCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKS5uZXh0LXNlbGVjdGVkLm5leHQtZm9jdXNlZDpob3ZlciAubmV4dC1tZW51LWljb24tYXJyb3csIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpLm5leHQtc2VsZWN0ZWQ6Zm9jdXM6aG92ZXIgLm5leHQtbWVudS1pY29uLWFycm93LCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKS5uZXh0LWZvY3VzZWQgLm5leHQtbWVudS1pY29uLWFycm93LCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKTpmb2N1cyAubmV4dC1tZW51LWljb24tYXJyb3csIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpLm5leHQtc2VsZWN0ZWQubmV4dC1mb2N1c2VkIC5uZXh0LW1lbnUtaWNvbi1hcnJvdywgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCkubmV4dC1zZWxlY3RlZDpmb2N1cyAubmV4dC1tZW51LWljb24tYXJyb3cge1xcbiAgICAgICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gICAgICAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKTpob3ZlciAubmV4dC1tZW51LWljb24tc2VsZWN0ZWQsIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpLm5leHQtc2VsZWN0ZWQ6aG92ZXIgLm5leHQtbWVudS1pY29uLXNlbGVjdGVkLCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKS5uZXh0LXNlbGVjdGVkLm5leHQtZm9jdXNlZDpob3ZlciAubmV4dC1tZW51LWljb24tc2VsZWN0ZWQsIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpLm5leHQtc2VsZWN0ZWQ6Zm9jdXM6aG92ZXIgLm5leHQtbWVudS1pY29uLXNlbGVjdGVkLCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKS5uZXh0LWZvY3VzZWQgLm5leHQtbWVudS1pY29uLXNlbGVjdGVkLCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKTpmb2N1cyAubmV4dC1tZW51LWljb24tc2VsZWN0ZWQsIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpLm5leHQtc2VsZWN0ZWQubmV4dC1mb2N1c2VkIC5uZXh0LW1lbnUtaWNvbi1zZWxlY3RlZCwgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCkubmV4dC1zZWxlY3RlZDpmb2N1cyAubmV4dC1tZW51LWljb24tc2VsZWN0ZWQge1xcbiAgICAgICAgY29sb3I6ICM1NTg0RkY7IH1cXG4gIC5uZXh0LW1lbnUtaXRlbS1pbm5lciB7XFxuICAgIGhlaWdodDogMzJweDtcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gICAgd29yZC13cmFwOiBub3JtYWw7IH1cXG4gIC5uZXh0LW1lbnUtaXRlbS10ZXh0IHtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgfVxcbiAgICAubmV4dC1tZW51LWl0ZW0tdGV4dCA+IGEge1xcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gICAgICAubmV4dC1tZW51LWl0ZW0tdGV4dCA+IGE6OmJlZm9yZSB7XFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgIHRvcDogMDtcXG4gICAgICAgIGxlZnQ6IDA7XFxuICAgICAgICBib3R0b206IDA7XFxuICAgICAgICByaWdodDogMDtcXG4gICAgICAgIGNvbnRlbnQ6ICcnOyB9XFxuICAubmV4dC1tZW51Lm5leHQtaG96IHtcXG4gICAgcGFkZGluZzogMDsgfVxcbiAgICAubmV4dC1tZW51Lm5leHQtaG96ID4gLm5leHQtbWVudS1pdGVtLFxcbiAgICAubmV4dC1tZW51Lm5leHQtaG96IC5uZXh0LW1lbnUtY29udGVudCA+IC5uZXh0LW1lbnUtaXRlbSB7XFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7IH1cXG4gICAgLm5leHQtbWVudS5uZXh0LWhveiAubmV4dC1tZW51LWhlYWRlcixcXG4gICAgLm5leHQtbWVudS5uZXh0LWhveiAubmV4dC1tZW51LWNvbnRlbnQsXFxuICAgIC5uZXh0LW1lbnUubmV4dC1ob3ogLm5leHQtbWVudS1mb290ZXIge1xcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jazsgfVxcbiAgLm5leHQtbWVudS1ob3otcmlnaHQge1xcbiAgICBmbG9hdDogcmlnaHQ7IH1cXG4gIC5uZXh0LW1lbnUtZ3JvdXAtbGFiZWwge1xcbiAgICBwYWRkaW5nOiAwIDEycHg7XFxuICAgIGNvbG9yOiAjOTk5OTk5OyB9XFxuICAubmV4dC1tZW51LWRpdmlkZXIge1xcbiAgICBtYXJnaW46IDhweCAxMnB4O1xcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI0U2RTdFQjsgfVxcbiAgLm5leHQtbWVudSAubmV4dC1tZW51LWljb24tc2VsZWN0ZWQubmV4dC1pY29uIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMTZweDsgfVxcbiAgICAubmV4dC1tZW51IC5uZXh0LW1lbnUtaWNvbi1zZWxlY3RlZC5uZXh0LWljb246YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTJweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gIC5uZXh0LW1lbnUgLm5leHQtbWVudS1pY29uLWFycm93Lm5leHQtaWNvbiB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMTBweDtcXG4gICAgY29sb3I6ICM2NjY2NjY7XFxuICAgIC13ZWJraXQtdHJhbnNpdGlvbjogYWxsIGVhc2UgLjNzO1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgZWFzZSAuM3M7IH1cXG4gICAgLm5leHQtbWVudSAubmV4dC1tZW51LWljb24tYXJyb3cubmV4dC1pY29uOmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDhweDtcXG4gICAgICBmb250LXNpemU6IDhweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICBAbWVkaWEgYWxsIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAwKSBhbmQgKG1pbi1yZXNvbHV0aW9uOiAwLjAwMWRwY20pIHtcXG4gICAgICAubmV4dC1tZW51IC5uZXh0LW1lbnUtaWNvbi1hcnJvdy5uZXh0LWljb24ge1xcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuNSk7XFxuICAgICAgICAgICAgLW1zLXRyYW5zZm9ybTogc2NhbGUoMC41KTtcXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjUpO1xcbiAgICAgICAgbWFyZ2luLWxlZnQ6IC00cHg7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IC00cHg7IH1cXG4gICAgICAgIC5uZXh0LW1lbnUgLm5leHQtbWVudS1pY29uLWFycm93Lm5leHQtaWNvbjpiZWZvcmUge1xcbiAgICAgICAgICB3aWR0aDogMTZweDtcXG4gICAgICAgICAgZm9udC1zaXplOiAxNnB4OyB9IH1cXG4gIC5uZXh0LW1lbnUgLm5leHQtbWVudS1pY29uLWFycm93LWRvd24ubmV4dC1vcGVuIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcbiAgICAgICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTsgfVxcbiAgICAubmV4dC1tZW51IC5uZXh0LW1lbnUtaWNvbi1hcnJvdy1kb3duLm5leHQtb3BlbjpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiA4cHg7XFxuICAgICAgZm9udC1zaXplOiA4cHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgQG1lZGlhIGFsbCBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMCkgYW5kIChtaW4tcmVzb2x1dGlvbjogMC4wMDFkcGNtKSB7XFxuICAgICAgLm5leHQtbWVudSAubmV4dC1tZW51LWljb24tYXJyb3ctZG93bi5uZXh0LW9wZW4ge1xcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuNSkgcm90YXRlKDE4MGRlZyk7XFxuICAgICAgICAgICAgLW1zLXRyYW5zZm9ybTogc2NhbGUoMC41KSByb3RhdGUoMTgwZGVnKTtcXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjUpIHJvdGF0ZSgxODBkZWcpO1xcbiAgICAgICAgbWFyZ2luLWxlZnQ6IC00cHg7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IC00cHg7IH1cXG4gICAgICAgIC5uZXh0LW1lbnUgLm5leHQtbWVudS1pY29uLWFycm93LWRvd24ubmV4dC1vcGVuOmJlZm9yZSB7XFxuICAgICAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgICAgICBmb250LXNpemU6IDE2cHg7IH0gfVxcbiAgLm5leHQtbWVudSAubmV4dC1tZW51LWljb24tYXJyb3ctcmlnaHQubmV4dC1vcGVuIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgtOTBkZWcpO1xcbiAgICAgICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKC05MGRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoLTkwZGVnKTsgfVxcbiAgICAubmV4dC1tZW51IC5uZXh0LW1lbnUtaWNvbi1hcnJvdy1yaWdodC5uZXh0LW9wZW46YmVmb3JlIHtcXG4gICAgICB3aWR0aDogOHB4O1xcbiAgICAgIGZvbnQtc2l6ZTogOHB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgIEBtZWRpYSBhbGwgYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDApIGFuZCAobWluLXJlc29sdXRpb246IDAuMDAxZHBjbSkge1xcbiAgICAgIC5uZXh0LW1lbnUgLm5leHQtbWVudS1pY29uLWFycm93LXJpZ2h0Lm5leHQtb3BlbiB7XFxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC41KSByb3RhdGUoLTkwZGVnKTtcXG4gICAgICAgICAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgwLjUpIHJvdGF0ZSgtOTBkZWcpO1xcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNSkgcm90YXRlKC05MGRlZyk7XFxuICAgICAgICBtYXJnaW4tbGVmdDogLTRweDtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogLTRweDsgfVxcbiAgICAgICAgLm5leHQtbWVudSAubmV4dC1tZW51LWljb24tYXJyb3ctcmlnaHQubmV4dC1vcGVuOmJlZm9yZSB7XFxuICAgICAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgICAgICBmb250LXNpemU6IDE2cHg7IH0gfVxcbiAgLm5leHQtbWVudSAubmV4dC1tZW51LWhvei1pY29uLWFycm93Lm5leHQtaWNvbiB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogNnB4O1xcbiAgICBjb2xvcjogIzY2NjY2NjtcXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgZWFzZSAuM3M7XFxuICAgIHRyYW5zaXRpb246IGFsbCBlYXNlIC4zczsgfVxcbiAgICAubmV4dC1tZW51IC5uZXh0LW1lbnUtaG96LWljb24tYXJyb3cubmV4dC1pY29uOmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC1tZW51IC5uZXh0LW1lbnUtaG96LWljb24tYXJyb3cubmV4dC1vcGVuIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcbiAgICAgICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTsgfVxcbiAgICAubmV4dC1tZW51IC5uZXh0LW1lbnUtaG96LWljb24tYXJyb3cubmV4dC1vcGVuOmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC1tZW51Lm5leHQtY29udGV4dCB7XFxuICAgIGxpbmUtaGVpZ2h0OiAyNHB4OyB9XFxuICAgIC5uZXh0LW1lbnUubmV4dC1jb250ZXh0IC5uZXh0LW1lbnUtaXRlbS1pbm5lciB7XFxuICAgICAgaGVpZ2h0OiAyNHB4OyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyPz9yZWYtLTItMSEuL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliPz9yZWYtLTItMiEuL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYiEuL3NyYy9tZW51L21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIDEyIDEzIDE0IDE1IDE2IDE3IDE4IDE5IDIwIDIxIDIyIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBjaGFyc2V0IFxcXCJVVEYtOFxcXCI7XFxuLyoqXFxuICog5bC65a+4IOWfuuehgOWwuuWvuFxcbiAqIOWRveWQjeiDveWcqOivreS5ieeahOWJjeaPkOS4i+eugOWNleWwseWwvemHj+eugOWNlSwg6L+Z6YeM5Y+v5Lul5pivIHNpemUtMngsIHNwYWNlLTJ4LCBzaXplLWJhc2UgLi4uXFxuICog5LiN6L+H5Y+v5Lul5Zyo6K+t5LmJ55qE5YmN5o+Q5LiL5YGa55qE5pu057K+566A5LiA5LqbLCDkuo7mmK/nlKjkuoZzMiwgczHnrYlcXG4gKiDlj6/nlKjlj5jph486IGAkczEgLSAkczhgXFxuICogQGV4YW1wbGUgc2NzcyAtIOS9v+eUqFxcbiAqICAgLmVsZW1lbnQge1xcbiAqICAgICBwYWRkaW5nOiAkczEgIWRlZmF1bHQ7XFxuICogICB9XFxuICpcXG4gKiBAZXhhbXBsZSBjc3MgLSBDU1Mg6L6T5Ye6XFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6IDRweCAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKi9cXG4ubmV4dC1idG4ge1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XFxuICAubmV4dC1idG4gKixcXG4gIC5uZXh0LWJ0biAqOmJlZm9yZSxcXG4gIC5uZXh0LWJ0biAqOmFmdGVyIHtcXG4gICAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH1cXG4gIC5uZXh0LWJ0bjo6LW1vei1mb2N1cy1pbm5lciB7XFxuICAgIGJvcmRlcjogMDtcXG4gICAgcGFkZGluZzogMDsgfVxcbiAgLm5leHQtYnRuLCAubmV4dC1idG46YWN0aXZlLCAubmV4dC1idG46Zm9jdXMsIC5uZXh0LWJ0bjpob3ZlciB7XFxuICAgIG91dGxpbmU6IDA7IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgbG9hZGluZ0NpcmNsZSB7XFxuICAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogNTAlIDUwJTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpOyB9XFxuICAxMDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIGxvYWRpbmdDaXJjbGUge1xcbiAgMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XFxuICAgICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogNTAlIDUwJTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfVxcbiAgMTAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogNTAlIDUwJTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfSB9XFxuXFxuLm5leHQtYnRuIHtcXG4gIC8qIOWwuuWvuOe7tOW6piAqL1xcbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcbiAgLyog5pmu6YCa5oyJ6ZKuICovXFxuICAvKiDmma7pgJrmgIHnpoHnlKjmoLflvI8gKi9cXG4gIC8qIOitpuWRiuaMiemSriAqL1xcbiAgLyog5paH5pys5oyJ6ZKuICovXFxuICAvKiBsb2FkaW5nICovXFxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuICAvKiDlub3ngbXmjInpkq4gKi9cXG4gIC8qIOe7hOWQiCAqL1xcbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqLyB9XFxuICAubmV4dC1idG4ge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiBub25lO1xcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IG5vbmU7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgLjNzIGVhc2Utb3V0O1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgLjNzIGVhc2Utb3V0O1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7IH1cXG4gICAgLm5leHQtYnRuOmFmdGVyIHtcXG4gICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgIG9wYWNpdHk6IDA7XFxuICAgICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAuNXMgZWFzZTtcXG4gICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IC41cyBlYXNlOyB9XFxuICAgIC5uZXh0LWJ0biAubmV4dC1pY29uLm5leHQteHM6YmVmb3JlIHtcXG4gICAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7IH1cXG4gICAgLm5leHQtYnRuLmhvdmVyLCAubmV4dC1idG46aG92ZXIge1xcbiAgICAgIC13ZWJraXQtYm94LXNoYWRvdzogbm9uZTtcXG4gICAgICAgICAgICAgIGJveC1zaGFkb3c6IG5vbmU7IH1cXG4gIC5uZXh0LWJ0bi5uZXh0LXNtYWxsIHtcXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgICBwYWRkaW5nOiAwIDhweDtcXG4gICAgaGVpZ2h0OiAyMHB4O1xcbiAgICBsaW5lLWhlaWdodDogMThweDtcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICBib3JkZXItd2lkdGg6IDFweDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1zbWFsbCA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdCB7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gICAgICAubmV4dC1idG4ubmV4dC1zbWFsbCA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdDpiZWZvcmUge1xcbiAgICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1zbWFsbCA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0IHtcXG4gICAgICBtYXJnaW4tbGVmdDogNHB4O1xcbiAgICAgIG1hcmdpbi1yaWdodDogMDsgfVxcbiAgICAgIC5uZXh0LWJ0bi5uZXh0LXNtYWxsID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Q6YmVmb3JlIHtcXG4gICAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtc21hbGwgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tYWxvbmU6YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTJweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtc21hbGwubmV4dC1idG4tbG9hZGluZyB7XFxuICAgICAgcGFkZGluZy1sZWZ0OiAyNHB4OyB9XFxuICAgICAgLm5leHQtYnRuLm5leHQtc21hbGwubmV4dC1idG4tbG9hZGluZzphZnRlciB7XFxuICAgICAgICB3aWR0aDogMTJweDtcXG4gICAgICAgIGhlaWdodDogMTJweDtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxMnB4O1xcbiAgICAgICAgbGVmdDogOHB4O1xcbiAgICAgICAgdG9wOiA1MCU7XFxuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgICAgICBtYXJnaW4tdG9wOiAtNnB4O1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gICAgICAubmV4dC1idG4ubmV4dC1zbWFsbC5uZXh0LWJ0bi1sb2FkaW5nID4gLm5leHQtaWNvbiB7XFxuICAgICAgICBkaXNwbGF5OiBub25lOyB9XFxuICAubmV4dC1idG4ubmV4dC1tZWRpdW0ge1xcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICAgIHBhZGRpbmc6IDAgMTJweDtcXG4gICAgaGVpZ2h0OiAyOHB4O1xcbiAgICBsaW5lLWhlaWdodDogMjZweDtcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICBib3JkZXItd2lkdGg6IDFweDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1tZWRpdW0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Qge1xcbiAgICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICAgIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuICAgICAgLm5leHQtYnRuLm5leHQtbWVkaXVtID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0OmJlZm9yZSB7XFxuICAgICAgICB3aWR0aDogMTJweDtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LW1lZGl1bSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0IHtcXG4gICAgICBtYXJnaW4tbGVmdDogNHB4O1xcbiAgICAgIG1hcmdpbi1yaWdodDogMDsgfVxcbiAgICAgIC5uZXh0LWJ0bi5uZXh0LW1lZGl1bSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0OmJlZm9yZSB7XFxuICAgICAgICB3aWR0aDogMTJweDtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LW1lZGl1bSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1hbG9uZTpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1tZWRpdW0ubmV4dC1idG4tbG9hZGluZyB7XFxuICAgICAgcGFkZGluZy1sZWZ0OiAyOHB4OyB9XFxuICAgICAgLm5leHQtYnRuLm5leHQtbWVkaXVtLm5leHQtYnRuLWxvYWRpbmc6YWZ0ZXIge1xcbiAgICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgICBoZWlnaHQ6IDEycHg7XFxuICAgICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgICBsaW5lLWhlaWdodDogMTJweDtcXG4gICAgICAgIGxlZnQ6IDEycHg7XFxuICAgICAgICB0b3A6IDUwJTtcXG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgIG1hcmdpbi10b3A6IC02cHg7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgICAgIC5uZXh0LWJ0bi5uZXh0LW1lZGl1bS5uZXh0LWJ0bi1sb2FkaW5nID4gLm5leHQtaWNvbiB7XFxuICAgICAgICBkaXNwbGF5OiBub25lOyB9XFxuICAubmV4dC1idG4ubmV4dC1sYXJnZSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gICAgcGFkZGluZzogMCAxNnB4O1xcbiAgICBoZWlnaHQ6IDQwcHg7XFxuICAgIGxpbmUtaGVpZ2h0OiAzOHB4O1xcbiAgICBmb250LXNpemU6IDE2cHg7XFxuICAgIGJvcmRlci13aWR0aDogMXB4OyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LWxhcmdlID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0IHtcXG4gICAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgICAgIC5uZXh0LWJ0bi5uZXh0LWxhcmdlID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0OmJlZm9yZSB7XFxuICAgICAgICB3aWR0aDogMTZweDtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LWxhcmdlID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Qge1xcbiAgICAgIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAwOyB9XFxuICAgICAgLm5leHQtYnRuLm5leHQtbGFyZ2UgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdDpiZWZvcmUge1xcbiAgICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1sYXJnZSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1hbG9uZTpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1sYXJnZS5uZXh0LWJ0bi1sb2FkaW5nIHtcXG4gICAgICBwYWRkaW5nLWxlZnQ6IDM2cHg7IH1cXG4gICAgICAubmV4dC1idG4ubmV4dC1sYXJnZS5uZXh0LWJ0bi1sb2FkaW5nOmFmdGVyIHtcXG4gICAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgICAgaGVpZ2h0OiAxNnB4O1xcbiAgICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IDE2cHg7XFxuICAgICAgICBsZWZ0OiAxNnB4O1xcbiAgICAgICAgdG9wOiA1MCU7XFxuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgICAgICBtYXJnaW4tdG9wOiAtOHB4O1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gICAgICAubmV4dC1idG4ubmV4dC1sYXJnZS5uZXh0LWJ0bi1sb2FkaW5nID4gLm5leHQtaWNvbiB7XFxuICAgICAgICBkaXNwbGF5OiBub25lOyB9XFxuICAubmV4dC1idG4ubmV4dC1idG4tbm9ybWFsIHtcXG4gICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRjtcXG4gICAgYm9yZGVyLWNvbG9yOiAjQzRDNkNGOyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LWJ0bi1ub3JtYWwsIC5uZXh0LWJ0bi5uZXh0LWJ0bi1ub3JtYWw6bGluaywgLm5leHQtYnRuLm5leHQtYnRuLW5vcm1hbDp2aXNpdGVkLCAubmV4dC1idG4ubmV4dC1idG4tbm9ybWFsLnZpc2l0ZWQge1xcbiAgICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LWJ0bi1ub3JtYWw6Zm9jdXMsIC5uZXh0LWJ0bi5uZXh0LWJ0bi1ub3JtYWw6aG92ZXIsIC5uZXh0LWJ0bi5uZXh0LWJ0bi1ub3JtYWwuaG92ZXIsIC5uZXh0LWJ0bi5uZXh0LWJ0bi1ub3JtYWw6YWN0aXZlLCAubmV4dC1idG4ubmV4dC1idG4tbm9ybWFsLmFjdGl2ZSB7XFxuICAgICAgY29sb3I6ICMzMzMzMzM7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0YyRjNGNztcXG4gICAgICBib3JkZXItY29sb3I6ICNBMEEyQUQ7XFxuICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuICAubmV4dC1idG4ubmV4dC1idG4tcHJpbWFyeSB7XFxuICAgIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM1NTg0RkY7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtYnRuLXByaW1hcnksIC5uZXh0LWJ0bi5uZXh0LWJ0bi1wcmltYXJ5OmxpbmssIC5uZXh0LWJ0bi5uZXh0LWJ0bi1wcmltYXJ5OnZpc2l0ZWQsIC5uZXh0LWJ0bi5uZXh0LWJ0bi1wcmltYXJ5LnZpc2l0ZWQge1xcbiAgICAgIGNvbG9yOiAjRkZGRkZGOyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LWJ0bi1wcmltYXJ5OmZvY3VzLCAubmV4dC1idG4ubmV4dC1idG4tcHJpbWFyeTpob3ZlciwgLm5leHQtYnRuLm5leHQtYnRuLXByaW1hcnkuaG92ZXIsIC5uZXh0LWJ0bi5uZXh0LWJ0bi1wcmltYXJ5OmFjdGl2ZSwgLm5leHQtYnRuLm5leHQtYnRuLXByaW1hcnkuYWN0aXZlIHtcXG4gICAgICBjb2xvcjogI0ZGRkZGRjtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjM0U3MUY3O1xcbiAgICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuICAubmV4dC1idG4ubmV4dC1idG4tc2Vjb25kYXJ5IHtcXG4gICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRjtcXG4gICAgYm9yZGVyLWNvbG9yOiAjNTU4NEZGOyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LWJ0bi1zZWNvbmRhcnksIC5uZXh0LWJ0bi5uZXh0LWJ0bi1zZWNvbmRhcnk6bGluaywgLm5leHQtYnRuLm5leHQtYnRuLXNlY29uZGFyeTp2aXNpdGVkLCAubmV4dC1idG4ubmV4dC1idG4tc2Vjb25kYXJ5LnZpc2l0ZWQge1xcbiAgICAgIGNvbG9yOiAjNTU4NEZGOyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LWJ0bi1zZWNvbmRhcnk6Zm9jdXMsIC5uZXh0LWJ0bi5uZXh0LWJ0bi1zZWNvbmRhcnk6aG92ZXIsIC5uZXh0LWJ0bi5uZXh0LWJ0bi1zZWNvbmRhcnkuaG92ZXIsIC5uZXh0LWJ0bi5uZXh0LWJ0bi1zZWNvbmRhcnk6YWN0aXZlLCAubmV4dC1idG4ubmV4dC1idG4tc2Vjb25kYXJ5LmFjdGl2ZSB7XFxuICAgICAgY29sb3I6ICNGRkZGRkY7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzNFNzFGNztcXG4gICAgICBib3JkZXItY29sb3I6ICMzRTcxRjc7XFxuICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuICAubmV4dC1idG4uZGlzYWJsZWQsIC5uZXh0LWJ0bltkaXNhYmxlZF0ge1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGOEZBO1xcbiAgICBib3JkZXItY29sb3I6ICNFNkU3RUI7IH1cXG4gICAgLm5leHQtYnRuLmRpc2FibGVkLCAubmV4dC1idG4uZGlzYWJsZWQ6bGluaywgLm5leHQtYnRuLmRpc2FibGVkOnZpc2l0ZWQsIC5uZXh0LWJ0bi5kaXNhYmxlZC52aXNpdGVkLCAubmV4dC1idG5bZGlzYWJsZWRdLCAubmV4dC1idG5bZGlzYWJsZWRdOmxpbmssIC5uZXh0LWJ0bltkaXNhYmxlZF06dmlzaXRlZCwgLm5leHQtYnRuW2Rpc2FibGVkXS52aXNpdGVkIHtcXG4gICAgICBjb2xvcjogI0NDQ0NDQzsgfVxcbiAgICAubmV4dC1idG4uZGlzYWJsZWQ6Zm9jdXMsIC5uZXh0LWJ0bi5kaXNhYmxlZDpob3ZlciwgLm5leHQtYnRuLmRpc2FibGVkLmhvdmVyLCAubmV4dC1idG4uZGlzYWJsZWQ6YWN0aXZlLCAubmV4dC1idG4uZGlzYWJsZWQuYWN0aXZlLCAubmV4dC1idG5bZGlzYWJsZWRdOmZvY3VzLCAubmV4dC1idG5bZGlzYWJsZWRdOmhvdmVyLCAubmV4dC1idG5bZGlzYWJsZWRdLmhvdmVyLCAubmV4dC1idG5bZGlzYWJsZWRdOmFjdGl2ZSwgLm5leHQtYnRuW2Rpc2FibGVkXS5hY3RpdmUge1xcbiAgICAgIGNvbG9yOiAjQ0NDQ0NDO1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y4RkE7XFxuICAgICAgYm9yZGVyLWNvbG9yOiAjRTZFN0VCO1xcbiAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbiAgLm5leHQtYnRuLXdhcm5pbmcge1xcbiAgICBib3JkZXItc3R5bGU6IHNvbGlkOyB9XFxuICAgIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnkge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNGRjMwMDA7XFxuICAgICAgYm9yZGVyLWNvbG9yOiAjRkYzMDAwOyB9XFxuICAgICAgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeSwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeTpsaW5rLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5OnZpc2l0ZWQsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnkudmlzaXRlZCB7XFxuICAgICAgICBjb2xvcjogI0ZGRkZGRjsgfVxcbiAgICAgIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnk6Zm9jdXMsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnk6aG92ZXIsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnkuaG92ZXIsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnk6YWN0aXZlLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5LmFjdGl2ZSB7XFxuICAgICAgICBjb2xvcjogI0ZGRkZGRjtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNFNzJCMDA7XFxuICAgICAgICBib3JkZXItY29sb3I6ICNFNzJCMDA7XFxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG4gICAgICAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5LmRpc2FibGVkLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5W2Rpc2FibGVkXSB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGOEZBO1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiAjRENERUUzOyB9XFxuICAgICAgICAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5LmRpc2FibGVkLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5LmRpc2FibGVkOmxpbmssIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnkuZGlzYWJsZWQ6dmlzaXRlZCwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeS5kaXNhYmxlZC52aXNpdGVkLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5W2Rpc2FibGVkXSwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeVtkaXNhYmxlZF06bGluaywgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeVtkaXNhYmxlZF06dmlzaXRlZCwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeVtkaXNhYmxlZF0udmlzaXRlZCB7XFxuICAgICAgICAgIGNvbG9yOiAjQ0NDQ0NDOyB9XFxuICAgICAgICAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5LmRpc2FibGVkOmZvY3VzLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5LmRpc2FibGVkOmhvdmVyLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5LmRpc2FibGVkLmhvdmVyLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5LmRpc2FibGVkOmFjdGl2ZSwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeS5kaXNhYmxlZC5hY3RpdmUsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnlbZGlzYWJsZWRdOmZvY3VzLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5W2Rpc2FibGVkXTpob3ZlciwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeVtkaXNhYmxlZF0uaG92ZXIsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnlbZGlzYWJsZWRdOmFjdGl2ZSwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeVtkaXNhYmxlZF0uYWN0aXZlIHtcXG4gICAgICAgICAgY29sb3I6ICNDQ0NDQ0M7XFxuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y4RkE7XFxuICAgICAgICAgIGJvcmRlci1jb2xvcjogI0RDREVFMztcXG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuICAgIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbCB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRjtcXG4gICAgICBib3JkZXItY29sb3I6ICNGRjMwMDA7IH1cXG4gICAgICAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWwsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbDpsaW5rLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWw6dmlzaXRlZCwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsLnZpc2l0ZWQge1xcbiAgICAgICAgY29sb3I6ICNGRjMwMDA7IH1cXG4gICAgICAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWw6Zm9jdXMsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbDpob3ZlciwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsLmhvdmVyLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWw6YWN0aXZlLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWwuYWN0aXZlIHtcXG4gICAgICAgIGNvbG9yOiAjRkZGRkZGO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0U3MkIwMDtcXG4gICAgICAgIGJvcmRlci1jb2xvcjogI0U3MkIwMDtcXG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbiAgICAgIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbC5kaXNhYmxlZCwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsW2Rpc2FibGVkXSB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGOEZBO1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiAjRTZFN0VCOyB9XFxuICAgICAgICAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWwuZGlzYWJsZWQsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbC5kaXNhYmxlZDpsaW5rLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWwuZGlzYWJsZWQ6dmlzaXRlZCwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsLmRpc2FibGVkLnZpc2l0ZWQsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbFtkaXNhYmxlZF0sIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbFtkaXNhYmxlZF06bGluaywgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsW2Rpc2FibGVkXTp2aXNpdGVkLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWxbZGlzYWJsZWRdLnZpc2l0ZWQge1xcbiAgICAgICAgICBjb2xvcjogI0NDQ0NDQzsgfVxcbiAgICAgICAgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsLmRpc2FibGVkOmZvY3VzLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWwuZGlzYWJsZWQ6aG92ZXIsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbC5kaXNhYmxlZC5ob3ZlciwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsLmRpc2FibGVkOmFjdGl2ZSwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsLmRpc2FibGVkLmFjdGl2ZSwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsW2Rpc2FibGVkXTpmb2N1cywgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsW2Rpc2FibGVkXTpob3ZlciwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsW2Rpc2FibGVkXS5ob3ZlciwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsW2Rpc2FibGVkXTphY3RpdmUsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbFtkaXNhYmxlZF0uYWN0aXZlIHtcXG4gICAgICAgICAgY29sb3I6ICNDQ0NDQ0M7XFxuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y4RkE7XFxuICAgICAgICAgIGJvcmRlci1jb2xvcjogI0U2RTdFQjtcXG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuICAubmV4dC1idG4tdGV4dCB7XFxuICAgIC13ZWJraXQtYm94LXNoYWRvdzogbm9uZTtcXG4gICAgICAgICAgICBib3gtc2hhZG93OiBub25lO1xcbiAgICBib3JkZXItcmFkaXVzOiAwOyB9XFxuICAgIC5uZXh0LWJ0bi10ZXh0LmhvdmVyLCAubmV4dC1idG4tdGV4dDpob3ZlciB7XFxuICAgICAgLXdlYmtpdC1ib3gtc2hhZG93OiBub25lO1xcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogbm9uZTsgfVxcbiAgICAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1wcmltYXJ5IHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1idG4tcHJpbWFyeSwgLm5leHQtYnRuLXRleHQubmV4dC1idG4tcHJpbWFyeTpsaW5rLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1wcmltYXJ5OnZpc2l0ZWQsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXByaW1hcnkudmlzaXRlZCB7XFxuICAgICAgICBjb2xvcjogIzU1ODRGRjsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXByaW1hcnk6Zm9jdXMsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXByaW1hcnk6aG92ZXIsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXByaW1hcnkuaG92ZXIsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXByaW1hcnk6YWN0aXZlLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1wcmltYXJ5LmFjdGl2ZSB7XFxuICAgICAgICBjb2xvcjogIzNFNzFGNztcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbiAgICAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1zZWNvbmRhcnkge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1zZWNvbmRhcnksIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXNlY29uZGFyeTpsaW5rLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1zZWNvbmRhcnk6dmlzaXRlZCwgLm5leHQtYnRuLXRleHQubmV4dC1idG4tc2Vjb25kYXJ5LnZpc2l0ZWQge1xcbiAgICAgICAgY29sb3I6ICM2NjY2NjY7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1zZWNvbmRhcnk6Zm9jdXMsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXNlY29uZGFyeTpob3ZlciwgLm5leHQtYnRuLXRleHQubmV4dC1idG4tc2Vjb25kYXJ5LmhvdmVyLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1zZWNvbmRhcnk6YWN0aXZlLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1zZWNvbmRhcnkuYWN0aXZlIHtcXG4gICAgICAgIGNvbG9yOiAjNTU4NEZGO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLW5vcm1hbCB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLW5vcm1hbCwgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbm9ybWFsOmxpbmssIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLW5vcm1hbDp2aXNpdGVkLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1ub3JtYWwudmlzaXRlZCB7XFxuICAgICAgICBjb2xvcjogIzMzMzMzMzsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLW5vcm1hbDpmb2N1cywgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbm9ybWFsOmhvdmVyLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1ub3JtYWwuaG92ZXIsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLW5vcm1hbDphY3RpdmUsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLW5vcm1hbC5hY3RpdmUge1xcbiAgICAgICAgY29sb3I6ICM1NTg0RkY7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG4gICAgLm5leHQtYnRuLXRleHQubmV4dC1sYXJnZSB7XFxuICAgICAgYm9yZGVyLXJhZGl1czogMDtcXG4gICAgICBwYWRkaW5nOiAwIDA7XFxuICAgICAgaGVpZ2h0OiAyNHB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiAyNHB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgICBib3JkZXItd2lkdGg6IDA7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LWxhcmdlID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0IHtcXG4gICAgICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtbGFyZ2UgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Q6YmVmb3JlIHtcXG4gICAgICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LWxhcmdlID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Qge1xcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogMDsgfVxcbiAgICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1sYXJnZSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0OmJlZm9yZSB7XFxuICAgICAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1sYXJnZSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1hbG9uZTpiZWZvcmUge1xcbiAgICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtbGFyZ2UubmV4dC1idG4tbG9hZGluZyB7XFxuICAgICAgICBwYWRkaW5nLWxlZnQ6IDIwcHg7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtbGFyZ2UubmV4dC1idG4tbG9hZGluZzphZnRlciB7XFxuICAgICAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgICAgICBoZWlnaHQ6IDE2cHg7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IDE2cHg7XFxuICAgICAgICAgIGxlZnQ6IDA7XFxuICAgICAgICAgIHRvcDogNTAlO1xcbiAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgICAgICAgIG1hcmdpbi10b3A6IC04cHg7XFxuICAgICAgICAgIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuICAgICAgICAubmV4dC1idG4tdGV4dC5uZXh0LWxhcmdlLm5leHQtYnRuLWxvYWRpbmcgPiAubmV4dC1pY29uIHtcXG4gICAgICAgICAgZGlzcGxheTogbm9uZTsgfVxcbiAgICAubmV4dC1idG4tdGV4dC5uZXh0LW1lZGl1bSB7XFxuICAgICAgYm9yZGVyLXJhZGl1czogMDtcXG4gICAgICBwYWRkaW5nOiAwIDA7XFxuICAgICAgaGVpZ2h0OiAyMHB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBib3JkZXItd2lkdGg6IDA7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LW1lZGl1bSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdCB7XFxuICAgICAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuICAgICAgICAubmV4dC1idG4tdGV4dC5uZXh0LW1lZGl1bSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdDpiZWZvcmUge1xcbiAgICAgICAgICB3aWR0aDogMTJweDtcXG4gICAgICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtbWVkaXVtID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Qge1xcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogMDsgfVxcbiAgICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1tZWRpdW0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdDpiZWZvcmUge1xcbiAgICAgICAgICB3aWR0aDogMTJweDtcXG4gICAgICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtbWVkaXVtID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWFsb25lOmJlZm9yZSB7XFxuICAgICAgICB3aWR0aDogMTJweDtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1tZWRpdW0ubmV4dC1idG4tbG9hZGluZyB7XFxuICAgICAgICBwYWRkaW5nLWxlZnQ6IDE2cHg7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtbWVkaXVtLm5leHQtYnRuLWxvYWRpbmc6YWZ0ZXIge1xcbiAgICAgICAgICB3aWR0aDogMTJweDtcXG4gICAgICAgICAgaGVpZ2h0OiAxMnB4O1xcbiAgICAgICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxMnB4O1xcbiAgICAgICAgICBsZWZ0OiAwO1xcbiAgICAgICAgICB0b3A6IDUwJTtcXG4gICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICAgICAgICBtYXJnaW4tdG9wOiAtNnB4O1xcbiAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1tZWRpdW0ubmV4dC1idG4tbG9hZGluZyA+IC5uZXh0LWljb24ge1xcbiAgICAgICAgICBkaXNwbGF5OiBub25lOyB9XFxuICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtc21hbGwge1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDA7XFxuICAgICAgcGFkZGluZzogMCAwO1xcbiAgICAgIGhlaWdodDogMTZweDtcXG4gICAgICBsaW5lLWhlaWdodDogMTZweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgYm9yZGVyLXdpZHRoOiAwOyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1zbWFsbCA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdCB7XFxuICAgICAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuICAgICAgICAubmV4dC1idG4tdGV4dC5uZXh0LXNtYWxsID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0OmJlZm9yZSB7XFxuICAgICAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1zbWFsbCA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0IHtcXG4gICAgICAgIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtc21hbGwgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdDpiZWZvcmUge1xcbiAgICAgICAgICB3aWR0aDogMTJweDtcXG4gICAgICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtc21hbGwgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tYWxvbmU6YmVmb3JlIHtcXG4gICAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LXNtYWxsLm5leHQtYnRuLWxvYWRpbmcge1xcbiAgICAgICAgcGFkZGluZy1sZWZ0OiAxNnB4OyB9XFxuICAgICAgICAubmV4dC1idG4tdGV4dC5uZXh0LXNtYWxsLm5leHQtYnRuLWxvYWRpbmc6YWZ0ZXIge1xcbiAgICAgICAgICB3aWR0aDogMTJweDtcXG4gICAgICAgICAgaGVpZ2h0OiAxMnB4O1xcbiAgICAgICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxMnB4O1xcbiAgICAgICAgICBsZWZ0OiAwO1xcbiAgICAgICAgICB0b3A6IDUwJTtcXG4gICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICAgICAgICBtYXJnaW4tdG9wOiAtNnB4O1xcbiAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1zbWFsbC5uZXh0LWJ0bi1sb2FkaW5nID4gLm5leHQtaWNvbiB7XFxuICAgICAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gICAgLm5leHQtYnRuLXRleHQuZGlzYWJsZWQsIC5uZXh0LWJ0bi10ZXh0W2Rpc2FibGVkXSB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0LmRpc2FibGVkLCAubmV4dC1idG4tdGV4dC5kaXNhYmxlZDpsaW5rLCAubmV4dC1idG4tdGV4dC5kaXNhYmxlZDp2aXNpdGVkLCAubmV4dC1idG4tdGV4dC5kaXNhYmxlZC52aXNpdGVkLCAubmV4dC1idG4tdGV4dFtkaXNhYmxlZF0sIC5uZXh0LWJ0bi10ZXh0W2Rpc2FibGVkXTpsaW5rLCAubmV4dC1idG4tdGV4dFtkaXNhYmxlZF06dmlzaXRlZCwgLm5leHQtYnRuLXRleHRbZGlzYWJsZWRdLnZpc2l0ZWQge1xcbiAgICAgICAgY29sb3I6ICNDQ0NDQ0M7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5kaXNhYmxlZDpmb2N1cywgLm5leHQtYnRuLXRleHQuZGlzYWJsZWQ6aG92ZXIsIC5uZXh0LWJ0bi10ZXh0LmRpc2FibGVkLmhvdmVyLCAubmV4dC1idG4tdGV4dC5kaXNhYmxlZDphY3RpdmUsIC5uZXh0LWJ0bi10ZXh0LmRpc2FibGVkLmFjdGl2ZSwgLm5leHQtYnRuLXRleHRbZGlzYWJsZWRdOmZvY3VzLCAubmV4dC1idG4tdGV4dFtkaXNhYmxlZF06aG92ZXIsIC5uZXh0LWJ0bi10ZXh0W2Rpc2FibGVkXS5ob3ZlciwgLm5leHQtYnRuLXRleHRbZGlzYWJsZWRdOmFjdGl2ZSwgLm5leHQtYnRuLXRleHRbZGlzYWJsZWRdLmFjdGl2ZSB7XFxuICAgICAgICBjb2xvcjogI0NDQ0NDQztcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbiAgICAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1sb2FkaW5nIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbG9hZGluZywgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbG9hZGluZzpsaW5rLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1sb2FkaW5nOnZpc2l0ZWQsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLWxvYWRpbmcudmlzaXRlZCB7XFxuICAgICAgICBjb2xvcjogIzMzMzMzMzsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLWxvYWRpbmc6Zm9jdXMsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLWxvYWRpbmc6aG92ZXIsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLWxvYWRpbmcuaG92ZXIsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLWxvYWRpbmc6YWN0aXZlLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1sb2FkaW5nLmFjdGl2ZSB7XFxuICAgICAgICBjb2xvcjogIzMzMzMzMztcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbiAgLm5leHQtYnRuLWxvYWRpbmcge1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTsgfVxcbiAgICAubmV4dC1idG4tbG9hZGluZzphZnRlciB7XFxuICAgICAgZm9udC1mYW1pbHk6IE5leHRJY29uO1xcbiAgICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTY0NlxcXCI7XFxuICAgICAgb3BhY2l0eTogMTtcXG4gICAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcbiAgICAgIC13ZWJraXQtYW5pbWF0aW9uOiBsb2FkaW5nQ2lyY2xlIDJzIGluZmluaXRlIGxpbmVhcjtcXG4gICAgICAgICAgICAgIGFuaW1hdGlvbjogbG9hZGluZ0NpcmNsZSAycyBpbmZpbml0ZSBsaW5lYXI7IH1cXG4gIC5uZXh0LWJ0bi1naG9zdCB7XFxuICAgIC13ZWJraXQtYm94LXNoYWRvdzogbm9uZTtcXG4gICAgICAgICAgICBib3gtc2hhZG93OiBub25lO1xcbiAgICBib3JkZXItc3R5bGU6IHNvbGlkOyB9XFxuICAgIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICBib3JkZXItY29sb3I6ICNGRkZGRkY7IH1cXG4gICAgICAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyaywgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcms6bGluaywgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcms6dmlzaXRlZCwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmsudmlzaXRlZCB7XFxuICAgICAgICBjb2xvcjogI0ZGRkZGRjsgfVxcbiAgICAgIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrOmZvY3VzLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyazpob3ZlciwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmsuaG92ZXIsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrOmFjdGl2ZSwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmsuYWN0aXZlIHtcXG4gICAgICAgIGNvbG9yOiAjRkZGRkZGO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiAjRkZGRkZGO1xcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuICAgICAgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmsuZGlzYWJsZWQsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrW2Rpc2FibGVkXSB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgIGJvcmRlci1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjQpOyB9XFxuICAgICAgICAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyay5kaXNhYmxlZCwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmsuZGlzYWJsZWQ6bGluaywgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmsuZGlzYWJsZWQ6dmlzaXRlZCwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmsuZGlzYWJsZWQudmlzaXRlZCwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmtbZGlzYWJsZWRdLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFya1tkaXNhYmxlZF06bGluaywgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmtbZGlzYWJsZWRdOnZpc2l0ZWQsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrW2Rpc2FibGVkXS52aXNpdGVkIHtcXG4gICAgICAgICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC40KTsgfVxcbiAgICAgICAgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmsuZGlzYWJsZWQ6Zm9jdXMsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrLmRpc2FibGVkOmhvdmVyLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyay5kaXNhYmxlZC5ob3ZlciwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmsuZGlzYWJsZWQ6YWN0aXZlLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyay5kaXNhYmxlZC5hY3RpdmUsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrW2Rpc2FibGVkXTpmb2N1cywgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmtbZGlzYWJsZWRdOmhvdmVyLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFya1tkaXNhYmxlZF0uaG92ZXIsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrW2Rpc2FibGVkXTphY3RpdmUsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrW2Rpc2FibGVkXS5hY3RpdmUge1xcbiAgICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjQpO1xcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgICAgYm9yZGVyLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNCk7XFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbiAgICAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgIGJvcmRlci1jb2xvcjogIzMzMzMzMzsgfVxcbiAgICAgIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodCwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0OmxpbmssIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodDp2aXNpdGVkLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQudmlzaXRlZCB7XFxuICAgICAgICBjb2xvcjogIzMzMzMzMzsgfVxcbiAgICAgIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodDpmb2N1cywgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0OmhvdmVyLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQuaG92ZXIsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodDphY3RpdmUsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodC5hY3RpdmUge1xcbiAgICAgICAgY29sb3I6ICM5OTk5OTk7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOTIpO1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiAjMzMzMzMzO1xcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuICAgICAgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0LmRpc2FibGVkLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHRbZGlzYWJsZWRdIHtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMSk7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodC5kaXNhYmxlZCwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0LmRpc2FibGVkOmxpbmssIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodC5kaXNhYmxlZDp2aXNpdGVkLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQuZGlzYWJsZWQudmlzaXRlZCwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0W2Rpc2FibGVkXSwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0W2Rpc2FibGVkXTpsaW5rLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHRbZGlzYWJsZWRdOnZpc2l0ZWQsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodFtkaXNhYmxlZF0udmlzaXRlZCB7XFxuICAgICAgICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMSk7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodC5kaXNhYmxlZDpmb2N1cywgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0LmRpc2FibGVkOmhvdmVyLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQuZGlzYWJsZWQuaG92ZXIsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodC5kaXNhYmxlZDphY3RpdmUsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodC5kaXNhYmxlZC5hY3RpdmUsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodFtkaXNhYmxlZF06Zm9jdXMsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodFtkaXNhYmxlZF06aG92ZXIsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodFtkaXNhYmxlZF0uaG92ZXIsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodFtkaXNhYmxlZF06YWN0aXZlLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHRbZGlzYWJsZWRdLmFjdGl2ZSB7XFxuICAgICAgICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMSk7XFxuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgICBib3JkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4xKTtcXG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuICAubmV4dC1idG4tZ3JvdXAge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgfVxcbiAgICAubmV4dC1idG4tZ3JvdXAgPiAubmV4dC1idG4ge1xcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICBmbG9hdDogbGVmdDtcXG4gICAgICAtd2Via2l0LWJveC1zaGFkb3c6IG5vbmU7XFxuICAgICAgICAgICAgICBib3gtc2hhZG93OiBub25lOyB9XFxuICAgICAgLm5leHQtYnRuLWdyb3VwID4gLm5leHQtYnRuOmhvdmVyLCAubmV4dC1idG4tZ3JvdXAgPiAubmV4dC1idG46Zm9jdXMsIC5uZXh0LWJ0bi1ncm91cCA+IC5uZXh0LWJ0bjphY3RpdmUsIC5uZXh0LWJ0bi1ncm91cCA+IC5uZXh0LWJ0bi5hY3RpdmUge1xcbiAgICAgICAgei1pbmRleDogMTsgfVxcbiAgICAgIC5uZXh0LWJ0bi1ncm91cCA+IC5uZXh0LWJ0bi5kaXNhYmxlZCwgLm5leHQtYnRuLWdyb3VwID4gLm5leHQtYnRuW2Rpc2FibGVkXSB7XFxuICAgICAgICB6LWluZGV4OiAwOyB9XFxuICAgIC5uZXh0LWJ0bi1ncm91cCAubmV4dC1idG4ubmV4dC1idG4ge1xcbiAgICAgIG1hcmdpbjogMCAwIDAgLTFweDsgfVxcbiAgICAubmV4dC1idG4tZ3JvdXAgLm5leHQtYnRuOm5vdCg6Zmlyc3QtY2hpbGQpOm5vdCg6bGFzdC1jaGlsZCkge1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDA7IH1cXG4gICAgLm5leHQtYnRuLWdyb3VwID4gLm5leHQtYnRuOmZpcnN0LWNoaWxkIHtcXG4gICAgICBtYXJnaW46IDA7IH1cXG4gICAgLm5leHQtYnRuLWdyb3VwID4gLm5leHQtYnRuOmZpcnN0LWNoaWxkOm5vdCg6bGFzdC1jaGlsZCkge1xcbiAgICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwO1xcbiAgICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAwOyB9XFxuICAgIC5uZXh0LWJ0bi1ncm91cCA+IC5uZXh0LWJ0bjpsYXN0LWNoaWxkOm5vdCg6Zmlyc3QtY2hpbGQpIHtcXG4gICAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwO1xcbiAgICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDA7IH1cXG4gICAgLm5leHQtYnRuLWdyb3VwID4gLm5leHQtYnRuLXByaW1hcnk6bm90KDpmaXJzdC1jaGlsZCkge1xcbiAgICAgIGJvcmRlci1sZWZ0LWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7IH1cXG4gICAgICAubmV4dC1idG4tZ3JvdXAgPiAubmV4dC1idG4tcHJpbWFyeTpub3QoOmZpcnN0LWNoaWxkKTpob3ZlciB7XFxuICAgICAgICBib3JkZXItbGVmdC1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gICAgICAubmV4dC1idG4tZ3JvdXAgPiAubmV4dC1idG4tcHJpbWFyeTpub3QoOmZpcnN0LWNoaWxkKS5kaXNhYmxlZCwgLm5leHQtYnRuLWdyb3VwID4gLm5leHQtYnRuLXByaW1hcnk6bm90KDpmaXJzdC1jaGlsZClbZGlzYWJsZWRdIHtcXG4gICAgICAgIGJvcmRlci1sZWZ0LWNvbG9yOiAjRTZFN0VCOyB9XFxuXFxuLyog57uE5ZCIICovXFxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcbi5uZXh0LWJ0bi1ncm91cFtkaXI9XFxcInJ0bFxcXCJdID4gLm5leHQtYnRuIHtcXG4gIGZsb2F0OiByaWdodDsgfVxcblxcbi5uZXh0LWJ0bi1ncm91cFtkaXI9XFxcInJ0bFxcXCJdIC5uZXh0LWJ0bi5uZXh0LWJ0biB7XFxuICBtYXJnaW46IDAgLTFweCAwIDA7IH1cXG5cXG4ubmV4dC1idG4tZ3JvdXBbZGlyPVxcXCJydGxcXFwiXSA+IC5uZXh0LWJ0bjpmaXJzdC1jaGlsZDpub3QoOmxhc3QtY2hpbGQpIHtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwOyB9XFxuXFxuLm5leHQtYnRuLWdyb3VwW2Rpcj1cXFwicnRsXFxcIl0gPiAubmV4dC1idG46bGFzdC1jaGlsZDpub3QoOmZpcnN0LWNoaWxkKSB7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMDtcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAwOyB9XFxuXFxuLm5leHQtYnRuLWdyb3VwW2Rpcj1cXFwicnRsXFxcIl0gPiAubmV4dC1idG4tcHJpbWFyeTpub3QoOmZpcnN0LWNoaWxkKSB7XFxuICBib3JkZXItcmlnaHQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTsgfVxcbiAgLm5leHQtYnRuLWdyb3VwW2Rpcj1cXFwicnRsXFxcIl0gPiAubmV4dC1idG4tcHJpbWFyeTpub3QoOmZpcnN0LWNoaWxkKTpob3ZlciB7XFxuICAgIGJvcmRlci1yaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gIC5uZXh0LWJ0bi1ncm91cFtkaXI9XFxcInJ0bFxcXCJdID4gLm5leHQtYnRuLXByaW1hcnk6bm90KDpmaXJzdC1jaGlsZCkuZGlzYWJsZWQsIC5uZXh0LWJ0bi1ncm91cFtkaXI9XFxcInJ0bFxcXCJdID4gLm5leHQtYnRuLXByaW1hcnk6bm90KDpmaXJzdC1jaGlsZClbZGlzYWJsZWRdIHtcXG4gICAgYm9yZGVyLXJpZ2h0LWNvbG9yOiAjRTZFN0VCOyB9XFxuXFxuLyog5bC65a+457u05bqmICovXFxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcbi5uZXh0LWJ0bi5uZXh0LXNtYWxsW2Rpcj1cXFwicnRsXFxcIl0ge1xcbiAgYm9yZGVyLXJhZGl1czogM3B4OyB9XFxuICAubmV4dC1idG4ubmV4dC1zbWFsbFtkaXI9XFxcInJ0bFxcXCJdID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwOyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LXNtYWxsW2Rpcj1cXFwicnRsXFxcIl0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Q6YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTJweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gIC5uZXh0LWJ0bi5uZXh0LXNtYWxsW2Rpcj1cXFwicnRsXFxcIl0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1zbWFsbFtkaXI9XFxcInJ0bFxcXCJdID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Q6YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTJweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gIC5uZXh0LWJ0bi5uZXh0LXNtYWxsW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1idG4tbG9hZGluZyB7XFxuICAgIHBhZGRpbmctbGVmdDogOHB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAyNHB4OyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LXNtYWxsW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1idG4tbG9hZGluZzphZnRlciB7XFxuICAgICAgcmlnaHQ6IDhweDtcXG4gICAgICB0b3A6IDUwJTtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDA7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDRweDsgfVxcblxcbi5uZXh0LWJ0bi5uZXh0LW1lZGl1bVtkaXI9XFxcInJ0bFxcXCJdIHtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDsgfVxcbiAgLm5leHQtYnRuLm5leHQtbWVkaXVtW2Rpcj1cXFwicnRsXFxcIl0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Qge1xcbiAgICBtYXJnaW4tbGVmdDogNHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtbWVkaXVtW2Rpcj1cXFwicnRsXFxcIl0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Q6YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTJweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gIC5uZXh0LWJ0bi5uZXh0LW1lZGl1bVtkaXI9XFxcInJ0bFxcXCJdID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Qge1xcbiAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtbWVkaXVtW2Rpcj1cXFwicnRsXFxcIl0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdDpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgLm5leHQtYnRuLm5leHQtbWVkaXVtW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1idG4tbG9hZGluZyB7XFxuICAgIHBhZGRpbmctbGVmdDogMTJweDtcXG4gICAgcGFkZGluZy1yaWdodDogMjhweDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1tZWRpdW1bZGlyPVxcXCJydGxcXFwiXS5uZXh0LWJ0bi1sb2FkaW5nOmFmdGVyIHtcXG4gICAgICByaWdodDogMTJweDtcXG4gICAgICB0b3A6IDUwJTtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDA7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDRweDsgfVxcblxcbi5uZXh0LWJ0bi5uZXh0LWxhcmdlW2Rpcj1cXFwicnRsXFxcIl0ge1xcbiAgYm9yZGVyLXJhZGl1czogM3B4OyB9XFxuICAubmV4dC1idG4ubmV4dC1sYXJnZVtkaXI9XFxcInJ0bFxcXCJdID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwOyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LWxhcmdlW2Rpcj1cXFwicnRsXFxcIl0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Q6YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTZweDtcXG4gICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gIC5uZXh0LWJ0bi5uZXh0LWxhcmdlW2Rpcj1cXFwicnRsXFxcIl0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1sYXJnZVtkaXI9XFxcInJ0bFxcXCJdID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Q6YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTZweDtcXG4gICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gIC5uZXh0LWJ0bi5uZXh0LWxhcmdlW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1idG4tbG9hZGluZyB7XFxuICAgIHBhZGRpbmctbGVmdDogMTZweDtcXG4gICAgcGFkZGluZy1yaWdodDogMzZweDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1sYXJnZVtkaXI9XFxcInJ0bFxcXCJdLm5leHQtYnRuLWxvYWRpbmc6YWZ0ZXIge1xcbiAgICAgIHJpZ2h0OiAxNnB4O1xcbiAgICAgIHRvcDogNTAlO1xcbiAgICAgIG1hcmdpbi1yaWdodDogMDtcXG4gICAgICBtYXJnaW4tbGVmdDogNHB4OyB9XFxuXFxuLyog5paH5pys5oyJ6ZKuICovXFxuLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LWxhcmdlIHtcXG4gIGJvcmRlci1yYWRpdXM6IDA7IH1cXG4gIC5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1sYXJnZSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICAgIG1hcmdpbi1yaWdodDogMDsgfVxcbiAgICAubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtbGFyZ2UgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Q6YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTZweDtcXG4gICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gIC5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1sYXJnZSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuICAgIC5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1sYXJnZSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0OmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtbGFyZ2UubmV4dC1idG4tbG9hZGluZyB7XFxuICAgIHBhZGRpbmctbGVmdDogMDtcXG4gICAgcGFkZGluZy1yaWdodDogMjBweDsgfVxcbiAgICAubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtbGFyZ2UubmV4dC1idG4tbG9hZGluZzphZnRlciB7XFxuICAgICAgcmlnaHQ6IDA7XFxuICAgICAgdG9wOiA1MCU7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgICAgIG1hcmdpbi1sZWZ0OiA0cHg7IH1cXG5cXG4ubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtbWVkaXVtIHtcXG4gIGJvcmRlci1yYWRpdXM6IDA7IH1cXG4gIC5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1tZWRpdW0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Qge1xcbiAgICBtYXJnaW4tbGVmdDogNHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG4gICAgLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LW1lZGl1bSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdDpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LW1lZGl1bSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuICAgIC5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1tZWRpdW0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdDpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LW1lZGl1bS5uZXh0LWJ0bi1sb2FkaW5nIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAwO1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxNnB4OyB9XFxuICAgIC5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1tZWRpdW0ubmV4dC1idG4tbG9hZGluZzphZnRlciB7XFxuICAgICAgcmlnaHQ6IDA7XFxuICAgICAgdG9wOiA1MCU7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgICAgIG1hcmdpbi1sZWZ0OiA0cHg7IH1cXG5cXG4ubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtc21hbGwge1xcbiAgYm9yZGVyLXJhZGl1czogMDsgfVxcbiAgLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LXNtYWxsID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwOyB9XFxuICAgIC5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1zbWFsbCA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdDpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LXNtYWxsID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Qge1xcbiAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gICAgLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LXNtYWxsID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Q6YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTJweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gIC5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1zbWFsbC5uZXh0LWJ0bi1sb2FkaW5nIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAwO1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxNnB4OyB9XFxuICAgIC5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1zbWFsbC5uZXh0LWJ0bi1sb2FkaW5nOmFmdGVyIHtcXG4gICAgICByaWdodDogMDtcXG4gICAgICB0b3A6IDUwJTtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDA7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDRweDsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlcj8/cmVmLS0yLTEhLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYj8/cmVmLS0yLTIhLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIhLi9zcmMvYnV0dG9uL21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIDEyIDEzIDE0IDE1IDE2IDE3IDE4IDE5IDIwIDIxIDIyIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBjaGFyc2V0IFxcXCJVVEYtOFxcXCI7XFxuLyoqXFxuICog5bC65a+4IOWfuuehgOWwuuWvuFxcbiAqIOWRveWQjeiDveWcqOivreS5ieeahOWJjeaPkOS4i+eugOWNleWwseWwvemHj+eugOWNlSwg6L+Z6YeM5Y+v5Lul5pivIHNpemUtMngsIHNwYWNlLTJ4LCBzaXplLWJhc2UgLi4uXFxuICog5LiN6L+H5Y+v5Lul5Zyo6K+t5LmJ55qE5YmN5o+Q5LiL5YGa55qE5pu057K+566A5LiA5LqbLCDkuo7mmK/nlKjkuoZzMiwgczHnrYlcXG4gKiDlj6/nlKjlj5jph486IGAkczEgLSAkczhgXFxuICogQGV4YW1wbGUgc2NzcyAtIOS9v+eUqFxcbiAqICAgLmVsZW1lbnQge1xcbiAqICAgICBwYWRkaW5nOiAkczEgIWRlZmF1bHQ7XFxuICogICB9XFxuICpcXG4gKiBAZXhhbXBsZSBjc3MgLSBDU1Mg6L6T5Ye6XFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6IDRweCAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKi9cXG4ubmV4dC1vdmVybGF5LXdyYXBwZXIgLm5leHQtb3ZlcmxheS1pbm5lciB7XFxuICB6LWluZGV4OiAxMDAxOyB9XFxuXFxuLm5leHQtb3ZlcmxheS13cmFwcGVyIC5uZXh0LW92ZXJsYXktYmFja2Ryb3Age1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgei1pbmRleDogMTAwMTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGJhY2tncm91bmQ6ICMwMDAwMDA7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgLjNzO1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAuM3M7XFxuICBvcGFjaXR5OiAwOyB9XFxuXFxuLm5leHQtb3ZlcmxheS13cmFwcGVyLm9wZW5lZCAubmV4dC1vdmVybGF5LWJhY2tkcm9wIHtcXG4gIG9wYWNpdHk6IDAuMjsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlcj8/cmVmLS0yLTEhLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYj8/cmVmLS0yLTIhLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIhLi9zcmMvb3ZlcmxheS9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUgNiA3IDggOSAxMCAxMSAxMiAxMyAxNCAxNSAxNiAxNyAxOCAxOSAyMCAyMSAyMiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXI/P3JlZi0tMi0xIS4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWI/P3JlZi0tMi0yIS4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliIS4vc3JjL2Ryb3Bkb3duL21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIDEyIDEzIDE0IDE1IDE2IDE3IDE4IDE5IDIwIDIxIDIyIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBjaGFyc2V0IFxcXCJVVEYtOFxcXCI7XFxuLyoqXFxuICog5bC65a+4IOWfuuehgOWwuuWvuFxcbiAqIOWRveWQjeiDveWcqOivreS5ieeahOWJjeaPkOS4i+eugOWNleWwseWwvemHj+eugOWNlSwg6L+Z6YeM5Y+v5Lul5pivIHNpemUtMngsIHNwYWNlLTJ4LCBzaXplLWJhc2UgLi4uXFxuICog5LiN6L+H5Y+v5Lul5Zyo6K+t5LmJ55qE5YmN5o+Q5LiL5YGa55qE5pu057K+566A5LiA5LqbLCDkuo7mmK/nlKjkuoZzMiwgczHnrYlcXG4gKiDlj6/nlKjlj5jph486IGAkczEgLSAkczhgXFxuICogQGV4YW1wbGUgc2NzcyAtIOS9v+eUqFxcbiAqICAgLmVsZW1lbnQge1xcbiAqICAgICBwYWRkaW5nOiAkczEgIWRlZmF1bHQ7XFxuICogICB9XFxuICpcXG4gKiBAZXhhbXBsZSBjc3MgLSBDU1Mg6L6T5Ye6XFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6IDRweCAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKi9cXG4vKiBwdXQgeW91ciBjb2RlIGhlcmUgKi9cXG4ubmV4dC1sb2FkaW5nIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIC8qIOmBrue9qeWxgiAqL1xcbiAgLyogZm9yIElFOSwxMCAqL1xcbiAgLyogdGV4dCBvbiB0aGUgcmlnaHQgc2lkZSBvZiAqL1xcbiAgLyog5Yqo5pWIICovIH1cXG4gIC5uZXh0LWxvYWRpbmcubmV4dC1vcGVuIHtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7IH1cXG4gIC5uZXh0LWxvYWRpbmcgLm5leHQtbG9hZGluZy1jb21wb25lbnQge1xcbiAgICBvcGFjaXR5OiAuNztcXG4gICAgLXdlYmtpdC1maWx0ZXI6IGJsdXIoMXB4KTtcXG4gICAgZmlsdGVyOiBibHVyKDFweCk7XFxuICAgIC13ZWJraXQtZmlsdGVyOiBcXFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkJsdXIoUGl4ZWxSYWRpdXM9MSwgTWFrZVNoYWRvdz1mYWxzZSlcXFwiO1xcbiAgICAgICAgICAgIGZpbHRlcjogXFxcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5CbHVyKFBpeGVsUmFkaXVzPTEsIE1ha2VTaGFkb3c9ZmFsc2UpXFxcIjtcXG4gICAgLyogSUU2fklFOSAqL1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lOyB9XFxuICAubmV4dC1sb2FkaW5nLW1hc2tlciB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICBib3R0b206IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICB6LWluZGV4OiA5OTtcXG4gICAgb3BhY2l0eTogLjI7XFxuICAgIGJhY2tncm91bmQ6ICNGRkY7IH1cXG4gIC5uZXh0LWxvYWRpbmctdGlwIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiA1MCU7XFxuICAgIGxlZnQ6IDUwJTtcXG4gICAgei1pbmRleDogNDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcXG4gICAgICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyOyB9XFxuICAubmV4dC1sb2FkaW5nLXRpcC1wbGFjZWhvbGRlciB7XFxuICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gIC5uZXh0LWxvYWRpbmctcmlnaHQtdGlwIC5uZXh0LWxvYWRpbmctaW5kaWNhdG9yIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9XFxuICAubmV4dC1sb2FkaW5nLXJpZ2h0LXRpcCAubmV4dC1sb2FkaW5nLXRpcC1jb250ZW50IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgdG9wOiA1MCU7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIC01MCUpO1xcbiAgICAgICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIC01MCUpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIC01MCUpOyB9XFxuICAubmV4dC1sb2FkaW5nLXJpZ2h0LXRpcCAubmV4dC1sb2FkaW5nLXRpcC1wbGFjZWhvbGRlciB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgICBtYXJnaW4tbGVmdDogMWVtOyB9XFxuICAubmV4dC1sb2FkaW5nLWZ1c2lvbi1yZWFjdG9yIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICB3aWR0aDogNDhweDtcXG4gICAgaGVpZ2h0OiA0OHB4O1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDUuNnM7XFxuICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogNS42cztcXG4gICAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiBpbmZpbml0ZTtcXG4gICAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogaW5maW5pdGU7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogbGluZWFyO1xcbiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBsaW5lYXI7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IG5leHRWZWN0b3JSb3V0ZTtcXG4gICAgYW5pbWF0aW9uLW5hbWU6IG5leHRWZWN0b3JSb3V0ZTsgfVxcbiAgICAubmV4dC1sb2FkaW5nLWZ1c2lvbi1yZWFjdG9yIC5uZXh0LWxvYWRpbmctZG90IHtcXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgbWFyZ2luOiBhdXRvO1xcbiAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgIGhlaWdodDogMTJweDtcXG4gICAgICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICAgICAgYmFja2dyb3VuZDogIzU1ODRGRjtcXG4gICAgICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2UtaW4tb3V0O1xcbiAgICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2UtaW4tb3V0O1xcbiAgICAgIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogaW5maW5pdGU7XFxuICAgICAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogaW5maW5pdGU7XFxuICAgICAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDEuNHM7XFxuICAgICAgYW5pbWF0aW9uLWR1cmF0aW9uOiAxLjRzOyB9XFxuICAgICAgLm5leHQtbG9hZGluZy1mdXNpb24tcmVhY3RvciAubmV4dC1sb2FkaW5nLWRvdDpudGgtY2hpbGQoMSkge1xcbiAgICAgICAgdG9wOiAwO1xcbiAgICAgICAgYm90dG9tOiAwO1xcbiAgICAgICAgbGVmdDogMDtcXG4gICAgICAgIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IG5leHRWZWN0b3JEb3RzWDtcXG4gICAgICAgIGFuaW1hdGlvbi1uYW1lOiBuZXh0VmVjdG9yRG90c1g7IH1cXG4gICAgICAubmV4dC1sb2FkaW5nLWZ1c2lvbi1yZWFjdG9yIC5uZXh0LWxvYWRpbmctZG90Om50aC1jaGlsZCgyKSB7XFxuICAgICAgICBsZWZ0OiAwO1xcbiAgICAgICAgcmlnaHQ6IDA7XFxuICAgICAgICB0b3A6IDA7XFxuICAgICAgICBvcGFjaXR5OiAuODtcXG4gICAgICAgIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IG5leHRWZWN0b3JEb3RzWTtcXG4gICAgICAgIGFuaW1hdGlvbi1uYW1lOiBuZXh0VmVjdG9yRG90c1k7IH1cXG4gICAgICAubmV4dC1sb2FkaW5nLWZ1c2lvbi1yZWFjdG9yIC5uZXh0LWxvYWRpbmctZG90Om50aC1jaGlsZCgzKSB7XFxuICAgICAgICB0b3A6IDA7XFxuICAgICAgICBib3R0b206IDA7XFxuICAgICAgICByaWdodDogMDtcXG4gICAgICAgIG9wYWNpdHk6IC42O1xcbiAgICAgICAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogbmV4dFZlY3RvckRvdHNYUjtcXG4gICAgICAgIGFuaW1hdGlvbi1uYW1lOiBuZXh0VmVjdG9yRG90c1hSOyB9XFxuICAgICAgLm5leHQtbG9hZGluZy1mdXNpb24tcmVhY3RvciAubmV4dC1sb2FkaW5nLWRvdDpudGgtY2hpbGQoNCkge1xcbiAgICAgICAgbGVmdDogMDtcXG4gICAgICAgIHJpZ2h0OiAwO1xcbiAgICAgICAgYm90dG9tOiAwO1xcbiAgICAgICAgb3BhY2l0eTogLjI7XFxuICAgICAgICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBuZXh0VmVjdG9yRG90c1lSO1xcbiAgICAgICAgYW5pbWF0aW9uLW5hbWU6IG5leHRWZWN0b3JEb3RzWVI7IH1cXG4gIC5uZXh0LWxvYWRpbmctbWVkaXVtLWZ1c2lvbi1yZWFjdG9yIHtcXG4gICAgd2lkdGg6IDMycHg7XFxuICAgIGhlaWdodDogMzJweDsgfVxcbiAgICAubmV4dC1sb2FkaW5nLW1lZGl1bS1mdXNpb24tcmVhY3RvciAubmV4dC1sb2FkaW5nLWRvdCB7XFxuICAgICAgd2lkdGg6IDhweDtcXG4gICAgICBoZWlnaHQ6IDhweDsgfVxcbiAgICAgIC5uZXh0LWxvYWRpbmctbWVkaXVtLWZ1c2lvbi1yZWFjdG9yIC5uZXh0LWxvYWRpbmctZG90Om50aC1jaGlsZCgxKSB7XFxuICAgICAgICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBuZXh0VmVjdG9yRG90c1gtbWVkaXVtO1xcbiAgICAgICAgYW5pbWF0aW9uLW5hbWU6IG5leHRWZWN0b3JEb3RzWC1tZWRpdW07IH1cXG4gICAgICAubmV4dC1sb2FkaW5nLW1lZGl1bS1mdXNpb24tcmVhY3RvciAubmV4dC1sb2FkaW5nLWRvdDpudGgtY2hpbGQoMikge1xcbiAgICAgICAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogbmV4dFZlY3RvckRvdHNZLW1lZGl1bTtcXG4gICAgICAgIGFuaW1hdGlvbi1uYW1lOiBuZXh0VmVjdG9yRG90c1ktbWVkaXVtOyB9XFxuICAgICAgLm5leHQtbG9hZGluZy1tZWRpdW0tZnVzaW9uLXJlYWN0b3IgLm5leHQtbG9hZGluZy1kb3Q6bnRoLWNoaWxkKDMpIHtcXG4gICAgICAgIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IG5leHRWZWN0b3JEb3RzWFItbWVkaXVtO1xcbiAgICAgICAgYW5pbWF0aW9uLW5hbWU6IG5leHRWZWN0b3JEb3RzWFItbWVkaXVtOyB9XFxuICAgICAgLm5leHQtbG9hZGluZy1tZWRpdW0tZnVzaW9uLXJlYWN0b3IgLm5leHQtbG9hZGluZy1kb3Q6bnRoLWNoaWxkKDQpIHtcXG4gICAgICAgIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IG5leHRWZWN0b3JEb3RzWVItbWVkaXVtO1xcbiAgICAgICAgYW5pbWF0aW9uLW5hbWU6IG5leHRWZWN0b3JEb3RzWVItbWVkaXVtOyB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIG5leHRWZWN0b3JSb3V0ZSB7XFxuICAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7IH1cXG4gIDUlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTsgfVxcbiAgMjUlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTsgfVxcbiAgMzAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTsgfVxcbiAgNTAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTsgfVxcbiAgNTUlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMjcwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMjcwZGVnKTsgfVxcbiAgNzUlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMjcwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMjcwZGVnKTsgfVxcbiAgODAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfVxcbiAgMTAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH0gfVxcblxcbkBrZXlmcmFtZXMgbmV4dFZlY3RvclJvdXRlIHtcXG4gIDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfVxcbiAgNSUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpOyB9XFxuICAyNSUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpOyB9XFxuICAzMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpOyB9XFxuICA1MCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpOyB9XFxuICA1NSUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpOyB9XFxuICA3NSUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpOyB9XFxuICA4MCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpOyB9XFxuICAxMDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfSB9XFxuXFxuLyogMjAlIOeahOaXtumXtOWcqOaXi+i9rCAqL1xcbkAtd2Via2l0LWtleWZyYW1lcyBuZXh0VmVjdG9yRG90c1lSIHtcXG4gIDI1JSB7XFxuICAgIGJvdHRvbTogMDsgfVxcbiAgNDUlLFxcbiAgNTAlIHtcXG4gICAgYm90dG9tOiAxNi44cHg7XFxuICAgIGhlaWdodDogMTQuNHB4O1xcbiAgICB3aWR0aDogMTQuNHB4OyB9XFxuICA5MCUge1xcbiAgICBib3R0b206IDA7XFxuICAgIGhlaWdodDogMTJweDtcXG4gICAgd2lkdGg6IDEycHg7IH0gfVxcblxcbkBrZXlmcmFtZXMgbmV4dFZlY3RvckRvdHNZUiB7XFxuICAyNSUge1xcbiAgICBib3R0b206IDA7IH1cXG4gIDQ1JSxcXG4gIDUwJSB7XFxuICAgIGJvdHRvbTogMTYuOHB4O1xcbiAgICBoZWlnaHQ6IDE0LjRweDtcXG4gICAgd2lkdGg6IDE0LjRweDsgfVxcbiAgOTAlIHtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBoZWlnaHQ6IDEycHg7XFxuICAgIHdpZHRoOiAxMnB4OyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgbmV4dFZlY3RvckRvdHNZIHtcXG4gIDI1JSB7XFxuICAgIHRvcDogMDsgfVxcbiAgNDUlLFxcbiAgNTAlIHtcXG4gICAgdG9wOiAxNi44cHg7XFxuICAgIGhlaWdodDogMTQuNHB4O1xcbiAgICB3aWR0aDogMTQuNHB4OyB9XFxuICA5MCUge1xcbiAgICB0b3A6IDA7XFxuICAgIGhlaWdodDogMTJweDtcXG4gICAgd2lkdGg6IDEycHg7IH0gfVxcblxcbkBrZXlmcmFtZXMgbmV4dFZlY3RvckRvdHNZIHtcXG4gIDI1JSB7XFxuICAgIHRvcDogMDsgfVxcbiAgNDUlLFxcbiAgNTAlIHtcXG4gICAgdG9wOiAxNi44cHg7XFxuICAgIGhlaWdodDogMTQuNHB4O1xcbiAgICB3aWR0aDogMTQuNHB4OyB9XFxuICA5MCUge1xcbiAgICB0b3A6IDA7XFxuICAgIGhlaWdodDogMTJweDtcXG4gICAgd2lkdGg6IDEycHg7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBuZXh0VmVjdG9yRG90c1gge1xcbiAgMjUlIHtcXG4gICAgbGVmdDogMDsgfVxcbiAgNDUlLFxcbiAgNTAlIHtcXG4gICAgbGVmdDogMTYuOHB4O1xcbiAgICB3aWR0aDogMTQuNHB4O1xcbiAgICBoZWlnaHQ6IDE0LjRweDsgfVxcbiAgOTAlIHtcXG4gICAgbGVmdDogMDtcXG4gICAgaGVpZ2h0OiAxMnB4O1xcbiAgICB3aWR0aDogMTJweDsgfSB9XFxuXFxuQGtleWZyYW1lcyBuZXh0VmVjdG9yRG90c1gge1xcbiAgMjUlIHtcXG4gICAgbGVmdDogMDsgfVxcbiAgNDUlLFxcbiAgNTAlIHtcXG4gICAgbGVmdDogMTYuOHB4O1xcbiAgICB3aWR0aDogMTQuNHB4O1xcbiAgICBoZWlnaHQ6IDE0LjRweDsgfVxcbiAgOTAlIHtcXG4gICAgbGVmdDogMDtcXG4gICAgaGVpZ2h0OiAxMnB4O1xcbiAgICB3aWR0aDogMTJweDsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIG5leHRWZWN0b3JEb3RzWFIge1xcbiAgMjUlIHtcXG4gICAgcmlnaHQ6IDA7IH1cXG4gIDQ1JSxcXG4gIDUwJSB7XFxuICAgIHJpZ2h0OiAxNi44cHg7XFxuICAgIHdpZHRoOiAxNC40cHg7XFxuICAgIGhlaWdodDogMTQuNHB4OyB9XFxuICA5MCUge1xcbiAgICByaWdodDogMDtcXG4gICAgaGVpZ2h0OiAxMnB4O1xcbiAgICB3aWR0aDogMTJweDsgfSB9XFxuXFxuQGtleWZyYW1lcyBuZXh0VmVjdG9yRG90c1hSIHtcXG4gIDI1JSB7XFxuICAgIHJpZ2h0OiAwOyB9XFxuICA0NSUsXFxuICA1MCUge1xcbiAgICByaWdodDogMTYuOHB4O1xcbiAgICB3aWR0aDogMTQuNHB4O1xcbiAgICBoZWlnaHQ6IDE0LjRweDsgfVxcbiAgOTAlIHtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGhlaWdodDogMTJweDtcXG4gICAgd2lkdGg6IDEycHg7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBuZXh0VmVjdG9yRG90c1lSLW1lZGl1bSB7XFxuICAyNSUge1xcbiAgICBib3R0b206IDA7IH1cXG4gIDQ1JSxcXG4gIDUwJSB7XFxuICAgIGJvdHRvbTogMTEuMnB4O1xcbiAgICBoZWlnaHQ6IDkuNnB4O1xcbiAgICB3aWR0aDogOS42cHg7IH1cXG4gIDkwJSB7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgaGVpZ2h0OiA4cHg7XFxuICAgIHdpZHRoOiA4cHg7IH0gfVxcblxcbkBrZXlmcmFtZXMgbmV4dFZlY3RvckRvdHNZUi1tZWRpdW0ge1xcbiAgMjUlIHtcXG4gICAgYm90dG9tOiAwOyB9XFxuICA0NSUsXFxuICA1MCUge1xcbiAgICBib3R0b206IDExLjJweDtcXG4gICAgaGVpZ2h0OiA5LjZweDtcXG4gICAgd2lkdGg6IDkuNnB4OyB9XFxuICA5MCUge1xcbiAgICBib3R0b206IDA7XFxuICAgIGhlaWdodDogOHB4O1xcbiAgICB3aWR0aDogOHB4OyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgbmV4dFZlY3RvckRvdHNZLW1lZGl1bSB7XFxuICAyNSUge1xcbiAgICB0b3A6IDA7IH1cXG4gIDQ1JSxcXG4gIDUwJSB7XFxuICAgIHRvcDogMTEuMnB4O1xcbiAgICBoZWlnaHQ6IDkuNnB4O1xcbiAgICB3aWR0aDogOS42cHg7IH1cXG4gIDkwJSB7XFxuICAgIHRvcDogMDtcXG4gICAgaGVpZ2h0OiA4cHg7XFxuICAgIHdpZHRoOiA4cHg7IH0gfVxcblxcbkBrZXlmcmFtZXMgbmV4dFZlY3RvckRvdHNZLW1lZGl1bSB7XFxuICAyNSUge1xcbiAgICB0b3A6IDA7IH1cXG4gIDQ1JSxcXG4gIDUwJSB7XFxuICAgIHRvcDogMTEuMnB4O1xcbiAgICBoZWlnaHQ6IDkuNnB4O1xcbiAgICB3aWR0aDogOS42cHg7IH1cXG4gIDkwJSB7XFxuICAgIHRvcDogMDtcXG4gICAgaGVpZ2h0OiA4cHg7XFxuICAgIHdpZHRoOiA4cHg7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBuZXh0VmVjdG9yRG90c1gtbWVkaXVtIHtcXG4gIDI1JSB7XFxuICAgIGxlZnQ6IDA7IH1cXG4gIDQ1JSxcXG4gIDUwJSB7XFxuICAgIGxlZnQ6IDExLjJweDtcXG4gICAgd2lkdGg6IDkuNnB4O1xcbiAgICBoZWlnaHQ6IDkuNnB4OyB9XFxuICA5MCUge1xcbiAgICBsZWZ0OiAwO1xcbiAgICBoZWlnaHQ6IDhweDtcXG4gICAgd2lkdGg6IDhweDsgfSB9XFxuXFxuQGtleWZyYW1lcyBuZXh0VmVjdG9yRG90c1gtbWVkaXVtIHtcXG4gIDI1JSB7XFxuICAgIGxlZnQ6IDA7IH1cXG4gIDQ1JSxcXG4gIDUwJSB7XFxuICAgIGxlZnQ6IDExLjJweDtcXG4gICAgd2lkdGg6IDkuNnB4O1xcbiAgICBoZWlnaHQ6IDkuNnB4OyB9XFxuICA5MCUge1xcbiAgICBsZWZ0OiAwO1xcbiAgICBoZWlnaHQ6IDhweDtcXG4gICAgd2lkdGg6IDhweDsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIG5leHRWZWN0b3JEb3RzWFItbWVkaXVtIHtcXG4gIDI1JSB7XFxuICAgIHJpZ2h0OiAwOyB9XFxuICA0NSUsXFxuICA1MCUge1xcbiAgICByaWdodDogMTEuMnB4O1xcbiAgICB3aWR0aDogOS42cHg7XFxuICAgIGhlaWdodDogOS42cHg7IH1cXG4gIDkwJSB7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBoZWlnaHQ6IDhweDtcXG4gICAgd2lkdGg6IDhweDsgfSB9XFxuXFxuQGtleWZyYW1lcyBuZXh0VmVjdG9yRG90c1hSLW1lZGl1bSB7XFxuICAyNSUge1xcbiAgICByaWdodDogMDsgfVxcbiAgNDUlLFxcbiAgNTAlIHtcXG4gICAgcmlnaHQ6IDExLjJweDtcXG4gICAgd2lkdGg6IDkuNnB4O1xcbiAgICBoZWlnaHQ6IDkuNnB4OyB9XFxuICA5MCUge1xcbiAgICByaWdodDogMDtcXG4gICAgaGVpZ2h0OiA4cHg7XFxuICAgIHdpZHRoOiA4cHg7IH0gfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlcj8/cmVmLS0yLTEhLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYj8/cmVmLS0yLTIhLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIhLi9zcmMvbG9hZGluZy9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUgNiA3IDggOSAxMCAxMSAxMiAxMyAxNCAxNSAxNiAxNyAxOCAxOSAyMCAyMSAyMiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAY2hhcnNldCBcXFwiVVRGLThcXFwiO1xcbi8qKlxcbiAqIOWwuuWvuCDln7rnoYDlsLrlr7hcXG4gKiDlkb3lkI3og73lnKjor63kuYnnmoTliY3mj5DkuIvnroDljZXlsLHlsL3ph4/nroDljZUsIOi/memHjOWPr+S7peaYryBzaXplLTJ4LCBzcGFjZS0yeCwgc2l6ZS1iYXNlIC4uLlxcbiAqIOS4jei/h+WPr+S7peWcqOivreS5ieeahOWJjeaPkOS4i+WBmueahOabtOeyvueugOS4gOS6mywg5LqO5piv55So5LqGczIsIHMx562JXFxuICog5Y+v55So5Y+Y6YePOiBgJHMxIC0gJHM4YFxcbiAqIEBleGFtcGxlIHNjc3MgLSDkvb/nlKhcXG4gKiAgIC5lbGVtZW50IHtcXG4gKiAgICAgcGFkZGluZzogJHMxICFkZWZhdWx0O1xcbiAqICAgfVxcbiAqXFxuICogQGV4YW1wbGUgY3NzIC0gQ1NTIOi+k+WHulxcbiAqICAgLmVsZW1lbnQge1xcbiAqICAgICBwYWRkaW5nOiA0cHggIWRlZmF1bHQ7XFxuICogICB9XFxuICovXFxuLyogcHV0IHlvdXIgY29kZSBoZXJlICovXFxuLm5leHQtdGFibGUge1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuICAubmV4dC10YWJsZSAqLFxcbiAgLm5leHQtdGFibGUgKjpiZWZvcmUsXFxuICAubmV4dC10YWJsZSAqOmFmdGVyIHtcXG4gICAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH1cXG4gIC5uZXh0LXRhYmxlIHRhYmxlIHtcXG4gICAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG4gICAgYm9yZGVyLXNwYWNpbmc6IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kOiAjRkZGRkZGOyB9XFxuICAgIC5uZXh0LXRhYmxlIHRhYmxlIHRyOmZpcnN0LWNoaWxkIHRkIHtcXG4gICAgICBib3JkZXItdG9wLXdpZHRoOiAwOyB9XFxuICAubmV4dC10YWJsZSB0aCB7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIGJhY2tncm91bmQ6ICNFQkVDRjA7XFxuICAgIGNvbG9yOiAjMzMzMzMzO1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjRENERUUzOyB9XFxuICAgIC5uZXh0LXRhYmxlIHRoIC5uZXh0LXRhYmxlLWNlbGwtd3JhcHBlciB7XFxuICAgICAgcGFkZGluZzogMTJweCAxNnB4O1xcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICAgICAgd29yZC1icmVhazogYnJlYWstYWxsOyB9XFxuICAubmV4dC10YWJsZS1hZmZpeCB7XFxuICAgIHotaW5kZXg6IDE7IH1cXG4gIC5uZXh0LXRhYmxlLWhlYWRlci1yZXNpemFibGUge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG4gICAgLm5leHQtdGFibGUtaGVhZGVyLXJlc2l6YWJsZSAubmV4dC10YWJsZS1yZXNpemUtaGFuZGxlciB7XFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgIHJpZ2h0OiAwO1xcbiAgICAgIHRvcDogMDtcXG4gICAgICBib3R0b206IDA7XFxuICAgICAgd2lkdGg6IDNweDtcXG4gICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gICAgICBjdXJzb3I6IGV3LXJlc2l6ZTsgfVxcbiAgLm5leHQtdGFibGUgdGQge1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjRENERUUzOyB9XFxuICAgIC5uZXh0LXRhYmxlIHRkIC5uZXh0LXRhYmxlLWNlbGwtd3JhcHBlciB7XFxuICAgICAgcGFkZGluZzogMTJweCAxNnB4O1xcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICAgICAgd29yZC1icmVhazogYnJlYWstYWxsOyB9XFxuICAgICAgLm5leHQtdGFibGUgdGQgLm5leHQtdGFibGUtY2VsbC13cmFwcGVyIC5uZXh0LWljb24tYXJyb3ctZG93bi5uZXh0LXRhYmxlLXRyZWUtYXJyb3csXFxuICAgICAgLm5leHQtdGFibGUgdGQgLm5leHQtdGFibGUtY2VsbC13cmFwcGVyIC5uZXh0LWljb24tYXJyb3ctcmlnaHQubmV4dC10YWJsZS10cmVlLWFycm93LFxcbiAgICAgIC5uZXh0LXRhYmxlIHRkIC5uZXh0LXRhYmxlLWNlbGwtd3JhcHBlciAubmV4dC10YWJsZS10cmVlLXBsYWNlaG9sZGVyIHtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogM3B4O1xcbiAgICAgICAgZmxvYXQ6IGxlZnQ7IH1cXG4gICAgICAubmV4dC10YWJsZSB0ZCAubmV4dC10YWJsZS1jZWxsLXdyYXBwZXIgLm5leHQtaWNvbi1hcnJvdy1kb3duLm5leHQtdGFibGUtdHJlZS1hcnJvdzpiZWZvcmUsXFxuICAgICAgLm5leHQtdGFibGUgdGQgLm5leHQtdGFibGUtY2VsbC13cmFwcGVyIC5uZXh0LWljb24tYXJyb3ctcmlnaHQubmV4dC10YWJsZS10cmVlLWFycm93OmJlZm9yZSB7XFxuICAgICAgICB3aWR0aDogMTJweDtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC10YWJsZSAubmV4dC10YWJsZS1leHBhbmRlZCAubmV4dC10YWJsZS1jZWxsLXdyYXBwZXIsXFxuICAubmV4dC10YWJsZSAubmV4dC10YWJsZS1zZWxlY3Rpb24gLm5leHQtdGFibGUtY2VsbC13cmFwcGVyIHtcXG4gICAgb3ZlcmZsb3c6IHZpc2libGU7IH1cXG4gIC5uZXh0LXRhYmxlLm5vLWhlYWRlciB0YWJsZSB0cjpmaXJzdC1jaGlsZCB0ZCB7XFxuICAgIGJvcmRlci10b3Atd2lkdGg6IDFweDsgfVxcbiAgLm5leHQtdGFibGUub25seS1ib3R0b20tYm9yZGVyIHtcXG4gICAgYm9yZGVyLXdpZHRoOiAwOyB9XFxuICAgIC5uZXh0LXRhYmxlLm9ubHktYm90dG9tLWJvcmRlciB0aCB7XFxuICAgICAgYm9yZGVyLXdpZHRoOiAwIDAgMXB4IDA7IH1cXG4gICAgLm5leHQtdGFibGUub25seS1ib3R0b20tYm9yZGVyIHRkIHtcXG4gICAgICBib3JkZXItd2lkdGg6IDAgMCAxcHggMDsgfVxcbiAgICAubmV4dC10YWJsZS5vbmx5LWJvdHRvbS1ib3JkZXIgLm5leHQtdGFibGUtZXhwYW5kZWQtcm93IHRoIHtcXG4gICAgICBib3JkZXItd2lkdGg6IDAgMCAxcHggMDsgfVxcbiAgICAubmV4dC10YWJsZS5vbmx5LWJvdHRvbS1ib3JkZXIgLm5leHQtdGFibGUtZXhwYW5kZWQtcm93IHRkIHtcXG4gICAgICBib3JkZXItd2lkdGg6IDAgMCAxcHggMDsgfVxcbiAgLm5leHQtdGFibGUtbG9hZGluZyB7XFxuICAgIGRpc3BsYXk6IGJsb2NrOyB9XFxuICAubmV4dC10YWJsZS56ZWJyYSB0cjpudGgtY2hpbGQob2RkKSB0ZCB7XFxuICAgIGJhY2tncm91bmQ6ICNGRkZGRkY7IH1cXG4gIC5uZXh0LXRhYmxlLnplYnJhIHRyOm50aC1jaGlsZChldmVuKSB0ZCB7XFxuICAgIGJhY2tncm91bmQ6ICNGN0Y4RkE7IH1cXG4gIC5uZXh0LXRhYmxlLnplYnJhIC5uZXh0LXRhYmxlLXJvdy5ob3ZlcmVkIHRkIHtcXG4gICAgYmFja2dyb3VuZDogI0YyRjNGNztcXG4gICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gIC5uZXh0LXRhYmxlLnplYnJhIC5uZXh0LXRhYmxlLXJvdy5zZWxlY3RlZCB0ZCB7XFxuICAgIGJhY2tncm91bmQ6ICNGMkYzRjc7XFxuICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuICAubmV4dC10YWJsZS1lbXB0eSB7XFxuICAgIGNvbG9yOiAjQTBBMkFEO1xcbiAgICBwYWRkaW5nOiAzMnB4IDA7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjsgfVxcbiAgLm5leHQtdGFibGUtZXhwYW5kZWQtcm93IHRkIHtcXG4gICAgYm9yZGVyLXdpZHRoOiAwOyB9XFxuICAgIC5uZXh0LXRhYmxlLWV4cGFuZGVkLXJvdyB0ZDpmaXJzdC1jaGlsZCB7XFxuICAgICAgYm9yZGVyLWxlZnQtd2lkdGg6IDFweDsgfVxcbiAgICAubmV4dC10YWJsZS1leHBhbmRlZC1yb3cgdGQ6bGFzdC1jaGlsZCB7XFxuICAgICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAxcHg7IH1cXG4gIC5uZXh0LXRhYmxlLWV4cGFuZGVkLXJvdzpsYXN0LWNoaWxkIHRkIHtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMXB4OyB9XFxuICAubmV4dC10YWJsZS1leHBhbmRlZC1yb3cgLm5leHQtdGFibGUgLmxhc3QgdGQge1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAwOyB9XFxuICAubmV4dC10YWJsZS1maWx0ZXItZm9vdGVyIHtcXG4gICAgbWFyZ2luOiAxMHB4IDEwcHggMDsgfVxcbiAgICAubmV4dC10YWJsZS1maWx0ZXItZm9vdGVyIGJ1dHRvbiB7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiA1cHg7IH1cXG4gIC5uZXh0LXRhYmxlLXJvdyB7XFxuICAgIC13ZWJraXQtdHJhbnNpdGlvbjogYWxsIGVhc2UgLjNzO1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgZWFzZSAuM3M7XFxuICAgIGJhY2tncm91bmQ6ICNGRkZGRkY7XFxuICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuICAgIC5uZXh0LXRhYmxlLXJvdy5oaWRkZW4ge1xcbiAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gICAgLm5leHQtdGFibGUtcm93LmhvdmVyZWQge1xcbiAgICAgIGJhY2tncm91bmQ6ICNGMkYzRjc7XFxuICAgICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gICAgLm5leHQtdGFibGUtcm93LnNlbGVjdGVkIHtcXG4gICAgICBiYWNrZ3JvdW5kOiAjRjJGM0Y3O1xcbiAgICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuICAubmV4dC10YWJsZS10cmVlLXBsYWNlaG9sZGVyIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICB3aWR0aDogMTJweDsgfVxcblxcbi5sYXN0IC5uZXh0LXRhYmxlLWV4cGFuZGVkLXJvdyB0ZCB7XFxuICBib3JkZXItYm90dG9tLXdpZHRoOiAxcHg7IH1cXG5cXG4ubmV4dC10YWJsZS1ib2R5LFxcbi5uZXh0LXRhYmxlLWhlYWRlciB7XFxuICBvdmVyZmxvdzogYXV0bztcXG4gIGZvbnQtc2l6ZTogMTJweDsgfVxcblxcbi5uZXh0LXRhYmxlLWJvZHkge1xcbiAgZm9udC1zaXplOiAxMnB4OyB9XFxuXFxuLm5leHQtdGFibGUtZml4ZWQge1xcbiAgYm9yZGVyOiAxcHggc29saWQgI0RDREVFMzsgfVxcbiAgLm5leHQtdGFibGUtZml4ZWQgdGFibGUge1xcbiAgICB0YWJsZS1sYXlvdXQ6IGZpeGVkOyB9XFxuICAubmV4dC10YWJsZS1maXhlZCAubmV4dC10YWJsZS1oZWFkZXIge1xcbiAgICBiYWNrZ3JvdW5kOiAjRUJFQ0YwOyB9XFxuICAubmV4dC10YWJsZS1maXhlZCB0YWJsZSB0ciB0ZDpmaXJzdC1jaGlsZCxcXG4gIC5uZXh0LXRhYmxlLWZpeGVkIHRhYmxlIHRyIHRoOmZpcnN0LWNoaWxkIHtcXG4gICAgYm9yZGVyLWxlZnQtd2lkdGg6IDA7IH1cXG4gIC5uZXh0LXRhYmxlLWZpeGVkIC5uZXh0LXRhYmxlLWhlYWRlciB0aCB7XFxuICAgIGJvcmRlci10b3Atd2lkdGg6IDA7IH1cXG4gIC5uZXh0LXRhYmxlLWZpeGVkIC5uZXh0LXRhYmxlLWhlYWRlciB0ciB0aDpsYXN0LWNoaWxkIHtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAwOyB9XFxuICAubmV4dC10YWJsZS1maXhlZCAubmV4dC10YWJsZS1ib2R5IHRkIHtcXG4gICAgYm9yZGVyLXRvcC13aWR0aDogMDsgfVxcbiAgLm5leHQtdGFibGUtZml4ZWQgLm5leHQtdGFibGUtYm9keSB0cjpsYXN0LWNoaWxkIHRkIHtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMDsgfVxcbiAgLm5leHQtdGFibGUtZml4ZWQgLm5leHQtdGFibGUtYm9keSB0ciB0ZDpsYXN0LWNoaWxkIHtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAwOyB9XFxuICAubmV4dC10YWJsZS1maXhlZC5uZXh0LXRhYmxlLWdyb3VwIHRhYmxlIHRyIHRkOmZpcnN0LWNoaWxkLFxcbiAgLm5leHQtdGFibGUtZml4ZWQubmV4dC10YWJsZS1ncm91cCB0YWJsZSB0ciB0aDpmaXJzdC1jaGlsZCB7XFxuICAgIGJvcmRlci1sZWZ0LXdpZHRoOiAxcHg7IH1cXG4gIC5uZXh0LXRhYmxlLWZpeGVkLm5leHQtdGFibGUtZ3JvdXAgLm5leHQtdGFibGUtaGVhZGVyIHRoIHtcXG4gICAgYm9yZGVyLXRvcC13aWR0aDogMXB4OyB9XFxuICAubmV4dC10YWJsZS1maXhlZC5uZXh0LXRhYmxlLWdyb3VwIC5uZXh0LXRhYmxlLWhlYWRlciB0ciB0aDpsYXN0LWNoaWxkIHtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAxcHg7IH1cXG4gIC5uZXh0LXRhYmxlLWZpeGVkLm5leHQtdGFibGUtZ3JvdXAgLm5leHQtdGFibGUtYm9keSB0ZCB7XFxuICAgIGJvcmRlci10b3Atd2lkdGg6IDFweDsgfVxcbiAgLm5leHQtdGFibGUtZml4ZWQubmV4dC10YWJsZS1ncm91cCAubmV4dC10YWJsZS1ib2R5IHRyOmxhc3QtY2hpbGQgdGQge1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAxcHg7IH1cXG4gIC5uZXh0LXRhYmxlLWZpeGVkLm5leHQtdGFibGUtZ3JvdXAgLm5leHQtdGFibGUtYm9keSB0ciB0ZDpsYXN0LWNoaWxkIHtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAxcHg7IH1cXG5cXG4ubmV4dC10YWJsZS1sb2NrIC5uZXh0LXRhYmxlLWJvZHkge1xcbiAgb3ZlcmZsb3cteDogYXV0bztcXG4gIG92ZXJmbG93LXk6IHZpc2libGU7IH1cXG5cXG4ubmV4dC10YWJsZS1ncm91cCB7XFxuICBib3JkZXItd2lkdGg6IDA7IH1cXG4gIC5uZXh0LXRhYmxlLWdyb3VwIC5uZXh0LXRhYmxlLWJvZHkge1xcbiAgICBtYXJnaW4tdG9wOiA4cHg7IH1cXG4gICAgLm5leHQtdGFibGUtZ3JvdXAgLm5leHQtdGFibGUtYm9keSB0YWJsZSB7XFxuICAgICAgbWFyZ2luLWJvdHRvbTogOHB4OyB9XFxuICAgICAgLm5leHQtdGFibGUtZ3JvdXAgLm5leHQtdGFibGUtYm9keSB0YWJsZSB0cjpmaXJzdC1jaGlsZCB0ZCB7XFxuICAgICAgICBib3JkZXItdG9wLXdpZHRoOiAxcHg7IH1cXG4gIC5uZXh0LXRhYmxlLWdyb3VwIC5uZXh0LXRhYmxlLWdyb3VwLWhlYWRlciB0ZCB7XFxuICAgIGJhY2tncm91bmQ6ICNFQkVDRjA7XFxuICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuICAubmV4dC10YWJsZS1ncm91cCAubmV4dC10YWJsZS1ncm91cC1mb290ZXIgdGQge1xcbiAgICBiYWNrZ3JvdW5kOiAjRUJFQ0YwO1xcbiAgICBjb2xvcjogIzMzMzMzMzsgfVxcbiAgLm5leHQtdGFibGUtZ3JvdXAgLm5leHQtdGFibGUtcm93LmhvdmVyZWQsXFxuICAubmV4dC10YWJsZS1ncm91cCAubmV4dC10YWJsZS1yb3cuc2VsZWN0ZWQge1xcbiAgICBiYWNrZ3JvdW5kOiAjRkZGRkZGO1xcbiAgICBjb2xvcjogIzMzMzMzMzsgfVxcblxcbi5uZXh0LXRhYmxlLWxvY2sge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuICAubmV4dC10YWJsZS1sb2NrIHRhYmxlIHtcXG4gICAgdGFibGUtbGF5b3V0OiBmaXhlZDsgfVxcblxcbi5uZXh0LXRhYmxlLWhlYWRlci1pbm5lciB7XFxuICBvdmVyZmxvdzogaGlkZGVuOyB9XFxuXFxuLm5leHQtdGFibGUtbG9jay1sZWZ0LFxcbi5uZXh0LXRhYmxlLWxvY2stcmlnaHQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbGVmdDogMDtcXG4gIHRvcDogMDtcXG4gIHotaW5kZXg6IDE7XFxuICBib3JkZXI6IDA7IH1cXG4gIC5uZXh0LXRhYmxlLWxvY2stbGVmdCB0YWJsZSxcXG4gIC5uZXh0LXRhYmxlLWxvY2stcmlnaHQgdGFibGUge1xcbiAgICB3aWR0aDogYXV0bzsgfVxcbiAgLm5leHQtdGFibGUtbG9jay1sZWZ0IC5uZXh0LXRhYmxlLWJvZHksXFxuICAubmV4dC10YWJsZS1sb2NrLXJpZ2h0IC5uZXh0LXRhYmxlLWJvZHkge1xcbiAgICBvdmVyZmxvdzogaGlkZGVuOyB9XFxuXFxuLm5leHQtdGFibGUtbG9jay1yaWdodCB7XFxuICByaWdodDogMDtcXG4gIGxlZnQ6IGF1dG87IH1cXG4gIC5uZXh0LXRhYmxlLWxvY2stcmlnaHQgdGFibGUgdHIgdGQ6Zmlyc3QtY2hpbGQsXFxuICAubmV4dC10YWJsZS1sb2NrLXJpZ2h0IHRhYmxlIHRyIHRoOmZpcnN0LWNoaWxkIHtcXG4gICAgYm9yZGVyLWxlZnQtd2lkdGg6IDFweDsgfVxcbiAgLm5leHQtdGFibGUtbG9jay1yaWdodC5zaGFkb3cge1xcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IC0ycHggMCAzcHggcmdiYSgwLCAwLCAwLCAwLjEyKTtcXG4gICAgICAgICAgICBib3gtc2hhZG93OiAtMnB4IDAgM3B4IHJnYmEoMCwgMCwgMCwgMC4xMik7IH1cXG5cXG4ubmV4dC10YWJsZS1sb2NrLWxlZnQuc2hhZG93IHtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMnB4IDAgM3B4IHJnYmEoMCwgMCwgMCwgMC4xMik7XFxuICAgICAgICAgIGJveC1zaGFkb3c6IDJweCAwIDNweCByZ2JhKDAsIDAsIDAsIDAuMTIpOyB9XFxuXFxuLm5leHQtdGFibGUtZmlsdGVyIHtcXG4gIGxpbmUtaGVpZ2h0OiAxOyB9XFxuXFxuLm5leHQtdGFibGUtc29ydCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB3aWR0aDogMTZweDtcXG4gIGhlaWdodDogMTVweDtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBsaW5lLWhlaWdodDogMTsgfVxcbiAgLm5leHQtdGFibGUtc29ydCAubmV4dC1pY29uIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBjb2xvcjogIzMzMzMzMzsgfVxcbiAgICAubmV4dC10YWJsZS1zb3J0IC5uZXh0LWljb246YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTJweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gIC5uZXh0LXRhYmxlLXNvcnQgLmN1cnJlbnQgLm5leHQtaWNvbiB7XFxuICAgIGNvbG9yOiAjNTU4NEZGOyB9XFxuICAubmV4dC10YWJsZS1zb3J0IC5uZXh0LWljb24tYXNjZW5kaW5nIHtcXG4gICAgbGVmdDogNHB4OyB9XFxuXFxuLm5leHQtdGFibGUtZmlsdGVyIHtcXG4gIG1hcmdpbi1sZWZ0OiA1cHg7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICB3aWR0aDogMjBweDtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jazsgfVxcbiAgLm5leHQtdGFibGUtZmlsdGVyIC5uZXh0LWljb24ge1xcbiAgICBjb2xvcjogIzMzMzMzMzsgfVxcbiAgICAubmV4dC10YWJsZS1maWx0ZXIgLm5leHQtaWNvbjpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcblxcbi5uZXh0LXRhYmxlLWV4cGFuZGVkLWN0cmwuZGlzYWJsZWQge1xcbiAgY29sb3I6ICM5OTk5OTk7IH1cXG5cXG4ubmV4dC10YWJsZS1leHBhbmRlZC1jdHJsIC5uZXh0LWljb246YmVmb3JlIHtcXG4gIHdpZHRoOiAxMnB4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXI/P3JlZi0tMi0xIS4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWI/P3JlZi0tMi0yIS4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliIS4vc3JjL3RhYmxlL21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIDEyIDEzIDE0IDE1IDE2IDE3IDE4IDE5IDIwIDIxIDIyIiwiZXhwb3J0IGRlZmF1bHQge1xuICAgIG1vbWVudExvY2FsZTogJ3poLWNuJyxcbiAgICBUaW1lbGluZToge1xuICAgICAgICBleHBhbmQ6ICflsZXlvIAnLFxuICAgICAgICBmb2xkOiAn5pS26LW3JyxcbiAgICB9LFxuICAgIENhcmQ6IHtcbiAgICAgICAgZXhwYW5kOiAn5bGV5byAJyxcbiAgICAgICAgZm9sZDogJ+aUtui1tycsXG4gICAgfSxcbiAgICBDYWxlbmRhcjoge1xuICAgICAgICB0b2RheTogJ+S7iuWkqScsXG4gICAgICAgIG5vdzogJ+atpOWIuycsXG4gICAgICAgIG9rOiAn56Gu5a6aJyxcbiAgICAgICAgY2xlYXI6ICfmuIXpmaQnLFxuICAgICAgICBtb250aDogJ+aciCcsXG4gICAgICAgIHllYXI6ICflubQnLFxuICAgICAgICBwcmV2WWVhcjogJ+S4iuS4gOW5tCcsXG4gICAgICAgIG5leHRZZWFyOiAn5LiL5LiA5bm0JyxcbiAgICAgICAgcHJldk1vbnRoOiAn5LiK5Liq5pyIJyxcbiAgICAgICAgbmV4dE1vbnRoOiAn5LiL5Liq5pyIJyxcbiAgICAgICAgcHJldkRlY2FkZTogJ+S4iuWNgeW5tCcsXG4gICAgICAgIG5leHREZWNhZGU6ICflkI7ljYHlubQnLFxuICAgIH0sXG4gICAgRGF0ZVBpY2tlcjoge1xuICAgICAgICBwbGFjZWhvbGRlcjogJ+ivt+mAieaLqeaXpeacnycsXG4gICAgICAgIGRhdGV0aW1lUGxhY2Vob2xkZXI6ICfor7fpgInmi6nml6XmnJ/lkozml7bpl7QnLFxuICAgICAgICBtb250aFBsYWNlaG9sZGVyOiAn6K+36YCJ5oup5pyIJyxcbiAgICAgICAgeWVhclBsYWNlaG9sZGVyOiAn6K+36YCJ5oup5bm0JyxcbiAgICAgICAgbm93OiAn5q2k5Yi7JyxcbiAgICAgICAgc2VsZWN0VGltZTogJ+mAieaLqeaXtumXtCcsXG4gICAgICAgIHNlbGVjdERhdGU6ICfpgInmi6nml6XmnJ8nLFxuICAgICAgICBvazogJ+ehruWumicsXG4gICAgICAgIGNsZWFyOiAn5riF6ZmkJyxcbiAgICAgICAgc3RhcnRQbGFjZWhvbGRlcjogJ+i1t+Wni+aXpeacnycsXG4gICAgICAgIGVuZFBsYWNlaG9sZGVyOiAn57uT5p2f5pel5pyfJyxcbiAgICAgICAgaG91cjogJ+aXticsXG4gICAgICAgIG1pbnV0ZTogJ+WIhicsXG4gICAgICAgIHNlY29uZDogJ+enkidcbiAgICB9LFxuICAgIERpYWxvZzoge1xuICAgICAgICBvazogJ+ehruiupCcsXG4gICAgICAgIGNhbmNlbDogJ+WPlua2iCdcbiAgICB9LFxuICAgIFBhZ2luYXRpb246IHtcbiAgICAgICAgcHJldjogJ+S4iuS4gOmhtScsXG4gICAgICAgIG5leHQ6ICfkuIvkuIDpobUnLFxuICAgICAgICBnb1RvOiAn5Yiw56ysJyxcbiAgICAgICAgcGFnZTogJ+mhtScsXG4gICAgICAgIGdvOiAn56Gu5a6aJyxcbiAgICAgICAgcGFnZVNpemU6ICfmr4/pobXmmL7npLrvvJonXG4gICAgfSxcbiAgICBJbnB1dDoge1xuICAgICAgICBjbGVhcjogJ+a4hemZpCdcbiAgICB9LFxuICAgIFNlbGVjdDoge1xuICAgICAgICBzZWxlY3RQbGFjZWhvbGRlcjogJ+ivt+mAieaLqScsXG4gICAgICAgIGF1dG9Db21wbGV0ZVBsYWNlaG9sZGVyOiAn6K+36L6T5YWlJyxcbiAgICAgICAgbm90Rm91bmRDb250ZW50OiAn5peg6YCJ6aG5J1xuICAgIH0sXG4gICAgVGFibGU6IHtcbiAgICAgICAgZW1wdHk6ICfmsqHmnInmlbDmja4nLFxuICAgICAgICBvazogJ+ehruiupCcsXG4gICAgICAgIHJlc2V0OiAn6YeN572uJyxcbiAgICAgICAgYXNjOiAn5Y2H5bqPJyxcbiAgICAgICAgZGVzYzogJ+mZjeW6jycsXG4gICAgICAgIGV4cGFuZGVkOiAn5bey5bGV5byAJyxcbiAgICAgICAgZm9sZGVkOiAn5bey5oqY5Y+gJyxcbiAgICAgICAgZmlsdGVyOiAn562b6YCJJyxcbiAgICAgICAgc2VsZWN0QWxsOiAn5YWo6YCJJ1xuICAgIH0sXG4gICAgVGltZVBpY2tlcjoge1xuICAgICAgICBwbGFjZWhvbGRlcjogJ+ivt+mAieaLqeaXtumXtCcsXG4gICAgICAgIGNsZWFyOiAn5riF6ZmkJyxcbiAgICAgICAgaG91cjogJ+aXticsXG4gICAgICAgIG1pbnV0ZTogJ+WIhicsXG4gICAgICAgIHNlY29uZDogJ+enkidcbiAgICB9LFxuICAgIFRyYW5zZmVyOiB7XG4gICAgICAgIGl0ZW1zOiAn6aG5JyxcbiAgICAgICAgaXRlbTogJ+mhuScsXG4gICAgICAgIG1vdmVBbGw6ICfnp7vliqjlhajpg6gnLFxuICAgICAgICBzZWFyY2hQbGFjZWhvbGRlcjogJ+ivt+i+k+WFpSdcbiAgICB9LFxuICAgIFVwbG9hZDoge1xuICAgICAgICBjYXJkOiB7XG4gICAgICAgICAgICBjYW5jZWw6ICflj5bmtognLFxuICAgICAgICAgICAgYWRkUGhvdG86ICfkuIrkvKDlm77niYcnXG4gICAgICAgIH0sXG4gICAgICAgIGRyYWc6IHtcbiAgICAgICAgICAgIHRleHQ6ICfngrnlh7vmiJbogIXmi5bliqjmlofku7bliLDomZrnur/moYblhoXkuIrkvKAnLFxuICAgICAgICAgICAgaGludDogJ+aUr+aMgSBkb2N4LCB4bHMsIFBERiwgcmFyLCB6aXAsIFBORywgSlBHIOetieexu+Wei+eahOaWh+S7tidcbiAgICAgICAgfVxuICAgIH0sXG4gICAgU2VhcmNoOiB7XG4gICAgICAgIGJ1dHRvblRleHQ6ICfmkJzntKInLFxuICAgIH0sXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xvY2FsZS96aC1jbi5qcyIsImltcG9ydCAnLi4vYW5pbWF0ZS9zdHlsZS5qcyc7XG5pbXBvcnQgJy4vbWFpbi5zY3NzJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9vdmVybGF5L3N0eWxlLmpzIiwiaW1wb3J0IENoZWNrYm94IGZyb20gJy4vY2hlY2tib3gnO1xuaW1wb3J0IEdyb3VwIGZyb20gJy4vY2hlY2tib3gtZ3JvdXAnO1xuXG5DaGVja2JveC5Hcm91cCA9IEdyb3VwO1xuXG5leHBvcnQgZGVmYXVsdCBDaGVja2JveDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jaGVja2JveC9pbmRleC5qc3giLCJpbXBvcnQgJy4uL2ljb24vc3R5bGUuanMnO1xuaW1wb3J0ICcuLi9hbmltYXRlL3N0eWxlLmpzJztcbmltcG9ydCAnLi9tYWluLnNjc3MnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NoZWNrYm94L3N0eWxlLmpzIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29udGV4dFByb3BzKHByb3BzLCBjb250ZXh0LCBkaXNwbGF5TmFtZSkge1xuICAgIGNvbnN0IHsgcHJlZml4LCBsb2NhbGUsIHB1cmUsIHJ0bCB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyBuZXh0UHJlZml4LCBuZXh0TG9jYWxlLCBuZXh0UHVyZSwgbmV4dFdhcm5pbmcsIG5leHRSdGwgfSA9IGNvbnRleHQ7XG5cbiAgICBjb25zdCBuZXdQcmVmaXggPSBwcmVmaXggfHwgbmV4dFByZWZpeDtcblxuICAgIGxldCBsb2NhbGVGcm9tQ29udGV4dDtcbiAgICBpZiAobmV4dExvY2FsZSkge1xuICAgICAgICBsb2NhbGVGcm9tQ29udGV4dCA9IG5leHRMb2NhbGVbZGlzcGxheU5hbWVdO1xuICAgICAgICBpZiAobG9jYWxlRnJvbUNvbnRleHQpIHtcbiAgICAgICAgICAgIGxvY2FsZUZyb21Db250ZXh0Lm1vbWVudExvY2FsZSA9IG5leHRMb2NhbGUubW9tZW50TG9jYWxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBuZXdMb2NhbGU7XG4gICAgaWYgKGxvY2FsZSkge1xuICAgICAgICBuZXdMb2NhbGUgPSB7IC4uLihsb2NhbGVGcm9tQ29udGV4dCB8fCB7fSksIC4uLmxvY2FsZSB9O1xuICAgIH0gZWxzZSBpZiAobG9jYWxlRnJvbUNvbnRleHQpIHtcbiAgICAgICAgbmV3TG9jYWxlID0gbG9jYWxlRnJvbUNvbnRleHQ7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3UHVyZSA9IHR5cGVvZiBwdXJlID09PSAnYm9vbGVhbicgPyBwdXJlIDogbmV4dFB1cmU7XG4gICAgY29uc3QgbmV3UnRsID0gdHlwZW9mIHJ0bCA9PT0gJ2Jvb2xlYW4nID8gcnRsIDogbmV4dFJ0bDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHByZWZpeDogbmV3UHJlZml4LFxuICAgICAgICBsb2NhbGU6IG5ld0xvY2FsZSxcbiAgICAgICAgcHVyZTogbmV3UHVyZSxcbiAgICAgICAgcnRsOiBuZXdSdGwsXG4gICAgICAgIHdhcm5pbmc6IG5leHRXYXJuaW5nXG4gICAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb25maWctcHJvdmlkZXIvZ2V0LWNvbnRleHQtcHJvcHMuanN4IiwiaW1wb3J0IHtjYW1lbGNhc2UsIGh5cGhlbmF0ZX0gZnJvbSAnLi9zdHJpbmcnO1xuaW1wb3J0IHtlYWNofSBmcm9tICcuL29iamVjdCc7XG5cbi8qKlxuICog5piv5ZCm6IO95L2/55SoIERPTSDmlrnms5VcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaGFzRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgISF3aW5kb3cuZG9jdW1lbnQgJiYgISFkb2N1bWVudC5jcmVhdGVFbGVtZW50O1xuXG4vKipcbiAqIOiKgueCueaYr+WQpuWMheWQq+aMh+WumiBjbGFzc05hbWVcbiAqIEBwYXJhbSAge0VsZW1lbnR9ICBub2RlXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBjbGFzc05hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICogQGV4YW1wbGVcbiAqIGRvbS5oYXNDbGFzcyhkb2N1bWVudC5ib2R5LCAnZm9vJyk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNDbGFzcyAobm9kZSwgY2xhc3NOYW1lKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFoYXNET00gfHwgIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChub2RlLmNsYXNzTGlzdCkge1xuICAgICAgICByZXR1cm4gbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9kZS5jbGFzc05hbWUuaW5kZXhPZihjbGFzc05hbWUpID4gLTE7XG4gICAgfVxufVxuXG4vKipcbiAqIOa3u+WKoCBjbGFzc05hbWVcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICpcbiAqIEBleGFtcGxlXG4gKiBkb20uYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2ZvbycpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2xhc3MgKG5vZGUsIGNsYXNzTmFtZSwgX2ZvcmNlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFoYXNET00gfHwgIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLmNsYXNzTGlzdCkge1xuICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICB9IGVsc2UgaWYgKF9mb3JjZSA9PT0gdHJ1ZSB8fCAhaGFzQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKSkge1xuICAgICAgICBub2RlLmNsYXNzTmFtZSArPSBgICR7Y2xhc3NOYW1lfWA7XG4gICAgfVxufVxuXG4vKipcbiAqIOenu+mZpCBjbGFzc05hbWVcbiAqIEBwYXJhbSAge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSAge1N0cmluZ30gY2xhc3NOYW1lXG4gKlxuICogQGV4YW1wbGVcbiAqIGRvbS5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnZm9vJyk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDbGFzcyAobm9kZSwgY2xhc3NOYW1lLCBfZm9yY2UpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWhhc0RPTSB8fCAhbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuY2xhc3NMaXN0KSB7XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgIH0gZWxzZSBpZiAoX2ZvcmNlID09PSB0cnVlIHx8IGhhc0NsYXNzKG5vZGUsIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgbm9kZS5jbGFzc05hbWUgPSBub2RlLmNsYXNzTmFtZS5yZXBsYWNlKGNsYXNzTmFtZSwgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIOWIh+aNoiBjbGFzc05hbWVcbiAqIEBwYXJhbSAge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSAge1N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAg5omn6KGM5ZCO6IqC54K55LiK5piv5ZCm6L+Y5pyJ5q2kIGNsYXNzTmFtZVxuICpcbiAqIEBleGFtcGxlXG4gKiBkb20udG9nZ2xlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2ZvbycpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlQ2xhc3MgKG5vZGUsIGNsYXNzTmFtZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaGFzRE9NIHx8ICFub2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5jbGFzc0xpc3QpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0LnRvZ2dsZShjbGFzc05hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZsYWcgPSBoYXNDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuICAgICAgICBmbGFnID8gcmVtb3ZlQ2xhc3Mobm9kZSwgY2xhc3NOYW1lLCB0cnVlKSA6IGFkZENsYXNzKG5vZGUsIGNsYXNzTmFtZSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuICFmbGFnO1xuICAgIH1cbn1cblxuLyoqXG4gKiDlhYPntKDmmK/lkKbljLnphY0gQ1NTIOmAieaLqeWZqFxuICogQHBhcmFtICB7RWxlbWVudH0gbm9kZSAgICAgICBET00g6IqC54K5XG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBzZWxlY3RvciAgIENTUyDpgInmi6nlmahcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICogQGV4YW1wbGVcbiAqIGRvbS5tYXRjaGVzKG1vdW50Tm9kZSwgJy5jb250YWluZXInKTsgLy8gYm9vbGVhblxuICovXG5leHBvcnQgY29uc3QgbWF0Y2hlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgbWF0Y2hlc0ZuID0gbnVsbDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChoYXNET00pIHtcbiAgICAgICAgY29uc3QgX2JvZHkgPSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmhlYWQ7XG4gICAgICAgIG1hdGNoZXNGbiA9IF9ib2R5Lm1hdGNoZXMgPyAnbWF0Y2hlcycgOlxuICAgICAgICAgICAgX2JvZHkud2Via2l0TWF0Y2hlc1NlbGVjdG9yID8gJ3dlYmtpdE1hdGNoZXNTZWxlY3RvcicgOlxuICAgICAgICAgICAgICAgIF9ib2R5Lm1zTWF0Y2hlc1NlbGVjdG9yID8gJ21zTWF0Y2hlc1NlbGVjdG9yJyA6XG4gICAgICAgICAgICAgICAgICAgIF9ib2R5Lm1vek1hdGNoZXNTZWxlY3RvciA/ICdtb3pNYXRjaGVzU2VsZWN0b3InIDogbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUsIHNlbGVjdG9yKSB7XG4gICAgICAgIGlmICghaGFzRE9NIHx8ICFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0Y2hlc0ZuID8gbm9kZVttYXRjaGVzRm5dKHNlbGVjdG9yKSA6IGZhbHNlO1xuICAgIH07XG59KCk7XG5cbi8qKlxuICog6I635Y+W5YWD57Sg6K6h566X5ZCO55qE5qC35byPXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBfZ2V0Q29tcHV0ZWRTdHlsZSAobm9kZSkge1xuICAgIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IDEgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKSA6IHt9O1xufVxuXG5jb25zdCBQSVhFTF9QQVRURVJOID0gL21hcmdpbnxwYWRkaW5nfHdpZHRofGhlaWdodHxtYXh8bWlufG9mZnNldHxzaXplL2k7XG5jb25zdCByZW1vdmVQaXhlbCA9IHtsZWZ0OiAxLCB0b3A6IDEsIHJpZ2h0OiAxLCBib3R0b206IDF9O1xuXG4vKipcbiAqIOagoemqjOW5tuS/ruato+WFg+e0oOeahOagt+W8j+WxnuaAp+WAvFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICogQHBhcmFtICB7TnVtYmVyfSB2YWx1ZVxuICovXG5mdW5jdGlvbiBfZ2V0U3R5bGVWYWx1ZSAobm9kZSwgdHlwZSwgdmFsdWUpIHtcbiAgICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKHZhbHVlID09PSAnYXV0bycpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdoZWlnaHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5vZmZzZXRIZWlnaHQgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3dpZHRoJykge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUub2Zmc2V0V2lkdGggfHwgMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKHR5cGUgaW4gcmVtb3ZlUGl4ZWwpKSB7XG4gICAgICAgIC8vIOWxnuaAp+WAvOaYr+WQpumcgOimgeWOu+aOiSBweCDljZXkvY3vvIzov5nph4zlgYflrprmraTnsbvnmoTlsZ7mgKflgLzpg73mmK8gcHgg5Li65Y2V5L2N55qEXG4gICAgICAgIHJlbW92ZVBpeGVsW3R5cGVdID0gUElYRUxfUEFUVEVSTi50ZXN0KHR5cGUpO1xuICAgIH1cblxuICAgIHJldHVybiByZW1vdmVQaXhlbFt0eXBlXSA/IChwYXJzZUZsb2F0KHZhbHVlKSB8fCAwKSA6IHZhbHVlO1xufVxuXG5jb25zdCBmbG9hdE1hcCA9IHtjc3NGbG9hdDogMSwgc3R5bGVGbG9hdDogMSwgZmxvYXQ6IDF9O1xuXG4vKipcbiAqIOiOt+WPluWFg+e0oOiuoeeul+WQjueahOagt+W8j1xuICogQHBhcmFtICB7RWxlbWVudH0gbm9kZSBET00g6IqC54K5XG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUg5bGe5oCn5ZCNXG4gKiBAcmV0dXJuIHtOdW1iZXJ8T2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3R5bGUgKG5vZGUsIG5hbWUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWhhc0RPTSB8fCAhbm9kZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBzdHlsZSA9IF9nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXG4gICAgLy8g5aaC5p6c5LiN5oyH5a6a5bGe5oCn5ZCN77yM5YiZ6L+U5Zue5YWo6YOo5YC8XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cblxuICAgIG5hbWUgPSBmbG9hdE1hcFtuYW1lXSA/ICdjc3NGbG9hdCcgaW4gbm9kZS5zdHlsZSA/ICdjc3NGbG9hdCcgOiAnc3R5bGVGbG9hdCcgOiBuYW1lO1xuXG4gICAgcmV0dXJuIF9nZXRTdHlsZVZhbHVlKG5vZGUsIG5hbWUsIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoaHlwaGVuYXRlKG5hbWUpKSB8fCBub2RlLnN0eWxlW2NhbWVsY2FzZShuYW1lKV0pO1xufVxuXG4vKipcbiAqIOiuvue9ruWFg+e0oOeahOagt+W8j1xuICogQHBhcmFtIHtFbGVtZW50fSBub2RlICBET00g6IqC54K5XG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG5hbWUgIOWxnuaAp+WQje+8jOaIluiAheaYr+S4gOS4quWvueixoe+8jOWMheWQq+WkmuS4quWxnuaAp1xuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZSDlsZ7mgKflgLxcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8g6K6+572u5Y2V5Liq5bGe5oCn5YC8XG4gKiBkb20uc2V0U3R5bGUobW91bnROb2RlLCAnd2lkdGgnLCAxMDApO1xuICogLy8g6K6+572u5aSa5p2h5bGe5oCn5YC8XG4gKiBkb20uc2V0U3R5bGUobW91bnROb2RlLCB7XG4gKiAgICAgd2lkdGg6IDEwMCxcbiAqICAgICBoZWlnaHQ6IDIwMFxuICogfSk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRTdHlsZSAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWhhc0RPTSB8fCAhbm9kZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8g5om56YeP6K6+572u5aSa5Liq5YC8XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGVhY2gobmFtZSwgKHZhbCwga2V5KSA9PiBzZXRTdHlsZShub2RlLCBrZXksIHZhbCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgPSBmbG9hdE1hcFtuYW1lXSA/ICdjc3NGbG9hdCcgaW4gbm9kZS5zdHlsZSA/ICdjc3NGbG9hdCcgOiAnc3R5bGVGbG9hdCcgOiBuYW1lO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBQSVhFTF9QQVRURVJOLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYCR7dmFsdWV9cHhgO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuc3R5bGVbY2FtZWxjYXNlKG5hbWUpXSA9IHZhbHVlOyAvLyBJRTggc3VwcG9ydFxuICAgIH1cbn1cblxuLyoqXG4gKiDojrflj5bpu5jorqTnmoTmu5rliqjmnaHlpKflsI9cbiAqIEByZXR1cm4ge09iamVjdH0gd2lkdGgsIGhlaWdodFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsYmFyICgpIHtcbiAgICBjb25zdCBzY3JvbGxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIHNldFN0eWxlKHNjcm9sbERpdiwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgd2lkdGg6ICcxMDBweCcsXG4gICAgICAgIGhlaWdodDogJzEwMHB4JyxcbiAgICAgICAgb3ZlcmZsb3c6ICdzY3JvbGwnLFxuICAgICAgICB0b3A6ICctOTk5OXB4J1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbERpdi5vZmZzZXRXaWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aDtcbiAgICBjb25zdCBzY3JvbGxiYXJIZWlnaHQgPSBzY3JvbGxEaXYub2Zmc2V0SGVpZ2h0IC0gc2Nyb2xsRGl2LmNsaWVudEhlaWdodDtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNjcm9sbERpdik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogc2Nyb2xsYmFyV2lkdGgsXG4gICAgICAgIGhlaWdodDogc2Nyb2xsYmFySGVpZ2h0XG4gICAgfTtcbn1cblxuLyoqXG4gKiDojrflj5blhYPntKDot53nprvop4blj6Ppobbpg6jlkozlt6bovrnnmoTlgY/np7vot53nprtcbiAqIEByZXR1cm4ge09iamVjdH0gdG9wLCBsZWZ0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPZmZzZXQgKG5vZGUpIHtcbiAgICBjb25zdCByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB3aW4gPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0XG4gICAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlsL2RvbS5qcyIsIi8qKlxuICog5bCG5a2X56ym5Liy6L2s5YyW5Li66am85bOw5byP5YaZ5rOVXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0ciDkvovvvJotd2Via2l0LXRyYW5zaXRpb25cbiAqIEByZXR1cm4ge1N0cmluZ30gICAgIOS+i++8mldlYmtpdFRyYW5zaXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbWVsY2FzZSAoc3RyKSB7XG4gICAgaWYgKCEvLS8udGVzdChzdHIpKSB7XG4gICAgICAgIHJldHVybiBzdHIgfHwgJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tKFthLXpdKS9nLCAoJDAsICQxKSA9PiAkMS50b1VwcGVyQ2FzZSgpKTtcbn1cblxuLyoqXG4gKiDlsIbpqbzls7DlvI/lrZfnrKbkuLLovazljJbkuLrov57lrZfnrKblhpnms5VcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyIOS+i++8mldlYmtpdFRyYW5zaXRpb25cbiAqIEByZXR1cm4ge1N0cmluZ30gICAgIOS+i++8mi13ZWJraXQtdHJhbnNpdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlwaGVuYXRlIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbQS1aXSkvZywgJDAgPT4gYC0keyQwLnRvTG93ZXJDYXNlKCl9YCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbC9zdHJpbmcuanMiLCIvKipcbiAqIElF5rWP6KeI5Zmo55qE5riy5p+T5byV5pOO54mI5pys5Y+3XG4gKiDms6jmhI/vvJrmraTlsZ7mgKfkuI7mtY/op4jlmajniYjmnKzlj7fkuI3lkIzvvIxJReeahOa4suafk+W8leaTjueJiOacrOWPt+aYr+WPr+S7pemAmui/h0hUTUwgaGVhZGVy5oiW5omL5Yqo6K6+572u5Y675pu05pS555qEXG4gKiBAdHlwZSB7TnVtYmVyfSA2IH4gMTBcbiAqL1xuZXhwb3J0IGNvbnN0IGllVmVyc2lvbiA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICog5Yik5pat5piv5ZCm5piv55Sf5Lqn546v5aKDXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzUHJvZHVjdGlvbiA9ICgpID0+IHtcbiAgICBjb25zdCBQUk9EVUNUSU9OX0VOViA9ICdwcm9kdWN0aW9uJztcbiAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBQUk9EVUNUSU9OX0VOVikge1xuICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvL1xuICAgIH1cblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAod2luZG93LnByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBQUk9EVUNUSU9OX0VOVikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBpZVZlcnNpb24sXG4gICAgaXNQcm9kdWN0aW9uLFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlsL2Vudi5qcyIsImV4cG9ydCBkZWZhdWx0IHtcbiAgICBCQUNLU1BBQ0U6IDgsXG4gICAgVEFCOiA5LFxuICAgIEVOVEVSOiAxMyxcbiAgICBTSElGVDogMTYsXG4gICAgQ1RSTDogMTcsXG4gICAgQUxUOiAxOCxcbiAgICBFU0M6IDI3LFxuICAgIFNQQUNFOiAzMixcbiAgICBFTkQ6IDM1LFxuICAgIEhPTUU6IDM2LFxuICAgIExFRlQ6IDM3LFxuICAgIFVQOiAzOCxcbiAgICBSSUdIVDogMzksXG4gICAgRE9XTjogNDAsXG5cbiAgICAvLyB2ZXJzaW9uIDAueFxuICAgIEVTQ0FQRTogMjcsXG4gICAgTEVGVF9BUlJPVzogMzcsXG4gICAgVVBfQVJST1c6IDM4LFxuICAgIFJJR0hUX0FSUk9XOiAzOSxcbiAgICBET1dOX0FSUk9XOiA0MCxcblxuICAgIC8vIE1hY09TXG4gICAgQ09OVFJPTDogMTcsXG4gICAgT1BUSU9OOiAxOCxcbiAgICBDTUQ6IDkxLFxuICAgIENPTU1BTkQ6IDkxLFxuICAgIERFTEVURTogOCxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbC9rZXljb2RlLmpzIiwidmFyIHN0eWxlRXF1YWwgPSByZXF1aXJlKCdzdHlsZS1lcXVhbCcpO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gdHlwZShhKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGEpID8gJ2FycmF5JyA6IHR5cGVvZiBhO1xufVxuXG5mdW5jdGlvbiBlbGVtZW50RXF1YWxzKGEsIGIpIHtcbiAgdmFyIHR5cGVPZkEgPSB0eXBlKGEpO1xuICB2YXIgdHlwZU9mQiA9IHR5cGUoYik7XG5cbiAgaWYgKHR5cGVPZkEgIT09IHR5cGVPZkIpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKHR5cGVPZkEpIHtcbiAgICBjYXNlICdhcnJheSc6XG4gICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFlbGVtZW50RXF1YWxzKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gYSA9PT0gYjtcbiAgICAgIGlmIChhLnR5cGUgIT09IGIudHlwZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGEua2V5ICE9PSBiLmtleSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGEucmVmICE9PSBiLnJlZikgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHNoYWxsb3dFbGVtZW50RXF1YWxzKGEucHJvcHMsIGIucHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBhID09PSBiO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dFbGVtZW50RXF1YWxzKGEsIGIpIHtcbiAgdmFyIGFDb3VudCA9IDA7XG4gIHZhciBiQ291bnQgPSAwO1xuXG4gIGZvciAodmFyIGtleSBpbiBhKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYSwga2V5KSkge1xuICAgICAgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAvLyBOT1RFKGxtcik6IGtpbmQgb2Ygcmlza3ksIGJ1dCBpJ20gYXNzdW1pbmcgdGhhdCBhIGBzdHlsZWAgcHJvcCBpcyBhIFJlYWN0IE5hdGl2ZSBzdHlsZSxcbiAgICAgICAgLy8gYW5kIHVzaW5nIHRoZSBgc3R5bGVFcXVhbGAgYWxnb3JpdGhtIGhlcmUuXG4gICAgICAgIGlmICghc3R5bGVFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnY2hpbGRyZW4nKSB7XG4gICAgICAgIC8vIHdpbGwgY29tcGFyZSBjaGlsZHJlbiBsYXRlclxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBhQ291bnQrKztcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gYikge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleSkpIHtcbiAgICAgIGJDb3VudCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhQ291bnQgIT09IGJDb3VudCkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIGNvbXBhcmUgY2hpbGRyZW4gbGFzdC4uLlxuICByZXR1cm4gZWxlbWVudEVxdWFscyhhLmNoaWxkcmVuLCBiLmNoaWxkcmVuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGFsbG93RWxlbWVudEVxdWFscztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fc2hhbGxvdy1lbGVtZW50LWVxdWFsc0AxLjAuMUBzaGFsbG93LWVsZW1lbnQtZXF1YWxzL2luZGV4LmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmaW5kRE9NTm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBkb20sIGV2ZW50cywgZnVuYywgc3VwcG9ydCwgZm9jdXMsIEtFWUNPREUsIGd1aWQgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBvdmVybGF5TWFuYWdlciBmcm9tICcuL21hbmFnZXInO1xuaW1wb3J0IEdhdGV3YXkgZnJvbSAnLi9nYXRld2F5JztcbmltcG9ydCBQb3NpdGlvbiBmcm9tICcuL3Bvc2l0aW9uJztcbmltcG9ydCBmaW5kTm9kZSBmcm9tICcuL3V0aWxzL2ZpbmQtbm9kZSc7XG5cbmNvbnN0IHsgc2F2ZUxhc3RGb2N1c05vZGUsIGdldEZvY3VzTm9kZUxpc3QsIGJhY2tMYXN0Rm9jdXNOb2RlIH0gPSBmb2N1cztcbmNvbnN0IHsgbWFrZUNoYWluLCBub29wLCBiaW5kQ3R4IH0gPSBmdW5jO1xuXG5jb25zdCBpc1Njcm9sbERpc3BsYXkgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsYmFyU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCAnOjotd2Via2l0LXNjcm9sbGJhcicpO1xuICAgICAgICByZXR1cm4gIXNjcm9sbGJhclN0eWxlIHx8IHNjcm9sbGJhclN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2Rpc3BsYXknKSAhPT0gJ25vbmUnO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWdub3JlIGVycm9yIGZvciBmaXJlZm94XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuY29uc3QgaGFzU2Nyb2xsID0gKCkgPT4ge1xuICAgIGNvbnN0IGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICByZXR1cm4gZG9jLnNjcm9sbEhlaWdodCA+IGRvYy5jbGllbnRIZWlnaHQgJiYgZG9tLnNjcm9sbGJhcigpLndpZHRoID4gMCAmJiBpc1Njcm9sbERpc3BsYXkoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSAmJiBpc1Njcm9sbERpc3BsYXkoZG9jdW1lbnQuYm9keSk7XG59O1xuY29uc3QgcHJlZml4ZXMgPSBbJy13ZWJraXQtJywgJy1tb3otJywgJy1vLScsICdtcy0nLCAnJ107XG5jb25zdCBnZXRTdHlsZVByb3BlcnR5ID0gKG5vZGUsIG5hbWUpID0+IHtcbiAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGxldCByZXQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJldCA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJlZml4ZXNbaV0gKyBuYW1lKTtcbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmNvbnN0IG1vZGFscyA9IFtdO1xubGV0IGJvZHlPdmVyZmxvd1ksIGJvZHlQYWRkaW5nUmlnaHQ7XG5cbi8qKlxuICogT3ZlcmxheVxuICogKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE92ZXJsYXkgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcHVyZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLlhoXlrrlcbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5pi+56S65by55bGCXG4gICAgICAgICAqL1xuICAgICAgICB2aXNpYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguivt+axguWFs+mXreaXtuinpuWPkeS6i+S7tueahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSDlvLnlsYLlhbPpl63nmoTmnaXmupBcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGUgRE9NIOS6i+S7tlxuICAgICAgICAgKi9cbiAgICAgICAgb25SZXF1ZXN0Q2xvc2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5a6a5L2N55qE5Y+C54Wn5YWD57SgXG4gICAgICAgICAqL1xuICAgICAgICB0YXJnZXQ6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLnm7jlr7nkuo7lj4LnhaflhYPntKDnmoTlrprkvY0sIOivpuingeW8gOWPkeaMh+WNl+eahFvlrprkvY3pg6jliIZdKCPlrprkvY0pXG4gICAgICAgICAqL1xuICAgICAgICBhbGlnbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmJvb2xdKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguebuOWvueS6juWPgueFp+WFg+e0oOWumuS9jeeahOW+ruiwg1xuICAgICAgICAgKi9cbiAgICAgICAgb2Zmc2V0OiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuLLmn5Pnu4Tku7bnmoTlrrnlmajvvIzlpoLmnpzmmK/lh73mlbDpnIDopoHov5Tlm54gcmVm77yM5aaC5p6c5piv5a2X56ym5Liy5YiZ5piv6K+lIERPTSDnmoQgaWTvvIzkuZ/lj6/ku6Xnm7TmjqXkvKDlhaUgRE9NIOiKgueCuVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbmVyOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5pi+56S66YGu572pXG4gICAgICAgICAqL1xuICAgICAgICBoYXNNYXNrOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuaUr+aMgSBlc2Mg5oyJ6ZSu5YWz6Zet5by55bGCXG4gICAgICAgICAqL1xuICAgICAgICBjYW5DbG9zZUJ5RXNjOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeCueWHu+W8ueWxguWklueahOWMuuWfn+aYr+WQpuWFs+mXreW8ueWxgu+8jOS4jeaYvuekuumBrue9qeaXtueUn+aViFxuICAgICAgICAgKi9cbiAgICAgICAgY2FuQ2xvc2VCeU91dFNpZGVDbGljazogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDngrnlh7vpga7nvanljLrln5/mmK/lkKblhbPpl63lvLnlsYLvvIzmmL7npLrpga7nvanml7bnlJ/mlYhcbiAgICAgICAgICovXG4gICAgICAgIGNhbkNsb3NlQnlNYXNrOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguaJk+W8gOWJjeinpuWPkeS6i+S7tueahOWbnuiwg+WHveaVsFxuICAgICAgICAgKi9cbiAgICAgICAgYmVmb3JlT3BlbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLmiZPlvIDml7bop6blj5Hkuovku7bnmoTlm57osIPlh73mlbBcbiAgICAgICAgICovXG4gICAgICAgIG9uT3BlbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLmiZPlvIDlkI7op6blj5Hkuovku7bnmoTlm57osIPlh73mlbAsIOWmguaenOacieWKqOeUu++8jOWImeWcqOWKqOeUu+e7k+adn+WQjuinpuWPkVxuICAgICAgICAgKi9cbiAgICAgICAgYWZ0ZXJPcGVuOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguWFs+mXreWJjeinpuWPkeS6i+S7tueahOWbnuiwg+WHveaVsFxuICAgICAgICAgKi9cbiAgICAgICAgYmVmb3JlQ2xvc2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5YWz6Zet5pe26Kem5Y+R5LqL5Lu255qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqL1xuICAgICAgICBvbkNsb3NlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguWFs+mXreWQjuinpuWPkeS6i+S7tueahOWbnuiwg+WHveaVsCwg5aaC5p6c5pyJ5Yqo55S777yM5YiZ5Zyo5Yqo55S757uT5p2f5ZCO6Kem5Y+RXG4gICAgICAgICAqL1xuICAgICAgICBhZnRlckNsb3NlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguWumuS9jeWujOaIkOWJjeinpuWPkeeahOS6i+S7tlxuICAgICAgICAgKi9cbiAgICAgICAgYmVmb3JlUG9zaXRpb246IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5a6a5L2N5a6M5oiQ5pe26Kem5Y+R55qE5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcg5a6a5L2N55qE5Y+C5pWwXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZy5hbGlnbiDlr7npvZDmlrnlvI/vvIzlpoIgWydjYycsICdjYydd77yI5aaC5p6c5byA5ZCvIG5lZWRBZGp1c3TvvIzlj6/og73lkozpooTlhYjorr7nva7nmoQgYWxpZ24g5LiN5ZCM77yJXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcudG9wIOi3neemu+inhuWPo+mhtumDqOi3neemu1xuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLmxlZnQg6Led56a76KeG5Y+j5bem5L6n6Led56a7XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIOWumuS9jeWPgueFp+eahOWuueWZqOiKgueCuVxuICAgICAgICAgKi9cbiAgICAgICAgb25Qb3NpdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblnKjmr4/mrKHlvLnlsYLph43mlrDmuLLmn5PlkI7lvLrliLbmm7TmlrDlrprkvY3kv6Hmga/vvIzkuIDoiKznlKjkuo7lvLnlsYLlhoXlrrnljLrln5/lpKflsI/lj5HnlJ/lj5jljJbml7bvvIzku43pnIDkv53mjIHljp/mnaXnmoTlrprkvY3mlrnlvI9cbiAgICAgICAgICovXG4gICAgICAgIHNob3VsZFVwZGF0ZVBvc2l0aW9uOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguaJk+W8gOaXtuaYr+WQpuiuqeWFtuS4reeahOWFg+e0oOiHquWKqOiOt+WPlueEpueCuVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b0ZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW9k+W8ueWxgueUseS6jumhtemdoua7muWKqOetieaDheWGteS4jeWcqOWPr+inhuWMuuWfn+aXtu+8jOaYr+WQpuiHquWKqOiwg+aVtOWumuS9jeS7peWHuueOsOWcqOWPr+inhuWMuuWfn1xuICAgICAgICAgKi9cbiAgICAgICAgbmVlZEFkanVzdDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbnpoHnlKjpobXpnaLmu5rliqhcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVTY3JvbGw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6ZqQ6JeP5pe25piv5ZCm5L+d55WZ5a2Q6IqC54K5XG4gICAgICAgICAqL1xuICAgICAgICBjYWNoZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlronlhajoioLngrnvvIzlvZPngrnlh7sgZG9jdW1lbnQg55qE5pe25YCZ77yM5aaC5p6c5YyF5ZCr6K+l6IqC54K55YiZ5LiN5Lya5YWz6Zet5by55bGC77yM5aaC5p6c5piv5Ye95pWw6ZyA6KaB6L+U5ZueIHJlZu+8jOWmguaenOaYr+Wtl+espuS4suWImeaYr+ivpSBET00g55qEIGlk77yM5Lmf5Y+v5Lul55u05o6l5Lyg5YWlIERPTSDoioLngrnvvIzmiJbogIXku6XkuIrlgLznu4TmiJDnmoTmlbDnu4RcbiAgICAgICAgICovXG4gICAgICAgIHNhZmVOb2RlOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC55qE5qC56IqC54K555qE5qC35byP57G7XG4gICAgICAgICAqL1xuICAgICAgICB3cmFwcGVyQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC55qE5qC56IqC54K555qE5YaF6IGU5qC35byPXG4gICAgICAgICAqL1xuICAgICAgICB3cmFwcGVyU3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDphY3nva7liqjnlLvnmoTmkq3mlL7mlrnlvI/vvIzmlK/mjIEgeyBpbjogJ2VudGVyLWNsYXNzJywgb3V0OiAnbGVhdmUtY2xhc3MnIH0g55qE5a+56LGh5Y+C5pWw77yM5aaC5p6c6K6+572u5Li6IGZhbHNl77yM5YiZ5LiN5pKt5pS+5Yqo55S7XG4gICAgICAgICAqIEBkZWZhdWx0IHsgaW46ICdleHBhbmRJbkRvd24nLCBvdXQ6ICdleHBhbmRPdXRVcCcgfVxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0aW9uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuYm9vbF0pLFxuICAgICAgICBvbk1hc2tNb3VzZUVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25NYXNrTW91c2VMZWF2ZTogUHJvcFR5cGVzLmZ1bmNcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgICAgICBwdXJlOiBmYWxzZSxcbiAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgIG9uUmVxdWVzdENsb3NlOiBub29wLFxuICAgICAgICB0YXJnZXQ6IFBvc2l0aW9uLlZJRVdQT1JULFxuICAgICAgICBhbGlnbjogJ3RsIGJsJyxcbiAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXG4gICAgICAgIGhhc01hc2s6IGZhbHNlLFxuICAgICAgICBjYW5DbG9zZUJ5RXNjOiB0cnVlLFxuICAgICAgICBjYW5DbG9zZUJ5T3V0U2lkZUNsaWNrOiB0cnVlLFxuICAgICAgICBjYW5DbG9zZUJ5TWFzazogdHJ1ZSxcbiAgICAgICAgYmVmb3JlT3Blbjogbm9vcCxcbiAgICAgICAgb25PcGVuOiBub29wLFxuICAgICAgICBhZnRlck9wZW46IG5vb3AsXG4gICAgICAgIGJlZm9yZUNsb3NlOiBub29wLFxuICAgICAgICBvbkNsb3NlOiBub29wLFxuICAgICAgICBhZnRlckNsb3NlOiBub29wLFxuICAgICAgICBiZWZvcmVQb3NpdGlvbjogbm9vcCxcbiAgICAgICAgb25Qb3NpdGlvbjogbm9vcCxcbiAgICAgICAgb25NYXNrTW91c2VFbnRlcjogbm9vcCxcbiAgICAgICAgb25NYXNrTW91c2VMZWF2ZTogbm9vcCxcbiAgICAgICAgc2hvdWxkVXBkYXRlUG9zaXRpb246IGZhbHNlLFxuICAgICAgICBhdXRvRm9jdXM6IGZhbHNlLFxuICAgICAgICBuZWVkQWRqdXN0OiB0cnVlLFxuICAgICAgICBkaXNhYmxlU2Nyb2xsOiBmYWxzZSxcbiAgICAgICAgY2FjaGU6IGZhbHNlXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdmlzaWJsZTogcHJvcHMudmlzaWJsZSxcbiAgICAgICAgICAgIHN0YXR1czogJ25vbmUnLFxuICAgICAgICAgICAgYW5pbWF0aW9uOiB0aGlzLmdldEFuaW1hdGlvbihwcm9wcylcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmxhc3RBbGlnbiA9IHByb3BzLmFsaWduO1xuXG4gICAgICAgIGJpbmRDdHgodGhpcywgW1xuICAgICAgICAgICAgJ2hhbmRsZVBvc2l0aW9uJyxcbiAgICAgICAgICAgICdoYW5kbGVBbmltYXRlRW5kJyxcbiAgICAgICAgICAgICdoYW5kbGVEb2N1bWVudEtleURvd24nLFxuICAgICAgICAgICAgJ2hhbmRsZURvY3VtZW50Q2xpY2snLFxuICAgICAgICAgICAgJ2hhbmRsZU1hc2tDbGljaycsXG4gICAgICAgICAgICAnYmVmb3JlT3BlbicsXG4gICAgICAgICAgICAnYmVmb3JlQ2xvc2UnXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHRoaXMudGltZW91dE1hcCA9IHt9O1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMudmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5iZWZvcmVPcGVuKCk7XG4gICAgICAgICAgICB0aGlzLnByb3BzLmJlZm9yZU9wZW4oKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuYW5pbWF0aW9uICYmIHN1cHBvcnQuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50RGlkVXBkYXRlKHsgdmlzaWJsZTogZmFsc2UgfSk7XG4gICAgICAgIHRoaXMuYWRkRG9jdW1lbnRFdmVudHMoKTtcblxuICAgICAgICBvdmVybGF5TWFuYWdlci5hZGRPdmVybGF5KHRoaXMpO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBpZiAoIXRoaXMuX2lzTW91bnRlZCAmJiBuZXh0UHJvcHMudmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdpbGxPcGVuID0gIXRoaXMucHJvcHMudmlzaWJsZSAmJiBuZXh0UHJvcHMudmlzaWJsZTtcbiAgICAgICAgY29uc3Qgd2lsbENsb3NlID0gdGhpcy5wcm9wcy52aXNpYmxlICYmICFuZXh0UHJvcHMudmlzaWJsZTtcbiAgICAgICAgaWYgKHdpbGxPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLmJlZm9yZU9wZW4oKTtcbiAgICAgICAgICAgIG5leHRQcm9wcy5iZWZvcmVPcGVuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAod2lsbENsb3NlKSB7XG4gICAgICAgICAgICB0aGlzLmJlZm9yZUNsb3NlKCk7XG4gICAgICAgICAgICBuZXh0UHJvcHMuYmVmb3JlQ2xvc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0UHJvcHMuYW5pbWF0aW9uIHx8IG5leHRQcm9wcy5hbmltYXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb246IG5leHRQcm9wcy5hbmltYXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQcm9wcy5hbmltYXRpb24gIT09IGZhbHNlICYmIHN1cHBvcnQuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBpZiAod2lsbE9wZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVudGVyKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHdpbGxDbG9zZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHZpc2libGU6IG5leHRQcm9wcy52aXNpYmxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgY29uc3Qgb3BlbiA9ICFwcmV2UHJvcHMudmlzaWJsZSAmJiB0aGlzLnByb3BzLnZpc2libGU7XG4gICAgICAgIGNvbnN0IGNsb3NlID0gcHJldlByb3BzLnZpc2libGUgJiYgIXRoaXMucHJvcHMudmlzaWJsZTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuYW5pbWF0aW9uICYmIHN1cHBvcnQuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBpZiAob3BlbiB8fCBjbG9zZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQW5pbWF0aW9uRXZlbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyTm9kZSA9IHRoaXMuZ2V0V3JhcHBlck5vZGUoKTtcbiAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25PcGVuKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuYWZ0ZXJPcGVuKCk7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5hZGRDbGFzcyh3cmFwcGVyTm9kZSwgJ29wZW5lZCcpO1xuICAgICAgICAgICAgICAgICAgICBvdmVybGF5TWFuYWdlci5hZGRPdmVybGF5KHRoaXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbG9zZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25DbG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuYWZ0ZXJDbG9zZSgpO1xuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyh3cmFwcGVyTm9kZSwgJ29wZW5lZCcpO1xuICAgICAgICAgICAgICAgIG92ZXJsYXlNYW5hZ2VyLnJlbW92ZU92ZXJsYXkodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEZvY3VzTm9kZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faXNNb3VudGVkID0gZmFsc2U7XG4gICAgICAgIG92ZXJsYXlNYW5hZ2VyLnJlbW92ZU92ZXJsYXkodGhpcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlRG9jdW1lbnRFdmVudHMoKTtcbiAgICAgICAgaWYgKHRoaXMuZm9jdXNUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5mb2N1c1RpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbi5vZmYoKTtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iZWZvcmVDbG9zZSgpO1xuICAgIH1cblxuICAgIGdldEFuaW1hdGlvbihwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMuYW5pbWF0aW9uID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BzLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmFuaW1hdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmdldEFuaW1hdGlvbkJ5QWxpZ24ocHJvcHMuYWxpZ24pO1xuICAgIH1cblxuICAgIGdldEFuaW1hdGlvbkJ5QWxpZ24oYWxpZ24pIHtcbiAgICAgICAgc3dpdGNoIChhbGlnblswXSkge1xuICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW46ICdleHBhbmRJbkRvd24nLFxuICAgICAgICAgICAgICAgICAgICBvdXQ6ICdleHBhbmRPdXRVcCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW46ICdleHBhbmRJblVwJyxcbiAgICAgICAgICAgICAgICAgICAgb3V0OiAnZXhwYW5kT3V0RG93bidcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbjogJ2V4cGFuZEluRG93bicsXG4gICAgICAgICAgICAgICAgICAgIG91dDogJ2V4cGFuZE91dFVwJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRBbmltYXRpb25FdmVudHMoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0Q29udGVudE5vZGUoKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBndWlkKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb24gPSBldmVudHMub24obm9kZSwgc3VwcG9ydC5hbmltYXRpb24uZW5kLCB0aGlzLmhhbmRsZUFuaW1hdGVFbmQuYmluZCh0aGlzLCBpZCkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uRGVsYXkgPSBwYXJzZUZsb2F0KGdldFN0eWxlUHJvcGVydHkobm9kZSwgJ2FuaW1hdGlvbi1kZWxheScpKSB8fCAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9uID0gcGFyc2VGbG9hdChnZXRTdHlsZVByb3BlcnR5KG5vZGUsICdhbmltYXRpb24tZHVyYXRpb24nKSkgfHwgMDtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lID0gYW5pbWF0aW9uRGVsYXkgKyBhbmltYXRpb25EdXJhdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAodGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRNYXBbaWRdID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUFuaW1hdGVFbmQoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lICogMTAwMCArIDIwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoYW5kbGVQb3NpdGlvbihjb25maWcpIHtcbiAgICAgICAgY29uc3QgYWxpZ24gPSBjb25maWcuYWxpZ24uam9pbignICcpO1xuXG4gICAgICAgIGlmICghKCdhbmltYXRpb24nIGluIHRoaXMucHJvcHMpICYmIHRoaXMucHJvcHMubmVlZEFkanVzdCAmJiB0aGlzLmxhc3RBbGlnbiAhPT0gYWxpZ24pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogdGhpcy5nZXRBbmltYXRpb25CeUFsaWduKGFsaWduKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3RBbGlnbiA9IGFsaWduO1xuICAgIH1cblxuICAgIGhhbmRsZUFuaW1hdGVFbmQoaWQpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dE1hcFtpZF0pIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRNYXBbaWRdKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy50aW1lb3V0TWFwW2lkXTtcblxuICAgICAgICBpZiAodGhpcy5fYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRpb24ub2ZmKCk7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRpb24gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pc01vdW50ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnN0YXR1cyA9PT0gJ2xlYXZpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdub25lJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMub25MZWF2ZWQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLnN0YXR1cyA9PT0gJ2VudGVyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiAnbm9uZSdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLm9uRW50ZXJlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZW50ZXIoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHN0YXR1czogJ2VudGVyaW5nJ1xuICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBOT1RFOiBzZXRTdGF0ZSBjYWxsYmFjayAoc2Vjb25kIGFyZ3VtZW50KSBub3cgZmlyZXMgaW1tZWRpYXRlbHkgYWZ0ZXIgY29tcG9uZW50RGlkTW91bnQgLyBjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZCBvZiBhZnRlciBhbGwgY29tcG9uZW50cyBoYXZlIHJlbmRlcmVkLlxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRW50ZXJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGVhdmUoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgc3RhdHVzOiAnbGVhdmluZydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5vbkxlYXZpbmcoKTtcbiAgICB9XG5cbiAgICBvbkVudGVyaW5nKCkge1xuICAgICAgICBjb25zdCB3cmFwcGVyTm9kZSA9IHRoaXMuZ2V0V3JhcHBlck5vZGUoKTtcbiAgICAgICAgZG9tLmFkZENsYXNzKHdyYXBwZXJOb2RlLCAnb3BlbmVkJyk7XG4gICAgICAgIHRoaXMucHJvcHMub25PcGVuKCk7XG4gICAgfVxuXG4gICAgb25MZWF2aW5nKCkge1xuICAgICAgICBjb25zdCB3cmFwcGVyTm9kZSA9IHRoaXMuZ2V0V3JhcHBlck5vZGUoKTtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKHdyYXBwZXJOb2RlLCAnb3BlbmVkJyk7XG4gICAgICAgIHRoaXMucHJvcHMub25DbG9zZSgpO1xuICAgIH1cblxuICAgIG9uRW50ZXJlZCgpIHtcbiAgICAgICAgb3ZlcmxheU1hbmFnZXIuYWRkT3ZlcmxheSh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRGb2N1c05vZGUoKTtcbiAgICAgICAgdGhpcy5wcm9wcy5hZnRlck9wZW4oKTtcbiAgICB9XG5cbiAgICBvbkxlYXZlZCgpIHtcbiAgICAgICAgb3ZlcmxheU1hbmFnZXIucmVtb3ZlT3ZlcmxheSh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRGb2N1c05vZGUoKTtcbiAgICAgICAgdGhpcy5wcm9wcy5hZnRlckNsb3NlKCk7XG4gICAgfVxuXG4gICAgYmVmb3JlT3BlbigpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZVNjcm9sbCkge1xuICAgICAgICAgICAgaWYgKG1vZGFscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dZOiAnaGlkZGVuJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICAgICAgYm9keU92ZXJmbG93WSA9IGJvZHkuc3R5bGUub3ZlcmZsb3dZO1xuICAgICAgICAgICAgICAgIGlmIChoYXNTY3JvbGwoKSkge1xuICAgICAgICAgICAgICAgICAgICBib2R5UGFkZGluZ1JpZ2h0ID0gYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnBhZGRpbmdSaWdodCA9IGAke2RvbS5nZXRTdHlsZShib2R5LCAncGFkZGluZ1JpZ2h0JykgKyBkb20uc2Nyb2xsYmFyKCkud2lkdGh9cHhgO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvbS5zZXRTdHlsZShib2R5LCBzdHlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RhbHMucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJlZm9yZUNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5kaXNhYmxlU2Nyb2xsKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IG1vZGFscy5pbmRleE9mKHRoaXMpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kYWxzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93WTogYm9keU92ZXJmbG93WVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzU2Nyb2xsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLnBhZGRpbmdSaWdodCA9IGJvZHlQYWRkaW5nUmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkb20uc2V0U3R5bGUoZG9jdW1lbnQuYm9keSwgc3R5bGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGJvZHlPdmVyZmxvd1kgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlQYWRkaW5nUmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kYWxzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRGb2N1c05vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5hdXRvRm9jdXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnZpc2libGUgJiYgIXRoaXMuX2hhc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgIHNhdmVMYXN0Rm9jdXNOb2RlKCk7XG4gICAgICAgICAgICAvLyDov5nkuKrml7blgJnlvojlj6/og73kuIrkuIDkuKrlvLnlsYLnmoTlhbPpl63kuovku7bov5jmnKrop6blj5HvvIzlr7zoh7TnhKbngrnlt7Lnu4/lm57liLDop6blj5HnmoTlhYPntKBcbiAgICAgICAgICAgIC8vIOi/memHjOW7tuaXtuWkhOeQhuS4gOS4i++8jOW7tuaXtueahOaXtumXtOS4uiBkb2N1bWVudC5jbGljayDmjZXojrfop6blj5HnmoTlu7bml7bml7bpl7RcbiAgICAgICAgICAgIHRoaXMuZm9jdXNUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0Q29udGVudE5vZGUoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb2N1c05vZGVMaXN0ID0gZ2V0Rm9jdXNOb2RlTGlzdChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzTm9kZUxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c05vZGVMaXN0WzBdLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFzRm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5zdGF0ZS52aXNpYmxlICYmIHRoaXMuX2hhc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgIGJhY2tMYXN0Rm9jdXNOb2RlKCk7XG4gICAgICAgICAgICB0aGlzLl9oYXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50UmVmO1xuICAgIH1cblxuICAgIGdldENvbnRlbnROb2RlKCkge1xuICAgICAgICByZXR1cm4gZmluZERPTU5vZGUodGhpcy5jb250ZW50UmVmKTtcbiAgICB9XG5cbiAgICBnZXRXcmFwcGVyTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2F0ZXdheVJlZiA/IHRoaXMuZ2F0ZXdheVJlZi5nZXRDaGlsZE5vZGUoKSA6IG51bGw7XG4gICAgfVxuXG4gICAgYWRkRG9jdW1lbnRFdmVudHMoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmNhbkNsb3NlQnlFc2MpIHtcbiAgICAgICAgICAgIHRoaXMuX2tleWRvd25FdmVudHMgPSBldmVudHMub24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5oYW5kbGVEb2N1bWVudEtleURvd24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmNhbkNsb3NlQnlPdXRTaWRlQ2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaWNrRXZlbnRzID0gZXZlbnRzLm9uKGRvY3VtZW50LCAnY2xpY2snLCB0aGlzLmhhbmRsZURvY3VtZW50Q2xpY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlRG9jdW1lbnRFdmVudHMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9rZXlkb3duRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9rZXlkb3duRXZlbnRzLm9mZigpO1xuICAgICAgICAgICAgdGhpcy5fa2V5ZG93bkV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NsaWNrRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGlja0V2ZW50cy5vZmYoKTtcbiAgICAgICAgICAgIHRoaXMuX2NsaWNrRXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZURvY3VtZW50S2V5RG93bihlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnZpc2libGUgJiYgZS5rZXlDb2RlID09PSBLRVlDT0RFLkVTQyAmJiBvdmVybGF5TWFuYWdlci5pc0N1cnJlbnRPdmVybGF5KHRoaXMpKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uUmVxdWVzdENsb3NlKCdrZXlib2FyZCcsIGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlRG9jdW1lbnRDbGljayhlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnZpc2libGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2FmZU5vZGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBjb25zdCBzYWZlTm9kZXMgID0gQXJyYXkuaXNBcnJheShzYWZlTm9kZSkgPyBbLi4uc2FmZU5vZGVdIDogW3NhZmVOb2RlXTtcbiAgICAgICAgICAgIHNhZmVOb2Rlcy51bnNoaWZ0KCgpID0+IHRoaXMuZ2V0V3JhcHBlck5vZGUoKSk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FmZU5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGZpbmROb2RlKHNhZmVOb2Rlc1tpXSwgdGhpcy5wcm9wcyk7XG4gICAgICAgICAgICAgICAgLy8gSEFDSzog5aaC5p6c6Kem5Y+R54K55Ye755qE6IqC54K55piv5by55bGC5YaF6YOo55qE6IqC54K577yM5bm25LiU5Zyo6KKr54K55Ye75ZCO56uL5Y2z6ZSA5q+B77yM6YKj5LmI5q2k5pe25peg5rOV5L2/55SoIG5vZGUuY29udGFpbnMoZS50YXJnZXQpXG4gICAgICAgICAgICAgICAgLy8g5p2l5Yik5pat5q2k5pe254K55Ye755qE6IqC54K55piv5ZCm5piv5by55bGC5YaF6YOo55qE6IqC54K577yM6aKd5aSW5Yik5patXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgKG5vZGUgPT09IGUudGFyZ2V0IHx8IG5vZGUuY29udGFpbnMoZS50YXJnZXQpIHx8XG4gICAgICAgICAgICAgICAgKGUudGFyZ2V0ICE9PSBkb2N1bWVudCAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGUudGFyZ2V0KSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucHJvcHMub25SZXF1ZXN0Q2xvc2UoJ2RvY0NsaWNrJywgZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVNYXNrQ2xpY2soZSkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5jYW5DbG9zZUJ5TWFzaykge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblJlcXVlc3RDbG9zZSgnbWFza0NsaWNrJywgZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzYXZlQ29udGVudFJlZiA9IChyZWYpID0+IHtcbiAgICAgICAgdGhpcy5jb250ZW50UmVmID0gcmVmO1xuICAgIH1cblxuICAgIHNhdmVHYXRld2F5UmVmID0gKHJlZikgPT4ge1xuICAgICAgICB0aGlzLmdhdGV3YXlSZWYgPSByZWY7XG4gICAgfVxuXG4gICAgLy8g5YW85a656L+H5Y6755qE55So5rOVOiB0aGlzLnBvcHVwUmVmLmdldEluc3RhbmNlKCkub3ZlcmxheS5nZXRJbnN0YW5jZSgpLmdldENvbnRlbnROb2RlKClcbiAgICBnZXRJbnN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBwcmVmaXgsIGNsYXNzTmFtZSwgc3R5bGUsIGNoaWxkcmVuOiBwcm9wQ2hpbGRyZW4sXG4gICAgICAgICAgICB0YXJnZXQsIGFsaWduLCBvZmZzZXQsIGNvbnRhaW5lciwgaGFzTWFzaywgbmVlZEFkanVzdCxcbiAgICAgICAgICAgIGJlZm9yZVBvc2l0aW9uLCBvblBvc2l0aW9uLCB3cmFwcGVyU3R5bGUsIHJ0bCxcbiAgICAgICAgICAgIHNob3VsZFVwZGF0ZVBvc2l0aW9uOiBwcm9wU2hvdWxkVXBkYXRlUG9zaXRpb24sXG4gICAgICAgICAgICBjYWNoZSwgd3JhcHBlckNsYXNzTmFtZSwgb25NYXNrTW91c2VFbnRlciwgb25NYXNrTW91c2VMZWF2ZVxuICAgICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyB2aXNpYmxlOiBzdGF0ZVZpc2libGUsIHN0YXR1cywgYW5pbWF0aW9uIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHN0YXRlVmlzaWJsZSB8fCAoY2FjaGUgJiYgdGhpcy5faXNNb3VudGVkKSA/IHByb3BDaGlsZHJlbiA6IG51bGw7XG4gICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBDaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ2xhenogPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4fW92ZXJsYXktaW5uZXJgXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBbYW5pbWF0aW9uLmluXTogc3RhdHVzID09PSAnZW50ZXJpbmcnLFxuICAgICAgICAgICAgICAgIFthbmltYXRpb24ub3V0XTogc3RhdHVzID09PSAnbGVhdmluZycsXG4gICAgICAgICAgICAgICAgW2NoaWxkLnByb3BzLmNsYXNzTmFtZV06ICEhY2hpbGQucHJvcHMuY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIFtjbGFzc05hbWVdOiAhIWNsYXNzTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkLnJlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3Qgc2V0IHJlZiBieSBzdHJpbmcgaW4gT3ZlcmxheSwgdXNlIGZ1bmN0aW9uIGluc3RlYWQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkcmVuID0gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjaGlsZENsYXp6LFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7Li4uY2hpbGQucHJvcHMuc3R5bGUsIC4uLnN0eWxlfSxcbiAgICAgICAgICAgICAgICByZWY6IG1ha2VDaGFpbih0aGlzLnNhdmVDb250ZW50UmVmLCBjaGlsZC5yZWYpLFxuICAgICAgICAgICAgICAgICdhcmlhLWhpZGRlbic6ICFzdGF0ZVZpc2libGUgJiYgY2FjaGUgJiYgdGhpcy5faXNNb3VudGVkXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGFsaWduKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkVXBkYXRlUG9zaXRpb24gPSBzdGF0dXMgPT09ICdsZWF2aW5nJyA/IGZhbHNlIDogcHJvcFNob3VsZFVwZGF0ZVBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gKFxuICAgICAgICAgICAgICAgICAgICA8UG9zaXRpb24gey4uLih7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiwgdGFyZ2V0LCBhbGlnbiwgb2Zmc2V0LCBuZWVkQWRqdXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlUG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBvblBvc2l0aW9uOiBtYWtlQ2hhaW4odGhpcy5oYW5kbGVQb3NpdGlvbiwgb25Qb3NpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVQb3NpdGlvbiwgcnRsXG4gICAgICAgICAgICAgICAgICAgIH0pfSAvPlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXJDbGF6eiA9IGNsYXNzbmFtZXMoW1xuICAgICAgICAgICAgICAgIGAke3ByZWZpeH1vdmVybGF5LXdyYXBwZXJgLFxuICAgICAgICAgICAgICAgIHdyYXBwZXJDbGFzc05hbWVcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgY29uc3QgbmV3V3JhcHBlclN0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IHN0YXRlVmlzaWJsZSA/ICcnIDogJ25vbmUnXG4gICAgICAgICAgICB9LCB3cmFwcGVyU3R5bGUpO1xuXG4gICAgICAgICAgICBjaGlsZHJlbiA9IChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17d3JhcHBlckNsYXp6fSBzdHlsZT17bmV3V3JhcHBlclN0eWxlfSBkaXI9e3J0bCA/ICdydGwnIDogdW5kZWZpbmVkfT5cbiAgICAgICAgICAgICAgICAgICAge2hhc01hc2sgP1xuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH1vdmVybGF5LWJhY2tkcm9wYH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZU1hc2tDbGlja31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXI9e29uTWFza01vdXNlRW50ZXJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXtvbk1hc2tNb3VzZUxlYXZlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcj17cnRsID8gJ3J0bCcgOiB1bmRlZmluZWR9IC8+IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGx9XG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gPEdhdGV3YXkgey4uLih7Y29udGFpbmVyLCB0YXJnZXQsIGNoaWxkcmVufSl9IHJlZj17dGhpcy5zYXZlR2F0ZXdheVJlZn0gLz47XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL292ZXJsYXkvb3ZlcmxheS5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZpbmRET01Ob2RlLCBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGZ1bmMgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBmaW5kTm9kZSBmcm9tICcuL3V0aWxzL2ZpbmQtbm9kZSc7XG5cbmNvbnN0IHsgbWFrZUNoYWluIH0gPSBmdW5jO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYXRld2F5IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIGNvbnRhaW5lcjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgdGFyZ2V0OiBQcm9wVHlwZXMuYW55LFxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBjb250YWluZXI6ICgpID0+IGRvY3VtZW50LmJvZHlcbiAgICB9O1xuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyTm9kZSA9IHRoaXMuZ2V0Q29udGFpbmVyTm9kZSh0aGlzLnByb3BzKTtcbiAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyTm9kZSA9IHRoaXMuZ2V0Q29udGFpbmVyTm9kZShuZXh0UHJvcHMpO1xuICAgIH1cblxuICAgIGdldENvbnRhaW5lck5vZGUocHJvcHMpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IGZpbmROb2RlKHByb3BzLnRhcmdldCk7XG4gICAgICAgIHJldHVybiBmaW5kTm9kZShwcm9wcy5jb250YWluZXIsIHRhcmdldE5vZGUpO1xuICAgIH1cblxuICAgIGdldENoaWxkTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRET01Ob2RlKHRoaXMuY2hpbGQpO1xuICAgIH1cblxuICAgIHNhdmVDaGlsZFJlZiA9IHJlZiA9PiB7XG4gICAgICAgIHRoaXMuY2hpbGQgPSByZWY7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlbiA/IENoaWxkcmVuLm9ubHkoY2hpbGRyZW4pIDogbnVsbDtcbiAgICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkLnJlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBzZXQgcmVmIGJ5IHN0cmluZyBpbiBHYXRld2F5LCB1c2UgZnVuY3Rpb24gaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZCA9IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgICAgcmVmOiBtYWtlQ2hhaW4odGhpcy5zYXZlQ2hpbGRSZWYsIGNoaWxkLnJlZilcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZCwgdGhpcy5jb250YWluZXJOb2RlKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvb3ZlcmxheS9nYXRld2F5LmpzeCIsImltcG9ydCB7IENvbXBvbmVudCwgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmaW5kRE9NTm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgZnVuYywgZG9tLCBldmVudHMgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBwb3NpdGlvbiBmcm9tICcuL3V0aWxzL3Bvc2l0aW9uJztcbmltcG9ydCBmaW5kTm9kZSBmcm9tICcuL3V0aWxzL2ZpbmQtbm9kZSc7XG5cbmNvbnN0IHsgbm9vcCwgYmluZEN0eCB9ID0gZnVuYztcbmNvbnN0IHsgZ2V0U3R5bGUgfSA9IGRvbTtcbmNvbnN0IHBsYWNlID0gcG9zaXRpb24ucGxhY2U7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc2l0aW9uIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgVklFV1BPUlQgPSBwb3NpdGlvbi5WSUVXUE9SVDtcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgdGFyZ2V0OiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBhbGlnbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmJvb2xdKSxcbiAgICAgICAgb2Zmc2V0OiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIGJlZm9yZVBvc2l0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25Qb3NpdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG5lZWRBZGp1c3Q6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBuZWVkTGlzdGVuUmVzaXplOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgc2hvdWxkVXBkYXRlUG9zaXRpb246IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBydGw6IFByb3BUeXBlcy5ib29sXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGFsaWduOiAndGwgYmwnLFxuICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgYmVmb3JlUG9zaXRpb246IG5vb3AsXG4gICAgICAgIG9uUG9zaXRpb246IG5vb3AsXG4gICAgICAgIG5lZWRBZGp1c3Q6IHRydWUsXG4gICAgICAgIG5lZWRMaXN0ZW5SZXNpemU6IHRydWUsXG4gICAgICAgIHNob3VsZFVwZGF0ZVBvc2l0aW9uOiBmYWxzZSxcbiAgICAgICAgcnRsOiBmYWxzZSxcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIGJpbmRDdHgodGhpcywgWydoYW5kbGVSZXNpemUnXSk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oKTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5uZWVkTGlzdGVuUmVzaXplKSB7XG4gICAgICAgICAgICBldmVudHMub24od2luZG93LCAncmVzaXplJywgdGhpcy5oYW5kbGVSZXNpemUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKCdhbGlnbicgaW4gbmV4dFByb3BzICYmIG5leHRQcm9wcy5hbGlnbiAhPT0gdGhpcy5wcm9wcy5hbGlnbiB8fCBuZXh0UHJvcHMuc2hvdWxkVXBkYXRlUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkVXBkYXRlUG9zaXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRVcGRhdGVQb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRVcGRhdGVQb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm5lZWRMaXN0ZW5SZXNpemUpIHtcbiAgICAgICAgICAgIGV2ZW50cy5vZmYod2luZG93LCAncmVzaXplJywgdGhpcy5oYW5kbGVSZXNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG4gICAgfVxuXG4gICAgc2V0UG9zaXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgYWxpZ24sIG9mZnNldCwgYmVmb3JlUG9zaXRpb24sIG9uUG9zaXRpb24sIG5lZWRBZGp1c3QsIHJ0bCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBiZWZvcmVQb3NpdGlvbigpO1xuXG4gICAgICAgIGNvbnN0IGNvbnRlbnROb2RlID0gdGhpcy5nZXRDb250ZW50Tm9kZSgpO1xuICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gdGhpcy5nZXRUYXJnZXROb2RlKCk7XG4gICAgICAgIGlmIChjb250ZW50Tm9kZSAmJiB0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRBbGlnbiA9IHBsYWNlKHtcbiAgICAgICAgICAgICAgICBwaW5FbGVtZW50OiBjb250ZW50Tm9kZSxcbiAgICAgICAgICAgICAgICBiYXNlRWxlbWVudDogdGFyZ2V0Tm9kZSxcbiAgICAgICAgICAgICAgICBhbGlnbixcbiAgICAgICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICAgICAgbmVlZEFkanVzdCxcbiAgICAgICAgICAgICAgICBpc1J0bDogcnRsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSBnZXRTdHlsZShjb250ZW50Tm9kZSwgJ3RvcCcpO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGdldFN0eWxlKGNvbnRlbnROb2RlLCAnbGVmdCcpO1xuXG4gICAgICAgICAgICBvblBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgICBhbGlnbjogcmVzdWx0QWxpZ24uc3BsaXQoJyAnKSxcbiAgICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgICAgbGVmdFxuICAgICAgICAgICAgfSwgY29udGVudE5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Q29udGVudE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgICB9XG5cbiAgICBnZXRUYXJnZXROb2RlKCkge1xuICAgICAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICByZXR1cm4gdGFyZ2V0ID09PSBwb3NpdGlvbi5WSUVXUE9SVCA/IHBvc2l0aW9uLlZJRVdQT1JUIDogZmluZE5vZGUodGFyZ2V0LCB0aGlzLnByb3BzKTtcbiAgICB9XG5cbiAgICBoYW5kbGVSZXNpemUoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVvdXQpO1xuXG4gICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbigpO1xuICAgICAgICB9LCAyMDApO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIENoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL292ZXJsYXkvcG9zaXRpb24uanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBGaWx0ZXJDb21wb25lbnQgZnJvbSAnLi9maWx0ZXInO1xuaW1wb3J0IFNvcnRDb21wb25lbnQgZnJvbSAnLi9zb3J0JztcbmltcG9ydCBDZWxsQ29tcG9uZW50IGZyb20gJy4vY2VsbCc7XG5pbXBvcnQgUmVzaXplQ29tcG9uZW50IGZyb20gJy4vcmVzaXplJztcblxuY29uc3Qgbm9vcCA9ICgpID0+IHsgfTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlYWRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcHVyZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY29tcG9uZW50OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjb2x1bW5zOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIGNvbEdyb3VwOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBoZWFkZXJDZWxsUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgbG9jYWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBmaWx0ZXJQYXJhbXM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIG9uRmlsdGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgY29tcG9uZW50czogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgc29ydDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgb25Tb3J0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25SZXNpemVDaGFuZ2U6IFByb3BUeXBlcy5mdW5jXG4gICAgfVxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGNvbXBvbmVudDogJ3RoZWFkJyxcbiAgICAgICAgY29sdW1uczogW10sXG4gICAgICAgIGhlYWRlckNlbGxSZWY6IG5vb3AsXG4gICAgICAgIG9uRmlsdGVyOiBub29wLFxuICAgICAgICBjb21wb25lbnRzOiB7fSxcbiAgICAgICAgb25Tb3J0OiBub29wLFxuICAgICAgICBvblJlc2l6ZUNoYW5nZTogbm9vcFxuICAgIH1cblxuICAgIGdldENlbGxSZWYgPSAoaSwgaiwgY2VsbCkgPT4ge1xuICAgICAgICB0aGlzLnByb3BzLmhlYWRlckNlbGxSZWYoaSwgaiwgY2VsbCk7XG4gICAgfVxuXG4gICAgb25Tb3J0ID0gKGRhdGFJbmRleCwgb3JkZXIsIHNvcnQpID0+IHtcbiAgICAgICAgdGhpcy5wcm9wcy5vblNvcnQoZGF0YUluZGV4LCBvcmRlciwgc29ydCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvKmVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBjbGFzc05hbWUsIGNoaWxkcmVuLCBjb21wb25lbnQ6IFRhZywgY29sR3JvdXAsIGNvbHVtbnMsIGxvY2FsZSwgZmlsdGVyUGFyYW1zLFxuICAgICAgICAgICAgb25GaWx0ZXIsIGNvbXBvbmVudHMsIGFmZml4UmVmLCBoZWFkZXJDZWxsUmVmLCBvblNvcnQsIHNvcnQsIG9uUmVzaXplQ2hhbmdlLCBwdXJlLCAuLi5vdGhlcnNcbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgY29uc3QgeyBDZWxsID0gQ2VsbENvbXBvbmVudCwgRmlsdGVyID0gRmlsdGVyQ29tcG9uZW50LCBTb3J0ID0gU29ydENvbXBvbmVudCwgUmVzaXplID0gUmVzaXplQ29tcG9uZW50IH0gPSBjb21wb25lbnRzO1xuICAgICAgICBjb25zdCByb3dTcGFuID0gY29sdW1ucy5sZW5ndGg7XG5cbiAgICAgICAgY29uc3QgaGVhZGVyID0gY29sdW1ucy5tYXAoKGNvbHMsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2wgPSBjb2xzLm1hcCgoY29sLCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIHByZWZlci1jb25zdCAqL1xuICAgICAgICAgICAgICAgIGxldCB7IHRpdGxlLCBjb2xTcGFuLCBzb3J0YWJsZSwgcmVzaXphYmxlLCBkYXRhSW5kZXgsIGZpbHRlcnMsIGZpbHRlck1vZGUsIHdpZHRoLCBhbGlnbiwgY2xhc3NOYW1lLCBfX25vcm1hbGl6ZWQsIGxvY2ssIC4uLm90aGVycyB9ID0gY29sO1xuXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9dGFibGUtaGVhZGVyLW5vZGVgXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgW2Ake3ByZWZpeH10YWJsZS1oZWFkZXItcmVzaXphYmxlYF06IHJlc2l6YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgW2NsYXNzTmFtZV06IGNsYXNzTmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCBhdHRycyA9IHt9LCBzb3J0RWxlbWVudCwgZmlsdGVyRWxlbWVudCwgcmVzaXplRWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoY29sLmNoaWxkcmVuICYmIGNvbC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuY29sU3BhbiA9IGNvbFNwYW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0RWxlbWVudCA9ICg8U29ydCBwcmVmaXg9e3ByZWZpeH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSW5kZXg9e2RhdGFJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblNvcnQ9e3RoaXMub25Tb3J0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnQ9e3NvcnR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlPXtsb2NhbGV9Lz4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNpemFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZUVsZW1lbnQgPSA8UmVzaXplIHByZWZpeD17cHJlZml4fSBkYXRhSW5kZXg9e2RhdGFJbmRleH0gb25DaGFuZ2U9e29uUmVzaXplQ2hhbmdlfS8+O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlckVsZW1lbnQgPSBmaWx0ZXJzLmxlbmd0aCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDxGaWx0ZXIgZGF0YUluZGV4PXtkYXRhSW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcnM9e2ZpbHRlcnN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeD17cHJlZml4fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU9e2xvY2FsZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyUGFyYW1zPXtmaWx0ZXJQYXJhbXN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlck1vZGU9e2ZpbHRlck1vZGV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRmlsdGVyPXtvbkZpbHRlcn0gLz4pIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhdHRycy5yb3dTcGFuID0gcm93U3BhbiAtIGluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKDxDZWxsIHsuLi5vdGhlcnN9IHsuLi5hdHRyc31cbiAgICAgICAgICAgICAgICAgICAga2V5PXtqfVxuICAgICAgICAgICAgICAgICAgICBwcmVmaXg9e3ByZWZpeH1cbiAgICAgICAgICAgICAgICAgICAgcHVyZT17cHVyZX1cbiAgICAgICAgICAgICAgICAgICAgY2VsbD17dGl0bGV9XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudD1cInRoXCJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ249e2FsaWdufVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgICAgICAgICAgICAgICAgcmVmPXt0aGlzLmdldENlbGxSZWYuYmluZCh0aGlzLCBpbmRleCwgail9XG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJoZWFkZXJcIj5cbiAgICAgICAgICAgICAgICAgICAge3NvcnRFbGVtZW50fXtmaWx0ZXJFbGVtZW50fXtyZXNpemVFbGVtZW50fVxuICAgICAgICAgICAgICAgIDwvQ2VsbD4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gPHRyIGtleT17aW5kZXh9Pntjb2x9PC90cj47XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAoPFRhZyBjbGFzc05hbWU9e2NsYXNzTmFtZX0gey4uLm90aGVyc30+XG4gICAgICAgICAgICB7aGVhZGVyfVxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L1RhZz4pO1xuICAgIH1cbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2Jhc2UvaGVhZGVyLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IERyb3Bkb3duIGZyb20gJy4uLy4uL2Ryb3Bkb3duJztcbmltcG9ydCBNZW51IGZyb20gJy4uLy4uL21lbnUnO1xuaW1wb3J0IEJ1dHRvbiBmcm9tICcuLi8uLi9idXR0b24nO1xuaW1wb3J0IEljb24gZnJvbSAnLi4vLi4vaWNvbic7XG5pbXBvcnQgeyBLRVlDT0RFIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5cbi8vIOWFseS6q+eKtuaAgeeahOe7hOS7tumcgOimgeWPmOaIkOmdnuWPl+aOp+e7hOS7tlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsdGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBkYXRhSW5kZXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGZpbHRlcnM6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgZmlsdGVyTW9kZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgZmlsdGVyUGFyYW1zOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBsb2NhbGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIG9uRmlsdGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nXG4gICAgfVxuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgb25GaWx0ZXI6ICgpID0+IHt9XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICBjb25zdCBmaWx0ZXJQYXJhbXMgPSBwcm9wcy5maWx0ZXJQYXJhbXMgfHwge307XG4gICAgICAgIGNvbnN0IGZpbHRlckNvbmZpZyA9IGZpbHRlclBhcmFtc1twcm9wcy5kYXRhSW5kZXhdIHx8IHt9O1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdmlzaWJsZTogZmlsdGVyQ29uZmlnLnZpc2libGUgfHwgZmFsc2UsXG4gICAgICAgICAgICBzZWxlY3RlZEtleXM6IGZpbHRlckNvbmZpZy5zZWxlY3RlZEtleXMgfHwgW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRLZXlzID0gWy4uLnRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzXTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KCdmaWx0ZXJQYXJhbXMnKSAmJiB0eXBlb2YgbmV4dFByb3BzLmZpbHRlclBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFJbmRleCA9IG5leHRQcm9wcy5kYXRhSW5kZXggfHwgdGhpcy5wcm9wcy5kYXRhSW5kZXg7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJQYXJhbXMgPSBuZXh0UHJvcHMuZmlsdGVyUGFyYW1zIHx8IHt9O1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyQ29uZmlnID0gZmlsdGVyUGFyYW1zW2RhdGFJbmRleF0gfHwge307XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZEtleXMgPSBmaWx0ZXJDb25maWcuc2VsZWN0ZWRLZXlzIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRLZXlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkS2V5cyA9IFsuLi5zZWxlY3RlZEtleXNdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmlsdGVyS2V5ZG93biA9IGUgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERS5FTlRFUikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgdmlzaWJsZTogIXRoaXMuc3RhdGUudmlzaWJsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkZpbHRlclZpc2libGUgPSAodmlzaWJsZSkgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHZpc2libGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZEtleXMgPSBbLi4udGhpcy5fc2VsZWN0ZWRLZXlzXTtcblxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRLZXlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uRmlsdGVyU2VsZWN0ID0gKHNlbGVjdGVkS2V5cykgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgICAgICBzZWxlY3RlZEtleXNcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25GaWx0ZXJDb25maXJtID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBzZWxlY3RlZEtleXMgPSB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cztcbiAgICAgICAgY29uc3QgZmlsdGVyUGFyYW1zID0ge30sIHsgZGF0YUluZGV4IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGZpbHRlclBhcmFtc1tkYXRhSW5kZXhdID0ge1xuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBzZWxlY3RlZEtleXM6IHNlbGVjdGVkS2V5c1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZWxlY3RlZEtleXMgPSBbLi4uc2VsZWN0ZWRLZXlzXTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8g5YW85a655LmL5YmN55qE5qC85byPXG4gICAgICAgIHRoaXMucHJvcHMub25GaWx0ZXIoZmlsdGVyUGFyYW1zKTtcbiAgICB9XG5cbiAgICBvbkZpbHRlckNsZWFyID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBmaWx0ZXJQYXJhbXMgPSB7fSwgeyBkYXRhSW5kZXggfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgZmlsdGVyUGFyYW1zW2RhdGFJbmRleF0gPSB7XG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHNlbGVjdGVkS2V5czogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRLZXlzID0gW107XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgc2VsZWN0ZWRLZXlzOiBbXSxcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyDlhbzlrrnkuYvliY3nmoTmoLzlvI9cbiAgICAgICAgdGhpcy5wcm9wcy5vbkZpbHRlcihmaWx0ZXJQYXJhbXMpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBmaWx0ZXJzLCBwcmVmaXgsIGxvY2FsZSwgZmlsdGVyTW9kZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyB2aXNpYmxlLCBzZWxlY3RlZEtleXMgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVuZGVyTWVudUl0ZW0oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIDxNZW51Lkl0ZW0ga2V5PXtpdGVtLnZhbHVlfT57aXRlbS5sYWJlbH08L01lbnUuSXRlbT47XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZW5kZXJTdWJNZW51KHBhcmVudCwgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPE1lbnUuU3ViTWVudSBsYWJlbD17cGFyZW50LmxhYmVsfSBrZXk9e3BhcmVudC52YWx1ZX0gc2VsZWN0YWJsZT17ZmFsc2V9PlxuICAgICAgICAgICAgICAgICAgICB7cmVuZGVyTWVudUNvbnRlbnQoY2hpbGRyZW4pfVxuICAgICAgICAgICAgICAgIDwvTWVudS5TdWJNZW51PlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbmRlck1lbnVDb250ZW50KGxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0Lm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyU3ViTWVudShpdGVtLCBpdGVtLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyTWVudUl0ZW0oaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250ZW50ID0gcmVuZGVyTWVudUNvbnRlbnQoZmlsdGVycyksXG4gICAgICAgICAgICBmb290ZXIgPSAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1maWx0ZXItZm9vdGVyYH0+XG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b24gdHlwZT1cInByaW1hcnlcIiBvbkNsaWNrPXt0aGlzLm9uRmlsdGVyQ29uZmlybX0+e2xvY2FsZS5va308L0J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXt0aGlzLm9uRmlsdGVyQ2xlYXJ9Pntsb2NhbGUucmVzZXR9PC9CdXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8RHJvcGRvd24gdHJpZ2dlcj17XG4gICAgICAgICAgICAgICAgPHNwYW4gcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e2xvY2FsZS5maWx0ZXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uS2V5RG93bj17dGhpcy5maWx0ZXJLZXlkb3dufVxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleD1cIjBcIlxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1maWx0ZXJgfT5cbiAgICAgICAgICAgICAgICAgICAgPEljb24gdHlwZT1cImZpbHRlclwiIHNpemU9XCJzbWFsbFwiIC8+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlclR5cGU9XCJjbGlja1wiXG4gICAgICAgICAgICB2aXNpYmxlPXt2aXNpYmxlfVxuICAgICAgICAgICAgYXV0b0ZvY3VzXG4gICAgICAgICAgICBjb250YWluZXI9e25vZGUgPT4gbm9kZS5wYXJlbnROb2RlfVxuICAgICAgICAgICAgb25WaXNpYmxlQ2hhbmdlPXt0aGlzLm9uRmlsdGVyVmlzaWJsZX0+XG4gICAgICAgICAgICAgICAgPE1lbnUgZm9vdGVyPXtmb290ZXJ9XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkS2V5cz17c2VsZWN0ZWRLZXlzfVxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RNb2RlPXtmaWx0ZXJNb2RlfVxuICAgICAgICAgICAgICAgICAgICBvblNlbGVjdD17dGhpcy5vbkZpbHRlclNlbGVjdH0+XG4gICAgICAgICAgICAgICAgICAgIHtjb250ZW50fVxuICAgICAgICAgICAgICAgIDwvTWVudT5cbiAgICAgICAgICAgIDwvRHJvcGRvd24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2Jhc2UvZmlsdGVyLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIENoaWxkcmVuLCBjbG9uZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmaW5kRE9NTm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgZnVuYywgb2JqLCBLRVlDT0RFIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5cbmNvbnN0IHsgYmluZEN0eCB9ID0gZnVuYztcbmNvbnN0IHsgcGlja090aGVycyB9ID0gb2JqO1xuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG4vKipcbiAqIE1lbnVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVudSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGlzTmV4dE1lbnUgPSB0cnVlO1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBwdXJlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgcnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog6I+c5Y2V6aG55ZKM5a2Q6I+c5Y2VXG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDngrnlh7voj5zljZXpobnop6blj5HnmoTlm57osIPlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSDngrnlh7vnmoToj5zljZXpobnnmoQga2V5IOWAvFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSDngrnlh7vnmoToj5zljZXpobnlr7nosaFcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOeCueWHu+eahOS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgb25JdGVtQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5b2T5YmN5omT5byA55qE5a2Q6I+c5Y2V55qEIGtleSDlgLxcbiAgICAgICAgICovXG4gICAgICAgIG9wZW5LZXlzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYXJyYXldKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIneWni+aJk+W8gOeahOWtkOiPnOWNleeahCBrZXkg5YC8XG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0T3BlbktleXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5hcnJheV0pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5Yid5aeL5bGV5byA5omA5pyJ55qE5a2Q6I+c5Y2V77yM5Y+q5ZyoIG1vZGUg6K6+572u5Li6ICdpbmxpbmUnIOS7peWPiiBvcGVuTW9kZSDorr7nva7kuLogJ211bHRpcGxlJyDkuIvnlJ/mlYjvvIzkvJjlhYjnuqfpq5jkuo4gZGVmYXVsdE9wZW5LZXlzXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0T3BlbkFsbDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmiZPlvIDmiJblhbPpl63lrZDoj5zljZXop6blj5HnmoTlm57osIPlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSDmiZPlvIDnmoTmiYDmnInlrZDoj5zljZXnmoQga2V5IOWAvFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXh0cmEg6aKd5aSW5Y+C5pWwXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBleHRyYS5rZXkg5b2T5YmN5pON5L2c5a2Q6I+c5Y2V55qEIGtleSDlgLxcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBleHRyYS5vcGVuIOaYr+WQpuaYr+aJk+W8gFxuICAgICAgICAgKi9cbiAgICAgICAgb25PcGVuOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWtkOiPnOWNleaJk+W8gOeahOaooeW8j1xuICAgICAgICAgKi9cbiAgICAgICAgbW9kZTogUHJvcFR5cGVzLm9uZU9mKFsnaW5saW5lJywgJ3BvcHVwJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5a2Q6I+c5Y2V5omT5byA55qE6Kem5Y+R6KGM5Li6XG4gICAgICAgICAqL1xuICAgICAgICB0cmlnZ2VyVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnY2xpY2snLCAnaG92ZXInXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlsZXlvIDlhoXov57lrZDoj5zljZXnmoTmqKHlvI/vvIzlkIzml7blj6/ku6XlsZXlvIDkuIDkuKrlrZDoj5zljZXov5jmmK/lpJrkuKrlrZDoj5zljZXvvIzor6XlsZ7mgKfku4XlnKggbW9kZSDkuLogaW5saW5lIOaXtueUn+aViFxuICAgICAgICAgKi9cbiAgICAgICAgb3Blbk1vZGU6IFByb3BUeXBlcy5vbmVPZihbJ3NpbmdsZScsICdtdWx0aXBsZSddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWGhei/nuWtkOiPnOWNlee8qei/m+i3neemu1xuICAgICAgICAgKi9cbiAgICAgICAgaW5saW5lSW5kZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBpbmxpbmVBcnJvd0RpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsnZG93bicsICdyaWdodCddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuiHquWKqOiuqeW8ueWxgueahOWuveW6puWSjOiPnOWNlemhueS/neaMgeS4gOiHtO+8jOWmguaenOW8ueWxgueahOWuveW6puavlOiPnOWNlemhueWwj+WImeWSjOiPnOWNlemhueS/neaMgeS4gOiHtO+8jOWmguaenOWuveW6puWkp+S6juiPnOWNlemhueWImeS4jeWBmuWkhOeQhlxuICAgICAgICAgKi9cbiAgICAgICAgcG9wdXBBdXRvV2lkdGg6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC55qE5a+56b2Q5pa55byPXG4gICAgICAgICAqL1xuICAgICAgICBwb3B1cEFsaWduOiBQcm9wVHlwZXMub25lT2YoWydmb2xsb3cnLCAnb3V0c2lkZSddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguiHquWumuS5iSBwcm9wc1xuICAgICAgICAgKi9cbiAgICAgICAgcG9wdXBQcm9wczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWHuuWtkOiPnOWNleiHquWumuS5iSBjbGFzc05hbWVcbiAgICAgICAgICovXG4gICAgICAgIHBvcHVwQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55Ye65a2Q6I+c5Y2V6Ieq5a6a5LmJIHN0eWxlXG4gICAgICAgICAqL1xuICAgICAgICBwb3B1cFN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAvKipcbiAgICAgICAgICog5b2T5YmN6YCJ5Lit6I+c5Y2V6aG555qEIGtleSDlgLxcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGVkS2V5czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmFycmF5XSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliJ3lp4vpgInkuK3oj5zljZXpobnnmoQga2V5IOWAvFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdFNlbGVjdGVkS2V5czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmFycmF5XSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpgInkuK3miJblj5bmtojpgInkuK3oj5zljZXpobnop6blj5HnmoTlm57osIPlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWRLZXlzIOmAieS4reeahOaJgOacieiPnOWNlemhueeahOWAvFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSDpgInkuK3miJblj5bmtojpgInkuK3nmoToj5zljZXpoblcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV4dHJhIOmineWkluWPguaVsFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV4dHJhLnNlbGVjdCDmmK/lkKbmmK/pgInkuK1cbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gZXh0cmEua2V5IOiPnOWNlemhueeahCBrZXlcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV4dHJhLmxhYmVsIOiPnOWNlemhueeahOaWh+acrFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBleHRyYS5rZXlQYXRoIOiPnOWNlemhuSBrZXkg55qE6Lev5b6EXG4gICAgICAgICAqL1xuICAgICAgICBvblNlbGVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpgInkuK3mqKHlvI/vvIzljZXpgInov5jmmK/lpJrpgInvvIzpu5jorqTml6DlgLzvvIzkuI3lj6/pgIlcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdE1vZGU6IFByb3BUeXBlcy5vbmVPZihbJ3NpbmdsZScsICdtdWx0aXBsZSddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuWPquiDvemAieaLqeesrOS4gOWxguiPnOWNlemhue+8iOS4jeiDvemAieaLqeWtkOiPnOWNleS4reeahOiPnOWNlemhue+8iVxuICAgICAgICAgKi9cbiAgICAgICAgc2hhbGxvd1NlbGVjdDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbmmL7npLrpgInkuK3lm77moIfvvIzlpoLmnpzorr7nva7kuLogZmFsc2Ug6ZyA6YWN5ZCI6YWN572u5bmz5Y+w6K6+572u6YCJ5Lit5pe255qE6IOM5pmv6Imy5Lul56S65Yy65YiGXG4gICAgICAgICAqL1xuICAgICAgICBoYXNTZWxlY3RlZEljb246IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBsYWJlbFRvZ2dsZUNoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6I+c5Y2V56ys5LiA5bGC5bGV56S65pa55ZCRXG4gICAgICAgICAqL1xuICAgICAgICBkaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbJ3ZlcicsICdob3onXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmqKrlkJHoj5zljZXmnaEgaXRlbSDlkowgZm9vdGVyIOeahOWvuem9kOaWueWQke+8jOWcqCBkaXJlY3Rpb24g6K6+572u5Li6ICdob3onIOW5tuS4lCBoZWFkZXIg5a2Y5Zyo5pe255Sf5pWIXG4gICAgICAgICAqL1xuICAgICAgICBob3pBbGlnbjogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsICdyaWdodCddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieiPnOWNleWktOmDqFxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGVyOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieiPnOWNleWwvumDqFxuICAgICAgICAgKi9cbiAgICAgICAgZm9vdGVyOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuiHquWKqOiOt+W+l+eEpueCuVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b0ZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW9k+WJjeiOt+W+l+eEpueCueeahOWtkOiPnOWNleaIluiPnOWNlemhuSBrZXkg5YC8XG4gICAgICAgICAqL1xuICAgICAgICBmb2N1c2VkS2V5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBmb2N1c2FibGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBvbkl0ZW1Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uQmx1cjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uSXRlbUtleURvd246IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBleHBhbmRBbmltYXRpb246IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBpdGVtQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHByZWZpeDogJ25leHQtJyxcbiAgICAgICAgcHVyZTogZmFsc2UsXG4gICAgICAgIGRlZmF1bHRPcGVuS2V5czogW10sXG4gICAgICAgIGRlZmF1bHRPcGVuQWxsOiBmYWxzZSxcbiAgICAgICAgb25PcGVuOiBub29wLFxuICAgICAgICBtb2RlOiAnaW5saW5lJyxcbiAgICAgICAgdHJpZ2dlclR5cGU6ICdjbGljaycsXG4gICAgICAgIG9wZW5Nb2RlOiAnbXVsdGlwbGUnLFxuICAgICAgICBpbmxpbmVJbmRlbnQ6IDIwLFxuICAgICAgICBpbmxpbmVBcnJvd0RpcmVjdGlvbjogJ2Rvd24nLFxuICAgICAgICBwb3B1cEF1dG9XaWR0aDogZmFsc2UsXG4gICAgICAgIHBvcHVwQWxpZ246ICdmb2xsb3cnLFxuICAgICAgICBwb3B1cFByb3BzOiB7fSxcbiAgICAgICAgZGVmYXVsdFNlbGVjdGVkS2V5czogW10sXG4gICAgICAgIG9uU2VsZWN0OiBub29wLFxuICAgICAgICBzaGFsbG93U2VsZWN0OiBmYWxzZSxcbiAgICAgICAgaGFzU2VsZWN0ZWRJY29uOiB0cnVlLFxuICAgICAgICBsYWJlbFRvZ2dsZUNoZWNrZWQ6IHRydWUsXG4gICAgICAgIGRpcmVjdGlvbjogJ3ZlcicsXG4gICAgICAgIGhvekFsaWduOiAnbGVmdCcsXG4gICAgICAgIGF1dG9Gb2N1czogZmFsc2UsXG4gICAgICAgIGZvY3VzYWJsZTogdHJ1ZSxcbiAgICAgICAgb25JdGVtRm9jdXM6IG5vb3AsXG4gICAgICAgIG9uSXRlbUtleURvd246IG5vb3AsXG4gICAgICAgIG9uSXRlbUNsaWNrOiBub29wLFxuICAgICAgICBleHBhbmRBbmltYXRpb246IHRydWVcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4sIHNlbGVjdGVkS2V5cywgZGVmYXVsdFNlbGVjdGVkS2V5cywgZm9jdXNlZEtleSwgZm9jdXNhYmxlLCBhdXRvRm9jdXMgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgdGhpcy5uZXdDaGlsZHJlbiA9IHRoaXMuZ2V0TmV3Q2hpbGRyZW4oY2hpbGRyZW4pO1xuXG4gICAgICAgIGlmIChmb2N1c2FibGUpIHtcbiAgICAgICAgICAgIHRoaXMudGFiYmFibGVLZXkgPSB0aGlzLmdldEZpcnN0QXZhbGlhYmxlbENoaWxkS2V5KCcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIG9wZW5LZXlzOiB0aGlzLmdldEluaXRPcGVuS2V5cyhwcm9wcyksXG4gICAgICAgICAgICBzZWxlY3RlZEtleXM6IHRoaXMubm9ybWFsaXplVG9BcnJheShzZWxlY3RlZEtleXMgfHwgZGVmYXVsdFNlbGVjdGVkS2V5cyksXG4gICAgICAgICAgICBmb2N1c2VkS2V5OiAnZm9jdXNlZEtleScgaW4gdGhpcy5wcm9wcyA/IGZvY3VzZWRLZXkgOiAoZm9jdXNhYmxlICYmIGF1dG9Gb2N1cyA/IHRoaXMudGFiYmFibGVLZXkgOiBudWxsKVxuICAgICAgICB9O1xuXG4gICAgICAgIGJpbmRDdHgodGhpcywgWydoYW5kbGVPcGVuJywgJ2hhbmRsZVNlbGVjdCcsICdoYW5kbGVJdGVtQ2xpY2snLCAnaGFuZGxlSXRlbUtleURvd24nLCAnb25CbHVyJ10pO1xuXG4gICAgICAgIHRoaXMucG9wdXBOb2RlcyA9IFtdO1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLm1lbnVOb2RlID0gZmluZERPTU5vZGUodGhpcyk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7fTtcblxuICAgICAgICBpZiAoJ29wZW5LZXlzJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5LZXlzID0gdGhpcy5ub3JtYWxpemVUb0FycmF5KG5leHRQcm9wcy5vcGVuS2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdzZWxlY3RlZEtleXMnIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgc3RhdGUuc2VsZWN0ZWRLZXlzID0gdGhpcy5ub3JtYWxpemVUb0FycmF5KG5leHRQcm9wcy5zZWxlY3RlZEtleXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZm9jdXNlZEtleScgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgICAgICBzdGF0ZS5mb2N1c2VkS2V5ID0gbmV4dFByb3BzLmZvY3VzZWRLZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoc3RhdGUpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcykge1xuICAgICAgICB0aGlzLm5ld0NoaWxkcmVuID0gdGhpcy5nZXROZXdDaGlsZHJlbihuZXh0UHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5mb2N1c2FibGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRhYmJhYmxlS2V5IGluIHRoaXMuazJuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZm9jdXNlZEtleSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhYmJhYmxlS2V5ID0gdGhpcy5zdGF0ZS5mb2N1c2VkS2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWJiYWJsZUtleSA9IHRoaXMuZ2V0Rmlyc3RBdmFsaWFibGVsQ2hpbGRLZXkoJzAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uQmx1cihlKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZm9jdXNlZEtleTogJydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vbkJsdXIgJiYgdGhpcy5wcm9wcy5vbkJsdXIoZSk7XG4gICAgfVxuXG4gICAgZ2V0SW5pdE9wZW5LZXlzKHByb3BzKSB7XG4gICAgICAgIGxldCBpbml0T3BlbktleXM7XG5cbiAgICAgICAgY29uc3QgeyBvcGVuS2V5cywgZGVmYXVsdE9wZW5LZXlzLCBkZWZhdWx0T3BlbkFsbCwgbW9kZSwgb3Blbk1vZGUgfSA9IHByb3BzO1xuICAgICAgICBpZiAob3BlbktleXMpIHtcbiAgICAgICAgICAgIGluaXRPcGVuS2V5cyA9IG9wZW5LZXlzO1xuICAgICAgICB9IGVsc2UgaWYgKGRlZmF1bHRPcGVuQWxsICYmIG1vZGUgPT09ICdpbmxpbmUnICYmIG9wZW5Nb2RlID09PSAnbXVsdGlwbGUnKSB7XG4gICAgICAgICAgICBpbml0T3BlbktleXMgPSBPYmplY3Qua2V5cyh0aGlzLmsybikuZmlsdGVyKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuazJuW2tleV0udHlwZSA9PT0gJ3N1Ym1lbnUnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbml0T3BlbktleXMgPSBkZWZhdWx0T3BlbktleXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVUb0FycmF5KGluaXRPcGVuS2V5cyk7XG4gICAgfVxuXG4gICAgZ2V0TmV3Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5rMm4gPSB7fTtcbiAgICAgICAgdGhpcy5wMm4gPSB7fTtcbiAgICAgICAgY29uc3QgbG9vcCA9IChjaGlsZHJlbiwgcG9zUHJlZml4LCBpbmRleFdyYXBwZXIgPSB7IGluZGV4OiAwIH0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgJiYgdHlwZW9mIGNoaWxkLnR5cGUgPT09ICdmdW5jdGlvbicgJiYgKCdtZW51Q2hpbGRUeXBlJyBpbiBjaGlsZC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3Q2hpbGQ7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB7IHJvb3Q6IHRoaXMgfTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoWydpdGVtJywgJ3N1Ym1lbnUnLCAnZ3JvdXAnXS5pbmRleE9mKGNoaWxkLnR5cGUubWVudUNoaWxkVHlwZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gYCR7cG9zUHJlZml4fS0ke2luZGV4V3JhcHBlci5pbmRleCsrfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSB0eXBlb2YgY2hpbGQua2V5ID09PSAnc3RyaW5nJyA/IGNoaWxkLmtleSA6IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxldmVsID0gcG9zLnNwbGl0KCctJykubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuazJuW2tleV0gPSB0aGlzLnAybltwb3NdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY2hpbGQudHlwZS5tZW51Q2hpbGRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBjaGlsZC5wcm9wcy5kaXNhYmxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogY2hpbGQucHJvcHMubGFiZWwgfHwgY2hpbGQucHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLl9rZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5sZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuZ3JvdXBJbmRlbnQgPSBjaGlsZC50eXBlLm1lbnVDaGlsZFR5cGUgPT09ICdncm91cCcgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hpbGQudHlwZS5tZW51Q2hpbGRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdWJtZW51JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNsb25lRWxlbWVudChjaGlsZCwgcHJvcHMsIGxvb3AoY2hpbGQucHJvcHMuY2hpbGRyZW4sIHBvcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZ3JvdXAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gY2xvbmVFbGVtZW50KGNoaWxkLCBwcm9wcywgbG9vcChjaGlsZC5wcm9wcy5jaGlsZHJlbiwgcG9zUHJlZml4LCBpbmRleFdyYXBwZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2l0ZW0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGl2aWRlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBjbG9uZUVsZW1lbnQoY2hpbGQsIHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbG9vcChjaGlsZHJlbiwgJzAnKTtcbiAgICB9XG5cbiAgICBub3JtYWxpemVUb0FycmF5KGl0ZW1zKSB7XG4gICAgICAgIGlmIChpdGVtcykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtpdGVtc107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaXNTaWJsaW5nKGN1cnJlbnRQb3MsIHRhcmdldFBvcykge1xuICAgICAgICBjb25zdCBjdXJyZW50TnVtcyA9IGN1cnJlbnRQb3Muc3BsaXQoJy0nKS5zbGljZSgwLCAtMSk7XG4gICAgICAgIGNvbnN0IHRhcmdldE51bXMgPSB0YXJnZXRQb3Muc3BsaXQoJy0nKS5zbGljZSgwLCAtMSk7XG5cbiAgICAgICAgcmV0dXJuIGN1cnJlbnROdW1zLmxlbmd0aCA9PT0gdGFyZ2V0TnVtcy5sZW5ndGggJiYgY3VycmVudE51bXMuZXZlcnkoKG51bSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBudW0gPT09IHRhcmdldE51bXNbaW5kZXhdO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpc0FuY2VzdG9yKGN1cnJlbnRQb3MsIHRhcmdldFBvcykge1xuICAgICAgICBjb25zdCBjdXJyZW50TnVtcyA9IGN1cnJlbnRQb3Muc3BsaXQoJy0nKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0TnVtcyA9IHRhcmdldFBvcy5zcGxpdCgnLScpO1xuXG4gICAgICAgIHJldHVybiBjdXJyZW50TnVtcy5sZW5ndGggPiB0YXJnZXROdW1zLmxlbmd0aCAmJiB0YXJnZXROdW1zLmV2ZXJ5KChudW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbnVtID09PSBjdXJyZW50TnVtc1tpbmRleF07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGhhbmRsZU9wZW4oa2V5LCBvcGVuLCB0cmlnZ2VyVHlwZSwgZSkge1xuICAgICAgICBsZXQgbmV3T3BlbktleXM7XG5cbiAgICAgICAgY29uc3QgeyBtb2RlLCBvcGVuTW9kZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBvcGVuS2V5cyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBvcGVuS2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIGlmIChvcGVuICYmIGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wZW5Nb2RlID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgICAgICAgICBuZXdPcGVuS2V5cyA9IG9wZW5LZXlzLmZpbHRlcihrID0+ICF0aGlzLmlzU2libGluZyh0aGlzLmsybltrZXldLnBvcywgdGhpcy5rMm5ba10ucG9zKSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld09wZW5LZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdPcGVuS2V5cyA9IG9wZW5LZXlzLmNvbmNhdChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3T3BlbktleXMgPSBvcGVuS2V5cy5maWx0ZXIoayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzQW5jZXN0b3IodGhpcy5rMm5ba2V5XS5wb3MsIHRoaXMuazJuW2tdLnBvcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbmV3T3BlbktleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFvcGVuICYmIGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgICAgIG5ld09wZW5LZXlzID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi5vcGVuS2V5cy5zbGljZSgwLCBpbmRleCksXG4gICAgICAgICAgICAgICAgICAgIC4uLm9wZW5LZXlzLnNsaWNlKGluZGV4ICsgMSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyVHlwZSA9PT0gJ2RvY0NsaWNrJykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wb3B1cE5vZGVzLmNvbmNhdCh0aGlzLm1lbnVOb2RlKS5zb21lKG5vZGUgPT4gbm9kZS5jb250YWlucyhlLnRhcmdldCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld09wZW5LZXlzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdPcGVuS2V5cyA9IG9wZW5LZXlzLmZpbHRlcihrID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGsgIT09IGtleSAmJiAhdGhpcy5pc0FuY2VzdG9yKHRoaXMuazJuW2tdLnBvcywgdGhpcy5rMm5ba2V5XS5wb3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld09wZW5LZXlzKSB7XG4gICAgICAgICAgICBpZiAoISgnb3BlbktleXMnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5LZXlzOiBuZXdPcGVuS2V5c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uT3BlbihuZXdPcGVuS2V5cywge1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBvcGVuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFBhdGgoa2V5KSB7XG4gICAgICAgIGNvbnN0IGtleVBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgbGFiZWxQYXRoID0gW107XG5cbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5rMm5ba2V5XS5wb3M7XG4gICAgICAgIGNvbnN0IG51bXMgPSBwb3Muc3BsaXQoJy0nKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW1zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50TnVtcyA9IG51bXMuc2xpY2UoMCwgaSArIDEpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50UG9zID0gcGFyZW50TnVtcy5qb2luKCctJyk7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnAybltwYXJlbnRQb3NdO1xuICAgICAgICAgICAga2V5UGF0aC5wdXNoKHBhcmVudC5rZXkpO1xuICAgICAgICAgICAgbGFiZWxQYXRoLnB1c2gocGFyZW50LmxhYmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgbGFiZWxQYXRoXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaGFuZGxlU2VsZWN0KGtleSwgc2VsZWN0LCBtZW51SXRlbSkge1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLmsybltrZXldLnBvcztcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBwb3Muc3BsaXQoJy0nKS5sZW5ndGggLSAxO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5zaGFsbG93U2VsZWN0ICYmIGxldmVsID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5ld1NlbGVjdGVkS2V5cztcblxuICAgICAgICBjb25zdCB7IHNlbGVjdE1vZGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0ZWRLZXlzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCBpbmRleCA9IHNlbGVjdGVkS2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIGlmIChzZWxlY3QgJiYgaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0TW9kZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgICAgICBuZXdTZWxlY3RlZEtleXMgPSBba2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0TW9kZSA9PT0gJ211bHRpcGxlJykge1xuICAgICAgICAgICAgICAgIG5ld1NlbGVjdGVkS2V5cyA9IHNlbGVjdGVkS2V5cy5jb25jYXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghc2VsZWN0ICYmIGluZGV4ID4gLTEgJiYgc2VsZWN0TW9kZSA9PT0gJ211bHRpcGxlJykge1xuICAgICAgICAgICAgbmV3U2VsZWN0ZWRLZXlzID0gW1xuICAgICAgICAgICAgICAgIC4uLnNlbGVjdGVkS2V5cy5zbGljZSgwLCBpbmRleCksXG4gICAgICAgICAgICAgICAgLi4uc2VsZWN0ZWRLZXlzLnNsaWNlKGluZGV4ICsgMSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3U2VsZWN0ZWRLZXlzKSB7XG4gICAgICAgICAgICBpZiAoISgnc2VsZWN0ZWRLZXlzJyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEtleXM6IG5ld1NlbGVjdGVkS2V5c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uU2VsZWN0KG5ld1NlbGVjdGVkS2V5cywgbWVudUl0ZW0sIHtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgc2VsZWN0LFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmsybltrZXldLmxhYmVsLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2V0UGF0aChrZXkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZUl0ZW1DbGljayhrZXksIGl0ZW0sIGUpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZm9jdXNhYmxlKSB7XG4gICAgICAgICAgICBpZiAoISgnZm9jdXNlZEtleScgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNlZEtleToga2V5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucHJvcHMub25JdGVtRm9jdXMoa2V5LCBpdGVtLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtLnByb3BzLnR5cGUgPT09ICdpdGVtJykge1xuICAgICAgICAgICAgaWYgKGl0ZW0ucHJvcHMucGFyZW50TW9kZSA9PT0gJ3BvcHVwJyAmJiB0aGlzLnN0YXRlLm9wZW5LZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghKCdvcGVuS2V5cycgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuS2V5czogW11cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbk9wZW4oW10sIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiB0aGlzLnN0YXRlLm9wZW5LZXlzLnNvcnQoKHByZXZLZXksIG5leHRLZXkpID0+IHRoaXMuazJuW25leHRLZXldLnBvcy5zcGxpdCgnLScpLmxlbmd0aCAtIHRoaXMuazJuW3ByZXZLZXldLnBvcy5zcGxpdCgnLScpLmxlbmd0aClbMF0sXG4gICAgICAgICAgICAgICAgICAgIG9wZW46IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucHJvcHMub25JdGVtQ2xpY2soa2V5LCBpdGVtLCBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzQXZhaWxhYmxlUG9zKHJlZlBvcywgdGFyZ2V0UG9zKSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgZGlzYWJsZWQgfSA9IHRoaXMucDJuW3RhcmdldFBvc107XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTaWJsaW5nKHJlZlBvcywgdGFyZ2V0UG9zKSAmJlxuICAgICAgICAgICAgKHR5cGUgPT09ICdpdGVtJyAmJiAhZGlzYWJsZWQgfHwgdHlwZSA9PT0gJ3N1Ym1lbnUnKTtcbiAgICB9XG5cbiAgICBnZXRBdmFpbGFibGVLZXkocG9zLCBwcmV2KSB7XG4gICAgICAgIGNvbnN0IHBzID0gT2JqZWN0LmtleXModGhpcy5wMm4pLmZpbHRlcihwID0+IHRoaXMuaXNBdmFpbGFibGVQb3MocG9zLCBwKSk7XG4gICAgICAgIGlmIChwcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHBzLmluZGV4T2YocG9zKTtcbiAgICAgICAgICAgIGxldCB0YXJnZXRJbmRleDtcbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SW5kZXggPSBpbmRleCA9PT0gMCA/IHBzLmxlbmd0aCAtIDEgOiBpbmRleCAtIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldEluZGV4ID0gaW5kZXggPT09IHBzLmxlbmd0aCAtIDEgPyAwIDogaW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wMm5bcHNbdGFyZ2V0SW5kZXhdXS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBnZXRGaXJzdEF2YWxpYWJsZWxDaGlsZEtleShwYXJlbnRQb3MpIHtcbiAgICAgICAgY29uc3QgcG9zID0gT2JqZWN0LmtleXModGhpcy5wMm4pLmZpbmQocCA9PiB0aGlzLmlzQXZhaWxhYmxlUG9zKGAke3BhcmVudFBvc30tMGAsIHApKTtcbiAgICAgICAgcmV0dXJuIHBvcyA/IHRoaXMucDJuW3Bvc10ua2V5IDogbnVsbDtcbiAgICB9XG5cbiAgICBnZXRQYXJlbnRLZXkocG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnAybltwb3Muc2xpY2UoMCwgcG9zLmxlbmd0aCAtIDIpXS5rZXk7XG4gICAgfVxuXG4gICAgaGFuZGxlSXRlbUtleURvd24oa2V5LCB0eXBlLCBpdGVtLCBlKSB7XG4gICAgICAgIGlmIChbXG4gICAgICAgICAgICBLRVlDT0RFLlVQLCBLRVlDT0RFLkRPV04sIEtFWUNPREUuUklHSFQsIEtFWUNPREUuTEVGVCxcbiAgICAgICAgICAgIEtFWUNPREUuRU5URVIsIEtFWUNPREUuRVNDLCBLRVlDT0RFLlNQQUNFXG4gICAgICAgIF0uaW5kZXhPZihlLmtleUNvZGUpID4gLTEpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZm9jdXNlZEtleSA9IHRoaXMuc3RhdGUuZm9jdXNlZEtleTtcblxuICAgICAgICBjb25zdCB7IGRpcmVjdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5rMm5ba2V5XS5wb3M7XG4gICAgICAgIGNvbnN0IGxldmVsID0gcG9zLnNwbGl0KCctJykubGVuZ3RoIC0gMTtcbiAgICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgS0VZQ09ERS5VUDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF2YWxpYWJsZUtleSA9IHRoaXMuZ2V0QXZhaWxhYmxlS2V5KHBvcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGF2YWxpYWJsZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBmb2N1c2VkS2V5ID0gYXZhbGlhYmxlS2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgS0VZQ09ERS5ET1dOOiB7XG4gICAgICAgICAgICAgICAgbGV0IGF2YWxpYWJsZUtleTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnaG96JyAmJiBsZXZlbCA9PT0gMSAmJiB0eXBlID09PSAnc3VibWVudScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVPcGVuKGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGF2YWxpYWJsZUtleSA9IHRoaXMuZ2V0Rmlyc3RBdmFsaWFibGVsQ2hpbGRLZXkocG9zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhdmFsaWFibGVLZXkgPSB0aGlzLmdldEF2YWlsYWJsZUtleShwb3MsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGF2YWxpYWJsZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBmb2N1c2VkS2V5ID0gYXZhbGlhYmxlS2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgS0VZQ09ERS5SSUdIVDoge1xuICAgICAgICAgICAgICAgIGxldCBhdmFsaWFibGVLZXk7XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2hveicgJiYgbGV2ZWwgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYXZhbGlhYmxlS2V5ID0gdGhpcy5nZXRBdmFpbGFibGVLZXkocG9zLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3VibWVudScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVPcGVuKGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGF2YWxpYWJsZUtleSA9IHRoaXMuZ2V0Rmlyc3RBdmFsaWFibGVsQ2hpbGRLZXkocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGF2YWxpYWJsZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBmb2N1c2VkS2V5ID0gYXZhbGlhYmxlS2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgS0VZQ09ERS5FTlRFUjoge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnc3VibWVudScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVPcGVuKGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF2YWxpYWJsZUtleSA9IHRoaXMuZ2V0Rmlyc3RBdmFsaWFibGVsQ2hpbGRLZXkocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF2YWxpYWJsZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNlZEtleSA9IGF2YWxpYWJsZUtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgS0VZQ09ERS5MRUZUOiB7XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2hveicgJiYgbGV2ZWwgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXZhbGlhYmxlS2V5ID0gdGhpcy5nZXRBdmFpbGFibGVLZXkocG9zLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF2YWxpYWJsZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNlZEtleSA9IGF2YWxpYWJsZUtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGV2ZWwgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudEtleSA9IHRoaXMuZ2V0UGFyZW50S2V5KHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlT3BlbihwYXJlbnRLZXksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNlZEtleSA9IHBhcmVudEtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEtFWUNPREUuRVNDOlxuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gdGhpcy5nZXRQYXJlbnRLZXkocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVPcGVuKHBhcmVudEtleSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBmb2N1c2VkS2V5ID0gcGFyZW50S2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBLRVlDT0RFLlRBQjpcbiAgICAgICAgICAgICAgICBmb2N1c2VkS2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9jdXNlZEtleSAhPT0gdGhpcy5zdGF0ZS5mb2N1c2VkS2V5KSB7XG4gICAgICAgICAgICBpZiAoISgnZm9jdXNlZEtleScgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNlZEtleVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uSXRlbUtleURvd24oZm9jdXNlZEtleSwgaXRlbSwgZSk7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uSXRlbUZvY3VzKGZvY3VzZWRLZXksIGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgY2xhc3NOYW1lLCBkaXJlY3Rpb24sIGhvekFsaWduLCBoZWFkZXIsIGZvb3Rlciwgc2VsZWN0TW9kZSwgcnRsIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBvdGhlcnMgPSBwaWNrT3RoZXJzKE9iamVjdC5rZXlzKE1lbnUucHJvcFR5cGVzKSwgdGhpcy5wcm9wcyk7XG5cbiAgICAgICAgY29uc3QgbmV3Q2xhc3NOYW1lID0gY3goe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1tZW51YF06IHRydWUsXG4gICAgICAgICAgICBbYCR7cHJlZml4fXZlcmBdOiBkaXJlY3Rpb24gPT09ICd2ZXInLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1ob3pgXTogZGlyZWN0aW9uID09PSAnaG96JyxcbiAgICAgICAgICAgIFtjbGFzc05hbWVdOiAhIWNsYXNzTmFtZVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByb2xlID0gZGlyZWN0aW9uID09PSAnaG96JyA/ICdtZW51YmFyJyA6ICdtZW51JztcbiAgICAgICAgY29uc3QgaGVhZGVyRWxlbWVudCA9IGhlYWRlciA/IDxsaSBjbGFzc05hbWU9e2Ake3ByZWZpeH1tZW51LWhlYWRlcmB9PntoZWFkZXJ9PC9saT4gOiBudWxsO1xuICAgICAgICBjb25zdCBpdGVtc0VsZW1lbnQgPSBoZWFkZXIgfHwgZm9vdGVyID8gIDx1bCBjbGFzc05hbWU9e2Ake3ByZWZpeH1tZW51LWNvbnRlbnRgfT57dGhpcy5uZXdDaGlsZHJlbn08L3VsPiA6IHRoaXMubmV3Q2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGZvb3RlckVsZW1lbnQgPSBmb290ZXIgPyA8bGkgY2xhc3NOYW1lPXtgJHtwcmVmaXh9bWVudS1mb290ZXJgfT57Zm9vdGVyfTwvbGk+IDogbnVsbDtcbiAgICAgICAgY29uc3Qgc2hvdWxkV3JhcEl0ZW1zQW5kRm9vdGVyID0gaG96QWxpZ24gPT09ICdyaWdodCcgJiYgISFoZWFkZXI7XG5cbiAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgb3RoZXJzLmRpciA9ICdydGwnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDx1bCByb2xlPXtyb2xlfSBvbkJsdXI9e3RoaXMub25CbHVyfSBjbGFzc05hbWU9e25ld0NsYXNzTmFtZX0gb25LZXlEb3duPXt0aGlzLmhhbmRsZUVudGVyfSBhcmlhLW11bHRpc2VsZWN0YWJsZT17c2VsZWN0TW9kZSA9PT0gJ211bHRpcGxlJ30gey4uLm90aGVyc30+XG4gICAgICAgICAgICAgICAge2hlYWRlckVsZW1lbnR9XG4gICAgICAgICAgICAgICAge3Nob3VsZFdyYXBJdGVtc0FuZEZvb3RlciA/XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9bWVudS1ob3otcmlnaHRgfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtpdGVtc0VsZW1lbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICB7Zm9vdGVyRWxlbWVudH1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+IDogbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB7IXNob3VsZFdyYXBJdGVtc0FuZEZvb3RlciA/IGl0ZW1zRWxlbWVudCA6IG51bGx9XG4gICAgICAgICAgICAgICAgeyFzaG91bGRXcmFwSXRlbXNBbmRGb290ZXIgPyBmb290ZXJFbGVtZW50IDogbnVsbH1cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21lbnUvdmlldy9tZW51LmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IFRyYW5zaXRpb25Hcm91cCB9IGZyb20gJ3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAnO1xuaW1wb3J0IEFuaW1hdGVDaGlsZCBmcm9tICcuL2NoaWxkJztcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuY29uc3QgRmlyc3RDaGlsZCA9IHByb3BzID0+IHtcbiAgICBjb25zdCBjaGlsZHJlbkFycmF5ID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheShwcm9wcy5jaGlsZHJlbik7XG4gICAgcmV0dXJuIGNoaWxkcmVuQXJyYXlbMF0gfHwgbnVsbDtcbn07XG5cbi8qKlxuICogQW5pbWF0ZVxuICovXG5jbGFzcyBBbmltYXRlIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5Yqo55S7IGNsYXNzTmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0aW9uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlrZDlhYPntKDnrKzkuIDmrKHmjILovb3ml7bmmK/lkKbmiafooYzliqjnlLtcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGlvbkFwcGVhcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDljIXoo7nlrZDlhYPntKDnmoTmoIfnrb5cbiAgICAgICAgICovXG4gICAgICAgIGNvbXBvbmVudDogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuWPquacieWNleS4quWtkOWFg+e0oO+8jOWmguaenOacieWkmuS4quWtkOWFg+e0oO+8jOivt+iuvue9ruS4uiBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xlTW9kZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlrZDlhYPntKBcbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZWxlbWVudCwgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmVsZW1lbnQpXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmiafooYznrKzkuIDmrKHmjILovb3liqjnlLvliY3op6blj5HnmoTlm57osIPlh73mlbBcbiAgICAgICAgICovXG4gICAgICAgIGJlZm9yZUFwcGVhcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmiafooYznrKzkuIDmrKHmjILovb3liqjnlLvvvIzmt7vliqAgeHh4LWFwcGVhci1hY3RpdmUg57G75ZCN5ZCO6Kem5Y+R55qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqICBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIFxi5omn6KGM5Yqo55S755qEIGRvbSDlhYPntKBcbiAgICAgICAgICovXG4gICAgICAgIG9uQXBwZWFyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaJp+ihjOWujOesrOS4gOasoeaMgui9veWKqOeUu+WQjuinpuWPkeeahOWHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIFxi5omn6KGM5Yqo55S755qEIGRvbSDlhYPntKBcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyQXBwZWFyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaJp+ihjOi/m+WcuuWKqOeUu+WJjeinpuWPkeeahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIFxi5omn6KGM5Yqo55S755qEIGRvbSDlhYPntKBcbiAgICAgICAgICovXG4gICAgICAgIGJlZm9yZUVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaJp+ihjOi/m+WcuuWKqOeUu++8jOa3u+WKoCB4eHgtZW50ZXItYWN0aXZlIOexu+WQjeWQjuinpuWPkeeahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIFxi5omn6KGM5Yqo55S755qEIGRvbSDlhYPntKBcbiAgICAgICAgICovXG4gICAgICAgIG9uRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5omn6KGM5a6M6L+b5Zy65Yqo55S75ZCO6Kem5Y+R55qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgXGLmiafooYzliqjnlLvnmoQgZG9tIOWFg+e0oFxuICAgICAgICAgKi9cbiAgICAgICAgYWZ0ZXJFbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmiafooYznprvlnLrliqjnlLvliY3op6blj5HnmoTlm57osIPlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBcYuaJp+ihjOWKqOeUu+eahCBkb20g5YWD57SgXG4gICAgICAgICAqL1xuICAgICAgICBiZWZvcmVMZWF2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmiafooYznprvlnLrliqjnlLvvvIzmt7vliqAgeHh4LWxlYXZlLWFjdGl2ZSDnsbvlkI3lkI7op6blj5HnmoTlm57osIPlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBcYuaJp+ihjOWKqOeUu+eahCBkb20g5YWD57SgXG4gICAgICAgICAqL1xuICAgICAgICBvbkxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaJp+ihjOWujOemu+WcuuWKqOeUu+WQjuinpuWPkeeahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIFxi5omn6KGM5Yqo55S755qEIGRvbSDlhYPntKBcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyTGVhdmU6IFByb3BUeXBlcy5mdW5jXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGFuaW1hdGlvbkFwcGVhcjogdHJ1ZSxcbiAgICAgICAgY29tcG9uZW50OiAnZGl2JyxcbiAgICAgICAgc2luZ2xlTW9kZTogdHJ1ZSxcbiAgICAgICAgYmVmb3JlQXBwZWFyOiBub29wLFxuICAgICAgICBvbkFwcGVhcjogbm9vcCxcbiAgICAgICAgYWZ0ZXJBcHBlYXI6IG5vb3AsXG4gICAgICAgIGJlZm9yZUVudGVyOiBub29wLFxuICAgICAgICBvbkVudGVyOiBub29wLFxuICAgICAgICBhZnRlckVudGVyOiBub29wLFxuICAgICAgICBiZWZvcmVMZWF2ZTogbm9vcCxcbiAgICAgICAgb25MZWF2ZTogbm9vcCxcbiAgICAgICAgYWZ0ZXJMZWF2ZTogbm9vcFxuICAgIH07XG5cbiAgICBub3JtYWxpemVOYW1lcyhuYW1lcykge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhcHBlYXI6IGAke25hbWVzfS1hcHBlYXJgLFxuICAgICAgICAgICAgICAgIGFwcGVhckFjdGl2ZTogYCR7bmFtZXN9LWFwcGVhci1hY3RpdmVgLFxuICAgICAgICAgICAgICAgIGVudGVyOiBgJHtuYW1lc30tZW50ZXJgLFxuICAgICAgICAgICAgICAgIGVudGVyQWN0aXZlOiBgJHtuYW1lc30tZW50ZXItYWN0aXZlYCxcbiAgICAgICAgICAgICAgICBsZWF2ZTogYCR7bmFtZXN9LWxlYXZlYCxcbiAgICAgICAgICAgICAgICBsZWF2ZUFjdGl2ZTogYCR7bmFtZXN9LWxlYXZlLWFjdGl2ZWBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXBwZWFyOiBuYW1lcy5hcHBlYXIsXG4gICAgICAgICAgICAgICAgYXBwZWFyQWN0aXZlOiBgJHtuYW1lcy5hcHBlYXJ9LWFjdGl2ZWAsXG4gICAgICAgICAgICAgICAgZW50ZXI6IGAke25hbWVzLmVudGVyfWAsXG4gICAgICAgICAgICAgICAgZW50ZXJBY3RpdmU6IGAke25hbWVzLmVudGVyfS1hY3RpdmVgLFxuICAgICAgICAgICAgICAgIGxlYXZlOiBgJHtuYW1lcy5sZWF2ZX1gLFxuICAgICAgICAgICAgICAgIGxlYXZlQWN0aXZlOiBgJHtuYW1lcy5sZWF2ZX0tYWN0aXZlYCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgY29uc3QgeyBhbmltYXRpb24sIGNoaWxkcmVuLCBhbmltYXRpb25BcHBlYXIsIHNpbmdsZU1vZGUsIGNvbXBvbmVudCxcbiAgICAgICAgICAgIGJlZm9yZUFwcGVhciwgb25BcHBlYXIsIGFmdGVyQXBwZWFyLFxuICAgICAgICAgICAgYmVmb3JlRW50ZXIsIG9uRW50ZXIsIGFmdGVyRW50ZXIsXG4gICAgICAgICAgICBiZWZvcmVMZWF2ZSwgb25MZWF2ZSwgYWZ0ZXJMZWF2ZSxcbiAgICAgICAgICAgIC4uLm90aGVyc1xuICAgICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4gICAgICAgIGNvbnN0IGFuaW1hdGVDaGlsZHJlbiA9IENoaWxkcmVuLm1hcChjaGlsZHJlbiwgY2hpbGQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8QW5pbWF0ZUNoaWxkIGtleT17Y2hpbGQua2V5fVxuICAgICAgICAgICAgICAgICAgICBuYW1lcz17dGhpcy5ub3JtYWxpemVOYW1lcyhhbmltYXRpb24pfVxuICAgICAgICAgICAgICAgICAgICBvbkFwcGVhcj17YmVmb3JlQXBwZWFyfVxuICAgICAgICAgICAgICAgICAgICBvbkFwcGVhcmluZz17b25BcHBlYXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uQXBwZWFyZWQ9e2FmdGVyQXBwZWFyfVxuICAgICAgICAgICAgICAgICAgICBvbkVudGVyPXtiZWZvcmVFbnRlcn1cbiAgICAgICAgICAgICAgICAgICAgb25FbnRlcmluZz17b25FbnRlcn1cbiAgICAgICAgICAgICAgICAgICAgb25FbnRlcmVkPXthZnRlckVudGVyfVxuICAgICAgICAgICAgICAgICAgICBvbkV4aXQ9e2JlZm9yZUxlYXZlfVxuICAgICAgICAgICAgICAgICAgICBvbkV4aXRpbmc9e29uTGVhdmV9XG4gICAgICAgICAgICAgICAgICAgIG9uRXhpdGVkPXthZnRlckxlYXZlfT5cbiAgICAgICAgICAgICAgICAgICAge2NoaWxkfVxuICAgICAgICAgICAgICAgIDwvQW5pbWF0ZUNoaWxkPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxUcmFuc2l0aW9uR3JvdXAgYXBwZWFyPXthbmltYXRpb25BcHBlYXJ9IGNvbXBvbmVudD17c2luZ2xlTW9kZSA/IEZpcnN0Q2hpbGQgOiBjb21wb25lbnR9IHsuLi5vdGhlcnN9PlxuICAgICAgICAgICAgICAgIHthbmltYXRlQ2hpbGRyZW59XG4gICAgICAgICAgICA8L1RyYW5zaXRpb25Hcm91cD5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFuaW1hdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYW5pbWF0ZS9hbmltYXRlLmpzeCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX0NTU1RyYW5zaXRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0NTU1RyYW5zaXRpb25cIikpO1xuXG52YXIgX1JlcGxhY2VUcmFuc2l0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9SZXBsYWNlVHJhbnNpdGlvblwiKSk7XG5cbnZhciBfVHJhbnNpdGlvbkdyb3VwID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9UcmFuc2l0aW9uR3JvdXBcIikpO1xuXG52YXIgX1RyYW5zaXRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1RyYW5zaXRpb25cIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVHJhbnNpdGlvbjogX1RyYW5zaXRpb24uZGVmYXVsdCxcbiAgVHJhbnNpdGlvbkdyb3VwOiBfVHJhbnNpdGlvbkdyb3VwLmRlZmF1bHQsXG4gIFJlcGxhY2VUcmFuc2l0aW9uOiBfUmVwbGFjZVRyYW5zaXRpb24uZGVmYXVsdCxcbiAgQ1NTVHJhbnNpdGlvbjogX0NTU1RyYW5zaXRpb24uZGVmYXVsdFxufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX3JlYWN0LXRyYW5zaXRpb24tZ3JvdXBAMi41LjJAcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9pbmRleC5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5FWElUSU5HID0gZXhwb3J0cy5FTlRFUkVEID0gZXhwb3J0cy5FTlRFUklORyA9IGV4cG9ydHMuRVhJVEVEID0gZXhwb3J0cy5VTk1PVU5URUQgPSB2b2lkIDA7XG5cbnZhciBQcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfcmVhY3REb20gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xuXG52YXIgX3JlYWN0TGlmZWN5Y2xlc0NvbXBhdCA9IHJlcXVpcmUoXCJyZWFjdC1saWZlY3ljbGVzLWNvbXBhdFwiKTtcblxudmFyIF9Qcm9wVHlwZXMgPSByZXF1aXJlKFwiLi91dGlscy9Qcm9wVHlwZXNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFVOTU9VTlRFRCA9ICd1bm1vdW50ZWQnO1xuZXhwb3J0cy5VTk1PVU5URUQgPSBVTk1PVU5URUQ7XG52YXIgRVhJVEVEID0gJ2V4aXRlZCc7XG5leHBvcnRzLkVYSVRFRCA9IEVYSVRFRDtcbnZhciBFTlRFUklORyA9ICdlbnRlcmluZyc7XG5leHBvcnRzLkVOVEVSSU5HID0gRU5URVJJTkc7XG52YXIgRU5URVJFRCA9ICdlbnRlcmVkJztcbmV4cG9ydHMuRU5URVJFRCA9IEVOVEVSRUQ7XG52YXIgRVhJVElORyA9ICdleGl0aW5nJztcbi8qKlxuICogVGhlIFRyYW5zaXRpb24gY29tcG9uZW50IGxldHMgeW91IGRlc2NyaWJlIGEgdHJhbnNpdGlvbiBmcm9tIG9uZSBjb21wb25lbnRcbiAqIHN0YXRlIHRvIGFub3RoZXIgX292ZXIgdGltZV8gd2l0aCBhIHNpbXBsZSBkZWNsYXJhdGl2ZSBBUEkuIE1vc3QgY29tbW9ubHlcbiAqIGl0J3MgdXNlZCB0byBhbmltYXRlIHRoZSBtb3VudGluZyBhbmQgdW5tb3VudGluZyBvZiBhIGNvbXBvbmVudCwgYnV0IGNhbiBhbHNvXG4gKiBiZSB1c2VkIHRvIGRlc2NyaWJlIGluLXBsYWNlIHRyYW5zaXRpb24gc3RhdGVzIGFzIHdlbGwuXG4gKlxuICogQnkgZGVmYXVsdCB0aGUgYFRyYW5zaXRpb25gIGNvbXBvbmVudCBkb2VzIG5vdCBhbHRlciB0aGUgYmVoYXZpb3Igb2YgdGhlXG4gKiBjb21wb25lbnQgaXQgcmVuZGVycywgaXQgb25seSB0cmFja3MgXCJlbnRlclwiIGFuZCBcImV4aXRcIiBzdGF0ZXMgZm9yIHRoZSBjb21wb25lbnRzLlxuICogSXQncyB1cCB0byB5b3UgdG8gZ2l2ZSBtZWFuaW5nIGFuZCBlZmZlY3QgdG8gdGhvc2Ugc3RhdGVzLiBGb3IgZXhhbXBsZSB3ZSBjYW5cbiAqIGFkZCBzdHlsZXMgdG8gYSBjb21wb25lbnQgd2hlbiBpdCBlbnRlcnMgb3IgZXhpdHM6XG4gKlxuICogYGBganN4XG4gKiBpbXBvcnQgVHJhbnNpdGlvbiBmcm9tICdyZWFjdC10cmFuc2l0aW9uLWdyb3VwL1RyYW5zaXRpb24nO1xuICpcbiAqIGNvbnN0IGR1cmF0aW9uID0gMzAwO1xuICpcbiAqIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHtcbiAqICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHtkdXJhdGlvbn1tcyBlYXNlLWluLW91dGAsXG4gKiAgIG9wYWNpdHk6IDAsXG4gKiB9XG4gKlxuICogY29uc3QgdHJhbnNpdGlvblN0eWxlcyA9IHtcbiAqICAgZW50ZXJpbmc6IHsgb3BhY2l0eTogMCB9LFxuICogICBlbnRlcmVkOiAgeyBvcGFjaXR5OiAxIH0sXG4gKiB9O1xuICpcbiAqIGNvbnN0IEZhZGUgPSAoeyBpbjogaW5Qcm9wIH0pID0+IChcbiAqICAgPFRyYW5zaXRpb24gaW49e2luUHJvcH0gdGltZW91dD17ZHVyYXRpb259PlxuICogICAgIHsoc3RhdGUpID0+IChcbiAqICAgICAgIDxkaXYgc3R5bGU9e3tcbiAqICAgICAgICAgLi4uZGVmYXVsdFN0eWxlLFxuICogICAgICAgICAuLi50cmFuc2l0aW9uU3R5bGVzW3N0YXRlXVxuICogICAgICAgfX0+XG4gKiAgICAgICAgIEknbSBhIGZhZGUgVHJhbnNpdGlvbiFcbiAqICAgICAgIDwvZGl2PlxuICogICAgICl9XG4gKiAgIDwvVHJhbnNpdGlvbj5cbiAqICk7XG4gKiBgYGBcbiAqXG4gKiBBcyBub3RlZCB0aGUgYFRyYW5zaXRpb25gIGNvbXBvbmVudCBkb2Vzbid0IF9kb18gYW55dGhpbmcgYnkgaXRzZWxmIHRvIGl0cyBjaGlsZCBjb21wb25lbnQuXG4gKiBXaGF0IGl0IGRvZXMgZG8gaXMgdHJhY2sgdHJhbnNpdGlvbiBzdGF0ZXMgb3ZlciB0aW1lIHNvIHlvdSBjYW4gdXBkYXRlIHRoZVxuICogY29tcG9uZW50IChzdWNoIGFzIGJ5IGFkZGluZyBzdHlsZXMgb3IgY2xhc3Nlcykgd2hlbiBpdCBjaGFuZ2VzIHN0YXRlcy5cbiAqXG4gKiBUaGVyZSBhcmUgNCBtYWluIHN0YXRlcyBhIFRyYW5zaXRpb24gY2FuIGJlIGluOlxuICogIC0gYCdlbnRlcmluZydgXG4gKiAgLSBgJ2VudGVyZWQnYFxuICogIC0gYCdleGl0aW5nJ2BcbiAqICAtIGAnZXhpdGVkJ2BcbiAqXG4gKiBUcmFuc2l0aW9uIHN0YXRlIGlzIHRvZ2dsZWQgdmlhIHRoZSBgaW5gIHByb3AuIFdoZW4gYHRydWVgIHRoZSBjb21wb25lbnQgYmVnaW5zIHRoZVxuICogXCJFbnRlclwiIHN0YWdlLiBEdXJpbmcgdGhpcyBzdGFnZSwgdGhlIGNvbXBvbmVudCB3aWxsIHNoaWZ0IGZyb20gaXRzIGN1cnJlbnQgdHJhbnNpdGlvbiBzdGF0ZSxcbiAqIHRvIGAnZW50ZXJpbmcnYCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSB0cmFuc2l0aW9uIGFuZCB0aGVuIHRvIHRoZSBgJ2VudGVyZWQnYCBzdGFnZSBvbmNlXG4gKiBpdCdzIGNvbXBsZXRlLiBMZXQncyB0YWtlIHRoZSBmb2xsb3dpbmcgZXhhbXBsZTpcbiAqXG4gKiBgYGBqc3hcbiAqIHN0YXRlID0geyBpbjogZmFsc2UgfTtcbiAqXG4gKiB0b2dnbGVFbnRlclN0YXRlID0gKCkgPT4ge1xuICogICB0aGlzLnNldFN0YXRlKHsgaW46IHRydWUgfSk7XG4gKiB9XG4gKlxuICogcmVuZGVyKCkge1xuICogICByZXR1cm4gKFxuICogICAgIDxkaXY+XG4gKiAgICAgICA8VHJhbnNpdGlvbiBpbj17dGhpcy5zdGF0ZS5pbn0gdGltZW91dD17NTAwfSAvPlxuICogICAgICAgPGJ1dHRvbiBvbkNsaWNrPXt0aGlzLnRvZ2dsZUVudGVyU3RhdGV9PkNsaWNrIHRvIEVudGVyPC9idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBXaGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZCB0aGUgY29tcG9uZW50IHdpbGwgc2hpZnQgdG8gdGhlIGAnZW50ZXJpbmcnYCBzdGF0ZSBhbmRcbiAqIHN0YXkgdGhlcmUgZm9yIDUwMG1zICh0aGUgdmFsdWUgb2YgYHRpbWVvdXRgKSBiZWZvcmUgaXQgZmluYWxseSBzd2l0Y2hlcyB0byBgJ2VudGVyZWQnYC5cbiAqXG4gKiBXaGVuIGBpbmAgaXMgYGZhbHNlYCB0aGUgc2FtZSB0aGluZyBoYXBwZW5zIGV4Y2VwdCB0aGUgc3RhdGUgbW92ZXMgZnJvbSBgJ2V4aXRpbmcnYCB0byBgJ2V4aXRlZCdgLlxuICpcbiAqICMjIFRpbWluZ1xuICpcbiAqIFRpbWluZyBpcyBvZnRlbiB0aGUgdHJpY2tpZXN0IHBhcnQgb2YgYW5pbWF0aW9uLCBtaXN0YWtlcyBjYW4gcmVzdWx0IGluIHNsaWdodCBkZWxheXNcbiAqIHRoYXQgYXJlIGhhcmQgdG8gcGluIGRvd24uIEEgY29tbW9uIGV4YW1wbGUgaXMgd2hlbiB5b3Ugd2FudCB0byBhZGQgYW4gZXhpdCB0cmFuc2l0aW9uLFxuICogeW91IHNob3VsZCBzZXQgdGhlIGRlc2lyZWQgZmluYWwgc3R5bGVzIHdoZW4gdGhlIHN0YXRlIGlzIGAnZXhpdGluZydgLiBUaGF0J3Mgd2hlbiB0aGVcbiAqIHRyYW5zaXRpb24gdG8gdGhvc2Ugc3R5bGVzIHdpbGwgc3RhcnQgYW5kLCBpZiB5b3UgbWF0Y2hlZCB0aGUgYHRpbWVvdXRgIHByb3Agd2l0aCB0aGVcbiAqIENTUyBUcmFuc2l0aW9uIGR1cmF0aW9uLCBpdCB3aWxsIGVuZCBleGFjdGx5IHdoZW4gdGhlIHN0YXRlIGNoYW5nZXMgdG8gYCdleGl0ZWQnYC5cbiAqXG4gKiA+ICoqTm90ZSoqOiBGb3Igc2ltcGxlciB0cmFuc2l0aW9ucyB0aGUgYFRyYW5zaXRpb25gIGNvbXBvbmVudCBtaWdodCBiZSBlbm91Z2gsIGJ1dFxuICogPiB0YWtlIGludG8gYWNjb3VudCB0aGF0IGl0J3MgcGxhdGZvcm0tYWdub3N0aWMsIHdoaWxlIHRoZSBgQ1NTVHJhbnNpdGlvbmAgY29tcG9uZW50XG4gKiA+IFtmb3JjZXMgcmVmbG93c10oaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9ibG9iLzUwMDczMDNlNzI5YTc0YmU2NmEyMWMzZTIyMDVlNDkxNjgyMTUyNGIvc3JjL0NTU1RyYW5zaXRpb24uanMjTDIwOC1MMjE1KVxuICogPiBpbiBvcmRlciB0byBtYWtlIG1vcmUgY29tcGxleCB0cmFuc2l0aW9ucyBtb3JlIHByZWRpY3RhYmxlLiBGb3IgZXhhbXBsZSwgZXZlbiB0aG91Z2hcbiAqID4gY2xhc3NlcyBgZXhhbXBsZS1lbnRlcmAgYW5kIGBleGFtcGxlLWVudGVyLWFjdGl2ZWAgYXJlIGFwcGxpZWQgaW1tZWRpYXRlbHkgb25lIGFmdGVyXG4gKiA+IGFub3RoZXIsIHlvdSBjYW4gc3RpbGwgdHJhbnNpdGlvbiBmcm9tIG9uZSB0byB0aGUgb3RoZXIgYmVjYXVzZSBvZiB0aGUgZm9yY2VkIHJlZmxvd1xuICogPiAocmVhZCBbdGhpcyBpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9pc3N1ZXMvMTU5I2lzc3VlY29tbWVudC0zMjI3NjExNzEpXG4gKiA+IGZvciBtb3JlIGluZm8pLiBUYWtlIHRoaXMgaW50byBhY2NvdW50IHdoZW4gY2hvb3NpbmcgYmV0d2VlbiBgVHJhbnNpdGlvbmAgYW5kXG4gKiA+IGBDU1NUcmFuc2l0aW9uYC5cbiAqL1xuXG5leHBvcnRzLkVYSVRJTkcgPSBFWElUSU5HO1xuXG52YXIgVHJhbnNpdGlvbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShUcmFuc2l0aW9uLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUcmFuc2l0aW9uKHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgdmFyIHBhcmVudEdyb3VwID0gY29udGV4dC50cmFuc2l0aW9uR3JvdXA7IC8vIEluIHRoZSBjb250ZXh0IG9mIGEgVHJhbnNpdGlvbkdyb3VwIGFsbCBlbnRlcnMgYXJlIHJlYWxseSBhcHBlYXJzXG5cbiAgICB2YXIgYXBwZWFyID0gcGFyZW50R3JvdXAgJiYgIXBhcmVudEdyb3VwLmlzTW91bnRpbmcgPyBwcm9wcy5lbnRlciA6IHByb3BzLmFwcGVhcjtcbiAgICB2YXIgaW5pdGlhbFN0YXR1cztcbiAgICBfdGhpcy5hcHBlYXJTdGF0dXMgPSBudWxsO1xuXG4gICAgaWYgKHByb3BzLmluKSB7XG4gICAgICBpZiAoYXBwZWFyKSB7XG4gICAgICAgIGluaXRpYWxTdGF0dXMgPSBFWElURUQ7XG4gICAgICAgIF90aGlzLmFwcGVhclN0YXR1cyA9IEVOVEVSSU5HO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbFN0YXR1cyA9IEVOVEVSRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wcy51bm1vdW50T25FeGl0IHx8IHByb3BzLm1vdW50T25FbnRlcikge1xuICAgICAgICBpbml0aWFsU3RhdHVzID0gVU5NT1VOVEVEO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbFN0YXR1cyA9IEVYSVRFRDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHN0YXR1czogaW5pdGlhbFN0YXR1c1xuICAgIH07XG4gICAgX3RoaXMubmV4dENhbGxiYWNrID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVHJhbnNpdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNpdGlvbkdyb3VwOiBudWxsIC8vIGFsbG93cyBmb3IgbmVzdGVkIFRyYW5zaXRpb25zXG5cbiAgICB9O1xuICB9O1xuXG4gIFRyYW5zaXRpb24uZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKF9yZWYsIHByZXZTdGF0ZSkge1xuICAgIHZhciBuZXh0SW4gPSBfcmVmLmluO1xuXG4gICAgaWYgKG5leHRJbiAmJiBwcmV2U3RhdGUuc3RhdHVzID09PSBVTk1PVU5URUQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogRVhJVEVEXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9OyAvLyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgLy8gICBsZXQgbmV4dFN0YXR1cyA9IG51bGxcbiAgLy8gICBpZiAocHJldlByb3BzICE9PSB0aGlzLnByb3BzKSB7XG4gIC8vICAgICBjb25zdCB7IHN0YXR1cyB9ID0gdGhpcy5zdGF0ZVxuICAvLyAgICAgaWYgKHRoaXMucHJvcHMuaW4pIHtcbiAgLy8gICAgICAgaWYgKHN0YXR1cyAhPT0gRU5URVJJTkcgJiYgc3RhdHVzICE9PSBFTlRFUkVEKSB7XG4gIC8vICAgICAgICAgbmV4dFN0YXR1cyA9IEVOVEVSSU5HXG4gIC8vICAgICAgIH1cbiAgLy8gICAgIH0gZWxzZSB7XG4gIC8vICAgICAgIGlmIChzdGF0dXMgPT09IEVOVEVSSU5HIHx8IHN0YXR1cyA9PT0gRU5URVJFRCkge1xuICAvLyAgICAgICAgIG5leHRTdGF0dXMgPSBFWElUSU5HXG4gIC8vICAgICAgIH1cbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vICAgcmV0dXJuIHsgbmV4dFN0YXR1cyB9XG4gIC8vIH1cblxuXG4gIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMudXBkYXRlU3RhdHVzKHRydWUsIHRoaXMuYXBwZWFyU3RhdHVzKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIHZhciBuZXh0U3RhdHVzID0gbnVsbDtcblxuICAgIGlmIChwcmV2UHJvcHMgIT09IHRoaXMucHJvcHMpIHtcbiAgICAgIHZhciBzdGF0dXMgPSB0aGlzLnN0YXRlLnN0YXR1cztcblxuICAgICAgaWYgKHRoaXMucHJvcHMuaW4pIHtcbiAgICAgICAgaWYgKHN0YXR1cyAhPT0gRU5URVJJTkcgJiYgc3RhdHVzICE9PSBFTlRFUkVEKSB7XG4gICAgICAgICAgbmV4dFN0YXR1cyA9IEVOVEVSSU5HO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RhdHVzID09PSBFTlRFUklORyB8fCBzdGF0dXMgPT09IEVOVEVSRUQpIHtcbiAgICAgICAgICBuZXh0U3RhdHVzID0gRVhJVElORztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlU3RhdHVzKGZhbHNlLCBuZXh0U3RhdHVzKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmNhbmNlbE5leHRDYWxsYmFjaygpO1xuICB9O1xuXG4gIF9wcm90by5nZXRUaW1lb3V0cyA9IGZ1bmN0aW9uIGdldFRpbWVvdXRzKCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5wcm9wcy50aW1lb3V0O1xuICAgIHZhciBleGl0LCBlbnRlciwgYXBwZWFyO1xuICAgIGV4aXQgPSBlbnRlciA9IGFwcGVhciA9IHRpbWVvdXQ7XG5cbiAgICBpZiAodGltZW91dCAhPSBudWxsICYmIHR5cGVvZiB0aW1lb3V0ICE9PSAnbnVtYmVyJykge1xuICAgICAgZXhpdCA9IHRpbWVvdXQuZXhpdDtcbiAgICAgIGVudGVyID0gdGltZW91dC5lbnRlcjtcbiAgICAgIGFwcGVhciA9IHRpbWVvdXQuYXBwZWFyO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBleGl0OiBleGl0LFxuICAgICAgZW50ZXI6IGVudGVyLFxuICAgICAgYXBwZWFyOiBhcHBlYXJcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by51cGRhdGVTdGF0dXMgPSBmdW5jdGlvbiB1cGRhdGVTdGF0dXMobW91bnRpbmcsIG5leHRTdGF0dXMpIHtcbiAgICBpZiAobW91bnRpbmcgPT09IHZvaWQgMCkge1xuICAgICAgbW91bnRpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobmV4dFN0YXR1cyAhPT0gbnVsbCkge1xuICAgICAgLy8gbmV4dFN0YXR1cyB3aWxsIGFsd2F5cyBiZSBFTlRFUklORyBvciBFWElUSU5HLlxuICAgICAgdGhpcy5jYW5jZWxOZXh0Q2FsbGJhY2soKTtcblxuICAgICAgdmFyIG5vZGUgPSBfcmVhY3REb20uZGVmYXVsdC5maW5kRE9NTm9kZSh0aGlzKTtcblxuICAgICAgaWYgKG5leHRTdGF0dXMgPT09IEVOVEVSSU5HKSB7XG4gICAgICAgIHRoaXMucGVyZm9ybUVudGVyKG5vZGUsIG1vdW50aW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGVyZm9ybUV4aXQobm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLnVubW91bnRPbkV4aXQgJiYgdGhpcy5zdGF0ZS5zdGF0dXMgPT09IEVYSVRFRCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHN0YXR1czogVU5NT1VOVEVEXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnBlcmZvcm1FbnRlciA9IGZ1bmN0aW9uIHBlcmZvcm1FbnRlcihub2RlLCBtb3VudGluZykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGVudGVyID0gdGhpcy5wcm9wcy5lbnRlcjtcbiAgICB2YXIgYXBwZWFyaW5nID0gdGhpcy5jb250ZXh0LnRyYW5zaXRpb25Hcm91cCA/IHRoaXMuY29udGV4dC50cmFuc2l0aW9uR3JvdXAuaXNNb3VudGluZyA6IG1vdW50aW5nO1xuICAgIHZhciB0aW1lb3V0cyA9IHRoaXMuZ2V0VGltZW91dHMoKTsgLy8gbm8gZW50ZXIgYW5pbWF0aW9uIHNraXAgcmlnaHQgdG8gRU5URVJFRFxuICAgIC8vIGlmIHdlIGFyZSBtb3VudGluZyBhbmQgcnVubmluZyB0aGlzIGl0IG1lYW5zIGFwcGVhciBfbXVzdF8gYmUgc2V0XG5cbiAgICBpZiAoIW1vdW50aW5nICYmICFlbnRlcikge1xuICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICBzdGF0dXM6IEVOVEVSRURcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnByb3BzLm9uRW50ZXJlZChub2RlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucHJvcHMub25FbnRlcihub2RlLCBhcHBlYXJpbmcpO1xuICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgIHN0YXR1czogRU5URVJJTkdcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczIucHJvcHMub25FbnRlcmluZyhub2RlLCBhcHBlYXJpbmcpOyAvLyBGSVhNRTogYXBwZWFyIHRpbWVvdXQ/XG5cblxuICAgICAgX3RoaXMyLm9uVHJhbnNpdGlvbkVuZChub2RlLCB0aW1lb3V0cy5lbnRlciwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgICBzdGF0dXM6IEVOVEVSRURcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5wcm9wcy5vbkVudGVyZWQobm9kZSwgYXBwZWFyaW5nKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ucGVyZm9ybUV4aXQgPSBmdW5jdGlvbiBwZXJmb3JtRXhpdChub2RlKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgZXhpdCA9IHRoaXMucHJvcHMuZXhpdDtcbiAgICB2YXIgdGltZW91dHMgPSB0aGlzLmdldFRpbWVvdXRzKCk7IC8vIG5vIGV4aXQgYW5pbWF0aW9uIHNraXAgcmlnaHQgdG8gRVhJVEVEXG5cbiAgICBpZiAoIWV4aXQpIHtcbiAgICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgc3RhdHVzOiBFWElURURcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLnByb3BzLm9uRXhpdGVkKG5vZGUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wcm9wcy5vbkV4aXQobm9kZSk7XG4gICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgc3RhdHVzOiBFWElUSU5HXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMzLnByb3BzLm9uRXhpdGluZyhub2RlKTtcblxuICAgICAgX3RoaXMzLm9uVHJhbnNpdGlvbkVuZChub2RlLCB0aW1lb3V0cy5leGl0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICAgIHN0YXR1czogRVhJVEVEXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczMucHJvcHMub25FeGl0ZWQobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmNhbmNlbE5leHRDYWxsYmFjayA9IGZ1bmN0aW9uIGNhbmNlbE5leHRDYWxsYmFjaygpIHtcbiAgICBpZiAodGhpcy5uZXh0Q2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHRoaXMubmV4dENhbGxiYWNrLmNhbmNlbCgpO1xuICAgICAgdGhpcy5uZXh0Q2FsbGJhY2sgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uc2FmZVNldFN0YXRlID0gZnVuY3Rpb24gc2FmZVNldFN0YXRlKG5leHRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAvLyBUaGlzIHNob3VsZG4ndCBiZSBuZWNlc3NhcnksIGJ1dCB0aGVyZSBhcmUgd2VpcmQgcmFjZSBjb25kaXRpb25zIHdpdGhcbiAgICAvLyBzZXRTdGF0ZSBjYWxsYmFja3MgYW5kIHVubW91bnRpbmcgaW4gdGVzdGluZywgc28gYWx3YXlzIG1ha2Ugc3VyZSB0aGF0XG4gICAgLy8gd2UgY2FuIGNhbmNlbCBhbnkgcGVuZGluZyBzZXRTdGF0ZSBjYWxsYmFja3MgYWZ0ZXIgd2UgdW5tb3VudC5cbiAgICBjYWxsYmFjayA9IHRoaXMuc2V0TmV4dENhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICB0aGlzLnNldFN0YXRlKG5leHRTdGF0ZSwgY2FsbGJhY2spO1xuICB9O1xuXG4gIF9wcm90by5zZXROZXh0Q2FsbGJhY2sgPSBmdW5jdGlvbiBzZXROZXh0Q2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIHZhciBhY3RpdmUgPSB0cnVlO1xuXG4gICAgdGhpcy5uZXh0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIF90aGlzNC5uZXh0Q2FsbGJhY2sgPSBudWxsO1xuICAgICAgICBjYWxsYmFjayhldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMubmV4dENhbGxiYWNrLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5uZXh0Q2FsbGJhY2s7XG4gIH07XG5cbiAgX3Byb3RvLm9uVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIG9uVHJhbnNpdGlvbkVuZChub2RlLCB0aW1lb3V0LCBoYW5kbGVyKSB7XG4gICAgdGhpcy5zZXROZXh0Q2FsbGJhY2soaGFuZGxlcik7XG5cbiAgICBpZiAobm9kZSkge1xuICAgICAgaWYgKHRoaXMucHJvcHMuYWRkRW5kTGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5hZGRFbmRMaXN0ZW5lcihub2RlLCB0aGlzLm5leHRDYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLm5leHRDYWxsYmFjaywgdGltZW91dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy5uZXh0Q2FsbGJhY2ssIDApO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBzdGF0dXMgPSB0aGlzLnN0YXRlLnN0YXR1cztcblxuICAgIGlmIChzdGF0dXMgPT09IFVOTU9VTlRFRCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgY2hpbGRQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBbXCJjaGlsZHJlblwiXSk7IC8vIGZpbHRlciBwcm9wcyBmb3IgVHJhbnN0aXRpb25cblxuXG4gICAgZGVsZXRlIGNoaWxkUHJvcHMuaW47XG4gICAgZGVsZXRlIGNoaWxkUHJvcHMubW91bnRPbkVudGVyO1xuICAgIGRlbGV0ZSBjaGlsZFByb3BzLnVubW91bnRPbkV4aXQ7XG4gICAgZGVsZXRlIGNoaWxkUHJvcHMuYXBwZWFyO1xuICAgIGRlbGV0ZSBjaGlsZFByb3BzLmVudGVyO1xuICAgIGRlbGV0ZSBjaGlsZFByb3BzLmV4aXQ7XG4gICAgZGVsZXRlIGNoaWxkUHJvcHMudGltZW91dDtcbiAgICBkZWxldGUgY2hpbGRQcm9wcy5hZGRFbmRMaXN0ZW5lcjtcbiAgICBkZWxldGUgY2hpbGRQcm9wcy5vbkVudGVyO1xuICAgIGRlbGV0ZSBjaGlsZFByb3BzLm9uRW50ZXJpbmc7XG4gICAgZGVsZXRlIGNoaWxkUHJvcHMub25FbnRlcmVkO1xuICAgIGRlbGV0ZSBjaGlsZFByb3BzLm9uRXhpdDtcbiAgICBkZWxldGUgY2hpbGRQcm9wcy5vbkV4aXRpbmc7XG4gICAgZGVsZXRlIGNoaWxkUHJvcHMub25FeGl0ZWQ7XG5cbiAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW4oc3RhdHVzLCBjaGlsZFByb3BzKTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGQgPSBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcblxuICAgIHJldHVybiBfcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGNoaWxkUHJvcHMpO1xuICB9O1xuXG4gIHJldHVybiBUcmFuc2l0aW9uO1xufShfcmVhY3QuZGVmYXVsdC5Db21wb25lbnQpO1xuXG5UcmFuc2l0aW9uLmNvbnRleHRUeXBlcyA9IHtcbiAgdHJhbnNpdGlvbkdyb3VwOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuVHJhbnNpdGlvbi5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgdHJhbnNpdGlvbkdyb3VwOiBmdW5jdGlvbiB0cmFuc2l0aW9uR3JvdXAoKSB7fVxufTtcblRyYW5zaXRpb24ucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICAvKipcbiAgICogQSBgZnVuY3Rpb25gIGNoaWxkIGNhbiBiZSB1c2VkIGluc3RlYWQgb2YgYSBSZWFjdCBlbGVtZW50LlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRoZSBjdXJyZW50IHRyYW5zaXRpb24gc3RhdHVzXG4gICAqICgnZW50ZXJpbmcnLCAnZW50ZXJlZCcsICdleGl0aW5nJywgJ2V4aXRlZCcsICd1bm1vdW50ZWQnKSwgd2hpY2ggY2FuIGJlIHVzZWRcbiAgICogdG8gYXBwbHkgY29udGV4dCBzcGVjaWZpYyBwcm9wcyB0byBhIGNvbXBvbmVudC5cbiAgICpcbiAgICogYGBganN4XG4gICAqIDxUcmFuc2l0aW9uIHRpbWVvdXQ9ezE1MH0+XG4gICAqICAgeyhzdGF0dXMpID0+IChcbiAgICogICAgIDxNeUNvbXBvbmVudCBjbGFzc05hbWU9e2BmYWRlIGZhZGUtJHtzdGF0dXN9YH0gLz5cbiAgICogICApfVxuICAgKiA8L1RyYW5zaXRpb24+XG4gICAqIGBgYFxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsIFByb3BUeXBlcy5lbGVtZW50LmlzUmVxdWlyZWRdKS5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBjb21wb25lbnQ7IHRyaWdnZXJzIHRoZSBlbnRlciBvciBleGl0IHN0YXRlc1xuICAgKi9cbiAgaW46IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0IHRoZSBjaGlsZCBjb21wb25lbnQgaXMgbW91bnRlZCBpbW1lZGlhdGVseSBhbG9uZyB3aXRoXG4gICAqIHRoZSBwYXJlbnQgYFRyYW5zaXRpb25gIGNvbXBvbmVudC4gSWYgeW91IHdhbnQgdG8gXCJsYXp5IG1vdW50XCIgdGhlIGNvbXBvbmVudCBvbiB0aGVcbiAgICogZmlyc3QgYGluPXt0cnVlfWAgeW91IGNhbiBzZXQgYG1vdW50T25FbnRlcmAuIEFmdGVyIHRoZSBmaXJzdCBlbnRlciB0cmFuc2l0aW9uIHRoZSBjb21wb25lbnQgd2lsbCBzdGF5XG4gICAqIG1vdW50ZWQsIGV2ZW4gb24gXCJleGl0ZWRcIiwgdW5sZXNzIHlvdSBhbHNvIHNwZWNpZnkgYHVubW91bnRPbkV4aXRgLlxuICAgKi9cbiAgbW91bnRPbkVudGVyOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQnkgZGVmYXVsdCB0aGUgY2hpbGQgY29tcG9uZW50IHN0YXlzIG1vdW50ZWQgYWZ0ZXIgaXQgcmVhY2hlcyB0aGUgYCdleGl0ZWQnYCBzdGF0ZS5cbiAgICogU2V0IGB1bm1vdW50T25FeGl0YCBpZiB5b3UnZCBwcmVmZXIgdG8gdW5tb3VudCB0aGUgY29tcG9uZW50IGFmdGVyIGl0IGZpbmlzaGVzIGV4aXRpbmcuXG4gICAqL1xuICB1bm1vdW50T25FeGl0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogTm9ybWFsbHkgYSBjb21wb25lbnQgaXMgbm90IHRyYW5zaXRpb25lZCBpZiBpdCBpcyBzaG93biB3aGVuIHRoZSBgPFRyYW5zaXRpb24+YCBjb21wb25lbnQgbW91bnRzLlxuICAgKiBJZiB5b3Ugd2FudCB0byB0cmFuc2l0aW9uIG9uIHRoZSBmaXJzdCBtb3VudCBzZXQgYGFwcGVhcmAgdG8gYHRydWVgLCBhbmQgdGhlXG4gICAqIGNvbXBvbmVudCB3aWxsIHRyYW5zaXRpb24gaW4gYXMgc29vbiBhcyB0aGUgYDxUcmFuc2l0aW9uPmAgbW91bnRzLlxuICAgKlxuICAgKiA+IE5vdGU6IHRoZXJlIGFyZSBubyBzcGVjaWZpYyBcImFwcGVhclwiIHN0YXRlcy4gYGFwcGVhcmAgb25seSBhZGRzIGFuIGFkZGl0aW9uYWwgYGVudGVyYCB0cmFuc2l0aW9uLlxuICAgKi9cbiAgYXBwZWFyOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgZW50ZXIgdHJhbnNpdGlvbnMuXG4gICAqL1xuICBlbnRlcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGV4aXQgdHJhbnNpdGlvbnMuXG4gICAqL1xuICBleGl0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGR1cmF0aW9uIG9mIHRoZSB0cmFuc2l0aW9uLCBpbiBtaWxsaXNlY29uZHMuXG4gICAqIFJlcXVpcmVkIHVubGVzcyBgYWRkRW5kTGlzdGVuZXJgIGlzIHByb3ZpZGVkXG4gICAqXG4gICAqIFlvdSBtYXkgc3BlY2lmeSBhIHNpbmdsZSB0aW1lb3V0IGZvciBhbGwgdHJhbnNpdGlvbnMgbGlrZTogYHRpbWVvdXQ9ezUwMH1gLFxuICAgKiBvciBpbmRpdmlkdWFsbHkgbGlrZTpcbiAgICpcbiAgICogYGBganN4XG4gICAqIHRpbWVvdXQ9e3tcbiAgICogIGVudGVyOiAzMDAsXG4gICAqICBleGl0OiA1MDAsXG4gICAqIH19XG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyIHwgeyBlbnRlcj86IG51bWJlciwgZXhpdD86IG51bWJlciB9fVxuICAgKi9cbiAgdGltZW91dDogZnVuY3Rpb24gdGltZW91dChwcm9wcykge1xuICAgIHZhciBwdCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IF9Qcm9wVHlwZXMudGltZW91dHNTaGFwZSA6IHt9OztcbiAgICBpZiAoIXByb3BzLmFkZEVuZExpc3RlbmVyKSBwdCA9IHB0LmlzUmVxdWlyZWQ7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHQuYXBwbHkodm9pZCAwLCBbcHJvcHNdLmNvbmNhdChhcmdzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBhIGN1c3RvbSB0cmFuc2l0aW9uIGVuZCB0cmlnZ2VyLiBDYWxsZWQgd2l0aCB0aGUgdHJhbnNpdGlvbmluZ1xuICAgKiBET00gbm9kZSBhbmQgYSBgZG9uZWAgY2FsbGJhY2suIEFsbG93cyBmb3IgbW9yZSBmaW5lIGdyYWluZWQgdHJhbnNpdGlvbiBlbmRcbiAgICogbG9naWMuICoqTm90ZToqKiBUaW1lb3V0cyBhcmUgc3RpbGwgdXNlZCBhcyBhIGZhbGxiYWNrIGlmIHByb3ZpZGVkLlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogYWRkRW5kTGlzdGVuZXI9eyhub2RlLCBkb25lKSA9PiB7XG4gICAqICAgLy8gdXNlIHRoZSBjc3MgdHJhbnNpdGlvbmVuZCBldmVudCB0byBtYXJrIHRoZSBmaW5pc2ggb2YgYSB0cmFuc2l0aW9uXG4gICAqICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZG9uZSwgZmFsc2UpO1xuICAgKiB9fVxuICAgKiBgYGBcbiAgICovXG4gIGFkZEVuZExpc3RlbmVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYmVmb3JlIHRoZSBcImVudGVyaW5nXCIgc3RhdHVzIGlzIGFwcGxpZWQuIEFuIGV4dHJhIHBhcmFtZXRlclxuICAgKiBgaXNBcHBlYXJpbmdgIGlzIHN1cHBsaWVkIHRvIGluZGljYXRlIGlmIHRoZSBlbnRlciBzdGFnZSBpcyBvY2N1cnJpbmcgb24gdGhlIGluaXRpYWwgbW91bnRcbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKSAtPiB2b2lkXG4gICAqL1xuICBvbkVudGVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgdGhlIFwiZW50ZXJpbmdcIiBzdGF0dXMgaXMgYXBwbGllZC4gQW4gZXh0cmEgcGFyYW1ldGVyXG4gICAqIGBpc0FwcGVhcmluZ2AgaXMgc3VwcGxpZWQgdG8gaW5kaWNhdGUgaWYgdGhlIGVudGVyIHN0YWdlIGlzIG9jY3VycmluZyBvbiB0aGUgaW5pdGlhbCBtb3VudFxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpXG4gICAqL1xuICBvbkVudGVyaW5nOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgdGhlIFwiZW50ZXJlZFwiIHN0YXR1cyBpcyBhcHBsaWVkLiBBbiBleHRyYSBwYXJhbWV0ZXJcbiAgICogYGlzQXBwZWFyaW5nYCBpcyBzdXBwbGllZCB0byBpbmRpY2F0ZSBpZiB0aGUgZW50ZXIgc3RhZ2UgaXMgb2NjdXJyaW5nIG9uIHRoZSBpbml0aWFsIG1vdW50XG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbCkgLT4gdm9pZFxuICAgKi9cbiAgb25FbnRlcmVkOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYmVmb3JlIHRoZSBcImV4aXRpbmdcIiBzdGF0dXMgaXMgYXBwbGllZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpIC0+IHZvaWRcbiAgICovXG4gIG9uRXhpdDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHRoZSBcImV4aXRpbmdcIiBzdGF0dXMgaXMgYXBwbGllZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpIC0+IHZvaWRcbiAgICovXG4gIG9uRXhpdGluZzogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHRoZSBcImV4aXRlZFwiIHN0YXR1cyBpcyBhcHBsaWVkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCkgLT4gdm9pZFxuICAgKi9cbiAgb25FeGl0ZWQ6IFByb3BUeXBlcy5mdW5jIC8vIE5hbWUgdGhlIGZ1bmN0aW9uIHNvIGl0IGlzIGNsZWFyZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cblxufSA6IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuVHJhbnNpdGlvbi5kZWZhdWx0UHJvcHMgPSB7XG4gIGluOiBmYWxzZSxcbiAgbW91bnRPbkVudGVyOiBmYWxzZSxcbiAgdW5tb3VudE9uRXhpdDogZmFsc2UsXG4gIGFwcGVhcjogZmFsc2UsXG4gIGVudGVyOiB0cnVlLFxuICBleGl0OiB0cnVlLFxuICBvbkVudGVyOiBub29wLFxuICBvbkVudGVyaW5nOiBub29wLFxuICBvbkVudGVyZWQ6IG5vb3AsXG4gIG9uRXhpdDogbm9vcCxcbiAgb25FeGl0aW5nOiBub29wLFxuICBvbkV4aXRlZDogbm9vcFxufTtcblRyYW5zaXRpb24uVU5NT1VOVEVEID0gMDtcblRyYW5zaXRpb24uRVhJVEVEID0gMTtcblRyYW5zaXRpb24uRU5URVJJTkcgPSAyO1xuVHJhbnNpdGlvbi5FTlRFUkVEID0gMztcblRyYW5zaXRpb24uRVhJVElORyA9IDQ7XG5cbnZhciBfZGVmYXVsdCA9ICgwLCBfcmVhY3RMaWZlY3ljbGVzQ29tcGF0LnBvbHlmaWxsKShUcmFuc2l0aW9uKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19yZWFjdC10cmFuc2l0aW9uLWdyb3VwQDIuNS4yQHJlYWN0LXRyYW5zaXRpb24tZ3JvdXAvVHJhbnNpdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAvLyBDYWxsIHRoaXMuY29uc3RydWN0b3IuZ0RTRlAgdG8gc3VwcG9ydCBzdWItY2xhc3Nlcy5cbiAgdmFyIHN0YXRlID0gdGhpcy5jb25zdHJ1Y3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHModGhpcy5wcm9wcywgdGhpcy5zdGF0ZSk7XG4gIGlmIChzdGF0ZSAhPT0gbnVsbCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgLy8gQ2FsbCB0aGlzLmNvbnN0cnVjdG9yLmdEU0ZQIHRvIHN1cHBvcnQgc3ViLWNsYXNzZXMuXG4gIC8vIFVzZSB0aGUgc2V0U3RhdGUoKSB1cGRhdGVyIHRvIGVuc3VyZSBzdGF0ZSBpc24ndCBzdGFsZSBpbiBjZXJ0YWluIGVkZ2UgY2FzZXMuXG4gIGZ1bmN0aW9uIHVwZGF0ZXIocHJldlN0YXRlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5jb25zdHJ1Y3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuICAgIHJldHVybiBzdGF0ZSAhPT0gbnVsbCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkID8gc3RhdGUgOiBudWxsO1xuICB9XG4gIC8vIEJpbmRpbmcgXCJ0aGlzXCIgaXMgaW1wb3J0YW50IGZvciBzaGFsbG93IHJlbmRlcmVyIHN1cHBvcnQuXG4gIHRoaXMuc2V0U3RhdGUodXBkYXRlci5iaW5kKHRoaXMpKTtcbn1cblxuZnVuY3Rpb24gY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICB0cnkge1xuICAgIHZhciBwcmV2UHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwcmV2U3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHRoaXMucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgdGhpcy5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICB0aGlzLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90RmxhZyA9IHRydWU7XG4gICAgdGhpcy5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdCA9IHRoaXMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoXG4gICAgICBwcmV2UHJvcHMsXG4gICAgICBwcmV2U3RhdGVcbiAgICApO1xuICB9IGZpbmFsbHkge1xuICAgIHRoaXMucHJvcHMgPSBwcmV2UHJvcHM7XG4gICAgdGhpcy5zdGF0ZSA9IHByZXZTdGF0ZTtcbiAgfVxufVxuXG4vLyBSZWFjdCBtYXkgd2FybiBhYm91dCBjV00vY1dSUC9jV1UgbWV0aG9kcyBiZWluZyBkZXByZWNhdGVkLlxuLy8gQWRkIGEgZmxhZyB0byBzdXBwcmVzcyB0aGVzZSB3YXJuaW5ncyBmb3IgdGhpcyBzcGVjaWFsIGNhc2UuXG5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyA9IHRydWU7XG5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgPSB0cnVlO1xuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nID0gdHJ1ZTtcblxuZnVuY3Rpb24gcG9seWZpbGwoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuXG4gIGlmICghcHJvdG90eXBlIHx8ICFwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgcG9seWZpbGwgY2xhc3MgY29tcG9uZW50cycpO1xuICB9XG5cbiAgaWYgKFxuICAgIHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHByb3RvdHlwZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm4gQ29tcG9uZW50O1xuICB9XG5cbiAgLy8gSWYgbmV3IGNvbXBvbmVudCBBUElzIGFyZSBkZWZpbmVkLCBcInVuc2FmZVwiIGxpZmVjeWNsZXMgd29uJ3QgYmUgY2FsbGVkLlxuICAvLyBFcnJvciBpZiBhbnkgb2YgdGhlc2UgbGlmZWN5Y2xlcyBhcmUgcHJlc2VudCxcbiAgLy8gQmVjYXVzZSB0aGV5IHdvdWxkIHdvcmsgZGlmZmVyZW50bHkgYmV0d2VlbiBvbGRlciBhbmQgbmV3ZXIgKDE2LjMrKSB2ZXJzaW9ucyBvZiBSZWFjdC5cbiAgdmFyIGZvdW5kV2lsbE1vdW50TmFtZSA9IG51bGw7XG4gIHZhciBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gbnVsbDtcbiAgdmFyIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuICBpZiAodHlwZW9mIHByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnY29tcG9uZW50V2lsbE1vdW50JztcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvdG90eXBlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCc7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb3RvdHlwZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvdG90eXBlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm90b3R5cGUuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJztcbiAgfVxuICBpZiAoXG4gICAgZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsIHx8XG4gICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCB8fFxuICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGxcbiAgKSB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWU7XG4gICAgdmFyIG5ld0FwaU5hbWUgPVxuICAgICAgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyAnZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCknXG4gICAgICAgIDogJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlKCknO1xuXG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICAnVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJyArXG4gICAgICAgIGNvbXBvbmVudE5hbWUgK1xuICAgICAgICAnIHVzZXMgJyArXG4gICAgICAgIG5ld0FwaU5hbWUgK1xuICAgICAgICAnIGJ1dCBhbHNvIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgbGVnYWN5IGxpZmVjeWNsZXM6JyArXG4gICAgICAgIChmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgPyAnXFxuICAnICsgZm91bmRXaWxsTW91bnROYW1lIDogJycpICtcbiAgICAgICAgKGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGxcbiAgICAgICAgICA/ICdcXG4gICcgKyBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lXG4gICAgICAgICAgOiAnJykgK1xuICAgICAgICAoZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCA/ICdcXG4gICcgKyBmb3VuZFdpbGxVcGRhdGVOYW1lIDogJycpICtcbiAgICAgICAgJ1xcblxcblRoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1hc3luYy1jb21wb25lbnQtbGlmZWN5Y2xlLWhvb2tzJ1xuICAgICk7XG4gIH1cblxuICAvLyBSZWFjdCA8PSAxNi4yIGRvZXMgbm90IHN1cHBvcnQgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy5cbiAgLy8gQXMgYSB3b3JrYXJvdW5kLCB1c2UgY1dNIGFuZCBjV1JQIHRvIGludm9rZSB0aGUgbmV3IHN0YXRpYyBsaWZlY3ljbGUuXG4gIC8vIE5ld2VyIHZlcnNpb25zIG9mIFJlYWN0IHdpbGwgaWdub3JlIHRoZXNlIGxpZmVjeWNsZXMgaWYgZ0RTRlAgZXhpc3RzLlxuICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gY29tcG9uZW50V2lsbE1vdW50O1xuICAgIHByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcztcbiAgfVxuXG4gIC8vIFJlYWN0IDw9IDE2LjIgZG9lcyBub3Qgc3VwcG9ydCBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZS5cbiAgLy8gQXMgYSB3b3JrYXJvdW5kLCB1c2UgY1dVIHRvIGludm9rZSB0aGUgbmV3IGxpZmVjeWNsZS5cbiAgLy8gTmV3ZXIgdmVyc2lvbnMgb2YgUmVhY3Qgd2lsbCBpZ25vcmUgdGhhdCBsaWZlY3ljbGUgaWYgZ1NCVSBleGlzdHMuXG4gIGlmICh0eXBlb2YgcHJvdG90eXBlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGVvZiBwcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW5ub3QgcG9seWZpbGwgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBmb3IgY29tcG9uZW50cyB0aGF0IGRvIG5vdCBkZWZpbmUgY29tcG9uZW50RGlkVXBkYXRlKCkgb24gdGhlIHByb3RvdHlwZSdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcHJvdG90eXBlLmNvbXBvbmVudFdpbGxVcGRhdGUgPSBjb21wb25lbnRXaWxsVXBkYXRlO1xuXG4gICAgdmFyIGNvbXBvbmVudERpZFVwZGF0ZSA9IHByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGU7XG5cbiAgICBwcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlUG9seWZpbGwoXG4gICAgICBwcmV2UHJvcHMsXG4gICAgICBwcmV2U3RhdGUsXG4gICAgICBtYXliZVNuYXBzaG90XG4gICAgKSB7XG4gICAgICAvLyAxNi4zKyB3aWxsIG5vdCBleGVjdXRlIG91ciB3aWxsLXVwZGF0ZSBtZXRob2Q7XG4gICAgICAvLyBJdCB3aWxsIHBhc3MgYSBzbmFwc2hvdCB2YWx1ZSB0byBkaWQtdXBkYXRlIHRob3VnaC5cbiAgICAgIC8vIE9sZGVyIHZlcnNpb25zIHdpbGwgcmVxdWlyZSBvdXIgcG9seWZpbGxlZCB3aWxsLXVwZGF0ZSB2YWx1ZS5cbiAgICAgIC8vIFdlIG5lZWQgdG8gaGFuZGxlIGJvdGggY2FzZXMsIGJ1dCBjYW4ndCBqdXN0IGNoZWNrIGZvciB0aGUgcHJlc2VuY2Ugb2YgXCJtYXliZVNuYXBzaG90XCIsXG4gICAgICAvLyBCZWNhdXNlIGZvciA8PSAxNS54IHZlcnNpb25zIHRoaXMgbWlnaHQgYmUgYSBcInByZXZDb250ZXh0XCIgb2JqZWN0LlxuICAgICAgLy8gV2UgYWxzbyBjYW4ndCBqdXN0IGNoZWNrIFwiX19yZWFjdEludGVybmFsU25hcHNob3RcIixcbiAgICAgIC8vIEJlY2F1c2UgZ2V0LXNuYXBzaG90IG1pZ2h0IHJldHVybiBhIGZhbHN5IHZhbHVlLlxuICAgICAgLy8gU28gY2hlY2sgZm9yIHRoZSBleHBsaWNpdCBfX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEZsYWcgZmxhZyB0byBkZXRlcm1pbmUgYmVoYXZpb3IuXG4gICAgICB2YXIgc25hcHNob3QgPSB0aGlzLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90RmxhZ1xuICAgICAgICA/IHRoaXMuX19yZWFjdEludGVybmFsU25hcHNob3RcbiAgICAgICAgOiBtYXliZVNuYXBzaG90O1xuXG4gICAgICBjb21wb25lbnREaWRVcGRhdGUuY2FsbCh0aGlzLCBwcmV2UHJvcHMsIHByZXZTdGF0ZSwgc25hcHNob3QpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gQ29tcG9uZW50O1xufVxuXG5leHBvcnQgeyBwb2x5ZmlsbCB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19yZWFjdC1saWZlY3ljbGVzLWNvbXBhdEAzLjAuNEByZWFjdC1saWZlY3ljbGVzLWNvbXBhdC9yZWFjdC1saWZlY3ljbGVzLWNvbXBhdC5lcy5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy50cmFuc2l0aW9uVGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuZXhwb3J0cy5jbGFzc05hbWVzU2hhcGUgPSBleHBvcnRzLnRpbWVvdXRzU2hhcGUgPSB2b2lkIDA7XG5cbnZhciBfcHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25UaW1lb3V0KHRyYW5zaXRpb25UeXBlKSB7XG4gIHZhciB0aW1lb3V0UHJvcE5hbWUgPSAndHJhbnNpdGlvbicgKyB0cmFuc2l0aW9uVHlwZSArICdUaW1lb3V0JztcbiAgdmFyIGVuYWJsZWRQcm9wTmFtZSA9ICd0cmFuc2l0aW9uJyArIHRyYW5zaXRpb25UeXBlO1xuICByZXR1cm4gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgLy8gSWYgdGhlIHRyYW5zaXRpb24gaXMgZW5hYmxlZFxuICAgIGlmIChwcm9wc1tlbmFibGVkUHJvcE5hbWVdKSB7XG4gICAgICAvLyBJZiBubyB0aW1lb3V0IGR1cmF0aW9uIGlzIHByb3ZpZGVkXG4gICAgICBpZiAocHJvcHNbdGltZW91dFByb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IodGltZW91dFByb3BOYW1lICsgJyB3YXNuXFwndCBzdXBwbGllZCB0byBDU1NUcmFuc2l0aW9uR3JvdXA6ICcgKyAndGhpcyBjYW4gY2F1c2UgdW5yZWxpYWJsZSBhbmltYXRpb25zIGFuZCB3b25cXCd0IGJlIHN1cHBvcnRlZCBpbiAnICsgJ2EgZnV0dXJlIHZlcnNpb24gb2YgUmVhY3QuIFNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtYW5pbWF0aW9uLXRyYW5zaXRpb24tZ3JvdXAtdGltZW91dCBmb3IgbW9yZSAnICsgJ2luZm9ybWF0aW9uLicpOyAvLyBJZiB0aGUgZHVyYXRpb24gaXNuJ3QgYSBudW1iZXJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzW3RpbWVvdXRQcm9wTmFtZV0gIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IodGltZW91dFByb3BOYW1lICsgJyBtdXN0IGJlIGEgbnVtYmVyIChpbiBtaWxsaXNlY29uZHMpJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5cbnZhciB0aW1lb3V0c1NoYXBlID0gX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlciwgX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgZW50ZXI6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gIGV4aXQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXJcbn0pLmlzUmVxdWlyZWRdKTtcblxuZXhwb3J0cy50aW1lb3V0c1NoYXBlID0gdGltZW91dHNTaGFwZTtcblxudmFyIGNsYXNzTmFtZXNTaGFwZSA9IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsIF9wcm9wVHlwZXMuZGVmYXVsdC5zaGFwZSh7XG4gIGVudGVyOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICBleGl0OiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICBhY3RpdmU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmdcbn0pLCBfcHJvcFR5cGVzLmRlZmF1bHQuc2hhcGUoe1xuICBlbnRlcjogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgZW50ZXJEb25lOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICBlbnRlckFjdGl2ZTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgZXhpdDogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgZXhpdERvbmU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIGV4aXRBY3RpdmU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmdcbn0pXSk7XG5cbmV4cG9ydHMuY2xhc3NOYW1lc1NoYXBlID0gY2xhc3NOYW1lc1NoYXBlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fcmVhY3QtdHJhbnNpdGlvbi1ncm91cEAyLjUuMkByZWFjdC10cmFuc2l0aW9uLWdyb3VwL3V0aWxzL1Byb3BUeXBlcy5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX3JlYWN0TGlmZWN5Y2xlc0NvbXBhdCA9IHJlcXVpcmUoXCJyZWFjdC1saWZlY3ljbGVzLWNvbXBhdFwiKTtcblxudmFyIF9DaGlsZE1hcHBpbmcgPSByZXF1aXJlKFwiLi91dGlscy9DaGlsZE1hcHBpbmdcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG52YXIgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBvYmpba107XG4gIH0pO1xufTtcblxudmFyIHByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgLyoqXG4gICAqIGA8VHJhbnNpdGlvbkdyb3VwPmAgcmVuZGVycyBhIGA8ZGl2PmAgYnkgZGVmYXVsdC4gWW91IGNhbiBjaGFuZ2UgdGhpc1xuICAgKiBiZWhhdmlvciBieSBwcm92aWRpbmcgYSBgY29tcG9uZW50YCBwcm9wLlxuICAgKiBJZiB5b3UgdXNlIFJlYWN0IHYxNisgYW5kIHdvdWxkIGxpa2UgdG8gYXZvaWQgYSB3cmFwcGluZyBgPGRpdj5gIGVsZW1lbnRcbiAgICogeW91IGNhbiBwYXNzIGluIGBjb21wb25lbnQ9e251bGx9YC4gVGhpcyBpcyB1c2VmdWwgaWYgdGhlIHdyYXBwaW5nIGRpdlxuICAgKiBib3JrcyB5b3VyIGNzcyBzdHlsZXMuXG4gICAqL1xuICBjb21wb25lbnQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5hbnksXG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIGA8VHJhbnNpdGlvbj5gIGNvbXBvbmVudHMsIHRoYXQgYXJlIHRvZ2dsZWQgYGluYCBhbmQgb3V0IGFzIHRoZXlcbiAgICogbGVhdmUuIHRoZSBgPFRyYW5zaXRpb25Hcm91cD5gIHdpbGwgaW5qZWN0IHNwZWNpZmljIHRyYW5zaXRpb24gcHJvcHMsIHNvXG4gICAqIHJlbWVtYmVyIHRvIHNwcmVhZCB0aGVtIHRocm91Z2ggaWYgeW91IGFyZSB3cmFwcGluZyB0aGUgYDxUcmFuc2l0aW9uPmAgYXNcbiAgICogd2l0aCBvdXIgYDxGYWRlPmAgZXhhbXBsZS5cbiAgICovXG4gIGNoaWxkcmVuOiBfcHJvcFR5cGVzLmRlZmF1bHQubm9kZSxcblxuICAvKipcbiAgICogQSBjb252ZW5pZW5jZSBwcm9wIHRoYXQgZW5hYmxlcyBvciBkaXNhYmxlcyBhcHBlYXIgYW5pbWF0aW9uc1xuICAgKiBmb3IgYWxsIGNoaWxkcmVuLiBOb3RlIHRoYXQgc3BlY2lmeWluZyB0aGlzIHdpbGwgb3ZlcnJpZGUgYW55IGRlZmF1bHRzIHNldFxuICAgKiBvbiBpbmRpdmlkdWFsIGNoaWxkcmVuIFRyYW5zaXRpb25zLlxuICAgKi9cbiAgYXBwZWFyOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcblxuICAvKipcbiAgICogQSBjb252ZW5pZW5jZSBwcm9wIHRoYXQgZW5hYmxlcyBvciBkaXNhYmxlcyBlbnRlciBhbmltYXRpb25zXG4gICAqIGZvciBhbGwgY2hpbGRyZW4uIE5vdGUgdGhhdCBzcGVjaWZ5aW5nIHRoaXMgd2lsbCBvdmVycmlkZSBhbnkgZGVmYXVsdHMgc2V0XG4gICAqIG9uIGluZGl2aWR1YWwgY2hpbGRyZW4gVHJhbnNpdGlvbnMuXG4gICAqL1xuICBlbnRlcjogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgcHJvcCB0aGF0IGVuYWJsZXMgb3IgZGlzYWJsZXMgZXhpdCBhbmltYXRpb25zXG4gICAqIGZvciBhbGwgY2hpbGRyZW4uIE5vdGUgdGhhdCBzcGVjaWZ5aW5nIHRoaXMgd2lsbCBvdmVycmlkZSBhbnkgZGVmYXVsdHMgc2V0XG4gICAqIG9uIGluZGl2aWR1YWwgY2hpbGRyZW4gVHJhbnNpdGlvbnMuXG4gICAqL1xuICBleGl0OiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcblxuICAvKipcbiAgICogWW91IG1heSBuZWVkIHRvIGFwcGx5IHJlYWN0aXZlIHVwZGF0ZXMgdG8gYSBjaGlsZCBhcyBpdCBpcyBleGl0aW5nLlxuICAgKiBUaGlzIGlzIGdlbmVyYWxseSBkb25lIGJ5IHVzaW5nIGBjbG9uZUVsZW1lbnRgIGhvd2V2ZXIgaW4gdGhlIGNhc2Ugb2YgYW4gZXhpdGluZ1xuICAgKiBjaGlsZCB0aGUgZWxlbWVudCBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQgYW5kIG5vdCBhY2Nlc3NpYmxlIHRvIHRoZSBjb25zdW1lci5cbiAgICpcbiAgICogSWYgeW91IGRvIG5lZWQgdG8gdXBkYXRlIGEgY2hpbGQgYXMgaXQgbGVhdmVzIHlvdSBjYW4gcHJvdmlkZSBhIGBjaGlsZEZhY3RvcnlgXG4gICAqIHRvIHdyYXAgZXZlcnkgY2hpbGQsIGV2ZW4gdGhlIG9uZXMgdGhhdCBhcmUgbGVhdmluZy5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24oY2hpbGQ6IFJlYWN0RWxlbWVudCkgLT4gUmVhY3RFbGVtZW50XG4gICAqL1xuICBjaGlsZEZhY3Rvcnk6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jXG59IDoge307O1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgY29tcG9uZW50OiAnZGl2JyxcbiAgY2hpbGRGYWN0b3J5OiBmdW5jdGlvbiBjaGlsZEZhY3RvcnkoY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBgPFRyYW5zaXRpb25Hcm91cD5gIGNvbXBvbmVudCBtYW5hZ2VzIGEgc2V0IG9mIHRyYW5zaXRpb24gY29tcG9uZW50c1xuICAgKiAoYDxUcmFuc2l0aW9uPmAgYW5kIGA8Q1NTVHJhbnNpdGlvbj5gKSBpbiBhIGxpc3QuIExpa2Ugd2l0aCB0aGUgdHJhbnNpdGlvblxuICAgKiBjb21wb25lbnRzLCBgPFRyYW5zaXRpb25Hcm91cD5gIGlzIGEgc3RhdGUgbWFjaGluZSBmb3IgbWFuYWdpbmcgdGhlIG1vdW50aW5nXG4gICAqIGFuZCB1bm1vdW50aW5nIG9mIGNvbXBvbmVudHMgb3ZlciB0aW1lLlxuICAgKlxuICAgKiBDb25zaWRlciB0aGUgZXhhbXBsZSBiZWxvdy4gQXMgaXRlbXMgYXJlIHJlbW92ZWQgb3IgYWRkZWQgdG8gdGhlIFRvZG9MaXN0IHRoZVxuICAgKiBgaW5gIHByb3AgaXMgdG9nZ2xlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBgPFRyYW5zaXRpb25Hcm91cD5gLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgYDxUcmFuc2l0aW9uR3JvdXA+YCAgZG9lcyBub3QgZGVmaW5lIGFueSBhbmltYXRpb24gYmVoYXZpb3IhXG4gICAqIEV4YWN0bHkgX2hvd18gYSBsaXN0IGl0ZW0gYW5pbWF0ZXMgaXMgdXAgdG8gdGhlIGluZGl2aWR1YWwgdHJhbnNpdGlvblxuICAgKiBjb21wb25lbnQuIFRoaXMgbWVhbnMgeW91IGNhbiBtaXggYW5kIG1hdGNoIGFuaW1hdGlvbnMgYWNyb3NzIGRpZmZlcmVudCBsaXN0XG4gICAqIGl0ZW1zLlxuICAgKi9cblxufTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShUcmFuc2l0aW9uR3JvdXAsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRyYW5zaXRpb25Hcm91cChwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSB8fCB0aGlzO1xuXG4gICAgdmFyIGhhbmRsZUV4aXRlZCA9IF90aGlzLmhhbmRsZUV4aXRlZC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpKTsgLy8gSW5pdGlhbCBjaGlsZHJlbiBzaG91bGQgYWxsIGJlIGVudGVyaW5nLCBkZXBlbmRlbnQgb24gYXBwZWFyXG5cblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgaGFuZGxlRXhpdGVkOiBoYW5kbGVFeGl0ZWQsXG4gICAgICBmaXJzdFJlbmRlcjogdHJ1ZVxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRyYW5zaXRpb25Hcm91cC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNpdGlvbkdyb3VwOiB7XG4gICAgICAgIGlzTW91bnRpbmc6ICF0aGlzLmFwcGVhcmVkXG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLmFwcGVhcmVkID0gdHJ1ZTtcbiAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICB9O1xuXG4gIFRyYW5zaXRpb25Hcm91cC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBfcmVmKSB7XG4gICAgdmFyIHByZXZDaGlsZE1hcHBpbmcgPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgICBoYW5kbGVFeGl0ZWQgPSBfcmVmLmhhbmRsZUV4aXRlZCxcbiAgICAgICAgZmlyc3RSZW5kZXIgPSBfcmVmLmZpcnN0UmVuZGVyO1xuICAgIHJldHVybiB7XG4gICAgICBjaGlsZHJlbjogZmlyc3RSZW5kZXIgPyAoMCwgX0NoaWxkTWFwcGluZy5nZXRJbml0aWFsQ2hpbGRNYXBwaW5nKShuZXh0UHJvcHMsIGhhbmRsZUV4aXRlZCkgOiAoMCwgX0NoaWxkTWFwcGluZy5nZXROZXh0Q2hpbGRNYXBwaW5nKShuZXh0UHJvcHMsIHByZXZDaGlsZE1hcHBpbmcsIGhhbmRsZUV4aXRlZCksXG4gICAgICBmaXJzdFJlbmRlcjogZmFsc2VcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5oYW5kbGVFeGl0ZWQgPSBmdW5jdGlvbiBoYW5kbGVFeGl0ZWQoY2hpbGQsIG5vZGUpIHtcbiAgICB2YXIgY3VycmVudENoaWxkTWFwcGluZyA9ICgwLCBfQ2hpbGRNYXBwaW5nLmdldENoaWxkTWFwcGluZykodGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgaWYgKGNoaWxkLmtleSBpbiBjdXJyZW50Q2hpbGRNYXBwaW5nKSByZXR1cm47XG5cbiAgICBpZiAoY2hpbGQucHJvcHMub25FeGl0ZWQpIHtcbiAgICAgIGNoaWxkLnByb3BzLm9uRXhpdGVkKG5vZGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1vdW50ZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IF9leHRlbmRzKHt9LCBzdGF0ZS5jaGlsZHJlbik7XG5cbiAgICAgICAgZGVsZXRlIGNoaWxkcmVuW2NoaWxkLmtleV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBDb21wb25lbnQgPSBfdGhpcyRwcm9wcy5jb21wb25lbnQsXG4gICAgICAgIGNoaWxkRmFjdG9yeSA9IF90aGlzJHByb3BzLmNoaWxkRmFjdG9yeSxcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiY29tcG9uZW50XCIsIFwiY2hpbGRGYWN0b3J5XCJdKTtcblxuICAgIHZhciBjaGlsZHJlbiA9IHZhbHVlcyh0aGlzLnN0YXRlLmNoaWxkcmVuKS5tYXAoY2hpbGRGYWN0b3J5KTtcbiAgICBkZWxldGUgcHJvcHMuYXBwZWFyO1xuICAgIGRlbGV0ZSBwcm9wcy5lbnRlcjtcbiAgICBkZWxldGUgcHJvcHMuZXhpdDtcblxuICAgIGlmIChDb21wb25lbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHByb3BzLCBjaGlsZHJlbik7XG4gIH07XG5cbiAgcmV0dXJuIFRyYW5zaXRpb25Hcm91cDtcbn0oX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50KTtcblxuVHJhbnNpdGlvbkdyb3VwLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICB0cmFuc2l0aW9uR3JvdXA6IF9wcm9wVHlwZXMuZGVmYXVsdC5vYmplY3QuaXNSZXF1aXJlZFxufTtcblRyYW5zaXRpb25Hcm91cC5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBwcm9wVHlwZXMgOiB7fTtcblRyYW5zaXRpb25Hcm91cC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cbnZhciBfZGVmYXVsdCA9ICgwLCBfcmVhY3RMaWZlY3ljbGVzQ29tcGF0LnBvbHlmaWxsKShUcmFuc2l0aW9uR3JvdXApO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19yZWFjdC10cmFuc2l0aW9uLWdyb3VwQDIuNS4yQHJlYWN0LXRyYW5zaXRpb24tZ3JvdXAvVHJhbnNpdGlvbkdyb3VwLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgSWNvbiBmcm9tICcuLi8uLi9pY29uJztcbmltcG9ydCBPdmVybGF5IGZyb20gJy4uLy4uL292ZXJsYXknO1xuaW1wb3J0IHsgZnVuYywgb2JqLCBkb20gfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCBJdGVtIGZyb20gJy4vaXRlbSc7XG5pbXBvcnQgU2VsZWN0YWJsZUl0ZW0gZnJvbSAnLi9zZWxlY3RhYmxlLWl0ZW0nO1xuXG5jb25zdCB7IGJpbmRDdHggfSA9IGZ1bmM7XG5jb25zdCB7IHNldFN0eWxlIH0gPSBkb207XG5jb25zdCBQb3B1cCA9IE92ZXJsYXkuUG9wdXA7XG5cbi8qKlxuICogTWVudS5Qb3B1cEl0ZW1cbiAqIEBvcmRlciAyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvcHVwSXRlbSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIG1lbnVDaGlsZFR5cGUgPSAnc3VibWVudSc7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBfa2V5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICByb290OiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBsZXZlbDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgaGFzU3ViTWVudTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHNlbGVjdGFibGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5qCH562+5YaF5a65XG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnlvLnlsYLlhoXlrrlcbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICB0cmlnZ2VyVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnY2xpY2snLCAnaG92ZXInXSksXG4gICAgICAgIGFsaWduOiBQcm9wVHlwZXMub25lT2YoWydvdXRzaWRlJywgJ2ZvbGxvdyddKSxcbiAgICAgICAgYXV0b1dpZHRoOiBQcm9wVHlwZXMuYm9vbFxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBzZWxlY3RhYmxlOiBmYWxzZVxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgYmluZEN0eCh0aGlzLCBbICdoYW5kbGVPcGVuJywgJ2hhbmRsZVBvcHVwT3BlbicsICdoYW5kbGVQb3B1cENsb3NlJywgJ2dldFBvcHVwJ10pO1xuICAgIH1cblxuICAgIGdldFBvcHVwKHJlZikge1xuICAgICAgICB0aGlzLnBvcHVwID0gcmVmO1xuICAgIH1cblxuICAgIGdldE9wZW4oKSB7XG4gICAgICAgIGNvbnN0IHsgX2tleSwgcm9vdCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBvcGVuS2V5cyB9ID0gcm9vdC5zdGF0ZTtcblxuICAgICAgICByZXR1cm4gb3BlbktleXMuaW5kZXhPZihfa2V5KSA+IC0xO1xuICAgIH1cblxuICAgIGdldFBvcHVwUHJvcHMoKSB7XG4gICAgICAgIGxldCB7IHBvcHVwUHJvcHMgfSA9IHRoaXMucHJvcHMucm9vdC5wcm9wcztcbiAgICAgICAgaWYgKHR5cGVvZiBwb3B1cFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwb3B1cFByb3BzID0gcG9wdXBQcm9wcyh0aGlzLnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9wdXBQcm9wcztcbiAgICB9XG5cbiAgICBoYW5kbGVPcGVuKG9wZW4sIHRyaWdnZXJUeXBlLCBlKSB7XG4gICAgICAgIGNvbnN0IHsgX2tleSwgcm9vdCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgcm9vdC5oYW5kbGVPcGVuKF9rZXksIG9wZW4sIHRyaWdnZXJUeXBlLCBlKTtcblxuICAgICAgICBjb25zdCBwb3B1cFByb3BzID0gdGhpcy5wb3B1cFByb3BzO1xuICAgICAgICBwb3B1cFByb3BzLm9uVmlzaWJsZUNoYW5nZSAmJiBwb3B1cFByb3BzLm9uVmlzaWJsZUNoYW5nZShvcGVuLCB0cmlnZ2VyVHlwZSwgZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlUG9wdXBPcGVuKCkge1xuICAgICAgICBjb25zdCB7IHJvb3QsIGxldmVsLCBhbGlnbiwgYXV0b1dpZHRoIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHBvcHVwQXV0b1dpZHRoOiByb290UG9wdXBBdXRvV2lkdGgsIHBvcHVwQWxpZ246IHJvb3RQb3B1cEFsaWduLCBkaXJlY3Rpb24gfSA9IHJvb3QucHJvcHM7XG4gICAgICAgIGNvbnN0IHBvcHVwQWxpZ24gPSBhbGlnbiB8fCByb290UG9wdXBBbGlnbjtcbiAgICAgICAgY29uc3QgcG9wdXBBdXRvV2lkdGggPSAnYXV0b1dpZHRoJyBpbiB0aGlzLnByb3BzID8gYXV0b1dpZHRoIDogcm9vdFBvcHVwQXV0b1dpZHRoO1xuICAgICAgICBjb25zdCBpdGVtTm9kZSA9IGZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgICBjb25zdCBtZW51Tm9kZSA9IGl0ZW1Ob2RlLnBhcmVudE5vZGU7XG4gICAgICAgIHRoaXMucG9wdXBOb2RlID0gdGhpcy5wb3B1cC5nZXRJbnN0YW5jZSgpLm92ZXJsYXkuZ2V0SW5zdGFuY2UoKS5nZXRDb250ZW50Tm9kZSgpO1xuICAgICAgICByb290LnBvcHVwTm9kZXMucHVzaCh0aGlzLnBvcHVwTm9kZSk7XG5cbiAgICAgICAgaWYgKHBvcHVwQXV0b1dpZHRoKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gZGlyZWN0aW9uID09PSAnaG96JyAmJiBsZXZlbCA9PT0gMSA/IGl0ZW1Ob2RlIDogbWVudU5vZGU7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXROb2RlLm9mZnNldFdpZHRoID4gdGhpcy5wb3B1cE5vZGUub2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBzZXRTdHlsZSh0aGlzLnBvcHVwTm9kZSwgJ3dpZHRoJywgYCR7dGFyZ2V0Tm9kZS5vZmZzZXRXaWR0aH1weGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3B1cEFsaWduID09PSAnb3V0c2lkZScgJiYgIShkaXJlY3Rpb24gPT09ICdob3onICYmIGxldmVsID09PSAxKSkge1xuICAgICAgICAgICAgc2V0U3R5bGUodGhpcy5wb3B1cE5vZGUsICdoZWlnaHQnLCBgJHttZW51Tm9kZS5vZmZzZXRIZWlnaHR9cHhgKTtcbiAgICAgICAgICAgIHNldFN0eWxlKHRoaXMucG9wdXBOb2RlLCAnb3ZlcmZsb3cteScsICdzY3JvbGwnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmVDbGFzcyh0aGlzLnBvcHVwTm9kZSwgYCR7cHJlZml4fWhpZGVgKTtcblxuICAgICAgICBjb25zdCBwb3B1cFByb3BzID0gdGhpcy5wb3B1cFByb3BzO1xuICAgICAgICBwb3B1cFByb3BzLm9uT3BlbiAmJiBwb3B1cFByb3BzLm9uT3BlbigpO1xuICAgIH1cblxuICAgIGhhbmRsZVBvcHVwQ2xvc2UoKSB7XG4gICAgICAgIGNvbnN0IHsgcm9vdCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgcG9wdXBOb2RlcyA9IHJvb3QucG9wdXBOb2RlcztcbiAgICAgICAgY29uc3QgaW5kZXggPSBwb3B1cE5vZGVzLmluZGV4T2YodGhpcy5wb3B1cE5vZGUpO1xuICAgICAgICBpbmRleCA+IC0xICYmIHBvcHVwTm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICBjb25zdCBwb3B1cFByb3BzID0gdGhpcy5wb3B1cFByb3BzO1xuICAgICAgICBwb3B1cFByb3BzLm9uQ2xvc2UgJiYgcG9wdXBQcm9wcy5vbkNsb3NlKCk7XG4gICAgfVxuXG4gICAgcmVuZGVySXRlbShzZWxlY3RhYmxlLCBjaGlsZHJlbiwgb3RoZXJzKSB7XG4gICAgICAgIGNvbnN0IHsgX2tleSwgcm9vdCwgbGV2ZWwsIGxhYmVsLCBjbGFzc05hbWUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4IH0gPSByb290LnByb3BzO1xuICAgICAgICBjb25zdCBOZXdJdGVtID0gc2VsZWN0YWJsZSA/IFNlbGVjdGFibGVJdGVtIDogSXRlbTtcbiAgICAgICAgY29uc3Qgb3BlbiA9IHRoaXMuZ2V0T3BlbigpO1xuXG4gICAgICAgIGNvbnN0IGl0ZW1Qcm9wcyA9IHtcbiAgICAgICAgICAgICdhcmlhLWhhc3BvcHVwJzogdHJ1ZSxcbiAgICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogb3BlbixcbiAgICAgICAgICAgIF9rZXksXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICB0eXBlOiAnc3VibWVudSdcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIGl0ZW1Qcm9wcy5jbGFzc05hbWUgPSBjeCh7XG4gICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1vcGVuZWRgXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBbY2xhc3NOYW1lXTogISFjbGFzc05hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbVByb3BzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8TmV3SXRlbSB7Li4uaXRlbVByb3BzfSB7Li4ub3RoZXJzfT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Ake3ByZWZpeH1tZW51LWl0ZW0tdGV4dGB9PntsYWJlbH08L3NwYW4+XG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgPC9OZXdJdGVtPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJlbmRlclBvcHVwKHRyaWdnZXIsIHRyaWdnZXJUeXBlLCBwb3NpdGlvblByb3BzLCBjaGlsZHJlbikge1xuICAgICAgICBjb25zdCB7IHJvb3QsIGxldmVsLCBzZWxlY3RhYmxlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IGRpcmVjdGlvbiB9ID0gcm9vdC5wcm9wcztcbiAgICAgICAgdGhpcy5wb3B1cFByb3BzID0gdGhpcy5nZXRQb3B1cFByb3BzKCk7XG4gICAgICAgIGNvbnN0IG9wZW4gPSB0aGlzLmdldE9wZW4oKTtcblxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnaG96JyAmJiBsZXZlbCA9PT0gMSAmJiBzZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICBwb3NpdGlvblByb3BzLnRhcmdldCA9ICgpID0+IGZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxQb3B1cCByZWY9e3RoaXMuZ2V0UG9wdXB9XG4gICAgICAgICAgICAgICAgey4uLnBvc2l0aW9uUHJvcHN9XG4gICAgICAgICAgICAgICAgey4uLnRoaXMucG9wdXBQcm9wc31cbiAgICAgICAgICAgICAgICBjYW5DbG9zZUJ5RXNjPXtmYWxzZX1cbiAgICAgICAgICAgICAgICB0cmlnZ2VyPXt0cmlnZ2VyfVxuICAgICAgICAgICAgICAgIHRyaWdnZXJUeXBlPXt0cmlnZ2VyVHlwZX1cbiAgICAgICAgICAgICAgICB2aXNpYmxlPXtvcGVufVxuICAgICAgICAgICAgICAgIG9uVmlzaWJsZUNoYW5nZT17dGhpcy5oYW5kbGVPcGVufVxuICAgICAgICAgICAgICAgIG9uT3Blbj17dGhpcy5oYW5kbGVQb3B1cE9wZW59XG4gICAgICAgICAgICAgICAgb25DbG9zZT17dGhpcy5oYW5kbGVQb3B1cENsb3NlfT5cbiAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICA8L1BvcHVwPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyByb290LCBsZXZlbCwgaGFzU3ViTWVudSwgc2VsZWN0YWJsZTogc2VsZWN0YWJsZUZyb21Qcm9wcywgY2hpbGRyZW4sIHRyaWdnZXJUeXBlLCBhbGlnbiwgcnRsIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBvdGhlcnMgPSBvYmoucGlja090aGVycyhPYmplY3Qua2V5cyhQb3B1cEl0ZW0ucHJvcFR5cGVzKSwgdGhpcy5wcm9wcyk7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBzZWxlY3RNb2RlLCBkaXJlY3Rpb24sIHBvcHVwQWxpZ246IHJvb3RQb3B1cEFsaWduLCB0cmlnZ2VyVHlwZTogcm9vdFRyaWdnZXJUeXBlIH0gPSByb290LnByb3BzO1xuICAgICAgICBjb25zdCBwb3B1cEFsaWduID0gYWxpZ24gfHwgcm9vdFBvcHVwQWxpZ247XG4gICAgICAgIGNvbnN0IG5ld1RyaWdnZXJUeXBlID0gdHJpZ2dlclR5cGUgfHwgKGhhc1N1Yk1lbnUgPyByb290VHJpZ2dlclR5cGUgOiAnaG92ZXInKTtcbiAgICAgICAgY29uc3QgbmV3Q2hpbGRyZW4gPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuWzBdIDogY2hpbGRyZW47XG4gICAgICAgIC8vIGxldCBuZXdDaGlsZHJlbiA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW5bMF0gOiBjaGlsZHJlbjtcbiAgICAgICAgLy8gbmV3Q2hpbGRyZW4gPSBjbG9uZUVsZW1lbnQobmV3Q2hpbGRyZW4sIHtcbiAgICAgICAgLy8gICAgIGNsYXNzTmFtZTogY3goe1xuICAgICAgICAvLyAgICAgICAgIFtgJHtwcmVmaXh9bWVudS1wb3B1cC1jb250ZW50YF06IHRydWUsXG4gICAgICAgIC8vICAgICAgICAgW25ld0NoaWxkcmVuLnByb3BzLmNsYXNzTmFtZV06ICEhbmV3Q2hpbGRyZW4ucHJvcHMuY2xhc3NOYW1lLFxuICAgICAgICAvLyAgICAgICAgIFtgJHtwcmVmaXh9aGlkZWBdOiBwb3B1cEF1dG9XaWR0aCB8fCBwb3B1cEFsaWduID09PSAnb3V0c2lkZSdcbiAgICAgICAgLy8gICAgIH0pXG4gICAgICAgIC8vIH0pO1xuICAgICAgICBjb25zdCBzZWxlY3RhYmxlID0gc2VsZWN0TW9kZSAmJiBzZWxlY3RhYmxlRnJvbVByb3BzO1xuICAgICAgICBjb25zdCB0cmlnZ2VySXNJY29uID0gc2VsZWN0YWJsZSAmJiBuZXdUcmlnZ2VyVHlwZSA9PT0gJ2NsaWNrJztcbiAgICAgICAgY29uc3Qgb3BlbiA9IHRoaXMuZ2V0T3BlbigpO1xuXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uUHJvcHMgPSB7fTtcbiAgICAgICAgbGV0IGFycm93UHJvcHM7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2hveicgJiYgbGV2ZWwgPT09IDEpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uUHJvcHMuYWxpZ24gPSAndGwgYmwnO1xuICAgICAgICAgICAgcG9zaXRpb25Qcm9wcy5vZmZzZXQgPSBbMCwgMF07XG5cbiAgICAgICAgICAgIGFycm93UHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Fycm93LWRvd24nLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY3goe1xuICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4fW1lbnUtaG96LWljb24tYXJyb3dgXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1vcGVuYF06IG9wZW5cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocG9wdXBBbGlnbiA9PT0gJ291dHNpZGUnKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25Qcm9wcy50YXJnZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5kRE9NTm9kZShyb290KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uUHJvcHMuYWxpZ24gPSAndGwgdHInO1xuXG4gICAgICAgICAgICAgICAgcnRsID9cbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25Qcm9wcy5vZmZzZXQgPSBbLTIsIDBdIDpcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25Qcm9wcy5vZmZzZXQgPSBbMiwgMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VySXNJY29uKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uUHJvcHMudGFyZ2V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3NpdGlvblByb3BzLmFsaWduID0gJ3RsIHRyJztcblxuICAgICAgICAgICAgICAgIHJ0bCA/XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uUHJvcHMub2Zmc2V0ID0gWzIsIC04XSA6XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uUHJvcHMub2Zmc2V0ID0gWy0yLCAtOF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFycm93UHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Fycm93LXJpZ2h0JyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGAke3ByZWZpeH1tZW51LWljb24tYXJyb3dgXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXJyb3cgPSA8SWNvbiB7Li4uYXJyb3dQcm9wc30gLz47XG4gICAgICAgIGNvbnN0IHRyaWdnZXIgPSB0cmlnZ2VySXNJY29uID8gYXJyb3cgOiB0aGlzLnJlbmRlckl0ZW0oc2VsZWN0YWJsZSwgYXJyb3csIG90aGVycyk7XG4gICAgICAgIGNvbnN0IHBvcHVwID0gdGhpcy5yZW5kZXJQb3B1cCh0cmlnZ2VyLCBuZXdUcmlnZ2VyVHlwZSwgcG9zaXRpb25Qcm9wcywgbmV3Q2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gdHJpZ2dlcklzSWNvbiA/IHRoaXMucmVuZGVySXRlbShzZWxlY3RhYmxlLCBwb3B1cCwgb3RoZXJzKSA6IHBvcHVwO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tZW51L3ZpZXcvcG9wdXAtaXRlbS5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBDaGVja2JveCBmcm9tICcuLi8uLi9jaGVja2JveCc7XG5pbXBvcnQgUmFkaW8gZnJvbSAnLi4vLi4vcmFkaW8nO1xuaW1wb3J0IHsgZnVuYywgb2JqLCBLRVlDT0RFIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgSXRlbSBmcm9tICcuL2l0ZW0nO1xuXG5jb25zdCBub29wID0ge307XG5jb25zdCB7IGJpbmRDdHggfSA9IGZ1bmM7XG5jb25zdCB7IHBpY2tPdGhlcnMgfSA9IG9iajtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hlY2thYmxlSXRlbSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgX2tleTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcm9vdDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBpbmxpbmVJbmRlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGNoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBpbmRldGVybWluYXRlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBjaGVja1R5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2NoZWNrYm94JywgJ3JhZGlvJ10pLFxuICAgICAgICBjaGVja0Rpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgaGVscGVyOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICBvbktleURvd246IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuY1xuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIGNoZWNrZWQ6IGZhbHNlLFxuICAgICAgICBpbmRldGVybWluYXRlOiBmYWxzZSxcbiAgICAgICAgY2hlY2tUeXBlOiAnY2hlY2tib3gnLFxuICAgICAgICBjaGVja0Rpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgb25DaGFuZ2U6IG5vb3BcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIGJpbmRDdHgodGhpcywgWydzdG9wUHJvcGFnYXRpb24nLCAnaGFuZGxlS2V5RG93bicsICdoYW5kbGVDbGljayddKTtcbiAgICB9XG5cbiAgICBzdG9wUHJvcGFnYXRpb24oZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIGhhbmRsZUNoZWNrKGUpIHtcbiAgICAgICAgY29uc3QgeyBjaGVja1R5cGUsIGNoZWNrZWQsIG9uQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAoIShjaGVja1R5cGUgPT09ICdyYWRpbycgJiYgY2hlY2tlZCkpIHtcbiAgICAgICAgICAgIG9uQ2hhbmdlKCFjaGVja2VkLCBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZUtleURvd24oZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBLRVlDT0RFLlNQQUNFICYmICF0aGlzLnByb3BzLmNoZWNrRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hlY2soZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3BzLm9uS2V5RG93biAmJiB0aGlzLnByb3BzLm9uS2V5RG93bihlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDbGljayhlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2hlY2soZSk7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vbkNsaWNrICYmIHRoaXMucHJvcHMub25DbGljayhlKTtcbiAgICB9XG5cbiAgICByZW5kZXJDaGVjaygpIHtcbiAgICAgICAgY29uc3QgeyByb290LCBjaGVja2VkLCBpbmRldGVybWluYXRlLCBkaXNhYmxlZCwgY2hlY2tUeXBlLCBjaGVja0Rpc2FibGVkLCBvbkNoYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBsYWJlbFRvZ2dsZUNoZWNrZWQgfSA9IHJvb3QucHJvcHM7XG4gICAgICAgIGNvbnN0IENoZWNrID0gY2hlY2tUeXBlID09PSAncmFkaW8nID8gUmFkaW8gOiBDaGVja2JveDtcblxuICAgICAgICBjb25zdCBjaGVja1Byb3BzID0ge1xuICAgICAgICAgICAgdGFiSW5kZXg6ICctMScsXG4gICAgICAgICAgICBjaGVja2VkLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkIHx8IGNoZWNrRGlzYWJsZWRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNoZWNrVHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgICAgICAgICAgY2hlY2tQcm9wcy5pbmRldGVybWluYXRlID0gaW5kZXRlcm1pbmF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxhYmVsVG9nZ2xlQ2hlY2tlZCkge1xuICAgICAgICAgICAgY2hlY2tQcm9wcy5vbkNoYW5nZSA9IG9uQ2hhbmdlO1xuICAgICAgICAgICAgY2hlY2tQcm9wcy5vbkNsaWNrID0gdGhpcy5zdG9wUHJvcGFnYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPENoZWNrIHsuLi5jaGVja1Byb3BzfSAvPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBfa2V5LCByb290LCBjaGVja2VkLCBkaXNhYmxlZCwgb25DbGljaywgaGVscGVyLCBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIGxhYmVsVG9nZ2xlQ2hlY2tlZCB9ID0gcm9vdC5wcm9wcztcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gcGlja090aGVycyhPYmplY3Qua2V5cyhDaGVja2FibGVJdGVtLnByb3BUeXBlcyksIHRoaXMucHJvcHMpO1xuXG4gICAgICAgIGNvbnN0IG5ld1Byb3BzID0ge1xuICAgICAgICAgICAgX2tleSxcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgICAgIHR5cGU6ICdpdGVtJyxcbiAgICAgICAgICAgIG9uQ2xpY2ssXG4gICAgICAgICAgICBvbktleURvd246IHRoaXMuaGFuZGxlS2V5RG93bixcbiAgICAgICAgICAgIC4uLm90aGVyc1xuICAgICAgICB9O1xuICAgICAgICBpZiAobGFiZWxUb2dnbGVDaGVja2VkICYmICFkaXNhYmxlZCkge1xuICAgICAgICAgICAgbmV3UHJvcHMub25DbGljayA9IHRoaXMuaGFuZGxlQ2xpY2s7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEl0ZW0gYXJpYS1jaGVja2VkPXtjaGVja2VkfSB7Li4ubmV3UHJvcHN9PlxuICAgICAgICAgICAgICAgIHt0aGlzLnJlbmRlckNoZWNrKCl9XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtgJHtwcmVmaXh9bWVudS1pdGVtLXRleHRgfT57Y2hpbGRyZW59PC9zcGFuPlxuICAgICAgICAgICAgICAgIHtoZWxwZXIgPyA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fW1lbnUtaXRlbS1oZWxwZXJgfT57aGVscGVyfTwvZGl2PiA6IG51bGx9XG4gICAgICAgICAgICA8L0l0ZW0+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21lbnUvdmlldy9jaGVja2FibGUtaXRlbS5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFVJU3RhdGUgZnJvbSAnLi4vbWl4aW4tdWktc3RhdGUnO1xuaW1wb3J0IENvbmZpZ1Byb3ZpZGVyIGZyb20gJy4uL2NvbmZpZy1wcm92aWRlcic7XG5pbXBvcnQgSWNvbiBmcm9tICcuLi9pY29uJztcbmltcG9ydCB7IG9iaiwgZnVuYyB9IGZyb20gJy4uL3V0aWwnO1xuXG5jb25zdCBub29wID0gZnVuYy5ub29wO1xuZnVuY3Rpb24gaXNDaGVja2VkKHNlbGVjdGVkVmFsdWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHNlbGVjdGVkVmFsdWUuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbn1cbi8qKlxuICogQ2hlY2tib3hcbiAqIEBvcmRlciAxXG4gKi9cbmNsYXNzIENoZWNrYm94IGV4dGVuZHMgVUlTdGF0ZSB7XG4gICAgc3RhdGljIGRpc3BsYXlOYW1lID0gJ0NoZWNrYm94JztcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnnsbvlkI1cbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoZWNrYm94IGlkLCDmjILovb3lnKhpbnB1dOS4ilxuICAgICAgICAgKi9cbiAgICAgICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnlhoXmlZvmoLflvI9cbiAgICAgICAgICovXG4gICAgICAgIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAvKipcbiAgICAgICAgICog6YCJ5Lit54q25oCBXG4gICAgICAgICAqL1xuICAgICAgICBjaGVja2VkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOm7mOiupOmAieS4reeKtuaAgVxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdENoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog56aB55SoXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpgJrov4flsZ7mgKfphY3nva5sYWJlbO+8jFxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tib3gg55qE5Lit6Ze054q25oCB77yM5Y+q5Lya5b2x5ZON5YiwIENoZWNrYm94IOeahOagt+W8j++8jOW5tuS4jeW9seWTjeWFtiBjaGVja2VkIOWxnuaAp1xuICAgICAgICAgKi9cbiAgICAgICAgaW5kZXRlcm1pbmF0ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgQ2hlY2tib3gg55qE6buY6K6k5Lit6Ze05oCB77yM5Y+q5Lya5b2x5ZON5YiwIENoZWNrYm94IOeahOagt+W8j++8jOW5tuS4jeW9seWTjeWFtiBjaGVja2VkIOWxnuaAp1xuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdEluZGV0ZXJtaW5hdGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog54q25oCB5Y+Y5YyW5pe26Kem5Y+R55qE5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2hlY2tlZCDmmK/lkKbpgInkuK1cbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSBEb20g5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpvKDmoIfov5vlhaVlbnRlcuS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIERvbSDkuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIG9uTW91c2VFbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpvKDmoIfnprvlvIBMZWF2ZeS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIERvbSDkuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIG9uTW91c2VMZWF2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgfVxuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgZGVmYXVsdENoZWNrZWQ6IGZhbHNlLFxuICAgICAgICBkZWZhdWx0SW5kZXRlcm1pbmF0ZTogZmFsc2UsXG4gICAgICAgIG9uQ2hhbmdlOiBub29wLFxuICAgICAgICBvbk1vdXNlRW50ZXI6IG5vb3AsXG4gICAgICAgIG9uTW91c2VMZWF2ZTogbm9vcCxcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgIH1cblxuICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgX19ncm91cF9fOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZTogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgbGV0IGNoZWNrZWQsIGluZGV0ZXJtaW5hdGU7XG4gICAgICAgIGlmIChjb250ZXh0Ll9fZ3JvdXBfXykge1xuICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgY2hlY2tlZCA9IGlzQ2hlY2tlZChjb250ZXh0LnNlbGVjdGVkVmFsdWUsIHByb3BzLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICgnY2hlY2tlZCcgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hlY2tlZCA9IHByb3BzLmRlZmF1bHRDaGVja2VkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoJ2luZGV0ZXJtaW5hdGUnIGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZSA9IHByb3BzLmluZGV0ZXJtaW5hdGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV0ZXJtaW5hdGUgPSBwcm9wcy5kZWZhdWx0SW5kZXRlcm1pbmF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjaGVja2VkLFxuICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZSxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRpc2FibGVkID0gIHByb3BzLmRpc2FibGVkIHx8IChjb250ZXh0Ll9fZ3JvdXBfXyAmJiAoJ2Rpc2FibGVkJyBpbiBjb250ZXh0KSAmJiBjb250ZXh0LmRpc2FibGVkKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICAgICAgaWYgKG5leHRDb250ZXh0Ll9fZ3JvdXBfXykge1xuICAgICAgICAgICAgaWYgKCdzZWxlY3RlZFZhbHVlJyBpbiBuZXh0Q29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBpc0NoZWNrZWQobmV4dENvbnRleHQuc2VsZWN0ZWRWYWx1ZSwgbmV4dFByb3BzLnZhbHVlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNhYmxlZCA9IG5leHRQcm9wcy5kaXNhYmxlZCB8fCAoXG4gICAgICAgICAgICAgICAgJ2Rpc2FibGVkJyBpbiBuZXh0Q29udGV4dCAmJlxuICAgICAgICAgICAgICAgIG5leHRDb250ZXh0LmRpc2FibGVkXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCdjaGVja2VkJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogbmV4dFByb3BzLmNoZWNrZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnaW5kZXRlcm1pbmF0ZScgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGluZGV0ZXJtaW5hdGU6IG5leHRQcm9wcy5pbmRldGVybWluYXRlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVkID0gbmV4dFByb3BzLmRpc2FibGVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgICAgICAgY29uc3QgeyBzaGFsbG93RXF1YWwgfSA9IG9iajtcbiAgICAgICAgcmV0dXJuICFzaGFsbG93RXF1YWwodGhpcy5wcm9wcywgbmV4dFByb3BzKSB8fFxuICAgICAgICAgICAgIXNoYWxsb3dFcXVhbCh0aGlzLnN0YXRlLCBuZXh0U3RhdGUpIHx8XG4gICAgICAgICAgICAhc2hhbGxvd0VxdWFsKHRoaXMuY29udGV4dCwgbmV4dENvbnRleHQpO1xuICAgIH1cblxuICAgIG9uQ2hhbmdlKGUpIHtcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9IGUudGFyZ2V0LmNoZWNrZWQ7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wcm9wcy52YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb250ZXh0Ll9fZ3JvdXBfXykge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0Lm9uQ2hhbmdlKHZhbHVlLCBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghKCdjaGVja2VkJyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBjaGVja2VkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKCdpbmRldGVybWluYXRlJyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBpbmRldGVybWluYXRlOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShjaGVja2VkLCBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgY29uc3QgeyBpZCwgY2xhc3NOYW1lLCBjaGlsZHJlbiwgc3R5bGUsIGxhYmVsLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSwgcnRsLFxuICAgICAgICAgICAgLi4ub3RoZXJQcm9wcyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9ICEhdGhpcy5zdGF0ZS5jaGVja2VkO1xuICAgICAgICBjb25zdCBkaXNhYmxlZCA9IHRoaXMuZGlzYWJsZWQ7XG4gICAgICAgIGNvbnN0IGluZGV0ZXJtaW5hdGUgPSAhIXRoaXMuc3RhdGUuaW5kZXRlcm1pbmF0ZTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gdGhpcy5jb250ZXh0LnByZWZpeCB8fCB0aGlzLnByb3BzLnByZWZpeDtcblxuICAgICAgICBjb25zdCBvdGhlcnMgPSBvYmoucGlja090aGVycyhDaGVja2JveC5wcm9wVHlwZXMsIG90aGVyUHJvcHMpO1xuICAgICAgICBjb25zdCBvdGhlcnNEYXRhID0gb2JqLnBpY2tBdHRyc1dpdGgob3RoZXJzLCAnZGF0YS0nKTtcblxuXG5cbiAgICAgICAgbGV0IGNoaWxkSW5wdXQgPSAoPGlucHV0XG4gICAgICAgICAgICB7Li4ub2JqLnBpY2tPdGhlcnMoQ2hlY2tib3gucHJvcFR5cGVzLCBvdGhlclByb3BzKX1cbiAgICAgICAgICAgIGlkPXtpZH1cbiAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICAgIGNoZWNrZWQ9e2NoZWNrZWR9XG4gICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25DaGFuZ2V9XG4gICAgICAgICAgICBhcmlhLWNoZWNrZWQ9e2luZGV0ZXJtaW5hdGUgPyAnbWl4ZWQnIDogY2hlY2tlZH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7cHJlZml4fWNoZWNrYm94LWlucHV0YH1cbiAgICAgICAgLz4pO1xuXG4gICAgICAgIC8vIGRpc2FibGUg5peg54q25oCB5pON5L2cXG4gICAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGNoaWxkSW5wdXQgPSB0aGlzLmdldFN0YXRlRWxlbWVudChjaGlsZElucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbHMgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9Y2hlY2tib3gtd3JhcHBlcmBdOiB0cnVlLFxuICAgICAgICAgICAgW2NsYXNzTmFtZV06ICEhY2xhc3NOYW1lLFxuICAgICAgICAgICAgY2hlY2tlZCxcbiAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZSxcbiAgICAgICAgICAgIFt0aGlzLmdldFN0YXRlQ2xhc3NOYW1lKCldOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBsYWJlbENscyA9IGAke3ByZWZpeH1jaGVja2JveC1sYWJlbGA7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBpbmRldGVybWluYXRlID8gJ3NlbWktc2VsZWN0JyA6ICdzZWxlY3QnO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8bGFiZWxcbiAgICAgICAgICAgICAgICB7Li4ub3RoZXJzRGF0YX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nsc31cbiAgICAgICAgICAgICAgICBzdHlsZT17c3R5bGV9XG4gICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyPXtvbk1vdXNlRW50ZXJ9XG4gICAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXtvbk1vdXNlTGVhdmV9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtgJHtwcmVmaXh9Y2hlY2tib3hgfT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtgJHtwcmVmaXh9Y2hlY2tib3gtaW5uZXJgfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9e3R5cGV9IHNpemU9XCJ4c1wiIGNsYXNzTmFtZT17aW5kZXRlcm1pbmF0ZSA/ICd6b29tSW4nIDogJyd9IC8+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAge2NoaWxkSW5wdXR9XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIHtbbGFiZWwsIGNoaWxkcmVuXS5tYXAoKGl0ZW0sIGkpID0+IChpdGVtID8gPHNwYW4ga2V5PXtpfSBjbGFzc05hbWU9e2xhYmVsQ2xzfT57aXRlbX08L3NwYW4+IDogbnVsbCkpfVxuICAgICAgICAgICAgPC9sYWJlbD4pO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlnUHJvdmlkZXIuY29uZmlnKENoZWNrYm94KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jaGVja2JveC9jaGVja2JveC5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBmdW5jIH0gZnJvbSAnLi4vdXRpbCc7XG5cbmNvbnN0IHsgbWFrZUNoYWluIH0gPSBmdW5jO1xuLy8gVUlTdGF0ZSDkuLrkuIDkupvnibnmrorlhYPntKDnmoTnirbmgIHlk43lupTmj5DkvpvkuobmoIflh4bnmoTmlrnlvI/vvIxcbi8vIOWwpOWFtumAguWQiENTU+aXoOazleWujOWFqOWumuWItueahOaOp+S7tu+8jOavlOWmgmNoZWNrYm9477yMcmFkaW/nrYnjgIJcbi8vIOiLpee7hOS7tiBkaXNhYmxlIOWImeiHquihjOWIpOaWreaYr+WQpumcgOimgee7keWumueKtuaAgeeuoeeQhuOAglxuLy8g5rOo5oSP77yaZGlzYWJsZSDkuI3kvJrop6blj5Hkuovku7bvvIzor7fkvb/nlKhyZXNldFVJU3RhdGXov5jljp/nirbmgIFcbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3Byb3AtdHlwZXMgKi9cbmNsYXNzIFVJU3RhdGUgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgICBbJ19vblVJRm9jdXMnLCAnX29uVUlCbHVyJ10uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIHRoaXNbaXRlbV0gPSB0aGlzW2l0ZW1dLmJpbmQodGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBiYXNlIOS6i+S7tue7keWumueahOWFg+e0oFxuICAgIGdldFN0YXRlRWxlbWVudChiYXNlKSB7XG4gICAgICAgIGNvbnN0IHsgb25Gb2N1cywgb25CbHVyIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGJhc2UsIHtcbiAgICAgICAgICAgIG9uRm9jdXM6IG1ha2VDaGFpbih0aGlzLl9vblVJRm9jdXMsIG9uRm9jdXMpLFxuICAgICAgICAgICAgb25CbHVyOiBtYWtlQ2hhaW4odGhpcy5fb25VSUJsdXIsIG9uQmx1cilcbiAgICAgICAgfSk7XG5cbiAgICB9XG4gICAgLy8g6I635Y+W54q25oCBY2xhc3NuYW1lXG4gICAgZ2V0U3RhdGVDbGFzc05hbWUoKSB7XG4gICAgICAgIGNvbnN0IHsgZm9jdXNlZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgcmV0dXJuIGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgZm9jdXNlZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8g5aSN5Y6f54q25oCBXG4gICAgcmVzZXRVSVN0YXRlKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZvY3VzZWQ6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX29uVUlGb2N1cygpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBmb2N1c2VkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfb25VSUJsdXIoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZm9jdXNlZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBVSVN0YXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21peGluLXVpLXN0YXRlL2luZGV4LmpzeCIsImltcG9ydCBSYWRpbyBmcm9tICcuL3JhZGlvJztcbmltcG9ydCBSYWRpb0dyb3VwIGZyb20gJy4vcmFkaW8tZ3JvdXAnO1xuXG5SYWRpby5Hcm91cCA9IFJhZGlvR3JvdXA7XG5cbmV4cG9ydCBkZWZhdWx0IFJhZGlvO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JhZGlvL2luZGV4LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgVUlTdGF0ZSBmcm9tICcuLi9taXhpbi11aS1zdGF0ZSc7XG5pbXBvcnQgQ29uZmlnUHJvdmlkZXIgZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCB7IG9iaiwgZnVuYyB9IGZyb20gJy4uL3V0aWwnO1xuXG5jb25zdCB7IG1ha2VDaGFpbiwgbm9vcCB9ID0gZnVuYztcbi8qKlxuICogUmFkaW9cbiAqIEBvcmRlciAxXG4gKi9cbmNsYXNzIFJhZGlvIGV4dGVuZHMgVUlTdGF0ZSB7XG4gICAgc3RhdGljIGRpc3BsYXlOYW1lID0gJ1JhZGlvJztcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnnsbvlkI1cbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe7hOS7tmlucHV055qEaWRcbiAgICAgICAgICovXG4gICAgICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ5YaF5pWb5qC35byPXG4gICAgICAgICAqL1xuICAgICAgICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9rnJhZGlv5piv5ZCm6YCJ5LitXG4gICAgICAgICAqL1xuICAgICAgICBjaGVja2VkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9rnJhZGlv5piv5ZCm6buY6K6k6YCJ5LitXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0Q2hlY2tlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpgJrov4flsZ7mgKfphY3nva5sYWJlbFxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICAvKipcbiAgICAgICAgICog54q25oCB5Y+Y5YyW5pe26Kem5Y+R55qE5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2hlY2tlZCDmmK/lkKbpgInkuK1cbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSBEb20g5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpvKDmoIfov5vlhaVlbnRlcuS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIERvbSDkuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIG9uTW91c2VFbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpvKDmoIfnprvlvIDkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSBEb20g5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBvbk1vdXNlTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICogcmFkaW/mmK/lkKbooqvnpoHnlKhcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJhZGlvIOeahHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLmJvb2xdKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgfVxuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgb25DaGFuZ2U6IG5vb3AsXG4gICAgICAgIG9uTW91c2VMZWF2ZTogbm9vcCxcbiAgICAgICAgb25Nb3VzZUVudGVyOiBub29wLFxuICAgICAgICB0YWJJbmRleDogMCxcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nXG4gICAgfVxuXG4gICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBfX2dyb3VwX186IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBpc0J1dHRvbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHNlbGVjdGVkVmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5ib29sXSksXG4gICAgICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgbGV0IGNoZWNrZWQ7XG4gICAgICAgIGlmIChjb250ZXh0Ll9fZ3JvdXBfXykge1xuICAgICAgICAgICAgY2hlY2tlZCA9IGNvbnRleHQuc2VsZWN0ZWRWYWx1ZSA9PT0gcHJvcHMudmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2NoZWNrZWQnIGluIHByb3BzKSB7XG4gICAgICAgICAgICBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrZWQgPSBwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7IGNoZWNrZWQgfTtcblxuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gdGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQgfHwgIChjb250ZXh0Ll9fZ3JvdXBfXyAmJiAoJ2Rpc2FibGVkJyBpbiBjb250ZXh0KSAmJiBjb250ZXh0LmRpc2FibGVkKTtcblxuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzLCBuZXh0Q29udGV4dCkge1xuICAgICAgICBpZiAobmV4dENvbnRleHQuX19ncm91cF9fKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNlbGVjdGVkVmFsdWUgfSA9IG5leHRDb250ZXh0O1xuICAgICAgICAgICAgaWYgKCdzZWxlY3RlZFZhbHVlJyBpbiBuZXh0Q29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBzZWxlY3RlZFZhbHVlID09PSBuZXh0UHJvcHMudmFsdWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoJ2NoZWNrZWQnIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgY2hlY2tlZDogbmV4dFByb3BzLmNoZWNrZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IG5leHRQcm9wcy5kaXNhYmxlZCB8fCAgKG5leHRDb250ZXh0Ll9fZ3JvdXBfXyAmJiAoJ2Rpc2FibGVkJyBpbiBuZXh0Q29udGV4dCkgJiYgbmV4dENvbnRleHQuZGlzYWJsZWQpO1xuXG4gICAgICAgIC8vIHdoZW4gZGlzYWJsZWQsIHJlc2V0IFVJU3RhdGVcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgY2xhc3MgaGFzIGFuIGltcGFjdCwgbm8gZWZmZWN0IG9uIHZpc3VhbFxuICAgICAgICAgICAgdGhpcy5yZXNldFVJU3RhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgICAgICAgY29uc3QgeyBzaGFsbG93RXF1YWwgfSA9IG9iajtcbiAgICAgICAgcmV0dXJuICFzaGFsbG93RXF1YWwodGhpcy5wcm9wcywgbmV4dFByb3BzKSB8fFxuICAgICAgICAgICAgIXNoYWxsb3dFcXVhbCh0aGlzLnN0YXRlLCBuZXh0U3RhdGUpIHx8XG4gICAgICAgICAgICAhc2hhbGxvd0VxdWFsKHRoaXMubmV4dENvbnRleHQsIG5leHRDb250ZXh0KTtcbiAgICB9XG5cbiAgICBvbkNoYW5nZShlKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrZWQgPSBlLnRhcmdldC5jaGVja2VkO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucHJvcHMudmFsdWU7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5fX2dyb3VwX18pIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5vbkNoYW5nZSh2YWx1ZSwgZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5jaGVja2VkICE9PSBjaGVja2VkKSB7XG4gICAgICAgICAgICBpZiAoISgnY2hlY2tlZCcgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogY2hlY2tlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShjaGVja2VkLCBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgY29uc3QgeyBpZCwgY2xhc3NOYW1lLCBjaGlsZHJlbiwgc3R5bGUsIGxhYmVsLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSwgdGFiSW5kZXgsIHJ0bCxcbiAgICAgICAgICAgIC4uLm90aGVyUHJvcHMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGNoZWNrZWQgPSAhIXRoaXMuc3RhdGUuY2hlY2tlZDtcbiAgICAgICAgY29uc3QgZGlzYWJsZWQgPSB0aGlzLmRpc2FibGVkO1xuICAgICAgICBjb25zdCBpc0J1dHRvbiA9IHRoaXMuY29udGV4dC5pc0J1dHRvbjtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gdGhpcy5jb250ZXh0LnByZWZpeCB8fCB0aGlzLnByb3BzLnByZWZpeDtcblxuICAgICAgICBjb25zdCBvdGhlcnMgPSBvYmoucGlja090aGVycyhSYWRpby5wcm9wVHlwZXMsIG90aGVyUHJvcHMpO1xuICAgICAgICBjb25zdCBvdGhlcnNEYXRhID0gb2JqLnBpY2tBdHRyc1dpdGgob3RoZXJzLCAnZGF0YS0nKTtcblxuXG4gICAgICAgIGxldCBpbnB1dCA9ICg8aW5wdXRcbiAgICAgICAgICAgIHsuLi5vYmoucGlja090aGVycyhvdGhlcnNEYXRhLCBvdGhlcnMpfVxuICAgICAgICAgICAgaWQ9e2lkfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cbiAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZX1cbiAgICAgICAgICAgIGFyaWEtY2hlY2tlZD17Y2hlY2tlZH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7cHJlZml4fXJhZGlvLWlucHV0YH1cbiAgICAgICAgLz4pO1xuXG4gICAgICAgIC8vIGRpc2FibGVkIGRvIG5vdCBob3ZlIGZvY3VzIHN0YXRlXG4gICAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGlucHV0ID0gdGhpcy5nZXRTdGF0ZUVsZW1lbnQoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2xzID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fXJhZGlvYF06IHRydWUsXG4gICAgICAgICAgICBjaGVja2VkLFxuICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICBbdGhpcy5nZXRTdGF0ZUNsYXNzTmFtZSgpXTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xzSW5uZXIgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9cmFkaW8taW5uZXJgXTogdHJ1ZSxcbiAgICAgICAgICAgIHByZXNzOiBjaGVja2VkLFxuICAgICAgICAgICAgdW5wcmVzczogIWNoZWNrZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNsc1dyYXBwZXIgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9cmFkaW8td3JhcHBlcmBdOiB0cnVlLFxuICAgICAgICAgICAgW2NsYXNzTmFtZV06ICEhY2xhc3NOYW1lLFxuICAgICAgICAgICAgY2hlY2tlZCxcbiAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgW3RoaXMuZ2V0U3RhdGVDbGFzc05hbWUoKV06IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuQ2xzID0gYCR7cHJlZml4fXJhZGlvLWxhYmVsYDtcblxuICAgICAgICBjb25zdCByYWRpb0NvbXAgPSAhaXNCdXR0b24gP1xuICAgICAgICAgICAgKDxzcGFuIGNsYXNzTmFtZT17Y2xzfT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Nsc0lubmVyfT48L3NwYW4+XG4gICAgICAgICAgICAgICAge2lucHV0fVxuICAgICAgICAgICAgPC9zcGFuPikgOlxuICAgICAgICAgICAgKDxzcGFuIGNsYXNzTmFtZT17YCR7cHJlZml4fXJhZGlvLXNpbmdsZS1pbnB1dGB9PlxuICAgICAgICAgICAgICAgIHtpbnB1dH1cbiAgICAgICAgICAgIDwvc3Bhbj4pO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8bGFiZWxcbiAgICAgICAgICAgICAgICB7Li4ub3RoZXJzRGF0YX1cbiAgICAgICAgICAgICAgICByb2xlPVwicmFkaW9cIlxuICAgICAgICAgICAgICAgIGRpcj17cnRsID8gJ3J0bCcgOiAnbHRyJ31cbiAgICAgICAgICAgICAgICBzdHlsZT17c3R5bGV9XG4gICAgICAgICAgICAgICAgdGFiSW5kZXg9e3RhYkluZGV4fVxuICAgICAgICAgICAgICAgIGFyaWEtY2hlY2tlZD17Y2hlY2tlZH1cbiAgICAgICAgICAgICAgICBhcmlhLWRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nsc1dyYXBwZXJ9XG4gICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyPXtkaXNhYmxlZCA/IG9uTW91c2VFbnRlciA6IG1ha2VDaGFpbih0aGlzLl9vblVJTW91c2VFbnRlciwgb25Nb3VzZUVudGVyKX1cbiAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU9e2Rpc2FibGVkID8gb25Nb3VzZUxlYXZlIDogbWFrZUNoYWluKHRoaXMuX29uVUlNb3VzZUxlYXZlLCBvbk1vdXNlTGVhdmUpfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHtyYWRpb0NvbXB9XG4gICAgICAgICAgICAgICAge1tjaGlsZHJlbiwgbGFiZWxdLm1hcCgoZCwgaSkgPT4gZCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4ga2V5PXtpfSBjbGFzc05hbWU9e2NoaWxkcmVuQ2xzfT57ZH08L3NwYW4+IDogbnVsbCl9XG4gICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlnUHJvdmlkZXIuY29uZmlnKFJhZGlvKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yYWRpby9yYWRpby5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBJY29uIGZyb20gJy4uLy4uL2ljb24nO1xuaW1wb3J0IHsgS0VZQ09ERSB9IGZyb20gJy4uLy4uL3V0aWwnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9wcmVmZXItc3RhdGVsZXNzLWZ1bmN0aW9uICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTb3J0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgc29ydDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgb25Tb3J0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgZGF0YUluZGV4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBsb2NhbGU6IFByb3BUeXBlcy5vYmplY3RcbiAgICB9XG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgc29ydDoge31cbiAgICB9XG4gICAgLy8g5riy5p+T5o6S5bqPXG4gICAgcmVuZGVyU29ydCgpIHtcbiAgICAgICAgY29uc3Qge3ByZWZpeCwgc29ydCwgZGF0YUluZGV4LCBsb2NhbGV9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIHNvcnRTdGF0dXMgPSBzb3J0W2RhdGFJbmRleF0sXG4gICAgICAgICAgICBtYXAgPSB7XG4gICAgICAgICAgICAgICAgZGVzYzogJ2Rlc2NlbmRpbmcnLFxuICAgICAgICAgICAgICAgIGFzYzogJ2FzY2VuZGluZydcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaWNvbnMgPSBbJ2FzYycsICdkZXNjJ10ubWFwKHNvcnRPcmRlciA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJqYXZhc2NyaXB0OjtcIlxuICAgICAgICAgICAgICAgICAgICBrZXk9e3NvcnRPcmRlcn1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzb3J0U3RhdHVzID09PSBzb3J0T3JkZXIgPyAnY3VycmVudCcgOiAnJ30+XG4gICAgICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9e21hcFtzb3J0T3JkZXJdfSBzaXplPVwic21hbGxcIi8+XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxzcGFuIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgIHRhYkluZGV4PVwiMFwiXG4gICAgICAgICAgICAgICAgYXJpYS1sYWJlbD17bG9jYWxlW3NvcnRTdGF0dXNdfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLXNvcnRgfVxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2suYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICBvbktleURvd249e3RoaXMua2V5ZG93bkhhbmRsZXJ9PlxuICAgICAgICAgICAgICAgIHtpY29uc31cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDbGljayA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qge3NvcnQsIGRhdGFJbmRleH0gPSB0aGlzLnByb3BzO1xuICAgICAgICB0aGlzLm9uU29ydChkYXRhSW5kZXgsIHNvcnRbZGF0YUluZGV4XSA9PT0gJ2Rlc2MnID8gJ2FzYycgOiAnZGVzYycpO1xuICAgIH1cblxuICAgIGtleWRvd25IYW5kbGVyID0gZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBLRVlDT0RFLkVOVEVSKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNsaWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblNvcnQgPSAoZGF0YUluZGV4LCBvcmRlcikgPT4ge1xuICAgICAgICBjb25zdCBzb3J0ID0ge307XG4gICAgICAgIHNvcnRbZGF0YUluZGV4XSA9IG9yZGVyO1xuXG4gICAgICAgIHRoaXMucHJvcHMub25Tb3J0KGRhdGFJbmRleCwgb3JkZXIsIHNvcnQpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyU29ydCgpO1xuICAgIH1cblxufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvYmFzZS9zb3J0LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgUm93IGZyb20gJy4uL2V4cGFuZGVkL3Jvdyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3ByZWZlci1zdGF0ZWxlc3MtZnVuY3Rpb24gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlbGVjdGlvblJvdyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLi4uUm93LnByb3BUeXBlc1xuICAgIH1cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIC4uLlJvdy5kZWZhdWx0UHJvcHNcbiAgICB9XG5cbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICBzZWxlY3RlZFJvd0tleXM6IFByb3BUeXBlcy5hcnJheSxcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzKi9cbiAgICAgICAgY29uc3QgeyBjbGFzc05hbWUsIHJlY29yZCwgcHJpbWFyeUtleSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBzZWxlY3RlZFJvd0tleXMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgY29uc3QgY2xzID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWRSb3dLZXlzLmluZGV4T2YocmVjb3JkW3ByaW1hcnlLZXldKSA+IC0xLFxuICAgICAgICAgICAgW2NsYXNzTmFtZV06IGNsYXNzTmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICg8Um93IHsuLi50aGlzLnByb3BzfSBjbGFzc05hbWU9e2Nsc30gLz4pO1xuICAgIH1cbn1cblxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvc2VsZWN0aW9uL3Jvdy5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGxvZyB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IFJvdyBmcm9tICcuLi9sb2NrL3Jvdyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV4cGFuZGVkUm93IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAuLi5Sb3cucHJvcFR5cGVzXG4gICAgfVxuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgLi4uUm93LmRlZmF1bHRQcm9wcyxcbiAgICB9XG5cbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICBvcGVuUm93S2V5czogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBleHBhbmRlZFJvd1JlbmRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGV4cGFuZGVkUm93SW5kZW50OiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIGxvY2tUeXBlOiBQcm9wVHlwZXMub25lT2YoWydsZWZ0JywgJ3JpZ2h0J10pXG4gICAgfVxuXG4gICAgcmVuZGVyRXhwYW5kZWRSb3cocmVjb3JkLCBpbmRleCwgY29sU3Bhbikge1xuICAgICAgICBjb25zdCB7IGV4cGFuZGVkUm93UmVuZGVyLCBleHBhbmRlZFJvd0luZGVudCwgb3BlblJvd0tleXMsIGxvY2tUeXBlIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGNvbnN0IHsgY29sdW1ucywgY2VsbFJlZiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKGV4cGFuZGVkUm93UmVuZGVyKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByaW1hcnlLZXksIHByZWZpeCB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBsZWZ0SW5kZW50ID0gZXhwYW5kZWRSb3dJbmRlbnRbMF0sXG4gICAgICAgICAgICAgICAgcmlnaHRJbmRlbnQgPSBleHBhbmRlZFJvd0luZGVudFsxXSxcbiAgICAgICAgICAgICAgICB0b3RhbEluZGVudCA9IGxlZnRJbmRlbnQgKyByaWdodEluZGVudCxcbiAgICAgICAgICAgICAgICByZW5kZXJDb2xzID0gKG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goPHRkIGtleT17aX0gcmVmPXsoY2VsbCkgPT4gY2VsbFJlZihpbmRleCwgaSwgY2VsbCl9PiZuYnNwOzwvdGQ+KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHRvdGFsSW5kZW50ID4gY29sU3BhbiAmJiAhbG9ja1R5cGUpIHtcbiAgICAgICAgICAgICAgICBsb2cud2FybmluZygnSXRcXCdzIG5vdCBhbGxvd2VkIGV4cGFuZGVkUm93SW5kZW50IGlzIG1vcmUgdGhhbiB0aGUgbnVtYmVyIG9mIGNvbHVtbnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdEluZGVudCA8IGNvbHVtbnMubGVuZ3RoICYmIGxvY2tUeXBlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICBsb2cud2FybmluZygnZXhwYW5kZWRSb3dJbmRlbnQgbGVmdCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBsZWZ0IGxvY2sgY29sdW1ucy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyaWdodEluZGVudCA8IGNvbHVtbnMubGVuZ3RoICYmIGxvY2tUeXBlID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm5pbmcoJ2V4cGFuZGVkUm93SW5kZW50IHJpZ2h0IGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIHJpZ2h0IGxvY2sgY29sdW1ucy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb2NrVHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIG9wZW5Sb3dLZXlzLmluZGV4T2YocmVjb3JkW3ByaW1hcnlLZXldKSA+IC0xID8gPHRyIGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLWV4cGFuZGVkLXJvd2B9ICBrZXk9e2BleHBhbmRlZC0ke2luZGV4fWB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNvbFNwYW49e2NvbFNwYW59IHJlZj17KGNlbGwpID0+IGNlbGxSZWYoaW5kZXgsIDAsIGNlbGwpfT4mbmJzcDs8L3RkPlxuICAgICAgICAgICAgICAgICAgICA8L3RyPiA6IG51bGxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGVudCA9IGV4cGFuZGVkUm93UmVuZGVyKHJlY29yZCwgaW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChjb250ZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtY2VsbC13cmFwcGVyYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICB7Y29udGVudH1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgb3BlblJvd0tleXMuaW5kZXhPZihyZWNvcmRbcHJpbWFyeUtleV0pID4gLTEgPyA8dHIgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtZXhwYW5kZWQtcm93YH0ga2V5PXtgZXhwYW5kZWQtJHtyZWNvcmRbcHJpbWFyeUtleV0gfHwgaW5kZXh9YH0+XG4gICAgICAgICAgICAgICAgICAgIHtyZW5kZXJDb2xzKGxlZnRJbmRlbnQpfVxuICAgICAgICAgICAgICAgICAgICA8dGQgY29sU3Bhbj17Y29sU3BhbiAtIHRvdGFsSW5kZW50fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtjb250ZW50fVxuICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICB7cmVuZGVyQ29scyhyaWdodEluZGVudCl9XG4gICAgICAgICAgICAgICAgPC90cj4gOiBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzKi9cbiAgICAgICAgY29uc3QgeyByZWNvcmQsIHJvd0luZGV4LCBjb2x1bW5zIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAocmVjb3JkLl9fZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlckV4cGFuZGVkUm93KHJlY29yZCwgcm93SW5kZXgsIGNvbHVtbnMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDxSb3cgey4uLnRoaXMucHJvcHN9IC8+KTtcbiAgICB9XG59XG5cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2V4cGFuZGVkL3Jvdy5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSb3cgZnJvbSAnLi4vYmFzZS9yb3cnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NrUm93IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAuLi5Sb3cucHJvcFR5cGVzXG4gICAgfVxuXG4gICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgb25Sb3dNb3VzZUVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25Sb3dNb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuY1xuICAgIH1cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIC4uLlJvdy5kZWZhdWx0UHJvcHNcbiAgICB9XG5cbiAgICBvbk1vdXNlRW50ZXIgPSAocmVjb3JkLCBpbmRleCwgZSkgPT4ge1xuICAgICAgICBjb25zdCB7IG9uUm93TW91c2VFbnRlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBjb25zdCB7IG9uTW91c2VFbnRlciB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgb25Sb3dNb3VzZUVudGVyICYmIG9uUm93TW91c2VFbnRlcihyZWNvcmQsIGluZGV4LCBlKTtcbiAgICAgICAgb25Nb3VzZUVudGVyKHJlY29yZCwgaW5kZXgsIGUpO1xuICAgIH1cblxuICAgIG9uTW91c2VMZWF2ZSA9IChyZWNvcmQsIGluZGV4LCBlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25Sb3dNb3VzZUxlYXZlIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGNvbnN0IHsgb25Nb3VzZUxlYXZlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBvblJvd01vdXNlTGVhdmUgJiYgb25Sb3dNb3VzZUxlYXZlKHJlY29yZCwgaW5kZXgsIGUpO1xuICAgICAgICBvbk1vdXNlTGVhdmUocmVjb3JkLCBpbmRleCwgZSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyovXG4gICAgICAgIHJldHVybiAoPFJvdyB7Li4udGhpcy5wcm9wc30gb25Nb3VzZUVudGVyPXt0aGlzLm9uTW91c2VFbnRlcn0gb25Nb3VzZUxlYXZlPXt0aGlzLm9uTW91c2VMZWF2ZX0gLz4pO1xuICAgIH1cbn1cblxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvbG9jay9yb3cuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm9keUNvbXBvbmVudCBmcm9tICcuLi9iYXNlL2JvZHknO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9wcmVmZXItc3RhdGVsZXNzLWZ1bmN0aW9uICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXhlZEJvZHkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY29sR3JvdXA6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIG9uU2Nyb2xsOiBQcm9wVHlwZXMuZnVuY1xuICAgIH1cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIG9uU2Nyb2xsOiAoKSA9PiB7fVxuICAgIH1cblxuICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIGZpeGVkSGVhZGVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgbWF4Qm9keUhlaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgICAgICBvbkJvZHlTY3JvbGw6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBnZXROb2RlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyBnZXROb2RlIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGdldE5vZGUgJiYgZ2V0Tm9kZSgnYm9keScsIGZpbmRET01Ob2RlKHRoaXMpKTtcbiAgICB9XG5cbiAgICBvbkJvZHlTY3JvbGwgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25Cb2R5U2Nyb2xsIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIG9uQm9keVNjcm9sbCAmJiBvbkJvZHlTY3JvbGwoKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vblNjcm9sbCgpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBjbGFzc05hbWUsIGNvbEdyb3VwLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgbWF4Qm9keUhlaWdodCwgZml4ZWRIZWFkZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSB7fTtcbiAgICAgICAgaWYgKGZpeGVkSGVhZGVyKSB7XG4gICAgICAgICAgICBzdHlsZS5tYXhIZWlnaHQgPSBtYXhCb2R5SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoPGRpdiBzdHlsZT17c3R5bGV9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBvblNjcm9sbD17dGhpcy5vbkJvZHlTY3JvbGx9PlxuICAgICAgICAgICAgPHRhYmxlPlxuICAgICAgICAgICAgICAgIHtjb2xHcm91cH1cbiAgICAgICAgICAgICAgICA8Qm9keUNvbXBvbmVudCB7Li4ub3RoZXJzfSBjb2xHcm91cD17Y29sR3JvdXB9Lz5cbiAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgIDwvZGl2Pik7XG4gICAgfVxufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvZml4ZWQvYm9keS5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuLyoqXG4gKiBUYWJsZS5Hcm91cEhlYWRlclxuICogQG9yZGVyIDJcbiAqKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RIZWFkZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOihjOa4suafk+eahOmAu+i+kVxuICAgICAgICAgKi9cbiAgICAgICAgY2VsbDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmVsZW1lbnQsIFByb3BUeXBlcy5ub2RlLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5ZyoQ2hpbGRyZW7kuIrpnaLmuLLmn5NzZWxlY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIGhhc0NoaWxkcmVuU2VsZWN0aW9uOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuWcqEdyb3VwSGVhZGVy5LiK6Z2i5riy5p+Tc2VsZWN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBoYXNTZWxlY3Rpb246IFByb3BUeXBlcy5ib29sLFxuICAgIH1cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGNlbGw6ICgpID0+ICcnLFxuICAgICAgICBoYXNTZWxlY3Rpb246IHRydWUsXG4gICAgICAgIGhhc0NoaWxkcmVuU2VsZWN0aW9uOiBmYWxzZVxuICAgIH07XG5cbiAgICBzdGF0aWMgX3R5cGVNYXJrID0gJ2xpc3RIZWFkZXInO1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvbGlzdC1oZWFkZXIuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbi8qKlxuICogVGFibGUuR3JvdXBGb290ZXJcbiAqIEBvcmRlciAzXG4gKiovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXN0Rm9vdGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDooYzmuLLmn5PnmoTpgLvovpFcbiAgICAgICAgICovXG4gICAgICAgIGNlbGw6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5lbGVtZW50LCBQcm9wVHlwZXMubm9kZSwgUHJvcFR5cGVzLmZ1bmNdKVxuICAgIH1cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGNlbGw6ICgpID0+ICcnXG4gICAgfTtcblxuICAgIHN0YXRpYyBfdHlwZU1hcmsgPSAnbGlzdEZvb3Rlcic7XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9saXN0LWZvb3Rlci5qc3giLCJpbXBvcnQgJy4uL2FuaW1hdGUvc3R5bGUuanMnO1xuaW1wb3J0ICcuL21haW4uc2Nzcyc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmFkaW8vc3R5bGUuanMiLCJpbXBvcnQgQ29uZmlnUHJvdmlkZXIgZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCBCdXR0b24gZnJvbSAnLi92aWV3L2J1dHRvbic7XG5pbXBvcnQgQnV0dG9uR3JvdXAgZnJvbSAnLi92aWV3L2dyb3VwJztcblxuQnV0dG9uLkdyb3VwID0gQnV0dG9uR3JvdXA7XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZ1Byb3ZpZGVyLmNvbmZpZyhCdXR0b24sIHtcbiAgICB0cmFuc2Zvcm06IChwcm9wcywgZGVwcmVjYXRlZCkgPT4ge1xuICAgICAgICBpZiAoJ3NoYXBlJyBpbiBwcm9wcykge1xuICAgICAgICAgICAgZGVwcmVjYXRlZCgnc2hhcGUnLCAndGV4dCB8IHdhcm5pbmcgfCBnaG9zdCcsICdCdXR0b24nKTtcblxuICAgICAgICAgICAgY29uc3QgeyBzaGFwZSwgdHlwZSwgLi4ub3RoZXJzIH0gPSBwcm9wcztcblxuICAgICAgICAgICAgbGV0IG5ld1R5cGUgPSB0eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdsaWdodCcgfHwgdHlwZSA9PT0gJ2RhcmsnIHx8ICh0eXBlID09PSAnc2Vjb25kYXJ5JyAmJiBzaGFwZSA9PT0gJ3dhcm5pbmcnKSkge1xuICAgICAgICAgICAgICAgIG5ld1R5cGUgPSAnbm9ybWFsJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGdob3N0O1xuICAgICAgICAgICAgaWYgKHNoYXBlID09PSAnZ2hvc3QnKSB7XG4gICAgICAgICAgICAgICAgZ2hvc3QgPSAoe1xuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5OiAnZGFyaycsXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZGFyeTogJ2RhcmsnLFxuICAgICAgICAgICAgICAgICAgICBub3JtYWw6ICdsaWdodCcsXG4gICAgICAgICAgICAgICAgICAgIGRhcms6ICdkYXJrJyxcbiAgICAgICAgICAgICAgICAgICAgbGlnaHQ6ICdsaWdodCdcbiAgICAgICAgICAgICAgICB9KVt0eXBlIHx8IEJ1dHRvbi5kZWZhdWx0UHJvcHMudHlwZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBzaGFwZSA9PT0gJ3RleHQnO1xuICAgICAgICAgICAgY29uc3Qgd2FybmluZyA9IHNoYXBlID09PSAnd2FybmluZyc7XG5cbiAgICAgICAgICAgIHByb3BzID0geyB0eXBlOiBuZXdUeXBlLCBnaG9zdCwgdGV4dCwgd2FybmluZywgLi4ub3RoZXJzIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYnV0dG9uL2luZGV4LmpzeCIsImltcG9ydCAnLi4vaWNvbi9zdHlsZS5qcyc7XG5pbXBvcnQgJy4vbWFpbi5zY3NzJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9idXR0b24vc3R5bGUuanMiLCJpbXBvcnQgQW5pbWF0ZSBmcm9tICcuL2FuaW1hdGUnO1xuaW1wb3J0IEV4cGFuZCBmcm9tICcuL2V4cGFuZCc7XG5cbkFuaW1hdGUuRXhwYW5kID0gRXhwYW5kO1xuXG5leHBvcnQgZGVmYXVsdCBBbmltYXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FuaW1hdGUvaW5kZXguanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBPdmVybGF5IGZyb20gJy4uL292ZXJsYXknO1xuaW1wb3J0IENvbmZpZ1Byb3ZpZGVyIGZyb20gJy4uL2NvbmZpZy1wcm92aWRlcic7XG5pbXBvcnQge29iaiwgZnVuY30gZnJvbSAnLi4vdXRpbCc7XG5cbi8qKiBMb2FkaW5nICovXG5jbGFzcyBMb2FkaW5nIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5qC35byP5YmN57yAXG4gICAgICAgICAqL1xuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnlhoXlrrlcbiAgICAgICAgICovXG4gICAgICAgIHRpcDogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieWGheWuueS9jee9rlxuICAgICAgICAgKiBAZW51bWRlc2Mg5Ye6546w5Zyo5Yqo55S75Y+z6L65LCDlh7rnjrDlnKjliqjnlLvkuIvpnaJcbiAgICAgICAgICovXG4gICAgICAgIHRpcEFsaWduOiBQcm9wVHlwZXMub25lT2YoWydyaWdodCcsICdib3R0b20nXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBsb2FkaW5nIOeKtuaAgSwg6buY6K6kIHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHZpc2libGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBvblZpc2libGVDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJY2xhc3NcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieWGheiBlOagt+W8j1xuICAgICAgICAgKi9cbiAgICAgICAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7liqjnlLvlsLrlr7hcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOS7heS7heWvuem7mOiupOWKqOeUu+aViOaenOi1t+S9nOeUqFxuICAgICAgICAgKiBAZW51bWRlc2Mg5aSn5Y+3LCDkuK3lj7dcbiAgICAgICAgICovXG4gICAgICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ2xhcmdlJywgJ21lZGl1bSddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieWKqOeUu1xuICAgICAgICAgKi9cbiAgICAgICAgaW5kaWNhdG9yOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICAvKipcbiAgICAgICAgICog5Yqo55S76aKc6ImyXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWFqOWxj+WxleekulxuICAgICAgICAgKi9cbiAgICAgICAgZnVsbFNjcmVlbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlrZDlhYPntKBcbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55LFxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBwcmVmaXg6ICduZXh0LScsXG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgIG9uVmlzaWJsZUNoYW5nZTogZnVuYy5ub29wLFxuICAgICAgICBhbmltYXRlOiBudWxsLFxuICAgICAgICB0aXBBbGlnbjogJ2JvdHRvbScsXG4gICAgICAgIHNpemU6ICdsYXJnZScsXG4gICAgfTtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdGlwLFxuICAgICAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICBpbmRpY2F0b3IsXG4gICAgICAgICAgICBjb2xvcixcbiAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgIGZ1bGxTY3JlZW4sXG4gICAgICAgICAgICBvblZpc2libGVDaGFuZ2UsXG4gICAgICAgICAgICB0aXBBbGlnbixcbiAgICAgICAgICAgIHNpemVcbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgbGV0IGluZGljYXRvckRvbSA9IG51bGw7XG4gICAgICAgIGNvbnN0IGRvdENscyA9IGAke3ByZWZpeH1sb2FkaW5nLWRvdGA7XG5cbiAgICAgICAgaWYgKGluZGljYXRvcikge1xuICAgICAgICAgICAgaW5kaWNhdG9yRG9tID0gaW5kaWNhdG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG4gICAgICAgICAgICBjb25zdCBmdXNpb25SZWFjdG9yQ2xzID0gY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1sb2FkaW5nLWZ1c2lvbi1yZWFjdG9yYF06IHRydWUsXG4gICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1sb2FkaW5nLW1lZGl1bS1mdXNpb24tcmVhY3RvcmBdOiBzaXplID09PSAnbWVkaXVtJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5kaWNhdG9yRG9tID0gKDxkaXYgY2xhc3NOYW1lPXtmdXNpb25SZWFjdG9yQ2xzfT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2RvdENsc30gc3R5bGU9e3tiYWNrZ3JvdW5kQ29sb3J9fT48L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtkb3RDbHN9IHN0eWxlPXt7YmFja2dyb3VuZENvbG9yfX0+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17ZG90Q2xzfSBzdHlsZT17e2JhY2tncm91bmRDb2xvcn19Pjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2RvdENsc30gc3R5bGU9e3tiYWNrZ3JvdW5kQ29sb3J9fT48L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj4pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9hZGluZ0NscyA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1sb2FkaW5nYF06IHRydWUsXG4gICAgICAgICAgICBbYCR7cHJlZml4fW9wZW5gXTogdmlzaWJsZSxcbiAgICAgICAgICAgIFtjbGFzc05hbWVdOiBjbGFzc05hbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdGlwQ2xzID0gY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fWxvYWRpbmctdGlwYF06IHRydWUsXG4gICAgICAgICAgICAvLyDpu5jorqTpnZ4gcmlnaHTlsLHmmK8gYm90dG9tXG4gICAgICAgICAgICBbYCR7cHJlZml4fWxvYWRpbmctcmlnaHQtdGlwYF06IHRpcEFsaWduID09PSAncmlnaHQnLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBvdGhlcnMgPSBvYmoucGlja090aGVycyhMb2FkaW5nLnByb3BUeXBlcywgdGhpcy5wcm9wcyk7XG5cbiAgICAgICAgY29uc3QgY29udGVudENscyA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1sb2FkaW5nLWNvbXBvbmVudGBdOiB2aXNpYmxlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1sb2FkaW5nLXdyYXBgXTogdHJ1ZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bGxTY3JlZW4gP1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgICAgIDxPdmVybGF5IGtleT1cIm92ZXJsYXlcIiBoYXNNYXNrIGFsaWduPVwiY2MgY2NcIiB7Li4ub3RoZXJzfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3N0eWxlfVxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlPXt2aXNpYmxlfVxuICAgICAgICAgICAgICAgICAgICBvblJlcXVlc3RDbG9zZT17b25WaXNpYmxlQ2hhbmdlfT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3RpcENsc30+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fWxvYWRpbmctaW5kaWNhdG9yYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2luZGljYXRvckRvbX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH1sb2FkaW5nLXRpcC1jb250ZW50YH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3RpcH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgey8qIOeUseS6juaSkeW8gOmXrumimCDkvb/nlKjlkIzmoLfnmoTkuKTkuKpET00gKi99XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fWxvYWRpbmctdGlwLXBsYWNlaG9sZGVyYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3RpcH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L092ZXJsYXk+XG4gICAgICAgICAgICBdIDogKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtsb2FkaW5nQ2xzfSBzdHlsZT17c3R5bGV9IHsuLi5vdGhlcnN9PlxuICAgICAgICAgICAgICAgICAgICB7dmlzaWJsZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAoPGRpdiBjbGFzc05hbWU9e3RpcENsc30+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH1sb2FkaW5nLWluZGljYXRvcmB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aW5kaWNhdG9yRG9tfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9bG9hZGluZy10aXAtY29udGVudGB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGlwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9bG9hZGluZy10aXAtcGxhY2Vob2xkZXJgfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RpcH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PikgOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NvbnRlbnRDbHN9PlxuICAgICAgICAgICAgICAgICAgICAgICAge3Zpc2libGUgPyA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fWxvYWRpbmctbWFza2VyYH0+PC9kaXY+IDogbnVsbH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlnUHJvdmlkZXIuY29uZmlnKExvYWRpbmcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xvYWRpbmcvaW5kZXguanN4IiwiaW1wb3J0IENvbmZpZ1Byb3ZpZGVyIGZyb20gJy4uL2NvbmZpZy1wcm92aWRlcic7XG5pbXBvcnQgTWVudSBmcm9tICcuL3ZpZXcvbWVudSc7XG5pbXBvcnQgU3ViTWVudSBmcm9tICcuL3ZpZXcvc3ViLW1lbnUnO1xuaW1wb3J0IFNlbGVjdGFibGVJdGVtIGZyb20gJy4vdmlldy9zZWxlY3RhYmxlLWl0ZW0nO1xuaW1wb3J0IENoZWNrYm94SXRlbSBmcm9tICcuL3ZpZXcvY2hlY2tib3gtaXRlbSc7XG5pbXBvcnQgUmFkaW9JdGVtIGZyb20gJy4vdmlldy9yYWRpby1pdGVtJztcbmltcG9ydCBQb3B1cEl0ZW0gZnJvbSAnLi92aWV3L3BvcHVwLWl0ZW0nO1xuaW1wb3J0IEdyb3VwIGZyb20gJy4vdmlldy9ncm91cCc7XG5pbXBvcnQgRGl2aWRlciBmcm9tICcuL3ZpZXcvZGl2aWRlcic7XG5pbXBvcnQgY3JlYXRlIGZyb20gJy4vdmlldy9jcmVhdGUnO1xuXG5NZW51LlN1Yk1lbnUgPSBTdWJNZW51O1xuTWVudS5JdGVtID0gU2VsZWN0YWJsZUl0ZW07XG5NZW51LkNoZWNrYm94SXRlbSA9IENoZWNrYm94SXRlbTtcbk1lbnUuUmFkaW9JdGVtID0gUmFkaW9JdGVtO1xuTWVudS5Qb3B1cEl0ZW0gPSBQb3B1cEl0ZW07XG5NZW51Lkdyb3VwID0gR3JvdXA7XG5NZW51LkRpdmlkZXIgPSBEaXZpZGVyO1xuTWVudS5jcmVhdGUgPSBjcmVhdGU7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCB0cmFuc2Zvcm0gPSAocHJvcHMsIGRlcHJlY2F0ZWQpID0+IHtcbiAgICBpZiAoJ2luZGVudFNpemUnIGluIHByb3BzKSB7XG4gICAgICAgIGRlcHJlY2F0ZWQoJ2luZGVudFNpemUnLCAnaW5saW5lSW5kZW50JywgJ01lbnUnKTtcblxuICAgICAgICBjb25zdCB7IGluZGVudFNpemUsIC4uLm90aGVycyB9ID0gcHJvcHM7XG4gICAgICAgIHByb3BzID0geyBpbmxpbmVJbmRlbnQ6IGluZGVudFNpemUsIC4uLm90aGVycyB9O1xuICAgIH1cblxuICAgIGlmICgnb25EZXNlbGVjdCcgaW4gcHJvcHMpIHtcbiAgICAgICAgZGVwcmVjYXRlZCgnb25EZXNlbGVjdCcsICdvblNlbGVjdCcsICdNZW51Jyk7XG4gICAgICAgIGlmIChwcm9wcy5vbkRlc2VsZWN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IG9uRGVzZWxlY3QsIG9uU2VsZWN0LCAuLi5vdGhlcnMgfSA9IHByb3BzO1xuICAgICAgICAgICAgY29uc3QgbmV3T25TZWxlY3QgPSAoc2VsZWN0ZWRLZXlzLCBpdGVtLCBleHRyYSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZXh0cmEuc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRGVzZWxlY3QoZXh0cmEua2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9uU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0KHNlbGVjdGVkS2V5cywgaXRlbSwgZXh0cmEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHByb3BzID0geyBvblNlbGVjdDogbmV3T25TZWxlY3QsIC4uLm90aGVycyB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlnUHJvdmlkZXIuY29uZmlnKE1lbnUsIHtcbiAgICB0cmFuc2Zvcm1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21lbnUvaW5kZXguanN4IiwiaW1wb3J0ICcuLi9pY29uL3N0eWxlLmpzJztcbmltcG9ydCAnLi4vYW5pbWF0ZS9zdHlsZS5qcyc7XG5pbXBvcnQgJy4uL3JhZGlvL3N0eWxlLmpzJztcbmltcG9ydCAnLi4vY2hlY2tib3gvc3R5bGUuanMnO1xuaW1wb3J0ICcuL21haW4uc2Nzcyc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWVudS9zdHlsZS5qcyIsImltcG9ydCAnLi4vaWNvbi9zdHlsZS5qcyc7XG5pbXBvcnQgJy4uL2FuaW1hdGUvc3R5bGUuanMnO1xuaW1wb3J0ICcuLi9vdmVybGF5L3N0eWxlLmpzJztcbmltcG9ydCAnLi9tYWluLnNjc3MnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xvYWRpbmcvc3R5bGUuanMiLCJpbXBvcnQgQ29uZmlnUHJvdmlkZXIgZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCBCYXNlIGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgdHJlZSBmcm9tICcuL3RyZWUnO1xuaW1wb3J0IGZpeGVkIGZyb20gJy4vZml4ZWQnO1xuaW1wb3J0IHNlbGVjdGlvbiBmcm9tICcuL3NlbGVjdGlvbic7XG5pbXBvcnQgZXhwYW5kZWQgZnJvbSAnLi9leHBhbmRlZCc7XG5pbXBvcnQgdmlydHVhbCBmcm9tICcuL3ZpcnR1YWwnO1xuaW1wb3J0IGxvY2sgZnJvbSAnLi9sb2NrJztcbmltcG9ydCBsaXN0IGZyb20gJy4vbGlzdCc7XG5pbXBvcnQgc3RpY2t5IGZyb20gJy4vc3RpY2t5JztcbmltcG9ydCBMaXN0SGVhZGVyIGZyb20gJy4vbGlzdC1oZWFkZXInO1xuaW1wb3J0IExpc3RGb290ZXIgZnJvbSAnLi9saXN0LWZvb3Rlcic7XG5cbmNvbnN0IE9SREVSX0xJU1QgPSBbZml4ZWQsIGxvY2ssIHNlbGVjdGlvbiwgZXhwYW5kZWQsIHRyZWUsIHZpcnR1YWwsIGxpc3QsIHN0aWNreV07XG5jb25zdCBUYWJsZSA9IE9SREVSX0xJU1QucmVkdWNlKChyZXQsIGN1cnJlbnQpID0+IHtcbiAgICByZXQgPSBjdXJyZW50KHJldCk7XG4gICAgcmV0dXJuIHJldDtcbn0sIEJhc2UpO1xuVGFibGUuQmFzZSA9IEJhc2U7XG5UYWJsZS5maXhlZCA9IGZpeGVkO1xuVGFibGUubG9jayA9IGxvY2s7XG5UYWJsZS5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG5UYWJsZS5leHBhbmRlZCA9IGV4cGFuZGVkO1xuVGFibGUudHJlZSA9IHRyZWU7XG5UYWJsZS52aXJ0dWFsID0gdmlydHVhbDtcblRhYmxlLmxpc3QgPSBsaXN0O1xuVGFibGUuc3RpY2t5ID0gc3RpY2t5O1xuXG5UYWJsZS5Hcm91cEhlYWRlciA9IExpc3RIZWFkZXI7XG5UYWJsZS5Hcm91cEZvb3RlciA9IExpc3RGb290ZXI7XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZ1Byb3ZpZGVyLmNvbmZpZyhUYWJsZSwge1xuICAgIGNvbXBvbmVudE5hbWU6ICdUYWJsZScsXG4gICAgdHJhbnNmb3JtOiAocHJvcHMsIGRlcHJlY2F0ZWQpID0+IHtcbiAgICAgICAgaWYgKCdleHBhbmRlZFJvd0tleXMnIGluIHByb3BzKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVkKCdleHBhbmRlZFJvd0tleXMnLCAnb3BlblJvd0tleXMnLCAnVGFibGUnKTtcblxuICAgICAgICAgICAgY29uc3QgeyBleHBhbmRlZFJvd0tleXMsIC4uLm90aGVycyB9ID0gcHJvcHM7XG4gICAgICAgICAgICBwcm9wcyA9IHsgb3BlblJvd0tleXM6IGV4cGFuZGVkUm93S2V5cywgLi4ub3RoZXJzIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdvbkV4cGFuZGVkQ2hhbmdlJyBpbiBwcm9wcykge1xuICAgICAgICAgICAgZGVwcmVjYXRlZCgnb25FeHBhbmRlZENoYW5nZScsICdvblJvd09wZW4nLCAnVGFibGUnKTtcblxuICAgICAgICAgICAgY29uc3QgeyBvbkV4cGFuZGVkQ2hhbmdlLCAuLi5vdGhlcnMgfSA9IHByb3BzO1xuICAgICAgICAgICAgcHJvcHMgPSB7IG9uUm93T3Blbjogb25FeHBhbmRlZENoYW5nZSwgLi4ub3RoZXJzIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdpc0xvYWRpbmcnIGluIHByb3BzKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVkKCdpc0xvYWRpbmcnLCAnbG9hZGluZycsICdUYWJsZScpO1xuXG4gICAgICAgICAgICBjb25zdCB7IGlzTG9hZGluZywgLi4ub3RoZXJzIH0gPSBwcm9wcztcbiAgICAgICAgICAgIHByb3BzID0geyBsb2FkaW5nOiBpc0xvYWRpbmcsIC4uLm90aGVycyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICgnaW5kZW50U2l6ZScgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZWQoJ2luZGVudFNpemUnLCAnaW5kZW50JywgJ1RhYmxlJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgaW5kZW50U2l6ZSwgLi4ub3RoZXJzIH0gPSBwcm9wcztcbiAgICAgICAgICAgIHByb3BzID0geyBpbmRlbnQ6IGluZGVudFNpemUsIC4uLm90aGVycyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICgnb3B0aW1pemF0aW9uJyBpbiBwcm9wcykge1xuICAgICAgICAgICAgZGVwcmVjYXRlZCgnb3B0aW1pemF0aW9uJywgJ3B1cmUnLCAnVGFibGUnKTtcblxuICAgICAgICAgICAgY29uc3QgeyBvcHRpbWl6YXRpb24sIC4uLm90aGVycyB9ID0gcHJvcHM7XG4gICAgICAgICAgICBwcm9wcyA9IHsgcHVyZTogb3B0aW1pemF0aW9uLCAuLi5vdGhlcnMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2dldFJvd0NsYXNzTmFtZScgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZWQoJ2dldFJvd0NsYXNzTmFtZScsICdnZXRSb3dQcm9wcycsICdUYWJsZScpO1xuXG4gICAgICAgICAgICBjb25zdCB7IGdldFJvd0NsYXNzTmFtZSwgZ2V0Um93UHJvcHMsIC4uLm90aGVycyB9ID0gcHJvcHM7XG4gICAgICAgICAgICBpZiAoZ2V0Um93Q2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3R2V0Um93UHJvcHMgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBnZXRSb3dDbGFzc05hbWUoLi4uYXJncyksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi4oZ2V0Um93UHJvcHMgPyBnZXRSb3dQcm9wcyguLi5hcmdzKSA6IHt9KVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBwcm9wcyA9IHsgZ2V0Um93UHJvcHM6IG5ld0dldFJvd1Byb3BzLCAuLi5vdGhlcnMgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcHMgPSB7IGdldFJvd1Byb3BzLCAuLi5vdGhlcnMgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9pbmRleC5qc3giLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgcHJvcCBvbiBgJyArIGNvbXBvbmVudE5hbWUgICsgJ2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19wcm9wLXR5cGVzQDE1LjYuMkBwcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fb2JqZWN0LWFzc2lnbkA0LjEuMUBvYmplY3QtYXNzaWduL2luZGV4LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICAgICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAnICtcbiAgICAgICAgICAgIGxvY2F0aW9uICsgJyBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJyArIHR5cGVvZiBlcnJvciArICcuICcgK1xuICAgICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArXG4gICAgICAgICAgICAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLidcbiAgICAgICAgICApXG5cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fcHJvcC10eXBlc0AxNS42LjJAcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge31cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAvLyBJdCBpcyBzdGlsbCBzYWZlIHdoZW4gY2FsbGVkIGZyb20gUmVhY3QuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICApO1xuICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIHRocm93IGVycjtcbiAgfTtcbiAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcbiAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcbiAgICByZXR1cm4gc2hpbTtcbiAgfTtcbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBzaGltLFxuICAgIGJvb2w6IHNoaW0sXG4gICAgZnVuYzogc2hpbSxcbiAgICBudW1iZXI6IHNoaW0sXG4gICAgb2JqZWN0OiBzaGltLFxuICAgIHN0cmluZzogc2hpbSxcbiAgICBzeW1ib2w6IHNoaW0sXG5cbiAgICBhbnk6IHNoaW0sXG4gICAgYXJyYXlPZjogZ2V0U2hpbSxcbiAgICBlbGVtZW50OiBzaGltLFxuICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXG4gICAgbm9kZTogc2hpbSxcbiAgICBvYmplY3RPZjogZ2V0U2hpbSxcbiAgICBvbmVPZjogZ2V0U2hpbSxcbiAgICBvbmVPZlR5cGU6IGdldFNoaW0sXG4gICAgc2hhcGU6IGdldFNoaW0sXG4gICAgZXhhY3Q6IGdldFNoaW1cbiAgfTtcblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGVtcHR5RnVuY3Rpb247XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX3Byb3AtdHlwZXNAMTUuNi4yQHByb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgaG9pc3ROb25SZWFjdFN0YXRpYyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XG5pbXBvcnQgeyBvYmosIGxvZyB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IGdldENvbnRleHRQcm9wcyBmcm9tICcuL2dldC1jb250ZXh0LXByb3BzJztcblxuY29uc3QgeyBzaGFsbG93RXF1YWwgfSA9IG9iajtcblxuZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoQ29tcG9uZW50KSB7XG4gICAgcmV0dXJuIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jztcbn1cblxubGV0IGdsb2JhbExvY2FsZXM7XG5sZXQgY3VycmVudEdsb2JhbExhbmd1YWdlID0gJ3poLWNuJztcbmxldCBjdXJyZW50R2xvYmFsTG9jYWxlID0ge307XG5sZXQgY3VycmVudEdsb2JhbFJ0bCA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdExvY2FsZXMobG9jYWxlcykge1xuICAgIGdsb2JhbExvY2FsZXMgPSBsb2NhbGVzO1xuICAgIGN1cnJlbnRHbG9iYWxMb2NhbGUgPSBsb2NhbGVzW2N1cnJlbnRHbG9iYWxMYW5ndWFnZV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRMYW5ndWFnZShsYW5ndWFnZSkge1xuICAgIGlmIChnbG9iYWxMb2NhbGVzKSB7XG4gICAgICAgIGN1cnJlbnRHbG9iYWxMYW5ndWFnZSA9IGxhbmd1YWdlO1xuICAgICAgICBjdXJyZW50R2xvYmFsTG9jYWxlID0gZ2xvYmFsTG9jYWxlc1tsYW5ndWFnZV07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0TG9jYWxlKGxvY2FsZSkge1xuICAgIGN1cnJlbnRHbG9iYWxMb2NhbGUgPSB7XG4gICAgICAgIC4uLihnbG9iYWxMb2NhbGVzID8gZ2xvYmFsTG9jYWxlc1tjdXJyZW50R2xvYmFsTGFuZ3VhZ2VdIDoge30pLFxuICAgICAgICAuLi5sb2NhbGVcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0RGlyZWN0aW9uKGRpcikge1xuICAgIGN1cnJlbnRHbG9iYWxSdGwgPSBkaXIgPT09ICdydGwnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9jYWxlKCkge1xuICAgIHJldHVybiBjdXJyZW50R2xvYmFsTG9jYWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGFuZ3VhZ2UoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRHbG9iYWxMYW5ndWFnZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gY3VycmVudEdsb2JhbFJ0bDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZyhDb21wb25lbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChDb21wb25lbnQucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgbmV4dFN0YXRlXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMucHVyZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICFzaGFsbG93RXF1YWwodGhpcy5wcm9wcywgbmV4dFByb3BzKSB8fFxuICAgICAgICAgICAgICAgICAgICAhc2hhbGxvd0VxdWFsKHRoaXMuc3RhdGUsIG5leHRTdGF0ZSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjbGFzcyBDb25maWdlZENvbXBvbmVudCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgICAgICAuLi4oQ29tcG9uZW50LnByb3BUeXBlcyB8fCB7fSksXG4gICAgICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgICAgICBsb2NhbGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgICAgICBwdXJlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgICAgIHJ0bDogUHJvcFR5cGVzLmJvb2xcbiAgICAgICAgfTtcbiAgICAgICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgICAgIC4uLihDb21wb25lbnQuY29udGV4dFR5cGVzIHx8IHt9KSxcbiAgICAgICAgICAgIG5leHRQcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgICAgICBuZXh0TG9jYWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAgICAgbmV4dFB1cmU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAgICAgbmV4dFJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgICAgICBuZXh0V2FybmluZzogUHJvcFR5cGVzLmJvb2xcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xuICAgICAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICB0aGlzLl9nZXRJbnN0YW5jZSA9IHRoaXMuX2dldEluc3RhbmNlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9kZXByZWNhdGVkID0gdGhpcy5fZGVwcmVjYXRlZC5iaW5kKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2dldEluc3RhbmNlKHJlZikge1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSByZWY7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSAmJiBvcHRpb25zLmV4cG9ydE5hbWVzKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5leHBvcnROYW1lcy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMuX2luc3RhbmNlW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpZWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW25hbWVdID0gZmllbGQuYmluZCh0aGlzLl9pbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW25hbWVdID0gZmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9kZXByZWNhdGVkKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQubmV4dFdhcm5pbmcgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbG9nLmRlcHJlY2F0ZWQoLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZXRJbnN0YW5jZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJlZml4LCBsb2NhbGUsIHB1cmUsIHJ0bCwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIG5leHRQcmVmaXgsXG4gICAgICAgICAgICAgICAgbmV4dExvY2FsZSA9IHt9LFxuICAgICAgICAgICAgICAgIG5leHRQdXJlLFxuICAgICAgICAgICAgICAgIG5leHRSdGxcbiAgICAgICAgICAgIH0gPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgICAgICAgIGNvbnN0IGRpc3BsYXlOYW1lID1cbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbXBvbmVudE5hbWUgfHwgZ2V0RGlzcGxheU5hbWUoQ29tcG9uZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHRQcm9wcyA9IGdldENvbnRleHRQcm9wcyhcbiAgICAgICAgICAgICAgICB7IHByZWZpeCwgbG9jYWxlLCBwdXJlLCBydGwgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgIG5leHRMb2NhbGU6IHsgLi4uY3VycmVudEdsb2JhbExvY2FsZSwgLi4ubmV4dExvY2FsZSB9LFxuICAgICAgICAgICAgICAgICAgICBuZXh0UHVyZSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJ0bDogdHlwZW9mIG5leHRSdGwgPT09ICdib29sZWFuJyA/IG5leHRSdGwgOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdsb2JhbFJ0bCA9PT0gdHJ1ZSA/IHRydWUgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb25zdCBuZXdDb250ZXh0UHJvcHMgPSBbJ3ByZWZpeCcsICdsb2NhbGUnLCAncHVyZScsICdydGwnXS5yZWR1Y2UoXG4gICAgICAgICAgICAgICAgKHJldCwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHRQcm9wc1tuYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldFtuYW1lXSA9IGNvbnRleHRQcm9wc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge31cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnN0IG5ld090aGVycyA9IG9wdGlvbnMudHJhbnNmb3JtID9cbiAgICAgICAgICAgICAgICBvcHRpb25zLnRyYW5zZm9ybShvdGhlcnMsIHRoaXMuX2RlcHJlY2F0ZWQpIDpcbiAgICAgICAgICAgICAgICBvdGhlcnM7XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPENvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICB7Li4ubmV3T3RoZXJzfVxuICAgICAgICAgICAgICAgICAgICB7Li4ubmV3Q29udGV4dFByb3BzfVxuICAgICAgICAgICAgICAgICAgICByZWY9e3RoaXMuX2dldEluc3RhbmNlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQ29uZmlnZWRDb21wb25lbnQuZGlzcGxheU5hbWUgPSBgQ29uZmlnKCR7Z2V0RGlzcGxheU5hbWUoQ29tcG9uZW50KX0pYDtcblxuICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWMoQ29uZmlnZWRDb21wb25lbnQsIENvbXBvbmVudCk7XG5cbiAgICByZXR1cm4gQ29uZmlnZWRDb21wb25lbnQ7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29uZmlnLXByb3ZpZGVyL2NvbmZpZy5qc3giLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogdHJ1ZSxcbiAgICBtaXhpbnM6IHRydWUsXG4gICAgcHJvcFR5cGVzOiB0cnVlLFxuICAgIHR5cGU6IHRydWVcbn07XG5cbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICAgIG5hbWU6IHRydWUsXG4gICAgbGVuZ3RoOiB0cnVlLFxuICAgIHByb3RvdHlwZTogdHJ1ZSxcbiAgICBjYWxsZXI6IHRydWUsXG4gICAgY2FsbGVlOiB0cnVlLFxuICAgIGFyZ3VtZW50czogdHJ1ZSxcbiAgICBhcml0eTogdHJ1ZVxufTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgb2JqZWN0UHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YgJiYgZ2V0UHJvdG90eXBlT2YoT2JqZWN0KTtcblxuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGJsYWNrbGlzdCkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykgeyAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuXG4gICAgICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHZhciBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuICAgICAgICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50LCBibGFja2xpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIVJFQUNUX1NUQVRJQ1Nba2V5XSAmJiAhS05PV05fU1RBVElDU1trZXldICYmICghYmxhY2tsaXN0IHx8ICFibGFja2xpc3Rba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG4gICAgICAgICAgICAgICAgdHJ5IHsgLy8gQXZvaWQgZmFpbHVyZXMgZnJvbSByZWFkLW9ubHkgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBob2lzdE5vblJlYWN0U3RhdGljcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9faG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3NAMi41LjVAaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvZGlzdC9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy5janMuanMiLCIvKipcbiAqIOWPlua2iOS6i+S7tue7keWumlxuICogQHBhcmFtICB7Kn0gICBub2RlICAgICAgIERPTeiKgueCueaIluS7u+S9leWPr+S7pee7keWumuS6i+S7tueahOWvueixoVxuICogQHBhcmFtICB7U3RyaW5nfSAgIGV2ZW50TmFtZSAg5LqL5Lu25ZCNXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgICDlm57osIPmlrnms5VcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgW3VzZUNhcHR1cmU9ZmFsc2VdIOaYr+WQpuW8gOWQr+S6i+S7tuaNleiOt+S8mOWFiFxuICovXG5leHBvcnQgZnVuY3Rpb24gb2ZmIChub2RlLCBldmVudE5hbWUsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAobm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrLCB1c2VDYXB0dXJlIHx8IGZhbHNlKTtcbiAgICB9XG59XG5cbi8qKlxuICog57uR5a6a5LqL5Lu2XG4gKiBAcGFyYW0gIHsqfSAgIG5vZGUgICAgICAgRE9N6IqC54K55oiW5Lu75L2V5Y+v5Lul57uR5a6a5LqL5Lu255qE5a+56LGhXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgZXZlbnROYW1lICDkuovku7blkI1cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAgIOWbnuiwg+aWueazlVxuICogQHBhcmFtICB7Qm9vbGVhbn0gICB1c2VDYXB0dXJlIOaYr+WQpuW8gOWQr+S6i+S7tuaNleiOt+S8mOWFiFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgIOi/lOWbnueahG9iamVjdOS4reWMheWQq+S4gOS4qm9mZuaWueazle+8jOeUqOS6juWPlua2iOS6i+S7tuebkeWQrFxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBoYW5kbGVyID0gZXZlbnRzLm9uKGRvY3VtZW50LmJvZHksICdjbGljaycsIGUgPT4ge1xuICogICAgIC8vIGhhbmRsZSBjbGljayAuLi5cbiAqIH0pO1xuICogLy8g5Y+W5raI5LqL5Lu257uR5a6aXG4gKiBoYW5kbGVyLm9mZigpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gb24gKG5vZGUsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChub2RlLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2ssIHVzZUNhcHR1cmUgfHwgZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIG9mZjogKCkgPT4gb2ZmKG5vZGUsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpXG4gICAgfTtcbn1cblxuLyoqXG4gKiDnu5Hlrprkuovku7bvvIzlj6rmiafooYzkuIDmrKHlkI7plIDmr4FcbiAqIEBwYXJhbSAgeyp9ICAgbm9kZSAgICAgICBET03oioLngrnmiJbku7vkvZXlj6/ku6Xnu5Hlrprkuovku7bnmoTlr7nosaFcbiAqIEBwYXJhbSAge1N0cmluZ30gICBldmVudE5hbWUgIOS6i+S7tuWQjVxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrICAg5Zue6LCD5pa55rOVXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgIHVzZUNhcHR1cmUg5piv5ZCm5byA5ZCv5LqL5Lu25o2V6I635LyY5YWIXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gICAgICAgICAgICAg6L+U5Zue55qEb2JqZWN05Lit5YyF5ZCr5LiA5Liqb2Zm5pa55rOV77yM55So5LqO5Y+W5raI5LqL5Lu255uR5ZCsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbmNlIChub2RlLCBldmVudE5hbWUsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKSB7XG4gICAgcmV0dXJuIG9uKG5vZGUsIGV2ZW50TmFtZSwgZnVuY3Rpb24gX19mbiAoLi4uYXJncykge1xuICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgICAgICAvLyDnlLHkuo5hZGRFdmVudExpc3RlbmVy5Lit55qE5Y+C5pWwb3B0aW9uc+WPquWcqENocm9tZSA1NeOAgUZpcmVmb3goR2Vja28p5Lul5LiK54mI5pys5pSv5oyB77yM5pWF6L+Y5piv55So5Lyg57uf55qE5pa55rOV5a6e546wb25jZVxuICAgICAgICBvZmYobm9kZSwgZXZlbnROYW1lLCBfX2ZuLCB1c2VDYXB0dXJlKTtcbiAgICB9LCB1c2VDYXB0dXJlKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlsL2V2ZW50cy5qcyIsImltcG9ydCB7aXNQcm9taXNlfSBmcm9tICcuL29iamVjdCc7XG5cbi8qKlxuICog5LiA5Liq56m65pa55rOV77yM6L+U5Zue5YWl5Y+C5pys6Lqr5oiW56m65a+56LGhXG4gKi9cbmV4cG9ydCBjb25zdCBub29wID0gKCkgPT4ge307XG5cbi8qKlxuICog5bCGTuS4quaWueazleWQiOW5tuS4uuS4gOS4qumTvuW8j+iwg+eUqOeahOaWueazlVxuICogQHJldHVybiB7RnVuY3Rpb259ICAgICDlkIjlubblkI7nmoTmlrnms5VcbiAqIOWPguiAgyBodHRwczovL2dpdGh1Yi5jb20vcmVhY3QtY29tcG9uZW50L3V0aWwvXG4gKlxuICogQGV4YW1wbGVcbiAqIGZ1bmMubWFrZUNoYWluKHRoaXMuaGFuZGxlQ2hhbmdlLCB0aGlzLnByb3BzLm9uQ2hhbmdlKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VDaGFpbiAoLi4uZm5zKSB7XG4gICAgaWYgKGZucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZuc1swXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZEZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gZm5zLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZuc1tpXSAmJiBmbnNbaV0uYXBwbHkpIHtcbiAgICAgICAgICAgICAgICBmbnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbiAqIOaJuemHj+aUueWPmOaWueazleeahOS4iuS4i+aWh1xuICog5q2k5pa55rOV5ZyocmVhY3Tnu4Tku7bkuK3lvojmnInnlKjvvIzlnKhjb25zdHJ1Y3RvcuS4reaJuemHj+Wwhue7hOS7tuS4iueahOaWueazleaJp+ihjOS4iuS4i+aWh+e7keWumuWIsOe7hOS7tuacrOi6q1xuICog5rOo5oSP77ya55SoYmluZOaUueWPmOWHveaVsOi/kOihjOeahOS4iuS4i+aWh+WPquS8mueUn+aViOS4gOasoVxuICogQHBhcmFtICB7T2JqZWN0fSBjdHgg5pa55rOV5oyC6L2955qE5a+56LGh5Lul5Y+K5omn6KGM55qE5LiK5LiL5paHXG4gKiBAcGFyYW0gIHtBcnJheTxTdHJpbmc+fSBmbnMg5pa55rOV5ZCN5YiX6KGoXG4gKlxuICogQGV4YW1wbGVcbiAqIGZ1bmMuYmluZEN0eCh0aGlzLCBbJ2hhbmRsZUNsaWNrJywgJ2hhbmRsZUNoYW5nZSddKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRDdHggKGN0eCwgZm5zLCBucykge1xuICAgIGlmICh0eXBlb2YgZm5zID09PSAnc3RyaW5nJykge1xuICAgICAgICBmbnMgPSBbZm5zXTtcbiAgICB9XG5cbiAgICAvLyDmlrnms5XnmoTmjILovb3nqbrpl7TvvIzlpoLmnpzkuI3kvKDvvIzpu5jorqTkuI5jdHjnm7jlkIxcbiAgICBucyA9IG5zIHx8IGN0eDtcblxuICAgIGZucy5mb3JFYWNoKGZuTmFtZSA9PiB7XG4gICAgICAgIC8vIOi/memHjOS4jeimgea3u+WKoOepuuaWueazleWIpOaWre+8jOeUseiwg+eUqOiAheS/neivgeato+ehruaAp++8jOWQpuWImeWHuuS6humXrumimOaXoOazleaOkuafpVxuICAgICAgICBuc1tmbk5hbWVdID0gbnNbZm5OYW1lXS5iaW5kKGN0eCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICog55So5LqO5omn6KGM5Zue6LCD5pa55rOV5ZCO55qE6YC76L6RXG4gKiBAcGFyYW0gIHsqfSByZXQgICAgICAgICAgICDlm57osIPmlrnms5XmiafooYznu5PmnpxcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBzdWNjZXNzIOaJp+ihjOe7k+aenOi/lOWbnumdnmZhbHNl55qE5Zue6LCDXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gW2ZhaWx1cmU9bm9vcF0g5omn6KGM57uT5p6c6L+U5ZueZmFsc2XnmoTlm57osINcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb21pc2VDYWxsIChyZXQsIHN1Y2Nlc3MsIGZhaWx1cmUgPSBub29wKSB7XG4gICAgaWYgKGlzUHJvbWlzZShyZXQpKSB7XG4gICAgICAgIHJldHVybiByZXQudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgc3VjY2VzcyhyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICBmYWlsdXJlKGUpO1xuICAgICAgICAgICAgLy8gdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldCAhPT0gZmFsc2UgPyBzdWNjZXNzKHJldCkgOiBmYWlsdXJlKHJldCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbC9mdW5jLmpzIiwiaW1wb3J0IHsgaXNQcm9kdWN0aW9uIH0gZnJvbSAnLi9lbnYnO1xuXG4vKiBlc2xpbnQgbm8tY29uc29sZTogMCAqL1xuXG4vKipcbiAqIOWPjeWvueS9v+eUqOafkOS4gOaWueazleaIluWxnuaAp+eahOitpuWRilxuICogQHBhcmFtICB7U3RyaW5nfSBwcm9wcyAgICAg6L+H5pe255qE5bGe5oCn5oiW5pa55rOV5ZCNXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGluc3RlYWQgICDmm7/ku6PnmoTlsZ7mgKfmiJbmlrnms5XlkI1cbiAqIEBwYXJhbSAge1N0cmluZ30gY29tcG9uZW50IOe7hOS7tuWQjVxuICpcbiAqIEBleGFtcGxlXG4gKiBsb2cuZGVwcmVjYXRlZCgnb25CZWZvcmVDbG9zZScsICdiZWZvcmVDbG9zZScsICdEaWFsb2cnKTtcbiAqIC8vIFdhcm5pbmc6IG9uQmVmb3JlQ2xvc2UgaXMgZGVwcmVjYXRlZCBhdCBbIERpYWxvZyBdLCB1c2UgWyBiZWZvcmVDbG9zZSBdIGluc3RlYWQgb2YgaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXByZWNhdGVkIChwcm9wcywgaW5zdGVhZCwgY29tcG9uZW50KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoIWlzUHJvZHVjdGlvbigpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgYFdhcm5pbmc6IFsgJHtwcm9wc30gXSBpcyBkZXByZWNhdGVkIGF0IFsgJHtjb21wb25lbnR9IF0sIGAgK1xuICAgICAgICAgICAgYHVzZSBbICR7aW5zdGVhZH0gXSBpbnN0ZWFkIG9mIGl0LmBcbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICog5o6n5Yi25Y+w6K2m5ZGK5pel5b+XXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG1zZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gd2FybmluZyAobXNnKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6ICR7bXNnfWApO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlsL2xvZy5qcyIsImltcG9ydCB7aGFzRE9NfSBmcm9tICcuL2RvbSc7XG5pbXBvcnQge2VhY2h9IGZyb20gJy4vb2JqZWN0JztcblxuY29uc3QgYW5pbWF0aW9uRW5kRXZlbnROYW1lcyA9IHtcbiAgICBXZWJraXRBbmltYXRpb246ICd3ZWJraXRBbmltYXRpb25FbmQnLFxuICAgIE9BbmltYXRpb246ICdvQW5pbWF0aW9uRW5kJyxcbiAgICBhbmltYXRpb246ICdhbmltYXRpb25lbmQnXG59O1xuXG5jb25zdCB0cmFuc2l0aW9uRXZlbnROYW1lcyA9IHtcbiAgICBXZWJraXRUcmFuc2l0aW9uOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgT1RyYW5zaXRpb246ICdvVHJhbnNpdGlvbkVuZCcsXG4gICAgdHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnXG59O1xuXG4vKipcbiAqIOaYr+WQpuaUr+aMgeafkOS6m+WKqOaViOS6i+S7tu+8jOWmguaenOaUr+aMge+8jOi/lOWbnuebuOW6lOeahGVuZOS6i+S7tuWQjVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge09iamVjdDxTdHJpbmc+fSBuYW1lc1xuICogQHJldHVybiB7T2JqZWN0fGZhbHNlfVxuICovXG5mdW5jdGlvbiBfc3VwcG9ydEVuZCAobmFtZXMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWhhc0RPTSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBsZXQgcmV0ID0gZmFsc2U7XG5cbiAgICBlYWNoKG5hbWVzLCAodmFsLCBrZXkpID0+IHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGVsLnN0eWxlW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0ID0ge2VuZDogdmFsfTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiDmmK/lkKbmlK/mjIHmn5DkuptDU1PlsZ7mgKdcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtPYmplY3Q8QXJyYXk8U3RyaW5nPj59IG5hbWVzXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICBpcyBzdXBwb3J0XG4gKi9cbmZ1bmN0aW9uIF9zdXBwb3J0Q1NTIChuYW1lcykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaGFzRE9NKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxldCByZXQgPSBmYWxzZTtcblxuICAgIGVhY2gobmFtZXMsICh2YWwsIGtleSkgPT4ge1xuICAgICAgICBlYWNoKHZhbCwgaXRlbSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlW2tleV0gPSBpdGVtO1xuICAgICAgICAgICAgICAgIHJldCA9IHJldCB8fCBlbC5zdHlsZVtrZXldID09PSBpdGVtO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIEl0IHdpbGwgYmUgdGhyb3cgZXJyb3Igd2hlbiBzZXQgdW5rbm93biBwcm9wZXJ0eSB1bmRlciBJRThcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhcmV0OyAvLyDlpoLmnpzmnInkuIDkuKrmlK/mjIHlsLHov5Tlm55mYWxzZe+8jOWQjumdouS4jemcgOimgeWGjeWIpOaWrVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gIXJldDtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICog5piv5ZCm5pSv5oyBYW5pbWF0aW9u5Lul5Y+K5Yqo55S757uT5p2f5LqL5Lu25ZCNXG4gKiBAdHlwZSB7T2JqZWN0fGZhbHNlfVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGVuZCDliqjnlLvnu5PmnZ/kuovku7blkI1cbiAqL1xuZXhwb3J0IGNvbnN0IGFuaW1hdGlvbiA9IF9zdXBwb3J0RW5kKGFuaW1hdGlvbkVuZEV2ZW50TmFtZXMpO1xuXG4vKipcbiAqIOaYr+WQpuaUr+aMgXRyYW5zaXRpb27ku6Xlj4rov4fmu6TmlYjmnpznu5PmnZ/kuovku7blkI1cbiAqIEB0eXBlIHtPYmplY3R8ZmFsc2V9XG4gKiBAcHJvcGVydHkge1N0cmluZ30gZW5kIOi/h+a4oeaViOaenOe7k+adn+S6i+S7tuWQjVxuICovXG5leHBvcnQgY29uc3QgdHJhbnNpdGlvbiA9IF9zdXBwb3J0RW5kKHRyYW5zaXRpb25FdmVudE5hbWVzKTtcblxuLyoqXG4gKiDmmK/lkKbmlK/mjIFmbGV45bGe5oCnXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGZsZXggPSBfc3VwcG9ydENTUyh7XG4gICAgZGlzcGxheTogWydmbGV4JywgJy13ZWJraXQtZmxleCcsICctbW96LWZsZXgnLCAnLW1zLWZsZXhib3gnXVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbC9zdXBwb3J0LmpzIiwiaW1wb3J0IEtFWUNPREUgZnJvbSAnLi9rZXljb2RlJztcbmltcG9ydCB7ZWFjaH0gZnJvbSAnLi9vYmplY3QnO1xuXG4vKipcbiAqIOeUqOS6juWIh+aNoumhtemdouWFg+e0oOeahOeEpueCuVxuICovXG5cblxuLyoqXG4gKiDlhYPntKDmmK/lkKblj6/op4FcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gICB7RWxlbWVudH0gIG5vZGVcbiAqIEByZXR1cm4gIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBfaXNWaXNpYmxlKG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PT0gZG9jdW1lbnQuYm9keSB8fCBub2RlID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyB8fCBub2RlLnN0eWxlLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICog5YWD57Sg5piv5ZCm5Y+v5Lul6I635Y+W54Sm54K5XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge0VsZW1lbnR9ICBub2RlXG4gKiBAcmV0dXJuICB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gX2lzRm9jdXNhYmxlKG5vZGUpIHtcbiAgICBjb25zdCBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCB0YWJJbmRleCA9IHBhcnNlSW50KG5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCk7XG4gICAgY29uc3QgaGFzVGFiSW5kZXggPSAhaXNOYU4odGFiSW5kZXgpICYmIHRhYkluZGV4ID4gLTE7XG5cbiAgICBpZiAoX2lzVmlzaWJsZShub2RlKSkge1xuICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdpbnB1dCcpIHtcbiAgICAgICAgICAgIHJldHVybiAhbm9kZS5kaXNhYmxlZCAmJiBub2RlLnR5cGUgIT09ICdoaWRkZW4nO1xuICAgICAgICB9IGVsc2UgaWYgKFsnc2VsZWN0JywgJ3RleHRhcmVhJywgJ2J1dHRvbiddLmluZGV4T2Yobm9kZU5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAhbm9kZS5kaXNhYmxlZDtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlTmFtZSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICByZXR1cm4gKG5vZGUuZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgaGFzVGFiSW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGhhc1RhYkluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiDliJflh7rog73ojrflj5bnhKbngrnnmoTlrZDoioLngrlcbiAqIEBwYXJhbSAge0VsZW1lbnR9IG5vZGUg5a655Zmo6IqC54K5XG4gKiBAcmV0dXJuIHtBcnJheTxFbGVtZW50Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZvY3VzTm9kZUxpc3Qobm9kZSkge1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGNvbnN0IG5vZGVMaXN0ID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCcqJyk7XG5cbiAgICBlYWNoKG5vZGVMaXN0LCBpdGVtID0+IHtcbiAgICAgICAgaWYgKF9pc0ZvY3VzYWJsZShpdGVtKSkge1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtYXV0by1mb2N1cycpID8gJ3Vuc2hpZnQnIDogJ3B1c2gnO1xuICAgICAgICAgICAgcmVzW21ldGhvZF0oaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChfaXNGb2N1c2FibGUobm9kZSkpIHtcbiAgICAgICAgcmVzLnVuc2hpZnQobm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8g55So5LqO6K6w5b2V5LiK5LiA5qyh6I635b6X54Sm54K555qE5peg57SgXG5sZXQgbGFzdEZvY3VzRWxlbWVudCA9IG51bGw7XG5cbi8qKlxuICog5L+d5a2Y5pyA6L+R5LiA5qyh6I635b6X54Sm54K555qE5peg57SgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYXZlTGFzdEZvY3VzTm9kZSgpIHtcbiAgICBsYXN0Rm9jdXNFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbn1cblxuLyoqXG4gKiDmuIXpmaTnhKbngrnorrDlvZVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyTGFzdEZvY3VzTm9kZSgpIHtcbiAgICBsYXN0Rm9jdXNFbGVtZW50ID0gbnVsbDtcbn1cblxuLyoqXG4gKiDlsJ3or5XlsIbnhKbngrnliIfmjaLliLDkuIrkuIDkuKrlhYPntKBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhY2tMYXN0Rm9jdXNOb2RlKCkge1xuICAgIGlmIChsYXN0Rm9jdXNFbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyDlhYPntKDlj6/og73lt7Lnu4/ooqvnp7vliqjkuoZcbiAgICAgICAgICAgIGxhc3RGb2N1c0VsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaWdub3JlIC4uLlxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIOWcqOmZkOWItueahOiMg+WbtOWGheWIh+aNoueEpueCuVxuICogQHBhcmFtICB7RWxlbWVudH0gbm9kZSDlrrnlmajoioLngrlcbiAqIEBwYXJhbSAge0V2ZW50fSBlICAgICAg6ZSu55uY5LqL5Lu2XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW1pdFRhYlJhbmdlKG5vZGUsIGUpIHtcbiAgICBpZiAoZS5rZXlDb2RlID09PSBLRVlDT0RFLlRBQikge1xuICAgICAgICBjb25zdCB0YWJOb2RlTGlzdCA9IGdldEZvY3VzTm9kZUxpc3Qobm9kZSk7XG4gICAgICAgIGNvbnN0IG1heEluZGV4ID0gdGFiTm9kZUxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0YWJOb2RlTGlzdC5pbmRleE9mKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0SW5kZXggPSBpbmRleCArIChlLnNoaWZ0S2V5ID8gLTEgOiAxKTtcbiAgICAgICAgICAgIHRhcmdldEluZGV4IDwgMCAmJiAodGFyZ2V0SW5kZXggPSBtYXhJbmRleCk7XG4gICAgICAgICAgICB0YXJnZXRJbmRleCA+IG1heEluZGV4ICYmICh0YXJnZXRJbmRleCA9IDApO1xuICAgICAgICAgICAgdGFiTm9kZUxpc3RbdGFyZ2V0SW5kZXhdLmZvY3VzKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbC9mb2N1cy5qcyIsImxldCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXG4vKipcbiAqIOeUn+aIkOWFqOWxgOWUr+S4gOeahGlkXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFtwcmVmaXg9JyddIOWJjee8gOWtl+espuS4slxuICogQHJldHVybiB7U3RyaW5nfVxuICpcbiAqIEBleGFtcGxlXG4gKiBndWlkKCk7IC8vIGo3anY1MDljXG4gKiBndWlkKCdwcmVmaXgtJyk7IC8vIHByZWZpeC1qN2p2NTA5ZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gICAgcmV0dXJuIHByZWZpeCArICh0aW1lc3RhbXArKykudG9TdHJpbmcoMzYpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWwvZ3VpZC5qcyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgb2JqZWN0IGFuZCBrZXlzXG4gKiBnZW5lcmF0ZWQgYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eVxuICogb2Ygb2JqZWN0IHRocnUgaXRlcmF0ZWUuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5jb25zdCBtYXBLZXlzID0gKG9iaiwgZm4pID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgICAgICBjb25zdCBuZXdLZXkgPSBmbihrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdFtuZXdLZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXBsYWNlIHNwZWNpZmljIGtleSB3aXRoIHByZWZpeCBgbmV4dGBcbiAqIGFuZCBsb3dlcmNhc2UgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSByZXN1bHQuXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IHJlcGxhY2VLZXkgPSBrZXkgPT5cbiAgICBrZXkucmVwbGFjZSgvXihuZXh0KShbQS1aXSkvLCAobWF0Y2gsIHAxLCBwMikgPT4gcDIudG9Mb3dlckNhc2UoKSk7XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5jb25zdCB0cmFuc2Zvcm1Db250ZXh0ID0gc291cmNlID0+IG1hcEtleXMoc291cmNlLCByZXBsYWNlS2V5KTtcblxuLyoqXG4gKiBDb25zdW1lclxuICogQHBhcmFtIHtPYmplY3R9IHByb3BcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKi9cbmNvbnN0IENvbnN1bWVyID0gKHsgY2hpbGRyZW4gfSwgY29udGV4dCkgPT5cbiAgICB0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicgPyBjaGlsZHJlbih0cmFuc2Zvcm1Db250ZXh0KGNvbnRleHQpKSA6IG51bGw7XG5cbi8qKlxuICogUHJvcFR5cGVzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHN0YXRpY1xuICovXG5Db25zdW1lci5wcm9wVHlwZXMgPSB7XG4gICAgLy8gUmVuZGVyIGNvbnRleHQgYXMgZnVuY3Rpb25cbiAgICAvLyBGdW5jdGlvbihjb250ZXh0OiBvYmplY3QpOiBSZWFjdEVsZW1lbnRcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbi8qKlxuICogQ29udGV4dFR5cGVzIChsZWdhY3kgY29udGV4dClcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc3RhdGljXG4gKi9cbkNvbnN1bWVyLmNvbnRleHRUeXBlcyA9IHtcbiAgICBuZXh0UHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG5leHRMb2NhbGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgbmV4dFB1cmU6IFByb3BUeXBlcy5ib29sLFxuICAgIG5ld1J0bDogUHJvcFR5cGVzLmJvb2wsXG4gICAgbmV4dFdhcm5pbmc6IFByb3BUeXBlcy5ib29sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBDb25zdW1lcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb25maWctcHJvdmlkZXIvY29uc3VtZXIuanN4IiwiY2xhc3MgQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3RvcmUgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9yZS5zaXplID09PSAwO1xuICAgIH1cblxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIGdldChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLmhhcyhrZXkpID8gdGhpcy5fc3RvcmUuZ2V0KGtleSkgOiB0aGlzLnJvb3QoKTtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgcmVzID09PSAndW5kZWZpbmVkJyB8fCByZXMgPT09IG51bGwpID9cbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA6IHJlcztcbiAgICB9XG5cbiAgICBhZGQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5lbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9yb290ID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0b3JlLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5fc3RvcmUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlKGtleSkge1xuICAgICAgICB0aGlzLl9zdG9yZS5kZWxldGUoa2V5KTtcbiAgICB9XG5cbiAgICByb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcmUuZ2V0KHRoaXMuX3Jvb3QpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FjaGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29uZmlnLXByb3ZpZGVyL2NhY2hlLmpzIiwiaWYodHlwZW9mIHdpbmRvdy5tb21lbnQgPT09ICd1bmRlZmluZWQnKSB7dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgXFxcIndpbmRvdy5tb21lbnRcXFwiXCIpOyBlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7IHRocm93IGU7fVxubW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cubW9tZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwid2luZG93Lm1vbWVudFwiXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkgMTAgMTEgMTIgMTMgMTQgMTUgMTYgMTcgMTggMTkgMjAgMjEgMjIiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHNoYWxsb3dFbGVtZW50RXF1YWxzIGZyb20gJ3NoYWxsb3ctZWxlbWVudC1lcXVhbHMnO1xuaW1wb3J0IExvYWRpbmcgZnJvbSAnLi4vbG9hZGluZyc7XG5pbXBvcnQgemhDTiBmcm9tICcuLi9sb2NhbGUvemgtY24nO1xuaW1wb3J0IHsgbG9nLCBvYmogfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBCb2R5Q29tcG9uZW50IGZyb20gJy4vYmFzZS9ib2R5JztcbmltcG9ydCBIZWFkZXJDb21wb25lbnQgZnJvbSAnLi9iYXNlL2hlYWRlcic7XG5pbXBvcnQgV3JhcHBlckNvbXBvbmVudCBmcm9tICcuL2Jhc2Uvd3JhcHBlcic7XG5pbXBvcnQgUm93Q29tcG9uZW50IGZyb20gJy4vYmFzZS9yb3cnO1xuaW1wb3J0IENlbGxDb21wb25lbnQgZnJvbSAnLi9iYXNlL2NlbGwnO1xuaW1wb3J0IEZpbHRlckNvbXBvbmVudCBmcm9tICcuL2Jhc2UvZmlsdGVyJztcbmltcG9ydCBTb3J0Q29tcG9uZW50IGZyb20gJy4vYmFzZS9zb3J0JztcbmltcG9ydCBDb2x1bW4gZnJvbSAnLi9jb2x1bW4nO1xuaW1wb3J0IENvbHVtbkdyb3VwIGZyb20gJy4vY29sdW1uLWdyb3VwJztcblxuY29uc3QgQ2hpbGRyZW4gPSBSZWFjdC5DaGlsZHJlbixcbiAgICBub29wID0gKCkgPT4ge307XG5cbi8vPFRhYmxlPlxuLy8gICAgPFRhYmxlLkNvbHVtbi8+XG4vLyAgICA8VGFibGUuQ29sdW1uR3JvdXA+XG4vLyAgICAgIDxUYWJsZS5Db2x1bW4vPlxuLy8gICAgICA8VGFibGUuQ29sdW1uLz5cbi8vICAgIDwvVGFibGUuQ29sdW1uR3JvdXA+XG4vLzwvVGFibGU+XG5cbi8qKiBUYWJsZSAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFibGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBDb2x1bW4gPSBDb2x1bW47XG4gICAgc3RhdGljIENvbHVtbkdyb3VwID0gQ29sdW1uR3JvdXA7XG4gICAgc3RhdGljIEhlYWRlciA9IEhlYWRlckNvbXBvbmVudDtcbiAgICBzdGF0aWMgQm9keSA9IEJvZHlDb21wb25lbnQ7XG4gICAgc3RhdGljIFdyYXBwZXIgPSBXcmFwcGVyQ29tcG9uZW50O1xuICAgIHN0YXRpYyBSb3cgPSBSb3dDb21wb25lbnQ7XG4gICAgc3RhdGljIENlbGwgPSBDZWxsQ29tcG9uZW50O1xuICAgIHN0YXRpYyBGaWx0ZXIgPSBGaWx0ZXJDb21wb25lbnQ7XG4gICAgc3RhdGljIFNvcnQgPSBTb3J0Q29tcG9uZW50O1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOagt+W8j+exu+WQjeeahOWTgeeJjOWJjee8gFxuICAgICAgICAgKi9cbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBwdXJlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgcnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieexu+WQjVxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ5YaF6IGU5qC35byPXG4gICAgICAgICAqL1xuICAgICAgICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOihqOagvOWxleekuueahOaVsOaNrua6kFxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YVNvdXJjZTogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBlbnRpcmVEYXRhU291cmNlOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDngrnlh7vooajmoLzmr4/kuIDooYzop6blj5HnmoTkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZCDor6XooYzmiYDlr7nlupTnmoTmlbDmja5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IOivpeihjOaJgOWvueW6lOeahOW6j+WIl1xuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIERPTeS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgb25Sb3dDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmgqzmta7lnKjooajmoLzmr4/kuIDooYznmoTml7blgJnop6blj5HnmoTkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZCDor6XooYzmiYDlr7nlupTnmoTmlbDmja5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IOivpeihjOaJgOWvueW6lOeahOW6j+WIl1xuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIERPTeS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgb25Sb3dNb3VzZUVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOemu+W8gOihqOagvOavj+S4gOihjOeahOaXtuWAmeinpuWPkeeahOS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkIOivpeihjOaJgOWvueW6lOeahOaVsOaNrlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXgg6K+l6KGM5omA5a+55bqU55qE5bqP5YiXXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRE9N5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBvblJvd01vdXNlTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog54K55Ye75YiX5o6S5bqP6Kem5Y+R55qE5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhSW5kZXgg5oyH5a6a55qE5o6S5bqP55qE5a2X5q61XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmRlciDmjpLluo/lr7nlupTnmoTpobrluo8sIOaciWBkZXNjYOWSjGBhc2Ng5Lik56eNXG4gICAgICAgICAqL1xuICAgICAgICBvblNvcnQ6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog54K55Ye76L+H5ruk56Gu6K6k5oyJ6ZKu6Kem5Y+R55qE5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWx0ZXJQYXJhbXMg6L+H5ruk55qE5a2X5q615L+h5oGvXG4gICAgICAgICAqL1xuICAgICAgICBvbkZpbHRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDph43orr7liJflsLrlr7jnmoTml7blgJnop6blj5HnmoTkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFJbmRleCDmjIflrprph43orr7nmoTlrZfmrrVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIOWIl+WuveWPmOWKqOeahOaVsOWAvFxuICAgICAgICAgKi9cbiAgICAgICAgb25SZXNpemVDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5q+P5LiA6KGM55qE5bGe5oCn77yM5aaC5p6c6L+U5Zue5YC85ZKM5YW25LuW6ZKI5a+56KGM5pON5L2c55qE5bGe5oCn5Yay56qB5YiZ5peg5pWI44CCXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmQg6K+l6KGM5omA5a+55bqU55qE5pWw5o2uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCDor6XooYzmiYDlr7nlupTnmoTluo/liJdcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0g6ZyA6KaB6K6+572u55qE6KGM5bGe5oCnXG4gICAgICAgICAqL1xuICAgICAgICBnZXRSb3dQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7ljZXlhYPmoLznmoTlsZ7mgKfvvIzpgJrov4for6XlsZ7mgKflj6/ku6Xov5vooYzlkIjlubbljZXlhYPmoLxcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd0luZGV4IOivpeihjOaJgOWvueW6lOeahOW6j+WIl1xuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY29sSW5kZXgg6K+l5YiX5omA5a+55bqU55qE5bqP5YiXXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhSW5kZXgg6K+l5YiX5omA5a+55bqU55qE5a2X5q615ZCN56ewXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmQg6K+l6KGM5a+55bqU55qE6K6w5b2VXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IOi/lOWbnnRk5YWD57Sg55qE5omA5pSv5oyB55qE5bGe5oCn5a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDZWxsUHJvcHM6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog6KGo5qC85piv5ZCm5YW35pyJ6L655qGGXG4gICAgICAgICAqL1xuICAgICAgICBoYXNCb3JkZXI6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6KGo5qC85piv5ZCm5YW35pyJ5aS06YOoXG4gICAgICAgICAqL1xuICAgICAgICBoYXNIZWFkZXI6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6KGo5qC85piv5ZCm5piv5paR6ams57q/XG4gICAgICAgICAqL1xuICAgICAgICBpc1plYnJhOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOihqOagvOaYr+WQpuWcqOWKoOi9veS4rVxuICAgICAgICAgKi9cbiAgICAgICAgbG9hZGluZzogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYkgTG9hZGluZyDnu4Tku7ZcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgbG9hZGluZ0NvbXBvbmVudDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvZPliY3ov4fmu6TnmoTnmoRrZXlzLOS9v+eUqOatpOWxnuaAp+WPr+S7peaOp+WItuihqOagvOeahOWktOmDqOeahOi/h+a7pOmAiemhueS4reWTquS4quiPnOWNleiiq+mAieS4rSzmoLzlvI/kuLoge2RhdGFJbmRleDoge3NlbGVjdGVkS2V5czpbXX19XG4gICAgICAgICAqIOekuuS+izpcbiAgICAgICAgICog5YGH6K6+6KaB5o6n5Yi2ZGF0YUluZGV45Li6aWTnmoTliJfnmoTov4fmu6Toj5zljZXkuK1rZXnkuLpvbmXnmoToj5zljZXpobnpgInkuK1cbiAgICAgICAgICogYDxUYWJsZSBmaWx0ZXJQYXJhbXM9e3tpZDoge3NlbGVjdGVkS2V5czogWydvbmUnXX19fS8+YFxuICAgICAgICAgKi9cbiAgICAgICAgZmlsdGVyUGFyYW1zOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAvKipcbiAgICAgICAgICog5b2T5YmN5o6S5bqP55qE5a2X5q61LOS9v+eUqOatpOWxnuaAp+WPr+S7peaOp+WItuihqOagvOeahOWtl+auteeahOaOkuW6jyzmoLzlvI/kuLp7ZGF0YUluZGV4OiAnYXNjJ31cbiAgICAgICAgICovXG4gICAgICAgIHNvcnQ6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnlm73pmYXljJbmlofmoYjlr7nosaFcbiAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IG9rIOi/h+a7pOWZqOS4reehruiupOaMiemSruaWh+ahiFxuICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gcmVzZXQg6L+H5ruk5Zmo5Lit6YeN572u5oyJ6ZKu5paH5qGIXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBlbXB0eSDmsqHmnInmlbDmja7mg4XlhrXkuIsgdGFibGXlhoXnmoTmlofmoYhcbiAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGFzYyDmjpLluo/ljYfluo/nirbmgIHkuIvnmoTmlofmoYhcbiAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGRlc2Mg5o6S5bqP5bCG5bqP54q25oCB5LiL55qE5paH5qGIXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBleHBhbmRlZCDlj6/mipjlj6DooYzvvIzlsZXlvIDnirbmgIHkuIvnmoTmlofmoYhcbiAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGZvbGRlZCDlj6/mipjlj6DooYzvvIzmipjlj6DnirbmgIHkuIvnmoTmlofmoYhcbiAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGZpbHRlciDov4fmu6TlmajmlofmoYhcbiAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IHNlbGVjdEFsbCBoZWFkZXLph4zlhajpgInnmoTmjInpkq7mlofmoYhcbiAgICAgICAgICovXG4gICAgICAgIGxvY2FsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgY29tcG9uZW50czogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgY29sdW1uczogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5pWw5o2u5Li656m655qE5pe25YCZ55qE6KGo5qC85YaF5a655bGV546wXG4gICAgICAgICAqL1xuICAgICAgICBlbXB0eUNvbnRlbnQ6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICAvKipcbiAgICAgICAgICogZGF0YVNvdXJjZeW9k+S4reaVsOaNrueahOS4u+mUru+8jOWmguaenOe7meWumueahOaVsOaNrua6kOS4reeahOWxnuaAp+S4jeWMheWQq+ivpeS4u+mUru+8jOS8mumAoOaIkOmAieaLqeeKtuaAgeWFqOmDqOmAieS4rVxuICAgICAgICAgKi9cbiAgICAgICAgcHJpbWFyeUtleTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgbG9ja1R5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2xlZnQnLCAncmlnaHQnXSksXG4gICAgICAgIHdyYXBwZXJDb250ZW50OiBQcm9wVHlwZXMuYW55LFxuICAgICAgICByZWZzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAvKipcbiAgICAgICAgICog6aKd5aSW5riy5p+T6KGM55qE5riy5p+T5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmQg6K+l6KGM5omA5a+55bqU55qE5pWw5o2uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCDor6XooYzmiYDlr7nlupTnmoTluo/liJdcbiAgICAgICAgICogQHJldHVybnMge0VsZW1lbnR9IOa4suafk+WGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgZXhwYW5kZWRSb3dSZW5kZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog6aKd5aSW5riy5p+T6KGM55qE57yp6L+bXG4gICAgICAgICAqL1xuICAgICAgICBleHBhbmRlZFJvd0luZGVudDogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICAvKipcbiAgICAgICAgICog6buY6K6k5oOF5Ya15LiL5bGV5byA55qE5riy5p+T6KGM5oiW6ICFVHJlZSwg5Lyg5YWl5q2k5bGe5oCn5Li65Y+X5o6n54q25oCBXG4gICAgICAgICAqL1xuICAgICAgICBvcGVuUm93S2V5czogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5pi+56S654K55Ye75bGV5byA6aKd5aSW5riy5p+T6KGM55qEK+WPt+aMiemSrlxuICAgICAgICAgKi9cbiAgICAgICAgaGFzRXhwYW5kZWRSb3dDdHJsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9rumineWklua4suafk+ihjOeahOWxnuaAp1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RXhwYW5kZWRDb2xQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlnKjpop3lpJbmuLLmn5PooYzmiJbogIVUcmVl5bGV5byA5oiW6ICF5pS26LW355qE5pe25YCZ6Kem5Y+R55qE5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IG9wZW5Sb3dLZXlzIOWxleW8gOeahOa4suafk+ihjOeahGtleVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gY3VycmVudFJvd0tleSDlvZPliY3ngrnlh7vnmoTmuLLmn5PooYznmoRrZXlcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBleHBhbmRlZCDlvZPliY3ngrnlh7vmmK/lsZXlvIDov5jmmK/mlLbotbdcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGN1cnJlbnRSZWNvcmQg5b2T5YmN54K55Ye76aKd5aSW5riy5p+T6KGM55qE6K6w5b2VXG4gICAgICAgICAqL1xuICAgICAgICBvblJvd09wZW46IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog54K55Ye76aKd5aSW5riy5p+T6KGM6Kem5Y+R55qE5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmQg6K+l6KGM5omA5a+55bqU55qE5pWw5o2uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCDor6XooYzmiYDlr7nlupTnmoTluo/liJdcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSBET03kuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIG9uRXhwYW5kZWRSb3dDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDooajlpLTmmK/lkKblm7rlrprvvIzor6XlsZ7mgKfphY3lkIhtYXhCb2R5SGVpZ2h05L2/55So77yM5b2T5YaF5a655Yy65Z+f55qE6auY5bqm6LaF6L+HbWF4Qm9keUhlaWdodOeahOaXtuWAme+8jOWcqOWGheWuueWMuuWfn+S8muWHuueOsOa7muWKqOadoVxuICAgICAgICAgKi9cbiAgICAgICAgZml4ZWRIZWFkZXI6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5pyA5aSn5YaF5a655Yy65Z+f55qE6auY5bqmLOWcqGBmaXhlZEhlYWRlcmDkuLpgdHJ1ZWDnmoTml7blgJks6LaF6L+H6L+Z5Liq6auY5bqm5Lya5Ye6546w5rua5Yqo5p2hXG4gICAgICAgICAqL1xuICAgICAgICBtYXhCb2R5SGVpZ2h0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblkK/nlKjpgInmi6nmqKHlvI9cbiAgICAgICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZ2V0UHJvcHMgYEZ1bmN0aW9uKHJlY29yZCwgaW5kZXgpPT5PYmplY3RgIOiOt+WPlnNlbGVjdGlvbueahOm7mOiupOWxnuaAp1xuICAgICAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvbkNoYW5nZSBgRnVuY3Rpb24oc2VsZWN0ZWRSb3dLZXlzOkFycmF5LCByZWNvcmRzOkFycmF5KWAg6YCJ5oup5pS55Y+Y55qE5pe25YCZ6Kem5Y+R55qE5LqL5Lu277yMKirms6jmhI86Kiog5YW25LitcmVjb3Jkc+WPquS8muWMheWQq+W9k+WJjWRhdGFTb3VyY2XnmoTmlbDmja7vvIzlvojlj6/og73kvJrlsI/kuo5zZWxlY3RlZFJvd0tleXPnmoTplb/luqbjgIJcbiAgICAgICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb25TZWxlY3QgYEZ1bmN0aW9uKHNlbGVjdGVkOkJvb2xlYW4sIHJlY29yZDpPYmplY3QsIHJlY29yZHM6QXJyYXkpYCDnlKjmiLfmiYvliqjpgInmi6kv5Y+W5raI6YCJ5oup5p+Q6KGM55qE5Zue6LCDXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG9uU2VsZWN0QWxsIGBGdW5jdGlvbihzZWxlY3RlZDpCb29sZWFuLCByZWNvcmRzOkFycmF5KWAg55So5oi35omL5Yqo6YCJ5oupL+WPlua2iOmAieaLqeaJgOacieihjOeahOWbnuiwg1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5fSBzZWxlY3RlZFJvd0tleXMg6K6+572u5LqG5q2k5bGe5oCnLOWwhnJvd1NlbGVjdGlvbuWPmOS4uuWPl+aOp+eKtuaAgSzmjqXmlLblgLzkuLror6XooYzmlbDmja7nmoRwcmltYXJ5S2V555qE5YC8XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBtb2RlIOmAieaLqXNlbGVjdGlvbueahOaooeW8jywg5Y+v6YCJ5YC85Li6YHNpbmdsZWAsIGBtdWx0aXBsZWDvvIzpu5jorqTkuLpgbXVsdGlwbGVgXG4gICAgICAgICAqL1xuICAgICAgICByb3dTZWxlY3Rpb246IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDooajlpLTmmK/lkKbmmK9zdGlja3lcbiAgICAgICAgICovXG4gICAgICAgIHN0aWNreUhlYWRlcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDot53nprvnqpflj6Ppobbpg6jovr7liLDmjIflrprlgY/np7vph4/lkI7op6blj5FcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNldFRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFmZml457uE5Lu255qE55qE5bGe5oCnXG4gICAgICAgICAqL1xuICAgICAgICBhZmZpeFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAvKipcbiAgICAgICAgICog5ZyodHJlZeaooeW8j+S4i+eahOe8qei/m+WwuuWvuO+8jCDku4XlnKhpc1RyZWXkuLp0cnVl5pe25YCZ5pyJ5pWIXG4gICAgICAgICAqL1xuICAgICAgICBpbmRlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvIDlkK9UYWJsZeeahHRyZWXmqKHlvI8sIOaOpeaUtueahOaVsOaNruagvOW8j+S4reWMheWQq2NoaWxkcmVu5YiZ5riy5p+T5oiQdHJlZSB0YWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNUcmVlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuW8gOWQr+iZmuaLn+a7muWKqFxuICAgICAgICAgKi9cbiAgICAgICAgdXNlVmlydHVhbDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7ooYzpq5hcbiAgICAgICAgICovXG4gICAgICAgIHJvd0hlaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWcqOWGheWuueWMuuWfn+a7muWKqOeahOaXtuWAmeinpuWPkeeahOWHveaVsFxuICAgICAgICAgKi9cbiAgICAgICAgb25Cb2R5U2Nyb2xsOiBQcm9wVHlwZXMuZnVuY1xuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBkYXRhU291cmNlOiBbXSxcbiAgICAgICAgb25Sb3dDbGljazogbm9vcCxcbiAgICAgICAgb25Sb3dNb3VzZUVudGVyOiBub29wLFxuICAgICAgICBvblJvd01vdXNlTGVhdmU6IG5vb3AsXG4gICAgICAgIG9uU29ydDogbm9vcCxcbiAgICAgICAgb25GaWx0ZXI6IG5vb3AsXG4gICAgICAgIG9uUmVzaXplQ2hhbmdlOiBub29wLFxuICAgICAgICBnZXRSb3dQcm9wczogbm9vcCxcbiAgICAgICAgZ2V0Q2VsbFByb3BzOiBub29wLFxuICAgICAgICBwcmVmaXg6ICduZXh0LScsXG4gICAgICAgIGhhc0JvcmRlcjogdHJ1ZSxcbiAgICAgICAgaGFzSGVhZGVyOiB0cnVlLFxuICAgICAgICBpc1plYnJhOiBmYWxzZSxcbiAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgIHByaW1hcnlLZXk6ICdpZCcsXG4gICAgICAgIGNvbXBvbmVudHM6IHt9LFxuICAgICAgICBsb2NhbGU6IHpoQ04uVGFibGVcbiAgICB9O1xuXG4gICAgc3RhdGljIGNoaWxkQ29udGV4dFR5cGVzID0ge1xuICAgICAgICBub3RSZW5kZXJDZWxsSW5kZXg6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgbG9ja1R5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2xlZnQnLCAncmlnaHQnXSlcbiAgICB9O1xuXG4gICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgZ2V0VGFibGVJbnN0YW5jZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGdldFRhYmxlSW5zdGFuY2VGb3JWaXJ0dWFsOiBQcm9wVHlwZXMuZnVuY1xuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xuICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IHsgZ2V0VGFibGVJbnN0YW5jZSwgZ2V0VGFibGVJbnN0YW5jZUZvclZpcnR1YWwgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgZ2V0VGFibGVJbnN0YW5jZSAmJiBnZXRUYWJsZUluc3RhbmNlKHByb3BzLmxvY2tUeXBlLCB0aGlzKTtcbiAgICAgICAgZ2V0VGFibGVJbnN0YW5jZUZvclZpcnR1YWwgJiZcbiAgICAgICAgICAgIGdldFRhYmxlSW5zdGFuY2VGb3JWaXJ0dWFsKHByb3BzLmxvY2tUeXBlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5ub3RSZW5kZXJDZWxsSW5kZXggPSBbXTtcbiAgICB9XG5cbiAgICBzdGF0ZSA9IHtcbiAgICAgICAgc29ydDogdGhpcy5wcm9wcy5zb3J0IHx8IHt9XG4gICAgfTtcblxuICAgIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vdFJlbmRlckNlbGxJbmRleDogdGhpcy5ub3RSZW5kZXJDZWxsSW5kZXgsXG4gICAgICAgICAgICBsb2NrVHlwZTogdGhpcy5wcm9wcy5sb2NrVHlwZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5zb3J0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgc29ydDogbmV4dFByb3BzLnNvcnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCkge1xuICAgICAgICBpZiAobmV4dFByb3BzLnB1cmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzRXF1YWwgPVxuICAgICAgICAgICAgICAgIHNoYWxsb3dFbGVtZW50RXF1YWxzKG5leHRQcm9wcywgdGhpcy5wcm9wcykgJiZcbiAgICAgICAgICAgICAgICBvYmouc2hhbGxvd0VxdWFsKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkgJiZcbiAgICAgICAgICAgICAgICBvYmouc2hhbGxvd0VxdWFsKG5leHRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuICFpc0VxdWFsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5ub3RSZW5kZXJDZWxsSW5kZXggPSBbXTtcbiAgICB9XG5cbiAgICBub3JtYWxpemVDaGlsZHJlblN0YXRlKHByb3BzKSB7XG4gICAgICAgIGxldCBjb2x1bW5zID0gcHJvcHMuY29sdW1ucztcbiAgICAgICAgaWYgKHByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb2x1bW5zID0gdGhpcy5ub3JtYWxpemVDaGlsZHJlbihwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hJbmZvRnJvbUJpbmFyeUNoaWxkcmVuKGNvbHVtbnMpO1xuICAgIH1cblxuICAgIC8vIOWwhlJlYWN057uT5p6E5YyW5pWw5o2u5o+Q5Y+WcHJvcHPovazmjaLmiJDmlbDnu4RcbiAgICBub3JtYWxpemVDaGlsZHJlbihwcm9wcykge1xuICAgICAgICBsZXQgeyBjb2x1bW5zIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgZ2V0Q2hpbGRyZW4gPSBjaGlsZHJlbiA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgICAgICAgIENoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB7IC4uLmNoaWxkLnByb3BzIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjaGlsZC50eXBlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNoaWxkLnR5cGUuX3R5cGVNYXJrID09PSAnY29sdW1uJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC50eXBlLl90eXBlTWFyayA9PT0gJ2NvbHVtbkdyb3VwJylcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cud2FybmluZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVXNlIDxUYWJsZS5Db2x1bW4vPiwgPFRhYmxlLkNvbHVtbkdyb3VwLz4gYXMgY2hpbGQuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSBnZXRDaGlsZHJlbihjaGlsZC5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgY29sdW1ucyA9IGdldENoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sdW1ucztcbiAgICB9XG5cbiAgICBmZXRjaEluZm9Gcm9tQmluYXJ5Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGhhc0dyb3VwSGVhZGVyID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGZsYXRDaGlsZHJlbiA9IFtdLFxuICAgICAgICAgICAgZ3JvdXBDaGlsZHJlbiA9IFtdLFxuICAgICAgICAgICAgZ2V0Q2hpbGRyZW4gPSAocHJvcHNDaGlsZHJlbiwgbGV2ZWwpID0+IHtcbiAgICAgICAgICAgICAgICBncm91cENoaWxkcmVuW2xldmVsXSA9IGdyb3VwQ2hpbGRyZW5bbGV2ZWxdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHByb3BzQ2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzR3JvdXBIZWFkZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q2hpbGRyZW4oY2hpbGQuY2hpbGRyZW4sIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGF0Q2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBDaGlsZHJlbltsZXZlbF0ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q29sU3BhbiA9IChjaGlsZHJlbiwgY29sU3BhbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbFNwYW4gPSBjb2xTcGFuIHx8IDA7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sU3BhbiA9IGdldENvbFNwYW4oY2hpbGQuY2hpbGRyZW4sIGNvbFNwYW4pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sU3BhbiArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbFNwYW47XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGdldENoaWxkcmVuKGNoaWxkcmVuLCAwKTtcblxuICAgICAgICBncm91cENoaWxkcmVuLmZvckVhY2goKGdyb3VwQ2hpbGQsIGkpID0+IHtcbiAgICAgICAgICAgIGdyb3VwQ2hpbGQuZm9yRWFjaCgoY2hpbGQsIGopID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY29sU3BhbjtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGNoaWxkLmNoaWxkcmVuO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbFNwYW4gPSBnZXRDb2xTcGFuKGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29sU3BhbiA9IGNvbFNwYW47XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwQ2hpbGRyZW5baV1bal0gPSBjaGlsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZsYXRDaGlsZHJlbixcbiAgICAgICAgICAgIGdyb3VwQ2hpbGRyZW4sXG4gICAgICAgICAgICBoYXNHcm91cEhlYWRlclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJlbmRlckNvbEdyb3VwKGZsYXRDaGlsZHJlbikge1xuICAgICAgICBjb25zdCBjb2xzID0gZmxhdENoaWxkcmVuLm1hcCgoY29sLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBjb2wud2lkdGg7XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSB7fTtcbiAgICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgICAgIHN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gPGNvbCBzdHlsZT17c3R5bGV9IGtleT17aW5kZXh9IC8+O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIDxjb2xncm91cCBrZXk9XCJ0YWJsZS1jb2xncm91cFwiPntjb2xzfTwvY29sZ3JvdXA+O1xuICAgIH1cblxuICAgIG9uU29ydCA9IChkYXRhSW5kZXgsIG9yZGVyLCBzb3J0KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5zb3J0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNvcnQ6IHNvcnRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblNvcnQoZGF0YUluZGV4LCBvcmRlciwgc29ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Tb3J0KGRhdGFJbmRleCwgb3JkZXIsIHNvcnQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG9uRmlsdGVyID0gZmlsdGVyUGFyYW1zID0+IHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkZpbHRlcihmaWx0ZXJQYXJhbXMpO1xuICAgIH07XG5cbiAgICBvblJlc2l6ZUNoYW5nZSA9IChkYXRhSW5kZXgsIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMucHJvcHMub25SZXNpemVDaGFuZ2UoZGF0YUluZGV4LCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8vIOmAmui/h+WktOmDqOWSjOaJgeW5s+eahOe7k+aehOa4suafk+ihqOagvFxuICAgIHJlbmRlclRhYmxlKGdyb3VwQ2hpbGRyZW4sIGZsYXRDaGlsZHJlbikge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBmbGF0Q2hpbGRyZW4ubGVuZ3RoIHx8XG4gICAgICAgICAgICAoIWZsYXRDaGlsZHJlbi5sZW5ndGggJiYgIXRoaXMucHJvcHMubG9ja1R5cGUpXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGhhc0hlYWRlcixcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLFxuICAgICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgICB3cmFwcGVyQ29udGVudCxcbiAgICAgICAgICAgICAgICBmaWx0ZXJQYXJhbXMsXG4gICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgZW1wdHlDb250ZW50LFxuICAgICAgICAgICAgICAgIGxvYWRpbmcsXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbFByb3BzLFxuICAgICAgICAgICAgICAgIHByaW1hcnlLZXksXG4gICAgICAgICAgICAgICAgZ2V0Um93UHJvcHMsXG4gICAgICAgICAgICAgICAgb25Sb3dDbGljayxcbiAgICAgICAgICAgICAgICBvblJvd01vdXNlRW50ZXIsXG4gICAgICAgICAgICAgICAgb25Sb3dNb3VzZUxlYXZlLFxuICAgICAgICAgICAgICAgIHB1cmVcbiAgICAgICAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgY29uc3QgeyBzb3J0IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIEhlYWRlciA9IEhlYWRlckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBXcmFwcGVyID0gV3JhcHBlckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBCb2R5ID0gQm9keUNvbXBvbmVudFxuICAgICAgICAgICAgfSA9IGNvbXBvbmVudHM7XG4gICAgICAgICAgICBjb25zdCBjb2xHcm91cCA9IHRoaXMucmVuZGVyQ29sR3JvdXAoZmxhdENoaWxkcmVuKTtcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8V3JhcHBlclxuICAgICAgICAgICAgICAgICAgICBjb2xHcm91cD17Y29sR3JvdXB9XG4gICAgICAgICAgICAgICAgICAgIHJlZj17dGhpcy5nZXRXcmFwcGVyUmVmfVxuICAgICAgICAgICAgICAgICAgICBwcmVmaXg9e3ByZWZpeH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHtoYXNIZWFkZXIgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8SGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4PXtwcmVmaXh9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVyZT17cHVyZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZmZpeFJlZj17dGhpcy5nZXRBZmZpeFJlZn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xHcm91cD17Y29sR3JvdXB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtaGVhZGVyYH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJQYXJhbXM9e2ZpbHRlclBhcmFtc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zPXtncm91cENoaWxkcmVufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZT17bG9jYWxlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlckNlbGxSZWY9e3RoaXMuZ2V0SGVhZGVyQ2VsbFJlZn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzPXtjb21wb25lbnRzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRmlsdGVyPXt0aGlzLm9uRmlsdGVyfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnQ9e3NvcnR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZXNpemVDaGFuZ2U9e3RoaXMub25SZXNpemVDaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Tb3J0PXt0aGlzLm9uU29ydH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICkgOiBudWxsfVxuICAgICAgICAgICAgICAgICAgICA8Qm9keVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4PXtwcmVmaXh9XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXJlPXtwdXJlfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sR3JvdXA9e2NvbEdyb3VwfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtYm9keWB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzPXtjb21wb25lbnRzfVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZz17bG9hZGluZ31cbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcHR5Q29udGVudD17ZW1wdHlDb250ZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q2VsbFByb3BzPXtnZXRDZWxsUHJvcHN9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5PXtwcmltYXJ5S2V5fVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Um93UHJvcHM9e2dldFJvd1Byb3BzfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1ucz17ZmxhdENoaWxkcmVufVxuICAgICAgICAgICAgICAgICAgICAgICAgcm93UmVmPXt0aGlzLmdldFJvd1JlZn1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxSZWY9e3RoaXMuZ2V0Q2VsbFJlZn1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUm93Q2xpY2s9e29uUm93Q2xpY2t9XG4gICAgICAgICAgICAgICAgICAgICAgICBvblJvd01vdXNlRW50ZXI9e29uUm93TW91c2VFbnRlcn1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUm93TW91c2VMZWF2ZT17b25Sb3dNb3VzZUxlYXZlfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVNvdXJjZT17ZGF0YVNvdXJjZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZT17bG9jYWxlfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICB7d3JhcHBlckNvbnRlbnR9XG4gICAgICAgICAgICAgICAgPC9XcmFwcGVyPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0V3JhcHBlclJlZiA9IHdyYXBwZXIgPT4ge1xuICAgICAgICBpZiAoIXdyYXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cmFwcGVyID0gd3JhcHBlcjtcbiAgICB9O1xuXG4gICAgZ2V0QWZmaXhSZWYgPSAoYWZmaXhSZWYpID0+IHtcbiAgICAgICAgaWYgKCFhZmZpeFJlZikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWZmaXhSZWY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZmZpeFJlZiA9IGFmZml4UmVmO1xuICAgIH07XG5cbiAgICBnZXRIZWFkZXJDZWxsUmVmID0gKGksIGosIGNlbGwpID0+IHtcbiAgICAgICAgY29uc3QgY2VsbFJlZiA9IGBoZWFkZXJfY2VsbF8ke2l9XyR7an1gO1xuICAgICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2NlbGxSZWZdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbY2VsbFJlZl0gPSBjZWxsO1xuICAgIH07XG5cbiAgICBnZXRSb3dSZWYgPSAoaSwgcm93KSA9PiB7XG4gICAgICAgIGNvbnN0IHJvd1JlZiA9IGByb3dfJHtpfWA7XG4gICAgICAgIGlmICghcm93KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tyb3dSZWZdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbcm93UmVmXSA9IHJvdztcbiAgICB9O1xuXG4gICAgZ2V0Q2VsbFJlZiA9IChpLCBqLCBjZWxsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNlbGxSZWYgPSBgY2VsbF8ke2l9XyR7an1gO1xuICAgICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2NlbGxSZWZdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbY2VsbFJlZl0gPSBjZWxsO1xuICAgIH07XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXMubm9ybWFsaXplQ2hpbGRyZW5TdGF0ZSh0aGlzLnByb3BzKTtcbiAgICAgICAgdGhpcy5ncm91cENoaWxkcmVuID0gcmV0Lmdyb3VwQ2hpbGRyZW47XG4gICAgICAgIHRoaXMuZmxhdENoaWxkcmVuID0gcmV0LmZsYXRDaGlsZHJlbjtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIHByZWZlci1jb25zdCAqL1xuICAgICAgICBsZXQgdGFibGUgPSB0aGlzLnJlbmRlclRhYmxlKHJldC5ncm91cENoaWxkcmVuLCByZXQuZmxhdENoaWxkcmVuKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgaGFzQm9yZGVyLFxuICAgICAgICAgICAgICAgIGlzWmVicmEsXG4gICAgICAgICAgICAgICAgbG9hZGluZyxcbiAgICAgICAgICAgICAgICBoYXNIZWFkZXIsXG4gICAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgZW50aXJlRGF0YVNvdXJjZSxcbiAgICAgICAgICAgICAgICBvblNvcnQsXG4gICAgICAgICAgICAgICAgb25SZXNpemVDaGFuZ2UsXG4gICAgICAgICAgICAgICAgb25Sb3dDbGljayxcbiAgICAgICAgICAgICAgICBvblJvd01vdXNlRW50ZXIsXG4gICAgICAgICAgICAgICAgb25Sb3dNb3VzZUxlYXZlLFxuICAgICAgICAgICAgICAgIG9uRmlsdGVyLFxuICAgICAgICAgICAgICAgIGdldFJvd1Byb3BzLFxuICAgICAgICAgICAgICAgIGdldENlbGxQcm9wcyxcbiAgICAgICAgICAgICAgICBwcmltYXJ5S2V5LFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgd3JhcHBlckNvbnRlbnQsXG4gICAgICAgICAgICAgICAgbG9ja1R5cGUsXG4gICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHJlZnMsXG4gICAgICAgICAgICAgICAgcHVyZSxcbiAgICAgICAgICAgICAgICBydGwsXG4gICAgICAgICAgICAgICAgZW1wdHlDb250ZW50LFxuICAgICAgICAgICAgICAgIGZpbHRlclBhcmFtcyxcbiAgICAgICAgICAgICAgICBsb2FkaW5nQ29tcG9uZW50OiBMb2FkaW5nQ29tcG9uZW50ID0gTG9hZGluZyxcbiAgICAgICAgICAgICAgICAuLi5vdGhlcnNcbiAgICAgICAgICAgIH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgY2xzID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICAgICAgW2Ake3ByZWZpeH10YWJsZWBdOiB0cnVlLFxuICAgICAgICAgICAgICAgICdvbmx5LWJvdHRvbS1ib3JkZXInOiAhaGFzQm9yZGVyLFxuICAgICAgICAgICAgICAgICduby1oZWFkZXInOiAhaGFzSGVhZGVyLFxuICAgICAgICAgICAgICAgIHplYnJhOiBpc1plYnJhLFxuICAgICAgICAgICAgICAgIFtjbGFzc05hbWVdOiBjbGFzc05hbWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChydGwpIHtcbiAgICAgICAgICAgIG90aGVycy5kaXIgPSAncnRsJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZW50ID0gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nsc30gey4uLm90aGVyc30+XG4gICAgICAgICAgICAgICAge3RhYmxlfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgICAgIGlmIChsb2FkaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBsb2FkaW5nQ2xhc3NOYW1lID0gYCR7cHJlZml4fXRhYmxlLWxvYWRpbmdgO1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8TG9hZGluZ0NvbXBvbmVudCBjbGFzc05hbWU9e2xvYWRpbmdDbGFzc05hbWV9PlxuICAgICAgICAgICAgICAgICAgICB7Y29udGVudH1cbiAgICAgICAgICAgICAgICA8L0xvYWRpbmdDb21wb25lbnQ+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9iYXNlLmpzeCIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUVudHJ5RXF1YWwoYSwgYikge1xuICBmb3IgKHZhciBrIGluIGEpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhLCBrKSkge1xuICAgICAgcmV0dXJuIGFba10gPT09IGJba107XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtRXF1YWwoYSwgYikge1xuICBpZiAoKCFhICYmICFiKSB8fCAoYSA9PT0gYikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIWEgIT09ICFiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCF0cmFuc2Zvcm1FbnRyeUVxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzaGFsbG93T2JqZWN0RXF1YWxzKGEsIGIpIHtcbiAgdmFyIGs7XG4gIHZhciBpID0gMDtcbiAgdmFyIGogPSAwO1xuICBmb3IgKGsgaW4gYSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGspKSB7XG4gICAgICBzd2l0Y2ggKGspIHtcbiAgICAgICAgY2FzZSAndHJhbnNmb3JtJzpcbiAgICAgICAgICBpZiAoIXRyYW5zZm9ybUVxdWFsKGFba10sIGJba10pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzaGFkb3dPZmZzZXQnOlxuICAgICAgICAgIGlmICghc2hhbGxvd09iamVjdEVxdWFscyhhW2tdLCBiW2tdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoYVtrXSAhPT0gYltrXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gIH1cbiAgZm9yIChrIGluIGIpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChiLCBrKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaSA9PT0gajtcbn1cblxuZnVuY3Rpb24gc3R5bGVFcXVhbChhLCBiKSB7XG4gIGlmICgoIWEgJiYgIWIpIHx8IChhID09PSBiKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghYSAhPT0gIWIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YgYSkge1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghc3R5bGVFcXVhbChhW2ldLCBiW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNoYWxsb3dPYmplY3RFcXVhbHMoYSwgYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWxlRXF1YWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX3N0eWxlLWVxdWFsQDEuMC4wQHN0eWxlLWVxdWFsL2luZGV4LmpzIiwiY29uc3Qgb3ZlcmxheU1hbmFnZXIgPSB7XG4gICAgYWxsT3ZlcmxheXM6IFtdLFxuXG4gICAgYWRkT3ZlcmxheShvdmVybGF5KSB7XG4gICAgICAgIHRoaXMucmVtb3ZlT3ZlcmxheShvdmVybGF5KTtcbiAgICAgICAgdGhpcy5hbGxPdmVybGF5cy51bnNoaWZ0KG92ZXJsYXkpO1xuICAgIH0sXG5cbiAgICBpc0N1cnJlbnRPdmVybGF5KG92ZXJsYXkpIHtcbiAgICAgICAgcmV0dXJuIG92ZXJsYXkgJiYgdGhpcy5hbGxPdmVybGF5c1swXSA9PT0gb3ZlcmxheTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlT3ZlcmxheShvdmVybGF5KSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLmFsbE92ZXJsYXlzLmluZGV4T2Yob3ZlcmxheSk7XG4gICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYWxsT3ZlcmxheXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgb3ZlcmxheU1hbmFnZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvb3ZlcmxheS9tYW5hZ2VyLmpzIiwiaW1wb3J0IHtkb219IGZyb20gJy4uLy4uL3V0aWwnO1xuXG5jb25zdCBWSUVXUE9SVCA9ICd2aWV3cG9ydCc7XG5cbi8vIElFOCBub3Qgc3VwcG9ydCBwYWdlWE9mZnNldFxuY29uc3QgZ2V0UGFnZVggPSAoKSA9PiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQ7XG5jb25zdCBnZXRQYWdlWSA9ICgpID0+IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuXG4vKipcbiAqIEBwcml2YXRlIGdldCBlbGVtZW50IHJlY3RcbiAqIEBwYXJhbSAgICAgICB7RWxlbWVudH0gZWxlbVxuICogQHJldHVybiAgICAgIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIF9nZXRFbGVtZW50UmVjdCAoZWxlbSkge1xuICAgIGxldCBvZmZzZXRUb3AgPSAwLFxuICAgICAgICBvZmZzZXRMZWZ0ID0gMDtcblxuICAgIGNvbnN0IG9mZnNldEhlaWdodCA9IGVsZW0ub2Zmc2V0SGVpZ2h0O1xuICAgIGNvbnN0IG9mZnNldFdpZHRoID0gZWxlbS5vZmZzZXRXaWR0aDtcblxuICAgIGRvIHtcbiAgICAgICAgaWYgKCFpc05hTihlbGVtLm9mZnNldFRvcCkpIHtcbiAgICAgICAgICAgIG9mZnNldFRvcCArPSBlbGVtLm9mZnNldFRvcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTmFOKGVsZW0ub2Zmc2V0TGVmdCkpIHtcbiAgICAgICAgICAgIG9mZnNldExlZnQgKz0gZWxlbS5vZmZzZXRMZWZ0O1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoKGVsZW0gPSBlbGVtLm9mZnNldFBhcmVudCkgIT09IG51bGwpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBvZmZzZXRUb3AgLSAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCksXG4gICAgICAgIGxlZnQ6IG9mZnNldExlZnQgLSAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0KSxcbiAgICAgICAgaGVpZ2h0OiBvZmZzZXRIZWlnaHQsXG4gICAgICAgIHdpZHRoOiBvZmZzZXRXaWR0aFxuICAgIH07XG59XG5cbi8qKlxuICogQHByaXZhdGUgZ2V0IHZpZXdwb3J0IHNpemVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gX2dldFZpZXdwb3J0U2l6ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICB9O1xufVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9zaXRpb24ge1xuXG4gICAgc3RhdGljIFZJRVdQT1JUID0gVklFV1BPUlQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHVibGljIHN0YXRpYyBwbGFjZSBtZXRob2RcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgIHByb3BzXG4gICAgICogICAgIEBwYXJhbSAge0RPTX0gICAgICBwcm9wcy5waW5FbGVtZW50XG4gICAgICogICAgIEBwYXJhbSAge0RPTX0gICAgICBwcm9wcy5iYXNlRWxlbWVudFxuICAgICAqICAgICBAcGFyYW0gIHtTdHJpbmd9ICAgcHJvcHMuYWxpZ25cbiAgICAgKiAgICAgQHBhcmFtICB7TnVtYmVyfSAgIHByb3BzLm9mZnNldFxuICAgICAqICAgICBAcGFyYW0gIHtCb29sZWFufSAgcHJvcHMubmVlZEFkanVzdFxuICAgICAqICAgICBAcGFyYW0gIHtCb29sZWFufSAgcHJvcHMuaXNSdGxcbiAgICAgKiBAcmV0dXJuIHtQb3NpdGlvbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgcGxhY2UgPSBwcm9wcyA9PiBuZXcgUG9zaXRpb24ocHJvcHMpLnNldFBvc2l0aW9uKCk7XG5cblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHRoaXMucGluRWxlbWVudCA9IHByb3BzLnBpbkVsZW1lbnQ7XG4gICAgICAgIHRoaXMuYmFzZUVsZW1lbnQgPSBwcm9wcy5iYXNlRWxlbWVudDtcbiAgICAgICAgdGhpcy5hbGlnbiA9IHByb3BzLmFsaWduIHx8ICd0bCB0bCc7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gcHJvcHMub2Zmc2V0IHx8IFswLCAwXTtcbiAgICAgICAgdGhpcy5uZWVkQWRqdXN0ID0gcHJvcHMubmVlZEFkanVzdCB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1J0bCA9IHByb3BzLmlzUnRsIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIHNldFBvc2l0aW9uKCkge1xuICAgICAgICBjb25zdCBwaW5FbGVtZW50ID0gdGhpcy5waW5FbGVtZW50O1xuICAgICAgICBjb25zdCBiYXNlRWxlbWVudCA9IHRoaXMuYmFzZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkQWxpZ24gPSB0aGlzLl9nZXRFeHBlY3RlZEFsaWduKCk7XG4gICAgICAgIGxldCBpc1BpbkZpeGVkLCBpc0Jhc2VGaXhlZCwgZmlyc3RQb3NpdGlvblJlc3VsdDtcbiAgICAgICAgaWYgKHBpbkVsZW1lbnQgPT09IFZJRVdQT1JUKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbS5nZXRTdHlsZShwaW5FbGVtZW50LCAncG9zaXRpb24nKSAhPT0gJ2ZpeGVkJykge1xuICAgICAgICAgICAgZG9tLnNldFN0eWxlKHBpbkVsZW1lbnQsICdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xuICAgICAgICAgICAgaXNQaW5GaXhlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNQaW5GaXhlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VFbGVtZW50ID09PSBWSUVXUE9SVCB8fCBkb20uZ2V0U3R5bGUoYmFzZUVsZW1lbnQsICdwb3NpdGlvbicpICE9PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICBpc0Jhc2VGaXhlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNCYXNlRml4ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIOagueaNruacn+acm+eahOWumuS9jVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cGVjdGVkQWxpZ24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFsaWduID0gZXhwZWN0ZWRBbGlnbltpXTtcbiAgICAgICAgICAgIGNvbnN0IHBpbkVsZW1lbnRQb2ludHMgPSB0aGlzLl9ub3JtYWxpemVQb3NpdGlvbihwaW5FbGVtZW50LCBhbGlnbi5zcGxpdCgnICcpWzBdLCBpc1BpbkZpeGVkKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VFbGVtZW50UG9pbnRzID0gdGhpcy5fbm9ybWFsaXplUG9zaXRpb24oYmFzZUVsZW1lbnQsIGFsaWduLnNwbGl0KCcgJylbMV0sIGlzUGluRml4ZWQpO1xuICAgICAgICAgICAgY29uc3QgcGluRWxlbWVudFBhcmVudE9mZnNldCA9IHRoaXMuX2dldFBhcmVudE9mZnNldChwaW5FbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VFbGVtZW50T2Zmc2V0ID0gKGlzUGluRml4ZWQgJiYgaXNCYXNlRml4ZWQpID8gdGhpcy5fZ2V0TGVmdFRvcChiYXNlRWxlbWVudCkgOiBiYXNlRWxlbWVudFBvaW50cy5vZmZzZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGJhc2VFbGVtZW50T2Zmc2V0LnRvcCArIGJhc2VFbGVtZW50UG9pbnRzLnkgLSBwaW5FbGVtZW50UGFyZW50T2Zmc2V0LnRvcCAtIHBpbkVsZW1lbnRQb2ludHMueTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBiYXNlRWxlbWVudE9mZnNldC5sZWZ0ICsgYmFzZUVsZW1lbnRQb2ludHMueCAtIHBpbkVsZW1lbnRQYXJlbnRPZmZzZXQubGVmdCAgLSBwaW5FbGVtZW50UG9pbnRzLng7XG4gICAgICAgICAgICB0aGlzLl9zZXRQaW5FbGVtZW50UG9zdGlvbihwaW5FbGVtZW50LCB7bGVmdCwgdG9wfSwgdGhpcy5vZmZzZXQpO1xuXG4gICAgICAgICAgICBpZiAoIWZpcnN0UG9zaXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBmaXJzdFBvc2l0aW9uUmVzdWx0ID0ge2xlZnQsIHRvcH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faXNJblZpZXdwb3J0KHBpbkVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW5WaWV3cG9ydExlZnQgPSB0aGlzLl9tYWtlRWxlbWVudEluVmlld3BvcnQocGluRWxlbWVudCwgZmlyc3RQb3NpdGlvblJlc3VsdC5sZWZ0LCAnTGVmdCcsIGlzUGluRml4ZWQpO1xuICAgICAgICBjb25zdCBpblZpZXdwb3J0VG9wID0gdGhpcy5fbWFrZUVsZW1lbnRJblZpZXdwb3J0KHBpbkVsZW1lbnQsIGZpcnN0UG9zaXRpb25SZXN1bHQudG9wLCAnVG9wJywgaXNQaW5GaXhlZCk7XG5cbiAgICAgICAgdGhpcy5fc2V0UGluRWxlbWVudFBvc3Rpb24ocGluRWxlbWVudCwge2xlZnQ6IGluVmlld3BvcnRMZWZ0LCB0b3A6IGluVmlld3BvcnRUb3B9KTtcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkQWxpZ25bMF07XG4gICAgfVxuXG4gICAgX2dldFBhcmVudE9mZnNldChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgbGV0IG9mZnNldDtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gZG9jdW1lbnQuYm9keSAmJiBkb20uZ2V0U3R5bGUocGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHtcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX2dldEVsZW1lbnRPZmZzZXQocGFyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldC50b3AgKz0gcGFyc2VGbG9hdChkb20uZ2V0U3R5bGUocGFyZW50LCAnYm9yZGVyLXRvcC13aWR0aCcpLCAxMCk7XG4gICAgICAgIG9mZnNldC5sZWZ0ICs9IHBhcnNlRmxvYXQoZG9tLmdldFN0eWxlKHBhcmVudCwgJ2JvcmRlci1sZWZ0LXdpZHRoJyksIDEwKTtcbiAgICAgICAgb2Zmc2V0Lm9mZnNldFBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBfbWFrZUVsZW1lbnRJblZpZXdwb3J0KHBpbkVsZW1lbnQsIG51bWJlciwgdHlwZSwgaXNQaW5GaXhlZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbnVtYmVyO1xuICAgICAgICBjb25zdCBkb2NFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBjb25zdCBvZmZzZXRQYXJlbnQgPSBwaW5FbGVtZW50Lm9mZnNldFBhcmVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA8IDApIHtcbiAgICAgICAgICAgIGlmIChpc1BpbkZpeGVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0UGFyZW50ID09PSBkb2N1bWVudC5ib2R5ICYmIGRvbS5nZXRTdHlsZShvZmZzZXRQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgd2hlbiBkaXYncyBvZmZzZXRQYXJlbnQgaXMgZG9jdW1lbnQuYm9keSwgd2Ugc2V0IG5ldyBwb3NpdGlvbiByZXN1bHQuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gTWF0aC5tYXgoZG9jRWxlbWVudFtgc2Nyb2xsJHt0eXBlfWBdLCBkb2N1bWVudC5ib2R5W2BzY3JvbGwke3R5cGV9YF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBfbm9ybWFsaXplUG9zaXRpb24oZWxlbWVudCwgYWxpZ24sIGlzUGluRml4ZWQpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5fbm9ybWFsaXplRWxlbWVudChlbGVtZW50LCBpc1BpbkZpeGVkKTtcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplWFkocG9pbnRzLCBhbGlnbik7XG5cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG5cbiAgICBfbm9ybWFsaXplWFkocG9pbnRzLCBhbGlnbikge1xuICAgICAgICBjb25zdCB4ID0gYWxpZ24uc3BsaXQoJycpWzFdO1xuICAgICAgICBjb25zdCB5ID0gYWxpZ24uc3BsaXQoJycpWzBdO1xuXG4gICAgICAgIHBvaW50cy54ID0gdGhpcy5feHlDb252ZXJ0ZXIoeCwgcG9pbnRzLCAnd2lkdGgnKTtcbiAgICAgICAgcG9pbnRzLnkgPSB0aGlzLl94eUNvbnZlcnRlcih5LCBwb2ludHMsICdoZWlnaHQnKTtcblxuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cblxuICAgIF94eUNvbnZlcnRlcihhbGlnbiwgcG9pbnRzLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGFsaWduLnJlcGxhY2UoL3R8bC9naSwgJzAlJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9jL2dpLCAnNTAlJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9ifHIvZ2ksICcxMDAlJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oXFxkKyklL2dpLCBmdW5jdGlvbihtLCBkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5zaXplKClbdHlwZV0gKiAoZCAvIDEwMCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChyZXMsIDEwKSB8fCAwO1xuICAgIH1cblxuICAgIF9nZXRMZWZ0VG9wKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IHBhcnNlRmxvYXQoZG9tLmdldFN0eWxlKGVsZW1lbnQsICdsZWZ0JykpIHx8IDAsXG4gICAgICAgICAgICB0b3A6IHBhcnNlRmxvYXQoZG9tLmdldFN0eWxlKGVsZW1lbnQsICd0b3AnKSkgfHwgMFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9ub3JtYWxpemVFbGVtZW50KGVsZW1lbnQsIGlzUGluRml4ZWQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9LCBpc1ZpZXdwb3J0ID0gKGVsZW1lbnQgPT09IFZJRVdQT1JUKSwgZG9jRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICByZXN1bHQub2Zmc2V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzUGluRml4ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1ZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZ2V0UGFnZVgoKSxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBnZXRQYWdlWSgpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEVsZW1lbnRPZmZzZXQoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVzdWx0LnNpemUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNWaWV3cG9ydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBkb2NFbGVtZW50LmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGRvY0VsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgX2dldEVsZW1lbnRPZmZzZXQoZWxlbWVudCkge1xuICAgICAgICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgZG9jRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgY29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIGNvbnN0IGRvY0NsaWVudExlZnQgPSAoZG9jRWxlbWVudC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwKTtcbiAgICAgICAgY29uc3QgZG9jQ2xpZW50VG9wID0gKGRvY0VsZW1lbnQuY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDApO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyAoZ2V0UGFnZVgoKSAtIGRvY0NsaWVudExlZnQpLFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCArIChnZXRQYWdlWSgpIC0gZG9jQ2xpZW50VG9wKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEFjY29yZGluZyB0byB0aGUgbG9jYXRpb24gb2YgdGhlIG92ZXJmbG93IHRvIGNhbGN1bGF0ZSB0aGUgZGVzaXJlZCBwb3NpdGlvbmluZ1xuICAgIF9nZXRFeHBlY3RlZEFsaWduKCkge1xuICAgICAgICBjb25zdCBhbGlnbiA9IHRoaXMuaXNSdGwgPyB0aGlzLl9yZXBsYWNlQWxpZ25EaXIodGhpcy5hbGlnbiwgL2x8ci9nLCB7bDogJ3InLCByOiAnbCd9KSA6IHRoaXMuYWxpZ247XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkQWxpZ24gPSBbYWxpZ25dO1xuXG4gICAgICAgIGlmICh0aGlzLm5lZWRBZGp1c3QpIHtcbiAgICAgICAgICAgIGlmICgvdHxiL2cudGVzdChhbGlnbikpIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZEFsaWduLnB1c2godGhpcy5fcmVwbGFjZUFsaWduRGlyKGFsaWduLCAvdHxiL2csIHt0OiAnYicsIGI6ICd0J30pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgvbHxyL2cudGVzdChhbGlnbikpIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZEFsaWduLnB1c2godGhpcy5fcmVwbGFjZUFsaWduRGlyKGFsaWduLCAvbHxyL2csIHtsOiAncicsIHI6ICdsJ30pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgvYy9nLnRlc3QoYWxpZ24pKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRBbGlnbi5wdXNoKHRoaXMuX3JlcGxhY2VBbGlnbkRpcihhbGlnbiwgL2MoPz0gfCQpL2csIHtjOiAnbCd9KSk7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRBbGlnbi5wdXNoKHRoaXMuX3JlcGxhY2VBbGlnbkRpcihhbGlnbiwgL2MoPz0gfCQpL2csIHtjOiAncid9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBlY3RlZEFsaWduLnB1c2godGhpcy5fcmVwbGFjZUFsaWduRGlyKGFsaWduLCAvbHxyfHR8Yi9nLCB7bDogJ3InLCByOiAnbCcsIHQ6ICdiJywgYjogJ3QnfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBlY3RlZEFsaWduO1xuICAgIH1cblxuICAgIC8vIFRyYW5zZm9ybSBhbGlnbiBvcmRlci5cbiAgICBfcmVwbGFjZUFsaWduRGlyKGFsaWduLCByZWdFeHAsIG1hcCkge1xuICAgICAgICByZXR1cm4gYWxpZ24ucmVwbGFjZShyZWdFeHAsIHJlcyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWFwW3Jlc107XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERldGVjdGluZyBlbGVtZW50IGlzIGluIHRoZSB3aW5kb3fvvIwgd2Ugd2FudCB0byBhZGp1c3QgcG9zaXRpb24gbGF0ZXIuXG4gICAgX2lzSW5WaWV3cG9ydChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0U2l6ZSA9IF9nZXRWaWV3cG9ydFNpemUoKTtcbiAgICAgICAgLy8gQXZvaWQgYW5pbWF0ZSBwcm9ibGVtIHRoYXQgdXNlIG9mZnNldFdpZHRoIGluc3RlYWQgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0LlxuICAgICAgICBjb25zdCBlbGVtZW50UmVjdCA9IF9nZXRFbGVtZW50UmVjdChlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIChlbGVtZW50UmVjdC5sZWZ0ID49IDAgJiYgZWxlbWVudFJlY3QubGVmdCArIGVsZW1lbnQub2Zmc2V0V2lkdGggPD0gdmlld3BvcnRTaXplLndpZHRoICYmXG4gICAgICAgICAgICBlbGVtZW50UmVjdC50b3AgPj0gMCAmJiBlbGVtZW50UmVjdC50b3AgKyBlbGVtZW50Lm9mZnNldEhlaWdodCA8PSB2aWV3cG9ydFNpemUuaGVpZ2h0KTtcbiAgICB9XG4gICAgLy8g5Zyo6L+Z6YeM5YGaUlRM5Yik5patIHRvcC1sZWZ0IOWumuS9jei9rOWMluS4uuetieaViOeahCB0b3AtcmlnaHTlrprkvY1cbiAgICBfc2V0UGluRWxlbWVudFBvc3Rpb24ocGluRWxlbWVudCwgcG9zdGlvbiwgb2Zmc2V0ID0gWzAsIDBdKSB7XG4gICAgICAgIGNvbnN0IHt0b3AsIGxlZnR9ID0gcG9zdGlvbjtcbiAgICAgICAgaWYgKCF0aGlzLmlzUnRsKSB7XG4gICAgICAgICAgICBkb20uc2V0U3R5bGUocGluRWxlbWVudCwge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGAke2xlZnQgKyBvZmZzZXRbMF19cHhgLFxuICAgICAgICAgICAgICAgIHRvcDogYCR7dG9wICsgb2Zmc2V0WzFdfXB4YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJhbnNmZXIge2xlZnQsdG9wfSBlcXVhbHkgdG8ge3JpZ2h0LHRvcH1cbiAgICAgICAgY29uc3QgcGluRWxlbWVudFBhcmVudE9mZnNldCA9IHRoaXMuX2dldFBhcmVudE9mZnNldChwaW5FbGVtZW50KTtcbiAgICAgICAgY29uc3Qge3dpZHRoOiBvZmZzZXRQYXJlbnRXaWR0aH0gPSAgX2dldEVsZW1lbnRSZWN0KHBpbkVsZW1lbnRQYXJlbnRPZmZzZXQub2Zmc2V0UGFyZW50KTtcbiAgICAgICAgY29uc3Qge3dpZHRofSA9IF9nZXRFbGVtZW50UmVjdChwaW5FbGVtZW50KTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBvZmZzZXRQYXJlbnRXaWR0aCAtIChsZWZ0ICsgd2lkdGgpO1xuICAgICAgICBkb20uc2V0U3R5bGUocGluRWxlbWVudCwge1xuICAgICAgICAgICAgbGVmdDogJ2F1dG8nLFxuICAgICAgICAgICAgcmlnaHQ6IGAke3JpZ2h0ICsgb2Zmc2V0WzBdfXB4YCxcbiAgICAgICAgICAgIHRvcDogYCR7dG9wICsgb2Zmc2V0WzFdfXB4YCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL292ZXJsYXkvdXRpbHMvcG9zaXRpb24uanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBmdW5jLCBLRVlDT0RFIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgT3ZlcmxheSBmcm9tICcuL292ZXJsYXknO1xuXG5jb25zdCB7IG5vb3AsIG1ha2VDaGFpbiwgYmluZEN0eCB9ID0gZnVuYztcblxuLyoqXG4gKiBPdmVybGF5LlBvcHVwXG4gKiBAZGVzY3JpcHRpb24g57un5om/IE92ZXJsYXkg55qEIEFQSe+8jOmZpOmdnueJueWIq+ivtOaYjlxuICogKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvcHVwIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5YaF5a65XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDop6blj5HlvLnlsYLmmL7npLrmiJbpmpDol4/nmoTlhYPntKBcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXI6IFByb3BUeXBlcy5lbGVtZW50LFxuICAgICAgICAvKipcbiAgICAgICAgICog6Kem5Y+R5by55bGC5pi+56S65oiW6ZqQ6JeP55qE5pON5L2c57G75Z6L77yM5Y+v5Lul5pivICdjbGljayfvvIwnaG92ZXIn77yMJ2ZvY3VzJ++8jOaIluiAheWug+S7rOe7hOaIkOeahOaVsOe7hO+8jOWmgiBbJ2hvdmVyJywgJ2ZvY3VzJ11cbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXJUeXBlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYXJyYXldKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguW9k+WJjeaYr+WQpuaYvuekulxuICAgICAgICAgKi9cbiAgICAgICAgdmlzaWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLpu5jorqTmmK/lkKbmmL7npLpcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRWaXNpYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguaYvuekuuaIlumakOiXj+aXtuinpuWPkeeahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGUg5by55bGC5piv5ZCm5pi+56S6XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOinpuWPkeW8ueWxguaYvuekuuaIlumakOiXj+eahOadpea6kFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZSBET03kuovku7ZcbiAgICAgICAgICovXG4gICAgICAgIG9uVmlzaWJsZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7mraTlsZ7mgKfvvIzlvLnlsYLml6Dms5XmmL7npLrmiJbpmpDol49cbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguaYvuekuuaIlumakOiXj+eahOW7tuaXtuaXtumXtO+8iOS7peavq+enkuS4uuWNleS9je+8ie+8jOWcqCB0cmlnZ2VyVHlwZSDooqvorr7nva7kuLogaG92ZXIg5pe255Sf5pWIXG4gICAgICAgICAqL1xuICAgICAgICBkZWxheTogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOinpuWPkeWFg+e0oOaYr+WQpuWPr+S7peWFs+mXreW8ueWxglxuICAgICAgICAgKi9cbiAgICAgICAgY2FuQ2xvc2VCeVRyaWdnZXI6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5a6a5L2N55qE5Y+C54Wn5YWD57SgXG4gICAgICAgICAqIEBkZWZhdWx0IHRhcmdldCDlsZ7mgKfvvIzljbPop6blj5HlhYPntKBcbiAgICAgICAgICovXG4gICAgICAgIHRhcmdldDogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgc2FmZU5vZGU6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbot5/pmo90cmlnZ2Vy5rua5YqoXG4gICAgICAgICAqL1xuICAgICAgICBmb2xsb3dUcmlnZ2VyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgY29udGFpbmVyOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBoYXNNYXNrOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgd3JhcHBlclN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBydGw6IFByb3BUeXBlcy5ib29sLFxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICB0cmlnZ2VyVHlwZTogJ2hvdmVyJyxcbiAgICAgICAgZGVmYXVsdFZpc2libGU6IGZhbHNlLFxuICAgICAgICBvblZpc2libGVDaGFuZ2U6IG5vb3AsXG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgZGVsYXk6IDIwMCxcbiAgICAgICAgY2FuQ2xvc2VCeVRyaWdnZXI6IHRydWUsXG4gICAgICAgIGZvbGxvd1RyaWdnZXI6IGZhbHNlLFxuICAgICAgICBjb250YWluZXI6ICgpID0+IGRvY3VtZW50LmJvZHksXG4gICAgICAgIHJ0bDogZmFsc2UsXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdmlzaWJsZTogdHlwZW9mIHByb3BzLnZpc2libGUgPT09ICd1bmRlZmluZWQnID8gcHJvcHMuZGVmYXVsdFZpc2libGUgOiBwcm9wcy52aXNpYmxlXG4gICAgICAgIH07XG5cbiAgICAgICAgYmluZEN0eCh0aGlzLCBbXG4gICAgICAgICAgICAnaGFuZGxlVHJpZ2dlckNsaWNrJywgJ2hhbmRsZVRyaWdnZXJLZXlEb3duJyxcbiAgICAgICAgICAgICdoYW5kbGVUcmlnZ2VyTW91c2VFbnRlcicsICdoYW5kbGVUcmlnZ2VyTW91c2VMZWF2ZScsXG4gICAgICAgICAgICAnaGFuZGxlVHJpZ2dlckZvY3VzJywgJ2hhbmRsZVRyaWdnZXJCbHVyJyxcbiAgICAgICAgICAgICdoYW5kbGVDb250ZW50TW91c2VFbnRlcicsICdoYW5kbGVDb250ZW50TW91c2VMZWF2ZScsXG4gICAgICAgICAgICAnaGFuZGxlQ29udGVudE1vdXNlRG93bicsICdoYW5kbGVSZXF1ZXN0Q2xvc2UnLFxuICAgICAgICAgICAgJ2hhbmRsZU1hc2tNb3VzZUVudGVyJywgJ2hhbmRsZU1hc2tNb3VzZUxlYXZlJ1xuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBpZiAoJ3Zpc2libGUnIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgdmlzaWJsZTogbmV4dFByb3BzLnZpc2libGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIFsnX3RpbWVyJywgJ19oaWRlVGltZXInLCAnX3Nob3dUaW1lciddLmZvckVhY2godGltZSA9PiB7XG4gICAgICAgICAgICB0aGlzW3RpbWVdICYmIGNsZWFyVGltZW91dCh0aGlzW3RpbWVdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaGFuZGxlVmlzaWJsZUNoYW5nZSh2aXNpYmxlLCB0eXBlLCBlKSB7XG4gICAgICAgIGlmICghKCd2aXNpYmxlJyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgdmlzaWJsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3BzLm9uVmlzaWJsZUNoYW5nZSh2aXNpYmxlLCB0eXBlLCBlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVUcmlnZ2VyQ2xpY2soZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS52aXNpYmxlICYmICF0aGlzLnByb3BzLmNhbkNsb3NlQnlUcmlnZ2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhhbmRsZVZpc2libGVDaGFuZ2UoIXRoaXMuc3RhdGUudmlzaWJsZSwgJ2Zyb21UcmlnZ2VyJywgZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlVHJpZ2dlcktleURvd24oZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBLRVlDT0RFLlNQQUNFIHx8IGUua2V5Q29kZSA9PT0gS0VZQ09ERS5FTlRFUikge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmlnZ2VyQ2xpY2soZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVUcmlnZ2VyTW91c2VFbnRlcihlKSB7XG4gICAgICAgIHRoaXMuX21vdXNlTm90Rmlyc3RPbk1hc2sgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5faGlkZVRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5faGlkZVRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuX2hpZGVUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Nob3dUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Nob3dUaW1lcik7XG4gICAgICAgICAgICB0aGlzLl9zaG93VGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9zaG93VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVZpc2libGVDaGFuZ2UodHJ1ZSwgJ2Zyb21UcmlnZ2VyJywgZSk7XG4gICAgICAgICAgICB9LCB0aGlzLnByb3BzLmRlbGF5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVRyaWdnZXJNb3VzZUxlYXZlKGUsIHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Nob3dUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Nob3dUaW1lcik7XG4gICAgICAgICAgICB0aGlzLl9zaG93VGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVmlzaWJsZUNoYW5nZShmYWxzZSwgdHlwZSB8fCAnZnJvbVRyaWdnZXInLCBlKTtcbiAgICAgICAgICAgIH0sIHRoaXMucHJvcHMuZGVsYXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlVHJpZ2dlckZvY3VzKGUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVWaXNpYmxlQ2hhbmdlKHRydWUsICdmcm9tVHJpZ2dlcicsIGUpO1xuICAgIH1cblxuICAgIGhhbmRsZVRyaWdnZXJCbHVyKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0ZvcndhcmRDb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVZpc2libGVDaGFuZ2UoZmFsc2UsICdmcm9tVHJpZ2dlcicsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzRm9yd2FyZENvbnRlbnQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBoYW5kbGVDb250ZW50TW91c2VEb3duKCkge1xuICAgICAgICB0aGlzLl9pc0ZvcndhcmRDb250ZW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBoYW5kbGVDb250ZW50TW91c2VFbnRlcigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2hpZGVUaW1lcik7XG4gICAgfVxuXG4gICAgaGFuZGxlQ29udGVudE1vdXNlTGVhdmUoZSkge1xuICAgICAgICB0aGlzLmhhbmRsZVRyaWdnZXJNb3VzZUxlYXZlKGUsICdmcm9tQ29udGVudCcpO1xuICAgIH1cblxuICAgIGhhbmRsZU1hc2tNb3VzZUVudGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX21vdXNlTm90Rmlyc3RPbk1hc2spIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9oaWRlVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5faGlkZVRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX21vdXNlTm90Rmlyc3RPbk1hc2sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZU1hc2tNb3VzZUxlYXZlKCkge1xuICAgICAgICB0aGlzLl9tb3VzZU5vdEZpcnN0T25NYXNrID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBoYW5kbGVSZXF1ZXN0Q2xvc2UodHlwZSwgZSkge1xuICAgICAgICB0aGlzLmhhbmRsZVZpc2libGVDaGFuZ2UoZmFsc2UsIHR5cGUsIGUpO1xuICAgIH1cblxuICAgIHJlbmRlclRyaWdnZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgdHJpZ2dlciwgZGlzYWJsZWQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICAgICAga2V5OiAndHJpZ2dlcicsXG4gICAgICAgICAgICAnYXJpYS1oYXNwb3B1cCc6IHRydWUsXG4gICAgICAgICAgICAnYXJpYS1leHBhbmRlZCc6IHRoaXMuc3RhdGUudmlzaWJsZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJpZ2dlclR5cGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBjb25zdCB0cmlnZ2VyVHlwZXMgPSBBcnJheS5pc0FycmF5KHRyaWdnZXJUeXBlKSA/IHRyaWdnZXJUeXBlIDogW3RyaWdnZXJUeXBlXTtcbiAgICAgICAgICAgIGNvbnN0IHsgb25DbGljaywgb25LZXlEb3duLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSwgb25Gb2N1cywgb25CbHVyIH0gPSB0cmlnZ2VyLnByb3BzO1xuICAgICAgICAgICAgdHJpZ2dlclR5cGVzLmZvckVhY2godHJpZ2dlclR5cGUgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHJpZ2dlclR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xpY2snOlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMub25DbGljayA9IG1ha2VDaGFpbih0aGlzLmhhbmRsZVRyaWdnZXJDbGljaywgb25DbGljayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5vbktleURvd24gPSBtYWtlQ2hhaW4odGhpcy5oYW5kbGVUcmlnZ2VyS2V5RG93biwgb25LZXlEb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdob3ZlcicgOlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMub25Nb3VzZUVudGVyID0gbWFrZUNoYWluKHRoaXMuaGFuZGxlVHJpZ2dlck1vdXNlRW50ZXIsIG9uTW91c2VFbnRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5vbk1vdXNlTGVhdmUgPSBtYWtlQ2hhaW4odGhpcy5oYW5kbGVUcmlnZ2VyTW91c2VMZWF2ZSwgb25Nb3VzZUxlYXZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5vbkZvY3VzID0gbWFrZUNoYWluKHRoaXMuaGFuZGxlVHJpZ2dlckZvY3VzLCBvbkZvY3VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLm9uQmx1ciA9IG1ha2VDaGFpbih0aGlzLmhhbmRsZVRyaWdnZXJCbHVyLCBvbkJsdXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQodHJpZ2dlciwgcHJvcHMpO1xuICAgIH1cblxuICAgIHJlbmRlckNvbnRlbnQoKSB7XG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4sIHRyaWdnZXJUeXBlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB0cmlnZ2VyVHlwZXMgPSBBcnJheS5pc0FycmF5KHRyaWdnZXJUeXBlKSA/IHRyaWdnZXJUeXBlIDogW3RyaWdnZXJUeXBlXTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IENoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICAgICAgICBjb25zdCB7IG9uTW91c2VEb3duLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSB9ID0gY29udGVudC5wcm9wcztcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgICAgICBrZXk6ICdwb3J0YWwnXG4gICAgICAgIH07XG5cbiAgICAgICAgdHJpZ2dlclR5cGVzLmZvckVhY2godHJpZ2dlclR5cGUgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0cmlnZ2VyVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZvY3VzJzpcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMub25Nb3VzZURvd24gPSBtYWtlQ2hhaW4odGhpcy5oYW5kbGVDb250ZW50TW91c2VEb3duLCBvbk1vdXNlRG93bik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdmVyJzpcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMub25Nb3VzZUVudGVyID0gbWFrZUNoYWluKHRoaXMuaGFuZGxlQ29udGVudE1vdXNlRW50ZXIsIG9uTW91c2VFbnRlcik7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLm9uTW91c2VMZWF2ZSA9IG1ha2VDaGFpbih0aGlzLmhhbmRsZUNvbnRlbnRNb3VzZUxlYXZlLCBvbk1vdXNlTGVhdmUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjb250ZW50LCBwcm9wcyk7XG4gICAgfVxuXG4gICAgcmVuZGVyUG9ydGFsKCkge1xuICAgICAgICBjb25zdCB7IHRhcmdldCwgc2FmZU5vZGUsIGZvbGxvd1RyaWdnZXIsIHRyaWdnZXJUeXBlLCBoYXNNYXNrLCB3cmFwcGVyU3R5bGUsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHtjb250YWluZXJ9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgZmluZFRyaWdnZXJOb2RlID0gKCkgPT4gKGZpbmRET01Ob2RlKHRoaXMpIHx8IHt9KTtcbiAgICAgICAgY29uc3Qgc2FmZU5vZGVzID0gQXJyYXkuaXNBcnJheShzYWZlTm9kZSkgPyBbLi4uc2FmZU5vZGVdIDogW3NhZmVOb2RlXTtcbiAgICAgICAgc2FmZU5vZGVzLnVuc2hpZnQoZmluZFRyaWdnZXJOb2RlKTtcblxuICAgICAgICBjb25zdCBuZXdXcmFwcGVyU3R5bGUgPSB3cmFwcGVyU3R5bGUgfHwge307XG5cbiAgICAgICAgaWYgKGZvbGxvd1RyaWdnZXIpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHRyaWdnZXIgPT4gdHJpZ2dlci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgbmV3V3JhcHBlclN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmlnZ2VyVHlwZSA9PT0gJ2hvdmVyJyAmJiBoYXNNYXNrKSB7XG4gICAgICAgICAgICBvdGhlcnMub25NYXNrTW91c2VFbnRlciA9IHRoaXMuaGFuZGxlTWFza01vdXNlRW50ZXI7XG4gICAgICAgICAgICBvdGhlcnMub25NYXNrTW91c2VMZWF2ZSA9IHRoaXMuaGFuZGxlTWFza01vdXNlTGVhdmU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPE92ZXJsYXkgey4uLm90aGVyc31cbiAgICAgICAgICAgICAgICBrZXk9XCJvdmVybGF5XCJcbiAgICAgICAgICAgICAgICByZWY9e292ZXJsYXkgPT4gKHRoaXMub3ZlcmxheSA9IG92ZXJsYXkpfVxuICAgICAgICAgICAgICAgIHZpc2libGU9e3RoaXMuc3RhdGUudmlzaWJsZX1cbiAgICAgICAgICAgICAgICB0YXJnZXQ9e3RhcmdldCB8fCBmaW5kVHJpZ2dlck5vZGV9XG4gICAgICAgICAgICAgICAgY29udGFpbmVyPXtjb250YWluZXJ9XG4gICAgICAgICAgICAgICAgc2FmZU5vZGU9e3NhZmVOb2Rlc31cbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGU9e25ld1dyYXBwZXJTdHlsZX1cbiAgICAgICAgICAgICAgICB0cmlnZ2VyVHlwZT17dHJpZ2dlclR5cGV9XG4gICAgICAgICAgICAgICAgaGFzTWFzaz17aGFzTWFza31cbiAgICAgICAgICAgICAgICBvblJlcXVlc3RDbG9zZT17dGhpcy5oYW5kbGVSZXF1ZXN0Q2xvc2V9PlxuICAgICAgICAgICAgICAgIHt0aGlzLnJlbmRlckNvbnRlbnQoKX1cbiAgICAgICAgICAgIDwvT3ZlcmxheT5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLnJlbmRlclRyaWdnZXIoKSxcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUG9ydGFsKClcbiAgICAgICAgXTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvb3ZlcmxheS9wb3B1cC5qc3giLCJpbXBvcnQgUmVhY3QsIHtDb21wb25lbnQsIENoaWxkcmVufSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IE92ZXJsYXkgZnJvbSAnLi4vb3ZlcmxheSc7XG5pbXBvcnQgQ29uZmlnUHJvdmlkZXIgZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCB7ZnVuY30gZnJvbSAnLi4vdXRpbCc7XG5cbmNvbnN0IHtub29wLCBtYWtlQ2hhaW4sIGJpbmRDdHh9ID0gZnVuYztcbmNvbnN0IFBvcHVwID0gT3ZlcmxheS5Qb3B1cDtcblxuLyoqXG4gKiBEcm9wZG93blxuICogQGRlc2NyaXB0aW9uIOe7p+aJvyBQb3B1cCDnmoQgQVBJ77yM6Zmk6Z2e54m55Yir6K+05piOXG4gKi9cbmNsYXNzIERyb3Bkb3duIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHB1cmU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLlhoXlrrlcbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguW9k+WJjeaYr+WQpuaYvuekulxuICAgICAgICAgKi9cbiAgICAgICAgdmlzaWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLpu5jorqTmmK/lkKbmmL7npLpcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRWaXNpYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguaYvuekuuaIlumakOiXj+aXtuinpuWPkeeahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGUg5by55bGC5piv5ZCm5pi+56S6XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOinpuWPkeW8ueWxguaYvuekuuaIlumakOiXj+eahOadpea6kFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZSBET03kuovku7ZcbiAgICAgICAgICovXG4gICAgICAgIG9uVmlzaWJsZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDop6blj5HlvLnlsYLmmL7npLrmiJbogIXpmpDol4/nmoTlhYPntKBcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXI6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Kem5Y+R5by55bGC5pi+56S65oiW6ZqQ6JeP55qE5pON5L2c57G75Z6LXG4gICAgICAgICAqL1xuICAgICAgICB0cmlnZ2VyVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnaG92ZXInLCAnY2xpY2snLCAnZm9jdXMnXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7mraTlsZ7mgKfvvIzlvLnlsYLml6Dms5XmmL7npLrmiJbpmpDol49cbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguebuOWvueS6juinpuWPkeWFg+e0oOeahOWumuS9jSwg6K+m6KeBIE92ZXJsYXkg55qE5a6a5L2N6YOo5YiGXG4gICAgICAgICAqL1xuICAgICAgICBhbGlnbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguebuOWvueS6juinpuWPkeWFg+e0oOWumuS9jeeahOW+ruiwg1xuICAgICAgICAgKi9cbiAgICAgICAgb2Zmc2V0OiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLmmL7npLrmiJbpmpDol4/nmoTlu7bml7bml7bpl7TvvIjku6Xmr6vnp5LkuLrljZXkvY3vvInvvIzlnKggdHJpZ2dlclR5cGUg6KKr6K6+572u5Li6IGhvdmVyIOaXtueUn+aViFxuICAgICAgICAgKi9cbiAgICAgICAgZGVsYXk6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLmiZPlvIDml7bmmK/lkKborqnlhbbkuK3nmoTlhYPntKDoh6rliqjojrflj5bnhKbngrlcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Gb2N1czogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbmmL7npLrpga7nvalcbiAgICAgICAgICovXG4gICAgICAgIGhhc01hc2s6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6ZqQ6JeP5pe25piv5ZCm5L+d55WZ5a2Q6IqC54K5XG4gICAgICAgICAqL1xuICAgICAgICBjYWNoZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDphY3nva7liqjnlLvnmoTmkq3mlL7mlrnlvI/vvIzmlK/mjIEgeyBpbjogJ2VudGVyLWNsYXNzJywgb3V0OiAnbGVhdmUtY2xhc3MnIH0g55qE5a+56LGh5Y+C5pWw77yM5aaC5p6c6K6+572u5Li6IGZhbHNl77yM5YiZ5LiN5pKt5pS+5Yqo55S7XG4gICAgICAgICAqIEBkZWZhdWx0IHsgaW46ICdleHBhbmRJbkRvd24nLCBvdXQ6ICdleHBhbmRPdXRVcCcgfVxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0aW9uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuYm9vbF0pLFxuICAgIH07XG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgICAgICBwdXJlOiBmYWxzZSxcbiAgICAgICAgZGVmYXVsdFZpc2libGU6IGZhbHNlLFxuICAgICAgICBvblZpc2libGVDaGFuZ2U6IG5vb3AsXG4gICAgICAgIHRyaWdnZXJUeXBlOiAnaG92ZXInLFxuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIGFsaWduOiAndGwgYmwnLFxuICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgZGVsYXk6IDIwMCxcbiAgICAgICAgYXV0b0ZvY3VzOiB0cnVlLFxuICAgICAgICBoYXNNYXNrOiBmYWxzZSxcbiAgICAgICAgY2FjaGU6IGZhbHNlLFxuICAgICAgICBvblBvc2l0aW9uOiBub29wXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdmlzaWJsZTogJ3Zpc2libGUnIGluIHByb3BzID8gcHJvcHMudmlzaWJsZSA6IChwcm9wcy5kZWZhdWx0VmlzaWJsZSB8fCBmYWxzZSlcbiAgICAgICAgfTtcblxuICAgICAgICBiaW5kQ3R4KHRoaXMsIFtcbiAgICAgICAgICAgICdvbk1lbnVDbGljaycsXG4gICAgICAgICAgICAnb25WaXNpYmxlQ2hhbmdlJ1xuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICBnZXRWaXNpYmxlKHByb3BzID0gdGhpcy5wcm9wcykge1xuICAgICAgICByZXR1cm4gJ3Zpc2libGUnIGluIHByb3BzID8gcHJvcHMudmlzaWJsZSA6IHRoaXMuc3RhdGUudmlzaWJsZTtcbiAgICB9XG5cbiAgICBvbk1lbnVDbGljaygpIHtcbiAgICAgICAgdGhpcy5vblZpc2libGVDaGFuZ2UoZmFsc2UsICdmcm9tQ29udGVudCcpO1xuICAgIH1cblxuICAgIG9uVmlzaWJsZUNoYW5nZSh2aXNpYmxlLCBmcm9tKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe3Zpc2libGV9KTtcblxuICAgICAgICB0aGlzLnByb3BzLm9uVmlzaWJsZUNoYW5nZSh2aXNpYmxlLCBmcm9tKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IENoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiBjaGlsZC50eXBlLmlzTmV4dE1lbnUpIHtcbiAgICAgICAgICAgIGNoaWxkID0gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgICAgICAgICAgb25JdGVtQ2xpY2s6IG1ha2VDaGFpbih0aGlzLm9uTWVudUNsaWNrLCBjaGlsZC5wcm9wcy5vbkl0ZW1DbGljaylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxQb3B1cCB7Li4udGhpcy5wcm9wc31cbiAgICAgICAgICAgICAgICB2aXNpYmxlPXt0aGlzLmdldFZpc2libGUoKX1cbiAgICAgICAgICAgICAgICBvblZpc2libGVDaGFuZ2U9e3RoaXMub25WaXNpYmxlQ2hhbmdlfVxuICAgICAgICAgICAgICAgIGNhbkNsb3NlQnlPdXRTaWRlQ2xpY2s+e2NoaWxkfTwvUG9wdXA+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb25maWdQcm92aWRlci5jb25maWcoRHJvcGRvd24pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Ryb3Bkb3duL2luZGV4LmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIENoaWxkcmVuLCBjbG9uZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmaW5kRE9NTm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IEFuaW1hdGUgZnJvbSAnLi4vLi4vYW5pbWF0ZSc7XG5pbXBvcnQgSWNvbiBmcm9tICcuLi8uLi9pY29uJztcbmltcG9ydCB7IGZ1bmMsIG9iaiB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IEl0ZW0gZnJvbSAnLi9pdGVtJztcbmltcG9ydCBTZWxlY3RhYmVsSXRlbSBmcm9tICcuL3NlbGVjdGFibGUtaXRlbSc7XG5pbXBvcnQgUG9wdXBJdGVtIGZyb20gJy4vcG9wdXAtaXRlbSc7XG5cbmNvbnN0IHsgRXhwYW5kIH0gPSBBbmltYXRlO1xuY29uc3QgeyBiaW5kQ3R4IH0gPSBmdW5jO1xuXG4vKipcbiAqIE1lbnUuU3ViTWVudVxuICogQG9yZGVyIDFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ViTWVudSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIG1lbnVDaGlsZFR5cGUgPSAnc3VibWVudSc7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBfa2V5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICByb290OiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBsZXZlbDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgZ3JvdXBJbmRlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmoIfnrb7lhoXlrrlcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuWPr+mAie+8jOivpeWxnuaAp+S7heWcqOiuvue9riBNZW51IOe7hOS7tiBzZWxlY3RNb2RlIOWxnuaAp+WQjueUn+aViFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0YWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlrZDoj5zljZXmiZPlvIDmlrnlvI/vvIzlpoLmnpzorr7nva7kvJropobnm5YgTWVudSDkuIrnmoTlkIzlkI3lsZ7mgKdcbiAgICAgICAgICogQGRlZmF1bHQgTWVudSDnmoQgbW9kZSDlsZ7mgKflgLxcbiAgICAgICAgICovXG4gICAgICAgIG1vZGU6IFByb3BUeXBlcy5vbmVPZihbJ2lubGluZScsICdwb3B1cCddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiPnOWNlemhueaIluS4i+S4gOe6p+WtkOiPnOWNlVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICBvbk1vdXNlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBzdWJNZW51Q29udGVudENsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgdHJpZ2dlclR5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2NsaWNrJywgJ2hvdmVyJ10pLFxuICAgICAgICBhbGlnbjogUHJvcFR5cGVzLm9uZU9mKFsnb3V0c2lkZScsICdmb2xsb3cnXSksXG4gICAgICAgIHBhcmVudE1vZGU6IFByb3BUeXBlcy5vbmVPZihbJ2lubGluZScsICdwb3B1cCddKVxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBncm91cEluZGVudDogMCxcbiAgICAgICAgc2VsZWN0YWJsZTogZmFsc2VcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIGJpbmRDdHgodGhpcywgW1xuICAgICAgICAgICAgJ2hhbmRsZU1vdXNlRW50ZXInLCAnaGFuZGxlTW91c2VMZWF2ZScsICdoYW5kbGVDbGljaycsXG4gICAgICAgICAgICAnaGFuZGxlT3BlbicsICdhZnRlckxlYXZlJ1xuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5pdGVtTm9kZSA9IGZpbmRET01Ob2RlKHRoaXMpO1xuICAgIH1cblxuICAgIGFmdGVyTGVhdmUoKSB7XG4gICAgICAgIGNvbnN0IHsgZm9jdXNlZCwgcm9vdCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBmb2N1c2FibGUgfSA9IHJvb3QucHJvcHM7XG4gICAgICAgIGlmIChmb2N1c2FibGUgJiYgZm9jdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5pdGVtTm9kZS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0T3BlbigpIHtcbiAgICAgICAgY29uc3QgeyBfa2V5LCByb290IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IG9wZW5LZXlzIH0gPSByb290LnN0YXRlO1xuXG4gICAgICAgIHJldHVybiBvcGVuS2V5cy5pbmRleE9mKF9rZXkpID4gLTE7XG4gICAgfVxuXG4gICAgaGFuZGxlTW91c2VFbnRlcihlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlT3Blbih0cnVlKTtcblxuICAgICAgICB0aGlzLnByb3BzLm9uTW91c2VFbnRlciAmJiB0aGlzLnByb3BzLm9uTW91c2VFbnRlcihlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVNb3VzZUxlYXZlKGUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVPcGVuKGZhbHNlKTtcblxuICAgICAgICB0aGlzLnByb3BzLm9uTW91c2VMZWF2ZSAmJiB0aGlzLnByb3BzLm9uTW91c2VMZWF2ZShlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDbGljayhlKSB7XG4gICAgICAgIGNvbnN0IHsgcm9vdCwgc2VsZWN0YWJsZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBzZWxlY3RNb2RlIH0gPSByb290LnByb3BzO1xuICAgICAgICBpZiAoc2VsZWN0TW9kZSAmJiBzZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3BlbiA9IHRoaXMuZ2V0T3BlbigpO1xuICAgICAgICB0aGlzLmhhbmRsZU9wZW4oIW9wZW4pO1xuICAgIH1cblxuICAgIGhhbmRsZU9wZW4ob3BlbiwgdHJpZ2dlclR5cGUsIGUpIHtcbiAgICAgICAgY29uc3QgeyBfa2V5LCByb290IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByb290LmhhbmRsZU9wZW4oX2tleSwgb3BlbiwgdHJpZ2dlclR5cGUsIGUpO1xuICAgIH1cblxuICAgIHBhc3NQYXJlbnRUb0NoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IHsgbW9kZSwgcm9vdCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICByZXR1cm4gQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBjaGlsZCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgICAgICAgICAgIHBhcmVudE1vZGU6IG1vZGUgfHwgcm9vdC5wcm9wcy5tb2RlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVySW5saW5lKCkge1xuICAgICAgICBjb25zdCB7IF9rZXksIGxldmVsLCByb290LCBjbGFzc05hbWUsIHNlbGVjdGFibGU6IHNlbGVjdGFibGVGcm9tUHJvcHMsIGxhYmVsLCBjaGlsZHJlbiwgc3ViTWVudUNvbnRlbnRDbGFzc05hbWUsIHRyaWdnZXJUeXBlOiBwcm9wc1RyaWdnZXJUeXBlLCBwYXJlbnRNb2RlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgc2VsZWN0TW9kZSwgdHJpZ2dlclR5cGU6IHJvb3RUcmlnZ2VyVHlwZSwgaW5saW5lQXJyb3dEaXJlY3Rpb24sIGV4cGFuZEFuaW1hdGlvbiwgcnRsIH0gPSByb290LnByb3BzO1xuICAgICAgICBjb25zdCB0cmlnZ2VyVHlwZSA9IHByb3BzVHJpZ2dlclR5cGUgfHwgcm9vdFRyaWdnZXJUeXBlO1xuICAgICAgICBjb25zdCBvcGVuID0gdGhpcy5nZXRPcGVuKCk7XG4gICAgICAgIGNvbnN0IG90aGVycyA9IG9iai5waWNrT3RoZXJzKE9iamVjdC5rZXlzKFN1Yk1lbnUucHJvcFR5cGVzKSwgdGhpcy5wcm9wcyk7XG5cbiAgICAgICAgY29uc3QgbGlQcm9wcyA9IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY3goe1xuICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9bWVudS1zdWItbWVudS13cmFwcGVyYF06IHRydWUsXG4gICAgICAgICAgICAgICAgW2NsYXNzTmFtZV06ICEhY2xhc3NOYW1lXG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpdGVtUHJvcHMgPSB7XG4gICAgICAgICAgICAnYXJpYS1leHBhbmRlZCc6IG9wZW4sXG4gICAgICAgICAgICBfa2V5LFxuICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgdHlwZTogJ3N1Ym1lbnUnLFxuICAgICAgICAgICAgY29tcG9uZW50OiAnZGl2JyxcbiAgICAgICAgICAgIHBhcmVudE1vZGVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXJyb3JQcm9wcyA9IHtcbiAgICAgICAgICAgIHR5cGU6IGlubGluZUFycm93RGlyZWN0aW9uID09PSAncmlnaHQnID8gJ2Fycm93LXJpZ2h0JyA6ICdhcnJvdy1kb3duJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY3goe1xuICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9bWVudS1pY29uLWFycm93YF06IHRydWUsXG4gICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1tZW51LWljb24tYXJyb3ctZG93bmBdOiBpbmxpbmVBcnJvd0RpcmVjdGlvbiA9PT0gJ2Rvd24nLFxuICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9bWVudS1pY29uLWFycm93LXJpZ2h0YF06IGlubGluZUFycm93RGlyZWN0aW9uID09PSAncmlnaHQnLFxuICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9b3BlbmBdOiBvcGVuXG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHNlbGVjdGFibGUgPSAhIXNlbGVjdE1vZGUgJiYgc2VsZWN0YWJsZUZyb21Qcm9wcztcbiAgICAgICAgY29uc3QgTmV3SXRlbSA9IHNlbGVjdGFibGUgPyBTZWxlY3RhYmVsSXRlbSA6IEl0ZW07XG5cbiAgICAgICAgaWYgKHRyaWdnZXJUeXBlID09PSAnaG92ZXInKSB7XG4gICAgICAgICAgICBsaVByb3BzLm9uTW91c2VFbnRlciA9IHRoaXMuaGFuZGxlTW91c2VFbnRlcjtcbiAgICAgICAgICAgIGxpUHJvcHMub25Nb3VzZUxlYXZlID0gdGhpcy5oYW5kbGVNb3VzZUxlYXZlO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIGFycm9yUHJvcHMub25DbGljayA9IHRoaXMuaGFuZGxlQ2xpY2s7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtUHJvcHMub25DbGljayA9IHRoaXMuaGFuZGxlQ2xpY2s7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIGl0ZW1Qcm9wcy5jbGFzc05hbWUgPSBgJHtwcmVmaXh9b3BlbmVkYDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5ld1N1Yk1lbnVDb250ZW50Q2xhc3NOYW1lID0gY3goe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1tZW51LXN1Yi1tZW51YF06IHRydWUsXG4gICAgICAgICAgICBbc3ViTWVudUNvbnRlbnRDbGFzc05hbWVdOiAhIXN1Yk1lbnVDb250ZW50Q2xhc3NOYW1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHN1Yk1lbnUgPSBvcGVuID8gKFxuICAgICAgICAgICAgPHVsIHJvbGU9XCJtZW51XCIgZGlyPXtydGwgPyAncnRsJyA6IHVuZGVmaW5lZH0gcmVmPVwic3ViTWVudVwiIGNsYXNzTmFtZT17bmV3U3ViTWVudUNvbnRlbnRDbGFzc05hbWV9PlxuICAgICAgICAgICAgICAgIHt0aGlzLnBhc3NQYXJlbnRUb0NoaWxkcmVuKGNoaWxkcmVuKX1cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICkgOiBudWxsO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8bGkgey4uLm90aGVyc30gey4uLmxpUHJvcHN9PlxuICAgICAgICAgICAgICAgIDxOZXdJdGVtIHsuLi5pdGVtUHJvcHN9PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Ake3ByZWZpeH1tZW51LWl0ZW0tdGV4dGB9PntsYWJlbH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxJY29uIHsuLi5hcnJvclByb3BzfSAvPlxuICAgICAgICAgICAgICAgIDwvTmV3SXRlbT5cbiAgICAgICAgICAgICAgICB7ZXhwYW5kQW5pbWF0aW9uID8gKFxuICAgICAgICAgICAgICAgICAgICA8RXhwYW5kIGFuaW1hdGlvbkFwcGVhcj17ZmFsc2V9IGFmdGVyTGVhdmU9e3RoaXMuYWZ0ZXJMZWF2ZX0+XG4gICAgICAgICAgICAgICAgICAgICAgICB7c3ViTWVudX1cbiAgICAgICAgICAgICAgICAgICAgPC9FeHBhbmQ+XG4gICAgICAgICAgICAgICAgKSA6IHN1Yk1lbnV9XG5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyUG9wdXAoKSB7XG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4sIHN1Yk1lbnVDb250ZW50Q2xhc3NOYW1lLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLnByb3BzLnJvb3Q7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBwb3B1cENsYXNzTmFtZSwgcG9wdXBTdHlsZSwgcnRsIH0gPSByb290LnByb3BzO1xuXG4gICAgICAgIGNvbnN0IG5ld0NsYXNzTmFtZSA9IGN4KHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9bWVudWBdOiB0cnVlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH12ZXJgXTogdHJ1ZSxcbiAgICAgICAgICAgIFtwb3B1cENsYXNzTmFtZV06ICEhcG9wdXBDbGFzc05hbWUsXG4gICAgICAgICAgICBbc3ViTWVudUNvbnRlbnRDbGFzc05hbWVdOiAhIXN1Yk1lbnVDb250ZW50Q2xhc3NOYW1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG90aGVycy5ydGwgPSBydGw7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxQb3B1cEl0ZW0gey4uLm90aGVyc30gaGFzU3ViTWVudT5cbiAgICAgICAgICAgICAgICA8dWwgcm9sZT1cIm1lbnVcIiBkaXI9e3J0bCA/ICdydGwnIDogdW5kZWZpbmVkfSBjbGFzc05hbWU9e25ld0NsYXNzTmFtZX0gc3R5bGU9e3BvcHVwU3R5bGV9PlxuICAgICAgICAgICAgICAgICAgICB7dGhpcy5wYXNzUGFyZW50VG9DaGlsZHJlbihjaGlsZHJlbil9XG4gICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDwvUG9wdXBJdGVtPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBtb2RlLCByb290IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBuZXdNb2RlID0gbW9kZSB8fCByb290LnByb3BzLm1vZGU7XG5cbiAgICAgICAgcmV0dXJuIG5ld01vZGUgPT09ICdwb3B1cCcgP1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJQb3B1cCgpIDpcbiAgICAgICAgICAgIHRoaXMucmVuZGVySW5saW5lKCk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21lbnUvdmlldy9zdWItbWVudS5qc3giLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIFByb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcblxudmFyIF9hZGRDbGFzcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImRvbS1oZWxwZXJzL2NsYXNzL2FkZENsYXNzXCIpKTtcblxudmFyIF9yZW1vdmVDbGFzcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImRvbS1oZWxwZXJzL2NsYXNzL3JlbW92ZUNsYXNzXCIpKTtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcblxudmFyIF9UcmFuc2l0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9UcmFuc2l0aW9uXCIpKTtcblxudmFyIF9Qcm9wVHlwZXMgPSByZXF1aXJlKFwiLi91dGlscy9Qcm9wVHlwZXNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbnZhciBhZGRDbGFzcyA9IGZ1bmN0aW9uIGFkZENsYXNzKG5vZGUsIGNsYXNzZXMpIHtcbiAgcmV0dXJuIG5vZGUgJiYgY2xhc3NlcyAmJiBjbGFzc2VzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAoMCwgX2FkZENsYXNzLmRlZmF1bHQpKG5vZGUsIGMpO1xuICB9KTtcbn07XG5cbnZhciByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKG5vZGUsIGNsYXNzZXMpIHtcbiAgcmV0dXJuIG5vZGUgJiYgY2xhc3NlcyAmJiBjbGFzc2VzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAoMCwgX3JlbW92ZUNsYXNzLmRlZmF1bHQpKG5vZGUsIGMpO1xuICB9KTtcbn07XG5cbnZhciBwcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBfZXh0ZW5kcyh7fSwgX1RyYW5zaXRpb24uZGVmYXVsdC5wcm9wVHlwZXMsIHtcbiAgLyoqXG4gICAqIFRoZSBhbmltYXRpb24gY2xhc3NOYW1lcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQgYXMgaXQgZW50ZXJzLCBleGl0cyBvciBoYXMgZmluaXNoZWQgdGhlIHRyYW5zaXRpb24uXG4gICAqIEEgc2luZ2xlIG5hbWUgY2FuIGJlIHByb3ZpZGVkIGFuZCBpdCB3aWxsIGJlIHN1ZmZpeGVkIGZvciBlYWNoIHN0YWdlOiBlLmcuXG4gICAqXG4gICAqIGBjbGFzc05hbWVzPVwiZmFkZVwiYCBhcHBsaWVzIGBmYWRlLWVudGVyYCwgYGZhZGUtZW50ZXItYWN0aXZlYCwgYGZhZGUtZW50ZXItZG9uZWAsXG4gICAqIGBmYWRlLWV4aXRgLCBgZmFkZS1leGl0LWFjdGl2ZWAsIGBmYWRlLWV4aXQtZG9uZWAsIGBmYWRlLWFwcGVhcmAsIGFuZCBgZmFkZS1hcHBlYXItYWN0aXZlYC5cbiAgICogRWFjaCBpbmRpdmlkdWFsIGNsYXNzTmFtZXMgY2FuIGFsc28gYmUgc3BlY2lmaWVkIGluZGVwZW5kZW50bHkgbGlrZTpcbiAgICpcbiAgICogYGBganNcbiAgICogY2xhc3NOYW1lcz17e1xuICAgKiAgYXBwZWFyOiAnbXktYXBwZWFyJyxcbiAgICogIGFwcGVhckFjdGl2ZTogJ215LWFjdGl2ZS1hcHBlYXInLFxuICAgKiAgZW50ZXI6ICdteS1lbnRlcicsXG4gICAqICBlbnRlckFjdGl2ZTogJ215LWFjdGl2ZS1lbnRlcicsXG4gICAqICBlbnRlckRvbmU6ICdteS1kb25lLWVudGVyJyxcbiAgICogIGV4aXQ6ICdteS1leGl0JyxcbiAgICogIGV4aXRBY3RpdmU6ICdteS1hY3RpdmUtZXhpdCcsXG4gICAqICBleGl0RG9uZTogJ215LWRvbmUtZXhpdCcsXG4gICAqIH19XG4gICAqIGBgYFxuICAgKlxuICAgKiBJZiB5b3Ugd2FudCB0byBzZXQgdGhlc2UgY2xhc3NlcyB1c2luZyBDU1MgTW9kdWxlczpcbiAgICpcbiAgICogYGBganNcbiAgICogaW1wb3J0IHN0eWxlcyBmcm9tICcuL3N0eWxlcy5jc3MnO1xuICAgKiBgYGBcbiAgICpcbiAgICogeW91IG1pZ2h0IHdhbnQgdG8gdXNlIGNhbWVsQ2FzZSBpbiB5b3VyIENTUyBmaWxlLCB0aGF0IHdheSBjb3VsZCBzaW1wbHkgc3ByZWFkXG4gICAqIHRoZW0gaW5zdGVhZCBvZiBsaXN0aW5nIHRoZW0gb25lIGJ5IG9uZTpcbiAgICpcbiAgICogYGBganNcbiAgICogY2xhc3NOYW1lcz17eyAuLi5zdHlsZXMgfX1cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmcgfCB7XG4gICAqICBhcHBlYXI/OiBzdHJpbmcsXG4gICAqICBhcHBlYXJBY3RpdmU/OiBzdHJpbmcsXG4gICAqICBlbnRlcj86IHN0cmluZyxcbiAgICogIGVudGVyQWN0aXZlPzogc3RyaW5nLFxuICAgKiAgZW50ZXJEb25lPzogc3RyaW5nLFxuICAgKiAgZXhpdD86IHN0cmluZyxcbiAgICogIGV4aXRBY3RpdmU/OiBzdHJpbmcsXG4gICAqICBleGl0RG9uZT86IHN0cmluZyxcbiAgICogfX1cbiAgICovXG4gIGNsYXNzTmFtZXM6IF9Qcm9wVHlwZXMuY2xhc3NOYW1lc1NoYXBlLFxuXG4gIC8qKlxuICAgKiBBIGA8VHJhbnNpdGlvbj5gIGNhbGxiYWNrIGZpcmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSAnZW50ZXInIG9yICdhcHBlYXInIGNsYXNzIGlzXG4gICAqIGFwcGxpZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbClcbiAgICovXG4gIG9uRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBBIGA8VHJhbnNpdGlvbj5gIGNhbGxiYWNrIGZpcmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSAnZW50ZXItYWN0aXZlJyBvclxuICAgKiAnYXBwZWFyLWFjdGl2ZScgY2xhc3MgaXMgYXBwbGllZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKVxuICAgKi9cbiAgb25FbnRlcmluZzogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEEgYDxUcmFuc2l0aW9uPmAgY2FsbGJhY2sgZmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlICdlbnRlcicgb3JcbiAgICogJ2FwcGVhcicgY2xhc3NlcyBhcmUgKipyZW1vdmVkKiogYW5kIHRoZSBgZG9uZWAgY2xhc3MgaXMgYWRkZWQgdG8gdGhlIERPTSBub2RlLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpXG4gICAqL1xuICBvbkVudGVyZWQ6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBBIGA8VHJhbnNpdGlvbj5gIGNhbGxiYWNrIGZpcmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSAnZXhpdCcgY2xhc3MgaXNcbiAgICogYXBwbGllZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpXG4gICAqL1xuICBvbkV4aXQ6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBBIGA8VHJhbnNpdGlvbj5gIGNhbGxiYWNrIGZpcmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSAnZXhpdC1hY3RpdmUnIGlzIGFwcGxpZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KVxuICAgKi9cbiAgb25FeGl0aW5nOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQSBgPFRyYW5zaXRpb24+YCBjYWxsYmFjayBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgJ2V4aXQnIGNsYXNzZXNcbiAgICogYXJlICoqcmVtb3ZlZCoqIGFuZCB0aGUgYGV4aXQtZG9uZWAgY2xhc3MgaXMgYWRkZWQgdG8gdGhlIERPTSBub2RlLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudClcbiAgICovXG4gIG9uRXhpdGVkOiBQcm9wVHlwZXMuZnVuY1xufSkgOiB7fTs7XG4vKipcbiAqIEEgYFRyYW5zaXRpb25gIGNvbXBvbmVudCB1c2luZyBDU1MgdHJhbnNpdGlvbnMgYW5kIGFuaW1hdGlvbnMuXG4gKiBJdCdzIGluc3BpcmVkIGJ5IHRoZSBleGNlbGxlbnQgW25nLWFuaW1hdGVdKGh0dHA6Ly93d3cubmdhbmltYXRlLm9yZy8pIGxpYnJhcnkuXG4gKlxuICogYENTU1RyYW5zaXRpb25gIGFwcGxpZXMgYSBwYWlyIG9mIGNsYXNzIG5hbWVzIGR1cmluZyB0aGUgYGFwcGVhcmAsIGBlbnRlcmAsXG4gKiBhbmQgYGV4aXRgIHN0YWdlcyBvZiB0aGUgdHJhbnNpdGlvbi4gVGhlIGZpcnN0IGNsYXNzIGlzIGFwcGxpZWQgYW5kIHRoZW4gYVxuICogc2Vjb25kIFwiYWN0aXZlXCIgY2xhc3MgaW4gb3JkZXIgdG8gYWN0aXZhdGUgdGhlIGNzcyBhbmltYXRpb24uIEFmdGVyIHRoZSBhbmltYXRpb24sXG4gKiBtYXRjaGluZyBgZG9uZWAgY2xhc3MgbmFtZXMgYXJlIGFwcGxpZWQgdG8gcGVyc2lzdCB0aGUgYW5pbWF0aW9uIHN0YXRlLlxuICpcbiAqIFdoZW4gdGhlIGBpbmAgcHJvcCBpcyB0b2dnbGVkIHRvIGB0cnVlYCB0aGUgQ29tcG9uZW50IHdpbGwgZ2V0XG4gKiB0aGUgYGV4YW1wbGUtZW50ZXJgIENTUyBjbGFzcyBhbmQgdGhlIGBleGFtcGxlLWVudGVyLWFjdGl2ZWAgQ1NTIGNsYXNzXG4gKiBhZGRlZCBpbiB0aGUgbmV4dCB0aWNrLiBUaGlzIGlzIGEgY29udmVudGlvbiBiYXNlZCBvbiB0aGUgYGNsYXNzTmFtZXNgIHByb3AuXG4gKi9cblxudmFyIENTU1RyYW5zaXRpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ1NTVHJhbnNpdGlvbiwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQ1NTVHJhbnNpdGlvbigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcblxuICAgIF90aGlzLm9uRW50ZXIgPSBmdW5jdGlvbiAobm9kZSwgYXBwZWFyaW5nKSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0Q2xhc3NOYW1lcyA9IF90aGlzLmdldENsYXNzTmFtZXMoYXBwZWFyaW5nID8gJ2FwcGVhcicgOiAnZW50ZXInKSxcbiAgICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRnZXRDbGFzc05hbWVzLmNsYXNzTmFtZTtcblxuICAgICAgX3RoaXMucmVtb3ZlQ2xhc3Nlcyhub2RlLCAnZXhpdCcpO1xuXG4gICAgICBhZGRDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25FbnRlcikge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkVudGVyKG5vZGUsIGFwcGVhcmluZyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uRW50ZXJpbmcgPSBmdW5jdGlvbiAobm9kZSwgYXBwZWFyaW5nKSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0Q2xhc3NOYW1lczIgPSBfdGhpcy5nZXRDbGFzc05hbWVzKGFwcGVhcmluZyA/ICdhcHBlYXInIDogJ2VudGVyJyksXG4gICAgICAgICAgYWN0aXZlQ2xhc3NOYW1lID0gX3RoaXMkZ2V0Q2xhc3NOYW1lczIuYWN0aXZlQ2xhc3NOYW1lO1xuXG4gICAgICBfdGhpcy5yZWZsb3dBbmRBZGRDbGFzcyhub2RlLCBhY3RpdmVDbGFzc05hbWUpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25FbnRlcmluZykge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkVudGVyaW5nKG5vZGUsIGFwcGVhcmluZyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uRW50ZXJlZCA9IGZ1bmN0aW9uIChub2RlLCBhcHBlYXJpbmcpIHtcbiAgICAgIHZhciBfdGhpcyRnZXRDbGFzc05hbWVzMyA9IF90aGlzLmdldENsYXNzTmFtZXMoJ2VudGVyJyksXG4gICAgICAgICAgZG9uZUNsYXNzTmFtZSA9IF90aGlzJGdldENsYXNzTmFtZXMzLmRvbmVDbGFzc05hbWU7XG5cbiAgICAgIF90aGlzLnJlbW92ZUNsYXNzZXMobm9kZSwgYXBwZWFyaW5nID8gJ2FwcGVhcicgOiAnZW50ZXInKTtcblxuICAgICAgYWRkQ2xhc3Mobm9kZSwgZG9uZUNsYXNzTmFtZSk7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkVudGVyZWQpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25FbnRlcmVkKG5vZGUsIGFwcGVhcmluZyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uRXhpdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0Q2xhc3NOYW1lczQgPSBfdGhpcy5nZXRDbGFzc05hbWVzKCdleGl0JyksXG4gICAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkZ2V0Q2xhc3NOYW1lczQuY2xhc3NOYW1lO1xuXG4gICAgICBfdGhpcy5yZW1vdmVDbGFzc2VzKG5vZGUsICdhcHBlYXInKTtcblxuICAgICAgX3RoaXMucmVtb3ZlQ2xhc3Nlcyhub2RlLCAnZW50ZXInKTtcblxuICAgICAgYWRkQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRXhpdCkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkV4aXQobm9kZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uRXhpdGluZyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0Q2xhc3NOYW1lczUgPSBfdGhpcy5nZXRDbGFzc05hbWVzKCdleGl0JyksXG4gICAgICAgICAgYWN0aXZlQ2xhc3NOYW1lID0gX3RoaXMkZ2V0Q2xhc3NOYW1lczUuYWN0aXZlQ2xhc3NOYW1lO1xuXG4gICAgICBfdGhpcy5yZWZsb3dBbmRBZGRDbGFzcyhub2RlLCBhY3RpdmVDbGFzc05hbWUpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25FeGl0aW5nKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uRXhpdGluZyhub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25FeGl0ZWQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIF90aGlzJGdldENsYXNzTmFtZXM2ID0gX3RoaXMuZ2V0Q2xhc3NOYW1lcygnZXhpdCcpLFxuICAgICAgICAgIGRvbmVDbGFzc05hbWUgPSBfdGhpcyRnZXRDbGFzc05hbWVzNi5kb25lQ2xhc3NOYW1lO1xuXG4gICAgICBfdGhpcy5yZW1vdmVDbGFzc2VzKG5vZGUsICdleGl0Jyk7XG5cbiAgICAgIGFkZENsYXNzKG5vZGUsIGRvbmVDbGFzc05hbWUpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25FeGl0ZWQpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25FeGl0ZWQobm9kZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmdldENsYXNzTmFtZXMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIGNsYXNzTmFtZXMgPSBfdGhpcy5wcm9wcy5jbGFzc05hbWVzO1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHR5cGVvZiBjbGFzc05hbWVzICE9PSAnc3RyaW5nJyA/IGNsYXNzTmFtZXNbdHlwZV0gOiBjbGFzc05hbWVzICsgJy0nICsgdHlwZTtcbiAgICAgIHZhciBhY3RpdmVDbGFzc05hbWUgPSB0eXBlb2YgY2xhc3NOYW1lcyAhPT0gJ3N0cmluZycgPyBjbGFzc05hbWVzW3R5cGUgKyAnQWN0aXZlJ10gOiBjbGFzc05hbWUgKyAnLWFjdGl2ZSc7XG4gICAgICB2YXIgZG9uZUNsYXNzTmFtZSA9IHR5cGVvZiBjbGFzc05hbWVzICE9PSAnc3RyaW5nJyA/IGNsYXNzTmFtZXNbdHlwZSArICdEb25lJ10gOiBjbGFzc05hbWUgKyAnLWRvbmUnO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIGFjdGl2ZUNsYXNzTmFtZTogYWN0aXZlQ2xhc3NOYW1lLFxuICAgICAgICBkb25lQ2xhc3NOYW1lOiBkb25lQ2xhc3NOYW1lXG4gICAgICB9O1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ1NTVHJhbnNpdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbW92ZUNsYXNzZXMgPSBmdW5jdGlvbiByZW1vdmVDbGFzc2VzKG5vZGUsIHR5cGUpIHtcbiAgICB2YXIgX3RoaXMkZ2V0Q2xhc3NOYW1lczcgPSB0aGlzLmdldENsYXNzTmFtZXModHlwZSksXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJGdldENsYXNzTmFtZXM3LmNsYXNzTmFtZSxcbiAgICAgICAgYWN0aXZlQ2xhc3NOYW1lID0gX3RoaXMkZ2V0Q2xhc3NOYW1lczcuYWN0aXZlQ2xhc3NOYW1lLFxuICAgICAgICBkb25lQ2xhc3NOYW1lID0gX3RoaXMkZ2V0Q2xhc3NOYW1lczcuZG9uZUNsYXNzTmFtZTtcblxuICAgIGNsYXNzTmFtZSAmJiByZW1vdmVDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuICAgIGFjdGl2ZUNsYXNzTmFtZSAmJiByZW1vdmVDbGFzcyhub2RlLCBhY3RpdmVDbGFzc05hbWUpO1xuICAgIGRvbmVDbGFzc05hbWUgJiYgcmVtb3ZlQ2xhc3Mobm9kZSwgZG9uZUNsYXNzTmFtZSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlZmxvd0FuZEFkZENsYXNzID0gZnVuY3Rpb24gcmVmbG93QW5kQWRkQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKSB7XG4gICAgLy8gVGhpcyBpcyBmb3IgdG8gZm9yY2UgYSByZXBhaW50LFxuICAgIC8vIHdoaWNoIGlzIG5lY2Vzc2FyeSBpbiBvcmRlciB0byB0cmFuc2l0aW9uIHN0eWxlcyB3aGVuIGFkZGluZyBhIGNsYXNzIG5hbWUuXG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgICBub2RlICYmIG5vZGUuc2Nyb2xsVG9wO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cblxuICAgICAgYWRkQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcHJvcHMgPSBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcyk7XG5cbiAgICBkZWxldGUgcHJvcHMuY2xhc3NOYW1lcztcbiAgICByZXR1cm4gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfVHJhbnNpdGlvbi5kZWZhdWx0LCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIG9uRW50ZXI6IHRoaXMub25FbnRlcixcbiAgICAgIG9uRW50ZXJlZDogdGhpcy5vbkVudGVyZWQsXG4gICAgICBvbkVudGVyaW5nOiB0aGlzLm9uRW50ZXJpbmcsXG4gICAgICBvbkV4aXQ6IHRoaXMub25FeGl0LFxuICAgICAgb25FeGl0aW5nOiB0aGlzLm9uRXhpdGluZyxcbiAgICAgIG9uRXhpdGVkOiB0aGlzLm9uRXhpdGVkXG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBDU1NUcmFuc2l0aW9uO1xufShfcmVhY3QuZGVmYXVsdC5Db21wb25lbnQpO1xuXG5DU1NUcmFuc2l0aW9uLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHByb3BUeXBlcyA6IHt9O1xudmFyIF9kZWZhdWx0ID0gQ1NTVHJhbnNpdGlvbjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX3JlYWN0LXRyYW5zaXRpb24tZ3JvdXBAMi41LjJAcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9DU1NUcmFuc2l0aW9uLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gYWRkQ2xhc3M7XG5cbnZhciBfaGFzQ2xhc3MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2hhc0NsYXNzXCIpKTtcblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7ZWxzZSBpZiAoISgwLCBfaGFzQ2xhc3MuZGVmYXVsdCkoZWxlbWVudCwgY2xhc3NOYW1lKSkgaWYgKHR5cGVvZiBlbGVtZW50LmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUgKyAnICcgKyBjbGFzc05hbWU7ZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoZWxlbWVudC5jbGFzc05hbWUgJiYgZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCB8fCAnJykgKyAnICcgKyBjbGFzc05hbWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fZG9tLWhlbHBlcnNAMy40LjBAZG9tLWhlbHBlcnMvY2xhc3MvYWRkQ2xhc3MuanMiLCJmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgIGRlZmF1bHQ6IG9ialxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19AYmFiZWxfcnVudGltZUA3LjIuMEBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gaGFzQ2xhc3M7XG5cbmZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHJldHVybiAhIWNsYXNzTmFtZSAmJiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO2Vsc2UgcmV0dXJuIChcIiBcIiArIChlbGVtZW50LmNsYXNzTmFtZS5iYXNlVmFsIHx8IGVsZW1lbnQuY2xhc3NOYW1lKSArIFwiIFwiKS5pbmRleE9mKFwiIFwiICsgY2xhc3NOYW1lICsgXCIgXCIpICE9PSAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX2RvbS1oZWxwZXJzQDMuNC4wQGRvbS1oZWxwZXJzL2NsYXNzL2hhc0NsYXNzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiByZXBsYWNlQ2xhc3NOYW1lKG9yaWdDbGFzcywgY2xhc3NUb1JlbW92ZSkge1xuICByZXR1cm4gb3JpZ0NsYXNzLnJlcGxhY2UobmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIGNsYXNzVG9SZW1vdmUgKyAnKD86XFxcXHN8JCknLCAnZycpLCAnJDEnKS5yZXBsYWNlKC9cXHMrL2csICcgJykucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO2Vsc2UgaWYgKHR5cGVvZiBlbGVtZW50LmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIGVsZW1lbnQuY2xhc3NOYW1lID0gcmVwbGFjZUNsYXNzTmFtZShlbGVtZW50LmNsYXNzTmFtZSwgY2xhc3NOYW1lKTtlbHNlIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIHJlcGxhY2VDbGFzc05hbWUoZWxlbWVudC5jbGFzc05hbWUgJiYgZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCB8fCAnJywgY2xhc3NOYW1lKSk7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fZG9tLWhlbHBlcnNAMy40LjBAZG9tLWhlbHBlcnMvY2xhc3MvcmVtb3ZlQ2xhc3MuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoXCJyZWFjdC1kb21cIik7XG5cbnZhciBfVHJhbnNpdGlvbkdyb3VwID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9UcmFuc2l0aW9uR3JvdXBcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgcHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICBpbjogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wuaXNSZXF1aXJlZCxcbiAgY2hpbGRyZW46IGZ1bmN0aW9uIGNoaWxkcmVuKHByb3BzLCBwcm9wTmFtZSkge1xuICAgIGlmIChfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5jb3VudChwcm9wc1twcm9wTmFtZV0pICE9PSAyKSByZXR1cm4gbmV3IEVycm9yKFwiXFxcIlwiICsgcHJvcE5hbWUgKyBcIlxcXCIgbXVzdCBiZSBleGFjdGx5IHR3byB0cmFuc2l0aW9uIGNvbXBvbmVudHMuXCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59IDoge307O1xuLyoqXG4gKiBUaGUgYDxSZXBsYWNlVHJhbnNpdGlvbj5gIGNvbXBvbmVudCBpcyBhIHNwZWNpYWxpemVkIGBUcmFuc2l0aW9uYCBjb21wb25lbnRcbiAqIHRoYXQgYW5pbWF0ZXMgYmV0d2VlbiB0d28gY2hpbGRyZW4uXG4gKlxuICogYGBganN4XG4gKiA8UmVwbGFjZVRyYW5zaXRpb24gaW4+XG4gKiAgIDxGYWRlPjxkaXY+SSBhcHBlYXIgZmlyc3Q8L2Rpdj48L0ZhZGU+XG4gKiAgIDxGYWRlPjxkaXY+SSByZXBsYWNlIHRoZSBhYm92ZTwvZGl2PjwvRmFkZT5cbiAqIDwvUmVwbGFjZVRyYW5zaXRpb24+XG4gKiBgYGBcbiAqL1xuXG52YXIgUmVwbGFjZVRyYW5zaXRpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoUmVwbGFjZVRyYW5zaXRpb24sIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJlcGxhY2VUcmFuc2l0aW9uKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBfYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIF9hcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoX2FyZ3MpKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuaGFuZGxlRW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMuaGFuZGxlTGlmZWN5Y2xlKCdvbkVudGVyJywgMCwgYXJncyk7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZUVudGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZUxpZmVjeWNsZSgnb25FbnRlcmluZycsIDAsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVFbnRlcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZUxpZmVjeWNsZSgnb25FbnRlcmVkJywgMCwgYXJncyk7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZUV4aXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUpLCBfa2V5NSA9IDA7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMuaGFuZGxlTGlmZWN5Y2xlKCdvbkV4aXQnLCAxLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlRXhpdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgICBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVMaWZlY3ljbGUoJ29uRXhpdGluZycsIDEsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVFeGl0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjcpLCBfa2V5NyA9IDA7IF9rZXk3IDwgX2xlbjc7IF9rZXk3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5N10gPSBhcmd1bWVudHNbX2tleTddO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMuaGFuZGxlTGlmZWN5Y2xlKCdvbkV4aXRlZCcsIDEsIGFyZ3MpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUmVwbGFjZVRyYW5zaXRpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5oYW5kbGVMaWZlY3ljbGUgPSBmdW5jdGlvbiBoYW5kbGVMaWZlY3ljbGUoaGFuZGxlciwgaWR4LCBvcmlnaW5hbEFyZ3MpIHtcbiAgICB2YXIgX2NoaWxkJHByb3BzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcblxuICAgIHZhciBjaGlsZCA9IF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pW2lkeF07XG5cbiAgICBpZiAoY2hpbGQucHJvcHNbaGFuZGxlcl0pIChfY2hpbGQkcHJvcHMgPSBjaGlsZC5wcm9wcylbaGFuZGxlcl0uYXBwbHkoX2NoaWxkJHByb3BzLCBvcmlnaW5hbEFyZ3MpO1xuICAgIGlmICh0aGlzLnByb3BzW2hhbmRsZXJdKSB0aGlzLnByb3BzW2hhbmRsZXJdKCgwLCBfcmVhY3REb20uZmluZERPTU5vZGUpKHRoaXMpKTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGluUHJvcCA9IF90aGlzJHByb3BzLmluLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImluXCJdKTtcblxuICAgIHZhciBfUmVhY3QkQ2hpbGRyZW4kdG9BcnIgPSBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKSxcbiAgICAgICAgZmlyc3QgPSBfUmVhY3QkQ2hpbGRyZW4kdG9BcnJbMF0sXG4gICAgICAgIHNlY29uZCA9IF9SZWFjdCRDaGlsZHJlbiR0b0FyclsxXTtcblxuICAgIGRlbGV0ZSBwcm9wcy5vbkVudGVyO1xuICAgIGRlbGV0ZSBwcm9wcy5vbkVudGVyaW5nO1xuICAgIGRlbGV0ZSBwcm9wcy5vbkVudGVyZWQ7XG4gICAgZGVsZXRlIHByb3BzLm9uRXhpdDtcbiAgICBkZWxldGUgcHJvcHMub25FeGl0aW5nO1xuICAgIGRlbGV0ZSBwcm9wcy5vbkV4aXRlZDtcbiAgICByZXR1cm4gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfVHJhbnNpdGlvbkdyb3VwLmRlZmF1bHQsIHByb3BzLCBpblByb3AgPyBfcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoZmlyc3QsIHtcbiAgICAgIGtleTogJ2ZpcnN0JyxcbiAgICAgIG9uRW50ZXI6IHRoaXMuaGFuZGxlRW50ZXIsXG4gICAgICBvbkVudGVyaW5nOiB0aGlzLmhhbmRsZUVudGVyaW5nLFxuICAgICAgb25FbnRlcmVkOiB0aGlzLmhhbmRsZUVudGVyZWRcbiAgICB9KSA6IF9yZWFjdC5kZWZhdWx0LmNsb25lRWxlbWVudChzZWNvbmQsIHtcbiAgICAgIGtleTogJ3NlY29uZCcsXG4gICAgICBvbkVudGVyOiB0aGlzLmhhbmRsZUV4aXQsXG4gICAgICBvbkVudGVyaW5nOiB0aGlzLmhhbmRsZUV4aXRpbmcsXG4gICAgICBvbkVudGVyZWQ6IHRoaXMuaGFuZGxlRXhpdGVkXG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBSZXBsYWNlVHJhbnNpdGlvbjtcbn0oX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50KTtcblxuUmVwbGFjZVRyYW5zaXRpb24ucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gcHJvcFR5cGVzIDoge307XG52YXIgX2RlZmF1bHQgPSBSZXBsYWNlVHJhbnNpdGlvbjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX3JlYWN0LXRyYW5zaXRpb24tZ3JvdXBAMi41LjJAcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9SZXBsYWNlVHJhbnNpdGlvbi5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5nZXRDaGlsZE1hcHBpbmcgPSBnZXRDaGlsZE1hcHBpbmc7XG5leHBvcnRzLm1lcmdlQ2hpbGRNYXBwaW5ncyA9IG1lcmdlQ2hpbGRNYXBwaW5ncztcbmV4cG9ydHMuZ2V0SW5pdGlhbENoaWxkTWFwcGluZyA9IGdldEluaXRpYWxDaGlsZE1hcHBpbmc7XG5leHBvcnRzLmdldE5leHRDaGlsZE1hcHBpbmcgPSBnZXROZXh0Q2hpbGRNYXBwaW5nO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG4vKipcbiAqIEdpdmVuIGB0aGlzLnByb3BzLmNoaWxkcmVuYCwgcmV0dXJuIGFuIG9iamVjdCBtYXBwaW5nIGtleSB0byBjaGlsZC5cbiAqXG4gKiBAcGFyYW0geyp9IGNoaWxkcmVuIGB0aGlzLnByb3BzLmNoaWxkcmVuYFxuICogQHJldHVybiB7b2JqZWN0fSBNYXBwaW5nIG9mIGtleSB0byBjaGlsZFxuICovXG5mdW5jdGlvbiBnZXRDaGlsZE1hcHBpbmcoY2hpbGRyZW4sIG1hcEZuKSB7XG4gIHZhciBtYXBwZXIgPSBmdW5jdGlvbiBtYXBwZXIoY2hpbGQpIHtcbiAgICByZXR1cm4gbWFwRm4gJiYgKDAsIF9yZWFjdC5pc1ZhbGlkRWxlbWVudCkoY2hpbGQpID8gbWFwRm4oY2hpbGQpIDogY2hpbGQ7XG4gIH07XG5cbiAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmIChjaGlsZHJlbikgX3JlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gYztcbiAgfSkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAvLyBydW4gdGhlIG1hcCBmdW5jdGlvbiBoZXJlIGluc3RlYWQgc28gdGhhdCB0aGUga2V5IGlzIHRoZSBjb21wdXRlZCBvbmVcbiAgICByZXN1bHRbY2hpbGQua2V5XSA9IG1hcHBlcihjaGlsZCk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBXaGVuIHlvdSdyZSBhZGRpbmcgb3IgcmVtb3ZpbmcgY2hpbGRyZW4gc29tZSBtYXkgYmUgYWRkZWQgb3IgcmVtb3ZlZCBpbiB0aGVcbiAqIHNhbWUgcmVuZGVyIHBhc3MuIFdlIHdhbnQgdG8gc2hvdyAqYm90aCogc2luY2Ugd2Ugd2FudCB0byBzaW11bHRhbmVvdXNseVxuICogYW5pbWF0ZSBlbGVtZW50cyBpbiBhbmQgb3V0LiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgcHJldmlvdXMgc2V0IG9mIGtleXNcbiAqIGFuZCBhIG5ldyBzZXQgb2Yga2V5cyBhbmQgbWVyZ2VzIHRoZW0gd2l0aCBpdHMgYmVzdCBndWVzcyBvZiB0aGUgY29ycmVjdFxuICogb3JkZXJpbmcuIEluIHRoZSBmdXR1cmUgd2UgbWF5IGV4cG9zZSBzb21lIG9mIHRoZSB1dGlsaXRpZXMgaW5cbiAqIFJlYWN0TXVsdGlDaGlsZCB0byBtYWtlIHRoaXMgZWFzeSwgYnV0IGZvciBub3cgUmVhY3QgaXRzZWxmIGRvZXMgbm90XG4gKiBkaXJlY3RseSBoYXZlIHRoaXMgY29uY2VwdCBvZiB0aGUgdW5pb24gb2YgcHJldkNoaWxkcmVuIGFuZCBuZXh0Q2hpbGRyZW5cbiAqIHNvIHdlIGltcGxlbWVudCBpdCBoZXJlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2IHByZXYgY2hpbGRyZW4gYXMgcmV0dXJuZWQgZnJvbVxuICogYFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcoKWAuXG4gKiBAcGFyYW0ge29iamVjdH0gbmV4dCBuZXh0IGNoaWxkcmVuIGFzIHJldHVybmVkIGZyb21cbiAqIGBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKClgLlxuICogQHJldHVybiB7b2JqZWN0fSBhIGtleSBzZXQgdGhhdCBjb250YWlucyBhbGwga2V5cyBpbiBgcHJldmAgYW5kIGFsbCBrZXlzXG4gKiBpbiBgbmV4dGAgaW4gYSByZWFzb25hYmxlIG9yZGVyLlxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2VDaGlsZE1hcHBpbmdzKHByZXYsIG5leHQpIHtcbiAgcHJldiA9IHByZXYgfHwge307XG4gIG5leHQgPSBuZXh0IHx8IHt9O1xuXG4gIGZ1bmN0aW9uIGdldFZhbHVlRm9yS2V5KGtleSkge1xuICAgIHJldHVybiBrZXkgaW4gbmV4dCA/IG5leHRba2V5XSA6IHByZXZba2V5XTtcbiAgfSAvLyBGb3IgZWFjaCBrZXkgb2YgYG5leHRgLCB0aGUgbGlzdCBvZiBrZXlzIHRvIGluc2VydCBiZWZvcmUgdGhhdCBrZXkgaW5cbiAgLy8gdGhlIGNvbWJpbmVkIGxpc3RcblxuXG4gIHZhciBuZXh0S2V5c1BlbmRpbmcgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgcGVuZGluZ0tleXMgPSBbXTtcblxuICBmb3IgKHZhciBwcmV2S2V5IGluIHByZXYpIHtcbiAgICBpZiAocHJldktleSBpbiBuZXh0KSB7XG4gICAgICBpZiAocGVuZGluZ0tleXMubGVuZ3RoKSB7XG4gICAgICAgIG5leHRLZXlzUGVuZGluZ1twcmV2S2V5XSA9IHBlbmRpbmdLZXlzO1xuICAgICAgICBwZW5kaW5nS2V5cyA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nS2V5cy5wdXNoKHByZXZLZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpO1xuICB2YXIgY2hpbGRNYXBwaW5nID0ge307XG5cbiAgZm9yICh2YXIgbmV4dEtleSBpbiBuZXh0KSB7XG4gICAgaWYgKG5leHRLZXlzUGVuZGluZ1tuZXh0S2V5XSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IG5leHRLZXlzUGVuZGluZ1tuZXh0S2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGVuZGluZ05leHRLZXkgPSBuZXh0S2V5c1BlbmRpbmdbbmV4dEtleV1baV07XG4gICAgICAgIGNoaWxkTWFwcGluZ1tuZXh0S2V5c1BlbmRpbmdbbmV4dEtleV1baV1dID0gZ2V0VmFsdWVGb3JLZXkocGVuZGluZ05leHRLZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoaWxkTWFwcGluZ1tuZXh0S2V5XSA9IGdldFZhbHVlRm9yS2V5KG5leHRLZXkpO1xuICB9IC8vIEZpbmFsbHksIGFkZCB0aGUga2V5cyB3aGljaCBkaWRuJ3QgYXBwZWFyIGJlZm9yZSBhbnkga2V5IGluIGBuZXh0YFxuXG5cbiAgZm9yIChpID0gMDsgaSA8IHBlbmRpbmdLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2hpbGRNYXBwaW5nW3BlbmRpbmdLZXlzW2ldXSA9IGdldFZhbHVlRm9yS2V5KHBlbmRpbmdLZXlzW2ldKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZE1hcHBpbmc7XG59XG5cbmZ1bmN0aW9uIGdldFByb3AoY2hpbGQsIHByb3AsIHByb3BzKSB7XG4gIHJldHVybiBwcm9wc1twcm9wXSAhPSBudWxsID8gcHJvcHNbcHJvcF0gOiBjaGlsZC5wcm9wc1twcm9wXTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5pdGlhbENoaWxkTWFwcGluZyhwcm9wcywgb25FeGl0ZWQpIHtcbiAgcmV0dXJuIGdldENoaWxkTWFwcGluZyhwcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuICgwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShjaGlsZCwge1xuICAgICAgb25FeGl0ZWQ6IG9uRXhpdGVkLmJpbmQobnVsbCwgY2hpbGQpLFxuICAgICAgaW46IHRydWUsXG4gICAgICBhcHBlYXI6IGdldFByb3AoY2hpbGQsICdhcHBlYXInLCBwcm9wcyksXG4gICAgICBlbnRlcjogZ2V0UHJvcChjaGlsZCwgJ2VudGVyJywgcHJvcHMpLFxuICAgICAgZXhpdDogZ2V0UHJvcChjaGlsZCwgJ2V4aXQnLCBwcm9wcylcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldE5leHRDaGlsZE1hcHBpbmcobmV4dFByb3BzLCBwcmV2Q2hpbGRNYXBwaW5nLCBvbkV4aXRlZCkge1xuICB2YXIgbmV4dENoaWxkTWFwcGluZyA9IGdldENoaWxkTWFwcGluZyhuZXh0UHJvcHMuY2hpbGRyZW4pO1xuICB2YXIgY2hpbGRyZW4gPSBtZXJnZUNoaWxkTWFwcGluZ3MocHJldkNoaWxkTWFwcGluZywgbmV4dENoaWxkTWFwcGluZyk7XG4gIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltrZXldO1xuICAgIGlmICghKDAsIF9yZWFjdC5pc1ZhbGlkRWxlbWVudCkoY2hpbGQpKSByZXR1cm47XG4gICAgdmFyIGhhc1ByZXYgPSBrZXkgaW4gcHJldkNoaWxkTWFwcGluZztcbiAgICB2YXIgaGFzTmV4dCA9IGtleSBpbiBuZXh0Q2hpbGRNYXBwaW5nO1xuICAgIHZhciBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRNYXBwaW5nW2tleV07XG4gICAgdmFyIGlzTGVhdmluZyA9ICgwLCBfcmVhY3QuaXNWYWxpZEVsZW1lbnQpKHByZXZDaGlsZCkgJiYgIXByZXZDaGlsZC5wcm9wcy5pbjsgLy8gaXRlbSBpcyBuZXcgKGVudGVyaW5nKVxuXG4gICAgaWYgKGhhc05leHQgJiYgKCFoYXNQcmV2IHx8IGlzTGVhdmluZykpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdlbnRlcmluZycsIGtleSlcbiAgICAgIGNoaWxkcmVuW2tleV0gPSAoMCwgX3JlYWN0LmNsb25lRWxlbWVudCkoY2hpbGQsIHtcbiAgICAgICAgb25FeGl0ZWQ6IG9uRXhpdGVkLmJpbmQobnVsbCwgY2hpbGQpLFxuICAgICAgICBpbjogdHJ1ZSxcbiAgICAgICAgZXhpdDogZ2V0UHJvcChjaGlsZCwgJ2V4aXQnLCBuZXh0UHJvcHMpLFxuICAgICAgICBlbnRlcjogZ2V0UHJvcChjaGlsZCwgJ2VudGVyJywgbmV4dFByb3BzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghaGFzTmV4dCAmJiBoYXNQcmV2ICYmICFpc0xlYXZpbmcpIHtcbiAgICAgIC8vIGl0ZW0gaXMgb2xkIChleGl0aW5nKVxuICAgICAgLy8gY29uc29sZS5sb2coJ2xlYXZpbmcnLCBrZXkpXG4gICAgICBjaGlsZHJlbltrZXldID0gKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKGNoaWxkLCB7XG4gICAgICAgIGluOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChoYXNOZXh0ICYmIGhhc1ByZXYgJiYgKDAsIF9yZWFjdC5pc1ZhbGlkRWxlbWVudCkocHJldkNoaWxkKSkge1xuICAgICAgLy8gaXRlbSBoYXNuJ3QgY2hhbmdlZCB0cmFuc2l0aW9uIHN0YXRlc1xuICAgICAgLy8gY29weSBvdmVyIHRoZSBsYXN0IHRyYW5zaXRpb24gcHJvcHM7XG4gICAgICAvLyBjb25zb2xlLmxvZygndW5jaGFuZ2VkJywga2V5KVxuICAgICAgY2hpbGRyZW5ba2V5XSA9ICgwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShjaGlsZCwge1xuICAgICAgICBvbkV4aXRlZDogb25FeGl0ZWQuYmluZChudWxsLCBjaGlsZCksXG4gICAgICAgIGluOiBwcmV2Q2hpbGQucHJvcHMuaW4sXG4gICAgICAgIGV4aXQ6IGdldFByb3AoY2hpbGQsICdleGl0JywgbmV4dFByb3BzKSxcbiAgICAgICAgZW50ZXI6IGdldFByb3AoY2hpbGQsICdlbnRlcicsIG5leHRQcm9wcylcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX3JlYWN0LXRyYW5zaXRpb24tZ3JvdXBAMi41LjJAcmVhY3QtdHJhbnNpdGlvbi1ncm91cC91dGlscy9DaGlsZE1hcHBpbmcuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICdyZWFjdC10cmFuc2l0aW9uLWdyb3VwJztcbmltcG9ydCB7IGZ1bmMsIHN1cHBvcnQsIGV2ZW50cywgZG9tLCBndWlkIH0gZnJvbSAnLi4vdXRpbCc7XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcbmNvbnN0IHsgb24sIG9mZiB9ID0gZXZlbnRzO1xuY29uc3QgeyBhZGRDbGFzcywgcmVtb3ZlQ2xhc3MgfSA9IGRvbTtcbmNvbnN0IHByZWZpeGVzID0gWyctd2Via2l0LScsICctbW96LScsICctby0nLCAnbXMtJywgJyddO1xuXG5mdW5jdGlvbiBnZXRTdHlsZVByb3BlcnR5KG5vZGUsIG5hbWUpIHtcbiAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGxldCByZXQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJldCA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJlZml4ZXNbaV0gKyBuYW1lKTtcbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0ZUNoaWxkIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBuYW1lczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgICAgICBvbkFwcGVhcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uQXBwZWFyaW5nOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25BcHBlYXJlZDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkVudGVyaW5nOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25FbnRlcmVkOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25FeGl0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25FeGl0aW5nOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25FeGl0ZWQ6IFByb3BUeXBlcy5mdW5jXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIG9uQXBwZWFyOiBub29wLFxuICAgICAgICBvbkFwcGVhcmluZzogbm9vcCxcbiAgICAgICAgb25BcHBlYXJlZDogbm9vcCxcbiAgICAgICAgb25FbnRlcjogbm9vcCxcbiAgICAgICAgb25FbnRlcmluZzogbm9vcCxcbiAgICAgICAgb25FbnRlcmVkOiBub29wLFxuICAgICAgICBvbkV4aXQ6IG5vb3AsXG4gICAgICAgIG9uRXhpdGluZzogbm9vcCxcbiAgICAgICAgb25FeGl0ZWQ6IG5vb3BcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICBmdW5jLmJpbmRDdHgodGhpcywgW1xuICAgICAgICAgICAgJ2hhbmRsZUVudGVyJywgJ2hhbmRsZUVudGVyaW5nJywgJ2hhbmRsZUVudGVyZWQnLFxuICAgICAgICAgICAgJ2hhbmRsZUV4aXQnLCAnaGFuZGxlRXhpdGluZycsICdoYW5kbGVFeGl0ZWQnLFxuICAgICAgICAgICAgJ2FkZEVuZExpc3RlbmVyJ1xuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5lbmRMaXN0ZW5lcnMgPSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uZW5kOiBbXSxcbiAgICAgICAgICAgIGFuaW1hdGlvbmVuZDogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50aW1lb3V0TWFwID0ge307XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZW5kTGlzdGVuZXJzKS5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVuZExpc3RlbmVyc1tldmVudE5hbWVdLmZvckVhY2gobGlzdGVuZXIgPT4ge1xuICAgICAgICAgICAgICAgIG9mZih0aGlzLm5vZGUsIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVuZExpc3RlbmVycyA9IHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25lbmQ6IFtdLFxuICAgICAgICAgICAgYW5pbWF0aW9uZW5kOiBbXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGdlbmVyYXRlRW5kTGlzdGVuZXIobm9kZSwgZG9uZSwgZXZlbnROYW1lLCBpZCkge1xuICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBlbmRMaXN0ZW5lcihlKSB7XG5cbiAgICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnRpbWVvdXRNYXBbaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0TWFwW2lkXSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy50aW1lb3V0TWFwW2lkXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgb2ZmKG5vZGUsIGV2ZW50TmFtZSwgZW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IF90aGlzLmVuZExpc3RlbmVyc1tldmVudE5hbWVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YoZW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIGluZGV4ID4gLTEgJiYgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYWRkRW5kTGlzdGVuZXIobm9kZSwgZG9uZSkge1xuICAgICAgICBpZiAoc3VwcG9ydC50cmFuc2l0aW9uIHx8IHN1cHBvcnQuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGd1aWQoKTtcblxuICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0LnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uRW5kTGlzdGVuZXIgPSB0aGlzLmdlbmVyYXRlRW5kTGlzdGVuZXIobm9kZSwgZG9uZSwgJ3RyYW5zaXRpb25lbmQnLCBpZCk7XG4gICAgICAgICAgICAgICAgb24obm9kZSwgJ3RyYW5zaXRpb25lbmQnLCB0cmFuc2l0aW9uRW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kTGlzdGVuZXJzLnRyYW5zaXRpb25lbmQucHVzaCh0cmFuc2l0aW9uRW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1cHBvcnQuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uRW5kTGlzdGVuZXIgPSB0aGlzLmdlbmVyYXRlRW5kTGlzdGVuZXIobm9kZSwgZG9uZSwgJ2FuaW1hdGlvbmVuZCcsIGlkKTtcbiAgICAgICAgICAgICAgICBvbihub2RlLCAnYW5pbWF0aW9uZW5kJywgYW5pbWF0aW9uRW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kTGlzdGVuZXJzLmFuaW1hdGlvbmVuZC5wdXNoKGFuaW1hdGlvbkVuZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNpdGlvbkRlbGF5ID0gcGFyc2VGbG9hdChnZXRTdHlsZVByb3BlcnR5KG5vZGUsICd0cmFuc2l0aW9uLWRlbGF5JykpIHx8IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uID0gcGFyc2VGbG9hdChnZXRTdHlsZVByb3BlcnR5KG5vZGUsICd0cmFuc2l0aW9uLWR1cmF0aW9uJykpIHx8IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uRGVsYXkgPSBwYXJzZUZsb2F0KGdldFN0eWxlUHJvcGVydHkobm9kZSwgJ2FuaW1hdGlvbi1kZWxheScpKSB8fCAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9uID0gcGFyc2VGbG9hdChnZXRTdHlsZVByb3BlcnR5KG5vZGUsICdhbmltYXRpb24tZHVyYXRpb24nKSkgfHwgMDtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lID0gTWF0aC5tYXgodHJhbnNpdGlvbkR1cmF0aW9uICsgdHJhbnNpdGlvbkRlbGF5LCBhbmltYXRpb25EdXJhdGlvbiArIGFuaW1hdGlvbkRlbGF5KTtcbiAgICAgICAgICAgICAgICBpZiAodGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRNYXBbaWRdID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRpbWUgKiAxMDAwICsgMjAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxNSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZUVuZHRMaXN0ZW5lcigpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uT2ZmICYmIHRoaXMudHJhbnNpdGlvbk9mZigpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbk9mZiAmJiB0aGlzLmFuaW1hdGlvbk9mZigpO1xuICAgIH1cblxuICAgIHJlbW92ZUNsYXNzTmFtZXMobm9kZSwgbmFtZXMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMobmFtZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKG5vZGUsIG5hbWVzW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoYW5kbGVFbnRlcihub2RlLCBpc0FwcGVhcmluZykge1xuICAgICAgICBjb25zdCB7IG5hbWVzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAobmFtZXMpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3NOYW1lcyhub2RlLCBuYW1lcyk7XG4gICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBpc0FwcGVhcmluZyA/ICdhcHBlYXInIDogJ2VudGVyJztcbiAgICAgICAgICAgIGFkZENsYXNzKG5vZGUsIG5hbWVzW2NsYXNzTmFtZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaG9vayA9IGlzQXBwZWFyaW5nID8gdGhpcy5wcm9wcy5vbkFwcGVhciA6IHRoaXMucHJvcHMub25FbnRlcjtcbiAgICAgICAgaG9vayhub2RlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVFbnRlcmluZyhub2RlLCBpc0FwcGVhcmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZXMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAobmFtZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBpc0FwcGVhcmluZyA/ICdhcHBlYXJBY3RpdmUnIDogJ2VudGVyQWN0aXZlJztcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhub2RlLCBuYW1lc1tjbGFzc05hbWVdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaG9vayA9IGlzQXBwZWFyaW5nID8gdGhpcy5wcm9wcy5vbkFwcGVhcmluZyA6IHRoaXMucHJvcHMub25FbnRlcmluZztcbiAgICAgICAgICAgIGhvb2sobm9kZSk7XG4gICAgICAgIH0sIDEwKTtcbiAgICB9XG5cbiAgICBoYW5kbGVFbnRlcmVkKG5vZGUsIGlzQXBwZWFyaW5nKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZXMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChuYW1lcykge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IGlzQXBwZWFyaW5nID9cbiAgICAgICAgICAgICAgICBbbmFtZXMuYXBwZWFyLCBuYW1lcy5hcHBlYXJBY3RpdmVdIDpcbiAgICAgICAgICAgICAgICBbbmFtZXMuZW50ZXIsIG5hbWVzLmVudGVyQWN0aXZlXTtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMuZm9yRWFjaChjbGFzc05hbWUgPT4ge1xuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKG5vZGUsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhvb2sgPSBpc0FwcGVhcmluZyA/IHRoaXMucHJvcHMub25BcHBlYXJlZCA6IHRoaXMucHJvcHMub25FbnRlcmVkO1xuICAgICAgICBob29rKG5vZGUpO1xuICAgIH1cblxuICAgIGhhbmRsZUV4aXQobm9kZSkge1xuICAgICAgICBjb25zdCB7IG5hbWVzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAobmFtZXMpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3NOYW1lcyhub2RlLCBuYW1lcyk7XG4gICAgICAgICAgICBhZGRDbGFzcyhub2RlLCBuYW1lcy5sZWF2ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3BzLm9uRXhpdChub2RlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVFeGl0aW5nKG5vZGUpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWVzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKG5hbWVzKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3Mobm9kZSwgbmFtZXMubGVhdmVBY3RpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkV4aXRpbmcobm9kZSk7XG4gICAgICAgIH0sIDEwKTtcbiAgICB9XG5cbiAgICBoYW5kbGVFeGl0ZWQobm9kZSkge1xuICAgICAgICBjb25zdCB7IG5hbWVzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAobmFtZXMpIHtcbiAgICAgICAgICAgIFtuYW1lcy5sZWF2ZSwgbmFtZXMubGVhdmVBY3RpdmVdLmZvckVhY2goY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3BzLm9uRXhpdGVkKG5vZGUpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgY29uc3QgeyBuYW1lcyxcbiAgICAgICAgICAgIG9uQXBwZWFyLCBvbkFwcGVhcmVkLCBvbkFwcGVhcmluZyxcbiAgICAgICAgICAgIG9uRW50ZXIsIG9uRW50ZXJpbmcsIG9uRW50ZXJlZCxcbiAgICAgICAgICAgIG9uRXhpdCwgb25FeGl0aW5nLCBvbkV4aXRlZCxcbiAgICAgICAgICAgIC4uLm90aGVyc1xuICAgICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8VHJhbnNpdGlvbiB7Li4ub3RoZXJzfVxuICAgICAgICAgICAgICAgIG9uRW50ZXI9e3RoaXMuaGFuZGxlRW50ZXJ9XG4gICAgICAgICAgICAgICAgb25FbnRlcmluZz17dGhpcy5oYW5kbGVFbnRlcmluZ31cbiAgICAgICAgICAgICAgICBvbkVudGVyZWQ9e3RoaXMuaGFuZGxlRW50ZXJlZH1cbiAgICAgICAgICAgICAgICBvbkV4aXQ9e3RoaXMuaGFuZGxlRXhpdH1cbiAgICAgICAgICAgICAgICBvbkV4aXRpbmc9e3RoaXMuaGFuZGxlRXhpdGluZ31cbiAgICAgICAgICAgICAgICBvbkV4aXRlZD17dGhpcy5oYW5kbGVFeGl0ZWR9XG4gICAgICAgICAgICAgICAgYWRkRW5kTGlzdGVuZXI9e3RoaXMuYWRkRW5kTGlzdGVuZXJ9IC8+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FuaW1hdGUvY2hpbGQuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBmdW5jLCBkb20gfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBBbmltYXRlIGZyb20gJy4vYW5pbWF0ZSc7XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcbmNvbnN0IHsgZ2V0U3R5bGUgfSA9IGRvbTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXhwYW5kIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBhbmltYXRpb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgICAgICAgYmVmb3JlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgYWZ0ZXJFbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGJlZm9yZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25MZWF2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGFmdGVyTGVhdmU6IFByb3BUeXBlcy5mdW5jXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGJlZm9yZUVudGVyOiBub29wLFxuICAgICAgICBvbkVudGVyOiBub29wLFxuICAgICAgICBhZnRlckVudGVyOiBub29wLFxuICAgICAgICBiZWZvcmVMZWF2ZTogbm9vcCxcbiAgICAgICAgb25MZWF2ZTogbm9vcCxcbiAgICAgICAgYWZ0ZXJMZWF2ZTogbm9vcFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIGZ1bmMuYmluZEN0eCh0aGlzLCBbXG4gICAgICAgICAgICAnYmVmb3JlRW50ZXInLCAnb25FbnRlcicsICdhZnRlckVudGVyJyxcbiAgICAgICAgICAgICdiZWZvcmVMZWF2ZScsICdvbkxlYXZlJywgJ2FmdGVyTGVhdmUnXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIGJlZm9yZUVudGVyKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMubGVhdmluZykge1xuICAgICAgICAgICAgdGhpcy5hZnRlckxlYXZlKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWNoZUN1cnJlbnRTdHlsZShub2RlKTtcbiAgICAgICAgdGhpcy5jYWNoZUNvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFN0eWxlVG9aZXJvKG5vZGUpO1xuXG4gICAgICAgIHRoaXMucHJvcHMuYmVmb3JlRW50ZXIobm9kZSk7XG4gICAgfVxuXG4gICAgb25FbnRlcihub2RlKSB7XG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFN0eWxlVG9Db21wdXRlZFN0eWxlKG5vZGUpO1xuXG4gICAgICAgIHRoaXMucHJvcHMub25FbnRlcihub2RlKTtcbiAgICB9XG5cbiAgICBhZnRlckVudGVyKG5vZGUpIHtcbiAgICAgICAgdGhpcy5yZXN0b3JlQ3VycmVudFN0eWxlKG5vZGUpO1xuXG4gICAgICAgIHRoaXMucHJvcHMuYWZ0ZXJFbnRlcihub2RlKTtcbiAgICB9XG5cbiAgICBiZWZvcmVMZWF2ZShub2RlKSB7XG4gICAgICAgIHRoaXMubGVhdmluZyA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5jYWNoZUN1cnJlbnRTdHlsZShub2RlKTtcbiAgICAgICAgdGhpcy5jYWNoZUNvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFN0eWxlVG9Db21wdXRlZFN0eWxlKG5vZGUpO1xuXG4gICAgICAgIHRoaXMucHJvcHMuYmVmb3JlTGVhdmUobm9kZSk7XG4gICAgfVxuXG4gICAgb25MZWF2ZShub2RlKSB7XG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFN0eWxlVG9aZXJvKG5vZGUpO1xuXG4gICAgICAgIHRoaXMucHJvcHMub25MZWF2ZShub2RlKTtcbiAgICB9XG5cbiAgICBhZnRlckxlYXZlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5sZWF2aW5nID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5yZXN0b3JlQ3VycmVudFN0eWxlKG5vZGUpO1xuXG4gICAgICAgIHRoaXMucHJvcHMuYWZ0ZXJMZWF2ZShub2RlKTtcbiAgICB9XG5cbiAgICBjYWNoZUN1cnJlbnRTdHlsZShub2RlKSB7XG4gICAgICAgIHRoaXMuc3R5bGVCb3JkZXJUb3BXaWR0aCA9IG5vZGUuc3R5bGUuYm9yZGVyVG9wV2lkdGg7XG4gICAgICAgIHRoaXMuc3R5bGVQYWRkaW5nVG9wID0gbm9kZS5zdHlsZS5wYWRkaW5nVG9wO1xuICAgICAgICB0aGlzLnN0eWxlSGVpZ2h0ID0gbm9kZS5zdHlsZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuc3R5bGVQYWRkaW5nQm90dG9tID0gbm9kZS5zdHlsZS5wYWRkaW5nQm90dG9tO1xuICAgICAgICB0aGlzLnN0eWxlQm9yZGVyQm90dG9tV2lkdGggPSBub2RlLnN0eWxlLmJvcmRlckJvdHRvbVdpZHRoO1xuICAgIH1cblxuICAgIGNhY2hlQ29tcHV0ZWRTdHlsZShub2RlKSB7XG4gICAgICAgIHRoaXMuYm9yZGVyVG9wV2lkdGggPSBnZXRTdHlsZShub2RlLCAnYm9yZGVyVG9wV2lkdGgnKTtcbiAgICAgICAgdGhpcy5wYWRkaW5nVG9wID0gZ2V0U3R5bGUobm9kZSwgJ3BhZGRpbmdUb3AnKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBub2RlLm9mZnNldEhlaWdodDtcbiAgICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gZ2V0U3R5bGUobm9kZSwgJ3BhZGRpbmdCb3R0b20nKTtcbiAgICAgICAgdGhpcy5ib3JkZXJCb3R0b21XaWR0aCA9IGdldFN0eWxlKG5vZGUsICdib3JkZXJCb3R0b21XaWR0aCcpO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRTdHlsZVRvWmVybyhub2RlKSB7XG4gICAgICAgIG5vZGUuc3R5bGUuYm9yZGVyVG9wV2lkdGggPSAnMHB4JztcbiAgICAgICAgbm9kZS5zdHlsZS5wYWRkaW5nVG9wID0gJzBweCc7XG4gICAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gJzBweCc7XG4gICAgICAgIG5vZGUuc3R5bGUucGFkZGluZ0JvdHRvbSA9ICcwcHgnO1xuICAgICAgICBub2RlLnN0eWxlLmJvcmRlckJvdHRvbVdpZHRoID0gJzBweCc7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudFN0eWxlVG9Db21wdXRlZFN0eWxlKG5vZGUpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5ib3JkZXJUb3BXaWR0aCA9IGAke3RoaXMuYm9yZGVyVG9wV2lkdGh9cHhgO1xuICAgICAgICBub2RlLnN0eWxlLnBhZGRpbmdUb3AgPSBgJHt0aGlzLnBhZGRpbmdUb3B9cHhgO1xuICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9IGAke3RoaXMuaGVpZ2h0fXB4YDtcbiAgICAgICAgbm9kZS5zdHlsZS5wYWRkaW5nQm90dG9tID0gYCR7dGhpcy5wYWRkaW5nQm90dG9tfXB4YDtcbiAgICAgICAgbm9kZS5zdHlsZS5ib3JkZXJCb3R0b21XaWR0aCA9IGAke3RoaXMuYm9yZGVyQm90dG9tV2lkdGh9cHhgO1xuICAgIH1cblxuICAgIHJlc3RvcmVDdXJyZW50U3R5bGUobm9kZSkge1xuICAgICAgICBub2RlLnN0eWxlLmJvcmRlclRvcFdpZHRoID0gdGhpcy5zdHlsZUJvcmRlclRvcFdpZHRoO1xuICAgICAgICBub2RlLnN0eWxlLnBhZGRpbmdUb3AgPSB0aGlzLnN0eWxlUGFkZGluZ1RvcDtcbiAgICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSB0aGlzLnN0eWxlSGVpZ2h0O1xuICAgICAgICBub2RlLnN0eWxlLnBhZGRpbmdCb3R0b20gPSB0aGlzLnN0eWxlUGFkZGluZ0JvdHRvbTtcbiAgICAgICAgbm9kZS5zdHlsZS5ib3JkZXJCb3R0b21XaWR0aCA9IHRoaXMuc3R5bGVCb3JkZXJCb3R0b21XaWR0aDtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IG5ld0FuaW1hdGlvbiA9IGFuaW1hdGlvbiB8fCAnZXhwYW5kJztcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEFuaW1hdGUgey4uLm90aGVyc31cbiAgICAgICAgICAgICAgICBhbmltYXRpb249e25ld0FuaW1hdGlvbn1cbiAgICAgICAgICAgICAgICBiZWZvcmVFbnRlcj17dGhpcy5iZWZvcmVFbnRlcn1cbiAgICAgICAgICAgICAgICBvbkVudGVyPXt0aGlzLm9uRW50ZXJ9XG4gICAgICAgICAgICAgICAgYWZ0ZXJFbnRlcj17dGhpcy5hZnRlckVudGVyfVxuICAgICAgICAgICAgICAgIGJlZm9yZUxlYXZlPXt0aGlzLmJlZm9yZUxlYXZlfVxuICAgICAgICAgICAgICAgIG9uTGVhdmU9e3RoaXMub25MZWF2ZX1cbiAgICAgICAgICAgICAgICBhZnRlckxlYXZlPXt0aGlzLmFmdGVyTGVhdmV9IC8+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FuaW1hdGUvZXhwYW5kLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENoZWNrYWJsZUl0ZW0gZnJvbSAnLi9jaGVja2FibGUtaXRlbSc7XG5cbi8qKlxuICogTWVudS5DaGVja2JveEl0ZW1cbiAqIEBvcmRlciAzXG4gKiBAZGVzY3JpcHRpb24g6K+l5a2Q57uE5Lu26YCJ5Lit5oOF5Ya15LiN5Y+XIGRlZmF1bHRTZWxlY3RlZEtleXMvc2VsZWN0ZWRLZXlzIOaOp+WItu+8jOivt+iHquihjOaOp+WItumAieS4remAu+i+kVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGVja2JveEl0ZW0gZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBtZW51Q2hpbGRUeXBlID0gJ2l0ZW0nO1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpumAieS4rVxuICAgICAgICAgKi9cbiAgICAgICAgY2hlY2tlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbljYrpgInkuK1cbiAgICAgICAgICovXG4gICAgICAgIGluZGV0ZXJtaW5hdGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm56aB55SoXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpgInkuK3miJblj5bmtojpgInkuK3op6blj5HnmoTlm57osIPlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBjaGVja2VkIOaYr+WQpumAieS4rVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg6YCJ5Lit5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDluK7liqnmlofmnKxcbiAgICAgICAgICovXG4gICAgICAgIGhlbHBlcjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmoIfnrb7lhoXlrrlcbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgY2hlY2tib3hEaXNhYmxlZDogUHJvcFR5cGVzLmJvb2xcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgY2hlY2tlZDogZmFsc2UsXG4gICAgICAgIGluZGV0ZXJtaW5hdGU6IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIG9uQ2hhbmdlOiAoKSA9PiB7fSxcbiAgICAgICAgY2hlY2tib3hEaXNhYmxlZDogZmFsc2VcbiAgICB9O1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGNoZWNrYm94RGlzYWJsZWQsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuIDxDaGVja2FibGVJdGVtIHJvbGU9XCJtZW51aXRlbWNoZWNrYm94XCIgY2hlY2tUeXBlPVwiY2hlY2tib3hcIiBjaGVja0Rpc2FibGVkPXtjaGVja2JveERpc2FibGVkfSB7Li4ub3RoZXJzfSAvPjtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWVudS92aWV3L2NoZWNrYm94LWl0ZW0uanN4IiwiaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgQ29uZmlnUHJvdmlkZXIgZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCB7IG9iaiB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IENoZWNrYm94IGZyb20gJy4vY2hlY2tib3gnO1xuXG5jb25zdCB7IHBpY2tPdGhlcnMgfSA9IG9iajtcblxuLyoqIENoZWNrYm94Lkdyb3VwICovXG5jbGFzcyBDaGVja2JveEdyb3VwIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieexu+WQjVxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ5YaF5pWb5qC35byPXG4gICAgICAgICAqL1xuICAgICAgICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaVtOS9k+emgeeUqFxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5Y+v6YCJ6aG55YiX6KGoLCDmlbDmja7pobnlj6/kuLogU3RyaW5nIOaIluiAhSBPYmplY3QsIOWmgiBgWydhcHBsZScsICdwZWFyJywgJ29yYW5nZSddYCDmiJbogIUgYFt7dmFsdWU6ICdhcHBsZScsIGxhYmVsOiAn6Iu55p6cJyx9LCB7dmFsdWU6ICdwZWFyJywgbGFiZWw6ICfmoqgnfSwge3ZhbHVlOiAnb3JhbmdlJywgbGFiZWw6ICfmqZnlrZAnfV1gXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhU291cmNlOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuYW55KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiiq+mAieS4reeahOWAvOWIl+ihqFxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5hcnJheSwgUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICAgICAgICAvKipcbiAgICAgICAgICog6buY6K6k6KKr6YCJ5Lit55qE5YC85YiX6KGoXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0VmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5hcnJheSwgUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICAgICAgICAvKipcbiAgICAgICAgICog6YCa6L+H5a2Q5YWD57Sg5pa55byP6K6+572u5YaF6YOoIGNoZWNrYm94XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmVsZW1lbnQpLFxuICAgICAgICAvKipcbiAgICAgICAgICog6YCJ5Lit5YC85pS55Y+Y5pe255qE5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlIOmAieS4remhueWIl+ihqFxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIERvbSDkuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5a2Q6aG555uu55qE5o6S5YiX5pa55byPXG4gICAgICAgICAqIC0gaG96OiDmsLTlubPmjpLliJcgKGRlZmF1bHQpXG4gICAgICAgICAqIC0gdmVyOiDlnoLnm7TmjpLliJdcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1EaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbXG4gICAgICAgICAgICAnaG96JyxcbiAgICAgICAgICAgICd2ZXInLFxuICAgICAgICBdKSxcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBkYXRhU291cmNlOiBbXSxcbiAgICAgICAgb25DaGFuZ2U6ICgpID0+IHtcbiAgICAgICAgfSxcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgICAgICBpdGVtRGlyZWN0aW9uOiAnaG96JyxcbiAgICB9XG5cbiAgICBzdGF0aWMgY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgX19ncm91cF9fOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZTogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2xcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgbGV0IHZhbHVlID0gW107XG4gICAgICAgIGlmICgndmFsdWUnIGluIHByb3BzKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKCdkZWZhdWx0VmFsdWUnIGluIHByb3BzKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdmFsdWU6IFsuLi52YWx1ZV0sXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfX2dyb3VwX186IHRydWUsXG4gICAgICAgICAgICBvbkNoYW5nZTogdGhpcy5vbkNoYW5nZSxcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWU6IHRoaXMuc3RhdGUudmFsdWUsXG4gICAgICAgICAgICBkaXNhYmxlZDogdGhpcy5wcm9wcy5kaXNhYmxlZFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIGlmICgndmFsdWUnIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgbGV0IHt2YWx1ZX0gPSBuZXh0UHJvcHM7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25DaGFuZ2UoY3VycmVudFZhbHVlLCBlKSB7XG4gICAgICAgIGNvbnN0IHt2YWx1ZX0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCBpbmRleCA9IHZhbHVlLmluZGV4T2YoY3VycmVudFZhbHVlKTtcbiAgICAgICAgY29uc3QgdmFsVGVtcCA9IFsuLi52YWx1ZV07XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgdmFsVGVtcC5wdXNoKGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWxUZW1wLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISgndmFsdWUnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHt2YWx1ZTogdmFsVGVtcH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UodmFsVGVtcCwgZSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGNsYXNzTmFtZSwgc3R5bGUsIHByZWZpeCwgZGlzYWJsZWQsIGl0ZW1EaXJlY3Rpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IG90aGVycyA9IHBpY2tPdGhlcnMoQ2hlY2tib3hHcm91cC5wcm9wVHlwZXMsIHRoaXMucHJvcHMpO1xuXG4gICAgICAgIC8vIOWmguaenOWGheW1jOagh+etvui3n2RhdGFTb3VyY2XlkIzml7blrZjlnKjvvIzku6XlhoXltYzmoIfnrb7kuLrkuLtcbiAgICAgICAgbGV0IGNoaWxkcmVuO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmRhdGFTb3VyY2UubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBvcHRpb24gPSBpdGVtO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSB0aGlzLnN0YXRlLnZhbHVlICYmIHRoaXMuc3RhdGUudmFsdWUuaW5kZXhPZihvcHRpb24udmFsdWUpID4gLTE7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3gga2V5PXtpbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtvcHRpb24udmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXtjaGVja2VkfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkIHx8IG9wdGlvbi5kaXNhYmxlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPXtvcHRpb24ubGFiZWx9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2xzID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fWNoZWNrYm94LWdyb3VwYF06IHRydWUsXG4gICAgICAgICAgICBbYCR7cHJlZml4fWNoZWNrYm94LWdyb3VwLSR7aXRlbURpcmVjdGlvbn1gXTogdHJ1ZSxcbiAgICAgICAgICAgIFtjbGFzc05hbWVdOiAhIWNsYXNzTmFtZSxcbiAgICAgICAgICAgIGRpc2FibGVkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiA8c3BhbiB7Li4ub3RoZXJzfSBjbGFzc05hbWU9e2Nsc30gc3R5bGU9e3N0eWxlfT57Y2hpbGRyZW59PC9zcGFuPjtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZ1Byb3ZpZGVyLmNvbmZpZyhDaGVja2JveEdyb3VwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jaGVja2JveC9jaGVja2JveC1ncm91cC5qc3giLCJpbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBDb25maWdQcm92aWRlciBmcm9tICcuLi9jb25maWctcHJvdmlkZXInO1xuaW1wb3J0IHsgb2JqIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgUmFkaW8gZnJvbSAnLi9yYWRpbyc7XG5cbmNvbnN0IHsgcGlja090aGVycyB9ID0gb2JqO1xuXG4vKipcbiAqIFJhZGlvLkdyb3VwXG4gKiBAb3JkZXIgMlxuICovXG5jbGFzcyBSYWRpb0dyb3VwIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmoLflvI/nsbvlkI3nmoTlk4HniYzliY3nvIBcbiAgICAgICAgICovXG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieexu+WQjVxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ5YaF5pWb5qC35byPXG4gICAgICAgICAqL1xuICAgICAgICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByYWRpbyBncm91cOeahOmAieS4remhueeahOWAvFxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5ib29sXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByYWRpbyBncm91cOeahOm7mOiupOWAvFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuYm9vbF0pLFxuICAgICAgICAvKipcbiAgICAgICAgICog6YCJ5Lit5YC85pS55Y+Y5pe255qE5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nL051bWJlcn0gdmFsdWUg6YCJ5Lit6aG555qE5YC8XG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRG9tIOS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog6KGo56S6cmFkaW/ooqvnpoHnlKhcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWPr+S7peiuvue9ruaIkCBidXR0b24g5bGV56S65b2i54q2XG4gICAgICAgICAqIEBlbnVtZGVzYyDmjInpkq7nirZcbiAgICAgICAgICovXG4gICAgICAgIHNoYXBlOiBQcm9wVHlwZXMub25lT2YoWydidXR0b24nXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuI4gYHNoYXBlYCDlsZ7mgKfphY3lpZfkvb/nlKjvvIxzaGFwZeiuvuS4umJ1dHRvbuaXtuacieaViFxuICAgICAgICAgKiBAZW51bWRlc2Mg5aSnLCDkuK0sIOWwj1xuICAgICAgICAgKi9cbiAgICAgICAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsnbGFyZ2UnLCAnbWVkaXVtJywgJ3NtYWxsJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5Y+v6YCJ6aG55YiX6KGoLCDmlbDmja7pobnlj6/kuLogU3RyaW5nIOaIluiAhSBPYmplY3QsIOWmgiBgWydhcHBsZScsICdwZWFyJywgJ29yYW5nZSddYFxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YVNvdXJjZTogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmFueSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpgJrov4flrZDlhYPntKDmlrnlvI/orr7nva7lhoXpg6hyYWRpb1xuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5lbGVtZW50KSwgUHJvcFR5cGVzLmVsZW1lbnRdKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5a2Q6aG555uu55qE5o6S5YiX5pa55byPXG4gICAgICAgICAqIC0gaG96OiDmsLTlubPmjpLliJcgKGRlZmF1bHQpXG4gICAgICAgICAqIC0gdmVyOiDlnoLnm7TmjpLliJdcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1EaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbXG4gICAgICAgICAgICAnaG96JyxcbiAgICAgICAgICAgICd2ZXInLFxuICAgICAgICBdKSxcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBkYXRhU291cmNlOiBbXSxcbiAgICAgICAgc2l6ZTogJ21lZGl1bScsXG4gICAgICAgIG9uQ2hhbmdlOiAoKSA9PiB7XG4gICAgICAgIH0sXG4gICAgICAgIHByZWZpeDogJ25leHQtJyxcbiAgICAgICAgaXRlbURpcmVjdGlvbjogJ2hveicsXG4gICAgfVxuXG4gICAgc3RhdGljIGNoaWxkQ29udGV4dFR5cGVzID0ge1xuICAgICAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIF9fZ3JvdXBfXzogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGlzQnV0dG9uOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLmJvb2xdKSxcbiAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sXG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgaWYgKCd2YWx1ZScgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2RlZmF1bHRWYWx1ZScgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7dmFsdWV9O1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gdGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9fZ3JvdXBfXzogdHJ1ZSxcbiAgICAgICAgICAgIGlzQnV0dG9uOiB0aGlzLnByb3BzLnNoYXBlID09PSAnYnV0dG9uJyxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLm9uQ2hhbmdlLFxuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZTogdGhpcy5zdGF0ZS52YWx1ZSxcbiAgICAgICAgICAgIGRpc2FibGVkOiB0aGlzLnByb3BzLmRpc2FibGVkXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgbGV0IHt2YWx1ZX0gPSBuZXh0UHJvcHM7XG4gICAgICAgIGlmICgndmFsdWUnIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25DaGFuZ2UoY3VycmVudFZhbHVlLCBlKSB7XG4gICAgICAgIGlmICghKCd2YWx1ZScgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe3ZhbHVlOiBjdXJyZW50VmFsdWV9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudFZhbHVlICE9PSB0aGlzLnN0YXRlLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKGN1cnJlbnRWYWx1ZSwgZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcnRsLCBjbGFzc05hbWUsIHNoYXBlLCBzaXplLCBzdHlsZSwgcHJlZml4LCBpdGVtRGlyZWN0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBvdGhlcnMgPSBwaWNrT3RoZXJzKE9iamVjdC5rZXlzKFJhZGlvR3JvdXAucHJvcFR5cGVzKSwgdGhpcy5wcm9wcyk7XG4gICAgICAgIGNvbnN0IGRpc2FibGVkID0gdGhpcy5wcm9wcy5kaXNhYmxlZDtcblxuICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgICBvdGhlcnMuZGlyID0gJ3J0bCc7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2hpbGRyZW47XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMucHJvcHMuZGF0YVNvdXJjZS5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG9wdGlvbiA9IGl0ZW07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IHRoaXMuc3RhdGUudmFsdWUgPT09IG9wdGlvbi52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDxSYWRpb1xuICAgICAgICAgICAgICAgICAgICBrZXk9e2luZGV4fVxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleD17KChpbmRleCA9PT0gMCAmJiAhdGhpcy5zdGF0ZS52YWx1ZSkgfHwgY2hlY2tlZCkgPyAwIDogLTF9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtvcHRpb24udmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2NoZWNrZWR9XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPXtvcHRpb24ubGFiZWx9XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZCB8fCBvcHRpb24uZGlzYWJsZWR9XG4gICAgICAgICAgICAgICAgLz4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc0J1dHRvblNoYXBlID0gc2hhcGUgPT09ICdidXR0b24nO1xuXG4gICAgICAgIGNvbnN0IGNscyA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1yYWRpby1ncm91cGBdOiB0cnVlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1yYWRpby1ncm91cC0ke2l0ZW1EaXJlY3Rpb259YF06ICFpc0J1dHRvblNoYXBlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1yYWRpby1idXR0b25gXTogaXNCdXR0b25TaGFwZSxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9cmFkaW8tYnV0dG9uLSR7c2l6ZX1gXTogaXNCdXR0b25TaGFwZSxcbiAgICAgICAgICAgIFtjbGFzc05hbWVdOiAhIWNsYXNzTmFtZSxcbiAgICAgICAgICAgIGRpc2FibGVkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiA8ZGl2IHsuLi5vdGhlcnN9IGFyaWEtZGlzYWJsZWQ9e2Rpc2FibGVkfSByb2xlPVwicmFkaW9ncm91cFwiIGNsYXNzTmFtZT17Y2xzfSBzdHlsZT17c3R5bGV9PntjaGlsZHJlbn08L2Rpdj47XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb25maWdQcm92aWRlci5jb25maWcoUmFkaW9Hcm91cCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmFkaW8vcmFkaW8tZ3JvdXAuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQ2hlY2thYmxlSXRlbSBmcm9tICcuL2NoZWNrYWJsZS1pdGVtJztcblxuLyoqXG4gKiBNZW51LlJhZGlvSXRlbVxuICogQG9yZGVyIDRcbiAqIEBkZXNjcmlwdGlvbiDor6XlrZDnu4Tku7bpgInkuK3mg4XlhrXkuI3lj5cgZGVmYXVsdFNlbGVjdGVkS2V5cy9zZWxlY3RlZEtleXMg5o6n5Yi277yM6K+36Ieq6KGM5o6n5Yi26YCJ5Lit6YC76L6RXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhZGlvSXRlbSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIG1lbnVDaGlsZFR5cGUgPSAnaXRlbSc7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm6YCJ5LitXG4gICAgICAgICAqL1xuICAgICAgICBjaGVja2VkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuemgeeUqFxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6YCJ5Lit5oiW5Y+W5raI6YCJ5Lit6Kem5Y+R55qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2hlY2tlZCDmmK/lkKbpgInkuK1cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOmAieS4reS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5biu5Yqp5paH5pysXG4gICAgICAgICAqL1xuICAgICAgICBoZWxwZXI6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICAvKipcbiAgICAgICAgICog5qCH562+5YaF5a65XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgY2hlY2tlZDogZmFsc2UsXG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgb25DaGFuZ2U6ICgpID0+IHt9XG4gICAgfTtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIDxDaGVja2FibGVJdGVtIHJvbGU9XCJtZW51aXRlbXJhZGlvXCIgY2hlY2tUeXBlPVwicmFkaW9cIiB7Li4udGhpcy5wcm9wc30gLz47XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21lbnUvdmlldy9yYWRpby1pdGVtLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIGNsb25lRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgSXRlbSBmcm9tICcuL2l0ZW0nO1xuXG4vKipcbiAqIE1lbnUuR3JvdXBcbiAqIEBvcmRlciA1XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyb3VwIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgbWVudUNoaWxkVHlwZSA9ICdncm91cCc7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICByb290OiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmoIfnrb7lhoXlrrlcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiPnOWNlemhuVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICBwYXJlbnRNb2RlOiBQcm9wVHlwZXMub25lT2YoWydpbmxpbmUnLCAncG9wdXAnXSksXG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHJvb3QsIGNsYXNzTmFtZSwgbGFiZWwsIGNoaWxkcmVuLCBwYXJlbnRNb2RlLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4IH0gPSByb290LnByb3BzO1xuXG4gICAgICAgIGNvbnN0IG5ld0NsYXNzTmFtZSA9IGN4KHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9bWVudS1ncm91cC1sYWJlbGBdOiB0cnVlLFxuICAgICAgICAgICAgW2NsYXNzTmFtZV06ICEhY2xhc3NOYW1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG5ld0NoaWxkcmVuID0gY2hpbGRyZW4ubWFwKGNoaWxkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2xhc3NOYW1lIH0gPSBjaGlsZC5wcm9wcztcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkQ2xhc3NOYW1lID0gY3goe1xuICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9bWVudS1ncm91cC1pdGVtYF06IHRydWUsXG4gICAgICAgICAgICAgICAgW2NsYXNzTmFtZV06ICEhY2xhc3NOYW1lXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgICAgICAgIHBhcmVudE1vZGUsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBuZXdDaGlsZENsYXNzTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICA8SXRlbVxuICAgICAgICAgICAgICAgIGtleT1cIm1lbnUtZ3JvdXAtbGFiZWxcIlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17bmV3Q2xhc3NOYW1lfVxuICAgICAgICAgICAgICAgIHJlcGxhY2VDbGFzc05hbWVcbiAgICAgICAgICAgICAgICByb290PXtyb290fVxuICAgICAgICAgICAgICAgIHBhcmVudE1vZGU9e3BhcmVudE1vZGV9XG4gICAgICAgICAgICAgICAgey4uLm90aGVyc30+e2xhYmVsfTwvSXRlbT4sXG4gICAgICAgICAgICAuLi5uZXdDaGlsZHJlblxuICAgICAgICBdO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tZW51L3ZpZXcvZ3JvdXAuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5cbi8qKlxuICogTWVudS5EaXZpZGVyXG4gKiBAb3JkZXIgNlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXZpZGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgbWVudUNoaWxkVHlwZSA9ICdkaXZpZGVyJztcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHJvb3Q6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcm9vdCwgY2xhc3NOYW1lLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4IH0gPSByb290LnByb3BzO1xuXG4gICAgICAgIGNvbnN0IG5ld0NsYXNzTmFtZSA9IGN4KHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9bWVudS1kaXZpZGVyYF06IHRydWUsXG4gICAgICAgICAgICBbY2xhc3NOYW1lXTogISFjbGFzc05hbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxsaSByb2xlPVwic2VwYXJhdG9yXCIgY2xhc3NOYW1lPXtuZXdDbGFzc05hbWV9IHsuLi5vdGhlcnN9PjwvbGk+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21lbnUvdmlldy9kaXZpZGVyLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyByZW5kZXIsIHVubW91bnRDb21wb25lbnRBdE5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBPdmVybGF5IGZyb20gJy4uLy4uL292ZXJsYXknO1xuaW1wb3J0IHsgZnVuYyB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IENvbmZpZ1Byb3ZpZGVyIGZyb20gJy4uLy4uL2NvbmZpZy1wcm92aWRlcic7XG5pbXBvcnQgbWVudSBmcm9tICcuL21lbnUnO1xuXG5jb25zdCB7IGJpbmRDdHggfSA9IGZ1bmM7XG5jb25zdCB7IGdldENvbnRleHRQcm9wcyB9ID0gQ29uZmlnUHJvdmlkZXI7XG5jb25zdCBNZW51ID0gQ29uZmlnUHJvdmlkZXIuY29uZmlnKG1lbnUpO1xuXG5sZXQgbWVudUluc3RhbmNlO1xuXG5jbGFzcyBDb250ZXh0TWVudSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBwb3B1cENsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgdGFyZ2V0OiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBhbGlnbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgb2Zmc2V0OiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIG92ZXJsYXlQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgYWZ0ZXJDbG9zZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG1vZGU6IFByb3BUeXBlcy5vbmVPZihbJ2lubGluZScsICdwb3B1cCddKSxcbiAgICAgICAgb25PcGVuOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25JdGVtQ2xpY2s6IFByb3BUeXBlcy5mdW5jXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHByZWZpeDogJ25leHQtJyxcbiAgICAgICAgYWxpZ246ICd0bCB0bCcsXG4gICAgICAgIG1vZGU6ICdwb3B1cCdcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgYmluZEN0eCh0aGlzLCBbJ2hhbmRsZU92ZXJsYXlDbG9zZScsICdoYW5kbGVPdmVybGF5T3BlbicsICdoYW5kbGVJdGVtQ2xpY2snLCAnZ2V0T3ZlcmxheSddKTtcbiAgICB9XG5cbiAgICBnZXRPdmVybGF5KHJlZikge1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSByZWY7XG4gICAgfVxuXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIG1lbnVJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaGFuZGxlT3ZlcmxheUNsb3NlKHRyaWdnZXJUeXBlLCBlLCAuLi5vdGhlcnMpIHtcbiAgICAgICAgY29uc3QgY2xpY2tlZFBvcHVwTWVudSA9IHRyaWdnZXJUeXBlID09PSAnZG9jQ2xpY2snICYmXG4gICAgICAgICAgICB0aGlzLnBvcHVwTm9kZXMuc29tZShub2RlID0+IG5vZGUuY29udGFpbnMoZS50YXJnZXQpKTtcbiAgICAgICAgaWYgKCFjbGlja2VkUG9wdXBNZW51KSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICBjb25zdCB7IG92ZXJsYXlQcm9wcyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChvdmVybGF5UHJvcHMgJiYgb3ZlcmxheVByb3BzLm9uUmVxdWVzdENsb3NlKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheVByb3BzLm9uUmVxdWVzdENsb3NlKHRyaWdnZXJUeXBlLCBlLCAuLi5vdGhlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlT3ZlcmxheU9wZW4oKSB7XG4gICAgICAgIHRoaXMucG9wdXBOb2RlcyA9IHRoaXMub3ZlcmxheS5nZXRJbnN0YW5jZSgpLmdldENvbnRlbnQoKS5nZXRJbnN0YW5jZSgpLnBvcHVwTm9kZXM7XG4gICAgICAgIGNvbnN0IHsgb3ZlcmxheVByb3BzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAob3ZlcmxheVByb3BzICYmIG92ZXJsYXlQcm9wcy5vbk9wZW4pIHtcbiAgICAgICAgICAgIG92ZXJsYXlQcm9wcy5vbk9wZW4oKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgaGFuZGxlSXRlbUNsaWNrKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuXG4gICAgICAgIHRoaXMucHJvcHMub25JdGVtQ2xpY2sgJiYgdGhpcy5wcm9wcy5vbkl0ZW1DbGljayguLi5hcmdzKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY2xhc3NOYW1lLCBwb3B1cENsYXNzTmFtZSwgdGFyZ2V0LCBhbGlnbiwgb2Zmc2V0LCBhZnRlckNsb3NlLCBvdmVybGF5UHJvcHMgPSB7fSwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBjb250ZXh0UHJvcHMgPSBnZXRDb250ZXh0UHJvcHModGhpcy5wcm9wcyk7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4IH0gPSBjb250ZXh0UHJvcHM7XG4gICAgICAgIGNvbnN0IHsgdmlzaWJsZSB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBjb25zdCBuZXdPdmVybGF5UHJvcHMgPSB7XG4gICAgICAgICAgICAuLi5jb250ZXh0UHJvcHMsXG4gICAgICAgICAgICAuLi5vdmVybGF5UHJvcHMsXG4gICAgICAgICAgICB0YXJnZXQsIGFsaWduLCBvZmZzZXQsIGFmdGVyQ2xvc2UsIHZpc2libGUsXG4gICAgICAgICAgICBvblJlcXVlc3RDbG9zZTogdGhpcy5oYW5kbGVPdmVybGF5Q2xvc2UsXG4gICAgICAgICAgICBvbk9wZW46IHRoaXMuaGFuZGxlT3ZlcmxheU9wZW4sXG4gICAgICAgICAgICByZWY6IHRoaXMuZ2V0T3ZlcmxheVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtZW51UHJvcHMgPSB7XG4gICAgICAgICAgICAuLi5jb250ZXh0UHJvcHMsXG4gICAgICAgICAgICB0cmlnZ2VyVHlwZTogJ2hvdmVyJyxcbiAgICAgICAgICAgIC4uLm90aGVycyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY3goe1xuICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9Y29udGV4dGBdOiB0cnVlLFxuICAgICAgICAgICAgICAgIFtjbGFzc05hbWVdOiAhIWNsYXNzTmFtZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwb3B1cENsYXNzTmFtZTogY3goe1xuICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9Y29udGV4dGBdOiB0cnVlLFxuICAgICAgICAgICAgICAgIFtwb3B1cENsYXNzTmFtZV06ICEhcG9wdXBDbGFzc05hbWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb25JdGVtQ2xpY2s6IHRoaXMuaGFuZGxlSXRlbUNsaWNrXG4gICAgICAgIH07XG5cbiAgICAgICAgbmV3T3ZlcmxheVByb3BzLnJ0bCA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8T3ZlcmxheSB7Li4ubmV3T3ZlcmxheVByb3BzfT5cbiAgICAgICAgICAgICAgICA8TWVudSB7Li4ubWVudVByb3BzfSAvPlxuICAgICAgICAgICAgPC9PdmVybGF5PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiDliJvlu7rkuIrkuIvmlofoj5zljZVcbiAqIEBleHBvcnROYW1lIGNyZWF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIOWxnuaAp+WvueixoVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGUocHJvcHMpIHtcbiAgICBpZiAobWVudUluc3RhbmNlKSB7XG4gICAgICAgIG1lbnVJbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICBjb25zdCB7IGFmdGVyQ2xvc2UsIC4uLm90aGVycyB9ID0gcHJvcHM7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuXG4gICAgY29uc3QgY2xvc2VDaGFpbiA9ICgpID0+IHtcbiAgICAgICAgdW5tb3VudENvbXBvbmVudEF0Tm9kZShkaXYpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG5cbiAgICAgICAgYWZ0ZXJDbG9zZSAmJiBhZnRlckNsb3NlKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG5ld0NvbnRleHQgPSBDb25maWdQcm92aWRlci5nZXRDb250ZXh0KCk7XG5cbiAgICBsZXQgbWVudTtcbiAgICByZW5kZXIoXG4gICAgICAgIDxDb25maWdQcm92aWRlciB7Li4ubmV3Q29udGV4dH0+XG4gICAgICAgICAgICA8Q29udGV4dE1lbnUgcmVmPXtyZWYgPT4ge1xuICAgICAgICAgICAgICAgIG1lbnUgPSByZWY7XG4gICAgICAgICAgICB9fSBhZnRlckNsb3NlPXtjbG9zZUNoYWlufSB7Li4ub3RoZXJzfSAvPlxuICAgICAgICA8L0NvbmZpZ1Byb3ZpZGVyPlxuICAgICAgICAsIGRpdlxuICAgICk7XG5cbiAgICBtZW51SW5zdGFuY2UgPSB7XG4gICAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChtZW51KSB7XG4gICAgICAgICAgICAgICAgbWVudS5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBtZW51SW5zdGFuY2U7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWVudS92aWV3L2NyZWF0ZS5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcblxuZnVuY3Rpb24gbWFwSWNvblNpemUoc2l6ZSkge1xuICAgIHJldHVybiAoe1xuICAgICAgICBsYXJnZTogJ3NtYWxsJyxcbiAgICAgICAgbWVkaXVtOiAneHMnLFxuICAgICAgICBzbWFsbDogJ3hzJyxcbiAgICB9KVtzaXplXTtcbn1cblxuLyoqIEJ1dHRvbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnV0dG9uIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmjInpkq7nmoTnsbvlnotcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6IFByb3BUeXBlcy5vbmVPZihbJ3ByaW1hcnknLCAnc2Vjb25kYXJ5JywgJ25vcm1hbCddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaMiemSrueahOWwuuWvuFxuICAgICAgICAgKi9cbiAgICAgICAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsnc21hbGwnLCAnbWVkaXVtJywgJ2xhcmdlJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5oyJ6ZKu5LitIEljb24g55qE5bC65a+477yM55So5LqO5pu/5LujIEljb24g55qE6buY6K6k5aSn5bCPXG4gICAgICAgICAqL1xuICAgICAgICBpY29uU2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsneHhzJywgJ3hzJywgJ3NtYWxsJywgJ21lZGl1bScsICdsYXJnZScsICd4bCcsICd4eGwnLCAneHh4bCddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW9kyBjb21wb25lbnQgPSAnYnV0dG9uJyDml7bvvIzorr7nva4gYnV0dG9uIOagh+etvueahCB0eXBlIOWAvFxuICAgICAgICAgKi9cbiAgICAgICAgaHRtbFR5cGU6IFByb3BUeXBlcy5vbmVPZihbJ3N1Ym1pdCcsICdyZXNldCcsICdidXR0b24nXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7moIfnrb7nsbvlnotcbiAgICAgICAgICovXG4gICAgICAgIGNvbXBvbmVudDogUHJvcFR5cGVzLm9uZU9mKFsnYnV0dG9uJywgJ2EnXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7mjInpkq7nmoTovb3lhaXnirbmgIFcbiAgICAgICAgICovXG4gICAgICAgIGxvYWRpbmc6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5Li65bm954G15oyJ6ZKuXG4gICAgICAgICAqL1xuICAgICAgICBnaG9zdDogUHJvcFR5cGVzLm9uZU9mKFt0cnVlLCBmYWxzZSwgJ2xpZ2h0JywgJ2RhcmsnXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbkuLrmlofmnKzmjInpkq5cbiAgICAgICAgICovXG4gICAgICAgIHRleHQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5Li66K2m5ZGK5oyJ6ZKuXG4gICAgICAgICAqL1xuICAgICAgICB3YXJuaW5nOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuemgeeUqFxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog54K55Ye75oyJ6ZKu55qE5Zue6LCDXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIEV2ZW50IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgb25Nb3VzZVVwOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHByZWZpeDogJ25leHQtJyxcbiAgICAgICAgdHlwZTogJ25vcm1hbCcsXG4gICAgICAgIHNpemU6ICdtZWRpdW0nLFxuICAgICAgICBodG1sVHlwZTogJ2J1dHRvbicsXG4gICAgICAgIGNvbXBvbmVudDogJ2J1dHRvbicsXG4gICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICBnaG9zdDogZmFsc2UsXG4gICAgICAgIHRleHQ6IGZhbHNlLFxuICAgICAgICB3YXJuaW5nOiBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBvbkNsaWNrOiAoKSA9PiB7fVxuICAgIH07XG5cbiAgICBvbk1vdXNlVXAgPSAoZSkgPT4ge1xuICAgICAgICB0aGlzLmJ1dHRvbi5ibHVyKCk7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25Nb3VzZVVwKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uTW91c2VVcChlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBidXR0b25SZWZIYW5kbGVyID0gKGJ1dHRvbikgPT4ge1xuICAgICAgICB0aGlzLmJ1dHRvbiA9IGJ1dHRvbjtcbiAgICB9O1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgY2xhc3NOYW1lLCB0eXBlLCBzaXplLCBodG1sVHlwZSwgbG9hZGluZywgdGV4dCwgd2FybmluZywgZ2hvc3QsIGNvbXBvbmVudCwgaWNvblNpemUsIGNoaWxkcmVuLCBydGwsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgZ2hvc3RUeXBlID0gWydsaWdodCcsICdkYXJrJ10uaW5kZXhPZihnaG9zdCkgPj0gMCA/IGdob3N0IDogJ2RhcmsnO1xuXG4gICAgICAgIGNvbnN0IGJ0bkNscyA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1idG5gXTogdHJ1ZSxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9JHtzaXplfWBdOiBzaXplLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1idG4tJHt0eXBlfWBdOiB0eXBlICYmICFnaG9zdCxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9YnRuLXRleHRgXTogdGV4dCxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9YnRuLXdhcm5pbmdgXTogd2FybmluZyxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9YnRuLWxvYWRpbmdgXTogbG9hZGluZyxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9YnRuLWdob3N0YF06IGdob3N0LFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1idG4tJHtnaG9zdFR5cGV9YF06IGdob3N0LFxuICAgICAgICAgICAgW2NsYXNzTmFtZV06IGNsYXNzTmFtZVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBjb3VudCA9IENoaWxkcmVuLmNvdW50KGNoaWxkcmVuKTtcbiAgICAgICAgY29uc3QgY2xvbmVkQ2hpbGRyZW4gPSBDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiB0eXBlb2YgY2hpbGQudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiBjaGlsZC50eXBlLl90eXBlTWFyayA9PT0gJ2ljb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWNvbkNscyA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4fWJ0bi1pY29uYF06ICFpY29uU2l6ZSwgLy8g5aaC5p6c55So5oi35rKh5pyJ5LygIGljb25TaXpl77yM5YiZ5L2/55So6K+l5qC35byP5qCH6K6wIGljb24g5Li6IGJ1dHRvbiDpooTorr7lsLrlr7hcbiAgICAgICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1pY29uLWZpcnN0YF06IGNvdW50ID4gMSAmJiBpbmRleCA9PT0gMCxcbiAgICAgICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1pY29uLWxhc3RgXTogY291bnQgPiAxICYmIGluZGV4ID09PSBjb3VudCAtIDEsXG4gICAgICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9aWNvbi1hbG9uZWBdOiBjb3VudCA9PT0gMSxcbiAgICAgICAgICAgICAgICAgICAgW2NoaWxkLnByb3BzLmNsYXNzTmFtZV06ICEhY2hpbGQucHJvcHMuY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGljb25DbHMsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGljb25TaXplIHx8IG1hcEljb25TaXplKHNpemUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgVGFnTmFtZSA9IGNvbXBvbmVudDtcbiAgICAgICAgY29uc3QgdGFnQXR0cnMgPSB7XG4gICAgICAgICAgICAuLi5vdGhlcnMsXG4gICAgICAgICAgICB0eXBlOiBodG1sVHlwZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogYnRuQ2xzXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKFRhZ05hbWUgPT09ICdhJykge1xuICAgICAgICAgICAgZGVsZXRlIHRhZ0F0dHJzLnR5cGU7XG5cbiAgICAgICAgICAgIGlmICh0YWdBdHRycy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0YWdBdHRycy5vbkNsaWNrOyAvLyBhIOagh+etvueahCBvbkNsaWNrIOa1j+iniOWZqOm7mOiupOS4jeS8muemgeeUqFxuICAgICAgICAgICAgICAgIHRhZ0F0dHJzLmhyZWYgJiYgZGVsZXRlIHRhZ0F0dHJzLmhyZWY7IC8vIGEg5qCH562+5Zyo56aB55So54q25oCB5LiL5peg6Lez6L2sXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPFRhZ05hbWUgey4uLnRhZ0F0dHJzfSBkaXI9e3J0bCA/ICdydGwnIDogdW5kZWZpbmVkfSBvbk1vdXNlVXA9e3RoaXMub25Nb3VzZVVwfSByZWY9e3RoaXMuYnV0dG9uUmVmSGFuZGxlcn0gcm9sZT1cImJ1dHRvblwiPlxuICAgICAgICAgICAgICAgIHtjbG9uZWRDaGlsZHJlbn1cbiAgICAgICAgICAgIDwvVGFnTmFtZT5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYnV0dG9uL3ZpZXcvYnV0dG9uLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IENvbmZpZ1Byb3ZpZGVyIGZyb20gJy4uLy4uL2NvbmZpZy1wcm92aWRlcic7XG5cbi8qKlxuICogQnV0dG9uLkdyb3VwXG4gKi9cbmNsYXNzIEJ1dHRvbkdyb3VwIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBydGw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnu5/kuIDorr7nva4gQnV0dG9uIOe7hOS7tueahOaMiemSruWkp+Wwj1xuICAgICAgICAgKi9cbiAgICAgICAgc2l6ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgICAgICBzaXplOiAnbWVkaXVtJyxcbiAgICB9O1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgY2xhc3NOYW1lLCBzaXplLCBjaGlsZHJlbiwgcnRsLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgY29uc3QgZ3JvdXBDbHMgPSBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9YnRuLWdyb3VwYF06IHRydWUsXG4gICAgICAgICAgICBbY2xhc3NOYW1lXTogY2xhc3NOYW1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGNsb25lQ2hpbGRyZW4gPSBDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChydGwpIHtcbiAgICAgICAgICAgIG90aGVycy5kaXIgPSAncnRsJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IHsuLi5vdGhlcnN9IGNsYXNzTmFtZT17Z3JvdXBDbHN9PlxuICAgICAgICAgICAgICAgIHtjbG9uZUNoaWxkcmVufVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb25maWdQcm92aWRlci5jb25maWcoQnV0dG9uR3JvdXApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2J1dHRvbi92aWV3L2dyb3VwLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgVCBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGV2ZW50cywgZG9tIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5cbmNsYXNzIFJlc2l6ZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgcHJlZml4OiBULnN0cmluZyxcbiAgICAgICAgb25DaGFuZ2U6IFQuZnVuYyxcbiAgICAgICAgZGF0YUluZGV4OiBULnN0cmluZ1xuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBvbkNoYW5nZTogKCkgPT4ge31cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuZGVzdG9yeSgpO1xuICAgIH1cbiAgICBvbk1vdXNlRG93biA9IChlKSA9PiB7XG4gICAgICAgIHRoaXMubGFzdFBhZ2VYID0gZS5wYWdlWDtcbiAgICAgICAgZXZlbnRzLm9uKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICAgIGV2ZW50cy5vbihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgICAgIHRoaXMudW5TZWxlY3QoKTtcbiAgICB9XG4gICAgb25Nb3VzZU1vdmUgPSAoZSkgPT4ge1xuICAgICAgICBjb25zdCBwYWdlWCA9IGUucGFnZVg7XG4gICAgICAgIGNvbnN0IGNoYW5nZWRQYWdlWCA9IHBhZ2VYIC0gdGhpcy5sYXN0UGFnZVg7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UodGhpcy5wcm9wcy5kYXRhSW5kZXgsIGNoYW5nZWRQYWdlWCk7XG4gICAgICAgIHRoaXMubGFzdFBhZ2VYID0gcGFnZVg7XG4gICAgfVxuICAgIG9uTW91c2VVcCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5kZXN0b3J5KCk7XG4gICAgfVxuICAgIGRlc3RvcnkoKSB7XG4gICAgICAgIGV2ZW50cy5vZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgZXZlbnRzLm9mZihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgdGhpcy5zZWxlY3QoKTtcbiAgICB9XG4gICAgdW5TZWxlY3QoKSB7XG4gICAgICAgIGRvbS5zZXRTdHlsZShkb2N1bWVudC5ib2R5LCB7XG4gICAgICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICAgICAgICBjdXJzb3I6ICdldy1yZXNpemUnXG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZSgndW5zZWxlY3RhYmxlJywgJ29uJyk7XG4gICAgfVxuICAgIHNlbGVjdCgpIHtcbiAgICAgICAgZG9tLnNldFN0eWxlKGRvY3VtZW50LmJvZHksIHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Q6ICcnLFxuICAgICAgICAgICAgY3Vyc29yOiAnJ1xuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVBdHRyaWJ1dGUoJ3Vuc2VsZWN0YWJsZScpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gPGEgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtcmVzaXplLWhhbmRsZXJgfSBvbk1vdXNlRG93bj17dGhpcy5vbk1vdXNlRG93bn0+PC9hPjtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlc2l6ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9iYXNlL3Jlc2l6ZS5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcHJlZmVyLXN0YXRlbGVzcy1mdW5jdGlvbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV3JhcHBlciBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7Y29sR3JvdXAsIGNoaWxkcmVuLCBjb21wb25lbnQ6IFRhZ30gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKDxUYWcgcm9sZT1cInRhYmxlXCI+XG4gICAgICAgICAgICB7Y29sR3JvdXB9XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvVGFnPik7XG4gICAgfVxufVxuXG5XcmFwcGVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21wb25lbnQ6ICd0YWJsZSdcbn07XG5cbldyYXBwZXIucHJvcFR5cGVzID0ge1xuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55LFxuICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjb2xHcm91cDogUHJvcFR5cGVzLmFueSxcbiAgICBjb21wb25lbnQ6IFByb3BUeXBlcy5zdHJpbmdcbn07XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9iYXNlL3dyYXBwZXIuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbi8qKlxuICogVGFibGUuQ29sdW1uR3JvdXBcbiAqIEBvcmRlciAxXG4gKiovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2x1bW5Hcm91cCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog6KGo5aS05pi+56S655qE5YaF5a65XG4gICAgICAgICAqL1xuICAgICAgICB0aXRsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmVsZW1lbnQsIFByb3BUeXBlcy5ub2RlLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIH1cblxuICAgIHN0YXRpYyBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgcGFyZW50OiBQcm9wVHlwZXMuYW55XG4gICAgfVxuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgdGl0bGU6ICdjb2x1bW4tZ3JvdXAnXG4gICAgfVxuXG4gICAgc3RhdGljIF90eXBlTWFyayA9ICdjb2x1bW5Hcm91cCc7XG5cbiAgICBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9jb2x1bW4tZ3JvdXAuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUm93Q29tcG9uZW50IGZyb20gJy4vdHJlZS9yb3cnO1xuaW1wb3J0IENlbGxDb21wb25lbnQgZnJvbSAnLi90cmVlL2NlbGwnO1xuaW1wb3J0IHtzdGF0aWNzfSBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCBub29wID0gKCkgPT4geyB9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmVlKEJhc2VDb21wb25lbnQpIHtcbiAgICBjbGFzcyBUcmVlVGFibGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgICAgICBzdGF0aWMgVHJlZVJvdyA9IFJvd0NvbXBvbmVudDtcbiAgICAgICAgc3RhdGljIFRyZWVDZWxsID0gQ2VsbENvbXBvbmVudDtcbiAgICAgICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog6buY6K6k5oOF5Ya15LiL5bGV5byA55qE5qCR5b2i6KGo5qC877yM5Lyg5YWl5LqG5q2k5bGe5oCn5Luj6KGodHJlZeeahOWxleW8gOS4uuWPl+aOp+aTjeS9nFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvcGVuUm93S2V5czogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDngrnlh7t0cmVl5bGV5byA5oiW6ICF5YWz6Zet55qE5pe25YCZ6Kem5Y+R55qE5LqL5Lu2XG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBvcGVuUm93S2V5cyB0cmVl5qih5byP5LiL5bGV5byA55qEa2V5XG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gY3VycmVudFJvd0tleSDlvZPliY3ngrnlh7vooYznmoRrZXlcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3BlbmVkIOW9k+WJjeeCueWHu+aYr+WxleW8gOi/mOaYr+aUtui1t1xuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGN1cnJlbnRSZWNvcmQg5b2T5YmN54K55Ye76KGM55qE6K6w5b2VXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9uUm93T3BlbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGRhdGFTb3VyY2XlvZPkuK3mlbDmja7nmoTkuLvplK7vvIzlpoLmnpznu5nlrprnmoTmlbDmja7mupDkuK3nmoTlsZ7mgKfkuI3ljIXlkKvor6XkuLvplK7vvIzkvJrpgKDmiJDpgInmi6nnirbmgIHlhajpg6jpgInkuK1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcHJpbWFyeUtleTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5ZyodHJlZeaooeW8j+S4i+eahOe8qei/m+WwuuWvuO+8jCDku4XlnKhpc1RyZWXkuLp0cnVl5pe25YCZ5pyJ5pWIXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGluZGVudDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5byA5ZCvVGFibGXnmoR0cmVl5qih5byPLCDmjqXmlLbnmoTmlbDmja7moLzlvI/kuK3ljIXlkKtjaGlsZHJlbuWImea4suafk+aIkHRyZWUgdGFibGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaXNUcmVlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgICAgIGxvY2FsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgICAgIC4uLkJhc2VDb21wb25lbnQucHJvcFR5cGVzLFxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgICAgIC4uLkJhc2VDb21wb25lbnQuZGVmYXVsdFByb3BzLFxuICAgICAgICAgICAgcHJpbWFyeUtleTogJ2lkJyxcbiAgICAgICAgICAgIG9uUm93T3Blbjogbm9vcCxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IHt9LFxuICAgICAgICAgICAgaW5kZW50OiAxMlxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGljIGNoaWxkQ29udGV4dFR5cGVzID0ge1xuICAgICAgICAgICAgb3BlblRyZWVSb3dLZXlzOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgICAgICBpbmRlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgICAgICB0cmVlU3RhdHVzOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgICAgICBvblRyZWVOb2RlQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAgICAgaXNUcmVlOiBQcm9wVHlwZXMuYm9vbFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgb3BlblJvd0tleXM6IHByb3BzLm9wZW5Sb3dLZXlzIHx8IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvcGVuVHJlZVJvd0tleXM6IHRoaXMuc3RhdGUub3BlblJvd0tleXMsXG4gICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLnByb3BzLmluZGVudCxcbiAgICAgICAgICAgICAgICB0cmVlU3RhdHVzOiB0aGlzLmdldFRyZWVOb2RlU3RhdHVzKHRoaXMuZHMpLFxuICAgICAgICAgICAgICAgIG9uVHJlZU5vZGVDbGljazogdGhpcy5vblRyZWVOb2RlQ2xpY2ssXG4gICAgICAgICAgICAgICAgaXNUcmVlOiB0aGlzLnByb3BzLmlzVHJlZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgICAgICBpZiAoJ29wZW5Sb3dLZXlzJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG9wZW5Sb3dLZXlzIH0gPSBuZXh0UHJvcHM7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5Sb3dLZXlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub3JtYWxpemVEYXRhU291cmNlKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IFtdLFxuICAgICAgICAgICAgICAgIGxvb3AgPSBmdW5jdGlvbiAoZGF0YVNvdXJjZSwgbGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVNvdXJjZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5fX2xldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcChpdGVtLmNoaWxkcmVuLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgbG9vcChkYXRhU291cmNlLCAwKTtcbiAgICAgICAgICAgIHRoaXMuZHMgPSByZXQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0VHJlZU5vZGVTdGF0dXMoZGF0YVNvdXJjZSA9IFtdKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9wZW5Sb3dLZXlzIH0gPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgICAgIHsgcHJpbWFyeUtleSB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICByZXQgPSBbXTtcblxuICAgICAgICAgICAgb3BlblJvd0tleXMuZm9yRWFjaChvcGVuS2V5ID0+IHtcbiAgICAgICAgICAgICAgICBkYXRhU291cmNlLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtW3ByaW1hcnlLZXldID09PSBvcGVuS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGNoaWxkW3ByaW1hcnlLZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgb25UcmVlTm9kZUNsaWNrID0gKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwcmltYXJ5S2V5IH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGlkID0gcmVjb3JkW3ByaW1hcnlLZXldLFxuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UgPSB0aGlzLmRzLFxuICAgICAgICAgICAgICAgIG9wZW5Sb3dLZXlzID0gWy4uLnRoaXMuc3RhdGUub3BlblJvd0tleXNdLFxuICAgICAgICAgICAgICAgIGluZGV4ID0gb3BlblJvd0tleXMuaW5kZXhPZihpZCksXG4gICAgICAgICAgICAgICAgZ2V0Q2hpbGRyZW5LZXlCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IFtpZF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvb3AgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGl0ZW1bcHJpbWFyeUtleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AoaXRlbS5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtW3ByaW1hcnlLZXldID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AoaXRlbS5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIOS4jeS7heimgeWIoOmZpOW9k+WJjeeahG9wZW5Sb3dLZXnvvIzov5jpnIDopoHliKDpmaTlhbPogZTlrZDoioLngrnnmoRvcGVuUm93S2V5XG4gICAgICAgICAgICAgICAgY29uc3QgaWRzID0gZ2V0Q2hpbGRyZW5LZXlCeUlkKGlkKTtcbiAgICAgICAgICAgICAgICBpZHMuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBvcGVuUm93S2V5cy5pbmRleE9mKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlblJvd0tleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wZW5Sb3dLZXlzLnB1c2goaWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISgnb3BlblJvd0tleXMnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5Sb3dLZXlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uUm93T3BlbihvcGVuUm93S2V5cywgaWQsIGluZGV4ID09PSAtMSwgcmVjb3JkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBwcmVmZXItY29uc3QgKi9cbiAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudHMsIGlzVHJlZSwgZGF0YVNvdXJjZSwgaW5kZW50LCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgICAgIGlmIChpc1RyZWUpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzID0gey4uLmNvbXBvbmVudHN9O1xuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50cy5Sb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5Sb3cgPSBSb3dDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50cy5DZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuQ2VsbCA9IENlbGxDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGF0YVNvdXJjZSA9IHRoaXMubm9ybWFsaXplRGF0YVNvdXJjZShkYXRhU291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoPEJhc2VDb21wb25lbnQgey4uLm90aGVyc30gZGF0YVNvdXJjZT17ZGF0YVNvdXJjZX0gY29tcG9uZW50cz17Y29tcG9uZW50c30gLz4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpY3MoVHJlZVRhYmxlLCBCYXNlQ29tcG9uZW50KTtcbiAgICByZXR1cm4gVHJlZVRhYmxlO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL3RyZWUuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBSb3cgZnJvbSAnLi4vc2VsZWN0aW9uL3Jvdyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyZWVSb3cgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC4uLlJvdy5wcm9wVHlwZXNcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAuLi5Sb3cuZGVmYXVsdFByb3BzXG4gICAgfVxuXG4gICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgdHJlZVN0YXR1czogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBvcGVuUm93S2V5czogUHJvcFR5cGVzLmFycmF5XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyovXG4gICAgICAgIGNvbnN0IHsgY2xhc3NOYW1lLCByZWNvcmQsIHByaW1hcnlLZXksIHByZWZpeCwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHRyZWVTdGF0dXMsIG9wZW5Sb3dLZXlzIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGNvbnN0IGNscyA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgaGlkZGVuOiAhKHRyZWVTdGF0dXMuaW5kZXhPZihyZWNvcmRbcHJpbWFyeUtleV0pID4gLTEpICYmIHJlY29yZC5fX2xldmVsICE9PSAwLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH10YWJsZS1yb3ctbGV2ZWwtJHtyZWNvcmQuX19sZXZlbH1gXTogdHJ1ZSxcbiAgICAgICAgICAgIG9wZW5lZDogb3BlblJvd0tleXMuaW5kZXhPZihyZWNvcmRbcHJpbWFyeUtleV0pID4gLTEsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKDxSb3cgey4uLm90aGVyc30gcmVjb3JkPXtyZWNvcmR9IGNsYXNzTmFtZT17Y2xzfSBwcmltYXJ5S2V5PXtwcmltYXJ5S2V5fSBwcmVmaXg9e3ByZWZpeH0vPik7XG4gICAgfVxufVxuXG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS90cmVlL3Jvdy5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBJY29uIGZyb20gJy4uLy4uL2ljb24nO1xuaW1wb3J0IHsgS0VZQ09ERSB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IENlbGxDb21wb25lbnQgZnJvbSAnLi4vYmFzZS9jZWxsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJlZUNlbGwgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIGluZGVudDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgbG9jYWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAuLi5DZWxsQ29tcG9uZW50LnByb3BUeXBlc1xuICAgIH1cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIC4uLkNlbGxDb21wb25lbnQuZGVmYXVsdFByb3BzLFxuICAgICAgICBjb21wb25lbnQ6ICd0ZCcsXG4gICAgICAgIGluZGVudDogMjBcbiAgICB9XG5cbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICBvcGVuVHJlZVJvd0tleXM6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgaW5kZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBvblRyZWVOb2RlQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBpc1RyZWU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICByb3dTZWxlY3Rpb246IFByb3BUeXBlcy5vYmplY3QsXG4gICAgfVxuXG4gICAgb25UcmVlTm9kZUNsaWNrID0gKHJlY29yZCwgZSkgPT4ge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLmNvbnRleHQub25UcmVlTm9kZUNsaWNrKHJlY29yZCk7XG4gICAgfVxuXG4gICAgZXhwYW5kZWRLZXlkb3duID0gKHJlY29yZCwgZSkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERS5FTlRFUikge1xuICAgICAgICAgICAgdGhpcy5vblRyZWVOb2RlQ2xpY2socmVjb3JkLCBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBjb2xJbmRleCwgcmVjb3JkLCBwcmVmaXgsIHByaW1hcnlLZXksIGxvY2FsZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBvcGVuVHJlZVJvd0tleXM6IG9wZW5Sb3dLZXlzLCBpbmRlbnQsIGlzVHJlZSwgcm93U2VsZWN0aW9uIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGNvbnN0IHRyZWVBcnJvd05vZGVJbmRleCA9IHJvd1NlbGVjdGlvbiA/IDEgOiAwO1xuICAgICAgICBsZXQgZmlyc3RDZWxsU3R5bGUsIHRyZWVBcnJvd05vZGU7XG4gICAgICAgIGlmIChjb2xJbmRleCA9PT0gdHJlZUFycm93Tm9kZUluZGV4KSB7XG4gICAgICAgICAgICBsZXQgdHJlZUFycm93VHlwZTtcbiAgICAgICAgICAgIGlmIChpc1RyZWUpIHtcbiAgICAgICAgICAgICAgICBmaXJzdENlbGxTdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IGluZGVudCAqIChyZWNvcmQuX19sZXZlbCArIDEpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0cmVlQXJyb3dOb2RlID0gPEljb24gc2l6ZT1cInhzXCIgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtdHJlZS1wbGFjZWhvbGRlcmB9IC8+O1xuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuY2hpbGRyZW4gJiYgcmVjb3JkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNFeHBhbmRlZCA9IG9wZW5Sb3dLZXlzLmluZGV4T2YocmVjb3JkW3ByaW1hcnlLZXldKSA+IC0xO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyZWVBcnJvd1R5cGUgPSBoYXNFeHBhbmRlZCA/ICdhcnJvdy1kb3duJyA6ICdhcnJvdy1yaWdodCc7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJlZUFycm93Tm9kZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAoPEljb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS10cmVlLWFycm93YH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPXt0cmVlQXJyb3dUeXBlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU9XCJ4c1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17ZSA9PiB0aGlzLm9uVHJlZU5vZGVDbGljayhyZWNvcmQsIGUpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uS2V5RG93bj17ZSA9PiB0aGlzLmV4cGFuZGVkS2V5ZG93bihyZWNvcmQsIGUpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYkluZGV4PVwiMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1leHBhbmRlZD17aGFzRXhwYW5kZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD17aGFzRXhwYW5kZWQgPyBsb2NhbGUuZXhwYW5kZWQgOiBsb2NhbGUuZm9sZGVkfS8+KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICg8Q2VsbENvbXBvbmVudCB7Li4udGhpcy5wcm9wc30gaW5uZXJTdHlsZT17Zmlyc3RDZWxsU3R5bGV9PlxuICAgICAgICAgICAge3RyZWVBcnJvd05vZGV9XG4gICAgICAgIDwvQ2VsbENvbXBvbmVudD4pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS90cmVlL2NlbGwuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IEhlYWRlckNvbXBvbmVudCBmcm9tICcuL2ZpeGVkL2hlYWRlcic7XG5pbXBvcnQgQm9keUNvbXBvbmVudCBmcm9tICcuL2ZpeGVkL2JvZHknO1xuaW1wb3J0IFdyYXBwZXJDb21wb25lbnQgZnJvbSAnLi9maXhlZC93cmFwcGVyJztcbmltcG9ydCB7c3RhdGljc30gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZml4ZWQoQmFzZUNvbXBvbmVudCkge1xuICAgIC8qKiBUYWJsZSAqL1xuICAgIGNsYXNzIEZpeGVkVGFibGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgICAgICBzdGF0aWMgRml4ZWRIZWFkZXIgPSBIZWFkZXJDb21wb25lbnQ7XG4gICAgICAgIHN0YXRpYyBGaXhlZEJvZHkgPSBCb2R5Q29tcG9uZW50O1xuICAgICAgICBzdGF0aWMgRml4ZWRXcmFwcGVyID0gV3JhcHBlckNvbXBvbmVudDtcbiAgICAgICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAqIOaYr+WQpuWFt+acieihqOWktFxuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaGFzSGVhZGVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAqIOihqOWktOaYr+WQpuWbuuWumu+8jOivpeWxnuaAp+mFjeWQiG1heEJvZHlIZWlnaHTkvb/nlKjvvIzlvZPlhoXlrrnljLrln5/nmoTpq5jluqbotoXov4dtYXhCb2R5SGVpZ2h055qE5pe25YCZ77yM5Zyo5YaF5a655Yy65Z+f5Lya5Ye6546w5rua5Yqo5p2hXG4gICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmaXhlZEhlYWRlcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOacgOWkp+WGheWuueWMuuWfn+eahOmrmOW6pizlnKhgZml4ZWRIZWFkZXJg5Li6YHRydWVg55qE5pe25YCZLOi2hei/h+i/meS4qumrmOW6puS8muWHuueOsOa7muWKqOadoVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtYXhCb2R5SGVpZ2h0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gICAgICAgICAgICAuLi5CYXNlQ29tcG9uZW50LnByb3BUeXBlc1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgICAgIC4uLkJhc2VDb21wb25lbnQuZGVmYXVsdFByb3BzLFxuICAgICAgICAgICAgaGFzSGVhZGVyOiB0cnVlLFxuICAgICAgICAgICAgZml4ZWRIZWFkZXI6IGZhbHNlLFxuICAgICAgICAgICAgbWF4Qm9keUhlaWdodDogMjAwLFxuICAgICAgICAgICAgY29tcG9uZW50czoge30sXG4gICAgICAgICAgICByZWZzOiB7fSxcbiAgICAgICAgICAgIHByZWZpeDogJ25leHQtJ1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGljIGNoaWxkQ29udGV4dFR5cGVzID0ge1xuICAgICAgICAgICAgZml4ZWRIZWFkZXI6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAgICAgbWF4Qm9keUhlaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgICAgICAgICAgb25Cb2R5U2Nyb2xsOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgICAgIGdldE5vZGU6IFByb3BUeXBlcy5mdW5jXG4gICAgICAgIH1cblxuICAgICAgICBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZpeGVkSGVhZGVyOiB0aGlzLnByb3BzLmZpeGVkSGVhZGVyLFxuICAgICAgICAgICAgICAgIG1heEJvZHlIZWlnaHQ6IHRoaXMucHJvcHMubWF4Qm9keUhlaWdodCxcbiAgICAgICAgICAgICAgICBvbkJvZHlTY3JvbGw6IHRoaXMub25Cb2R5U2Nyb2xsLFxuICAgICAgICAgICAgICAgIGdldE5vZGU6IHRoaXMuZ2V0Tm9kZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RGaXhlZEhlYWRlclNpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0Rml4ZWRIZWFkZXJTaXplKCk7XG4gICAgICAgIH1cblxuICAgICAgICBhZGp1c3RGaXhlZEhlYWRlclNpemUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGhhc0hlYWRlciwgZml4ZWRIZWFkZXIsIG1heEJvZHlIZWlnaHQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAoaGFzSGVhZGVyICYmIGZpeGVkSGVhZGVyICYmICF0aGlzLnByb3BzLmxvY2tUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYm9keU5vZGUuc2Nyb2xsSGVpZ2h0IDw9IG1heEJvZHlIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tLnNldFN0eWxlKHRoaXMuaGVhZGVyTm9kZSwgJ3BhZGRpbmdSaWdodCcsIDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5zZXRTdHlsZSh0aGlzLmhlYWRlck5vZGUsICdwYWRkaW5nUmlnaHQnLCBkb20uc2Nyb2xsYmFyKCkud2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdldE5vZGUgPSAodHlwZSwgbm9kZSwgbG9ja1R5cGUpID0+IHtcbiAgICAgICAgICAgIGxvY2tUeXBlID0gbG9ja1R5cGUgPyBsb2NrVHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGxvY2tUeXBlLnN1YnN0cigxKSA6ICcnO1xuICAgICAgICAgICAgdGhpc1tgJHt0eXBlfSR7bG9ja1R5cGV9Tm9kZWBdID0gbm9kZTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnaGVhZGVyJyAmJiAhbG9ja1R5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVySGVhZGVyTm9kZSA9IHRoaXMuaGVhZGVyTm9kZS5xdWVyeVNlbGVjdG9yKCdkaXYnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9uQm9keVNjcm9sbCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG8odGhpcy5ib2R5Tm9kZS5zY3JvbGxMZWZ0LCB0aGlzLmJvZHlOb2RlLnNjcm9sbFRvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBzY3JvbGxUbyh4KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbm5lckhlYWRlck5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVySGVhZGVyTm9kZS5zY3JvbGxMZWZ0ID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBwcmVmZXItY29uc3QgKi9cbiAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudHMsIGNsYXNzTmFtZSwgcHJlZml4LCBmaXhlZEhlYWRlciwgbWF4Qm9keUhlaWdodCwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKGZpeGVkSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cyA9IHsuLi5jb21wb25lbnRzfTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudHMuSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuSGVhZGVyID0gSGVhZGVyQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudHMuQm9keSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLkJvZHkgPSBCb2R5Q29tcG9uZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudHMuV3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLldyYXBwZXIgPSBXcmFwcGVyQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgW2Ake3ByZWZpeH10YWJsZS1maXhlZGBdOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBbY2xhc3NOYW1lXTogY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDxCYXNlQ29tcG9uZW50ICB7Li4ub3RoZXJzfSBjb21wb25lbnRzPXtjb21wb25lbnRzfSBjbGFzc05hbWU9e2NsYXNzTmFtZX0gcHJlZml4PXtwcmVmaXh9IC8+KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWNzKEZpeGVkVGFibGUsIEJhc2VDb21wb25lbnQpO1xuICAgIHJldHVybiBGaXhlZFRhYmxlO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2ZpeGVkLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQ2hlY2tib3ggZnJvbSAnLi4vY2hlY2tib3gnO1xuaW1wb3J0IFJhZGlvIGZyb20gJy4uL3JhZGlvJztcbmltcG9ydCB7IGZ1bmMsIGxvZyB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHpoQ04gZnJvbSAnLi4vbG9jYWxlL3poLWNuJztcbmltcG9ydCBTZWxlY3Rpb25Sb3cgZnJvbSAnLi9zZWxlY3Rpb24vcm93JztcbmltcG9ydCBDb2wgZnJvbSAnLi9jb2x1bW4nO1xuaW1wb3J0IHsgc3RhdGljcyB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IHsgbWFrZUNoYWluIH0gPSBmdW5jO1xuXG5jb25zdCB1bmlxdWUgPSAoYXJyLCBrZXkgPSAndGhpcycpID0+IHtcbiAgICBjb25zdCB0ZW1wID0ge30sIHJldCA9IFtdO1xuICAgIGFyci5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGlmIChrZXkgPT09ICd0aGlzJykge1xuICAgICAgICAgICAgdmFsdWUgPSBpdGVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBpdGVtW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0ZW1wW3ZhbHVlXSkge1xuICAgICAgICAgICAgcmV0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICB0ZW1wW3ZhbHVlXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2VsZWN0aW9uKEJhc2VDb21wb25lbnQpIHtcbiAgICAvKiogVGFibGUgKi9cbiAgICBjbGFzcyBTZWxlY3Rpb25UYWJsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgICAgIHN0YXRpYyBTZWxlY3Rpb25Sb3cgPSBTZWxlY3Rpb25Sb3c7XG4gICAgICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICog5piv5ZCm5ZCv55So6YCJ5oup5qih5byPXG4gICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGdldFByb3BzIGBGdW5jdGlvbihyZWNvcmQsIGluZGV4KT0+T2JqZWN0YCDojrflj5ZzZWxlY3Rpb27nmoTpu5jorqTlsZ7mgKdcbiAgICAgICAgICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb25DaGFuZ2UgYEZ1bmN0aW9uKHNlbGVjdGVkUm93S2V5czpBcnJheSwgcmVjb3JkczpBcnJheSlgIOmAieaLqeaUueWPmOeahOaXtuWAmeinpuWPkeeahOS6i+S7tu+8jCoq5rOo5oSPOioqIOWFtuS4rXJlY29yZHPlj6rkvJrljIXlkKvlvZPliY1kYXRhU291cmNl55qE5pWw5o2u77yM5b6I5Y+v6IO95Lya5bCP5LqOc2VsZWN0ZWRSb3dLZXlz55qE6ZW/5bqm44CCXG4gICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG9uU2VsZWN0IGBGdW5jdGlvbihzZWxlY3RlZDpCb29sZWFuLCByZWNvcmQ6T2JqZWN0LCByZWNvcmRzOkFycmF5KWAg55So5oi35omL5Yqo6YCJ5oupL+WPlua2iOmAieaLqeafkOihjOeahOWbnuiwg1xuICAgICAgICAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvblNlbGVjdEFsbCBgRnVuY3Rpb24oc2VsZWN0ZWQ6Qm9vbGVhbiwgcmVjb3JkczpBcnJheSlgIOeUqOaIt+aJi+WKqOmAieaLqS/lj5bmtojpgInmi6nmiYDmnInooYznmoTlm57osINcbiAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gc2VsZWN0ZWRSb3dLZXlzIOiuvue9ruS6huatpOWxnuaApyzlsIZyb3dTZWxlY3Rpb27lj5jkuLrlj5fmjqfnirbmgIEs5o6l5pS25YC85Li66K+l6KGM5pWw5o2u55qEcHJpbWFyeUtleeeahOWAvFxuICAgICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gbW9kZSDpgInmi6lzZWxlY3Rpb27nmoTmqKHlvI8sIOWPr+mAieWAvOS4umBzaW5nbGVgLCBgbXVsdGlwbGVg77yM6buY6K6k5Li6YG11bHRpcGxlYFxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJvd1NlbGVjdGlvbjogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgICAgIHByaW1hcnlLZXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgICAgICBkYXRhU291cmNlOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgICAgICBlbnRpcmVEYXRhU291cmNlOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgICAgICAuLi5CYXNlQ29tcG9uZW50LnByb3BUeXBlcyxcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgICAgICAuLi5CYXNlQ29tcG9uZW50LmRlZmF1bHRQcm9wcyxcbiAgICAgICAgICAgIGxvY2FsZTogemhDTi5UYWJsZSxcbiAgICAgICAgICAgIHByaW1hcnlLZXk6ICdpZCcsXG4gICAgICAgICAgICBwcmVmaXg6ICduZXh0LSdcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgICAgICAgICBsaXN0SGVhZGVyOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGljIGNoaWxkQ29udGV4dFR5cGVzID0ge1xuICAgICAgICAgICAgcm93U2VsZWN0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAgICAgc2VsZWN0ZWRSb3dLZXlzOiBQcm9wVHlwZXMuYXJyYXlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkUm93S2V5czogcHJvcHMucm93U2VsZWN0aW9uICYmICdzZWxlY3RlZFJvd0tleXMnIGluIHByb3BzLnJvd1NlbGVjdGlvbiA/IChwcm9wcy5yb3dTZWxlY3Rpb24uc2VsZWN0ZWRSb3dLZXlzIHx8IFtdKSA6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByb3dTZWxlY3Rpb246IHRoaXMucHJvcHMucm93U2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkUm93S2V5czogdGhpcy5zdGF0ZS5zZWxlY3RlZFJvd0tleXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICAgICAgaWYgKG5leHRQcm9wcy5yb3dTZWxlY3Rpb24gJiYgJ3NlbGVjdGVkUm93S2V5cycgaW4gbmV4dFByb3BzLnJvd1NlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkUm93S2V5cyA9IG5leHRQcm9wcy5yb3dTZWxlY3Rpb24uc2VsZWN0ZWRSb3dLZXlzIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd0tleXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByZWZpeCwgcm93U2VsZWN0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKHJvd1NlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCAoY2hpbGQsIGluZGV4KSA9PiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBpbmRleFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi51bnNoaWZ0KDxDb2wga2V5PVwic2VsZWN0aW9uXCIgdGl0bGU9e3RoaXMucmVuZGVyU2VsZWN0aW9uSGVhZGVyLmJpbmQodGhpcyl9XG4gICAgICAgICAgICAgICAgICAgIGNlbGw9e3RoaXMucmVuZGVyU2VsZWN0aW9uQm9keS5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgICAgICAgICB3aWR0aD17NTB9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLXNlbGVjdGlvbmB9IF9fbm9ybWFsaXplZCAvPik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyU2VsZWN0aW9uSGVhZGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb25DaGFuZ2UgPSB0aGlzLnNlbGVjdEFsbFJvdywgYXR0cnMgPSB7fSxcbiAgICAgICAgICAgICAgICB7IHJvd1NlbGVjdGlvbiwgcHJpbWFyeUtleSwgZGF0YVNvdXJjZSwgbG9jYWxlIH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIHsgc2VsZWN0ZWRSb3dLZXlzIH0gPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgICAgIG1vZGUgPSByb3dTZWxlY3Rpb24ubW9kZSA/IHJvd1NlbGVjdGlvbi5tb2RlIDogJ211bHRpcGxlJztcblxuICAgICAgICAgICAgbGV0IGNoZWNrZWQgPSAhIXNlbGVjdGVkUm93S2V5cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgaW5kZXRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5mbGF0RGF0YVNvdXJjZShkYXRhU291cmNlKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHJlY29yZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyb3dTZWxlY3Rpb24uZ2V0UHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEocm93U2VsZWN0aW9uLmdldFByb3BzKHJlY29yZCwgaW5kZXgpIHx8IHt9KS5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm1hcChyZWNvcmQgPT4gcmVjb3JkW3ByaW1hcnlLZXldKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkUm93S2V5cy5pbmRleE9mKGlkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhdHRycy5vbkNsaWNrID0gbWFrZUNoYWluKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0sIGF0dHJzLm9uQ2xpY2spO1xuXG4gICAgICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIGluZGV0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2RlID09PSAnbXVsdGlwbGUnID8gPENoZWNrYm94IGluZGV0ZXJtaW5hdGU9e2luZGV0ZXJtaW5hdGV9IGFyaWEtbGFiZWw9e2xvY2FsZS5zZWxlY3RBbGx9IGNoZWNrZWQ9e2NoZWNrZWR9IG9uQ2hhbmdlPXtvbkNoYW5nZX0gey4uLmF0dHJzfSAvPiA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJTZWxlY3Rpb25Cb2R5ID0gKHZhbHVlLCBpbmRleCwgcmVjb3JkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHJvd1NlbGVjdGlvbiwgcHJpbWFyeUtleSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0ZWRSb3dLZXlzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgbW9kZSA9IHJvd1NlbGVjdGlvbi5tb2RlID8gcm93U2VsZWN0aW9uLm1vZGUgOiAnbXVsdGlwbGUnO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IHNlbGVjdGVkUm93S2V5cy5pbmRleE9mKHJlY29yZFtwcmltYXJ5S2V5XSkgPiAtMTtcbiAgICAgICAgICAgIGNvbnN0IG9uQ2hhbmdlID0gdGhpcy5zZWxlY3RPbmVSb3cuYmluZCh0aGlzLCBpbmRleCwgcmVjb3JkKTtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gcm93U2VsZWN0aW9uLmdldFByb3BzID8gKHJvd1NlbGVjdGlvbi5nZXRQcm9wcyhyZWNvcmQsIGluZGV4KSB8fCB7fSkgOiB7fTtcblxuICAgICAgICAgICAgYXR0cnMub25DbGljayA9IG1ha2VDaGFpbigoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9LCBhdHRycy5vbkNsaWNrKTtcbiAgICAgICAgICAgIHJldHVybiBtb2RlID09PSAnbXVsdGlwbGUnID8gPENoZWNrYm94IGNoZWNrZWQ9e2NoZWNrZWR9IG9uQ2hhbmdlPXtvbkNoYW5nZX0gey4uLmF0dHJzfSAvPiA6XG4gICAgICAgICAgICAgICAgPFJhZGlvIGNoZWNrZWQ9e2NoZWNrZWR9IG9uQ2hhbmdlPXtvbkNoYW5nZX0gey4uLmF0dHJzfSAvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGVjdEFsbFJvdyA9IChjaGVja2VkLCBlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBbLi4udGhpcy5zdGF0ZS5zZWxlY3RlZFJvd0tleXNdLFxuICAgICAgICAgICAgICAgIHsgcm93U2VsZWN0aW9uLCBwcmltYXJ5S2V5LCBkYXRhU291cmNlLCBlbnRpcmVEYXRhU291cmNlIH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIHsgc2VsZWN0ZWRSb3dLZXlzIH0gPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgICAgIGdldFByb3BzID0gcm93U2VsZWN0aW9uLmdldFByb3BzO1xuICAgICAgICAgICAgbGV0IGF0dHJzID0ge30sIHJlY29yZHMgPSBbXTtcblxuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gZW50aXJlRGF0YVNvdXJjZSA/IGVudGlyZURhdGFTb3VyY2UgOiBkYXRhU291cmNlO1xuXG4gICAgICAgICAgICB0aGlzLmZsYXREYXRhU291cmNlKHNvdXJjZSkuZm9yRWFjaCgocmVjb3JkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gcmVjb3JkW3ByaW1hcnlLZXldO1xuICAgICAgICAgICAgICAgIGlmIChnZXRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICBhdHRycyA9IGdldFByb3BzKHJlY29yZCwgaW5kZXgpIHx8IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyDlj43pgInlkozlhajpgInnmoTml7blgJnkuI3opoHkuKLlvIPnpoHnlKjpobnnmoTpgInkuK3nirbmgIFcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCAmJiAoIWF0dHJzLmRpc2FibGVkIHx8IHNlbGVjdGVkUm93S2V5cy5pbmRleE9mKGlkKSA+IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZHMucHVzaChyZWNvcmQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXR0cnMuZGlzYWJsZWQgJiYgc2VsZWN0ZWRSb3dLZXlzLmluZGV4T2YoaWQpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goaWQpO1xuICAgICAgICAgICAgICAgICAgICByZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpID0gcmV0LmluZGV4T2YoaWQpO1xuICAgICAgICAgICAgICAgICAgICBpID4gLTEgJiYgcmV0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVjb3JkcyA9IHVuaXF1ZShyZWNvcmRzLCBwcmltYXJ5S2V5KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygcm93U2VsZWN0aW9uLm9uU2VsZWN0QWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcm93U2VsZWN0aW9uLm9uU2VsZWN0QWxsKGNoZWNrZWQsIHJlY29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyU2VsZWN0aW9uKHJvd1NlbGVjdGlvbiwgdW5pcXVlKHJldCksIHJlY29yZHMpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGVjdE9uZVJvdyhpbmRleCwgcmVjb3JkLCBjaGVja2VkLCBlKSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWRSb3dLZXlzID0gWy4uLnRoaXMuc3RhdGUuc2VsZWN0ZWRSb3dLZXlzXSwgaTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJpbWFyeUtleSwgcm93U2VsZWN0aW9uLCBkYXRhU291cmNlIH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIG1vZGUgPSByb3dTZWxlY3Rpb24ubW9kZSA/IHJvd1NlbGVjdGlvbi5tb2RlIDogJ211bHRpcGxlJyxcbiAgICAgICAgICAgICAgICBpZCA9IHJlY29yZFtwcmltYXJ5S2V5XTtcbiAgICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgICAgICBsb2cud2FybmluZyhgQ2FuJ3QgZ2V0IHZhbHVlIGZyb20gcmVjb3JkIHVzaW5nIGdpdmVuICR7cHJpbWFyeUtleX0gYXMgcHJpbWFyeUtleS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RlID09PSAnbXVsdGlwbGUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRSb3dLZXlzLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBzZWxlY3RlZFJvd0tleXMuaW5kZXhPZihpZCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkUm93S2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRSb3dLZXlzID0gW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlY29yZHMgPSB1bmlxdWUoZGF0YVNvdXJjZS5maWx0ZXIoaXRlbSA9PiBzZWxlY3RlZFJvd0tleXMuaW5kZXhPZihpdGVtW3ByaW1hcnlLZXldKSA+IC0xKSwgcHJpbWFyeUtleSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJvd1NlbGVjdGlvbi5vblNlbGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJvd1NlbGVjdGlvbi5vblNlbGVjdChjaGVja2VkLCByZWNvcmQsIHJlY29yZHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJTZWxlY3Rpb24ocm93U2VsZWN0aW9uLCBzZWxlY3RlZFJvd0tleXMsIHJlY29yZHMpO1xuXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRyaWdnZXJTZWxlY3Rpb24ocm93U2VsZWN0aW9uLCBzZWxlY3RlZFJvd0tleXMsIHJlY29yZHMpIHtcbiAgICAgICAgICAgIGlmICghKCdzZWxlY3RlZFJvd0tleXMnIGluIHJvd1NlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRSb3dLZXlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJvd1NlbGVjdGlvbi5vbkNoYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJvd1NlbGVjdGlvbi5vbkNoYW5nZShzZWxlY3RlZFJvd0tleXMsIHJlY29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZmxhdERhdGFTb3VyY2UoZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgbGV0IHJldCA9IGRhdGFTb3VyY2U7XG4gICAgICAgICAgICBjb25zdCB7IGxpc3RIZWFkZXIgfSA9IHRoaXMuY29udGV4dDtcblxuICAgICAgICAgICAgaWYgKGxpc3RIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGhhc0NoaWxkcmVuU2VsZWN0aW9uLCBoYXNTZWxlY3Rpb24gfSA9IGxpc3RIZWFkZXI7XG4gICAgICAgICAgICAgICAgZGF0YVNvdXJjZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGl0ZW0uY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOmcgOimgea4suafk3NlbGVjdGlvbuaJjeWwhui/meadoeiusOW9leaPkuWFpeWIsGRhdGFTb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgLy8g5oiW6ICF5rKh5pyJ5a2p5a2Q6IqC54K5XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbiAmJiBoYXNDaGlsZHJlblNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItY29uc3QgKi9cbiAgICAgICAgICAgIGxldCB7IHJvd1NlbGVjdGlvbiwgY29tcG9uZW50cywgY2hpbGRyZW4sIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICAgICAgaWYgKHJvd1NlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5ub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cyA9IHsgLi4uY29tcG9uZW50cyB9O1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuUm93ID0gY29tcG9uZW50cy5Sb3cgfHwgU2VsZWN0aW9uUm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICg8QmFzZUNvbXBvbmVudCB7Li4ub3RoZXJzfSBjb21wb25lbnRzPXtjb21wb25lbnRzfT5cbiAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICA8L0Jhc2VDb21wb25lbnQ+KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWNzKFNlbGVjdGlvblRhYmxlLCBCYXNlQ29tcG9uZW50KTtcbiAgICByZXR1cm4gU2VsZWN0aW9uVGFibGU7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvc2VsZWN0aW9uLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBJY29uIGZyb20gJy4uL2ljb24nO1xuaW1wb3J0IHsgS0VZQ09ERSB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IFJvd0NvbXBvbmVudCBmcm9tICcuL2V4cGFuZGVkL3Jvdyc7XG5pbXBvcnQgQ29sIGZyb20gJy4vY29sdW1uJztcbmltcG9ydCB7IHN0YXRpY3MgfSBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCBub29wID0gKCkgPT4geyB9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleHBhbmRlZChCYXNlQ29tcG9uZW50KSB7XG4gICAgLyoqIFRhYmxlICovXG4gICAgY2xhc3MgRXhwYW5kZWRUYWJsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgICAgIHN0YXRpYyBFeHBhbmRlZFJvdyA9IFJvd0NvbXBvbmVudDtcbiAgICAgICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog6aKd5aSW5riy5p+T6KGM55qE5riy5p+T5Ye95pWwXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkIOivpeihjOaJgOWvueW6lOeahOaVsOaNrlxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IOivpeihjOaJgOWvueW6lOeahOW6j+WIl1xuICAgICAgICAgICAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGV4cGFuZGVkUm93UmVuZGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog6aKd5aSW5riy5p+T6KGM55qE57yp6L+bXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGV4cGFuZGVkUm93SW5kZW50OiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOm7mOiupOaDheWGteS4i+WxleW8gOeahOa4suafk+ihjOaIluiAhVRyZWUsIOS8oOWFpeatpOWxnuaAp+S4uuWPl+aOp+eKtuaAgVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvcGVuUm93S2V5czogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDmmK/lkKbmmL7npLrngrnlh7vlsZXlvIDpop3lpJbmuLLmn5PooYznmoQr5Y+35oyJ6ZKuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGhhc0V4cGFuZGVkUm93Q3RybDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOiuvue9rumineWklua4suafk+ihjOeahOWxnuaAp1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRFeHBhbmRlZENvbFByb3BzOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5Zyo6aKd5aSW5riy5p+T6KGM5oiW6ICFVHJlZeWxleW8gOaIluiAheaUtui1t+eahOaXtuWAmeinpuWPkeeahOS6i+S7tlxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gb3BlblJvd0tleXMg5bGV5byA55qE5riy5p+T6KGM55qEa2V5XG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gY3VycmVudFJvd0tleSDlvZPliY3ngrnlh7vnmoTmuLLmn5PooYznmoRrZXlcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXhwYW5kZWQg5b2T5YmN54K55Ye75piv5bGV5byA6L+Y5piv5pS26LW3XG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY3VycmVudFJlY29yZCDlvZPliY3ngrnlh7vpop3lpJbmuLLmn5PooYznmoTorrDlvZVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb25Sb3dPcGVuOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog54K55Ye76aKd5aSW5riy5p+T6KGM6Kem5Y+R55qE5LqL5Lu2XG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkIOivpeihjOaJgOWvueW6lOeahOaVsOaNrlxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IOivpeihjOaJgOWvueW6lOeahOW6j+WIl1xuICAgICAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSBET03kuovku7blr7nosaFcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb25FeHBhbmRlZFJvd0NsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgICAgIGxvY2FsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgICAgIC4uLkJhc2VDb21wb25lbnQucHJvcFR5cGVzXG4gICAgICAgIH07XG5cbiAgICAgICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgICAgIC4uLkJhc2VDb21wb25lbnQuZGVmYXVsdFByb3BzLFxuICAgICAgICAgICAgZ2V0RXhwYW5kZWRDb2xQcm9wczogbm9vcCxcbiAgICAgICAgICAgIG9uUm93T3Blbjogbm9vcCxcbiAgICAgICAgICAgIGhhc0V4cGFuZGVkUm93Q3RybDogdHJ1ZSxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IHt9LFxuICAgICAgICAgICAgZXhwYW5kZWRSb3dJbmRlbnQ6IFsxLCAwXSxcbiAgICAgICAgICAgIHByZWZpeDogJ25leHQtJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0YXRpYyBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgICAgIG9wZW5Sb3dLZXlzOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgICAgICBleHBhbmRlZFJvd1JlbmRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgICAgICBleHBhbmRlZFJvd0luZGVudDogUHJvcFR5cGVzLmFycmF5XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgIG9wZW5Sb3dLZXlzOiB0aGlzLnByb3BzLm9wZW5Sb3dLZXlzIHx8IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvcGVuUm93S2V5czogdGhpcy5zdGF0ZS5vcGVuUm93S2V5cyxcbiAgICAgICAgICAgICAgICBleHBhbmRlZFJvd1JlbmRlcjogdGhpcy5wcm9wcy5leHBhbmRlZFJvd1JlbmRlcixcbiAgICAgICAgICAgICAgICBleHBhbmRlZFJvd0luZGVudDogdGhpcy5wcm9wcy5leHBhbmRlZFJvd0luZGVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgICAgICBpZiAoJ29wZW5Sb3dLZXlzJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG9wZW5Sb3dLZXlzIH0gPSBuZXh0UHJvcHM7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5Sb3dLZXlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBhbmRlZEtleWRvd24gPSAodmFsdWUsIHJlY29yZCwgaW5kZXgsIGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IEtFWUNPREUuRU5URVIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRXhwYW5kZWRDbGljayh2YWx1ZSwgcmVjb3JkLCBpbmRleCwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJFeHBhbmRlZENlbGwgPSAodmFsdWUsIGluZGV4LCByZWNvcmQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2V0RXhwYW5kZWRDb2xQcm9wcywgcHJlZml4LCBsb2NhbGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBjb25zdCB7IG9wZW5Sb3dLZXlzIH0gPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgICAgIHsgcHJpbWFyeUtleSB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBoYXNFeHBhbmRlZCA9IG9wZW5Sb3dLZXlzLmluZGV4T2YocmVjb3JkW3ByaW1hcnlLZXldKSA+IC0xLFxuICAgICAgICAgICAgICAgIHN3aXRjaE5vZGUgPSBoYXNFeHBhbmRlZCA/XG4gICAgICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9XCJtaW51c1wiIHNpemU9XCJ4c1wiIC8+IDogPEljb24gdHlwZT1cImFkZFwiIHNpemU9XCJ4c1wiIC8+LFxuXG4gICAgICAgICAgICAgICAgYXR0cnMgPSBnZXRFeHBhbmRlZENvbFByb3BzKHJlY29yZCwgaW5kZXgpIHx8IHt9O1xuICAgICAgICAgICAgY29uc3QgY2xzID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICAgICAgW2Ake3ByZWZpeH10YWJsZS1leHBhbmRlZC1jdHJsYF06IHRydWUsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGF0dHJzLmRpc2FibGVkLFxuICAgICAgICAgICAgICAgIFthdHRycy5jbGFzc05hbWVdOiBhdHRycy5jbGFzc05hbWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWF0dHJzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgYXR0cnMub25DbGljayA9IHRoaXMub25FeHBhbmRlZENsaWNrLmJpbmQodGhpcywgdmFsdWUsIHJlY29yZCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8c3BhbiB7Li4uYXR0cnN9XG4gICAgICAgICAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleD1cIjBcIlxuICAgICAgICAgICAgICAgICAgICBvbktleURvd249e3RoaXMuZXhwYW5kZWRLZXlkb3duLmJpbmQodGhpcywgdmFsdWUsIHJlY29yZCwgaW5kZXgpfVxuICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPXtoYXNFeHBhbmRlZCA/IGxvY2FsZS5leHBhbmRlZCA6IGxvY2FsZS5mb2xkZWR9XG4gICAgICAgICAgICAgICAgICAgIGFyaWEtZXhwYW5kZWQ9e2hhc0V4cGFuZGVkfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nsc30+XG4gICAgICAgICAgICAgICAgICAgIHtzd2l0Y2hOb2RlfVxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBvbkV4cGFuZGVkQ2xpY2sodmFsdWUsIHJlY29yZCwgaSwgZSkge1xuICAgICAgICAgICAgY29uc3Qgb3BlblJvd0tleXMgPSBbLi4udGhpcy5zdGF0ZS5vcGVuUm93S2V5c10sXG4gICAgICAgICAgICAgICAgeyBwcmltYXJ5S2V5IH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGlkID0gcmVjb3JkW3ByaW1hcnlLZXldLFxuICAgICAgICAgICAgICAgIGluZGV4ID0gb3BlblJvd0tleXMuaW5kZXhPZihpZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIG9wZW5Sb3dLZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wZW5Sb3dLZXlzLnB1c2goaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoJ29wZW5Sb3dLZXlzJyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBvcGVuUm93S2V5czogb3BlblJvd0tleXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Sb3dPcGVuKG9wZW5Sb3dLZXlzLCBpZCwgaW5kZXggPT09IC0xLCByZWNvcmQpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb25zdCB0b0FycmF5Q2hpbGRyZW4gPSBDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIChjaGlsZCwgaW5kZXgpID0+IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgICAgICAgIGtleTogaW5kZXhcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IHtwcmVmaXh9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIHRvQXJyYXlDaGlsZHJlbi51bnNoaWZ0KDxDb2wgdGl0bGU9XCJcIiBrZXk9XCJleHBhbmRlZFwiIGNlbGw9e3RoaXMucmVuZGVyRXhwYW5kZWRDZWxsLmJpbmQodGhpcyl9IHdpZHRoPXs1MH0gY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtZXhwYW5kZWRgfSBfX25vcm1hbGl6ZWQvPik7XG4gICAgICAgICAgICByZXR1cm4gdG9BcnJheUNoaWxkcmVuO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplRGF0YVNvdXJjZShkcykge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICAgICAgICBkcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1Db3B5ID0geyAuLi5pdGVtIH07XG4gICAgICAgICAgICAgICAgaXRlbUNvcHkuX19leHBhbmRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goaXRlbSwgaXRlbUNvcHkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyKCkge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIHByZWZlci1jb25zdCAqL1xuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50cywgb3BlblJvd0tleXMsIGV4cGFuZGVkUm93UmVuZGVyLCBoYXNFeHBhbmRlZFJvd0N0cmwsIGNoaWxkcmVuLCBkYXRhU291cmNlLCBnZXRFeHBhbmRlZENvbFByb3BzLCBleHBhbmRlZFJvd0luZGVudCwgb25Sb3dPcGVuLCBvbkV4cGFuZGVkUm93Q2xpY2ssIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChleHBhbmRlZFJvd1JlbmRlciAmJiAhY29tcG9uZW50cy5Sb3cpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzID0gey4uLmNvbXBvbmVudHN9O1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuUm93ID0gUm93Q29tcG9uZW50O1xuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UgPSB0aGlzLm5vcm1hbGl6ZURhdGFTb3VyY2UoZGF0YVNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwYW5kZWRSb3dSZW5kZXIgJiYgaGFzRXhwYW5kZWRSb3dDdHJsKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICg8QmFzZUNvbXBvbmVudCB7Li4ub3RoZXJzfSBkYXRhU291cmNlPXtkYXRhU291cmNlfSAgY29tcG9uZW50cz17Y29tcG9uZW50c30+XG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgPC9CYXNlQ29tcG9uZW50Pik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljcyhFeHBhbmRlZFRhYmxlLCBCYXNlQ29tcG9uZW50KTtcbiAgICByZXR1cm4gRXhwYW5kZWRUYWJsZTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9leHBhbmRlZC5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IFZpcnR1YWxCb2R5IGZyb20gJy4vdmlydHVhbC9ib2R5JztcbmltcG9ydCB7IHN0YXRpY3MgfSBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCBub29wID0gKCkgPT4geyB9O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmlydHVhbChCYXNlQ29tcG9uZW50KSB7XG4gICAgY2xhc3MgVmlydHVhbFRhYmxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAgICAgc3RhdGljIFZpcnR1YWxCb2R5ID0gVmlydHVhbEJvZHk7XG4gICAgICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOaYr+WQpuW8gOWQr+iZmuaLn+a7muWKqFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB1c2VWaXJ0dWFsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog6K6+572u6KGM6auYXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJvd0hlaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICAgICAgICAgIG1heEJvZHlIZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgICAgICAgICAgIHByaW1hcnlLZXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgICAgICBkYXRhU291cmNlOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOWcqOWGheWuueWMuuWfn+a7muWKqOeahOaXtuWAmeinpuWPkeeahOWHveaVsFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvbkJvZHlTY3JvbGw6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAgICAgLi4uQmFzZUNvbXBvbmVudC5wcm9wVHlwZXMsXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAgICAgLi4uQmFzZUNvbXBvbmVudC5kZWZhdWx0UHJvcHMsXG4gICAgICAgICAgICBwcmltYXJ5S2V5OiAnaWQnLFxuICAgICAgICAgICAgcm93SGVpZ2h0OiBub29wLFxuICAgICAgICAgICAgbWF4Qm9keUhlaWdodDogMjAwLFxuICAgICAgICAgICAgY29tcG9uZW50czoge30sXG4gICAgICAgICAgICBwcmVmaXg6ICduZXh0LScsXG4gICAgICAgICAgICBvbkJvZHlTY3JvbGw6IG5vb3BcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgICAgIG9uVmlydHVhbFNjcm9sbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgICAgICBib2R5SGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAgICAgaW5uZXJUb3A6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgICAgICBnZXRCb2R5Tm9kZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgICAgICBnZXRUYWJsZUluc3RhbmNlRm9yVmlydHVhbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgICAgICByb3dTZWxlY3Rpb246IFByb3BUeXBlcy5vYmplY3RcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgcm93SGVpZ2h0OiB0aGlzLnByb3BzLnJvd0hlaWdodCxcbiAgICAgICAgICAgIHNjcm9sbFRvUm93OiB0aGlzLnByb3BzLnNjcm9sbFRvUm93LFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnByb3BzLm1heEJvZHlIZWlnaHRcbiAgICAgICAgfVxuXG4gICAgICAgIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb25WaXJ0dWFsU2Nyb2xsOiB0aGlzLm9uU2Nyb2xsLFxuICAgICAgICAgICAgICAgIGJvZHlIZWlnaHQ6IHRoaXMuY29tcHV0ZUJvZHlIZWlnaHQoKSxcbiAgICAgICAgICAgICAgICBpbm5lclRvcDogdGhpcy5jb21wdXRlSW5uZXJUb3AoKSxcbiAgICAgICAgICAgICAgICBnZXRCb2R5Tm9kZTogdGhpcy5nZXRCb2R5Tm9kZSxcbiAgICAgICAgICAgICAgICBnZXRUYWJsZUluc3RhbmNlRm9yVmlydHVhbDogdGhpcy5nZXRUYWJsZUluc3RhbmNlLFxuICAgICAgICAgICAgICAgIHJvd1NlbGVjdGlvbjogdGhpcy5yb3dTZWxlY3Rpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHVzZVZpcnR1YWwsIGRhdGFTb3VyY2UgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgICAgIHRoaXMuaGFzVmlydHVhbERhdGEgPSAgdXNlVmlydHVhbCAmJiBkYXRhU291cmNlICYmIGRhdGFTb3VyY2UubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNWaXJ0dWFsRGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFNjcm9sbFRvcCA9IHRoaXMuYm9keU5vZGUuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFkanVzdFNjcm9sbFRvcCgpO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RTaXplKCk7XG4gICAgICAgICAgICB0aGlzLnJlQ29tcHV0ZVNpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgICAgICBjb25zdCB7IHVzZVZpcnR1YWwsIGRhdGFTb3VyY2UgfSA9IG5leHRQcm9wcztcblxuICAgICAgICAgICAgdGhpcy5oYXNWaXJ0dWFsRGF0YSA9ICB1c2VWaXJ0dWFsICYmIGRhdGFTb3VyY2UgJiYgZGF0YVNvdXJjZS5sZW5ndGggPiAwO1xuXG4gICAgICAgICAgICBpZiAoJ21heEJvZHlIZWlnaHQnIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmhlaWdodCAhPT0gbmV4dFByb3BzLm1heEJvZHlIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG5leHRQcm9wcy5tYXhCb2R5SGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCdzY3JvbGxUb1JvdycgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvUm93OiBuZXh0UHJvcHMuc2Nyb2xsVG9Sb3dcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUucm93SGVpZ2h0ICYmICdyb3dIZWlnaHQnIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuZ2V0Um93Tm9kZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvd0NsaWVudEhlaWdodCA9IHJvdyAmJiByb3cuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChyb3dDbGllbnRIZWlnaHQgJiYgcm93Q2xpZW50SGVpZ2h0ICE9PSB0aGlzLnN0YXRlLnJvd0hlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0hlaWdodDogcm93Q2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RTY3JvbGxUb3AoKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0U2l6ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZUNvbXB1dGVTaXplKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZUNvbXB1dGVTaXplKCkge1xuICAgICAgICAgICAgY29uc3QgeyByb3dIZWlnaHQgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJvd0hlaWdodCA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLmhhc1ZpcnR1YWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5nZXRSb3dOb2RlKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93Q2xpZW50SGVpZ2h0ID0gcm93ICYmIHJvdy5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHJvd0NsaWVudEhlaWdodCAhPT0gdGhpcy5zdGF0ZS5yb3dIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dIZWlnaHQ6IHJvd0NsaWVudEhlaWdodFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb21wdXRlQm9keUhlaWdodCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcm93SGVpZ2h0IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhU291cmNlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByb3dIZWlnaHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhU291cmNlLmxlbmd0aCAqIHJvd0hlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXB1dGVJbm5lclRvcCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcm93SGVpZ2h0IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByb3dIZWlnaHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAodGhpcy5zdGFydCAqIHJvd0hlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRWaXNpYmxlUmFuZ2UoRXhwZWN0U3RhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaGVpZ2h0LCByb3dIZWlnaHQgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSB0aGlzLnByb3BzLmRhdGFTb3VyY2UubGVuZ3RoO1xuXG4gICAgICAgICAgICBsZXQgZW5kLCB2aXNpYmxlQ291bnQgPSAwO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygcm93SGVpZ2h0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJ5IGdldCBjZWxsIGhlaWdodDtcbiAgICAgICAgICAgICAgICBlbmQgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlQ291bnQgPSBwYXJzZUludChoZWlnaHQgLyByb3dIZWlnaHQsIDEwKTtcblxuICAgICAgICAgICAgICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIEV4cGVjdFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gRXhwZWN0U3RhcnQgPCBsZW4gPyBFeHBlY3RTdGFydCA6IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oK3N0YXJ0ICsgMSArIHZpc2libGVDb3VudCArIDEwLCBsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgICAgICB0aGlzLnZpc2libGVDb3VudCA9IHZpc2libGVDb3VudDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgYWRqdXN0U2Nyb2xsVG9wKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzVmlydHVhbERhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHlOb2RlLnNjcm9sbFRvcCA9IHRoaXMubGFzdFNjcm9sbFRvcCAlIHRoaXMuc3RhdGUucm93SGVpZ2h0ICsgdGhpcy5zdGF0ZS5yb3dIZWlnaHQgKiB0aGlzLnN0YXRlLnNjcm9sbFRvUm93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWRqdXN0U2l6ZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1ZpcnR1YWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuYm9keU5vZGU7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlydHVhbFNjcm9sbE5vZGUgPSBib2R5LnF1ZXJ5U2VsZWN0b3IoJ2RpdicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2xpZW50SGVpZ2h0LCBjbGllbnRXaWR0aCB9ID0gYm9keTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlSW5jID0gdGhpcy50YWJsZUluYztcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZU5vZGUgPSBmaW5kRE9NTm9kZSh0YWJsZUluYyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwcmVmaXggfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyTm9kZSA9IHRhYmxlTm9kZS5xdWVyeVNlbGVjdG9yKGAuJHtwcmVmaXh9dGFibGUtaGVhZGVyIHRhYmxlYCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyQ2xpZW50V2lkdGggPSBoZWFkZXJOb2RlICYmIGhlYWRlck5vZGUuY2xpZW50V2lkdGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2xpZW50V2lkdGggPCBoZWFkZXJDbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBkb20uc2V0U3R5bGUodmlydHVhbFNjcm9sbE5vZGUsICdtaW4td2lkdGgnLCBoZWFkZXJDbGllbnRXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlZnROb2RlID0gdGhpcy5ib2R5TGVmdE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0Tm9kZSA9IHRoaXMuYm9keVJpZ2h0Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdE5vZGUgJiYgZG9tLnNldFN0eWxlKGxlZnROb2RlLCAnbWF4LWhlaWdodCcsIGNsaWVudEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Tm9kZSAmJiBkb20uc2V0U3R5bGUocmlnaHROb2RlLCAnbWF4LWhlaWdodCcsIGNsaWVudEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzU2Nyb2xsYmFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc1Njcm9sbGJhciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgb25TY3JvbGwgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyDpgb/lhY3mqKrlkJHmu5rliqjluKbmnaXnmoTmgKfog73pl67pophcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IHRoaXMuYm9keU5vZGUuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgaWYgKHNjcm9sbFRvcCA9PT0gdGhpcy5sYXN0U2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmNvbXB1dGVTY3JvbGxUb1JvdyhzY3JvbGxUb3ApO1xuICAgICAgICAgICAgaWYgKCEoJ3Njcm9sbFRvUm93JyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb1Jvdzogc3RhcnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Cb2R5U2Nyb2xsKHN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMubGFzdFNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXB1dGVTY3JvbGxUb1JvdyhvZmZzZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcm93SGVpZ2h0IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBwYXJzZUludChvZmZzZXQgLyByb3dIZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0Qm9keU5vZGUgPSAobm9kZSwgbG9ja1R5cGUpID0+IHtcbiAgICAgICAgICAgIGxvY2tUeXBlID0gbG9ja1R5cGUgPyBsb2NrVHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGxvY2tUeXBlLnN1YnN0cigxKSA6ICcnO1xuICAgICAgICAgICAgdGhpc1tgYm9keSR7bG9ja1R5cGV9Tm9kZWBdID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFRhYmxlSW5zdGFuY2UgPSAodHlwZSwgaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlID8gdHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR5cGUuc3Vic3RyKDEpIDogJyc7XG4gICAgICAgICAgICB0aGlzW2B0YWJsZSR7dHlwZX1JbmNgXSA9IGluc3RhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0Um93Tm9kZSgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSBvZiBmaW5kaW5nIGFuIHVubW91bnRlZCBjb21wb25lbnQgZHVlIHRvIGNhY2hlZCBkYXRhXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBjbGVhciByZWZzIG9mIHRoaXMudGFibGVJbmMgd2hlbiBkYXRhU291cmNlIENoYW5nZWRcbiAgICAgICAgICAgICAgICAvLyB1c2UgdHJ5IGNhdGNoIGZvciB0ZW1wb3JhcnlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluZERPTU5vZGUodGhpcy50YWJsZUluYy5nZXRSb3dSZWYoMCkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBwcmVmZXItY29uc3QgKi9cbiAgICAgICAgICAgIGxldCB7IHVzZVZpcnR1YWwsIGNvbXBvbmVudHMsIGRhdGFTb3VyY2UsIGZpeGVkSGVhZGVyLCByb3dIZWlnaHQsIHNjcm9sbFRvUm93LCBvbkJvZHlTY3JvbGwsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICAgICAgY29uc3QgZW50aXJlRGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG5cbiAgICAgICAgICAgIHRoaXMucm93U2VsZWN0aW9uID0gdGhpcy5wcm9wcy5yb3dTZWxlY3Rpb247XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNWaXJ0dWFsRGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMgPSB7IC4uLmNvbXBvbmVudHMgfTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHRoaXMuZ2V0VmlzaWJsZVJhbmdlKHRoaXMuc3RhdGUuc2Nyb2xsVG9Sb3cpO1xuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UgPSBkYXRhU291cmNlLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnRzLkJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5Cb2R5ID0gVmlydHVhbEJvZHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpeGVkSGVhZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICg8QmFzZUNvbXBvbmVudCB7Li4ub3RoZXJzfSBkYXRhU291cmNlPXtkYXRhU291cmNlfSBlbnRpcmVEYXRhU291cmNlPXtlbnRpcmVEYXRhU291cmNlfSBjb21wb25lbnRzPXtjb21wb25lbnRzfSBmaXhlZEhlYWRlcj17Zml4ZWRIZWFkZXJ9IC8+KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWNzKFZpcnR1YWxUYWJsZSwgQmFzZUNvbXBvbmVudCk7XG4gICAgcmV0dXJuIFZpcnR1YWxUYWJsZTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS92aXJ0dWFsLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmaW5kRE9NTm9kZSB9ICBmcm9tICAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm9keUNvbXBvbmVudCBmcm9tICcuLi9iYXNlL2JvZHknO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9wcmVmZXItc3RhdGVsZXNzLWZ1bmN0aW9uICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaXJ0dWFsQm9keSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjb2xHcm91cDogUHJvcFR5cGVzLmFueVxuICAgIH1cblxuICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIG1heEJvZHlIZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgICAgICAgb25Cb2R5U2Nyb2xsOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25WaXJ0dWFsU2Nyb2xsOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25Mb2NrQm9keVNjcm9sbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGJvZHlIZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGlubmVyVG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBnZXROb2RlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgZ2V0Qm9keU5vZGU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBnZXRMb2NrTm9kZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGxvY2tUeXBlOiBQcm9wVHlwZXMub25lT2YoWydsZWZ0JywgJ3JpZ2h0J10pXG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnN0IGJvZHlOb2RlID0gZmluZERPTU5vZGUodGhpcyk7XG4gICAgICAgIC8vIC8vIGZvciBmaXhlZFxuICAgICAgICB0aGlzLmNvbnRleHQuZ2V0Tm9kZSgnYm9keScsIGJvZHlOb2RlKTtcbiAgICAgICAgLy8gZm9yIHZpcnR1YWxcbiAgICAgICAgdGhpcy5jb250ZXh0LmdldEJvZHlOb2RlKGJvZHlOb2RlLCB0aGlzLmNvbnRleHQubG9ja1R5cGUpO1xuICAgICAgICAvLyBmb3IgbG9ja1xuICAgICAgICB0aGlzLmNvbnRleHQuZ2V0TG9ja05vZGUoJ2JvZHknLCBib2R5Tm9kZSwgdGhpcy5jb250ZXh0LmxvY2tUeXBlKTtcbiAgICB9XG5cbiAgICB0YWJsZVJlZiA9ICh0YWJsZSkgPT4ge1xuICAgICAgICB0aGlzLnRhYmxlTm9kZSA9IHRhYmxlO1xuICAgIH1cblxuICAgIHZpcnR1YWxTY3JvbGxSZWYgPSAodmlydHVhbFNjcm9sbCkgPT4ge1xuICAgICAgICB0aGlzLnZpcnR1YWxTY3JvbGxOb2RlID0gdmlydHVhbFNjcm9sbDtcbiAgICB9XG5cbiAgICBvblNjcm9sbCA9ICgpID0+IHtcbiAgICAgICAgLy8gZm9yIGZpeGVkXG4gICAgICAgIHRoaXMuY29udGV4dC5vbkJvZHlTY3JvbGwoKTtcbiAgICAgICAgLy8gZm9yIGxvY2tcbiAgICAgICAgdGhpcy5jb250ZXh0Lm9uTG9ja0JvZHlTY3JvbGwoKTtcbiAgICAgICAgLy8gZm9yIHZpcnR1YWxcbiAgICAgICAgdGhpcy5jb250ZXh0Lm9uVmlydHVhbFNjcm9sbCgpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIGNsYXNzTmFtZSwgY29sR3JvdXAsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3Qge21heEJvZHlIZWlnaHQsIGJvZHlIZWlnaHQsIGlubmVyVG9wfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgcmV0dXJuICg8ZGl2IHN0eWxlPXt7bWF4SGVpZ2h0OiBtYXhCb2R5SGVpZ2h0fX0gY2xhc3NOYW1lPXtjbGFzc05hbWV9IG9uU2Nyb2xsPXt0aGlzLm9uU2Nyb2xsfT5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3toZWlnaHQ6IGJvZHlIZWlnaHQsIG92ZXJmbG93OiAnaGlkZGVuJywgcG9zaXRpb246ICdyZWxhdGl2ZSd9fSByZWY9e3RoaXMudmlydHVhbFNjcm9sbFJlZn0+XG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17e2hlaWdodDogJzEwMCUnLCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWSgke2lubmVyVG9wfXB4KWB9fT5cbiAgICAgICAgICAgICAgICAgICAgPHRhYmxlIHJlZj17dGhpcy50YWJsZVJlZn0+XG4gICAgICAgICAgICAgICAgICAgICAgICB7Y29sR3JvdXB9XG4gICAgICAgICAgICAgICAgICAgICAgICA8Qm9keUNvbXBvbmVudCB7Li4ub3RoZXJzfSBwcmVmaXg9e3ByZWZpeH0vPlxuICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2Pik7XG4gICAgfVxufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvdmlydHVhbC9ib2R5LmpzeCIsImltcG9ydCBSZWFjdCwgeyBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBzaGFsbG93RWxlbWVudEVxdWFscyBmcm9tICdzaGFsbG93LWVsZW1lbnQtZXF1YWxzJztcbmltcG9ydCB7IGRvbSwgbG9nLCBvYmosIGV2ZW50cyB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IExvY2tSb3cgZnJvbSAnLi9sb2NrL3Jvdyc7XG5pbXBvcnQgTG9ja0JvZHkgZnJvbSAnLi9sb2NrL2JvZHknO1xuaW1wb3J0IExvY2tIZWFkZXIgZnJvbSAnLi9sb2NrL2hlYWRlcic7XG5pbXBvcnQgTG9ja1dyYXBwZXIgZnJvbSAnLi9maXhlZC93cmFwcGVyJztcbmltcG9ydCB7IHN0YXRpY3MgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsb2NrKEJhc2VDb21wb25lbnQpIHtcbiAgICAvKiogVGFibGUgKi9cbiAgICBjbGFzcyBMb2NrVGFibGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgICAgICBzdGF0aWMgTG9ja1JvdyA9IExvY2tSb3c7XG4gICAgICAgIHN0YXRpYyBMb2NrQm9keSA9IExvY2tCb2R5O1xuICAgICAgICBzdGF0aWMgTG9ja0hlYWRlciA9IExvY2tIZWFkZXI7XG4gICAgICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgICAgICBzY3JvbGxUb0NvbDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5oyH5a6a5rua5Yqo5Yiw5p+Q5LiA6KGM77yM5LuF5ZyoYHVzZVZpcnR1YWxg55qE5pe25YCZ55Sf5pWIXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNjcm9sbFRvUm93OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAgICAgLi4uQmFzZUNvbXBvbmVudC5wcm9wVHlwZXNcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgICAgICAuLi5CYXNlQ29tcG9uZW50LmRlZmF1bHRQcm9wc1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGljIGNoaWxkQ29udGV4dFR5cGVzID0ge1xuICAgICAgICAgICAgZ2V0VGFibGVJbnN0YW5jZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgICAgICBnZXRMb2NrTm9kZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgICAgICBvbkxvY2tCb2R5U2Nyb2xsOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgICAgIG9uTG9ja0JvZHlXaGVlbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgICAgICBvblJvd01vdXNlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAgICAgb25Sb3dNb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuY1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHRoaXMubG9ja0xlZnRDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgdGhpcy5sb2NrUmlnaHRDaGlsZHJlbiA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBnZXRUYWJsZUluc3RhbmNlOiB0aGlzLmdldFRhYmxlSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgZ2V0TG9ja05vZGU6IHRoaXMuZ2V0Tm9kZSxcbiAgICAgICAgICAgICAgICBvbkxvY2tCb2R5V2hlZWw6IHRoaXMub25Mb2NrQm9keVdoZWVsLFxuICAgICAgICAgICAgICAgIG9uTG9ja0JvZHlTY3JvbGw6IHRoaXMub25Mb2NrQm9keVNjcm9sbCxcbiAgICAgICAgICAgICAgICBvblJvd01vdXNlRW50ZXI6IHRoaXMub25Sb3dNb3VzZUVudGVyLFxuICAgICAgICAgICAgICAgIG9uUm93TW91c2VMZWF2ZTogdGhpcy5vblJvd01vdXNlTGVhdmVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0U2l6ZSA9IHRoaXMuYWRqdXN0U2l6ZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLmFkanVzdFNpemUoKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsKCk7XG5cbiAgICAgICAgICAgIGV2ZW50cy5vbih3aW5kb3csICdyZXNpemUnLCB0aGlzLmFkanVzdFNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCkge1xuICAgICAgICAgICAgaWYgKG5leHRQcm9wcy5wdXJlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNFcXVhbCA9IHNoYWxsb3dFbGVtZW50RXF1YWxzKG5leHRQcm9wcywgdGhpcy5wcm9wcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEoaXNFcXVhbCAmJiBvYmouc2hhbGxvd0VxdWFsKG5leHRDb250ZXh0LCB0aGlzLmNvbnRleHQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnRXaWxsVXBkYXRlKCkge1xuICAgICAgICAgICAgdGhpcy5faXNMb2NrID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFNpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICAgICAgZXZlbnRzLm9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLmFkanVzdFNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW5TdGF0ZShwcm9wcykge1xuICAgICAgICAgICAgbGV0IHsgY2hpbGRyZW4gfSA9IHByb3BzO1xuICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0Q2hpbGRyZW4gPSB0aGlzLnNwbGl0RnJvbU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbG9ja0xlZnRDaGlsZHJlbiwgbG9ja1JpZ2h0Q2hpbGRyZW4gfSA9IHNwbGl0Q2hpbGRyZW47XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxvY2tMZWZ0Q2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgbG9ja1JpZ2h0Q2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IHRoaXMubWVyZ2VGcm9tU3BsaXRMb2NrQ2hpbGRyZW4oc3BsaXRDaGlsZHJlbilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyDlsIZSZWFjdOe7k+aehOWMluaVsOaNruaPkOWPlnByb3Bz6L2s5o2i5oiQ5pWw57uEXG4gICAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgaXNMb2NrID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBnZXRDaGlsZHJlbiA9IChjaGlsZHJlbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgICAgICAgICAgIENoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IHsgLi4uY2hpbGQucHJvcHMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChbdHJ1ZSwgJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKHByb3BzLmxvY2spID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xvY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCd3aWR0aCcgaW4gcHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy53YXJuaW5nKGBTaG91bGQgY29uZmlnIHdpZHRoIGZvciBsb2NrIGNvbHVtbiBuYW1lZCBbICR7cHJvcHMuZGF0YUluZGV4fSBdLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oY2hpbGQucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXQgPSBnZXRDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgICAgICAgICByZXQuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgLy8g5Li66Ieq5a6a5LmJ55qE5YiX54m55q6K5aSE55CGXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLl9fbm9ybWFsaXplZCAmJiBpc0xvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQubG9jayA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNoaWxkLl9fbm9ybWFsaXplZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2lzTG9jayA9IGlzTG9jaztcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvL+S7juaVsOe7hOS4reWIhuemu+WHumxvY2vnmoTliJflkozmraPluLjnmoTliJdcbiAgICAgICAgc3BsaXRGcm9tTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbkNoaWxkcmVuID0gZGVlcENvcHkoY2hpbGRyZW4pO1xuICAgICAgICAgICAgY29uc3QgbG9ja0xlZnRDaGlsZHJlbiA9IGRlZXBDb3B5KGNoaWxkcmVuKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2tSaWdodENoaWxkcmVuID0gZGVlcENvcHkoY2hpbGRyZW4pO1xuICAgICAgICAgICAgY29uc3QgbG9vcCA9IChsb2NrQ2hpbGRyZW4sIGNvbmRpdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgICAgICAgICAgIGxvY2tDaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGxvb3AoY2hpbGQuY2hpbGRyZW4sIGNvbmRpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmRlciA9IGNvbmRpdGlvbihjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9yZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0LmZvckVhY2gocmVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBsb2NrQ2hpbGRyZW4uaW5kZXhPZihyZXMpO1xuICAgICAgICAgICAgICAgICAgICBsb2NrQ2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9ja0NoaWxkcmVuO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxvb3AobG9ja0xlZnRDaGlsZHJlbiwgKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmxvY2sgPT09IHRydWUgfHwgY2hpbGQubG9jayA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb29wKGxvY2tSaWdodENoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubG9jayA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxvb3Aob3JpZ2luQ2hpbGRyZW4sIChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5sb2NrICE9PSB0cnVlICYmIGNoaWxkLmxvY2sgIT09ICdsZWZ0JyAmJiBjaGlsZC5sb2NrICE9PSAncmlnaHQnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxvY2tMZWZ0Q2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgbG9ja1JpZ2h0Q2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgb3JpZ2luQ2hpbGRyZW5cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvL+WwhuW3puS+p+eahOmUgeWIl+agkeWSjOS4remXtOeahOaZrumAmuagkeWPiuWPs+S+p+eahOmUgeWIl+agkei/m+ihjOWQiOW5tlxuICAgICAgICBtZXJnZUZyb21TcGxpdExvY2tDaGlsZHJlbihzcGxpdENoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb25zdCB7IGxvY2tMZWZ0Q2hpbGRyZW4sIGxvY2tSaWdodENoaWxkcmVuIH0gPSBzcGxpdENoaWxkcmVuO1xuICAgICAgICAgICAgbGV0IHsgb3JpZ2luQ2hpbGRyZW4gfSA9IHNwbGl0Q2hpbGRyZW47XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShvcmlnaW5DaGlsZHJlbiwgbG9ja0xlZnRDaGlsZHJlbik7XG4gICAgICAgICAgICBvcmlnaW5DaGlsZHJlbiA9IG9yaWdpbkNoaWxkcmVuLmNvbmNhdChsb2NrUmlnaHRDaGlsZHJlbik7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luQ2hpbGRyZW47XG4gICAgICAgIH1cblxuICAgICAgICBnZXRUYWJsZUluc3RhbmNlID0gKHR5cGUsIGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZSA/IHR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eXBlLnN1YnN0cigxKSA6ICcnO1xuICAgICAgICAgICAgdGhpc1tgdGFibGUke3R5cGV9SW5jYF0gPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldE5vZGUgPSAodHlwZSwgbm9kZSwgbG9ja1R5cGUpID0+IHtcbiAgICAgICAgICAgIGxvY2tUeXBlID0gbG9ja1R5cGUgPyBsb2NrVHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGxvY2tUeXBlLnN1YnN0cigxKSA6ICcnO1xuICAgICAgICAgICAgdGhpc1tgJHt0eXBlfSR7bG9ja1R5cGV9Tm9kZWBdID0gbm9kZTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnaGVhZGVyJyAmJiAhdGhpcy5pbm5lckhlYWRlck5vZGUgJiYgIWxvY2tUeXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lckhlYWRlck5vZGUgPSB0aGlzLmhlYWRlck5vZGUucXVlcnlTZWxlY3RvcignZGl2Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvblJvd01vdXNlRW50ZXIgPSAocmVjb3JkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2NrKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3cgPSB0aGlzLmdldFJvd05vZGUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRSb3cgPSB0aGlzLmdldFJvd05vZGUoaW5kZXgsICdsZWZ0Jyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHRSb3cgPSB0aGlzLmdldFJvd05vZGUoaW5kZXgsICdyaWdodCcpO1xuICAgICAgICAgICAgICAgIFtyb3csIGxlZnRSb3csIHJpZ2h0Um93XS5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJvdyAmJiBkb20uYWRkQ2xhc3Mocm93LCAnaG92ZXJlZCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb25Sb3dNb3VzZUxlYXZlID0gKHJlY29yZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTG9jaygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5nZXRSb3dOb2RlKGluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0Um93ID0gdGhpcy5nZXRSb3dOb2RlKGluZGV4LCAnbGVmdCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0Um93ID0gdGhpcy5nZXRSb3dOb2RlKGluZGV4LCAncmlnaHQnKTtcbiAgICAgICAgICAgICAgICBbcm93LCBsZWZ0Um93LCByaWdodFJvd10uZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgICAgICAgICByb3cgJiYgZG9tLnJlbW92ZUNsYXNzKHJvdywgJ2hvdmVyZWQnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNjcm9sbCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsVG9Db2wgPSAwLCBzY3JvbGxUb1JvdyA9IDAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAoIXNjcm9sbFRvQ29sICYmICFzY3JvbGxUb1Jvdykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbENlbGxOb2RlID0gdGhpcy5nZXRDZWxsTm9kZSgwLCBzY3JvbGxUb0NvbCk7XG4gICAgICAgICAgICBjb25zdCByb3dDZWxsTm9kZSA9IHRoaXMuZ2V0Q2VsbE5vZGUoc2Nyb2xsVG9Sb3csIDApO1xuICAgICAgICAgICAgY29uc3QgYm9keU5vZGVPZmZzZXQgPSB0aGlzLmJvZHlOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgaWYgKGNvbENlbGxOb2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbE5vZGVvZmZzZXQgPSBjb2xDZWxsTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JvbGxMZWZ0ID0gY2VsbE5vZGVvZmZzZXQubGVmdCAtIGJvZHlOb2RlT2Zmc2V0LmxlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Tm9kZS5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb3dDZWxsTm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxOb2Rlb2Zmc2V0ID0gcm93Q2VsbE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gY2VsbE5vZGVvZmZzZXQudG9wIC0gYm9keU5vZGVPZmZzZXQudG9wO1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keU5vZGUuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb25Mb2NrQm9keVdoZWVsID0gKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBlLmRlbHRhWTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTG9jaygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9ja1JpZ2h0Qm9keSA9IHRoaXMuYm9keVJpZ2h0Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgbG9ja0xlZnRCb2R5ID0gdGhpcy5ib2R5TGVmdE5vZGUsXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbE5vZGUgPSB0aGlzLmJvZHlOb2RlLFxuICAgICAgICAgICAgICAgICAgICB7IHNjcm9sbFRvcCwgY2xpZW50SGVpZ2h0LCBzY3JvbGxIZWlnaHQgfSA9IHNjcm9sbE5vZGU7XG5cbiAgICAgICAgICAgICAgICBpZiAobG9ja0xlZnRCb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2tMZWZ0Qm9keS5zY3JvbGxUb3AgPSB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobG9ja1JpZ2h0Qm9keSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NrUmlnaHRCb2R5LnNjcm9sbFRvcCA9IHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNjcm9sbE5vZGUuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wICsgeTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNjcm9sbFRvcDogbmV3U2Nyb2xsVG9wIH0gPSBzY3JvbGxOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChuZXdTY3JvbGxUb3AgKyBjbGllbnRIZWlnaHQgPCBzY3JvbGxIZWlnaHQgJiYgbmV3U2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvbkxvY2tCb2R5U2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2NrKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NrUmlnaHRCb2R5ID0gdGhpcy5ib2R5UmlnaHROb2RlLFxuICAgICAgICAgICAgICAgICAgICBsb2NrTGVmdEJvZHkgPSB0aGlzLmJvZHlMZWZ0Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgbG9ja1JpZ2h0VGFibGUgPSB0aGlzLmdldFdyYXBwZXJOb2RlKCdyaWdodCcpLFxuICAgICAgICAgICAgICAgICAgICBsb2NrTGVmdFRhYmxlID0gdGhpcy5nZXRXcmFwcGVyTm9kZSgnbGVmdCcpLFxuICAgICAgICAgICAgICAgICAgICBzaGFkb3dDbGFzc05hbWUgPSAnc2hhZG93JztcblxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmJvZHlOb2RlLnNjcm9sbExlZnQsIHkgPSB0aGlzLmJvZHlOb2RlLnNjcm9sbFRvcDtcblxuICAgICAgICAgICAgICAgIGlmIChsb2NrTGVmdEJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9ja0xlZnRCb2R5LnNjcm9sbFRvcCA9IHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsb2NrUmlnaHRCb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2tSaWdodEJvZHkuc2Nyb2xsVG9wID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbG9ja0xlZnRUYWJsZSAmJiBkb20ucmVtb3ZlQ2xhc3MobG9ja0xlZnRUYWJsZSwgc2hhZG93Q2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbG9ja1JpZ2h0VGFibGUgJiYgZG9tLmFkZENsYXNzKGxvY2tSaWdodFRhYmxlLCBzaGFkb3dDbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeCA9PT0gKHRoaXMuYm9keU5vZGUuc2Nyb2xsV2lkdGggLSB0aGlzLmJvZHlOb2RlLmNsaWVudFdpZHRoKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NrTGVmdFRhYmxlICYmIGRvbS5hZGRDbGFzcyhsb2NrTGVmdFRhYmxlLCBzaGFkb3dDbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICBsb2NrUmlnaHRUYWJsZSAmJiBkb20ucmVtb3ZlQ2xhc3MobG9ja1JpZ2h0VGFibGUsIHNoYWRvd0NsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9ja0xlZnRUYWJsZSAmJiBkb20uYWRkQ2xhc3MobG9ja0xlZnRUYWJsZSwgc2hhZG93Q2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbG9ja1JpZ2h0VGFibGUgJiYgZG9tLmFkZENsYXNzKGxvY2tSaWdodFRhYmxlLCBzaGFkb3dDbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRhYmxl5aSE55CG6L+H5ZCO55yf5a6e55qEbG9ja+eKtuaAgVxuICAgICAgICBpc0xvY2soKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NrTGVmdENoaWxkcmVuLmxlbmd0aCB8fCB0aGlzLmxvY2tSaWdodENoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOeUqOaIt+iuvue9rueahGxvY2vnirbmgIFcbiAgICAgICAgaXNPcmlnaW5Mb2NrKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzTG9jaztcbiAgICAgICAgfVxuXG4gICAgICAgIGFkanVzdFNpemUoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWRqdXN0SWZUYWJsZU5vdE5lZWRMb2NrKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkanVzdEhlYWRlclNpemUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkanVzdEJvZHlTaXplKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGp1c3RDZWxsU2l6ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMub25Mb2NrQm9keVNjcm9sbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWRqdXN0SWZUYWJsZU5vdE5lZWRMb2NrKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNPcmlnaW5Mb2NrKCkgJiYgdGhpcy50YWJsZUluYy5wcm9wcy5kYXRhU291cmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZ1dpZHRocyA9IHRoaXMudGFibGVJbmMuZmxhdENoaWxkcmVuLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5nZXRDZWxsTm9kZSgwLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAocm93ICYmIHJvdy5jbGllbnRXaWR0aCkgfHwgMDtcbiAgICAgICAgICAgICAgICB9KS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IG5vZGUuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9ja0xlZnRMZW4gPSB0aGlzLmxvY2tMZWZ0Q2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2tSaWdodExlbiA9IHRoaXMubG9ja1JpZ2h0Q2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ1dpZHRocyA8PSB3aWR0aCAmJiBjb25maWdXaWR0aHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NrTGVmdExlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbm90TmVlZEFkanVzdExvY2tMZWZ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobG9ja1JpZ2h0TGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub3ROZWVkQWRqdXN0TG9ja1JpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobG9ja1JpZ2h0TGVuIHx8IGxvY2tMZWZ0TGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbm90TmVlZEFkanVzdExvY2tMZWZ0IHx8IHRoaXMuX25vdE5lZWRBZGp1c3RMb2NrUmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbm90TmVlZEFkanVzdExvY2tMZWZ0ID0gdGhpcy5fbm90TmVlZEFkanVzdExvY2tSaWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbm90TmVlZEFkanVzdExvY2tMZWZ0ID0gdGhpcy5fbm90TmVlZEFkanVzdExvY2tSaWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBhZGp1c3RCb2R5U2l6ZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTG9jaygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuYm9keU5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGxvY2tMZWZ0Qm9keSA9IHRoaXMuYm9keUxlZnROb2RlLFxuICAgICAgICAgICAgICAgICAgICBsb2NrUmlnaHRCb2R5ID0gdGhpcy5ib2R5UmlnaHROb2RlLFxuICAgICAgICAgICAgICAgICAgICBsb2NrUmlnaHRCb2R5V3JhcHBlciA9IHRoaXMuZ2V0V3JhcHBlck5vZGUoJ3JpZ2h0JyksXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhciA9IGRvbS5zY3JvbGxiYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgYm9keUhlaWdodCA9IGJvZHkub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBoYXNIb3pTY3JvbGwgPSBib2R5LnNjcm9sbFdpZHRoID4gYm9keS5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGFzVmVyU2Nyb2xsID0gYm9keS5zY3JvbGxIZWlnaHQgPiBib2R5LmNsaWVudEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBoYXNWZXJTY3JvbGwgPyBzY3JvbGxiYXIud2lkdGggOiAwLFxuICAgICAgICAgICAgICAgICAgICBsb2NrQm9keUhlaWdodCA9IGJvZHlIZWlnaHQgLSAoaGFzSG96U2Nyb2xsID8gc2Nyb2xsYmFyLmhlaWdodCA6IDApO1xuXG4gICAgICAgICAgICAgICAgbG9ja0xlZnRCb2R5ICYmIGRvbS5zZXRTdHlsZShsb2NrTGVmdEJvZHksICdtYXgtaGVpZ2h0JywgbG9ja0JvZHlIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGxvY2tSaWdodEJvZHkgJiYgZG9tLnNldFN0eWxlKGxvY2tSaWdodEJvZHksICdtYXgtaGVpZ2h0JywgbG9ja0JvZHlIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGxvY2tSaWdodEJvZHlXcmFwcGVyICYmIGRvbS5zZXRTdHlsZShsb2NrUmlnaHRCb2R5V3JhcHBlciwgJ3JpZ2h0Jywgd2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWRqdXN0SGVhZGVyU2l6ZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTG9jaygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWJsZUluYy5ncm91cENoaWxkcmVuLmZvckVhY2goKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0SW5kZXggPSB0aGlzLnRhYmxlSW5jLmdyb3VwQ2hpbGRyZW5baW5kZXhdLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJSaWdodFJvdyA9IHRoaXMuZ2V0SGVhZGVyQ2VsbE5vZGUoaW5kZXgsIGxhc3RJbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJMZWZ0Um93ID0gdGhpcy5nZXRIZWFkZXJDZWxsTm9kZShpbmRleCwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJSaWdodExvY2tSb3cgPSB0aGlzLmdldEhlYWRlckNlbGxOb2RlKGluZGV4LCAwLCAncmlnaHQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlckxlZnRMb2NrUm93ID0gdGhpcy5nZXRIZWFkZXJDZWxsTm9kZShpbmRleCwgMCwgJ2xlZnQnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyUmlnaHRSb3cgJiYgaGVhZGVyUmlnaHRMb2NrUm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhSaWdodFJvd0hlaWdodCA9IGhlYWRlclJpZ2h0Um93Lm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnNldFN0eWxlKGhlYWRlclJpZ2h0TG9ja1JvdywgJ2hlaWdodCcsIG1heFJpZ2h0Um93SGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YWJsZVJpZ2h0SW5jLmFmZml4UmVmICYmIHRoaXMudGFibGVSaWdodEluYy5hZmZpeFJlZi5nZXRJbnN0YW5jZSgpLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWFkZXJMZWZ0Um93ICYmIGhlYWRlckxlZnRMb2NrUm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhMZWZ0Um93SGVpZ2h0ID0gaGVhZGVyTGVmdFJvdy5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5zZXRTdHlsZShoZWFkZXJMZWZ0TG9ja1JvdywgJ2hlaWdodCcsIG1heExlZnRSb3dIZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhYmxlTGVmdEluYy5hZmZpeFJlZiAmJiB0aGlzLnRhYmxlTGVmdEluYy5hZmZpeFJlZi5nZXRJbnN0YW5jZSgpLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhZGp1c3RDZWxsU2l6ZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTG9jaygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWJsZUluYy5wcm9wcy5kYXRhU291cmNlLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2tMZWZ0Um93ID0gdGhpcy5nZXRDZWxsTm9kZShpbmRleCwgMCwgJ2xlZnQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2tSaWdodFJvdyA9IHRoaXMuZ2V0Q2VsbE5vZGUoaW5kZXgsIDAsICdyaWdodCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gdGhpcy5nZXRGaXJzdE5vcm1hbENlbGxOb2RlKGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0hlaWdodCA9IHJvdyAmJiBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUocm93KS5oZWlnaHQpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsb2NrTGVmdEhlaWdodCA9IDAsIGxvY2tSaWdodEhlaWdodCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2tMZWZ0Um93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NrTGVmdEhlaWdodCA9IGxvY2tMZWZ0Um93Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobG9ja1JpZ2h0Um93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NrUmlnaHRIZWlnaHQgPSBsb2NrUmlnaHRSb3cub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NrTGVmdFJvdyAmJiByb3dIZWlnaHQgIT09IGxvY2tMZWZ0SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb20uc2V0U3R5bGUobG9ja0xlZnRSb3csICdoZWlnaHQnLCByb3dIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NrUmlnaHRSb3cgJiYgcm93SGVpZ2h0ICE9PSBsb2NrUmlnaHRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5zZXRTdHlsZShsb2NrUmlnaHRSb3csICdoZWlnaHQnLCByb3dIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZXRXcmFwcGVyTm9kZSh0eXBlKSB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZSA/IHR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eXBlLnN1YnN0cigxKSA6ICcnO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIG9mIGZpbmRpbmcgYW4gdW5tb3VudGVkIGNvbXBvbmVudCBkdWUgdG8gY2FjaGVkIGRhdGFcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGNsZWFyIHJlZnMgb2YgdGFibGUgd2hlbiBkYXRhU291cmNlIENoYW5nZWRcbiAgICAgICAgICAgICAgICAvLyB1c2UgdHJ5IGNhdGNoIGZvciB0ZW1wb3JhcnlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluZERPTU5vZGUodGhpcy5yZWZzW2Bsb2NrJHt0eXBlfWBdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZXRGaXJzdE5vcm1hbENlbGxOb2RlKGluZGV4KSB7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBsZXQgcm93O1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJvdyA9IHRoaXMuZ2V0Q2VsbE5vZGUoaW5kZXgsIGkpO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gd2hpbGUgKCghcm93IHx8IHJvdyAmJiByb3cucm93U3BhbiAmJiByb3cucm93U3BhbiA+IDEpICYmIHRoaXMudGFibGVJbmMuZmxhdENoaWxkcmVuLmxlbmd0aCA+IGkpO1xuXG4gICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0Um93Tm9kZShpbmRleCwgdHlwZSkge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUgPyB0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zdWJzdHIoMSkgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gdGhpc1tgdGFibGUke3R5cGV9SW5jYF07XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSBvZiBmaW5kaW5nIGFuIHVubW91bnRlZCBjb21wb25lbnQgZHVlIHRvIGNhY2hlZCBkYXRhXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBjbGVhciByZWZzIG9mIHRhYmxlIHdoZW4gZGF0YVNvdXJjZSBDaGFuZ2VkXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRyeSBjYXRjaCBmb3IgdGVtcG9yYXJ5XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRET01Ob2RlKHRhYmxlLmdldFJvd1JlZihpbmRleCkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdldEhlYWRlckNlbGxOb2RlKGluZGV4LCBpLCB0eXBlKSB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZSA/IHR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eXBlLnN1YnN0cigxKSA6ICcnO1xuICAgICAgICAgICAgY29uc3QgdGFibGUgPSB0aGlzW2B0YWJsZSR7dHlwZX1JbmNgXTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIG9mIGZpbmRpbmcgYW4gdW5tb3VudGVkIGNvbXBvbmVudCBkdWUgdG8gY2FjaGVkIGRhdGFcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGNsZWFyIHJlZnMgb2YgdGFibGUgd2hlbiBkYXRhU291cmNlIENoYW5nZWRcbiAgICAgICAgICAgICAgICAvLyB1c2UgdHJ5IGNhdGNoIGZvciB0ZW1wb3JhcnlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluZERPTU5vZGUodGFibGUuZ2V0SGVhZGVyQ2VsbFJlZihpbmRleCwgaSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdldENlbGxOb2RlKGluZGV4LCBpLCB0eXBlKSB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZSA/IHR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eXBlLnN1YnN0cigxKSA6ICcnO1xuICAgICAgICAgICAgY29uc3QgdGFibGUgPSB0aGlzW2B0YWJsZSR7dHlwZX1JbmNgXTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIG9mIGZpbmRpbmcgYW4gdW5tb3VudGVkIGNvbXBvbmVudCBkdWUgdG8gY2FjaGVkIGRhdGFcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGNsZWFyIHJlZnMgb2YgdGFibGUgd2hlbiBkYXRhU291cmNlIENoYW5nZWRcbiAgICAgICAgICAgICAgICAvLyB1c2UgdHJ5IGNhdGNoIGZvciB0ZW1wb3JhcnlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluZERPTU5vZGUodGFibGUuZ2V0Q2VsbFJlZihpbmRleCwgaSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBwcmVmZXItY29uc3QgKi9cbiAgICAgICAgICAgIGxldCB7IGNoaWxkcmVuLCBwcmVmaXgsIGNvbXBvbmVudHMsIGNsYXNzTmFtZSwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgbGV0IHsgbG9ja0xlZnRDaGlsZHJlbiwgbG9ja1JpZ2h0Q2hpbGRyZW4sIGNoaWxkcmVuOiBub3JtYWxpemVkQ2hpbGRyZW4gfSA9IHRoaXMubm9ybWFsaXplQ2hpbGRyZW5TdGF0ZSh0aGlzLnByb3BzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ub3ROZWVkQWRqdXN0TG9ja0xlZnQpIHtcbiAgICAgICAgICAgICAgICBsb2NrTGVmdENoaWxkcmVuID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbm90TmVlZEFkanVzdExvY2tSaWdodCkge1xuICAgICAgICAgICAgICAgIGxvY2tSaWdodENoaWxkcmVuID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvY2tMZWZ0Q2hpbGRyZW4gPSBsb2NrTGVmdENoaWxkcmVuO1xuICAgICAgICAgICAgdGhpcy5sb2NrUmlnaHRDaGlsZHJlbiA9IGxvY2tSaWdodENoaWxkcmVuO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc09yaWdpbkxvY2soKSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMgPSB7IC4uLmNvbXBvbmVudHMgfTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLkJvZHkgPSBjb21wb25lbnRzLkJvZHkgfHwgTG9ja0JvZHk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5IZWFkZXIgPSBjb21wb25lbnRzLkhlYWRlciB8fCBMb2NrSGVhZGVyO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuV3JhcHBlciA9IGNvbXBvbmVudHMuV3JhcHBlciB8fCBMb2NrV3JhcHBlcjtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLlJvdyA9IGNvbXBvbmVudHMuUm93IHx8IExvY2tSb3c7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9dGFibGUtbG9ja2BdOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBbY2xhc3NOYW1lXTogY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgPEJhc2VDb21wb25lbnQgey4uLm90aGVyc30ga2V5PVwibG9jay1sZWZ0XCIgY29sdW1ucz17bG9ja0xlZnRDaGlsZHJlbn0gY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtbG9jay1sZWZ0YH0gcHJlZml4PXtwcmVmaXh9IGxvY2tUeXBlPVwibGVmdFwiIGNvbXBvbmVudHM9e2NvbXBvbmVudHN9IHJlZj1cImxvY2tMZWZ0XCIgbG9hZGluZz17ZmFsc2V9IC8+LFxuICAgICAgICAgICAgICAgICAgICA8QmFzZUNvbXBvbmVudCB7Li4ub3RoZXJzfSBrZXk9XCJsb2NrLXJpZ2h0XCIgY29sdW1ucz17bG9ja1JpZ2h0Q2hpbGRyZW59IGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLWxvY2stcmlnaHRgfSBwcmVmaXg9e3ByZWZpeH0gbG9ja1R5cGU9XCJyaWdodFwiIGNvbXBvbmVudHM9e2NvbXBvbmVudHN9IHJlZj1cImxvY2tSaWdodFwiIGxvYWRpbmc9e2ZhbHNlfSAvPlxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIDxCYXNlQ29tcG9uZW50IHsuLi5vdGhlcnN9IGNvbHVtbnM9e25vcm1hbGl6ZWRDaGlsZHJlbn0gcHJlZml4PXtwcmVmaXh9IHdyYXBwZXJDb250ZW50PXtjb250ZW50fSBjb21wb25lbnRzPXtjb21wb25lbnRzfSBjbGFzc05hbWU9e2NsYXNzTmFtZX0gLz47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDxCYXNlQ29tcG9uZW50IHsuLi50aGlzLnByb3BzfSAvPik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljcyhMb2NrVGFibGUsIEJhc2VDb21wb25lbnQpO1xuICAgIHJldHVybiBMb2NrVGFibGU7XG59XG5cblxuZnVuY3Rpb24gZGVlcENvcHkoYXJyKSB7XG4gICAgbGV0IGNvcHkgPSAoYXJyKSA9PiB7XG4gICAgICAgIHJldHVybiBhcnIubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3SXRlbSA9IHsgLi4uaXRlbSB9O1xuICAgICAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNoaWxkcmVuID0gY29weShpdGVtLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdJdGVtO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBjb3B5KGFycik7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvbG9jay5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBGaXhlZEJvZHkgZnJvbSAnLi4vZml4ZWQvYm9keSc7XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3ByZWZlci1zdGF0ZWxlc3MtZnVuY3Rpb24gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvY2tCb2R5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAuLi5GaXhlZEJvZHkucHJvcFR5cGVzXG4gICAgfVxuXG4gICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgLi4uRml4ZWRCb2R5LmNvbnRleHRUeXBlcyxcbiAgICAgICAgZ2V0TG9ja05vZGU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkxvY2tCb2R5U2Nyb2xsOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25Mb2NrQm9keVdoZWVsOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgbG9ja1R5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2xlZnQnLCAncmlnaHQnXSlcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmdldExvY2tOb2RlKCdib2R5JywgZmluZERPTU5vZGUodGhpcyksIHRoaXMuY29udGV4dC5sb2NrVHlwZSk7XG4gICAgfVxuXG4gICAgb25Cb2R5U2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmNvbnRleHQub25Mb2NrQm9keVNjcm9sbCgpO1xuICAgIH1cblxuICAgIG9uQm9keVdoZWVsID0gKGUpID0+IHtcbiAgICAgICAgdGhpcy5jb250ZXh0Lm9uTG9ja0JvZHlXaGVlbChlKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiA8Rml4ZWRCb2R5IHsuLi50aGlzLnByb3BzfSBvblNjcm9sbD17dGhpcy5vbkJvZHlTY3JvbGx9IG9uV2hlZWw9e3RoaXMub25Cb2R5V2hlZWx9IC8+O1xuICAgIH1cbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2xvY2svYm9keS5qc3giLCJpbXBvcnQgeyBmaW5kRE9NTm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEZpeGVkSGVhZGVyIGZyb20gJy4uL2ZpeGVkL2hlYWRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvY2tIZWFkZXIgZXh0ZW5kcyBGaXhlZEhlYWRlciB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLi4uRml4ZWRIZWFkZXIucHJvcFR5cGVzXG4gICAgfVxuXG4gICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgLi4uRml4ZWRIZWFkZXIuY29udGV4dFR5cGVzLFxuICAgICAgICBnZXRMb2NrTm9kZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGxvY2tUeXBlOiBQcm9wVHlwZXMub25lT2YoWydsZWZ0JywgJ3JpZ2h0J10pXG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHtnZXROb2RlLCBnZXRMb2NrTm9kZX0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGdldE5vZGUgJiYgZ2V0Tm9kZSgnaGVhZGVyJywgZmluZERPTU5vZGUodGhpcyksIHRoaXMuY29udGV4dC5sb2NrVHlwZSk7XG4gICAgICAgIGdldExvY2tOb2RlICYmIGdldExvY2tOb2RlKCdoZWFkZXInLCBmaW5kRE9NTm9kZSh0aGlzKSwgdGhpcy5jb250ZXh0LmxvY2tUeXBlKTtcbiAgICB9XG59XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9sb2NrL2hlYWRlci5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgTGlzdEhlYWRlciBmcm9tICcuL2xpc3QtaGVhZGVyJztcbmltcG9ydCBMaXN0Rm9vdGVyIGZyb20gJy4vbGlzdC1mb290ZXInO1xuaW1wb3J0IFJvd0NvbXBvbmVudCBmcm9tICcuL2xpc3Qvcm93JztcbmltcG9ydCBCb2R5Q29tcG9uZW50IGZyb20gJy4vbGlzdC9ib2R5JztcbmltcG9ydCBIZWFkZXJDb21wb25lbnQgZnJvbSAnLi9maXhlZC9oZWFkZXInO1xuaW1wb3J0IFdyYXBwZXJDb21wb25lbnQgZnJvbSAnLi9maXhlZC93cmFwcGVyJztcbmltcG9ydCB7IHN0YXRpY3MgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0KEJhc2VDb21wb25lbnQpIHtcbiAgICBjbGFzcyBMaXN0VGFibGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgICAgICBzdGF0aWMgTGlzdEhlYWRlciA9IExpc3RIZWFkZXI7XG4gICAgICAgIHN0YXRpYyBMaXN0Rm9vdGVyID0gTGlzdEZvb3RlcjtcbiAgICAgICAgc3RhdGljIExpc3RSb3cgPSBSb3dDb21wb25lbnQ7XG4gICAgICAgIHN0YXRpYyBMaXN0Qm9keSA9IEJvZHlDb21wb25lbnQ7XG4gICAgICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgICAgICAuLi5CYXNlQ29tcG9uZW50LnByb3BUeXBlc1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgICAgICAuLi5CYXNlQ29tcG9uZW50LmRlZmF1bHRQcm9wc1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGljIGNoaWxkQ29udGV4dFR5cGVzID0ge1xuICAgICAgICAgICAgbGlzdEhlYWRlcjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgICAgIGxpc3RGb290ZXI6IFByb3BUeXBlcy5hbnksXG4gICAgICAgICAgICByb3dTZWxlY3Rpb246IFByb3BUeXBlcy5vYmplY3RcbiAgICAgICAgfVxuXG4gICAgICAgIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGlzdEhlYWRlcjogdGhpcy5saXN0SGVhZGVyLFxuICAgICAgICAgICAgICAgIGxpc3RGb290ZXI6IHRoaXMubGlzdEZvb3RlcixcbiAgICAgICAgICAgICAgICByb3dTZWxlY3Rpb246IHRoaXMucm93U2VsZWN0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplRGF0YVNvdXJjZShkYXRhU291cmNlKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGxvb3AgPSBmdW5jdGlvbiAoZGF0YVNvdXJjZSwgbGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBkYXRhU291cmNlLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uX19sZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AoaXRlbS5jaGlsZHJlbiwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxvb3AoZGF0YVNvdXJjZSwgMCk7XG4gICAgICAgICAgICB0aGlzLmRzID0gcmV0O1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCAqL1xuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50cywgY2hpbGRyZW4sIGNsYXNzTmFtZSwgcHJlZml4LCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBsZXQgaXNMaXN0ID0gZmFsc2UsIHJldCA9IFtdO1xuICAgICAgICAgICAgQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlLl90eXBlTWFyayA9PT0gJ2xpc3RIZWFkZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0SGVhZGVyID0gY2hpbGQucHJvcHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNMaXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQudHlwZS5fdHlwZU1hcmsgPT09ICdsaXN0Rm9vdGVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdEZvb3RlciA9IGNoaWxkLnByb3BzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucm93U2VsZWN0aW9uID0gdGhpcy5wcm9wcy5yb3dTZWxlY3Rpb247XG4gICAgICAgICAgICBpZiAoaXNMaXN0KSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cyA9IHsgLi4uY29tcG9uZW50cyB9O1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuUm93ID0gY29tcG9uZW50cy5Sb3cgfHwgUm93Q29tcG9uZW50O1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuQm9keSA9IGNvbXBvbmVudHMuQm9keSB8fCBCb2R5Q29tcG9uZW50O1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuSGVhZGVyID0gY29tcG9uZW50cy5IZWFkZXIgfHwgSGVhZGVyQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuV3JhcHBlciA9IGNvbXBvbmVudHMuV3JhcHBlciB8fCBXcmFwcGVyQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4fXRhYmxlLWdyb3VwYF06IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFtjbGFzc05hbWVdOiBjbGFzc05hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoPEJhc2VDb21wb25lbnQgey4uLm90aGVyc30gY29tcG9uZW50cz17Y29tcG9uZW50c30gY2hpbGRyZW49e3JldH0gY2xhc3NOYW1lPXtjbGFzc05hbWV9IHByZWZpeD17cHJlZml4fS8+KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWNzKExpc3RUYWJsZSwgQmFzZUNvbXBvbmVudCk7XG4gICAgcmV0dXJuIExpc3RUYWJsZTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9saXN0LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBsb2cgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCBSb3cgZnJvbSAnLi4vYmFzZS9yb3cnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcm91cExpc3RSb3cgZXh0ZW5kcyBSb3cge1xuXG4gICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgbGlzdEhlYWRlcjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgbGlzdEZvb3RlcjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgcm93U2VsZWN0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBub3RSZW5kZXJDZWxsSW5kZXg6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgbG9ja1R5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2xlZnQnLCAncmlnaHQnXSlcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzKi9cbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIGNsYXNzTmFtZSwgb25DbGljaywgb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmUsIGNvbHVtbnMsIENlbGwsIHJvd0luZGV4LCByZWNvcmQsIGNoaWxkcmVuLCBwcmltYXJ5S2V5LCBjb2xHcm91cCwgY2VsbFJlZiwgZ2V0Q2VsbFByb3BzLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGNscyA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH10YWJsZS1yb3dgXTogdHJ1ZSxcbiAgICAgICAgICAgIFtjbGFzc05hbWVdOiBjbGFzc05hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoPHRhYmxlIGNsYXNzTmFtZT17Y2xzfSByb2xlPVwicm93XCIgey4uLm90aGVyc31cbiAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25DbGlja30gb25Nb3VzZUVudGVyPXt0aGlzLm9uTW91c2VFbnRlcn0gb25Nb3VzZUxlYXZlPXt0aGlzLm9uTW91c2VMZWF2ZX0+XG4gICAgICAgICAgICB7Y29sR3JvdXB9XG4gICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAge3RoaXMucmVuZGVyQ29udGVudCgnaGVhZGVyJyl9XG4gICAgICAgICAgICAgICAge3RoaXMucmVuZGVyQ2hpbGRyZW4oKX1cbiAgICAgICAgICAgICAgICB7dGhpcy5yZW5kZXJDb250ZW50KCdmb290ZXInKX1cbiAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgIDwvdGFibGU+KTtcbiAgICB9XG5cbiAgICBpc0NoaWxkcmVuU2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0Lmxpc3RIZWFkZXIgJiYgdGhpcy5jb250ZXh0Lmxpc3RIZWFkZXIuaGFzQ2hpbGRyZW5TZWxlY3Rpb247XG4gICAgfVxuXG4gICAgaXNTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQubGlzdEhlYWRlciAmJiB0aGlzLmNvbnRleHQubGlzdEhlYWRlci5oYXNTZWxlY3Rpb247XG4gICAgfVxuXG4gICAgcmVuZGVyQ2hpbGRyZW4oKSB7XG4gICAgICAgIGNvbnN0IHsgcmVjb3JkLCBwcmltYXJ5S2V5IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSByZWNvcmQ7XG4gICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuLm1hcCgoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbHMgPSB0aGlzLnJlbmRlckNlbGxzKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0NoaWxkcmVuU2VsZWN0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZFtwcmltYXJ5S2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLndhcm5pbmcoJ3JlY29yZC5jaGlsZHJlbiBzaG91bGQgY29udGFpbnMgcHJpbWFyeUtleSB3aGVuIGNoaWxkcmVuU2VsZWN0aW9uIGlzIHRydWUuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDx0ciBrZXk9e2NoaWxkW3ByaW1hcnlLZXldfT57Y2VsbHN9PC90cj47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQucm93U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxzWzBdID0gUmVhY3QuY2xvbmVFbGVtZW50KGNlbGxzWzBdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xTcGFuOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2VsbHNbMF0ucHJvcHNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiA8dHIga2V5PXtpbmRleH0+e2NlbGxzfTwvdHI+O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJlbmRlckNvbnRlbnQodHlwZSkge1xuICAgICAgICBjb25zdCB7IGNvbHVtbnMsIHByZWZpeCwgcmVjb3JkLCByb3dJbmRleCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgY2FtZVR5cGUgPSB0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zdWJzdHIoMSk7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLmNvbnRleHRbYGxpc3Qke2NhbWVUeXBlfWBdO1xuICAgICAgICBsZXQgbGlzdE5vZGU7XG4gICAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgICAgICBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQobGlzdC5jZWxsKSkge1xuICAgICAgICAgICAgICAgIGxpc3ROb2RlID0gUmVhY3QuY2xvbmVFbGVtZW50KGxpc3QuY2VsbCwgeyByZWNvcmQsIGluZGV4OiByb3dJbmRleCB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QuY2VsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGxpc3ROb2RlID0gbGlzdC5jZWxsKHJlY29yZCwgcm93SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpc3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNlbGxzID0gdGhpcy5yZW5kZXJDZWxscyhyZWNvcmQpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnaGVhZGVyJyAmJiB0aGlzLmNvbnRleHQucm93U2VsZWN0aW9uICYmIHRoaXMuaXNTZWxlY3Rpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICBjZWxscyA9IGNlbGxzLnNsaWNlKDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICBjZWxscy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNvbFNwYW49e2NvbHVtbnMubGVuZ3RoIC0gMX0ga2V5PVwibGlzdE5vZGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLWNlbGwtd3JhcHBlcmB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bGlzdE5vZGV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBsaXN0Tm9kZSA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1ncm91cC0ke3R5cGV9YH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2NlbGxzfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaXN0Tm9kZSA9ICg8dHIgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtZ3JvdXAtJHt0eXBlfWB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNvbFNwYW49e2NvbHVtbnMubGVuZ3RofT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLWNlbGwtd3JhcHBlcmB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bGlzdE5vZGV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICA8L3RyPik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0Tm9kZTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvbGlzdC9yb3cuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBCb2R5Q29tcG9uZW50IGZyb20gJy4uL2Jhc2UvYm9keSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExpc3RCb2R5KHByb3BzKSB7XG4gICAgcmV0dXJuIDxCb2R5Q29tcG9uZW50IGNvbXBvbmVudD1cImRpdlwiIHsuLi5wcm9wc30vPjtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9saXN0L2JvZHkuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgSGVhZGVyIGZyb20gJy4vZml4ZWQvaGVhZGVyJztcbmltcG9ydCBTdGlja3lIZWFkZXIgZnJvbSAnLi9zdGlja3kvaGVhZGVyJztcbmltcG9ydCB7IHN0YXRpY3MgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdGlja3koQmFzZUNvbXBvbmVudCkge1xuICAgIC8qKiBUYWJsZSAqL1xuICAgIGNsYXNzIFN0aWNreVRhYmxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAgICAgc3RhdGljIFN0aWNreUhlYWRlciA9IFN0aWNreUhlYWRlcjtcbiAgICAgICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog6KGo5aS05piv5ZCm5pivc3RpY2t5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHN0aWNreUhlYWRlcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOi3neemu+eql+WPo+mhtumDqOi+vuWIsOaMh+WumuWBj+enu+mHj+WQjuinpuWPkVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvZmZzZXRUb3A6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGFmZml457uE5Lu255qE55qE5bGe5oCnXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFmZml4UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgICAgICBjb21wb25lbnRzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAgICAgLi4uQmFzZUNvbXBvbmVudC5wcm9wVHlwZXNcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgICAgICBjb21wb25lbnRzOiB7fSxcbiAgICAgICAgICAgIC4uLkJhc2VDb21wb25lbnQuZGVmYXVsdFByb3BzXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0aWMgY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gICAgICAgICAgICBIZWFkZXI6IFByb3BUeXBlcy5hbnksXG4gICAgICAgICAgICBvZmZzZXRUb3A6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgICAgICBhZmZpeFByb3BzOiBQcm9wVHlwZXMub2JqZWN0XG4gICAgICAgIH1cblxuICAgICAgICBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIEhlYWRlcjogKHRoaXMucHJvcHMuY29tcG9uZW50cy5IZWFkZXIgfHwgSGVhZGVyKSxcbiAgICAgICAgICAgICAgICBvZmZzZXRUb3A6IHRoaXMucHJvcHMub2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgIGFmZml4UHJvcHM6IHRoaXMucHJvcHMuYWZmaXhQcm9wc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICAgICAgICBjb25zdCB7IHN0aWNreUhlYWRlciwgb2Zmc2V0VG9wLCBhZmZpeFByb3BzLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBsZXQgeyBjb21wb25lbnRzLCBtYXhCb2R5SGVpZ2h0LCBmaXhlZEhlYWRlciB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChzdGlja3lIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzID0gey4uLmNvbXBvbmVudHN9O1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuSGVhZGVyID0gU3RpY2t5SGVhZGVyO1xuICAgICAgICAgICAgICAgIGZpeGVkSGVhZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtYXhCb2R5SGVpZ2h0ID0gTWF0aC5tYXgobWF4Qm9keUhlaWdodCwgMTAwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDxCYXNlQ29tcG9uZW50IHsuLi5vdGhlcnN9IGNvbXBvbmVudHM9e2NvbXBvbmVudHN9IGZpeGVkSGVhZGVyPXtmaXhlZEhlYWRlcn0gbWF4Qm9keUhlaWdodD17bWF4Qm9keUhlaWdodH0vPjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWNzKFN0aWNreVRhYmxlLCBCYXNlQ29tcG9uZW50KTtcbiAgICByZXR1cm4gU3RpY2t5VGFibGU7XG59XG5cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL3N0aWNreS5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IEFmZml4IGZyb20gJy4uLy4uL2FmZml4JztcblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcHJlZmVyLXN0YXRlbGVzcy1mdW5jdGlvbiovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGlja0hlYWRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIH1cbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICBIZWFkZXI6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIG9mZnNldFRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgYWZmaXhQcm9wczogUHJvcFR5cGVzLm9iamVjdFxuICAgIH1cblxuICAgIGdldEFmZml4UmVmID0gKHJlZikgPT4ge1xuICAgICAgICB0aGlzLnByb3BzLmFmZml4UmVmICYmIHRoaXMucHJvcHMuYWZmaXhSZWYocmVmKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IEhlYWRlciwgb2Zmc2V0VG9wLCBhZmZpeFByb3BzIH0gPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgICAgY29uc3QgbmV3QWZmaXhQcm9wcyA9IGFmZml4UHJvcHMgfHwge307XG4gICAgICAgIGNvbnN0IHsgY2xhc3NOYW1lLCAuLi5vdGhlcnMgfSA9IG5ld0FmZml4UHJvcHM7XG4gICAgICAgIGNvbnN0IGNscyA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH10YWJsZS1hZmZpeGBdOiB0cnVlLFxuICAgICAgICAgICAgY2xhc3NOYW1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAoPEFmZml4IHJlZj17dGhpcy5nZXRBZmZpeFJlZn0gey4uLm90aGVyc30gY2xhc3NOYW1lPXtjbHN9IG9mZnNldFRvcD17b2Zmc2V0VG9wfT5cbiAgICAgICAgICAgIDxIZWFkZXIgey4uLnRoaXMucHJvcHN9Lz5cbiAgICAgICAgPC9BZmZpeD4pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9zdGlja3kvaGVhZGVyLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBvYmosIGV2ZW50cywgZnVuYyB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IENvbmZpZ1Byb3ZpZGVyIGZyb20gJy4uL2NvbmZpZy1wcm92aWRlcic7XG5pbXBvcnQgeyBnZXRTY3JvbGwsIGdldFJlY3QsIGdldE5vZGVIZWlnaHQgfSBmcm9tICcuL3V0aWwnO1xuXG4vKiogQWZmaXggKi9cbmNsYXNzIEFmZml4IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva4gQWZmaXgg6ZyA6KaB55uR5ZCs5rua5Yqo5LqL5Lu255qE5a655Zmo5YWD57SgXG4gICAgICAgICAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0g55uu5qCH5a655Zmo5YWD57Sg55qE5a6e5L6LXG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Led56a756qX5Y+j6aG26YOo6L6+5Yiw5oyH5a6a5YGP56e76YeP5ZCO6Kem5Y+RXG4gICAgICAgICAqL1xuICAgICAgICBvZmZzZXRUb3A6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDot53nprvnqpflj6PlupXpg6jovr7liLDliLblrprlgY/np7vph4/lkI7op6blj5FcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNldEJvdHRvbTogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW9k+WFg+e0oOeahOagt+W8j+WPkeeUn+WbuumSieagt+W8j+WPmOWMluaXtuinpuWPkeeahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IOWFg+e0oOaYr+WQpuiiq+WbuumSiVxuICAgICAgICAgKi9cbiAgICAgICAgb25BZmZpeDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblkK/nlKjnu53lr7nluIPlsYDlrp7njrAgYWZmaXhcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSDmmK/lkKblkK/nlKjnu53lr7nluIPlsYBcbiAgICAgICAgICovXG4gICAgICAgIHVzZUFic29sdXRlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHByZWZpeDogJ25leHQtJyxcbiAgICAgICAgY29udGFpbmVyOiAoKSA9PiB3aW5kb3csXG4gICAgICAgIG9uQWZmaXg6IGZ1bmMubm9vcCxcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc3R5bGU6IG51bGwsXG4gICAgICAgICAgICBjb250YWluZXJTdHlsZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZmZpeE1vZGUgPSB0aGlzLl9nZXRBZmZpeE1vZGUocHJvcHMpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy5fdXBkYXRlTm9kZVBvc2l0aW9uKCk7XG4gICAgICAgIC8vIHdhaXQgZm9yIHBhcmVudCByZW5kZXJlZFxuICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3NldEV2ZW50SGFuZGxlckZvckNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudEhhbmRsZXJGb3JDb250YWluZXIoY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBfc2V0RXZlbnRIYW5kbGVyRm9yQ29udGFpbmVyKGdldENvbnRhaW5lcikge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudHMub24oY29udGFpbmVyLCAnc2Nyb2xsJywgdGhpcy5fdXBkYXRlTm9kZVBvc2l0aW9uLCBmYWxzZSk7XG4gICAgICAgIGV2ZW50cy5vbihjb250YWluZXIsICdyZXNpemUnLCB0aGlzLl91cGRhdGVOb2RlUG9zaXRpb24sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlRXZlbnRIYW5kbGVyRm9yQ29udGFpbmVyKGdldENvbnRhaW5lcikge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgZXZlbnRzLm9mZihjb250YWluZXIsICdzY3JvbGwnLCB0aGlzLl91cGRhdGVOb2RlUG9zaXRpb24pO1xuICAgICAgICAgICAgZXZlbnRzLm9mZihjb250YWluZXIsICdyZXNpemUnLCB0aGlzLl91cGRhdGVOb2RlUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlUG9zaXRpb24gPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU5vZGVQb3NpdGlvbigpO1xuICAgIH1cblxuICAgIF91cGRhdGVOb2RlUG9zaXRpb24gPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyLCB1c2VBYnNvbHV0ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgYWZmaXhDb250YWluZXIgPSBjb250YWluZXIoKTtcblxuICAgICAgICBpZiAoIWFmZml4Q29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbmVyU2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGFmZml4Q29udGFpbmVyLCB0cnVlKTsgICAgLy8g5a655Zmo5Zyo5Z6C55u05L2N572u5LiK55qE5rua5YqoIG9mZnNldFxuICAgICAgICBjb25zdCBhZmZpeE9mZnNldCA9IHRoaXMuX2dldE9mZnNldCh0aGlzLmFmZml4Tm9kZSwgYWZmaXhDb250YWluZXIpOyAvLyDnm67moIfoioLngrnlvZPliY3nm7jlr7nkuo7lrrnlmajnmoQgb2Zmc2V0XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckhlaWdodCA9IGdldE5vZGVIZWlnaHQoYWZmaXhDb250YWluZXIpOyAgICAgICAgIC8vIOWuueWZqOeahOmrmOW6plxuICAgICAgICBjb25zdCBhZmZpeEhlaWdodCA9IHRoaXMuYWZmaXhOb2RlLm9mZnNldEhlaWdodDtcbiAgICAgICAgY29uc3QgY29udGFpbmVyUmVjdCA9IGdldFJlY3QoYWZmaXhDb250YWluZXIpO1xuXG4gICAgICAgIGNvbnN0IGFmZml4Q2hpbGRIZWlnaHQgPSB0aGlzLmFmZml4Q2hpbGROb2RlLm9mZnNldEhlaWdodDtcblxuICAgICAgICBjb25zdCBhZmZpeE1vZGUgPSB0aGlzLmFmZml4TW9kZTtcbiAgICAgICAgY29uc3QgYWZmaXhTdHlsZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBhZmZpeE9mZnNldC53aWR0aCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyU3R5bGUgPSB7XG4gICAgICAgICAgICB3aWR0aDogYWZmaXhPZmZzZXQud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGFmZml4Q2hpbGRIZWlnaHQsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGFmZml4TW9kZS50b3AgJiYgY29udGFpbmVyU2Nyb2xsVG9wID4gYWZmaXhPZmZzZXQudG9wIC0gYWZmaXhNb2RlLm9mZnNldCkge1xuICAgICAgICAgICAgLy8gYWZmaXggdG9wXG4gICAgICAgICAgICBpZiAodXNlQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICBhZmZpeFN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgICAgICBhZmZpeFN0eWxlLnRvcCA9IGNvbnRhaW5lclNjcm9sbFRvcCAtIChhZmZpeE9mZnNldC50b3AgLSBhZmZpeE1vZGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjb250YWluZXJTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFmZml4U3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICAgICAgICAgIGFmZml4U3R5bGUudG9wID0gYWZmaXhNb2RlLm9mZnNldCArIGNvbnRhaW5lclJlY3QudG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2V0QWZmaXhTdHlsZShhZmZpeFN0eWxlLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX3NldENvbnRhaW5lclN0eWxlKGNvbnRhaW5lclN0eWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChhZmZpeE1vZGUuYm90dG9tICYmIGNvbnRhaW5lclNjcm9sbFRvcCA8IGFmZml4T2Zmc2V0LnRvcCArIGFmZml4SGVpZ2h0ICsgYWZmaXhNb2RlLm9mZnNldCAtIGNvbnRhaW5lckhlaWdodCkge1xuICAgICAgICAgICAgLy8gYWZmaXggYm90dG9tXG4gICAgICAgICAgICBhZmZpeFN0eWxlLmhlaWdodCA9IGFmZml4SGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHVzZUFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgYWZmaXhTdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICAgICAgYWZmaXhTdHlsZS50b3AgPSBjb250YWluZXJTY3JvbGxUb3AgLSAoYWZmaXhPZmZzZXQudG9wICsgYWZmaXhIZWlnaHQgKyBhZmZpeE1vZGUub2Zmc2V0IC0gY29udGFpbmVySGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb250YWluZXJTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFmZml4U3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICAgICAgICAgIGFmZml4U3R5bGUuYm90dG9tID0gYWZmaXhNb2RlLm9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldEFmZml4U3R5bGUoYWZmaXhTdHlsZSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLl9zZXRDb250YWluZXJTdHlsZShjb250YWluZXJTdHlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRBZmZpeFN0eWxlKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fc2V0Q29udGFpbmVyU3R5bGUobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgX2dldEFmZml4TW9kZSgpIHtcbiAgICAgICAgY29uc3QgeyBvZmZzZXRUb3AsIG9mZnNldEJvdHRvbSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgYWZmaXhNb2RlID0ge1xuICAgICAgICAgICAgdG9wOiBmYWxzZSxcbiAgICAgICAgICAgIGJvdHRvbTogZmFsc2UsXG4gICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXRUb3AgIT09ICdudW1iZXInICYmIHR5cGVvZiBvZmZzZXRCb3R0b20gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBzZXQgZGVmYXVsdFxuICAgICAgICAgICAgYWZmaXhNb2RlLnRvcCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9mZnNldFRvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGFmZml4TW9kZS50b3AgPSB0cnVlO1xuICAgICAgICAgICAgYWZmaXhNb2RlLm9mZnNldCA9IG9mZnNldFRvcDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2Zmc2V0Qm90dG9tID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgYWZmaXhNb2RlLmJvdHRvbSA9IHRydWU7XG4gICAgICAgICAgICBhZmZpeE1vZGUub2Zmc2V0ID0gb2Zmc2V0Qm90dG9tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFmZml4TW9kZTtcbiAgICB9XG5cbiAgICBfc2V0QWZmaXhTdHlsZShhZmZpeFN0eWxlLCBhZmZpeGVkID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKG9iai5zaGFsbG93RXF1YWwoYWZmaXhTdHlsZSwgdGhpcy5zdGF0ZS5zdHlsZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgc3R5bGU6IGFmZml4U3R5bGUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHsgb25BZmZpeCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBpZiAoYWZmaXhlZCkge1xuICAgICAgICAgICAgb25BZmZpeCh0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICghYWZmaXhTdHlsZSkge1xuICAgICAgICAgICAgb25BZmZpeChmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0Q29udGFpbmVyU3R5bGUoY29udGFpbmVyU3R5bGUpIHtcbiAgICAgICAgaWYgKG9iai5zaGFsbG93RXF1YWwoY29udGFpbmVyU3R5bGUsIHRoaXMuc3RhdGUuY29udGFpbmVyU3R5bGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGNvbnRhaW5lclN0eWxlIH0pO1xuICAgIH1cblxuICAgIF9nZXRPZmZzZXQoYWZmaXhOb2RlLCBhZmZpeENvbnRhaW5lcikge1xuICAgICAgICBjb25zdCBhZmZpeFJlY3QgPSBhZmZpeE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7ICAvLyBhZmZpeCDlhYPntKAg55u45a+55rWP6KeI5Zmo56qX5Y+j55qE5L2N572uXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclJlY3QgPSBnZXRSZWN0KGFmZml4Q29udGFpbmVyKTsgLy8gYWZmaXgg5a655ZmoIOebuOWvuea1j+iniOWZqOeql+WPo+eahOS9jee9rlxuICAgICAgICBjb25zdCBjb250YWluZXJTY3JvbGxUb3AgPSBnZXRTY3JvbGwoYWZmaXhDb250YWluZXIsIHRydWUpO1xuICAgICAgICBjb25zdCBjb250YWluZXJTY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGFmZml4Q29udGFpbmVyLCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogYWZmaXhSZWN0LnRvcCAtIGNvbnRhaW5lclJlY3QudG9wICsgY29udGFpbmVyU2Nyb2xsVG9wLFxuICAgICAgICAgICAgbGVmdDogYWZmaXhSZWN0LmxlZnQgLSBjb250YWluZXJSZWN0LmxlZnQgKyBjb250YWluZXJTY3JvbGxMZWZ0LFxuICAgICAgICAgICAgd2lkdGg6IGFmZml4UmVjdC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogYWZmaXhSZWN0LmhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBfYWZmaXhOb2RlUmVmSGFuZGxlciA9IChyZWYpID0+IHtcbiAgICAgICAgdGhpcy5hZmZpeE5vZGUgPSBmaW5kRE9NTm9kZShyZWYpO1xuICAgIH1cblxuICAgIF9hZmZpeENoaWxkTm9kZVJlZkhhbmRsZXIgPSAocmVmKSA9PiB7XG4gICAgICAgIHRoaXMuYWZmaXhDaGlsZE5vZGUgPSBmaW5kRE9NTm9kZShyZWYpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIGNsYXNzTmFtZSwgc3R5bGUsIGNoaWxkcmVuIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9YWZmaXhgXTogc3RhdGUuc3R5bGUsXG4gICAgICAgICAgICBbYCR7cHJlZml4fWFmZml4LXRvcGBdOiAhc3RhdGUuc3R5bGUgJiYgdGhpcy5hZmZpeE1vZGUudG9wLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1hZmZpeC1ib3R0b21gXTogIXN0YXRlLnN0eWxlICYmIHRoaXMuYWZmaXhNb2RlLmJvdHRvbSxcbiAgICAgICAgICAgIFtjbGFzc05hbWVdOiBjbGFzc05hbWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb21iaW5lZFN0eWxlID0geyAuLi5zdGF0ZS5jb250YWluZXJTdHlsZSwgLi4uc3R5bGUgfTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiByZWY9e3RoaXMuX2FmZml4Tm9kZVJlZkhhbmRsZXJ9IHN0eWxlPXtjb21iaW5lZFN0eWxlfT5cbiAgICAgICAgICAgICAgICA8ZGl2IHJlZj17dGhpcy5fYWZmaXhDaGlsZE5vZGVSZWZIYW5kbGVyfSBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHN0eWxlPXtzdGF0ZS5zdHlsZX0+XG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlnUHJvdmlkZXIuY29uZmlnKEFmZml4KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hZmZpeC9pbmRleC5qc3giLCJleHBvcnQgZnVuY3Rpb24gZ2V0U2Nyb2xsKG5vZGUsIGlzVmVydGljYWwpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IHdpbmRvd1Byb3AgPSBpc1ZlcnRpY2FsID8gJ3BhZ2VZT2Zmc2V0JyA6ICdwYWdlWE9mZnNldCc7XG4gICAgY29uc3QgZWxlbWVudFByb3AgPSBpc1ZlcnRpY2FsID8gJ3Njcm9sbFRvcCcgOiAnc2Nyb2xsTGVmdCc7XG4gICAgcmV0dXJuIG5vZGUgPT09IHdpbmRvdyA/IG5vZGVbd2luZG93UHJvcF0gOiBub2RlW2VsZW1lbnRQcm9wXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlY3Qobm9kZSkge1xuICAgIHJldHVybiBub2RlICE9PSB3aW5kb3cgPyBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogeyB0b3A6IDAsIGxlZnQ6IDAsIGJvdHRvbTogMCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZUhlaWdodChub2RlKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gd2luZG93KSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlLmNsaWVudEhlaWdodDtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hZmZpeC91dGlsLmpzIiwiaW1wb3J0ICcuLi9pY29uL3N0eWxlLmpzJztcbmltcG9ydCAnLi4vY2hlY2tib3gvc3R5bGUuanMnO1xuaW1wb3J0ICcuLi9yYWRpby9zdHlsZS5qcyc7XG5pbXBvcnQgJy4uL21lbnUvc3R5bGUuanMnO1xuaW1wb3J0ICcuLi9idXR0b24vc3R5bGUuanMnO1xuaW1wb3J0ICcuLi9kcm9wZG93bi9zdHlsZS5qcyc7XG5pbXBvcnQgJy4uL2xvYWRpbmcvc3R5bGUuanMnO1xuaW1wb3J0ICcuL21haW4uc2Nzcyc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvc3R5bGUuanMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDAuMTguMkBzdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2ljb24vbWFpbi5zY3NzIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC8pL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAwLjE4LjJAc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAwLjE4LjJAc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hbmltYXRlL21haW4uc2NzcyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY2hlY2tib3gvbWFpbi5zY3NzIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAwLjE4LjJAc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yYWRpby9tYWluLnNjc3MiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDAuMTguMkBzdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21lbnUvbWFpbi5zY3NzIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAwLjE4LjJAc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9idXR0b24vbWFpbi5zY3NzIiwiaW1wb3J0ICcuLi9vdmVybGF5L3N0eWxlLmpzJztcbmltcG9ydCAnLi9tYWluLnNjc3MnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Ryb3Bkb3duL3N0eWxlLmpzIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAwLjE4LjJAc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9vdmVybGF5L21haW4uc2NzcyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZHJvcGRvd24vbWFpbi5zY3NzIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAwLjE4LjJAc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9sb2FkaW5nL21haW4uc2NzcyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvbWFpbi5zY3NzIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5iZWF1dHl7XFxuICBiYWNrZ3JvdW5kOiAjZjdmN2Y3O1xcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIhLi9zY3JpcHRzL3NlcnZlci9sb2FkZXJzL2RlbW8vc2VsZWN0b3IuanMhLi9kb2NzL3RhYmxlL2RlbW8vc3R5bGUubWRcbi8vIG1vZHVsZSBpZCA9IDE4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDMiLCJyZXF1aXJlKFwiISFzdHlsZS1sb2FkZXIhY3NzLWxvYWRlciEvVXNlcnMvemhhb2d1b3lhbi9naXRodWIvcHViL3NjcmlwdHMvc2VydmVyL2xvYWRlcnMvZGVtby9zZWxlY3Rvci5qcyEvVXNlcnMvemhhb2d1b3lhbi9naXRodWIvcHViL2RvY3MvdGFibGUvZGVtby9zdHlsZS5tZFwiKVxuXG5cbmltcG9ydCBUYWJsZSBmcm9tICcuLi8uLi8uLi9zcmMvdGFibGUnO1xuaW1wb3J0ICcuLi8uLi8uLi9zcmMvdGFibGUvc3R5bGUuanMnO1xuXG5cbmltcG9ydCBCdXR0b24gZnJvbSAnLi4vLi4vLi4vc3JjL2J1dHRvbic7XG5pbXBvcnQgJy4uLy4uLy4uL3NyYy9idXR0b24vc3R5bGUuanMnO1xuXG5cbmNvbnN0IGRhdGFTb3VyY2UgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBgUXVvdGF0aW9uIGZvciAxUENTIE5hbm8gJHszICsgaX0uMCBjb250cm9sbGVyIGNvbXBhdGlibGVgLFxuICAgICAgICAgICAgICAgIGlkOiAxMDAzMDY2NjA5NDAgKyBpLFxuICAgICAgICAgICAgICAgIHRpbWU6IDIwMDAgKyBpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgcmVuZGVyID0gKHZhbHVlLCBpbmRleCwgcmVjb3JkKSA9PiB7XG4gICAgICAgIHJldHVybiA8YT5SZW1vdmUoe3JlY29yZC5pZH0pPC9hPjtcbiAgICB9O1xuXG5jbGFzcyBBcHAgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRhdGFTb3VyY2U6IGRhdGFTb3VyY2UoKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJycsXG4gICAgICAgICAgICBhbGlnbjogJ2xlZnQnXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRvZ2dsZVplYnJhKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGlzWmVicmE6ICF0aGlzLnN0YXRlLmlzWmVicmFcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvZ2dsZUJvcmRlcigpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBoYXNCb3JkZXI6ICF0aGlzLnN0YXRlLmhhc0JvcmRlclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFrZUJlYXV0eSgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdiZWF1dHknXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYWtlQWxpZ24oKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgYWxpZ246ICdyaWdodCdcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuICg8c3Bhbj5cbiAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgIDxCdXR0b24gb25DbGljaz17dGhpcy50b2dnbGVaZWJyYS5iaW5kKHRoaXMpfT4gVG9nZ2xlIHplYnJhIDwvQnV0dG9uPiAmbmJzcDtcbiAgICAgICAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9e3RoaXMudG9nZ2xlQm9yZGVyLmJpbmQodGhpcyl9PiBUb2dnbGUgYm9yZGVyPC9CdXR0b24+ICZuYnNwO1xuICAgICAgICAgICAgICAgIDxCdXR0b24gb25DbGljaz17dGhpcy5tYWtlQmVhdXR5LmJpbmQodGhpcyl9PiBNYWtlIHNlY29uZCBjb2x1bW4gYmVhdXR5IDwvQnV0dG9uPiAmbmJzcDtcbiAgICAgICAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9e3RoaXMubWFrZUFsaWduLmJpbmQodGhpcyl9PiBNYWtlIGZpcnN0IGNvbHVtbiBhbGlnbiByaWdodCA8L0J1dHRvbj4gJm5ic3A7XG4gICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICA8VGFibGUgZGF0YVNvdXJjZT17dGhpcy5zdGF0ZS5kYXRhU291cmNlfVxuICAgICAgICAgICAgICAgIGlzWmVicmE9e3RoaXMuc3RhdGUuaXNaZWJyYX1cbiAgICAgICAgICAgICAgICBoYXNCb3JkZXI9e3RoaXMuc3RhdGUuaGFzQm9yZGVyfT5cbiAgICAgICAgICAgICAgICA8VGFibGUuQ29sdW1uIHRpdGxlPVwiSWRcIiBkYXRhSW5kZXg9XCJpZFwiICBhbGlnbj17dGhpcy5zdGF0ZS5hbGlnbn0vPlxuICAgICAgICAgICAgICAgIDxUYWJsZS5Db2x1bW4gdGl0bGU9XCJUaXRsZVwiIGRhdGFJbmRleD1cInRpdGxlXCIgY2xhc3NOYW1lPXt0aGlzLnN0YXRlLmNsYXNzTmFtZX0vPlxuICAgICAgICAgICAgICAgIDxUYWJsZS5Db2x1bW4gdGl0bGU9XCJUaW1lXCIgZGF0YUluZGV4PVwidGltZVwiLz5cbiAgICAgICAgICAgICAgICA8VGFibGUuQ29sdW1uIGNlbGw9e3JlbmRlcn0gd2lkdGg9ezIwMH0vPlxuICAgICAgICAgICAgPC9UYWJsZT5cbiAgICAgICAgPC9zcGFuPik7XG4gICAgfVxufVxuXG5SZWFjdERPTS5yZW5kZXIoPEFwcC8+LCBtb3VudE5vZGUpO1xuXG5cbi8vIEhPVCBSRUxPQUQgQ09ERVxuY29uc3QgY29tcG9uZW50RGVzYyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjb21wb25lbnQtZGVzYycpO1xuY29tcG9uZW50RGVzYy5pbm5lckhUTUwgPSBg6Ieq5a6a5LmJ6KGo5qC86L655qGGYDtcbmNvbnN0IGNvbXBvbmVudEJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY29tcG9uZW50LWJvZHknKTtcbmNvbXBvbmVudEJvZHkuaW5uZXJIVE1MID0gYDxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1qc3hcIj48ZGl2IGNsYXNzPVwiaGxqc1wiPjxzcGFuIGNsYXNzPVwiaGxqcy1rZXl3b3JkXCI+aW1wb3J0PC9zcGFuPiB7IFRhYmxlLCBCdXR0b24gfSA8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPmZyb208L3NwYW4+IDxzcGFuIGNsYXNzPVwiaGxqcy1zdHJpbmdcIj4nQGFsaWZkL25leHQnPC9zcGFuPjtcblxuPHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj5jb25zdDwvc3Bhbj4gZGF0YVNvdXJjZSA9IDxzcGFuIGNsYXNzPVwiaGxqcy1mdW5jdGlvblwiPjxzcGFuIGNsYXNzPVwiaGxqcy1wYXJhbXNcIj4oKTwvc3Bhbj4gPSZndDs8L3NwYW4+IHtcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj5jb25zdDwvc3Bhbj4gcmVzdWx0ID0gW107XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaGxqcy1rZXl3b3JkXCI+Zm9yPC9zcGFuPiAoPHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj5sZXQ8L3NwYW4+IGkgPSA8c3BhbiBjbGFzcz1cImhsanMtbnVtYmVyXCI+MDwvc3Bhbj47IGkgJmx0OyA8c3BhbiBjbGFzcz1cImhsanMtbnVtYmVyXCI+NTwvc3Bhbj47IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaGxqcy1hdHRyXCI+dGl0bGU8L3NwYW4+OiA8c3BhbiBjbGFzcz1cImhsanMtc3RyaW5nXCI+e2JhY2txdW90ZX1RdW90YXRpb24gZm9yIDFQQ1MgTmFubyA8c3BhbiBjbGFzcz1cImhsanMtc3Vic3RcIj57ZG9sbGFyfXs8c3BhbiBjbGFzcz1cImhsanMtbnVtYmVyXCI+Mzwvc3Bhbj4gKyBpfTwvc3Bhbj4uMCBjb250cm9sbGVyIGNvbXBhdGlibGV7YmFja3F1b3RlfTwvc3Bhbj4sXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJobGpzLWF0dHJcIj5pZDwvc3Bhbj46IDxzcGFuIGNsYXNzPVwiaGxqcy1udW1iZXJcIj4xMDAzMDY2NjA5NDA8L3NwYW4+ICsgaSxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMtYXR0clwiPnRpbWU8L3NwYW4+OiA8c3BhbiBjbGFzcz1cImhsanMtbnVtYmVyXCI+MjAwMDwvc3Bhbj4gKyBpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPnJldHVybjwvc3Bhbj4gcmVzdWx0O1xuICAgIH0sXG4gICAgcmVuZGVyID0gPHNwYW4gY2xhc3M9XCJobGpzLWZ1bmN0aW9uXCI+KDxzcGFuIGNsYXNzPVwiaGxqcy1wYXJhbXNcIj52YWx1ZSwgaW5kZXgsIHJlY29yZDwvc3Bhbj4pID0mZ3Q7PC9zcGFuPiB7XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaGxqcy1rZXl3b3JkXCI+cmV0dXJuPC9zcGFuPiA8c3BhbiBjbGFzcz1cInhtbFwiPjxzcGFuIGNsYXNzPVwiaGxqcy10YWdcIj4mbHQ7PHNwYW4gY2xhc3M9XCJobGpzLW5hbWVcIj5hPC9zcGFuPiZndDs8L3NwYW4+UmVtb3ZlKHtyZWNvcmQuaWR9KTxzcGFuIGNsYXNzPVwiaGxqcy10YWdcIj4mbHQ7LzxzcGFuIGNsYXNzPVwiaGxqcy1uYW1lXCI+YTwvc3Bhbj4mZ3Q7PC9zcGFuPjwvc3Bhbj47XG4gICAgfTtcblxuPHNwYW4gY2xhc3M9XCJobGpzLWNsYXNzXCI+PHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj5jbGFzczwvc3Bhbj4gPHNwYW4gY2xhc3M9XCJobGpzLXRpdGxlXCI+QXBwPC9zcGFuPiA8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPmV4dGVuZHM8L3NwYW4+IDxzcGFuIGNsYXNzPVwiaGxqcy10aXRsZVwiPlJlYWN0PC9zcGFuPi48c3BhbiBjbGFzcz1cImhsanMtdGl0bGVcIj5Db21wb25lbnQ8L3NwYW4+IDwvc3Bhbj57XG4gICAgPHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj5jb25zdHJ1Y3Rvcjwvc3Bhbj4ocHJvcHMpIHtcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj5zdXBlcjwvc3Bhbj4ocHJvcHMpO1xuICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPnRoaXM8L3NwYW4+LnN0YXRlID0ge1xuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJobGpzLWF0dHJcIj5kYXRhU291cmNlPC9zcGFuPjogZGF0YVNvdXJjZSgpLFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJobGpzLWF0dHJcIj5jbGFzc05hbWU8L3NwYW4+OiA8c3BhbiBjbGFzcz1cImhsanMtc3RyaW5nXCI+Jyc8L3NwYW4+LFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJobGpzLWF0dHJcIj5hbGlnbjwvc3Bhbj46IDxzcGFuIGNsYXNzPVwiaGxqcy1zdHJpbmdcIj4nbGVmdCc8L3NwYW4+XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRvZ2dsZVplYnJhKCkge1xuICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPnRoaXM8L3NwYW4+LnNldFN0YXRlKHtcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaGxqcy1hdHRyXCI+aXNaZWJyYTwvc3Bhbj46ICE8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPnRoaXM8L3NwYW4+LnN0YXRlLmlzWmVicmFcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvZ2dsZUJvcmRlcigpIHtcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj50aGlzPC9zcGFuPi5zZXRTdGF0ZSh7XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMtYXR0clwiPmhhc0JvcmRlcjwvc3Bhbj46ICE8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPnRoaXM8L3NwYW4+LnN0YXRlLmhhc0JvcmRlclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFrZUJlYXV0eSgpIHtcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj50aGlzPC9zcGFuPi5zZXRTdGF0ZSh7XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMtYXR0clwiPmNsYXNzTmFtZTwvc3Bhbj46IDxzcGFuIGNsYXNzPVwiaGxqcy1zdHJpbmdcIj4nYmVhdXR5Jzwvc3Bhbj5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1ha2VBbGlnbigpIHtcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj50aGlzPC9zcGFuPi5zZXRTdGF0ZSh7XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMtYXR0clwiPmFsaWduPC9zcGFuPjogPHNwYW4gY2xhc3M9XCJobGpzLXN0cmluZ1wiPidyaWdodCc8L3NwYW4+XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaGxqcy1rZXl3b3JkXCI+cmV0dXJuPC9zcGFuPiAoJmx0O3NwYW4mZ3Q7XG4gICAgICAgICAgICAmbHQ7cCZndDtcbiAgICAgICAgICAgICAgICAmbHQ7QnV0dG9uIG9uQ2xpY2s9e3RoaXMudG9nZ2xlWmVicmEuYmluZCh0aGlzKX0mZ3Q7IFRvZ2dsZSB6ZWJyYSAmbHQ7L0J1dHRvbiZndDsgJmFtcDtuYnNwO1xuICAgICAgICAgICAgICAgICZsdDtCdXR0b24gb25DbGljaz17dGhpcy50b2dnbGVCb3JkZXIuYmluZCh0aGlzKX0mZ3Q7IFRvZ2dsZSBib3JkZXImbHQ7L0J1dHRvbiZndDsgJmFtcDtuYnNwO1xuICAgICAgICAgICAgICAgICZsdDtCdXR0b24gb25DbGljaz17dGhpcy5tYWtlQmVhdXR5LmJpbmQodGhpcyl9Jmd0OyBNYWtlIHNlY29uZCBjb2x1bW4gYmVhdXR5ICZsdDsvQnV0dG9uJmd0OyAmYW1wO25ic3A7XG4gICAgICAgICAgICAgICAgJmx0O0J1dHRvbiBvbkNsaWNrPXt0aGlzLm1ha2VBbGlnbi5iaW5kKHRoaXMpfSZndDsgTWFrZSBmaXJzdCBjb2x1bW4gYWxpZ24gcmlnaHQgJmx0Oy9CdXR0b24mZ3Q7ICZhbXA7bmJzcDtcbiAgICAgICAgICAgICZsdDsvcCZndDtcbiAgICAgICAgICAgICZsdDtUYWJsZSBkYXRhU291cmNlPXt0aGlzLnN0YXRlLmRhdGFTb3VyY2V9XG4gICAgICAgICAgICAgICAgaXNaZWJyYT17dGhpcy5zdGF0ZS5pc1plYnJhfVxuICAgICAgICAgICAgICAgIGhhc0JvcmRlcj17dGhpcy5zdGF0ZS5oYXNCb3JkZXJ9Jmd0O1xuICAgICAgICAgICAgICAgICZsdDtUYWJsZS5Db2x1bW4gdGl0bGU9XCJJZFwiIGRhdGFJbmRleD1cImlkXCIgIGFsaWduPXt0aGlzLnN0YXRlLmFsaWdufS8mZ3Q7XG4gICAgICAgICAgICAgICAgJmx0O1RhYmxlLkNvbHVtbiB0aXRsZT1cIlRpdGxlXCIgZGF0YUluZGV4PVwidGl0bGVcIiBjbGFzc05hbWU9e3RoaXMuc3RhdGUuY2xhc3NOYW1lfS8mZ3Q7XG4gICAgICAgICAgICAgICAgJmx0O1RhYmxlLkNvbHVtbiB0aXRsZT1cIlRpbWVcIiBkYXRhSW5kZXg9XCJ0aW1lXCIvJmd0O1xuICAgICAgICAgICAgICAgICZsdDtUYWJsZS5Db2x1bW4gY2VsbD17cmVuZGVyfSB3aWR0aD17MjAwfS8mZ3Q7XG4gICAgICAgICAgICAmbHQ7L1RhYmxlJmd0O1xuICAgICAgICAmbHQ7L3NwYW4mZ3Q7KTtcbiAgICB9XG59XG5cblJlYWN0RE9NLnJlbmRlcigmbHQ7QXBwLyZndDssIG1vdW50Tm9kZSk7XG48L2Rpdj48L2NvZGU+PC9wcmU+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtY3NzXCI+PGRpdiBjbGFzcz1cImhsanNcIj48c3BhbiBjbGFzcz1cImhsanMtc2VsZWN0b3ItY2xhc3NcIj4uYmVhdXR5PC9zcGFuPntcbiAgPHNwYW4gY2xhc3M9XCJobGpzLWF0dHJpYnV0ZVwiPmJhY2tncm91bmQ8L3NwYW4+OiA8c3BhbiBjbGFzcz1cImhsanMtbnVtYmVyXCI+I2Y3ZjdmNzwvc3Bhbj47XG59XG48L2Rpdj48L2NvZGU+PC9wcmU+XG5gLnJlcGxhY2UoL3tiYWNrcXVvdGV9L2csICdgJykucmVwbGFjZSgve2RvbGxhcn0vZywgJyQnKTtcblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKTtcblxuICBjb25zdCByZWxvYWRpbmcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbmV4dC1kZW1vLXJlbG9hZGluZycpO1xuXG4gIGlmICghd2luZG93Lmhhc0FkZFN0YXR1c0hhbmRsZXIpIHtcbiAgICBtb2R1bGUuaG90LmFkZFN0YXR1c0hhbmRsZXIoc3RhdHVzID0+IHtcbiAgICAgIHdpbmRvdy5oYXNBZGRTdGF0dXNIYW5kbGVyID0gdHJ1ZTtcbiAgICAgIGlmIChzdGF0dXMgPT09ICdjaGVjaycpIHtcbiAgICAgICAgcmVsb2FkaW5nLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09ICdpZGxlJykge1xuICAgICAgICByZWxvYWRpbmcuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RvY3MvdGFibGUvZGVtby9zdHlsZS5tZCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL3NjcmlwdHMvc2VydmVyL2xvYWRlcnMvZGVtby9zZWxlY3Rvci5qcyEuL3N0eWxlLm1kXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL3NjcmlwdHMvc2VydmVyL2xvYWRlcnMvZGVtby9zZWxlY3Rvci5qcyEuL3N0eWxlLm1kXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL3NjcmlwdHMvc2VydmVyL2xvYWRlcnMvZGVtby9zZWxlY3Rvci5qcyEuL3N0eWxlLm1kXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDAuMTguMkBzdHlsZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyIS4vc2NyaXB0cy9zZXJ2ZXIvbG9hZGVycy9kZW1vL3NlbGVjdG9yLmpzIS4vZG9jcy90YWJsZS9kZW1vL3N0eWxlLm1kXG4vLyBtb2R1bGUgaWQgPSAzMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAzIl0sInNvdXJjZVJvb3QiOiIifQ==