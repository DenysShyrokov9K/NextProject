webpackJsonp([22],[
/* 0 */
/***/ (function(module, exports) {

module.exports = window.React;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;

  var isValidElement = function isValidElement(object) {
    return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(80)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(83)();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.KEYCODE = exports.guid = exports.focus = exports.support = exports.str = exports.obj = exports.log = exports.func = exports.events = exports.env = exports.dom = undefined;

var _dom2 = __webpack_require__(40);

var _dom = _interopRequireWildcard(_dom2);

var _env2 = __webpack_require__(42);

var _env = _interopRequireWildcard(_env2);

var _events2 = __webpack_require__(86);

var _events = _interopRequireWildcard(_events2);

var _func2 = __webpack_require__(87);

var _func = _interopRequireWildcard(_func2);

var _log2 = __webpack_require__(88);

var _log = _interopRequireWildcard(_log2);

var _object2 = __webpack_require__(13);

var _object = _interopRequireWildcard(_object2);

var _string2 = __webpack_require__(41);

var _string = _interopRequireWildcard(_string2);

var _support2 = __webpack_require__(89);

var _support = _interopRequireWildcard(_support2);

var _focus2 = __webpack_require__(90);

var _focus = _interopRequireWildcard(_focus2);

var _guid2 = __webpack_require__(91);

var _guid3 = _interopRequireDefault(_guid2);

var _keycode = __webpack_require__(43);

var _keycode2 = _interopRequireDefault(_keycode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var dom = exports.dom = _dom;
var env = exports.env = _env;
var events = exports.events = _events;
var func = exports.func = _func;
var log = exports.log = _log;
var obj = exports.obj = _object;
var str = exports.str = _string;
var support = exports.support = _support;
var focus = exports.focus = _focus;
var guid = exports.guid = _guid3.default;
var KEYCODE = exports.KEYCODE = _keycode2.default;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg === 'undefined' ? 'undefined' : _typeof(arg);

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if ("function" === 'function' && _typeof(__webpack_require__(73)) === 'object' && __webpack_require__(73)) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
})();

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = window.ReactDOM;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _getContextProps = __webpack_require__(39);

var _getContextProps2 = _interopRequireDefault(_getContextProps);

var _config = __webpack_require__(84);

var _consumer = __webpack_require__(92);

var _consumer2 = _interopRequireDefault(_consumer);

var _cache = __webpack_require__(93);

var _cache2 = _interopRequireDefault(_cache);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var childContextCache = new _cache2.default();

/**
 * ConfigProvider
 * @propsExtends false
 */
var ConfigProvider = (_temp = _class = function (_Component) {
    _inherits(ConfigProvider, _Component);

    /**
     * 传入组件的 props 和 displayName，得到和 childContext 计算过的包含有 preifx/locale/pure 的对象，一般用于通过静态方法生成脱离组件树的组件
     * @param {Object} props 组件的 props
     * @param {String} displayName 组件的 displayName
     * @returns {Object} 新的 context props
     */
    function ConfigProvider() {
        _classCallCheck(this, ConfigProvider);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args)));

        childContextCache.add(_this, _extends({}, childContextCache.get(_this, {}), _this.getChildContext()));
        return _this;
    }

    /**
     * 传入组件，生成受 ConfigProvider 控制的 HOC 组件
     * @param {Component} Component 组件类
     * @param {Object} options 可选项
     * @returns {Component} HOC
     */


    ConfigProvider.prototype.getChildContext = function getChildContext() {
        var _props = this.props,
            prefix = _props.prefix,
            locale = _props.locale,
            pure = _props.pure,
            warning = _props.warning,
            rtl = _props.rtl;


        return {
            nextPrefix: prefix,
            nextLocale: locale,
            nextPure: pure,
            nextRtl: rtl,
            nextWarning: warning
        };
    };

    ConfigProvider.prototype.componentWillMount = function componentWillMount() {
        this.setMomentLocale(this.props.locale);
    };

    ConfigProvider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (this.props.locale !== nextProps.locale) {
            this.setMomentLocale(nextProps.locale);
        }
    };

    ConfigProvider.prototype.componentDidUpdate = function componentDidUpdate() {
        childContextCache.add(this, _extends({}, childContextCache.get(this, {}), this.getChildContext()));
    };

    ConfigProvider.prototype.componentWillUnmount = function componentWillUnmount() {
        childContextCache.remove(this);
    };

    ConfigProvider.prototype.setMomentLocale = function setMomentLocale(locale) {
        var moment = void 0;
        try {
            moment = __webpack_require__(94);
        } catch (e) {
            // ignore
        }

        if (moment && locale) {
            moment.locale(locale.momentLocale);
        }
    };

    ConfigProvider.prototype.render = function render() {
        return _react.Children.only(this.props.children);
    };

    return ConfigProvider;
}(_react.Component), _class.propTypes = {
    /**
     * 样式类名的品牌前缀
     */
    prefix: _propTypes2.default.string,
    /**
     * 国际化文案对象，属性为组件的 displayName
     */
    locale: _propTypes2.default.object,
    /**
     * 是否开启 Pure Render 模式，会提高性能，但是也会带来副作用
     */
    pure: _propTypes2.default.bool,
    /**
     * 是否在开发模式下显示组件属性被废弃的 warning 提示
     */
    warning: _propTypes2.default.bool,
    /**
     * 是否开启 rtl 模式
     */
    rtl: _propTypes2.default.bool,
    /**
     * 组件树
     */
    children: _propTypes2.default.element
}, _class.defaultProps = {
    warning: true
}, _class.childContextTypes = {
    nextPrefix: _propTypes2.default.string,
    nextLocale: _propTypes2.default.object,
    nextPure: _propTypes2.default.bool,
    nextRtl: _propTypes2.default.bool,
    nextWarning: _propTypes2.default.bool
}, _class.config = function (Component, options) {
    return (0, _config.config)(Component, options);
}, _class.getContextProps = function (props, displayName) {
    return (0, _getContextProps2.default)(props, childContextCache.root() || {}, displayName);
}, _class.initLocales = _config.initLocales, _class.setLanguage = _config.setLanguage, _class.setLocale = _config.setLocale, _class.setDirection = _config.setDirection, _class.getLanguage = _config.getLanguage, _class.getLocale = _config.getLocale, _class.getDirection = _config.getDirection, _class.Consumer = _consumer2.default, _class.getContext = function () {
    var _ref = childContextCache.root() || {},
        nextPrefix = _ref.nextPrefix,
        nextLocale = _ref.nextLocale,
        nextPure = _ref.nextPure,
        nextRtl = _ref.nextRtl,
        nextWarning = _ref.nextWarning;

    return {
        prefix: nextPrefix,
        locale: nextLocale,
        pure: nextPure,
        rtl: nextRtl,
        warning: nextWarning
    };
}, _temp);
ConfigProvider.displayName = 'ConfigProvider';
exports.default = ConfigProvider;
module.exports = exports['default'];

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			memo[selector] = fn.call(this, selector);
		}

		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(143);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var blackList = ['defaultProps', 'propTypes', 'contextTypes', 'childContextTypes', 'displayName'];

var statics = exports.statics = function statics(Target, Component) {
    Object.keys(Component).forEach(function (property) {
        if (blackList.indexOf(property) === -1) {
            Target[property] = Component[property];
        }
    });
};

var fetchDataByPath = exports.fetchDataByPath = function fetchDataByPath(object, path) {
    if (!object || !path) {
        return false;
    }
    path = path.toString();
    var field = path.split('.');
    var val = void 0,
        key = void 0;
    if (field.length) {
        key = field[0];
        // lists[1].name
        if (key.indexOf('[') >= 0) {
            key = key.match(/(.*)\[(.*)\]/);
            if (key) {
                val = object[key[1]][key[2]];
            }
        } else {
            val = object[field[0]];
        }
        if (val) {
            for (var colIndex = 1; colIndex < field.length; colIndex++) {
                val = val[field[colIndex]];
                if (typeof val === 'undefined') {
                    break;
                }
            }
        }
    }
    return val;
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Icon
 */
var Icon = (_temp = _class = function (_Component) {
    _inherits(Icon, _Component);

    function Icon() {
        _classCallCheck(this, Icon);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    Icon.prototype.render = function render() {
        var _cx;

        /* eslint-disable no-unused-vars*/
        var _props = this.props,
            prefix = _props.prefix,
            type = _props.type,
            size = _props.size,
            className = _props.className,
            rtl = _props.rtl,
            other = _objectWithoutProperties(_props, ['prefix', 'type', 'size', 'className', 'rtl']);

        var classes = (0, _classnames2.default)((_cx = {}, _cx[prefix + 'icon'] = true, _cx[prefix + 'icon-' + type] = !!type, _cx['' + prefix + size] = !!size, _cx[className] = !!className, _cx));

        if (rtl && ['arrow-left', 'arrow-right', 'arrow-double-left', 'arrow-double-right', 'switch', 'sorting', 'descending', 'ascending'].indexOf(type) !== -1) {
            other.dir = 'rtl';
        }

        return _react2.default.createElement('i', _extends({}, other, { className: classes }));
    };

    return Icon;
}(_react.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    rtl: _propTypes2.default.bool,
    /**
     * 指定显示哪种图标
     */
    type: _propTypes2.default.string,
    /**
     * 指定图标大小
     */
    size: _propTypes2.default.oneOf(['xxs', 'xs', 'small', 'medium', 'large', 'xl', 'xxl', 'xxxl']),
    className: _propTypes2.default.string
}, _class.defaultProps = {
    prefix: 'next-',
    size: 'medium'
}, _class._typeMark = 'icon', _temp);
Icon.displayName = 'Icon';
exports.default = _configProvider2.default.config(Icon);
module.exports = exports['default'];

/***/ }),
/* 10 */,
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(142);

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(144);

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.typeOf = typeOf;
exports.isArrayLike = isArrayLike;
exports.isPromise = isPromise;
exports.isPlainObject = isPlainObject;
exports.shallowEqual = shallowEqual;
exports.each = each;
exports.pickOthers = pickOthers;
exports.pickAttrsWith = pickAttrsWith;
/**
 * 获取对象的类型
 * @param  {*} obj
 * @return {String}
 *
 * @example
 * typeOf([]) === 'Array'
 * typeOf() === 'Undefined'
 * typeOf(1) === 'Number'
 */
function typeOf(obj) {
    return Object.prototype.toString.call(obj).replace(/\[object\s|]/g, '');
}

/**
 * 判断是否是数组或类数组对象
 * @param  {*}  obj
 * @return {Boolean}
 *
 * @example
 * isArrayLike([]) === true
 * isArrayLike(arguments) === true
 * isArrayLike(this.props.children) === true
 */
function isArrayLike(obj) {
    var length = !!obj && 'length' in obj && obj.length;
    var type = typeOf(obj);

    return type === 'Array' || length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj;
}

/**
 * 判断对象是否是一个promise，即是否可以用.then
 * @param  {*}  obj
 * @return {Boolean}
 */
function isPromise(obj) {
    return !!obj && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}

/**
 * 是否是一个纯净的对象
 * @param  {*}  obj
 * @return {Boolean}
 * @reference https://github.com/jonschlinkert/is-plain-object
 */
function isPlainObject(obj) {
    if (typeOf(obj) !== 'Object') {
        return false;
    }

    var ctor = obj.constructor;

    if (typeof ctor !== 'function') {
        return false;
    }

    var prot = ctor.prototype;

    if (typeOf(prot) !== 'Object') {
        return false;
    }

    if (!prot.hasOwnProperty('isPrototypeOf')) {
        return false;
    }

    return true;
}

/**
 * 对象浅比较
 * @param  {Object} objA
 * @param  {Object} objB
 * @param  {Function}  [compare] 手动调用方法比较
 * @return {Boolean}      对象浅比较是否相等
 *
 * @example
 * object.shallowEqual({a: 100}, {a: 100}); // true
 */
function shallowEqual(objA, objB, compare) {
    if (objA === objB) {
        return true;
    }

    // 其中一个不是object，则不相等
    if (!objA || !objB || (typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) + (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'objectobject') {
        return false;
    }

    var keyA = Object.keys(objA);
    var keyB = Object.keys(objB);
    var len = keyA.length;

    // key 数量不一致则不相等
    if (len !== keyB.length) {
        return false;
    }

    var hasCallback = typeof compare === 'function';

    for (var i = 0; i < len; i++) {
        var key = keyA[i];

        if (!Object.prototype.hasOwnProperty.call(objB, key)) {
            return false;
        }

        var valA = objA[key];
        var valB = objB[key];

        var ret = hasCallback ? compare(valA, valB, key) : void 0;

        if (ret === false || ret === void 0 && valA !== valB) {
            return false;
        }
    }

    return true;
}

/**
 * 遍历对象或数组，或者类数组，例如React中的children对象、arguments等
 * @param  {Object|Array}   obj
 * @param  {Function} callback fn(n, i) or fn(val, key)
 * @param  {Number}   [direction = 1] 是否倒序遍历，只对数组有效
 * @return {Object|Array}
 *
 * @example
 * // 遍历数组
 * object.each([100, 200, 300], (n, i) => console.log(n, i));
 * // 遍历json对象
 * object.each({a: 100, b: 200}, (value, key) => console.log(key, value));
 * // 遍历React子节点
 * object.each(this.props.children, (child, index) => console.log(child));
 * // 遍历arguments
 * object.each(arguments, (arg, i) => console.log(arg));
 */
function each(obj, callback, direction) {
    var reversed = direction === -1;
    var length = obj.length;
    var value = void 0,
        i = reversed ? length - 1 : 0;

    if (isArrayLike(obj)) {
        for (; i < length && i >= 0; reversed ? i-- : i++) {
            value = callback.call(obj[i], obj[i], i);

            if (value === false) {
                break;
            }
        }
    } else {
        for (i in obj) {
            /* istanbul ignore else */
            if (obj.hasOwnProperty(i)) {
                value = callback.call(obj[i], obj[i], i);

                if (value === false) {
                    break;
                }
            }
        }
    }

    return obj;
}

// @private 判断key是否在数组或对象中
var _isInObj = function _isInObj(key, obj, isArray) {
    return isArray ? obj.indexOf(key) > -1 : key in obj;
};

/**
 * 过滤出其它属性
 * @param  {Object|Array} holdProps 过滤的参照对象，最终的结果只保留不在参照对象中的key
 * @param  {Object} props     被过滤的对象
 * @return {Object}           others
 *
 * @example
 * object.pickOthers(FooComponent.propTypes, this.props);
 * object.pickOthers(['className', 'onChange'], this.props);
 */
function pickOthers(holdProps, props) {
    var others = {};
    var isArray = typeOf(holdProps) === 'Array';

    for (var key in props) {
        if (!_isInObj(key, holdProps, isArray)) {
            others[key] = props[key];
        }
    }

    return others;
}

/**
 * 过滤出带prefix的属性
 * @param  {Object} holdProps 过滤的参照对象，最终的结果只保留不在参照对象中的key
 * @param  {string} prefix    包含的字符串
 * @return {Object}           others
 *
 * @example
 * object.pickAttrsWith(FooComponent.propTypes, 'data-');
 */
function pickAttrsWith(holdProps, prefix) {
    var others = {};

    for (var key in holdProps) {
        if (key.match(prefix)) {
            others[key] = holdProps[key];
        }
    }

    return others;
}

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var bindCtx = _util.func.bindCtx;
var pickOthers = _util.obj.pickOthers;
var Item = (_temp = _class = function (_Component) {
    _inherits(Item, _Component);

    function Item(props) {
        _classCallCheck(this, Item);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        bindCtx(_this, ['handleClick', 'handleKeyDown']);
        return _this;
    }

    Item.prototype.componentDidMount = function componentDidMount() {
        this.itemNode = (0, _reactDom.findDOMNode)(this);

        var _props = this.props,
            parentMode = _props.parentMode,
            root = _props.root;

        if (parentMode === 'popup') {
            this.menuNode = this.itemNode.parentNode;
        } else {
            this.menuNode = (0, _reactDom.findDOMNode)(root);
            var _root$props = root.props,
                prefix = _root$props.prefix,
                header = _root$props.header,
                footer = _root$props.footer;

            if (header || footer) {
                this.menuNode = this.menuNode.querySelector('.' + prefix + 'menu-content');
            }
        }

        this.setFocus();
    };

    Item.prototype.componentDidUpdate = function componentDidUpdate() {
        this.setFocus();
    };

    Item.prototype.focusable = function focusable() {
        var _props2 = this.props,
            root = _props2.root,
            type = _props2.type,
            disabled = _props2.disabled;
        var focusable = root.props.focusable;

        return focusable && (type === 'submenu' || !disabled);
    };

    Item.prototype.getFocused = function getFocused() {
        var _props3 = this.props,
            _key = _props3._key,
            root = _props3.root;
        var focusedKey = root.state.focusedKey;

        return focusedKey === _key;
    };

    Item.prototype.setFocus = function setFocus() {
        var focused = this.getFocused();
        if (focused) {
            if (this.focusable()) {
                this.itemNode.focus({ preventScroll: true });
            }
            if (this.menuNode && this.menuNode.scrollHeight > this.menuNode.clientHeight) {
                var scrollBottom = this.menuNode.clientHeight + this.menuNode.scrollTop;
                var itemBottom = this.itemNode.offsetTop + this.itemNode.offsetHeight;
                if (itemBottom > scrollBottom) {
                    this.menuNode.scrollTop = itemBottom - this.menuNode.clientHeight;
                } else if (this.itemNode.offsetTop < this.menuNode.scrollTop) {
                    this.menuNode.scrollTop = this.itemNode.offsetTop;
                }
            }
        }
    };

    Item.prototype.handleClick = function handleClick(e) {
        e.stopPropagation();

        var _props4 = this.props,
            _key = _props4._key,
            root = _props4.root,
            disabled = _props4.disabled;


        if (!disabled) {
            root.handleItemClick(_key, this, e);

            this.props.onClick && this.props.onClick(e);
        } else {
            e.preventDefault();
        }
    };

    Item.prototype.handleKeyDown = function handleKeyDown(e) {
        var _props5 = this.props,
            _key = _props5._key,
            root = _props5.root,
            type = _props5.type;

        if (this.focusable()) {
            root.handleItemKeyDown(_key, type, this, e);
        }

        this.props.onKeyDown && this.props.onKeyDown(e);
    };

    Item.prototype.getTitle = function getTitle(children) {
        var labelString = '';

        var loop = function loop(children) {
            _react.Children.forEach(children, function (child) {
                if ((0, _react.isValidElement)(child) && child.props.children) {
                    loop(child.props.children);
                } else if (typeof child === 'string') {
                    labelString += child;
                }
            });
        };

        loop(children);

        return labelString;
    };

    Item.prototype.render = function render() {
        var _cx;

        var _props6 = this.props,
            level = _props6.level,
            root = _props6.root,
            replaceClassName = _props6.replaceClassName,
            groupIndent = _props6.groupIndent,
            component = _props6.component,
            disabled = _props6.disabled,
            className = _props6.className,
            children = _props6.children,
            needIndent = _props6.needIndent,
            parentMode = _props6.parentMode,
            _key = _props6._key;

        var others = pickOthers(Object.keys(Item.propTypes), this.props);

        var _root$props2 = root.props,
            prefix = _root$props2.prefix,
            focusable = _root$props2.focusable,
            inlineIndent = _root$props2.inlineIndent,
            itemClassName = _root$props2.itemClassName,
            rtl = _root$props2.rtl;

        var focused = this.getFocused();

        var newClassName = replaceClassName ? className : (0, _classnames2.default)((_cx = {}, _cx[prefix + 'menu-item'] = true, _cx[prefix + 'disabled'] = disabled, _cx[prefix + 'focused'] = !focusable && focused, _cx[itemClassName] = !!itemClassName, _cx[className] = !!className, _cx));
        if (disabled) {
            others['aria-disabled'] = true;
        }

        others.tabIndex = root.tabbableKey === _key ? '0' : '-1';

        if (parentMode === 'inline' && level > 1 && inlineIndent > 0 && needIndent) {
            var _extends2;

            others.style = _extends({}, others.style || {}, (_extends2 = {}, _extends2[rtl ? 'paddingRight' : 'paddingLeft'] = level * inlineIndent - (groupIndent || 0) * 0.4 * inlineIndent + 'px', _extends2));
        }
        var TagName = component;

        return _react2.default.createElement(
            TagName,
            _extends({ role: 'menuitem',
                title: this.getTitle(children)
            }, others, {
                className: newClassName,
                onClick: this.handleClick,
                onKeyDown: this.handleKeyDown }),
            _react2.default.createElement(
                'div',
                { className: prefix + 'menu-item-inner' },
                children
            )
        );
    };

    return Item;
}(_react.Component), _class.propTypes = {
    _key: _propTypes2.default.string,
    level: _propTypes2.default.number,
    groupIndent: _propTypes2.default.number,
    root: _propTypes2.default.object,
    parent: _propTypes2.default.object,
    parentMode: _propTypes2.default.oneOf(['inline', 'popup']),
    type: _propTypes2.default.oneOf(['submenu', 'item']),
    component: _propTypes2.default.string,
    disabled: _propTypes2.default.bool,
    className: _propTypes2.default.string,
    onClick: _propTypes2.default.func,
    onKeyDown: _propTypes2.default.func,
    needIndent: _propTypes2.default.bool,
    replaceClassName: _propTypes2.default.bool
}, _class.defaultProps = {
    component: 'li',
    groupIndent: 0,
    replaceClassName: false,
    needIndent: true
}, _temp);
Item.displayName = 'Item';
exports.default = Item;
module.exports = exports['default'];

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _overlay = __webpack_require__(45);

var _overlay2 = _interopRequireDefault(_overlay);

var _gateway = __webpack_require__(46);

var _gateway2 = _interopRequireDefault(_gateway);

var _position = __webpack_require__(47);

var _position2 = _interopRequireDefault(_position);

var _popup = __webpack_require__(99);

var _popup2 = _interopRequireDefault(_popup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_overlay2.default.Gateway = _gateway2.default;
_overlay2.default.Position = _position2.default;
_overlay2.default.Popup = _configProvider2.default.config(_popup2.default, {
    exportNames: ['overlay']
});

exports.default = _configProvider2.default.config(_overlay2.default, {
    exportNames: ['getContent', 'getContentNode']
});
module.exports = exports['default'];

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _row = __webpack_require__(17);

var _row2 = _interopRequireDefault(_row);

var _cell = __webpack_require__(18);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};

var Body = (_temp2 = _class = function (_React$Component) {
    _inherits(Body, _React$Component);

    function Body() {
        var _temp, _this, _ret;

        _classCallCheck(this, Body);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.getRowRef = function (i, row) {
            _this.props.rowRef(i, row);
        }, _this.onRowClick = function (record, index, e) {
            _this.props.onRowClick(record, index, e);
        }, _this.onRowMouseEnter = function (record, index, e) {
            _this.props.onRowMouseEnter(record, index, e);
        }, _this.onRowMouseLeave = function (record, index, e) {
            _this.props.onRowMouseLeave(record, index, e);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Body.prototype.render = function render() {
        var _this2 = this;

        /*eslint-disable no-unused-vars */
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            children = _props.children,
            Tag = _props.component,
            colGroup = _props.colGroup,
            loading = _props.loading,
            emptyContent = _props.emptyContent,
            components = _props.components,
            getCellProps = _props.getCellProps,
            primaryKey = _props.primaryKey,
            getRowProps = _props.getRowProps,
            dataSource = _props.dataSource,
            cellRef = _props.cellRef,
            columns = _props.columns,
            rowRef = _props.rowRef,
            onRowClick = _props.onRowClick,
            onRowMouseEnter = _props.onRowMouseEnter,
            onRowMouseLeave = _props.onRowMouseLeave,
            locale = _props.locale,
            pure = _props.pure,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'children', 'component', 'colGroup', 'loading', 'emptyContent', 'components', 'getCellProps', 'primaryKey', 'getRowProps', 'dataSource', 'cellRef', 'columns', 'rowRef', 'onRowClick', 'onRowMouseEnter', 'onRowMouseLeave', 'locale', 'pure']);

        var _components$Row = components.Row,
            Row = _components$Row === undefined ? _row2.default : _components$Row,
            _components$Cell = components.Cell,
            Cell = _components$Cell === undefined ? _cell2.default : _components$Cell;

        var empty = loading ? _react2.default.createElement(
            'span',
            null,
            '\xA0'
        ) : emptyContent || locale.empty;
        var rows = _react2.default.createElement(
            'tr',
            null,
            _react2.default.createElement(
                'td',
                { colSpan: columns.length },
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'table-empty' },
                    empty
                )
            )
        );
        if (Tag === 'div') {
            rows = _react2.default.createElement(
                'table',
                { role: 'table' },
                _react2.default.createElement(
                    'tbody',
                    null,
                    rows
                )
            );
        }
        if (dataSource.length) {
            rows = dataSource.map(function (record, index) {
                var _classnames;

                var rowProps = getRowProps(record, index) || {};
                var rowClass = rowProps.className;
                var className = (0, _classnames3.default)((_classnames = {
                    first: index === 0,
                    last: index === dataSource.length - 1
                }, _classnames[rowClass] = rowClass, _classnames));
                var expanded = record.__expanded ? 'expanded' : '';
                return _react2.default.createElement(Row, _extends({ key: '' + (record[primaryKey] || index) + expanded
                }, rowProps, {
                    ref: _this2.getRowRef.bind(_this2, index),
                    colGroup: colGroup,
                    columns: columns,
                    primaryKey: primaryKey,
                    record: record,
                    rowIndex: index,
                    prefix: prefix,
                    pure: pure,
                    cellRef: cellRef,
                    getCellProps: getCellProps,
                    className: className,
                    Cell: Cell,
                    onClick: _this2.onRowClick,
                    locale: locale,
                    onMouseEnter: _this2.onRowMouseEnter,
                    onMouseLeave: _this2.onRowMouseLeave
                }));
            });
        }
        return _react2.default.createElement(
            Tag,
            _extends({ className: className }, others),
            rows,
            children
        );
    };

    return Body;
}(_react2.default.Component), _class.propTypes = {
    loading: _propTypes2.default.bool,
    emptyContent: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    components: _propTypes2.default.object,
    getCellProps: _propTypes2.default.func,
    cellRef: _propTypes2.default.func,
    primaryKey: _propTypes2.default.string,
    getRowProps: _propTypes2.default.func,
    rowRef: _propTypes2.default.func,
    dataSource: _propTypes2.default.array,
    children: _propTypes2.default.any,
    className: _propTypes2.default.string,
    component: _propTypes2.default.string,
    colGroup: _propTypes2.default.object,
    columns: _propTypes2.default.array,
    onRowClick: _propTypes2.default.func,
    onRowMouseEnter: _propTypes2.default.func,
    onRowMouseLeave: _propTypes2.default.func,
    locale: _propTypes2.default.object
}, _class.defaultProps = {
    loading: false,
    prefix: 'next-',
    components: {},
    getCellProps: noop,
    cellRef: noop,
    primaryKey: 'id',
    getRowProps: noop,
    rowRef: noop,
    dataSource: [],
    component: 'tbody',
    columns: []
}, _temp2);
Body.displayName = 'Body';
exports.default = Body;
module.exports = exports['default'];

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames3 = __webpack_require__(3);

var _classnames4 = _interopRequireDefault(_classnames3);

var _util = __webpack_require__(2);

var _util2 = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};

var Row = (_temp2 = _class = function (_React$Component) {
    _inherits(Row, _React$Component);

    function Row() {
        var _temp, _this, _ret;

        _classCallCheck(this, Row);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onClick = function (e) {
            var _this$props = _this.props,
                record = _this$props.record,
                rowIndex = _this$props.rowIndex;

            _this.props.onClick(record, rowIndex, e);
        }, _this.onMouseEnter = function (e) {
            var _this$props2 = _this.props,
                record = _this$props2.record,
                rowIndex = _this$props2.rowIndex;

            _this.onRowHover(record, rowIndex, true, e);
        }, _this.onMouseLeave = function (e) {
            var _this$props3 = _this.props,
                record = _this$props3.record,
                rowIndex = _this$props3.rowIndex;

            _this.onRowHover(record, rowIndex, false, e);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Row.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
        if (nextProps.pure) {
            var isEqual = _util.obj.shallowEqual(this.props, nextProps);
            return !isEqual;
        }

        return true;
    };

    Row.prototype.onRowHover = function onRowHover(record, index, isEnter, e) {
        var _props = this.props,
            onMouseEnter = _props.onMouseEnter,
            onMouseLeave = _props.onMouseLeave,
            currentRow = (0, _reactDom.findDOMNode)(this);

        if (isEnter) {
            onMouseEnter(record, index, e);
            currentRow && _util.dom.addClass(currentRow, 'hovered');
        } else {
            onMouseLeave(record, index, e);
            currentRow && _util.dom.removeClass(currentRow, 'hovered');
        }
    };

    Row.prototype.renderCells = function renderCells(record) {
        var _this2 = this;

        var _props2 = this.props,
            Cell = _props2.Cell,
            columns = _props2.columns,
            getCellProps = _props2.getCellProps,
            cellRef = _props2.cellRef,
            prefix = _props2.prefix,
            rowIndex = _props2.rowIndex,
            primaryKey = _props2.primaryKey,
            pure = _props2.pure,
            locale = _props2.locale;
        var lockType = this.context.lockType;

        return columns.map(function (child, colIndex) {
            var _classnames;

            var dataIndex = child.dataIndex,
                align = child.align,
                width = child.width,
                others = _objectWithoutProperties(child, ['dataIndex', 'align', 'width']);

            var value = (0, _util2.fetchDataByPath)(record, dataIndex);
            var attrs = getCellProps(rowIndex, colIndex, dataIndex, record) || {};

            if (_this2.context.notRenderCellIndex) {
                var matchCellIndex = _this2.context.notRenderCellIndex.map(function (cellIndex) {
                    return cellIndex.toString();
                }).indexOf([rowIndex, colIndex].toString());
                if (matchCellIndex > -1) {
                    _this2.context.notRenderCellIndex.splice(matchCellIndex, 1);
                    return null;
                }
            }
            if (attrs.colSpan && attrs.colSpan > 1 || attrs.rowSpan && attrs.rowSpan > 1) {
                _this2._getNotRenderCellIndex(colIndex, rowIndex, attrs.colSpan || 1, attrs.rowSpan || 1);
            }

            var className = (0, _classnames4.default)((_classnames = {
                first: lockType !== 'right' && colIndex === 0,
                last: lockType !== 'left' && (colIndex === columns.length - 1 || colIndex + attrs.colSpan === columns.length) }, _classnames[child.className] = child.className, _classnames));

            return _react2.default.createElement(Cell, _extends({ key: colIndex
            }, others, attrs, {
                ref: function ref(cell) {
                    return cellRef(rowIndex, colIndex, cell);
                },
                prefix: prefix,
                pure: pure,
                primaryKey: primaryKey,
                record: record,
                className: className,
                value: value,
                colIndex: colIndex,
                rowIndex: rowIndex,
                align: align,
                locale: locale,
                width: width
            }));
        });
    };

    Row.prototype._getNotRenderCellIndex = function _getNotRenderCellIndex(colIndex, rowIndex, colSpan, rowSpan) {
        var maxColIndex = colSpan;
        var maxRowIndex = rowSpan;
        var notRenderCellIndex = [];
        for (var i = 0; i < maxColIndex; i++) {
            for (var j = 0; j < maxRowIndex; j++) {
                notRenderCellIndex.push([rowIndex + j, colIndex + i]);
            }
        }
        [].push.apply(this.context.notRenderCellIndex, notRenderCellIndex);
    };

    Row.prototype.render = function render() {
        var _classnames2;

        /* eslint-disable no-unused-vars*/
        var _props3 = this.props,
            prefix = _props3.prefix,
            className = _props3.className,
            onClick = _props3.onClick,
            onMouseEnter = _props3.onMouseEnter,
            onMouseLeave = _props3.onMouseLeave,
            columns = _props3.columns,
            Cell = _props3.Cell,
            getCellProps = _props3.getCellProps,
            rowIndex = _props3.rowIndex,
            record = _props3.record,
            children = _props3.children,
            primaryKey = _props3.primaryKey,
            cellRef = _props3.cellRef,
            colGroup = _props3.colGroup,
            pure = _props3.pure,
            others = _objectWithoutProperties(_props3, ['prefix', 'className', 'onClick', 'onMouseEnter', 'onMouseLeave', 'columns', 'Cell', 'getCellProps', 'rowIndex', 'record', 'children', 'primaryKey', 'cellRef', 'colGroup', 'pure']);

        var cls = (0, _classnames4.default)((_classnames2 = {}, _classnames2[prefix + 'table-row'] = true, _classnames2[className] = className, _classnames2));
        return _react2.default.createElement(
            'tr',
            _extends({ className: cls, role: 'row' }, others, {
                onClick: this.onClick, onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave }),
            this.renderCells(record),
            children
        );
    };

    return Row;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    primaryKey: _propTypes2.default.string,
    className: _propTypes2.default.string,
    columns: _propTypes2.default.array,
    record: _propTypes2.default.any,
    Cell: _propTypes2.default.func,
    rowIndex: _propTypes2.default.number,
    getCellProps: _propTypes2.default.func,
    onClick: _propTypes2.default.func,
    onMouseEnter: _propTypes2.default.func,
    onMouseLeave: _propTypes2.default.func,
    children: _propTypes2.default.any,
    cellRef: _propTypes2.default.func,
    colGroup: _propTypes2.default.object,
    locale: _propTypes2.default.object
}, _class.defaultProps = {
    prefix: 'next-',
    primaryKey: 'id',
    columns: [],
    record: {},
    getCellProps: noop,
    onClick: noop,
    onMouseEnter: noop,
    onMouseLeave: noop,
    cellRef: noop,
    colGroup: {}
}, _class.contextTypes = {
    notRenderCellIndex: _propTypes2.default.array,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}, _temp2);
Row.displayName = 'Row';
exports.default = Row;
module.exports = exports['default'];

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var Cell = (_temp = _class = function (_React$Component) {
    _inherits(Cell, _React$Component);

    function Cell() {
        _classCallCheck(this, Cell);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    Cell.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
        if (nextProps.pure) {
            var isEqual = _util.obj.shallowEqual(this.props, nextProps);
            return !isEqual;
        }
        return true;
    };

    Cell.prototype.render = function render() {
        var _classnames;

        /* eslint-disable no-unused-vars */
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            cell = _props.cell,
            value = _props.value,
            resizable = _props.resizable,
            colIndex = _props.colIndex,
            rowIndex = _props.rowIndex,
            record = _props.record,
            context = _props.context,
            align = _props.align,
            _props$style = _props.style,
            style = _props$style === undefined ? {} : _props$style,
            Tag = _props.component,
            children = _props.children,
            title = _props.title,
            width = _props.width,
            innerStyle = _props.innerStyle,
            primaryKey = _props.primaryKey,
            __normalized = _props.__normalized,
            filterMode = _props.filterMode,
            filters = _props.filters,
            sortable = _props.sortable,
            lock = _props.lock,
            pure = _props.pure,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'cell', 'value', 'resizable', 'colIndex', 'rowIndex', 'record', 'context', 'align', 'style', 'component', 'children', 'title', 'width', 'innerStyle', 'primaryKey', '__normalized', 'filterMode', 'filters', 'sortable', 'lock', 'pure']);

        var tagStyle = _extends({}, style);
        var cellProps = { value: value, index: rowIndex, record: record, context: context };
        var content = cell;
        if (_react2.default.isValidElement(content)) {
            content = _react2.default.cloneElement(content, cellProps);
        } else if (typeof content === 'function') {
            content = content(value, rowIndex, record, context);
        }
        if (align) {
            tagStyle.textAlign = align;
        }
        var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-cell'] = true, _classnames[className] = className, _classnames));

        return _react2.default.createElement(
            Tag,
            _extends({}, others, { className: cls, style: tagStyle, role: 'gridcell' }),
            _react2.default.createElement(
                'div',
                { className: prefix + 'table-cell-wrapper', style: innerStyle },
                content,
                children
            )
        );
    };

    return Cell;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    primaryKey: _propTypes2.default.string,
    className: _propTypes2.default.string,
    record: _propTypes2.default.any,
    value: _propTypes2.default.any,
    colIndex: _propTypes2.default.number,
    rowIndex: _propTypes2.default.number,
    title: _propTypes2.default.any,
    width: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    context: _propTypes2.default.any,
    cell: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.node, _propTypes2.default.func]),
    align: _propTypes2.default.oneOf(['left', 'center', 'right']),
    component: _propTypes2.default.oneOf(['td', 'th', 'div']),
    children: _propTypes2.default.any,
    style: _propTypes2.default.object,
    innerStyle: _propTypes2.default.object,
    filterMode: _propTypes2.default.oneOf(['single', 'multiple']),
    filters: _propTypes2.default.array,
    sortable: _propTypes2.default.bool,
    lock: _propTypes2.default.any,
    type: _propTypes2.default.oneOf(['header', 'body']),
    resizable: _propTypes2.default.bool,
    __normalized: _propTypes2.default.bool
}, _class.defaultProps = {
    component: 'td',
    type: 'body',
    cell: function cell(value) {
        return value;
    },
    prefix: 'next-'
}, _temp);
Cell.displayName = 'Cell';
exports.default = Cell;
module.exports = exports['default'];

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _header = __webpack_require__(48);

var _header2 = _interopRequireDefault(_header);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var FixedHeader = (_temp = _class = function (_React$Component) {
    _inherits(FixedHeader, _React$Component);

    function FixedHeader() {
        _classCallCheck(this, FixedHeader);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    FixedHeader.prototype.componentDidMount = function componentDidMount() {
        this.context.getNode('header', (0, _reactDom.findDOMNode)(this));
    };

    FixedHeader.prototype.render = function render() {
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            colGroup = _props.colGroup,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'colGroup']);

        return _react2.default.createElement(
            'div',
            { className: className },
            _react2.default.createElement(
                'div',
                { className: prefix + 'table-header-inner' },
                _react2.default.createElement(
                    'table',
                    null,
                    colGroup,
                    _react2.default.createElement(_header2.default, _extends({}, others, { prefix: prefix }))
                )
            )
        );
    };

    return FixedHeader;
}(_react2.default.Component), _class.propTypes = {
    children: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    className: _propTypes2.default.string,
    colGroup: _propTypes2.default.any
}, _class.contextTypes = {
    getNode: _propTypes2.default.func,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}, _temp);
FixedHeader.displayName = 'FixedHeader';
exports.default = FixedHeader;
module.exports = exports['default'];

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = findNode;

var _reactDom = __webpack_require__(4);

function findNode(target, param) {
    if (!target) {
        return null;
    }

    if (typeof target === 'string') {
        return document.getElementById(target);
    }

    if (typeof target === 'function') {
        target = target(param);
    }

    if (!target) {
        return null;
    }

    try {
        return (0, _reactDom.findDOMNode)(target);
    } catch (err) {
        return target;
    }
}
module.exports = exports['default'];

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

var _item = __webpack_require__(14);

var _item2 = _interopRequireDefault(_item);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var bindCtx = _util.func.bindCtx;
var pickOthers = _util.obj.pickOthers;

/**
 * Menu.Item
 * @order 0
 */

var SelectableItem = (_temp = _class = function (_Component) {
    _inherits(SelectableItem, _Component);

    function SelectableItem(props) {
        _classCallCheck(this, SelectableItem);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        bindCtx(_this, ['handleKeyDown', 'handleClick']);
        return _this;
    }

    SelectableItem.prototype.getSelected = function getSelected() {
        var _props = this.props,
            _key = _props._key,
            root = _props.root,
            selected = _props.selected;
        var selectMode = root.props.selectMode;
        var selectedKeys = root.state.selectedKeys;

        return selected || !!selectMode && selectedKeys.indexOf(_key) > -1;
    };

    SelectableItem.prototype.handleSelect = function handleSelect(e) {
        var _props2 = this.props,
            _key = _props2._key,
            root = _props2.root,
            onSelect = _props2.onSelect;

        if (onSelect) {
            onSelect(!this.getSelected(), this, e);
        } else {
            root.handleSelect(_key, !this.getSelected(), this);
        }
    };

    SelectableItem.prototype.handleKeyDown = function handleKeyDown(e) {
        if (e.keyCode === _util.KEYCODE.SPACE) {
            this.handleSelect(e);
        }

        this.props.onKeyDown && this.props.onKeyDown(e);
    };

    SelectableItem.prototype.handleClick = function handleClick(e) {
        this.handleSelect(e);

        this.props.onClick && this.props.onClick(e);
    };

    SelectableItem.prototype.renderSelectedIcon = function renderSelectedIcon(selected) {
        var _props3 = this.props,
            root = _props3.root,
            inlineIndent = _props3.inlineIndent,
            needIndent = _props3.needIndent,
            hasSelectedIcon = _props3.hasSelectedIcon;
        var _root$props = root.props,
            prefix = _root$props.prefix,
            rootSelectedIcon = _root$props.hasSelectedIcon;


        return ('hasSelectedIcon' in this.props ? hasSelectedIcon : rootSelectedIcon) && selected ? _react2.default.createElement(_icon2.default, { style: needIndent && inlineIndent > 0 ? { left: inlineIndent + 'px' } : null, className: prefix + 'menu-icon-selected', type: 'select' }) : null;
    };

    SelectableItem.prototype.render = function render() {
        var _cx;

        var _props4 = this.props,
            _key = _props4._key,
            root = _props4.root,
            className = _props4.className,
            disabled = _props4.disabled,
            helper = _props4.helper,
            children = _props4.children,
            needIndent = _props4.needIndent;
        var prefix = root.props.prefix;

        var others = pickOthers(Object.keys(SelectableItem.propTypes), this.props);
        var selected = this.getSelected();

        var newProps = _extends({
            _key: _key,
            root: root,
            disabled: disabled,
            type: 'item',
            className: (0, _classnames2.default)((_cx = {}, _cx[prefix + 'selected'] = selected, _cx[className] = !!className, _cx)),
            onKeyDown: this.handleKeyDown,
            onClick: !disabled ? this.handleClick : this.props.onClick,
            needIndent: needIndent,
            'aria-selected': selected
        }, others);

        return _react2.default.createElement(
            _item2.default,
            newProps,
            this.renderSelectedIcon(selected),
            _react2.default.createElement(
                'span',
                { className: prefix + 'menu-item-text' },
                children
            ),
            helper ? _react2.default.createElement(
                'div',
                { className: prefix + 'menu-item-helper' },
                helper
            ) : null
        );
    };

    return SelectableItem;
}(_react.Component), _class.menuChildType = 'item', _class.propTypes = {
    _key: _propTypes2.default.string,
    root: _propTypes2.default.object,
    selected: _propTypes2.default.bool,
    onSelect: _propTypes2.default.func,
    inlineIndent: _propTypes2.default.number,
    /**
     * 是否禁用
     */
    disabled: _propTypes2.default.bool,
    /**
     * 帮助文本
     */
    helper: _propTypes2.default.node,
    /**
     * 菜单项标签内容
     */
    children: _propTypes2.default.node,
    className: _propTypes2.default.string,
    onKeyDown: _propTypes2.default.func,
    onClick: _propTypes2.default.func,
    needIndent: _propTypes2.default.bool,
    hasSelectedIcon: _propTypes2.default.bool
}, _class.defaultProps = {
    disabled: false,
    needIndent: true
}, _temp);
SelectableItem.displayName = 'SelectableItem';
exports.default = SelectableItem;
module.exports = exports['default'];

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Table.Column
 * @order 0
 **/
var Column = (_temp = _class = function (_React$Component) {
  _inherits(Column, _React$Component);

  function Column() {
    _classCallCheck(this, Column);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Column.prototype.render = function render() {
    return null;
  };

  return Column;
}(_react2.default.Component), _class.propTypes = {
  /**
   * 指定列对应的字段，支持`a.b`形式的快速取值
   */
  dataIndex: _propTypes2.default.string,
  /**
   * 行渲染的逻辑
   * value, rowIndex, record, context四个属性只可读不可被更改
   * Function(value, index, record) => Element
   */
  cell: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.node, _propTypes2.default.func]),
  /**
   * 表头显示的内容
   * value, rowIndex, record, context四个属性只可读不可被更改
   */
  title: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.node, _propTypes2.default.func]),
  /**
   * 是否支持排序
   */
  sortable: _propTypes2.default.bool,
  /**
   * 列宽，注意在锁列的情况下一定需要配置宽度
   */
  width: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
  /**
   * 单元格的对齐方式
   */
  align: _propTypes2.default.oneOf(['left', 'center', 'right']),
  /**
   * 生成标题过滤的菜单, 格式为`[{label:'xxx', value:'xxx'}]`
   */
  filters: _propTypes2.default.arrayOf(_propTypes2.default.shape({
    label: _propTypes2.default.string,
    value: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.string])
  })),
  /**
   * 过滤的模式是单选还是多选
   */
  filterMode: _propTypes2.default.oneOf(['single', 'multiple']),
  /**
   * 是否支持锁列,可选值为`left`,`right`, `true`
   */
  lock: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.string]),
  /**
   * 是否支持列宽调整, 当该值设为true，table的布局方式会修改为fixed.
   */
  resizable: _propTypes2.default.bool
}, _class.contextTypes = {
  parent: _propTypes2.default.any
}, _class.defaultProps = {
  cell: function cell(value) {
    return value;
  },
  filterMode: 'multiple',
  resizable: false
}, _class._typeMark = 'column', _temp);
Column.displayName = 'Column';
exports.default = Column;
module.exports = exports['default'];

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var FixedWrapper = (_temp = _class = function (_React$Component) {
    _inherits(FixedWrapper, _React$Component);

    function FixedWrapper() {
        _classCallCheck(this, FixedWrapper);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    FixedWrapper.prototype.render = function render() {
        var _props = this.props,
            children = _props.children,
            wrapperContent = _props.wrapperContent,
            prefix = _props.prefix;

        return _react2.default.createElement(
            'div',
            { className: prefix + 'table-inner' },
            children,
            wrapperContent
        );
    };

    return FixedWrapper;
}(_react2.default.Component), _class.propTypes = {
    children: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    colGroup: _propTypes2.default.any,
    wrapperContent: _propTypes2.default.any
}, _temp);
FixedWrapper.displayName = 'FixedWrapper';
exports.default = FixedWrapper;
module.exports = exports['default'];

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n.next-icon[dir=\"rtl\"]::before {\n  -webkit-transform: rotateY(180deg);\n          transform: rotateY(180deg); }\n\n@font-face {\n  font-family: NextIcon;\n  src: url(\"//at.alicdn.com/t/font_515771_emcns5054x3whfr.eot\");\n  src: url(\"//at.alicdn.com/t/font_515771_emcns5054x3whfr.eot?#iefix\") format(\"embedded-opentype\"), url(\"//at.alicdn.com/t/font_515771_emcns5054x3whfr.woff\") format(\"woff\"), url(\"//at.alicdn.com/t/font_515771_emcns5054x3whfr.ttf\") format(\"truetype\"), url(\"//at.alicdn.com/t/font_515771_emcns5054x3whfr.svg#NextIcon\") format(\"svg\"); }\n\n.next-icon {\n  display: inline-block;\n  font-family: NextIcon;\n  font-style: normal;\n  font-weight: normal;\n  text-transform: none;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale; }\n  .next-icon:before {\n    display: inline-block;\n    vertical-align: middle;\n    text-align: center; }\n  .next-icon-smile:before {\n    content: \"\\E65F\"; }\n  .next-icon-cry:before {\n    content: \"\\E65D\"; }\n  .next-icon-success:before {\n    content: \"\\E60A\"; }\n  .next-icon-warning:before {\n    content: \"\\E60B\"; }\n  .next-icon-prompt:before {\n    content: \"\\E60C\"; }\n  .next-icon-error:before {\n    content: \"\\E60D\"; }\n  .next-icon-help:before {\n    content: \"\\E673\"; }\n  .next-icon-clock:before {\n    content: \"\\E621\"; }\n  .next-icon-success-filling:before {\n    content: \"\\E63A\"; }\n  .next-icon-delete-filling:before {\n    content: \"\\E623\"; }\n  .next-icon-favorites-filling:before {\n    content: \"\\E60E\"; }\n  .next-icon-add:before {\n    content: \"\\E655\"; }\n  .next-icon-minus:before {\n    content: \"\\E601\"; }\n  .next-icon-arrow-up:before {\n    content: \"\\E625\"; }\n  .next-icon-arrow-down:before {\n    content: \"\\E63D\"; }\n  .next-icon-arrow-left:before {\n    content: \"\\E61D\"; }\n  .next-icon-arrow-right:before {\n    content: \"\\E619\"; }\n  .next-icon-arrow-double-left:before {\n    content: \"\\E659\"; }\n  .next-icon-arrow-double-right:before {\n    content: \"\\E65E\"; }\n  .next-icon-switch:before {\n    content: \"\\E6B3\"; }\n  .next-icon-sorting:before {\n    content: \"\\E634\"; }\n  .next-icon-descending:before {\n    content: \"\\E61F\"; }\n  .next-icon-ascending:before {\n    content: \"\\E61E\"; }\n  .next-icon-select:before {\n    content: \"\\E632\"; }\n  .next-icon-semi-select:before {\n    content: \"\\E633\"; }\n  .next-icon-search:before {\n    content: \"\\E656\"; }\n  .next-icon-close:before {\n    content: \"\\E626\"; }\n  .next-icon-ellipsis:before {\n    content: \"\\E654\"; }\n  .next-icon-picture:before {\n    content: \"\\E631\"; }\n  .next-icon-calendar:before {\n    content: \"\\E607\"; }\n  .next-icon-ashbin:before {\n    content: \"\\E639\"; }\n  .next-icon-upload:before {\n    content: \"\\E7EE\"; }\n  .next-icon-download:before {\n    content: \"\\E628\"; }\n  .next-icon-set:before {\n    content: \"\\E683\"; }\n  .next-icon-edit:before {\n    content: \"\\E63B\"; }\n  .next-icon-refresh:before {\n    content: \"\\E677\"; }\n  .next-icon-filter:before {\n    content: \"\\E627\"; }\n  .next-icon-attachment:before {\n    content: \"\\E665\"; }\n  .next-icon-account:before {\n    content: \"\\E608\"; }\n  .next-icon-email:before {\n    content: \"\\E605\"; }\n  .next-icon-atm:before {\n    content: \"\\E606\"; }\n  .next-icon-loading:before {\n    content: \"\\E646\";\n    -webkit-animation: loadingCircle 1s infinite linear;\n            animation: loadingCircle 1s infinite linear; }\n\n@-webkit-keyframes loadingCircle {\n  0% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n\n@keyframes loadingCircle {\n  0% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n\n.next-icon.next-xxs:before {\n  width: 8px;\n  font-size: 8px;\n  line-height: inherit; }\n\n@media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n  .next-icon.next-xxs {\n    -webkit-transform: scale(0.5);\n        -ms-transform: scale(0.5);\n            transform: scale(0.5);\n    margin-left: -4px;\n    margin-right: -4px; }\n    .next-icon.next-xxs:before {\n      width: 16px;\n      font-size: 16px; } }\n\n.next-icon.next-xs:before {\n  width: 12px;\n  font-size: 12px;\n  line-height: inherit; }\n\n.next-icon.next-small:before {\n  width: 16px;\n  font-size: 16px;\n  line-height: inherit; }\n\n.next-icon.next-medium:before {\n  width: 20px;\n  font-size: 20px;\n  line-height: inherit; }\n\n.next-icon.next-large:before {\n  width: 24px;\n  font-size: 24px;\n  line-height: inherit; }\n\n.next-icon.next-xl:before {\n  width: 32px;\n  font-size: 32px;\n  line-height: inherit; }\n\n.next-icon.next-xxl:before {\n  width: 48px;\n  font-size: 48px;\n  line-height: inherit; }\n\n.next-icon.next-xxxl:before {\n  width: 64px;\n  font-size: 64px;\n  line-height: inherit; }\n", ""]);

// exports


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@-webkit-keyframes fadeIn {\n  0% {\n    opacity: 0; }\n  100% {\n    opacity: 1; } }\n\n@keyframes fadeIn {\n  0% {\n    opacity: 0; }\n  100% {\n    opacity: 1; } }\n\n@-webkit-keyframes fadeInDown {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateY(-100px);\n    -ms-transform: translateY(-100px);\n    transform: translateY(-100px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); } }\n\n@keyframes fadeInDown {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateY(-100px);\n    -ms-transform: translateY(-100px);\n    transform: translateY(-100px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); } }\n\n@-webkit-keyframes fadeInLeft {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateX(-20px);\n    -ms-transform: translateX(-20px);\n    transform: translateX(-20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); } }\n\n@keyframes fadeInLeft {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateX(-20px);\n    -ms-transform: translateX(-20px);\n    transform: translateX(-20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); } }\n\n@-webkit-keyframes fadeInRight {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateX(20px);\n    -ms-transform: translateX(20px);\n    transform: translateX(20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); } }\n\n@keyframes fadeInRight {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateX(20px);\n    -ms-transform: translateX(20px);\n    transform: translateX(20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); } }\n\n@-webkit-keyframes fadeInUp {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateY(20px);\n    -ms-transform: translateY(20px);\n    transform: translateY(20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); } }\n\n@keyframes fadeInUp {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateY(20px);\n    -ms-transform: translateY(20px);\n    transform: translateY(20px); }\n  100% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); } }\n\n@-webkit-keyframes fadeOut {\n  0% {\n    opacity: 1; }\n  100% {\n    opacity: 0; } }\n\n@keyframes fadeOut {\n  0% {\n    opacity: 1; }\n  100% {\n    opacity: 0; } }\n\n@-webkit-keyframes fadeOutDown {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateY(20px);\n    -ms-transform: translateY(20px);\n    transform: translateY(20px); } }\n\n@keyframes fadeOutDown {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateY(20px);\n    -ms-transform: translateY(20px);\n    transform: translateY(20px); } }\n\n@-webkit-keyframes fadeOutLeft {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateX(-20px);\n    -ms-transform: translateX(-20px);\n    transform: translateX(-20px); } }\n\n@keyframes fadeOutLeft {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateX(-20px);\n    -ms-transform: translateX(-20px);\n    transform: translateX(-20px); } }\n\n@-webkit-keyframes fadeOutRight {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateX(20px);\n    -ms-transform: translateX(20px);\n    transform: translateX(20px); } }\n\n@keyframes fadeOutRight {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateX(20px);\n    -ms-transform: translateX(20px);\n    transform: translateX(20px); } }\n\n@-webkit-keyframes fadeOutUp {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateY(-100px);\n    -ms-transform: translateY(-100px);\n    transform: translateY(-100px); } }\n\n@keyframes fadeOutUp {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0); }\n  100% {\n    opacity: 0;\n    -webkit-transform: translateY(-100px);\n    -ms-transform: translateY(-100px);\n    transform: translateY(-100px); } }\n\n@-webkit-keyframes zoomIn {\n  0% {\n    opacity: 0;\n    -webkit-transform: scale3d(0.3, 0.3, 0.3);\n    -ms-transform: scale3d(0.3, 0.3, 0.3);\n    transform: scale3d(0.3, 0.3, 0.3); }\n  50% {\n    opacity: 1; } }\n\n@keyframes zoomIn {\n  0% {\n    opacity: 0;\n    -webkit-transform: scale3d(0.3, 0.3, 0.3);\n    -ms-transform: scale3d(0.3, 0.3, 0.3);\n    transform: scale3d(0.3, 0.3, 0.3); }\n  50% {\n    opacity: 1; } }\n\n@-webkit-keyframes zoomOut {\n  0% {\n    opacity: 1; }\n  50% {\n    opacity: 0;\n    -webkit-transform: scale3d(0.3, 0.3, 0.3);\n    -ms-transform: scale3d(0.3, 0.3, 0.3);\n    transform: scale3d(0.3, 0.3, 0.3); }\n  100% {\n    opacity: 0; } }\n\n@keyframes zoomOut {\n  0% {\n    opacity: 1; }\n  50% {\n    opacity: 0;\n    -webkit-transform: scale3d(0.3, 0.3, 0.3);\n    -ms-transform: scale3d(0.3, 0.3, 0.3);\n    transform: scale3d(0.3, 0.3, 0.3); }\n  100% {\n    opacity: 0; } }\n\n@-webkit-keyframes expandInDown {\n  0% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; }\n  100% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; } }\n\n@keyframes expandInDown {\n  0% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; }\n  100% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; } }\n\n@-webkit-keyframes expandInUp {\n  0% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; }\n  100% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; } }\n\n@keyframes expandInUp {\n  0% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; }\n  100% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; } }\n\n@-webkit-keyframes expandInWithFade {\n  0% {\n    opacity: 0; }\n  40% {\n    opacity: .1; }\n  50% {\n    opacity: .9; }\n  100% {\n    opacity: 1; } }\n\n@keyframes expandInWithFade {\n  0% {\n    opacity: 0; }\n  40% {\n    opacity: .1; }\n  50% {\n    opacity: .9; }\n  100% {\n    opacity: 1; } }\n\n@-webkit-keyframes expandOutUp {\n  0% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; }\n  100% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; } }\n\n@keyframes expandOutUp {\n  0% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; }\n  100% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left top 0;\n    -ms-transform-origin: left top 0;\n    transform-origin: left top 0; } }\n\n@-webkit-keyframes expandOutDown {\n  0% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; }\n  100% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; } }\n\n@keyframes expandOutDown {\n  0% {\n    opacity: 1;\n    -webkit-transform: scaleY(1);\n    -ms-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; }\n  100% {\n    opacity: 0;\n    -webkit-transform: scaleY(0.6);\n    -ms-transform: scaleY(0.6);\n    transform: scaleY(0.6);\n    -webkit-transform-origin: left bottom 0;\n    -ms-transform-origin: left bottom 0;\n    transform-origin: left bottom 0; } }\n\n@-webkit-keyframes expandOutWithFade {\n  0% {\n    opacity: 1; }\n  70% {\n    opacity: 0; }\n  100% {\n    opacity: 0; } }\n\n@keyframes expandOutWithFade {\n  0% {\n    opacity: 1; }\n  70% {\n    opacity: 0; }\n  100% {\n    opacity: 0; } }\n\n@-webkit-keyframes pulse {\n  from {\n    -webkit-transform: scale(1);\n    -ms-transform: scale(1);\n    transform: scale(1); }\n  20% {\n    -webkit-transform: scale(1.2);\n    -ms-transform: scale(1.2);\n    transform: scale(1.2); }\n  to {\n    -webkit-transform: scale(1);\n    -ms-transform: scale(1);\n    transform: scale(1); } }\n\n@keyframes pulse {\n  from {\n    -webkit-transform: scale(1);\n    -ms-transform: scale(1);\n    transform: scale(1); }\n  20% {\n    -webkit-transform: scale(1.2);\n    -ms-transform: scale(1.2);\n    transform: scale(1.2); }\n  to {\n    -webkit-transform: scale(1);\n    -ms-transform: scale(1);\n    transform: scale(1); } }\n\n.fadeIn {\n  -webkit-animation-name: fadeIn;\n  animation-name: fadeIn;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeInDown {\n  -webkit-animation-name: fadeInDown;\n  animation-name: fadeInDown;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeInLeft {\n  -webkit-animation-name: fadeInLeft;\n  animation-name: fadeInLeft;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeInRight {\n  -webkit-animation-name: fadeInRight;\n  animation-name: fadeInRight;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeInUp {\n  -webkit-animation-name: fadeInUp;\n  animation-name: fadeInUp;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeOut {\n  -webkit-animation-name: fadeOut;\n  animation-name: fadeOut;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeOutDown {\n  -webkit-animation-name: fadeOutDown;\n  animation-name: fadeOutDown;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeOutLeft {\n  -webkit-animation-name: fadeOutLeft;\n  animation-name: fadeOutLeft;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeOutRight {\n  -webkit-animation-name: fadeOutRight;\n  animation-name: fadeOutRight;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.fadeOutUp {\n  -webkit-animation-name: fadeOutUp;\n  animation-name: fadeOutUp;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.2s;\n  animation-duration: 0.2s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.zoomIn {\n  -webkit-animation-name: zoomIn;\n  animation-name: zoomIn;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.zoomOut {\n  -webkit-animation-name: zoomOut;\n  animation-name: zoomOut;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.expandInDown {\n  -webkit-animation-name: expandInDown;\n  animation-name: expandInDown;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.expandOutUp {\n  -webkit-animation-name: expandOutUp;\n  animation-name: expandOutUp;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.15s;\n  animation-duration: 0.15s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.expandInUp {\n  -webkit-animation-name: expandInUp;\n  animation-name: expandInUp;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.expandOutDown {\n  -webkit-animation-name: expandOutDown;\n  animation-name: expandOutDown;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.15s;\n  animation-duration: 0.15s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.pulse {\n  -webkit-animation-name: pulse;\n  animation-name: pulse;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-duration: 0.3s;\n  animation-duration: 0.3s;\n  -webkit-animation-delay: 0s;\n  animation-delay: 0s;\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  -webkit-backface-visibility: hidden;\n  backface-visibility: hidden; }\n\n.expand-enter {\n  overflow: hidden; }\n\n.expand-enter-active {\n  -webkit-transition: all .3s ease-out;\n  transition: all .3s ease-out; }\n  .expand-enter-active > * {\n    -webkit-animation-name: expandInWithFade;\n    animation-name: expandInWithFade;\n    -webkit-animation-iteration-count: 1;\n    animation-iteration-count: 1;\n    -webkit-animation-duration: 0.2s;\n    animation-duration: 0.2s;\n    -webkit-animation-delay: 0s;\n    animation-delay: 0s;\n    -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n    animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n    -webkit-animation-fill-mode: \"forwards\";\n    animation-fill-mode: \"forwards\";\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden; }\n\n.expand-leave {\n  overflow: hidden; }\n\n.expand-leave-active {\n  -webkit-transition: all .2s ease-out;\n  transition: all .2s ease-out; }\n  .expand-leave-active > * {\n    -webkit-animation-name: expandOutWithFade;\n    animation-name: expandOutWithFade;\n    -webkit-animation-iteration-count: 1;\n    animation-iteration-count: 1;\n    -webkit-animation-duration: 0.2s;\n    animation-duration: 0.2s;\n    -webkit-animation-delay: 0s;\n    animation-delay: 0s;\n    -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n    animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n    -webkit-animation-fill-mode: \"forwards\";\n    animation-fill-mode: \"forwards\";\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden; }\n", ""]);

// exports


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n/* stylelint-disable max-nesting-depth */\n.next-checkbox-wrapper {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box; }\n  .next-checkbox-wrapper *,\n  .next-checkbox-wrapper *:before,\n  .next-checkbox-wrapper *:after {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box; }\n  .next-checkbox-wrapper .next-checkbox {\n    display: inline-block;\n    position: relative;\n    line-height: 1;\n    vertical-align: middle; }\n  .next-checkbox-wrapper input[type=\"checkbox\"] {\n    opacity: 0;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 16px;\n    height: 16px;\n    margin: 0; }\n  .next-checkbox-wrapper .next-checkbox-inner {\n    display: block;\n    width: 16px;\n    height: 16px;\n    background: #FFFFFF;\n    border-radius: 3px;\n    border: 1px solid #C4C6CF;\n    -webkit-transition: ease all .3s 0s;\n    transition: ease all .3s 0s;\n    text-align: left;\n    /* 防止继承父级 */\n    -webkit-box-shadow: none;\n            box-shadow: none;\n    /* box-sizing: content-box; */ }\n    .next-checkbox-wrapper .next-checkbox-inner > .next-icon {\n      -webkit-transform: scale(0);\n          -ms-transform: scale(0);\n              transform: scale(0);\n      position: absolute;\n      top: 0;\n      opacity: 0;\n      line-height: 16px;\n      -webkit-transition: all 0.3s cubic-bezier(0.78, 0.14, 0.15, 0.86);\n      transition: all 0.3s cubic-bezier(0.78, 0.14, 0.15, 0.86);\n      color: #FFFFFF;\n      left: 4px;\n      margin-left: 0; }\n      .next-checkbox-wrapper .next-checkbox-inner > .next-icon:before {\n        width: 8px;\n        font-size: 8px;\n        line-height: inherit; }\n      @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n        .next-checkbox-wrapper .next-checkbox-inner > .next-icon {\n          -webkit-transform: scale(0.5);\n              -ms-transform: scale(0.5);\n                  transform: scale(0.5);\n          margin-left: -4px;\n          margin-right: -4px; }\n          .next-checkbox-wrapper .next-checkbox-inner > .next-icon:before {\n            width: 16px;\n            font-size: 16px; } }\n    .next-checkbox-wrapper .next-checkbox-inner > .next-icon::before {\n      vertical-align: top;\n      margin-top: 0; }\n  .next-checkbox-wrapper.checked .next-checkbox-inner {\n    border-color: transparent;\n    background-color: #5584FF; }\n    .next-checkbox-wrapper.checked .next-checkbox-inner:hover, .next-checkbox-wrapper.checked .next-checkbox-inner.hovered {\n      border-color: transparent; }\n    .next-checkbox-wrapper.checked .next-checkbox-inner > .next-icon {\n      opacity: 1;\n      -webkit-transform: scale(1);\n          -ms-transform: scale(1);\n              transform: scale(1);\n      margin-left: 0;\n      /* font-size < 12px的时候进行覆盖。 */ }\n      .next-checkbox-wrapper.checked .next-checkbox-inner > .next-icon:before {\n        width: 8px;\n        font-size: 8px;\n        line-height: inherit; }\n      @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n        .next-checkbox-wrapper.checked .next-checkbox-inner > .next-icon {\n          -webkit-transform: scale(0.5);\n              -ms-transform: scale(0.5);\n                  transform: scale(0.5);\n          margin-left: -4px;\n          margin-right: -4px; }\n          .next-checkbox-wrapper.checked .next-checkbox-inner > .next-icon:before {\n            width: 16px;\n            font-size: 16px; } }\n  .next-checkbox-wrapper.indeterminate .next-checkbox-inner {\n    border-color: transparent;\n    background-color: #5584FF; }\n    .next-checkbox-wrapper.indeterminate .next-checkbox-inner:hover, .next-checkbox-wrapper.indeterminate .next-checkbox-inner.hovered {\n      border-color: transparent; }\n    .next-checkbox-wrapper.indeterminate .next-checkbox-inner > .next-icon {\n      opacity: 1;\n      -webkit-transform: scale3d(1, 1, 1);\n              transform: scale3d(1, 1, 1);\n      margin-left: 0;\n      /* font-size < 12px的时候进行覆盖。 */ }\n      .next-checkbox-wrapper.indeterminate .next-checkbox-inner > .next-icon:before {\n        width: 8px;\n        font-size: 8px;\n        line-height: inherit; }\n      @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n        .next-checkbox-wrapper.indeterminate .next-checkbox-inner > .next-icon {\n          -webkit-transform: scale(0.5);\n              -ms-transform: scale(0.5);\n                  transform: scale(0.5);\n          margin-left: -4px;\n          margin-right: -4px; }\n          .next-checkbox-wrapper.indeterminate .next-checkbox-inner > .next-icon:before {\n            width: 16px;\n            font-size: 16px; } }\n  .next-checkbox-wrapper.disabled input[type=\"checkbox\"] {\n    cursor: not-allowed; }\n  .next-checkbox-wrapper.disabled .next-checkbox-inner {\n    border-color: #E6E7EB;\n    background: #F7F8FA; }\n  .next-checkbox-wrapper.disabled.checked .next-checkbox-inner:hover, .next-checkbox-wrapper.disabled.checked .next-checkbox-inner.hovered, .next-checkbox-wrapper.disabled.indeterminate .next-checkbox-inner:hover, .next-checkbox-wrapper.disabled.indeterminate .next-checkbox-inner.hovered {\n    border-color: #E6E7EB; }\n  .next-checkbox-wrapper.disabled.checked .next-checkbox-inner > .next-icon, .next-checkbox-wrapper.disabled.indeterminate .next-checkbox-inner > .next-icon {\n    color: #CCCCCC;\n    opacity: 1; }\n  .next-checkbox-wrapper:not(.disabled):hover .next-checkbox-inner, .next-checkbox-wrapper.hovered .next-checkbox-inner, .next-checkbox-wrapper.focused .next-checkbox-inner {\n    border-color: #5584FF;\n    background-color: #DEE8FF; }\n  .next-checkbox-wrapper.indeterminate:not(.disabled):hover .next-checkbox-inner, .next-checkbox-wrapper.indeterminate:not(.disabled).hovered .next-checkbox-inner, .next-checkbox-wrapper.indeterminate.focused .next-checkbox-inner, .next-checkbox-wrapper.checked:not(.disabled):hover .next-checkbox-inner, .next-checkbox-wrapper.checked:not(.disabled).hovered .next-checkbox-inner, .next-checkbox-wrapper.checked.focused .next-checkbox-inner {\n    border-color: transparent;\n    background-color: #3E71F7; }\n    .next-checkbox-wrapper.indeterminate:not(.disabled):hover .next-checkbox-inner > .next-icon, .next-checkbox-wrapper.indeterminate:not(.disabled).hovered .next-checkbox-inner > .next-icon, .next-checkbox-wrapper.indeterminate.focused .next-checkbox-inner > .next-icon, .next-checkbox-wrapper.checked:not(.disabled):hover .next-checkbox-inner > .next-icon, .next-checkbox-wrapper.checked:not(.disabled).hovered .next-checkbox-inner > .next-icon, .next-checkbox-wrapper.checked.focused .next-checkbox-inner > .next-icon {\n      color: #FFFFFF;\n      opacity: 1; }\n\n.next-checkbox-group .next-checkbox-wrapper {\n  margin-left: 8px; }\n  .next-checkbox-group .next-checkbox-wrapper:first-child {\n    margin-left: 0; }\n\n.next-checkbox-group-ver .next-checkbox-wrapper {\n  display: block;\n  margin-left: 0;\n  margin-bottom: 8px; }\n\n.next-checkbox-label {\n  font-size: 12px;\n  vertical-align: middle;\n  margin: 0;\n  margin-left: 4px;\n  line-height: 1; }\n", ""]);

// exports


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n.next-radio-button-large[dir='rtl'] > label:first-child {\n  margin-left: -1px;\n  border-top-right-radius: 3px;\n  border-bottom-right-radius: 3px;\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0; }\n\n.next-radio-button-large[dir='rtl'] > label:last-child {\n  margin-left: 0;\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  border-top-left-radius: 3px;\n  border-bottom-left-radius: 3px; }\n\n.next-radio-button-large[dir='rtl'] .next-radio-label {\n  height: 38px;\n  line-height: 38px;\n  font-size: 16px; }\n\n.next-radio-button-medium[dir='rtl'] > label:first-child {\n  margin-left: -1px;\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  border-top-right-radius: 3px;\n  border-bottom-right-radius: 3px; }\n\n.next-radio-button-medium[dir='rtl'] > label:last-child {\n  margin-left: 0;\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  border-top-left-radius: 3px;\n  border-bottom-left-radius: 3px; }\n\n.next-radio-button-small[dir='rtl'] > label:first-child {\n  margin-left: -1px;\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  border-top-right-radius: 3px;\n  border-bottom-right-radius: 3px; }\n\n.next-radio-button-small[dir='rtl'] > label:last-child {\n  margin-left: 0;\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  border-top-left-radius: 3px;\n  border-bottom-left-radius: 3px; }\n\n.next-radio-wrapper[dir='rtl'] .next-radio-label {\n  margin-left: 0;\n  margin-right: 4px; }\n\n.next-radio-group[dir='rtl'] .next-radio-label {\n  margin-right: 4px;\n  margin-left: 16px; }\n\n.next-radio-button[dir='rtl'] > label .next-radio-label {\n  margin: 0; }\n\n.next-radio-wrapper {\n  outline: 0; }\n  .next-radio-wrapper .next-radio {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box;\n    display: inline-block;\n    vertical-align: middle;\n    position: relative;\n    line-height: 1; }\n    .next-radio-wrapper .next-radio *,\n    .next-radio-wrapper .next-radio *:before,\n    .next-radio-wrapper .next-radio *:after {\n      -webkit-box-sizing: border-box;\n              box-sizing: border-box; }\n    .next-radio-wrapper .next-radio input[type=\"radio\"] {\n      opacity: 0;\n      position: absolute;\n      vertical-align: middle;\n      top: 0;\n      left: 0;\n      width: 16px;\n      height: 16px;\n      margin: 0; }\n  .next-radio-wrapper .next-radio-inner {\n    /* 动画待定 */\n    /* &.mouseDown { */\n    /*     transform: scale3d(.7, .7, .7); */\n    /*     transition: transform .2s linear; */\n    /* } */\n    /* &.mouseUp { */\n    /*     transform: scale3d(1, 1, 1); */\n    /*     transition: transform .2s linear; */\n    /* } */\n    display: block;\n    width: 16px;\n    height: 16px;\n    background: #FFFFFF;\n    border-radius: 50%;\n    border: 1px solid #C4C6CF;\n    -webkit-transition: ease all .36s 0s;\n    transition: ease all .36s 0s;\n    -webkit-box-shadow: none;\n            box-shadow: none; }\n    .next-radio-wrapper .next-radio-inner:after {\n      -webkit-transform: scale(0);\n          -ms-transform: scale(0);\n              transform: scale(0);\n      position: absolute;\n      border-radius: 50%;\n      top: 50%;\n      margin-top: -2px;\n      left: 50%;\n      margin-left: -2px;\n      background: #FFFFFF;\n      content: ' ';\n      -webkit-transition: all 0.3s cubic-bezier(0.78, 0.14, 0.15, 0.86);\n      transition: all 0.3s cubic-bezier(0.78, 0.14, 0.15, 0.86); }\n  .next-radio-wrapper.checked .next-radio-inner {\n    border-color: #5584FF;\n    background: #5584FF; }\n    .next-radio-wrapper.checked .next-radio-inner:after {\n      width: 4px;\n      height: 4px;\n      font-weight: bold;\n      background: #FFFFFF;\n      -webkit-transform: scale(1);\n          -ms-transform: scale(1);\n              transform: scale(1); }\n  .next-radio-wrapper.checked:hover .next-radio-inner, .next-radio-wrapper.checked.hovered .next-radio-inner {\n    border-color: transparent; }\n  .next-radio-wrapper.disabled input[type=\"radio\"] {\n    cursor: not-allowed; }\n  .next-radio-wrapper.disabled .next-radio-inner {\n    border-color: #E6E7EB;\n    background: #F7F8FA; }\n    .next-radio-wrapper.disabled .next-radio-inner:hover, .next-radio-wrapper.disabled .next-radio-inner.hovered {\n      border-color: #E6E7EB; }\n  .next-radio-wrapper.disabled.checked .next-radio-inner:after {\n    background: #CCCCCC; }\n  .next-radio-wrapper:not(.disabled):hover .next-radio-inner, .next-radio-wrapper:not(.disabled).hovered .next-radio-inner, .next-radio-wrapper:not(.disabled):focus .next-radio-inner, .next-radio-wrapper:not(.disabled).focused .next-radio-inner {\n    border-color: #5584FF;\n    background-color: #DEE8FF; }\n  .next-radio-wrapper.checked:not(.disabled):hover .next-radio-inner, .next-radio-wrapper.checked:not(.disabled).hovered .next-radio-inner, .next-radio-wrapper.checked:not(.disabled):focus .next-radio-inner, .next-radio-wrapper.checked.focused .next-radio-inner {\n    border-color: transparent;\n    background: #3E71F7; }\n    .next-radio-wrapper.checked:not(.disabled):hover .next-radio-inner:after, .next-radio-wrapper.checked:not(.disabled).hovered .next-radio-inner:after, .next-radio-wrapper.checked:not(.disabled):focus .next-radio-inner:after, .next-radio-wrapper.checked.focused .next-radio-inner:after {\n      background: #FFFFFF; }\n\n.next-radio-button .next-radio {\n  width: 0;\n  height: 0; }\n\n.next-radio-button input[type=\"radio\"] {\n  width: 0;\n  height: 0; }\n\n.next-radio-button > label {\n  display: inline-block;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  position: relative;\n  z-index: 1;\n  margin: 0 0 0 -1px;\n  border: 1px solid #C4C6CF;\n  background-color: #FFFFFF;\n  -webkit-transition: ease all .3s 0s;\n  transition: ease all .3s 0s; }\n  .next-radio-button > label .next-radio-label {\n    display: block;\n    color: #333333;\n    margin: 0;\n    -webkit-transition: ease all .3s 0s;\n    transition: ease all .3s 0s; }\n  .next-radio-button > label:hover, .next-radio-button > label:focus, .next-radio-button > label.hovered {\n    z-index: 10;\n    border-color: #A0A2AD;\n    background-color: #F2F3F7; }\n    .next-radio-button > label:hover .next-radio-label, .next-radio-button > label:focus .next-radio-label, .next-radio-button > label.hovered .next-radio-label {\n      color: #333333; }\n  .next-radio-button > label.checked {\n    z-index: 10;\n    border-color: #5584FF;\n    background-color: #FFFFFF; }\n    .next-radio-button > label.checked .next-radio-label {\n      color: #5584FF; }\n  .next-radio-button > label.disabled {\n    z-index: 0;\n    cursor: not-allowed;\n    border-color: #E6E7EB;\n    background-color: #F7F8FA; }\n    .next-radio-button > label.disabled .next-radio-label {\n      color: #CCCCCC; }\n  .next-radio-button > label.checked.disabled {\n    z-index: 0;\n    border-color: #E6E7EB;\n    background-color: #F2F3F7; }\n    .next-radio-button > label.checked.disabled .next-radio-label {\n      color: #CCCCCC; }\n\n.next-radio-button-large > label {\n  padding: 0 8px;\n  height: 40px;\n  line-height: 40px; }\n  .next-radio-button-large > label:first-child {\n    margin-left: 0;\n    border-top-left-radius: 3px;\n    border-bottom-left-radius: 3px; }\n  .next-radio-button-large > label:last-child {\n    border-top-right-radius: 3px;\n    border-bottom-right-radius: 3px; }\n\n.next-radio-button-large .next-radio-label {\n  height: 38px;\n  line-height: 38px;\n  font-size: 16px; }\n\n.next-radio-button-medium > label {\n  padding: 0 8px;\n  height: 28px;\n  line-height: 28px; }\n  .next-radio-button-medium > label:first-child {\n    margin-left: 0;\n    border-top-left-radius: 3px;\n    border-bottom-left-radius: 3px; }\n  .next-radio-button-medium > label:last-child {\n    border-top-right-radius: 3px;\n    border-bottom-right-radius: 3px; }\n\n.next-radio-button-medium .next-radio-label {\n  height: 26px;\n  line-height: 26px;\n  font-size: 12px; }\n\n.next-radio-button-small > label {\n  padding: 0 8px;\n  height: 20px;\n  line-height: 20px; }\n  .next-radio-button-small > label:first-child {\n    margin-left: 0;\n    border-top-left-radius: 3px;\n    border-bottom-left-radius: 3px; }\n  .next-radio-button-small > label:last-child {\n    border-top-right-radius: 3px;\n    border-bottom-right-radius: 3px; }\n\n.next-radio-button-small .next-radio-label {\n  height: 18px;\n  line-height: 18px;\n  font-size: 12px; }\n\n.next-radio-single-input input[type=\"radio\"] {\n  opacity: 0;\n  position: absolute;\n  top: 0;\n  left: 0;\n  margin: 0; }\n\n.next-radio-group {\n  display: inline-block; }\n  .next-radio-group .next-radio-label {\n    color: #333333;\n    margin-right: 16px; }\n  .next-radio-group.disabled .next-radio-label {\n    color: #CCCCCC; }\n\n.next-radio-group-ver .next-radio-wrapper {\n  display: block;\n  margin-bottom: 8px; }\n\n.next-radio-label {\n  margin: 0;\n  margin-left: 4px;\n  font-size: 12px;\n  vertical-align: middle;\n  line-height: 1; }\n\n@-moz-document url-prefix() {\n  .next-radio {\n    margin-top: -1px; }\n  @supports ((-webkit-animation: calc(0s)) or (animation: calc(0s))) {\n    /* firefox 57+ */\n    .next-radio {\n      margin-top: -3px; } } }\n", ""]);

// exports


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n.next-menu[dir=\"rtl\"] .next-menu-item-helper {\n  float: left; }\n\n.next-menu[dir=\"rtl\"] .next-menu-item .next-checkbox,\n.next-menu[dir=\"rtl\"] .next-menu-item .next-radio {\n  margin-left: 4px;\n  margin-right: 0; }\n\n.next-menu[dir=\"rtl\"] .next-menu-hoz-right {\n  float: right; }\n\n.next-menu[dir=\"rtl\"] .next-menu-icon-arrow.next-icon {\n  left: 10px;\n  right: auto; }\n\n.next-menu[dir=\"rtl\"] .next-menu-hoz-icon-arrow.next-icon {\n  left: 6px;\n  right: auto; }\n\n.next-menu[dir=\"rtl\"] .next-menu-icon-selected.next-icon {\n  margin-left: 0;\n  margin-right: -16px; }\n  .next-menu[dir=\"rtl\"] .next-menu-icon-selected.next-icon:before {\n    width: 12px;\n    font-size: 12px;\n    line-height: inherit; }\n\n.next-menu[dir=\"rtl\"] .next-menu-icon-arrow.next-icon {\n  left: 10px;\n  right: auto; }\n\n.next-menu {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  position: relative;\n  min-width: 100px;\n  padding: 8px 0;\n  margin: 0;\n  list-style: none;\n  border: 1px solid #DCDEE3;\n  border-radius: 3px;\n  -webkit-box-shadow: none;\n          box-shadow: none;\n  background: #FFFFFF;\n  line-height: 32px;\n  font-size: 12px;\n  /* &-popup-content.next-hide { */\n  /*     display: none; */\n  /* } */ }\n  .next-menu *,\n  .next-menu *:before,\n  .next-menu *:after {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box; }\n  .next-menu:focus,\n  .next-menu *:focus {\n    outline: 0; }\n  .next-menu-content {\n    position: relative;\n    padding: 0;\n    margin: 0;\n    list-style: none; }\n  .next-menu-sub-menu {\n    padding: 0;\n    margin: 0;\n    list-style: none; }\n    .next-menu-sub-menu.next-expand-enter {\n      overflow: hidden; }\n    .next-menu-sub-menu.next-expand-enter-active {\n      -webkit-transition: height .3s ease-out;\n      transition: height .3s ease-out; }\n    .next-menu-sub-menu.next-expand-leave {\n      overflow: hidden; }\n    .next-menu-sub-menu.next-expand-leave-active {\n      -webkit-transition: height .3s ease-out;\n      transition: height .3s ease-out; }\n  .next-menu-item {\n    position: relative;\n    padding: 0 20px;\n    -webkit-transition: background .2s ease;\n    transition: background .2s ease;\n    color: #333333;\n    cursor: pointer; }\n    .next-menu-item-helper {\n      float: right;\n      color: #999999;\n      font-style: normal;\n      font-size: 12px; }\n    .next-menu-item .next-checkbox,\n    .next-menu-item .next-radio {\n      margin-right: 4px; }\n    .next-menu-item.next-selected {\n      color: #333333;\n      background-color: #FFFFFF; }\n      .next-menu-item.next-selected .next-menu-icon-arrow {\n        color: #666666; }\n      .next-menu-item.next-selected .next-menu-icon-selected {\n        color: #5584FF; }\n    .next-menu-item.next-disabled,\n    .next-menu-item.next-disabled .next-menu-item-text > a {\n      color: #CCCCCC;\n      background-color: #FFFFFF;\n      cursor: not-allowed; }\n      .next-menu-item.next-disabled .next-menu-icon-arrow,\n      .next-menu-item.next-disabled .next-menu-item-text > a .next-menu-icon-arrow {\n        color: #CCCCCC; }\n      .next-menu-item.next-disabled .next-menu-icon-selected,\n      .next-menu-item.next-disabled .next-menu-item-text > a .next-menu-icon-selected {\n        color: #CCCCCC; }\n    .next-menu-item:not(.next-disabled):hover, .next-menu-item:not(.next-disabled).next-selected:hover, .next-menu-item:not(.next-disabled).next-selected.next-focused:hover, .next-menu-item:not(.next-disabled).next-selected:focus:hover, .next-menu-item:not(.next-disabled).next-focused, .next-menu-item:not(.next-disabled):focus, .next-menu-item:not(.next-disabled).next-selected.next-focused, .next-menu-item:not(.next-disabled).next-selected:focus {\n      color: #333333;\n      background-color: #F2F3F7; }\n      .next-menu-item:not(.next-disabled):hover .next-menu-icon-arrow, .next-menu-item:not(.next-disabled).next-selected:hover .next-menu-icon-arrow, .next-menu-item:not(.next-disabled).next-selected.next-focused:hover .next-menu-icon-arrow, .next-menu-item:not(.next-disabled).next-selected:focus:hover .next-menu-icon-arrow, .next-menu-item:not(.next-disabled).next-focused .next-menu-icon-arrow, .next-menu-item:not(.next-disabled):focus .next-menu-icon-arrow, .next-menu-item:not(.next-disabled).next-selected.next-focused .next-menu-icon-arrow, .next-menu-item:not(.next-disabled).next-selected:focus .next-menu-icon-arrow {\n        color: #333333; }\n      .next-menu-item:not(.next-disabled):hover .next-menu-icon-selected, .next-menu-item:not(.next-disabled).next-selected:hover .next-menu-icon-selected, .next-menu-item:not(.next-disabled).next-selected.next-focused:hover .next-menu-icon-selected, .next-menu-item:not(.next-disabled).next-selected:focus:hover .next-menu-icon-selected, .next-menu-item:not(.next-disabled).next-focused .next-menu-icon-selected, .next-menu-item:not(.next-disabled):focus .next-menu-icon-selected, .next-menu-item:not(.next-disabled).next-selected.next-focused .next-menu-icon-selected, .next-menu-item:not(.next-disabled).next-selected:focus .next-menu-icon-selected {\n        color: #5584FF; }\n  .next-menu-item-inner {\n    height: 32px;\n    font-size: 12px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    word-wrap: normal; }\n  .next-menu-item-text {\n    vertical-align: middle; }\n    .next-menu-item-text > a {\n      display: inline-block;\n      text-decoration: none;\n      color: #333333; }\n      .next-menu-item-text > a::before {\n        position: absolute;\n        background-color: transparent;\n        top: 0;\n        left: 0;\n        bottom: 0;\n        right: 0;\n        content: ''; }\n  .next-menu.next-hoz {\n    padding: 0; }\n    .next-menu.next-hoz > .next-menu-item,\n    .next-menu.next-hoz .next-menu-content > .next-menu-item {\n      display: inline-block;\n      vertical-align: top; }\n    .next-menu.next-hoz .next-menu-header,\n    .next-menu.next-hoz .next-menu-content,\n    .next-menu.next-hoz .next-menu-footer {\n      display: inline-block; }\n  .next-menu-hoz-right {\n    float: right; }\n  .next-menu-group-label {\n    padding: 0 12px;\n    color: #999999; }\n  .next-menu-divider {\n    margin: 8px 12px;\n    border-bottom: 1px solid #E6E7EB; }\n  .next-menu .next-menu-icon-selected.next-icon {\n    position: absolute;\n    top: 0;\n    margin-left: -16px; }\n    .next-menu .next-menu-icon-selected.next-icon:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-menu .next-menu-icon-arrow.next-icon {\n    position: absolute;\n    top: 0;\n    right: 10px;\n    color: #666666;\n    -webkit-transition: all ease .3s;\n    transition: all ease .3s; }\n    .next-menu .next-menu-icon-arrow.next-icon:before {\n      width: 8px;\n      font-size: 8px;\n      line-height: inherit; }\n    @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n      .next-menu .next-menu-icon-arrow.next-icon {\n        -webkit-transform: scale(0.5);\n            -ms-transform: scale(0.5);\n                transform: scale(0.5);\n        margin-left: -4px;\n        margin-right: -4px; }\n        .next-menu .next-menu-icon-arrow.next-icon:before {\n          width: 16px;\n          font-size: 16px; } }\n  .next-menu .next-menu-icon-arrow-down.next-open {\n    -webkit-transform: rotate(180deg);\n        -ms-transform: rotate(180deg);\n            transform: rotate(180deg); }\n    .next-menu .next-menu-icon-arrow-down.next-open:before {\n      width: 8px;\n      font-size: 8px;\n      line-height: inherit; }\n    @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n      .next-menu .next-menu-icon-arrow-down.next-open {\n        -webkit-transform: scale(0.5) rotate(180deg);\n            -ms-transform: scale(0.5) rotate(180deg);\n                transform: scale(0.5) rotate(180deg);\n        margin-left: -4px;\n        margin-right: -4px; }\n        .next-menu .next-menu-icon-arrow-down.next-open:before {\n          width: 16px;\n          font-size: 16px; } }\n  .next-menu .next-menu-icon-arrow-right.next-open {\n    -webkit-transform: rotate(-90deg);\n        -ms-transform: rotate(-90deg);\n            transform: rotate(-90deg); }\n    .next-menu .next-menu-icon-arrow-right.next-open:before {\n      width: 8px;\n      font-size: 8px;\n      line-height: inherit; }\n    @media all and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {\n      .next-menu .next-menu-icon-arrow-right.next-open {\n        -webkit-transform: scale(0.5) rotate(-90deg);\n            -ms-transform: scale(0.5) rotate(-90deg);\n                transform: scale(0.5) rotate(-90deg);\n        margin-left: -4px;\n        margin-right: -4px; }\n        .next-menu .next-menu-icon-arrow-right.next-open:before {\n          width: 16px;\n          font-size: 16px; } }\n  .next-menu .next-menu-hoz-icon-arrow.next-icon {\n    position: absolute;\n    top: 0;\n    right: 6px;\n    color: #666666;\n    -webkit-transition: all ease .3s;\n    transition: all ease .3s; }\n    .next-menu .next-menu-hoz-icon-arrow.next-icon:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-menu .next-menu-hoz-icon-arrow.next-open {\n    -webkit-transform: rotate(180deg);\n        -ms-transform: rotate(180deg);\n            transform: rotate(180deg); }\n    .next-menu .next-menu-hoz-icon-arrow.next-open:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-menu.next-context {\n    line-height: 24px; }\n    .next-menu.next-context .next-menu-item-inner {\n      height: 24px; }\n", ""]);

// exports


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n.next-btn {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box; }\n  .next-btn *,\n  .next-btn *:before,\n  .next-btn *:after {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box; }\n  .next-btn::-moz-focus-inner {\n    border: 0;\n    padding: 0; }\n  .next-btn, .next-btn:active, .next-btn:focus, .next-btn:hover {\n    outline: 0; }\n\n@-webkit-keyframes loadingCircle {\n  0% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n\n@keyframes loadingCircle {\n  0% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n\n.next-btn {\n  /* 尺寸维度 */\n  /* ---------------------------------------- */\n  /* 普通按钮 */\n  /* 普通态禁用样式 */\n  /* 警告按钮 */\n  /* 文本按钮 */\n  /* loading */\n  /* ---------------------------------------- */\n  /* 幽灵按钮 */\n  /* 组合 */\n  /* ---------------------------------------- */ }\n  .next-btn {\n    position: relative;\n    display: inline-block;\n    -webkit-box-shadow: none;\n            box-shadow: none;\n    text-decoration: none;\n    text-align: center;\n    text-transform: none;\n    white-space: nowrap;\n    vertical-align: middle;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n    -webkit-transition: all .3s ease-out;\n    transition: all .3s ease-out;\n    cursor: pointer; }\n    .next-btn:after {\n      text-align: center;\n      position: absolute;\n      opacity: 0;\n      visibility: hidden;\n      -webkit-transition: opacity .5s ease;\n      transition: opacity .5s ease; }\n    .next-btn .next-icon.next-xs:before {\n      vertical-align: baseline; }\n    .next-btn.hover, .next-btn:hover {\n      -webkit-box-shadow: none;\n              box-shadow: none; }\n  .next-btn.next-small {\n    border-radius: 3px;\n    padding: 0 8px;\n    height: 20px;\n    line-height: 18px;\n    font-size: 12px;\n    border-width: 1px; }\n    .next-btn.next-small > .next-btn-icon.next-icon-first {\n      margin-left: 0;\n      margin-right: 4px; }\n      .next-btn.next-small > .next-btn-icon.next-icon-first:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n    .next-btn.next-small > .next-btn-icon.next-icon-last {\n      margin-left: 4px;\n      margin-right: 0; }\n      .next-btn.next-small > .next-btn-icon.next-icon-last:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n    .next-btn.next-small > .next-btn-icon.next-icon-alone:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n    .next-btn.next-small.next-btn-loading {\n      padding-left: 24px; }\n      .next-btn.next-small.next-btn-loading:after {\n        width: 12px;\n        height: 12px;\n        font-size: 12px;\n        line-height: 12px;\n        left: 8px;\n        top: 50%;\n        text-align: center;\n        margin-top: -6px;\n        margin-right: 4px; }\n      .next-btn.next-small.next-btn-loading > .next-icon {\n        display: none; }\n  .next-btn.next-medium {\n    border-radius: 3px;\n    padding: 0 12px;\n    height: 28px;\n    line-height: 26px;\n    font-size: 12px;\n    border-width: 1px; }\n    .next-btn.next-medium > .next-btn-icon.next-icon-first {\n      margin-left: 0;\n      margin-right: 4px; }\n      .next-btn.next-medium > .next-btn-icon.next-icon-first:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n    .next-btn.next-medium > .next-btn-icon.next-icon-last {\n      margin-left: 4px;\n      margin-right: 0; }\n      .next-btn.next-medium > .next-btn-icon.next-icon-last:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n    .next-btn.next-medium > .next-btn-icon.next-icon-alone:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n    .next-btn.next-medium.next-btn-loading {\n      padding-left: 28px; }\n      .next-btn.next-medium.next-btn-loading:after {\n        width: 12px;\n        height: 12px;\n        font-size: 12px;\n        line-height: 12px;\n        left: 12px;\n        top: 50%;\n        text-align: center;\n        margin-top: -6px;\n        margin-right: 4px; }\n      .next-btn.next-medium.next-btn-loading > .next-icon {\n        display: none; }\n  .next-btn.next-large {\n    border-radius: 3px;\n    padding: 0 16px;\n    height: 40px;\n    line-height: 38px;\n    font-size: 16px;\n    border-width: 1px; }\n    .next-btn.next-large > .next-btn-icon.next-icon-first {\n      margin-left: 0;\n      margin-right: 4px; }\n      .next-btn.next-large > .next-btn-icon.next-icon-first:before {\n        width: 16px;\n        font-size: 16px;\n        line-height: inherit; }\n    .next-btn.next-large > .next-btn-icon.next-icon-last {\n      margin-left: 4px;\n      margin-right: 0; }\n      .next-btn.next-large > .next-btn-icon.next-icon-last:before {\n        width: 16px;\n        font-size: 16px;\n        line-height: inherit; }\n    .next-btn.next-large > .next-btn-icon.next-icon-alone:before {\n      width: 16px;\n      font-size: 16px;\n      line-height: inherit; }\n    .next-btn.next-large.next-btn-loading {\n      padding-left: 36px; }\n      .next-btn.next-large.next-btn-loading:after {\n        width: 16px;\n        height: 16px;\n        font-size: 16px;\n        line-height: 16px;\n        left: 16px;\n        top: 50%;\n        text-align: center;\n        margin-top: -8px;\n        margin-right: 4px; }\n      .next-btn.next-large.next-btn-loading > .next-icon {\n        display: none; }\n  .next-btn.next-btn-normal {\n    border-style: solid;\n    background-color: #FFFFFF;\n    border-color: #C4C6CF; }\n    .next-btn.next-btn-normal, .next-btn.next-btn-normal:link, .next-btn.next-btn-normal:visited, .next-btn.next-btn-normal.visited {\n      color: #333333; }\n    .next-btn.next-btn-normal:focus, .next-btn.next-btn-normal:hover, .next-btn.next-btn-normal.hover, .next-btn.next-btn-normal:active, .next-btn.next-btn-normal.active {\n      color: #333333;\n      background-color: #F2F3F7;\n      border-color: #A0A2AD;\n      text-decoration: none; }\n  .next-btn.next-btn-primary {\n    border-style: solid;\n    background-color: #5584FF;\n    border-color: transparent; }\n    .next-btn.next-btn-primary, .next-btn.next-btn-primary:link, .next-btn.next-btn-primary:visited, .next-btn.next-btn-primary.visited {\n      color: #FFFFFF; }\n    .next-btn.next-btn-primary:focus, .next-btn.next-btn-primary:hover, .next-btn.next-btn-primary.hover, .next-btn.next-btn-primary:active, .next-btn.next-btn-primary.active {\n      color: #FFFFFF;\n      background-color: #3E71F7;\n      border-color: transparent;\n      text-decoration: none; }\n  .next-btn.next-btn-secondary {\n    border-style: solid;\n    background-color: #FFFFFF;\n    border-color: #5584FF; }\n    .next-btn.next-btn-secondary, .next-btn.next-btn-secondary:link, .next-btn.next-btn-secondary:visited, .next-btn.next-btn-secondary.visited {\n      color: #5584FF; }\n    .next-btn.next-btn-secondary:focus, .next-btn.next-btn-secondary:hover, .next-btn.next-btn-secondary.hover, .next-btn.next-btn-secondary:active, .next-btn.next-btn-secondary.active {\n      color: #FFFFFF;\n      background-color: #3E71F7;\n      border-color: #3E71F7;\n      text-decoration: none; }\n  .next-btn.disabled, .next-btn[disabled] {\n    cursor: not-allowed;\n    background-color: #F7F8FA;\n    border-color: #E6E7EB; }\n    .next-btn.disabled, .next-btn.disabled:link, .next-btn.disabled:visited, .next-btn.disabled.visited, .next-btn[disabled], .next-btn[disabled]:link, .next-btn[disabled]:visited, .next-btn[disabled].visited {\n      color: #CCCCCC; }\n    .next-btn.disabled:focus, .next-btn.disabled:hover, .next-btn.disabled.hover, .next-btn.disabled:active, .next-btn.disabled.active, .next-btn[disabled]:focus, .next-btn[disabled]:hover, .next-btn[disabled].hover, .next-btn[disabled]:active, .next-btn[disabled].active {\n      color: #CCCCCC;\n      background-color: #F7F8FA;\n      border-color: #E6E7EB;\n      text-decoration: none; }\n  .next-btn-warning {\n    border-style: solid; }\n    .next-btn-warning.next-btn-primary {\n      background-color: #FF3000;\n      border-color: #FF3000; }\n      .next-btn-warning.next-btn-primary, .next-btn-warning.next-btn-primary:link, .next-btn-warning.next-btn-primary:visited, .next-btn-warning.next-btn-primary.visited {\n        color: #FFFFFF; }\n      .next-btn-warning.next-btn-primary:focus, .next-btn-warning.next-btn-primary:hover, .next-btn-warning.next-btn-primary.hover, .next-btn-warning.next-btn-primary:active, .next-btn-warning.next-btn-primary.active {\n        color: #FFFFFF;\n        background-color: #E72B00;\n        border-color: #E72B00;\n        text-decoration: none; }\n      .next-btn-warning.next-btn-primary.disabled, .next-btn-warning.next-btn-primary[disabled] {\n        background-color: #F7F8FA;\n        border-color: #DCDEE3; }\n        .next-btn-warning.next-btn-primary.disabled, .next-btn-warning.next-btn-primary.disabled:link, .next-btn-warning.next-btn-primary.disabled:visited, .next-btn-warning.next-btn-primary.disabled.visited, .next-btn-warning.next-btn-primary[disabled], .next-btn-warning.next-btn-primary[disabled]:link, .next-btn-warning.next-btn-primary[disabled]:visited, .next-btn-warning.next-btn-primary[disabled].visited {\n          color: #CCCCCC; }\n        .next-btn-warning.next-btn-primary.disabled:focus, .next-btn-warning.next-btn-primary.disabled:hover, .next-btn-warning.next-btn-primary.disabled.hover, .next-btn-warning.next-btn-primary.disabled:active, .next-btn-warning.next-btn-primary.disabled.active, .next-btn-warning.next-btn-primary[disabled]:focus, .next-btn-warning.next-btn-primary[disabled]:hover, .next-btn-warning.next-btn-primary[disabled].hover, .next-btn-warning.next-btn-primary[disabled]:active, .next-btn-warning.next-btn-primary[disabled].active {\n          color: #CCCCCC;\n          background-color: #F7F8FA;\n          border-color: #DCDEE3;\n          text-decoration: none; }\n    .next-btn-warning.next-btn-normal {\n      background-color: #FFFFFF;\n      border-color: #FF3000; }\n      .next-btn-warning.next-btn-normal, .next-btn-warning.next-btn-normal:link, .next-btn-warning.next-btn-normal:visited, .next-btn-warning.next-btn-normal.visited {\n        color: #FF3000; }\n      .next-btn-warning.next-btn-normal:focus, .next-btn-warning.next-btn-normal:hover, .next-btn-warning.next-btn-normal.hover, .next-btn-warning.next-btn-normal:active, .next-btn-warning.next-btn-normal.active {\n        color: #FFFFFF;\n        background-color: #E72B00;\n        border-color: #E72B00;\n        text-decoration: none; }\n      .next-btn-warning.next-btn-normal.disabled, .next-btn-warning.next-btn-normal[disabled] {\n        background-color: #F7F8FA;\n        border-color: #E6E7EB; }\n        .next-btn-warning.next-btn-normal.disabled, .next-btn-warning.next-btn-normal.disabled:link, .next-btn-warning.next-btn-normal.disabled:visited, .next-btn-warning.next-btn-normal.disabled.visited, .next-btn-warning.next-btn-normal[disabled], .next-btn-warning.next-btn-normal[disabled]:link, .next-btn-warning.next-btn-normal[disabled]:visited, .next-btn-warning.next-btn-normal[disabled].visited {\n          color: #CCCCCC; }\n        .next-btn-warning.next-btn-normal.disabled:focus, .next-btn-warning.next-btn-normal.disabled:hover, .next-btn-warning.next-btn-normal.disabled.hover, .next-btn-warning.next-btn-normal.disabled:active, .next-btn-warning.next-btn-normal.disabled.active, .next-btn-warning.next-btn-normal[disabled]:focus, .next-btn-warning.next-btn-normal[disabled]:hover, .next-btn-warning.next-btn-normal[disabled].hover, .next-btn-warning.next-btn-normal[disabled]:active, .next-btn-warning.next-btn-normal[disabled].active {\n          color: #CCCCCC;\n          background-color: #F7F8FA;\n          border-color: #E6E7EB;\n          text-decoration: none; }\n  .next-btn-text {\n    -webkit-box-shadow: none;\n            box-shadow: none;\n    border-radius: 0; }\n    .next-btn-text.hover, .next-btn-text:hover {\n      -webkit-box-shadow: none;\n              box-shadow: none; }\n    .next-btn-text.next-btn-primary {\n      background-color: transparent;\n      border-color: transparent; }\n      .next-btn-text.next-btn-primary, .next-btn-text.next-btn-primary:link, .next-btn-text.next-btn-primary:visited, .next-btn-text.next-btn-primary.visited {\n        color: #5584FF; }\n      .next-btn-text.next-btn-primary:focus, .next-btn-text.next-btn-primary:hover, .next-btn-text.next-btn-primary.hover, .next-btn-text.next-btn-primary:active, .next-btn-text.next-btn-primary.active {\n        color: #3E71F7;\n        background-color: transparent;\n        border-color: transparent;\n        text-decoration: none; }\n    .next-btn-text.next-btn-secondary {\n      background-color: transparent;\n      border-color: transparent; }\n      .next-btn-text.next-btn-secondary, .next-btn-text.next-btn-secondary:link, .next-btn-text.next-btn-secondary:visited, .next-btn-text.next-btn-secondary.visited {\n        color: #666666; }\n      .next-btn-text.next-btn-secondary:focus, .next-btn-text.next-btn-secondary:hover, .next-btn-text.next-btn-secondary.hover, .next-btn-text.next-btn-secondary:active, .next-btn-text.next-btn-secondary.active {\n        color: #5584FF;\n        background-color: transparent;\n        border-color: transparent;\n        text-decoration: none; }\n    .next-btn-text.next-btn-normal {\n      background-color: transparent;\n      border-color: transparent; }\n      .next-btn-text.next-btn-normal, .next-btn-text.next-btn-normal:link, .next-btn-text.next-btn-normal:visited, .next-btn-text.next-btn-normal.visited {\n        color: #333333; }\n      .next-btn-text.next-btn-normal:focus, .next-btn-text.next-btn-normal:hover, .next-btn-text.next-btn-normal.hover, .next-btn-text.next-btn-normal:active, .next-btn-text.next-btn-normal.active {\n        color: #5584FF;\n        background-color: transparent;\n        border-color: transparent;\n        text-decoration: none; }\n    .next-btn-text.next-large {\n      border-radius: 0;\n      padding: 0 0;\n      height: 24px;\n      line-height: 24px;\n      font-size: 14px;\n      border-width: 0; }\n      .next-btn-text.next-large > .next-btn-icon.next-icon-first {\n        margin-left: 0;\n        margin-right: 4px; }\n        .next-btn-text.next-large > .next-btn-icon.next-icon-first:before {\n          width: 16px;\n          font-size: 16px;\n          line-height: inherit; }\n      .next-btn-text.next-large > .next-btn-icon.next-icon-last {\n        margin-left: 4px;\n        margin-right: 0; }\n        .next-btn-text.next-large > .next-btn-icon.next-icon-last:before {\n          width: 16px;\n          font-size: 16px;\n          line-height: inherit; }\n      .next-btn-text.next-large > .next-btn-icon.next-icon-alone:before {\n        width: 16px;\n        font-size: 16px;\n        line-height: inherit; }\n      .next-btn-text.next-large.next-btn-loading {\n        padding-left: 20px; }\n        .next-btn-text.next-large.next-btn-loading:after {\n          width: 16px;\n          height: 16px;\n          font-size: 16px;\n          line-height: 16px;\n          left: 0;\n          top: 50%;\n          text-align: center;\n          margin-top: -8px;\n          margin-right: 4px; }\n        .next-btn-text.next-large.next-btn-loading > .next-icon {\n          display: none; }\n    .next-btn-text.next-medium {\n      border-radius: 0;\n      padding: 0 0;\n      height: 20px;\n      line-height: 20px;\n      font-size: 12px;\n      border-width: 0; }\n      .next-btn-text.next-medium > .next-btn-icon.next-icon-first {\n        margin-left: 0;\n        margin-right: 4px; }\n        .next-btn-text.next-medium > .next-btn-icon.next-icon-first:before {\n          width: 12px;\n          font-size: 12px;\n          line-height: inherit; }\n      .next-btn-text.next-medium > .next-btn-icon.next-icon-last {\n        margin-left: 4px;\n        margin-right: 0; }\n        .next-btn-text.next-medium > .next-btn-icon.next-icon-last:before {\n          width: 12px;\n          font-size: 12px;\n          line-height: inherit; }\n      .next-btn-text.next-medium > .next-btn-icon.next-icon-alone:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n      .next-btn-text.next-medium.next-btn-loading {\n        padding-left: 16px; }\n        .next-btn-text.next-medium.next-btn-loading:after {\n          width: 12px;\n          height: 12px;\n          font-size: 12px;\n          line-height: 12px;\n          left: 0;\n          top: 50%;\n          text-align: center;\n          margin-top: -6px;\n          margin-right: 4px; }\n        .next-btn-text.next-medium.next-btn-loading > .next-icon {\n          display: none; }\n    .next-btn-text.next-small {\n      border-radius: 0;\n      padding: 0 0;\n      height: 16px;\n      line-height: 16px;\n      font-size: 12px;\n      border-width: 0; }\n      .next-btn-text.next-small > .next-btn-icon.next-icon-first {\n        margin-left: 0;\n        margin-right: 4px; }\n        .next-btn-text.next-small > .next-btn-icon.next-icon-first:before {\n          width: 12px;\n          font-size: 12px;\n          line-height: inherit; }\n      .next-btn-text.next-small > .next-btn-icon.next-icon-last {\n        margin-left: 4px;\n        margin-right: 0; }\n        .next-btn-text.next-small > .next-btn-icon.next-icon-last:before {\n          width: 12px;\n          font-size: 12px;\n          line-height: inherit; }\n      .next-btn-text.next-small > .next-btn-icon.next-icon-alone:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n      .next-btn-text.next-small.next-btn-loading {\n        padding-left: 16px; }\n        .next-btn-text.next-small.next-btn-loading:after {\n          width: 12px;\n          height: 12px;\n          font-size: 12px;\n          line-height: 12px;\n          left: 0;\n          top: 50%;\n          text-align: center;\n          margin-top: -6px;\n          margin-right: 4px; }\n        .next-btn-text.next-small.next-btn-loading > .next-icon {\n          display: none; }\n    .next-btn-text.disabled, .next-btn-text[disabled] {\n      background-color: transparent;\n      border-color: transparent; }\n      .next-btn-text.disabled, .next-btn-text.disabled:link, .next-btn-text.disabled:visited, .next-btn-text.disabled.visited, .next-btn-text[disabled], .next-btn-text[disabled]:link, .next-btn-text[disabled]:visited, .next-btn-text[disabled].visited {\n        color: #CCCCCC; }\n      .next-btn-text.disabled:focus, .next-btn-text.disabled:hover, .next-btn-text.disabled.hover, .next-btn-text.disabled:active, .next-btn-text.disabled.active, .next-btn-text[disabled]:focus, .next-btn-text[disabled]:hover, .next-btn-text[disabled].hover, .next-btn-text[disabled]:active, .next-btn-text[disabled].active {\n        color: #CCCCCC;\n        background-color: transparent;\n        border-color: transparent;\n        text-decoration: none; }\n    .next-btn-text.next-btn-loading {\n      background-color: transparent;\n      border-color: transparent; }\n      .next-btn-text.next-btn-loading, .next-btn-text.next-btn-loading:link, .next-btn-text.next-btn-loading:visited, .next-btn-text.next-btn-loading.visited {\n        color: #333333; }\n      .next-btn-text.next-btn-loading:focus, .next-btn-text.next-btn-loading:hover, .next-btn-text.next-btn-loading.hover, .next-btn-text.next-btn-loading:active, .next-btn-text.next-btn-loading.active {\n        color: #333333;\n        background-color: transparent;\n        border-color: transparent;\n        text-decoration: none; }\n  .next-btn-loading {\n    pointer-events: none; }\n    .next-btn-loading:after {\n      font-family: NextIcon;\n      content: \"\\E646\";\n      opacity: 1;\n      visibility: visible;\n      -webkit-animation: loadingCircle 2s infinite linear;\n              animation: loadingCircle 2s infinite linear; }\n  .next-btn-ghost {\n    -webkit-box-shadow: none;\n            box-shadow: none;\n    border-style: solid; }\n    .next-btn-ghost.next-btn-dark {\n      background-color: transparent;\n      border-color: #FFFFFF; }\n      .next-btn-ghost.next-btn-dark, .next-btn-ghost.next-btn-dark:link, .next-btn-ghost.next-btn-dark:visited, .next-btn-ghost.next-btn-dark.visited {\n        color: #FFFFFF; }\n      .next-btn-ghost.next-btn-dark:focus, .next-btn-ghost.next-btn-dark:hover, .next-btn-ghost.next-btn-dark.hover, .next-btn-ghost.next-btn-dark:active, .next-btn-ghost.next-btn-dark.active {\n        color: #FFFFFF;\n        background-color: rgba(255, 255, 255, 0.8);\n        border-color: #FFFFFF;\n        text-decoration: none; }\n      .next-btn-ghost.next-btn-dark.disabled, .next-btn-ghost.next-btn-dark[disabled] {\n        background-color: transparent;\n        border-color: rgba(255, 255, 255, 0.4); }\n        .next-btn-ghost.next-btn-dark.disabled, .next-btn-ghost.next-btn-dark.disabled:link, .next-btn-ghost.next-btn-dark.disabled:visited, .next-btn-ghost.next-btn-dark.disabled.visited, .next-btn-ghost.next-btn-dark[disabled], .next-btn-ghost.next-btn-dark[disabled]:link, .next-btn-ghost.next-btn-dark[disabled]:visited, .next-btn-ghost.next-btn-dark[disabled].visited {\n          color: rgba(255, 255, 255, 0.4); }\n        .next-btn-ghost.next-btn-dark.disabled:focus, .next-btn-ghost.next-btn-dark.disabled:hover, .next-btn-ghost.next-btn-dark.disabled.hover, .next-btn-ghost.next-btn-dark.disabled:active, .next-btn-ghost.next-btn-dark.disabled.active, .next-btn-ghost.next-btn-dark[disabled]:focus, .next-btn-ghost.next-btn-dark[disabled]:hover, .next-btn-ghost.next-btn-dark[disabled].hover, .next-btn-ghost.next-btn-dark[disabled]:active, .next-btn-ghost.next-btn-dark[disabled].active {\n          color: rgba(255, 255, 255, 0.4);\n          background-color: transparent;\n          border-color: rgba(255, 255, 255, 0.4);\n          text-decoration: none; }\n    .next-btn-ghost.next-btn-light {\n      background-color: transparent;\n      border-color: #333333; }\n      .next-btn-ghost.next-btn-light, .next-btn-ghost.next-btn-light:link, .next-btn-ghost.next-btn-light:visited, .next-btn-ghost.next-btn-light.visited {\n        color: #333333; }\n      .next-btn-ghost.next-btn-light:focus, .next-btn-ghost.next-btn-light:hover, .next-btn-ghost.next-btn-light.hover, .next-btn-ghost.next-btn-light:active, .next-btn-ghost.next-btn-light.active {\n        color: #999999;\n        background-color: rgba(0, 0, 0, 0.92);\n        border-color: #333333;\n        text-decoration: none; }\n      .next-btn-ghost.next-btn-light.disabled, .next-btn-ghost.next-btn-light[disabled] {\n        background-color: transparent;\n        border-color: rgba(0, 0, 0, 0.1); }\n        .next-btn-ghost.next-btn-light.disabled, .next-btn-ghost.next-btn-light.disabled:link, .next-btn-ghost.next-btn-light.disabled:visited, .next-btn-ghost.next-btn-light.disabled.visited, .next-btn-ghost.next-btn-light[disabled], .next-btn-ghost.next-btn-light[disabled]:link, .next-btn-ghost.next-btn-light[disabled]:visited, .next-btn-ghost.next-btn-light[disabled].visited {\n          color: rgba(0, 0, 0, 0.1); }\n        .next-btn-ghost.next-btn-light.disabled:focus, .next-btn-ghost.next-btn-light.disabled:hover, .next-btn-ghost.next-btn-light.disabled.hover, .next-btn-ghost.next-btn-light.disabled:active, .next-btn-ghost.next-btn-light.disabled.active, .next-btn-ghost.next-btn-light[disabled]:focus, .next-btn-ghost.next-btn-light[disabled]:hover, .next-btn-ghost.next-btn-light[disabled].hover, .next-btn-ghost.next-btn-light[disabled]:active, .next-btn-ghost.next-btn-light[disabled].active {\n          color: rgba(0, 0, 0, 0.1);\n          background-color: transparent;\n          border-color: rgba(0, 0, 0, 0.1);\n          text-decoration: none; }\n  .next-btn-group {\n    position: relative;\n    display: inline-block;\n    vertical-align: middle; }\n    .next-btn-group > .next-btn {\n      position: relative;\n      float: left;\n      -webkit-box-shadow: none;\n              box-shadow: none; }\n      .next-btn-group > .next-btn:hover, .next-btn-group > .next-btn:focus, .next-btn-group > .next-btn:active, .next-btn-group > .next-btn.active {\n        z-index: 1; }\n      .next-btn-group > .next-btn.disabled, .next-btn-group > .next-btn[disabled] {\n        z-index: 0; }\n    .next-btn-group .next-btn.next-btn {\n      margin: 0 0 0 -1px; }\n    .next-btn-group .next-btn:not(:first-child):not(:last-child) {\n      border-radius: 0; }\n    .next-btn-group > .next-btn:first-child {\n      margin: 0; }\n    .next-btn-group > .next-btn:first-child:not(:last-child) {\n      border-bottom-right-radius: 0;\n      border-top-right-radius: 0; }\n    .next-btn-group > .next-btn:last-child:not(:first-child) {\n      border-bottom-left-radius: 0;\n      border-top-left-radius: 0; }\n    .next-btn-group > .next-btn-primary:not(:first-child) {\n      border-left-color: rgba(255, 255, 255, 0.2); }\n      .next-btn-group > .next-btn-primary:not(:first-child):hover {\n        border-left-color: transparent; }\n      .next-btn-group > .next-btn-primary:not(:first-child).disabled, .next-btn-group > .next-btn-primary:not(:first-child)[disabled] {\n        border-left-color: #E6E7EB; }\n\n/* 组合 */\n/* ---------------------------------------- */\n.next-btn-group[dir=\"rtl\"] > .next-btn {\n  float: right; }\n\n.next-btn-group[dir=\"rtl\"] .next-btn.next-btn {\n  margin: 0 -1px 0 0; }\n\n.next-btn-group[dir=\"rtl\"] > .next-btn:first-child:not(:last-child) {\n  border-bottom-left-radius: 0;\n  border-top-left-radius: 0; }\n\n.next-btn-group[dir=\"rtl\"] > .next-btn:last-child:not(:first-child) {\n  border-bottom-right-radius: 0;\n  border-top-right-radius: 0; }\n\n.next-btn-group[dir=\"rtl\"] > .next-btn-primary:not(:first-child) {\n  border-right-color: rgba(255, 255, 255, 0.2); }\n  .next-btn-group[dir=\"rtl\"] > .next-btn-primary:not(:first-child):hover {\n    border-right-color: transparent; }\n  .next-btn-group[dir=\"rtl\"] > .next-btn-primary:not(:first-child).disabled, .next-btn-group[dir=\"rtl\"] > .next-btn-primary:not(:first-child)[disabled] {\n    border-right-color: #E6E7EB; }\n\n/* 尺寸维度 */\n/* ---------------------------------------- */\n.next-btn.next-small[dir=\"rtl\"] {\n  border-radius: 3px; }\n  .next-btn.next-small[dir=\"rtl\"] > .next-btn-icon.next-icon-first {\n    margin-left: 4px;\n    margin-right: 0; }\n    .next-btn.next-small[dir=\"rtl\"] > .next-btn-icon.next-icon-first:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn.next-small[dir=\"rtl\"] > .next-btn-icon.next-icon-last {\n    margin-left: 0;\n    margin-right: 4px; }\n    .next-btn.next-small[dir=\"rtl\"] > .next-btn-icon.next-icon-last:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn.next-small[dir=\"rtl\"].next-btn-loading {\n    padding-left: 8px;\n    padding-right: 24px; }\n    .next-btn.next-small[dir=\"rtl\"].next-btn-loading:after {\n      right: 8px;\n      top: 50%;\n      margin-right: 0;\n      margin-left: 4px; }\n\n.next-btn.next-medium[dir=\"rtl\"] {\n  border-radius: 3px; }\n  .next-btn.next-medium[dir=\"rtl\"] > .next-btn-icon.next-icon-first {\n    margin-left: 4px;\n    margin-right: 0; }\n    .next-btn.next-medium[dir=\"rtl\"] > .next-btn-icon.next-icon-first:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn.next-medium[dir=\"rtl\"] > .next-btn-icon.next-icon-last {\n    margin-left: 0;\n    margin-right: 4px; }\n    .next-btn.next-medium[dir=\"rtl\"] > .next-btn-icon.next-icon-last:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn.next-medium[dir=\"rtl\"].next-btn-loading {\n    padding-left: 12px;\n    padding-right: 28px; }\n    .next-btn.next-medium[dir=\"rtl\"].next-btn-loading:after {\n      right: 12px;\n      top: 50%;\n      margin-right: 0;\n      margin-left: 4px; }\n\n.next-btn.next-large[dir=\"rtl\"] {\n  border-radius: 3px; }\n  .next-btn.next-large[dir=\"rtl\"] > .next-btn-icon.next-icon-first {\n    margin-left: 4px;\n    margin-right: 0; }\n    .next-btn.next-large[dir=\"rtl\"] > .next-btn-icon.next-icon-first:before {\n      width: 16px;\n      font-size: 16px;\n      line-height: inherit; }\n  .next-btn.next-large[dir=\"rtl\"] > .next-btn-icon.next-icon-last {\n    margin-left: 0;\n    margin-right: 4px; }\n    .next-btn.next-large[dir=\"rtl\"] > .next-btn-icon.next-icon-last:before {\n      width: 16px;\n      font-size: 16px;\n      line-height: inherit; }\n  .next-btn.next-large[dir=\"rtl\"].next-btn-loading {\n    padding-left: 16px;\n    padding-right: 36px; }\n    .next-btn.next-large[dir=\"rtl\"].next-btn-loading:after {\n      right: 16px;\n      top: 50%;\n      margin-right: 0;\n      margin-left: 4px; }\n\n/* 文本按钮 */\n.next-btn-text[dir=\"rtl\"].next-large {\n  border-radius: 0; }\n  .next-btn-text[dir=\"rtl\"].next-large > .next-btn-icon.next-icon-first {\n    margin-left: 4px;\n    margin-right: 0; }\n    .next-btn-text[dir=\"rtl\"].next-large > .next-btn-icon.next-icon-first:before {\n      width: 16px;\n      font-size: 16px;\n      line-height: inherit; }\n  .next-btn-text[dir=\"rtl\"].next-large > .next-btn-icon.next-icon-last {\n    margin-left: 0;\n    margin-right: 4px; }\n    .next-btn-text[dir=\"rtl\"].next-large > .next-btn-icon.next-icon-last:before {\n      width: 16px;\n      font-size: 16px;\n      line-height: inherit; }\n  .next-btn-text[dir=\"rtl\"].next-large.next-btn-loading {\n    padding-left: 0;\n    padding-right: 20px; }\n    .next-btn-text[dir=\"rtl\"].next-large.next-btn-loading:after {\n      right: 0;\n      top: 50%;\n      margin-right: 0;\n      margin-left: 4px; }\n\n.next-btn-text[dir=\"rtl\"].next-medium {\n  border-radius: 0; }\n  .next-btn-text[dir=\"rtl\"].next-medium > .next-btn-icon.next-icon-first {\n    margin-left: 4px;\n    margin-right: 0; }\n    .next-btn-text[dir=\"rtl\"].next-medium > .next-btn-icon.next-icon-first:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn-text[dir=\"rtl\"].next-medium > .next-btn-icon.next-icon-last {\n    margin-left: 0;\n    margin-right: 4px; }\n    .next-btn-text[dir=\"rtl\"].next-medium > .next-btn-icon.next-icon-last:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn-text[dir=\"rtl\"].next-medium.next-btn-loading {\n    padding-left: 0;\n    padding-right: 16px; }\n    .next-btn-text[dir=\"rtl\"].next-medium.next-btn-loading:after {\n      right: 0;\n      top: 50%;\n      margin-right: 0;\n      margin-left: 4px; }\n\n.next-btn-text[dir=\"rtl\"].next-small {\n  border-radius: 0; }\n  .next-btn-text[dir=\"rtl\"].next-small > .next-btn-icon.next-icon-first {\n    margin-left: 4px;\n    margin-right: 0; }\n    .next-btn-text[dir=\"rtl\"].next-small > .next-btn-icon.next-icon-first:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn-text[dir=\"rtl\"].next-small > .next-btn-icon.next-icon-last {\n    margin-left: 0;\n    margin-right: 4px; }\n    .next-btn-text[dir=\"rtl\"].next-small > .next-btn-icon.next-icon-last:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-btn-text[dir=\"rtl\"].next-small.next-btn-loading {\n    padding-left: 0;\n    padding-right: 16px; }\n    .next-btn-text[dir=\"rtl\"].next-small.next-btn-loading:after {\n      right: 0;\n      top: 50%;\n      margin-right: 0;\n      margin-left: 4px; }\n", ""]);

// exports


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n.next-overlay-wrapper .next-overlay-inner {\n  z-index: 1001; }\n\n.next-overlay-wrapper .next-overlay-backdrop {\n  position: fixed;\n  z-index: 1001;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: #000000;\n  -webkit-transition: opacity .3s;\n  transition: opacity .3s;\n  opacity: 0; }\n\n.next-overlay-wrapper.opened .next-overlay-backdrop {\n  opacity: 0.2; }\n", ""]);

// exports


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "", ""]);

// exports


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n/* put your code here */\n.next-loading {\n  position: relative;\n  display: inline-block;\n  /* 遮罩层 */\n  /* for IE9,10 */\n  /* text on the right side of */\n  /* 动效 */ }\n  .next-loading.next-open {\n    pointer-events: none; }\n  .next-loading .next-loading-component {\n    opacity: .7;\n    -webkit-filter: blur(1px);\n    filter: blur(1px);\n    -webkit-filter: \"progid:DXImageTransform.Microsoft.Blur(PixelRadius=1, MakeShadow=false)\";\n            filter: \"progid:DXImageTransform.Microsoft.Blur(PixelRadius=1, MakeShadow=false)\";\n    /* IE6~IE9 */\n    position: relative;\n    pointer-events: none; }\n  .next-loading-masker {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    z-index: 99;\n    opacity: .2;\n    background: #FFF; }\n  .next-loading-tip {\n    display: block;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    z-index: 4;\n    -webkit-transform: translate(-50%, -50%);\n        -ms-transform: translate(-50%, -50%);\n            transform: translate(-50%, -50%);\n    text-align: center; }\n  .next-loading-tip-placeholder {\n    display: none; }\n  .next-loading-right-tip .next-loading-indicator {\n    display: inline-block; }\n  .next-loading-right-tip .next-loading-tip-content {\n    position: absolute;\n    display: block;\n    top: 50%;\n    right: 0;\n    -webkit-transform: translate(0, -50%);\n        -ms-transform: translate(0, -50%);\n            transform: translate(0, -50%); }\n  .next-loading-right-tip .next-loading-tip-placeholder {\n    display: inline-block;\n    visibility: hidden;\n    margin-left: 1em; }\n  .next-loading-fusion-reactor {\n    display: inline-block;\n    width: 48px;\n    height: 48px;\n    position: relative;\n    margin: 0;\n    -webkit-animation-duration: 5.6s;\n    animation-duration: 5.6s;\n    -webkit-animation-iteration-count: infinite;\n    animation-iteration-count: infinite;\n    -webkit-animation-timing-function: linear;\n    animation-timing-function: linear;\n    -webkit-animation-name: nextVectorRoute;\n    animation-name: nextVectorRoute; }\n    .next-loading-fusion-reactor .next-loading-dot {\n      position: absolute;\n      margin: auto;\n      width: 12px;\n      height: 12px;\n      border-radius: 50%;\n      background: #5584FF;\n      -webkit-animation-timing-function: ease-in-out;\n      animation-timing-function: ease-in-out;\n      -webkit-animation-iteration-count: infinite;\n      animation-iteration-count: infinite;\n      -webkit-animation-duration: 1.4s;\n      animation-duration: 1.4s; }\n      .next-loading-fusion-reactor .next-loading-dot:nth-child(1) {\n        top: 0;\n        bottom: 0;\n        left: 0;\n        -webkit-animation-name: nextVectorDotsX;\n        animation-name: nextVectorDotsX; }\n      .next-loading-fusion-reactor .next-loading-dot:nth-child(2) {\n        left: 0;\n        right: 0;\n        top: 0;\n        opacity: .8;\n        -webkit-animation-name: nextVectorDotsY;\n        animation-name: nextVectorDotsY; }\n      .next-loading-fusion-reactor .next-loading-dot:nth-child(3) {\n        top: 0;\n        bottom: 0;\n        right: 0;\n        opacity: .6;\n        -webkit-animation-name: nextVectorDotsXR;\n        animation-name: nextVectorDotsXR; }\n      .next-loading-fusion-reactor .next-loading-dot:nth-child(4) {\n        left: 0;\n        right: 0;\n        bottom: 0;\n        opacity: .2;\n        -webkit-animation-name: nextVectorDotsYR;\n        animation-name: nextVectorDotsYR; }\n  .next-loading-medium-fusion-reactor {\n    width: 32px;\n    height: 32px; }\n    .next-loading-medium-fusion-reactor .next-loading-dot {\n      width: 8px;\n      height: 8px; }\n      .next-loading-medium-fusion-reactor .next-loading-dot:nth-child(1) {\n        -webkit-animation-name: nextVectorDotsX-medium;\n        animation-name: nextVectorDotsX-medium; }\n      .next-loading-medium-fusion-reactor .next-loading-dot:nth-child(2) {\n        -webkit-animation-name: nextVectorDotsY-medium;\n        animation-name: nextVectorDotsY-medium; }\n      .next-loading-medium-fusion-reactor .next-loading-dot:nth-child(3) {\n        -webkit-animation-name: nextVectorDotsXR-medium;\n        animation-name: nextVectorDotsXR-medium; }\n      .next-loading-medium-fusion-reactor .next-loading-dot:nth-child(4) {\n        -webkit-animation-name: nextVectorDotsYR-medium;\n        animation-name: nextVectorDotsYR-medium; }\n\n@-webkit-keyframes nextVectorRoute {\n  0% {\n    -webkit-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    transform: rotate(0deg); }\n  5% {\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    transform: rotate(90deg); }\n  25% {\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    transform: rotate(90deg); }\n  30% {\n    -webkit-transform: rotate(180deg);\n    -ms-transform: rotate(180deg);\n    transform: rotate(180deg); }\n  50% {\n    -webkit-transform: rotate(180deg);\n    -ms-transform: rotate(180deg);\n    transform: rotate(180deg); }\n  55% {\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    transform: rotate(270deg); }\n  75% {\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    transform: rotate(270deg); }\n  80% {\n    -webkit-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    transform: rotate(360deg); }\n  100% {\n    -webkit-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    transform: rotate(360deg); } }\n\n@keyframes nextVectorRoute {\n  0% {\n    -webkit-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    transform: rotate(0deg); }\n  5% {\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    transform: rotate(90deg); }\n  25% {\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    transform: rotate(90deg); }\n  30% {\n    -webkit-transform: rotate(180deg);\n    -ms-transform: rotate(180deg);\n    transform: rotate(180deg); }\n  50% {\n    -webkit-transform: rotate(180deg);\n    -ms-transform: rotate(180deg);\n    transform: rotate(180deg); }\n  55% {\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    transform: rotate(270deg); }\n  75% {\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    transform: rotate(270deg); }\n  80% {\n    -webkit-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    transform: rotate(360deg); }\n  100% {\n    -webkit-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    transform: rotate(360deg); } }\n\n/* 20% 的时间在旋转 */\n@-webkit-keyframes nextVectorDotsYR {\n  25% {\n    bottom: 0; }\n  45%,\n  50% {\n    bottom: 16.8px;\n    height: 14.4px;\n    width: 14.4px; }\n  90% {\n    bottom: 0;\n    height: 12px;\n    width: 12px; } }\n\n@keyframes nextVectorDotsYR {\n  25% {\n    bottom: 0; }\n  45%,\n  50% {\n    bottom: 16.8px;\n    height: 14.4px;\n    width: 14.4px; }\n  90% {\n    bottom: 0;\n    height: 12px;\n    width: 12px; } }\n\n@-webkit-keyframes nextVectorDotsY {\n  25% {\n    top: 0; }\n  45%,\n  50% {\n    top: 16.8px;\n    height: 14.4px;\n    width: 14.4px; }\n  90% {\n    top: 0;\n    height: 12px;\n    width: 12px; } }\n\n@keyframes nextVectorDotsY {\n  25% {\n    top: 0; }\n  45%,\n  50% {\n    top: 16.8px;\n    height: 14.4px;\n    width: 14.4px; }\n  90% {\n    top: 0;\n    height: 12px;\n    width: 12px; } }\n\n@-webkit-keyframes nextVectorDotsX {\n  25% {\n    left: 0; }\n  45%,\n  50% {\n    left: 16.8px;\n    width: 14.4px;\n    height: 14.4px; }\n  90% {\n    left: 0;\n    height: 12px;\n    width: 12px; } }\n\n@keyframes nextVectorDotsX {\n  25% {\n    left: 0; }\n  45%,\n  50% {\n    left: 16.8px;\n    width: 14.4px;\n    height: 14.4px; }\n  90% {\n    left: 0;\n    height: 12px;\n    width: 12px; } }\n\n@-webkit-keyframes nextVectorDotsXR {\n  25% {\n    right: 0; }\n  45%,\n  50% {\n    right: 16.8px;\n    width: 14.4px;\n    height: 14.4px; }\n  90% {\n    right: 0;\n    height: 12px;\n    width: 12px; } }\n\n@keyframes nextVectorDotsXR {\n  25% {\n    right: 0; }\n  45%,\n  50% {\n    right: 16.8px;\n    width: 14.4px;\n    height: 14.4px; }\n  90% {\n    right: 0;\n    height: 12px;\n    width: 12px; } }\n\n@-webkit-keyframes nextVectorDotsYR-medium {\n  25% {\n    bottom: 0; }\n  45%,\n  50% {\n    bottom: 11.2px;\n    height: 9.6px;\n    width: 9.6px; }\n  90% {\n    bottom: 0;\n    height: 8px;\n    width: 8px; } }\n\n@keyframes nextVectorDotsYR-medium {\n  25% {\n    bottom: 0; }\n  45%,\n  50% {\n    bottom: 11.2px;\n    height: 9.6px;\n    width: 9.6px; }\n  90% {\n    bottom: 0;\n    height: 8px;\n    width: 8px; } }\n\n@-webkit-keyframes nextVectorDotsY-medium {\n  25% {\n    top: 0; }\n  45%,\n  50% {\n    top: 11.2px;\n    height: 9.6px;\n    width: 9.6px; }\n  90% {\n    top: 0;\n    height: 8px;\n    width: 8px; } }\n\n@keyframes nextVectorDotsY-medium {\n  25% {\n    top: 0; }\n  45%,\n  50% {\n    top: 11.2px;\n    height: 9.6px;\n    width: 9.6px; }\n  90% {\n    top: 0;\n    height: 8px;\n    width: 8px; } }\n\n@-webkit-keyframes nextVectorDotsX-medium {\n  25% {\n    left: 0; }\n  45%,\n  50% {\n    left: 11.2px;\n    width: 9.6px;\n    height: 9.6px; }\n  90% {\n    left: 0;\n    height: 8px;\n    width: 8px; } }\n\n@keyframes nextVectorDotsX-medium {\n  25% {\n    left: 0; }\n  45%,\n  50% {\n    left: 11.2px;\n    width: 9.6px;\n    height: 9.6px; }\n  90% {\n    left: 0;\n    height: 8px;\n    width: 8px; } }\n\n@-webkit-keyframes nextVectorDotsXR-medium {\n  25% {\n    right: 0; }\n  45%,\n  50% {\n    right: 11.2px;\n    width: 9.6px;\n    height: 9.6px; }\n  90% {\n    right: 0;\n    height: 8px;\n    width: 8px; } }\n\n@keyframes nextVectorDotsXR-medium {\n  25% {\n    right: 0; }\n  45%,\n  50% {\n    right: 11.2px;\n    width: 9.6px;\n    height: 9.6px; }\n  90% {\n    right: 0;\n    height: 8px;\n    width: 8px; } }\n", ""]);

// exports


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n/**\n * 尺寸 基础尺寸\n * 命名能在语义的前提下简单就尽量简单, 这里可以是 size-2x, space-2x, size-base ...\n * 不过可以在语义的前提下做的更精简一些, 于是用了s2, s1等\n * 可用变量: `$s1 - $s8`\n * @example scss - 使用\n *   .element {\n *     padding: $s1 !default;\n *   }\n *\n * @example css - CSS 输出\n *   .element {\n *     padding: 4px !default;\n *   }\n */\n/* put your code here */\n.next-table {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  position: relative; }\n  .next-table *,\n  .next-table *:before,\n  .next-table *:after {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box; }\n  .next-table table {\n    border-collapse: collapse;\n    border-spacing: 0;\n    width: 100%;\n    background: #FFFFFF; }\n    .next-table table tr:first-child td {\n      border-top-width: 0; }\n  .next-table th {\n    padding: 0;\n    background: #EBECF0;\n    color: #333333;\n    text-align: left;\n    font-weight: normal;\n    border: 1px solid #DCDEE3; }\n    .next-table th .next-table-cell-wrapper {\n      padding: 12px 16px;\n      overflow: hidden;\n      text-overflow: ellipsis;\n      word-break: break-all; }\n  .next-table-affix {\n    z-index: 1; }\n  .next-table-header-resizable {\n    position: relative; }\n    .next-table-header-resizable .next-table-resize-handler {\n      position: absolute;\n      right: 0;\n      top: 0;\n      bottom: 0;\n      width: 3px;\n      background: transparent;\n      cursor: ew-resize; }\n  .next-table td {\n    padding: 0;\n    border: 1px solid #DCDEE3; }\n    .next-table td .next-table-cell-wrapper {\n      padding: 12px 16px;\n      overflow: hidden;\n      text-overflow: ellipsis;\n      word-break: break-all; }\n      .next-table td .next-table-cell-wrapper .next-icon-arrow-down.next-table-tree-arrow,\n      .next-table td .next-table-cell-wrapper .next-icon-arrow-right.next-table-tree-arrow,\n      .next-table td .next-table-cell-wrapper .next-table-tree-placeholder {\n        margin-right: 3px;\n        float: left; }\n      .next-table td .next-table-cell-wrapper .next-icon-arrow-down.next-table-tree-arrow:before,\n      .next-table td .next-table-cell-wrapper .next-icon-arrow-right.next-table-tree-arrow:before {\n        width: 12px;\n        font-size: 12px;\n        line-height: inherit; }\n  .next-table .next-table-expanded .next-table-cell-wrapper,\n  .next-table .next-table-selection .next-table-cell-wrapper {\n    overflow: visible; }\n  .next-table.no-header table tr:first-child td {\n    border-top-width: 1px; }\n  .next-table.only-bottom-border {\n    border-width: 0; }\n    .next-table.only-bottom-border th {\n      border-width: 0 0 1px 0; }\n    .next-table.only-bottom-border td {\n      border-width: 0 0 1px 0; }\n    .next-table.only-bottom-border .next-table-expanded-row th {\n      border-width: 0 0 1px 0; }\n    .next-table.only-bottom-border .next-table-expanded-row td {\n      border-width: 0 0 1px 0; }\n  .next-table-loading {\n    display: block; }\n  .next-table.zebra tr:nth-child(odd) td {\n    background: #FFFFFF; }\n  .next-table.zebra tr:nth-child(even) td {\n    background: #F7F8FA; }\n  .next-table.zebra .next-table-row.hovered td {\n    background: #F2F3F7;\n    color: #333333; }\n  .next-table.zebra .next-table-row.selected td {\n    background: #F2F3F7;\n    color: #333333; }\n  .next-table-empty {\n    color: #A0A2AD;\n    padding: 32px 0;\n    text-align: center; }\n  .next-table-expanded-row td {\n    border-width: 0; }\n    .next-table-expanded-row td:first-child {\n      border-left-width: 1px; }\n    .next-table-expanded-row td:last-child {\n      border-right-width: 1px; }\n  .next-table-expanded-row:last-child td {\n    border-bottom-width: 1px; }\n  .next-table-expanded-row .next-table .last td {\n    border-bottom-width: 0; }\n  .next-table-filter-footer {\n    margin: 10px 10px 0; }\n    .next-table-filter-footer button {\n      margin-right: 5px; }\n  .next-table-row {\n    -webkit-transition: all ease .3s;\n    transition: all ease .3s;\n    background: #FFFFFF;\n    color: #333333; }\n    .next-table-row.hidden {\n      display: none; }\n    .next-table-row.hovered {\n      background: #F2F3F7;\n      color: #333333; }\n    .next-table-row.selected {\n      background: #F2F3F7;\n      color: #333333; }\n  .next-table-tree-placeholder {\n    display: inline-block;\n    width: 12px; }\n\n.last .next-table-expanded-row td {\n  border-bottom-width: 1px; }\n\n.next-table-body,\n.next-table-header {\n  overflow: auto;\n  font-size: 12px; }\n\n.next-table-body {\n  font-size: 12px; }\n\n.next-table-fixed {\n  border: 1px solid #DCDEE3; }\n  .next-table-fixed table {\n    table-layout: fixed; }\n  .next-table-fixed .next-table-header {\n    background: #EBECF0; }\n  .next-table-fixed table tr td:first-child,\n  .next-table-fixed table tr th:first-child {\n    border-left-width: 0; }\n  .next-table-fixed .next-table-header th {\n    border-top-width: 0; }\n  .next-table-fixed .next-table-header tr th:last-child {\n    border-right-width: 0; }\n  .next-table-fixed .next-table-body td {\n    border-top-width: 0; }\n  .next-table-fixed .next-table-body tr:last-child td {\n    border-bottom-width: 0; }\n  .next-table-fixed .next-table-body tr td:last-child {\n    border-right-width: 0; }\n  .next-table-fixed.next-table-group table tr td:first-child,\n  .next-table-fixed.next-table-group table tr th:first-child {\n    border-left-width: 1px; }\n  .next-table-fixed.next-table-group .next-table-header th {\n    border-top-width: 1px; }\n  .next-table-fixed.next-table-group .next-table-header tr th:last-child {\n    border-right-width: 1px; }\n  .next-table-fixed.next-table-group .next-table-body td {\n    border-top-width: 1px; }\n  .next-table-fixed.next-table-group .next-table-body tr:last-child td {\n    border-bottom-width: 1px; }\n  .next-table-fixed.next-table-group .next-table-body tr td:last-child {\n    border-right-width: 1px; }\n\n.next-table-lock .next-table-body {\n  overflow-x: auto;\n  overflow-y: visible; }\n\n.next-table-group {\n  border-width: 0; }\n  .next-table-group .next-table-body {\n    margin-top: 8px; }\n    .next-table-group .next-table-body table {\n      margin-bottom: 8px; }\n      .next-table-group .next-table-body table tr:first-child td {\n        border-top-width: 1px; }\n  .next-table-group .next-table-group-header td {\n    background: #EBECF0;\n    color: #333333; }\n  .next-table-group .next-table-group-footer td {\n    background: #EBECF0;\n    color: #333333; }\n  .next-table-group .next-table-row.hovered,\n  .next-table-group .next-table-row.selected {\n    background: #FFFFFF;\n    color: #333333; }\n\n.next-table-lock {\n  position: relative; }\n  .next-table-lock table {\n    table-layout: fixed; }\n\n.next-table-header-inner {\n  overflow: hidden; }\n\n.next-table-lock-left,\n.next-table-lock-right {\n  position: absolute;\n  left: 0;\n  top: 0;\n  z-index: 1;\n  border: 0; }\n  .next-table-lock-left table,\n  .next-table-lock-right table {\n    width: auto; }\n  .next-table-lock-left .next-table-body,\n  .next-table-lock-right .next-table-body {\n    overflow: hidden; }\n\n.next-table-lock-right {\n  right: 0;\n  left: auto; }\n  .next-table-lock-right table tr td:first-child,\n  .next-table-lock-right table tr th:first-child {\n    border-left-width: 1px; }\n  .next-table-lock-right.shadow {\n    -webkit-box-shadow: -2px 0 3px rgba(0, 0, 0, 0.12);\n            box-shadow: -2px 0 3px rgba(0, 0, 0, 0.12); }\n\n.next-table-lock-left.shadow {\n  -webkit-box-shadow: 2px 0 3px rgba(0, 0, 0, 0.12);\n          box-shadow: 2px 0 3px rgba(0, 0, 0, 0.12); }\n\n.next-table-filter {\n  line-height: 1; }\n\n.next-table-sort {\n  position: relative;\n  width: 16px;\n  height: 15px;\n  display: inline-block;\n  vertical-align: middle;\n  line-height: 1; }\n  .next-table-sort .next-icon {\n    position: absolute;\n    left: 0;\n    color: #333333; }\n    .next-table-sort .next-icon:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n  .next-table-sort .current .next-icon {\n    color: #5584FF; }\n  .next-table-sort .next-icon-ascending {\n    left: 4px; }\n\n.next-table-filter {\n  margin-left: 5px;\n  cursor: pointer;\n  width: 20px;\n  display: inline-block; }\n  .next-table-filter .next-icon {\n    color: #333333; }\n    .next-table-filter .next-icon:before {\n      width: 12px;\n      font-size: 12px;\n      line-height: inherit; }\n\n.next-table-expanded-ctrl.disabled {\n  color: #999999; }\n\n.next-table-expanded-ctrl .next-icon:before {\n  width: 12px;\n  font-size: 12px;\n  line-height: inherit; }\n", ""]);

// exports


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = {
    momentLocale: 'zh-cn',
    Timeline: {
        expand: '展开',
        fold: '收起'
    },
    Card: {
        expand: '展开',
        fold: '收起'
    },
    Calendar: {
        today: '今天',
        now: '此刻',
        ok: '确定',
        clear: '清除',
        month: '月',
        year: '年',
        prevYear: '上一年',
        nextYear: '下一年',
        prevMonth: '上个月',
        nextMonth: '下个月',
        prevDecade: '上十年',
        nextDecade: '后十年'
    },
    DatePicker: {
        placeholder: '请选择日期',
        datetimePlaceholder: '请选择日期和时间',
        monthPlaceholder: '请选择月',
        yearPlaceholder: '请选择年',
        now: '此刻',
        selectTime: '选择时间',
        selectDate: '选择日期',
        ok: '确定',
        clear: '清除',
        startPlaceholder: '起始日期',
        endPlaceholder: '结束日期',
        hour: '时',
        minute: '分',
        second: '秒'
    },
    Dialog: {
        ok: '确认',
        cancel: '取消'
    },
    Pagination: {
        prev: '上一页',
        next: '下一页',
        goTo: '到第',
        page: '页',
        go: '确定',
        pageSize: '每页显示：'
    },
    Input: {
        clear: '清除'
    },
    Select: {
        selectPlaceholder: '请选择',
        autoCompletePlaceholder: '请输入',
        notFoundContent: '无选项'
    },
    Table: {
        empty: '没有数据',
        ok: '确认',
        reset: '重置',
        asc: '升序',
        desc: '降序',
        expanded: '已展开',
        folded: '已折叠',
        filter: '筛选',
        selectAll: '全选'
    },
    TimePicker: {
        placeholder: '请选择时间',
        clear: '清除',
        hour: '时',
        minute: '分',
        second: '秒'
    },
    Transfer: {
        items: '项',
        item: '项',
        moveAll: '移动全部',
        searchPlaceholder: '请输入'
    },
    Upload: {
        card: {
            cancel: '取消',
            addPhoto: '上传图片'
        },
        drag: {
            text: '点击或者拖动文件到虚线框内上传',
            hint: '支持 docx, xls, PDF, rar, zip, PNG, JPG 等类型的文件'
        }
    },
    Search: {
        buttonText: '搜索'
    }
};
module.exports = exports['default'];

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(12);

__webpack_require__(150);

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _checkbox = __webpack_require__(59);

var _checkbox2 = _interopRequireDefault(_checkbox);

var _checkboxGroup = __webpack_require__(112);

var _checkboxGroup2 = _interopRequireDefault(_checkboxGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_checkbox2.default.Group = _checkboxGroup2.default;

exports.default = _checkbox2.default;
module.exports = exports['default'];

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(11);

__webpack_require__(12);

__webpack_require__(145);

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = getContextProps;
function getContextProps(props, context, displayName) {
    var prefix = props.prefix,
        locale = props.locale,
        pure = props.pure,
        rtl = props.rtl;
    var nextPrefix = context.nextPrefix,
        nextLocale = context.nextLocale,
        nextPure = context.nextPure,
        nextWarning = context.nextWarning,
        nextRtl = context.nextRtl;


    var newPrefix = prefix || nextPrefix;

    var localeFromContext = void 0;
    if (nextLocale) {
        localeFromContext = nextLocale[displayName];
        if (localeFromContext) {
            localeFromContext.momentLocale = nextLocale.momentLocale;
        }
    }
    var newLocale = void 0;
    if (locale) {
        newLocale = _extends({}, localeFromContext || {}, locale);
    } else if (localeFromContext) {
        newLocale = localeFromContext;
    }

    var newPure = typeof pure === 'boolean' ? pure : nextPure;
    var newRtl = typeof rtl === 'boolean' ? rtl : nextRtl;

    return {
        prefix: newPrefix,
        locale: newLocale,
        pure: newPure,
        rtl: newRtl,
        warning: nextWarning
    };
}
module.exports = exports['default'];

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.matches = exports.hasDOM = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.hasClass = hasClass;
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.toggleClass = toggleClass;
exports.getStyle = getStyle;
exports.setStyle = setStyle;
exports.scrollbar = scrollbar;
exports.getOffset = getOffset;

var _string = __webpack_require__(41);

var _object = __webpack_require__(13);

/**
 * 是否能使用 DOM 方法
 * @type {Boolean}
 */
var hasDOM = exports.hasDOM = typeof window !== 'undefined' && !!window.document && !!document.createElement;

/**
 * 节点是否包含指定 className
 * @param  {Element}  node
 * @param  {String}  className
 * @return {Boolean}
 *
 * @example
 * dom.hasClass(document.body, 'foo');
 */
function hasClass(node, className) {
    /* istanbul ignore if */
    if (!hasDOM || !node) {
        return false;
    }

    if (node.classList) {
        return node.classList.contains(className);
    } else {
        return node.className.indexOf(className) > -1;
    }
}

/**
 * 添加 className
 * @param {Element} node
 * @param {String} className
 *
 * @example
 * dom.addClass(document.body, 'foo');
 */
function addClass(node, className, _force) {
    /* istanbul ignore if */
    if (!hasDOM || !node) {
        return;
    }

    if (node.classList) {
        node.classList.add(className);
    } else if (_force === true || !hasClass(node, className)) {
        node.className += ' ' + className;
    }
}

/**
 * 移除 className
 * @param  {Element} node
 * @param  {String} className
 *
 * @example
 * dom.removeClass(document.body, 'foo');
 */
function removeClass(node, className, _force) {
    /* istanbul ignore if */
    if (!hasDOM || !node) {
        return;
    }

    if (node.classList) {
        node.classList.remove(className);
    } else if (_force === true || hasClass(node, className)) {
        node.className = node.className.replace(className, '').replace(/\s+/g, ' ').trim();
    }
}

/**
 * 切换 className
 * @param  {Element} node
 * @param  {String} className
 * @return {Boolean}           执行后节点上是否还有此 className
 *
 * @example
 * dom.toggleClass(document.body, 'foo');
 */
function toggleClass(node, className) {
    /* istanbul ignore if */
    if (!hasDOM || !node) {
        return false;
    }

    if (node.classList) {
        return node.classList.toggle(className);
    } else {
        var flag = hasClass(node, className);
        flag ? removeClass(node, className, true) : addClass(node, className, true);

        return !flag;
    }
}

/**
 * 元素是否匹配 CSS 选择器
 * @param  {Element} node       DOM 节点
 * @param  {String}  selector   CSS 选择器
 * @return {Boolean}
 *
 * @example
 * dom.matches(mountNode, '.container'); // boolean
 */
var matches = exports.matches = function () {
    var matchesFn = null;
    /* istanbul ignore else */
    if (hasDOM) {
        var _body = document.body || document.head;
        matchesFn = _body.matches ? 'matches' : _body.webkitMatchesSelector ? 'webkitMatchesSelector' : _body.msMatchesSelector ? 'msMatchesSelector' : _body.mozMatchesSelector ? 'mozMatchesSelector' : null;
    }

    return function (node, selector) {
        if (!hasDOM || !node) {
            return false;
        }

        return matchesFn ? node[matchesFn](selector) : false;
    };
}();

/**
 * 获取元素计算后的样式
 * @private
 * @param  {Element} node
 * @return {Object}
 */
function _getComputedStyle(node) {
    return node && node.nodeType === 1 ? window.getComputedStyle(node, null) : {};
}

var PIXEL_PATTERN = /margin|padding|width|height|max|min|offset|size/i;
var removePixel = { left: 1, top: 1, right: 1, bottom: 1 };

/**
 * 校验并修正元素的样式属性值
 * @private
 * @param  {Element} node
 * @param  {String} type
 * @param  {Number} value
 */
function _getStyleValue(node, type, value) {
    type = type.toLowerCase();

    if (value === 'auto') {
        if (type === 'height') {
            return node.offsetHeight || 0;
        }
        if (type === 'width') {
            return node.offsetWidth || 0;
        }
    }

    if (!(type in removePixel)) {
        // 属性值是否需要去掉 px 单位，这里假定此类的属性值都是 px 为单位的
        removePixel[type] = PIXEL_PATTERN.test(type);
    }

    return removePixel[type] ? parseFloat(value) || 0 : value;
}

var floatMap = { cssFloat: 1, styleFloat: 1, float: 1 };

/**
 * 获取元素计算后的样式
 * @param  {Element} node DOM 节点
 * @param  {String} name 属性名
 * @return {Number|Object}
 */
function getStyle(node, name) {
    /* istanbul ignore if */
    if (!hasDOM || !node) {
        return null;
    }

    var style = _getComputedStyle(node);

    // 如果不指定属性名，则返回全部值
    if (arguments.length === 1) {
        return style;
    }

    name = floatMap[name] ? 'cssFloat' in node.style ? 'cssFloat' : 'styleFloat' : name;

    return _getStyleValue(node, name, style.getPropertyValue((0, _string.hyphenate)(name)) || node.style[(0, _string.camelcase)(name)]);
}

/**
 * 设置元素的样式
 * @param {Element} node  DOM 节点
 * @param {Object|String} name  属性名，或者是一个对象，包含多个属性
 * @param {Number|String} value 属性值
 *
 * @example
 * // 设置单个属性值
 * dom.setStyle(mountNode, 'width', 100);
 * // 设置多条属性值
 * dom.setStyle(mountNode, {
 *     width: 100,
 *     height: 200
 * });
 */
function setStyle(node, name, value) {
    /* istanbul ignore if */
    if (!hasDOM || !node) {
        return false;
    }

    // 批量设置多个值
    if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object' && arguments.length === 2) {
        (0, _object.each)(name, function (val, key) {
            return setStyle(node, key, val);
        });
    } else {
        name = floatMap[name] ? 'cssFloat' in node.style ? 'cssFloat' : 'styleFloat' : name;
        if (typeof value === 'number' && PIXEL_PATTERN.test(name)) {
            value = value + 'px';
        }
        node.style[(0, _string.camelcase)(name)] = value; // IE8 support
    }
}

/**
 * 获取默认的滚动条大小
 * @return {Object} width, height
 */
function scrollbar() {
    var scrollDiv = document.createElement('div');

    setStyle(scrollDiv, {
        position: 'absolute',
        width: '100px',
        height: '100px',
        overflow: 'scroll',
        top: '-9999px'
    });
    document.body.appendChild(scrollDiv);
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    var scrollbarHeight = scrollDiv.offsetHeight - scrollDiv.clientHeight;
    document.body.removeChild(scrollDiv);

    return {
        width: scrollbarWidth,
        height: scrollbarHeight
    };
}

/**
 * 获取元素距离视口顶部和左边的偏移距离
 * @return {Object} top, left
 */
function getOffset(node) {
    var rect = node.getBoundingClientRect();
    var win = node.ownerDocument.defaultView;
    return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
    };
}

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.camelcase = camelcase;
exports.hyphenate = hyphenate;
/**
 * 将字符串转化为驼峰式写法
 * @param  {String} str 例：-webkit-transition
 * @return {String}     例：WebkitTransition
 */
function camelcase(str) {
    if (!/-/.test(str)) {
        return str || '';
    }
    return str.toLowerCase().replace(/-([a-z])/g, function ($0, $1) {
        return $1.toUpperCase();
    });
}

/**
 * 将驼峰式字符串转化为连字符写法
 * @param  {String} str 例：WebkitTransition
 * @return {String}     例：-webkit-transition
 */
function hyphenate(str) {
    return str.replace(/([A-Z])/g, function ($0) {
        return '-' + $0.toLowerCase();
    });
}

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

exports.__esModule = true;
/**
 * IE浏览器的渲染引擎版本号
 * 注意：此属性与浏览器版本号不同，IE的渲染引擎版本号是可以通过HTML header或手动设置去更改的
 * @type {Number} 6 ~ 10
 */
var ieVersion = exports.ieVersion = typeof document !== 'undefined' ? document.documentMode : undefined;

/**
 * 判断是否是生产环境
 * @type {Boolean}
 */
var isProduction = exports.isProduction = function isProduction() {
    var PRODUCTION_ENV = 'production';
    var result = false;
    try {
        if (process.env.NODE_ENV === PRODUCTION_ENV) {
            result = true;
        }
    } catch (err) {
        //
    }

    if (!result) {
        try {
            if (window.process.env.NODE_ENV === PRODUCTION_ENV) {
                result = true;
            }
        } catch (err) {
            //
        }
    }

    return result;
};

exports.default = {
    ieVersion: ieVersion,
    isProduction: isProduction
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    ESC: 27,
    SPACE: 32,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,

    // version 0.x
    ESCAPE: 27,
    LEFT_ARROW: 37,
    UP_ARROW: 38,
    RIGHT_ARROW: 39,
    DOWN_ARROW: 40,

    // MacOS
    CONTROL: 17,
    OPTION: 18,
    CMD: 91,
    COMMAND: 91,
    DELETE: 8
};
module.exports = exports["default"];

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var styleEqual = __webpack_require__(96);
var hasOwnProperty = Object.prototype.hasOwnProperty;

function type(a) {
  return Array.isArray(a) ? 'array' : typeof a === 'undefined' ? 'undefined' : _typeof(a);
}

function elementEquals(a, b) {
  var typeOfA = type(a);
  var typeOfB = type(b);

  if (typeOfA !== typeOfB) return false;

  switch (typeOfA) {
    case 'array':
      if (a.length !== b.length) return false;
      for (var i = 0; i < a.length; i++) {
        if (!elementEquals(a[i], b[i])) return false;
      }
      return true;
    case 'object':
      if (!a || !b) return a === b;
      if (a.type !== b.type) return false;
      if (a.key !== b.key) return false;
      if (a.ref !== b.ref) return false;
      return shallowElementEquals(a.props, b.props);
      break;
    default:
      return a === b;
  }
}

function shallowElementEquals(a, b) {
  var aCount = 0;
  var bCount = 0;

  for (var key in a) {
    if (hasOwnProperty.call(a, key)) {
      if (key === 'style') {
        // NOTE(lmr): kind of risky, but i'm assuming that a `style` prop is a React Native style,
        // and using the `styleEqual` algorithm here.
        if (!styleEqual(a[key], b[key])) return false;
      } else if (key === 'children') {
        // will compare children later
      } else {
        if (a[key] !== b[key]) return false;
      }
      aCount++;
    }
  }

  for (var key in b) {
    if (hasOwnProperty.call(b, key)) {
      bCount++;
    }
  }

  if (aCount !== bCount) return false;

  // compare children last...
  return elementEquals(a.children, b.children);
}

module.exports = shallowElementEquals;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _util = __webpack_require__(2);

var _manager = __webpack_require__(97);

var _manager2 = _interopRequireDefault(_manager);

var _gateway = __webpack_require__(46);

var _gateway2 = _interopRequireDefault(_gateway);

var _position = __webpack_require__(47);

var _position2 = _interopRequireDefault(_position);

var _findNode = __webpack_require__(21);

var _findNode2 = _interopRequireDefault(_findNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var saveLastFocusNode = _util.focus.saveLastFocusNode,
    getFocusNodeList = _util.focus.getFocusNodeList,
    backLastFocusNode = _util.focus.backLastFocusNode;
var makeChain = _util.func.makeChain,
    noop = _util.func.noop,
    bindCtx = _util.func.bindCtx;


var isScrollDisplay = function isScrollDisplay(element) {
    try {
        var scrollbarStyle = window.getComputedStyle(element, '::-webkit-scrollbar');
        return !scrollbarStyle || scrollbarStyle.getPropertyValue('display') !== 'none';
    } catch (e) {
        // ignore error for firefox
    }

    return true;
};
var hasScroll = function hasScroll() {
    var doc = document.documentElement;
    return doc.scrollHeight > doc.clientHeight && _util.dom.scrollbar().width > 0 && isScrollDisplay(document.documentElement) && isScrollDisplay(document.body);
};
var prefixes = ['-webkit-', '-moz-', '-o-', 'ms-', ''];
var getStyleProperty = function getStyleProperty(node, name) {
    var style = window.getComputedStyle(node);
    var ret = '';
    for (var i = 0; i < prefixes.length; i++) {
        ret = style.getPropertyValue(prefixes[i] + name);
        if (ret) {
            break;
        }
    }
    return ret;
};

var modals = [];
var bodyOverflowY = void 0,
    bodyPaddingRight = void 0;

/**
 * Overlay
 * */
var Overlay = (_temp = _class = function (_Component) {
    _inherits(Overlay, _Component);

    function Overlay(props) {
        _classCallCheck(this, Overlay);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        _this.saveContentRef = function (ref) {
            _this.contentRef = ref;
        };

        _this.saveGatewayRef = function (ref) {
            _this.gatewayRef = ref;
        };

        _this.state = {
            visible: props.visible,
            status: 'none',
            animation: _this.getAnimation(props)
        };

        _this.lastAlign = props.align;

        bindCtx(_this, ['handlePosition', 'handleAnimateEnd', 'handleDocumentKeyDown', 'handleDocumentClick', 'handleMaskClick', 'beforeOpen', 'beforeClose']);

        _this.timeoutMap = {};
        return _this;
    }

    Overlay.prototype.componentWillMount = function componentWillMount() {
        if (this.props.visible) {
            this.beforeOpen();
            this.props.beforeOpen();

            if (this.state.animation && _util.support.animation) {
                this.enter();
            }
        }
    };

    Overlay.prototype.componentDidMount = function componentDidMount() {
        this.componentDidUpdate({ visible: false });
        this.addDocumentEvents();

        _manager2.default.addOverlay(this);

        if (this.state.visible) {
            this._isMounted = true;
        }
    };

    Overlay.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (!this._isMounted && nextProps.visible) {
            this._isMounted = true;
        }

        var willOpen = !this.props.visible && nextProps.visible;
        var willClose = this.props.visible && !nextProps.visible;
        if (willOpen) {
            this.beforeOpen();
            nextProps.beforeOpen();
        } else if (willClose) {
            this.beforeClose();
            nextProps.beforeClose();
        }

        if (nextProps.animation || nextProps.animation === false) {
            this.setState({
                animation: nextProps.animation
            });
        }

        if (nextProps.animation !== false && _util.support.animation) {
            if (willOpen) {
                this.enter();
            } else if (willClose) {
                this.leave();
            }
        } else {
            this.setState({
                visible: nextProps.visible
            });
        }
    };

    Overlay.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
        var _this2 = this;

        var open = !prevProps.visible && this.props.visible;
        var close = prevProps.visible && !this.props.visible;
        if (this.state.animation && _util.support.animation) {
            if (open || close) {
                this.addAnimationEvents();
            }
        } else {
            var wrapperNode = this.getWrapperNode();
            if (open) {
                setTimeout(function () {
                    _this2.props.onOpen();
                    _this2.props.afterOpen();
                    _util.dom.addClass(wrapperNode, 'opened');
                    _manager2.default.addOverlay(_this2);
                });
            } else if (close) {
                this.props.onClose();
                this.props.afterClose();
                _util.dom.removeClass(wrapperNode, 'opened');
                _manager2.default.removeOverlay(this);
            }
            this.setFocusNode();
        }
    };

    Overlay.prototype.componentWillUnmount = function componentWillUnmount() {
        this._isDestroyed = true;
        this._isMounted = false;
        _manager2.default.removeOverlay(this);
        this.removeDocumentEvents();
        if (this.focusTimeout) {
            clearTimeout(this.focusTimeout);
        }
        if (this._animation) {
            this._animation.off();
            this._animation = null;
        }
        this.beforeClose();
    };

    Overlay.prototype.getAnimation = function getAnimation(props) {
        if (props.animation === false) {
            return false;
        }

        if (props.animation) {
            return props.animation;
        }

        return this.getAnimationByAlign(props.align);
    };

    Overlay.prototype.getAnimationByAlign = function getAnimationByAlign(align) {
        switch (align[0]) {
            case 't':
                return {
                    in: 'expandInDown',
                    out: 'expandOutUp'
                };
            case 'b':
                return {
                    in: 'expandInUp',
                    out: 'expandOutDown'
                };
            default:
                return {
                    in: 'expandInDown',
                    out: 'expandOutUp'
                };
        }
    };

    Overlay.prototype.addAnimationEvents = function addAnimationEvents() {
        var _this3 = this;

        setTimeout(function () {
            var node = _this3.getContentNode();
            if (node) {
                var id = (0, _util.guid)();

                _this3._animation = _util.events.on(node, _util.support.animation.end, _this3.handleAnimateEnd.bind(_this3, id));

                var animationDelay = parseFloat(getStyleProperty(node, 'animation-delay')) || 0;
                var animationDuration = parseFloat(getStyleProperty(node, 'animation-duration')) || 0;
                var time = animationDelay + animationDuration;
                if (time) {
                    _this3.timeoutMap[id] = setTimeout(function () {
                        _this3.handleAnimateEnd(id);
                    }, time * 1000 + 200);
                }
            }
        });
    };

    Overlay.prototype.handlePosition = function handlePosition(config) {
        var align = config.align.join(' ');

        if (!('animation' in this.props) && this.props.needAdjust && this.lastAlign !== align) {
            this.setState({
                animation: this.getAnimationByAlign(align)
            });
        }

        this.lastAlign = align;
    };

    Overlay.prototype.handleAnimateEnd = function handleAnimateEnd(id) {
        if (this.timeoutMap[id]) {
            clearTimeout(this.timeoutMap[id]);
        }
        delete this.timeoutMap[id];

        if (this._animation) {
            this._animation.off();
            this._animation = null;
        }

        if (!this._isMounted) {
            return;
        }

        if (this.state.status === 'leaving') {
            this.setState({
                visible: false,
                status: 'none'
            });

            this.onLeaved();
        } else if (this.state.status === 'entering') {
            this.setState({
                status: 'none'
            });

            this.onEntered();
        }
    };

    Overlay.prototype.enter = function enter() {
        var _this4 = this;

        this.setState({
            visible: true,
            status: 'entering'
        }, function () {
            // NOTE: setState callback (second argument) now fires immediately after componentDidMount / componentDidUpdate instead of after all components have rendered.
            setTimeout(function () {
                if (!_this4._isDestroyed) {
                    _this4.onEntering();
                }
            });
        });
    };

    Overlay.prototype.leave = function leave() {
        this.setState({
            status: 'leaving'
        });

        this.onLeaving();
    };

    Overlay.prototype.onEntering = function onEntering() {
        var wrapperNode = this.getWrapperNode();
        _util.dom.addClass(wrapperNode, 'opened');
        this.props.onOpen();
    };

    Overlay.prototype.onLeaving = function onLeaving() {
        var wrapperNode = this.getWrapperNode();
        _util.dom.removeClass(wrapperNode, 'opened');
        this.props.onClose();
    };

    Overlay.prototype.onEntered = function onEntered() {
        _manager2.default.addOverlay(this);
        this.setFocusNode();
        this.props.afterOpen();
    };

    Overlay.prototype.onLeaved = function onLeaved() {
        _manager2.default.removeOverlay(this);
        this.setFocusNode();
        this.props.afterClose();
    };

    Overlay.prototype.beforeOpen = function beforeOpen() {
        if (this.props.disableScroll) {
            if (modals.length === 0) {
                var style = {
                    overflowY: 'hidden'
                };
                var body = document.body;
                bodyOverflowY = body.style.overflowY;
                if (hasScroll()) {
                    bodyPaddingRight = body.style.paddingRight;
                    style.paddingRight = _util.dom.getStyle(body, 'paddingRight') + _util.dom.scrollbar().width + 'px';
                }

                _util.dom.setStyle(body, style);
            }
            modals.push(this);
        }
    };

    Overlay.prototype.beforeClose = function beforeClose() {
        if (this.props.disableScroll) {
            var index = modals.indexOf(this);
            if (index > -1) {
                if (modals.length === 1) {
                    var style = {
                        overflowY: bodyOverflowY
                    };
                    if (hasScroll()) {
                        style.paddingRight = bodyPaddingRight;
                    }

                    _util.dom.setStyle(document.body, style);

                    bodyOverflowY = undefined;
                    bodyPaddingRight = undefined;
                }

                modals.splice(index, 1);
            }
        }
    };

    Overlay.prototype.setFocusNode = function setFocusNode() {
        var _this5 = this;

        if (!this.props.autoFocus) {
            return;
        }

        if (this.state.visible && !this._hasFocused) {
            saveLastFocusNode();
            // 这个时候很可能上一个弹层的关闭事件还未触发，导致焦点已经回到触发的元素
            // 这里延时处理一下，延时的时间为 document.click 捕获触发的延时时间
            this.focusTimeout = setTimeout(function () {
                var node = _this5.getContentNode();
                if (node) {
                    var focusNodeList = getFocusNodeList(node);
                    if (focusNodeList.length) {
                        focusNodeList[0].focus();
                    }
                    _this5._hasFocused = true;
                }
            }, 100);
        } else if (!this.state.visible && this._hasFocused) {
            backLastFocusNode();
            this._hasFocused = false;
        }
    };

    Overlay.prototype.getContent = function getContent() {
        return this.contentRef;
    };

    Overlay.prototype.getContentNode = function getContentNode() {
        return (0, _reactDom.findDOMNode)(this.contentRef);
    };

    Overlay.prototype.getWrapperNode = function getWrapperNode() {
        return this.gatewayRef ? this.gatewayRef.getChildNode() : null;
    };

    Overlay.prototype.addDocumentEvents = function addDocumentEvents() {
        if (this.props.canCloseByEsc) {
            this._keydownEvents = _util.events.on(document, 'keydown', this.handleDocumentKeyDown);
        }
        if (this.props.canCloseByOutSideClick) {
            this._clickEvents = _util.events.on(document, 'click', this.handleDocumentClick);
        }
    };

    Overlay.prototype.removeDocumentEvents = function removeDocumentEvents() {
        if (this._keydownEvents) {
            this._keydownEvents.off();
            this._keydownEvents = null;
        }
        if (this._clickEvents) {
            this._clickEvents.off();
            this._clickEvents = null;
        }
    };

    Overlay.prototype.handleDocumentKeyDown = function handleDocumentKeyDown(e) {
        if (this.state.visible && e.keyCode === _util.KEYCODE.ESC && _manager2.default.isCurrentOverlay(this)) {
            this.props.onRequestClose('keyboard', e);
        }
    };

    Overlay.prototype.handleDocumentClick = function handleDocumentClick(e) {
        var _this6 = this;

        if (this.state.visible) {
            var safeNode = this.props.safeNode;

            var safeNodes = Array.isArray(safeNode) ? [].concat(safeNode) : [safeNode];
            safeNodes.unshift(function () {
                return _this6.getWrapperNode();
            });

            for (var i = 0; i < safeNodes.length; i++) {
                var node = (0, _findNode2.default)(safeNodes[i], this.props);
                // HACK: 如果触发点击的节点是弹层内部的节点，并且在被点击后立即销毁，那么此时无法使用 node.contains(e.target)
                // 来判断此时点击的节点是否是弹层内部的节点，额外判断
                if (node && (node === e.target || node.contains(e.target) || e.target !== document && !document.documentElement.contains(e.target))) {
                    return;
                }
            }

            this.props.onRequestClose('docClick', e);
        }
    };

    Overlay.prototype.handleMaskClick = function handleMaskClick(e) {
        if (this.props.canCloseByMask) {
            this.props.onRequestClose('maskClick', e);
        }
    };

    // 兼容过去的用法: this.popupRef.getInstance().overlay.getInstance().getContentNode()
    Overlay.prototype.getInstance = function getInstance() {
        return this;
    };

    Overlay.prototype.render = function render() {
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            style = _props.style,
            propChildren = _props.children,
            target = _props.target,
            align = _props.align,
            offset = _props.offset,
            container = _props.container,
            hasMask = _props.hasMask,
            needAdjust = _props.needAdjust,
            beforePosition = _props.beforePosition,
            onPosition = _props.onPosition,
            wrapperStyle = _props.wrapperStyle,
            rtl = _props.rtl,
            propShouldUpdatePosition = _props.shouldUpdatePosition,
            cache = _props.cache,
            wrapperClassName = _props.wrapperClassName,
            onMaskMouseEnter = _props.onMaskMouseEnter,
            onMaskMouseLeave = _props.onMaskMouseLeave;
        var _state = this.state,
            stateVisible = _state.visible,
            status = _state.status,
            animation = _state.animation;


        var children = stateVisible || cache && this._isMounted ? propChildren : null;
        if (children) {
            var _classnames;

            var child = _react.Children.only(children);
            var childClazz = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'overlay-inner'] = true, _classnames[animation.in] = status === 'entering', _classnames[animation.out] = status === 'leaving', _classnames[child.props.className] = !!child.props.className, _classnames[className] = !!className, _classnames));
            if (typeof child.ref === 'string') {
                throw new Error('Can not set ref by string in Overlay, use function instead.');
            }

            children = _react2.default.cloneElement(child, {
                className: childClazz,
                style: _extends({}, child.props.style, style),
                ref: makeChain(this.saveContentRef, child.ref),
                'aria-hidden': !stateVisible && cache && this._isMounted
            });

            if (align) {
                var shouldUpdatePosition = status === 'leaving' ? false : propShouldUpdatePosition;
                children = _react2.default.createElement(_position2.default, {
                    children: children, target: target, align: align, offset: offset, needAdjust: needAdjust,
                    beforePosition: beforePosition,
                    onPosition: makeChain(this.handlePosition, onPosition),
                    shouldUpdatePosition: shouldUpdatePosition, rtl: rtl
                });
            }

            var wrapperClazz = (0, _classnames3.default)([prefix + 'overlay-wrapper', wrapperClassName]);
            var newWrapperStyle = _extends({}, {
                display: stateVisible ? '' : 'none'
            }, wrapperStyle);

            children = _react2.default.createElement(
                'div',
                { className: wrapperClazz, style: newWrapperStyle, dir: rtl ? 'rtl' : undefined },
                hasMask ? _react2.default.createElement('div', { className: prefix + 'overlay-backdrop',
                    onClick: this.handleMaskClick,
                    onMouseEnter: onMaskMouseEnter,
                    onMouseLeave: onMaskMouseLeave,
                    dir: rtl ? 'rtl' : undefined }) : null,
                children
            );
        }

        return _react2.default.createElement(_gateway2.default, _extends({ container: container, target: target, children: children }, { ref: this.saveGatewayRef }));
    };

    return Overlay;
}(_react.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    rtl: _propTypes2.default.bool,
    className: _propTypes2.default.string,
    style: _propTypes2.default.object,
    /**
     * 弹层内容
     */
    children: _propTypes2.default.any,
    /**
     * 是否显示弹层
     */
    visible: _propTypes2.default.bool,
    /**
     * 弹层请求关闭时触发事件的回调函数
     * @param {String} type 弹层关闭的来源
     * @param {Object} e DOM 事件
     */
    onRequestClose: _propTypes2.default.func,
    /**
     * 弹层定位的参照元素
     */
    target: _propTypes2.default.any,
    /**
     * 弹层相对于参照元素的定位, 详见开发指南的[定位部分](#定位)
     */
    align: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.bool]),
    /**
     * 弹层相对于参照元素定位的微调
     */
    offset: _propTypes2.default.array,
    /**
     * 渲染组件的容器，如果是函数需要返回 ref，如果是字符串则是该 DOM 的 id，也可以直接传入 DOM 节点
     */
    container: _propTypes2.default.any,
    /**
     * 是否显示遮罩
     */
    hasMask: _propTypes2.default.bool,
    /**
     * 是否支持 esc 按键关闭弹层
     */
    canCloseByEsc: _propTypes2.default.bool,
    /**
     * 点击弹层外的区域是否关闭弹层，不显示遮罩时生效
     */
    canCloseByOutSideClick: _propTypes2.default.bool,
    /**
     * 点击遮罩区域是否关闭弹层，显示遮罩时生效
     */
    canCloseByMask: _propTypes2.default.bool,
    /**
     * 弹层打开前触发事件的回调函数
     */
    beforeOpen: _propTypes2.default.func,
    /**
     * 弹层打开时触发事件的回调函数
     */
    onOpen: _propTypes2.default.func,
    /**
     * 弹层打开后触发事件的回调函数, 如果有动画，则在动画结束后触发
     */
    afterOpen: _propTypes2.default.func,
    /**
     * 弹层关闭前触发事件的回调函数
     */
    beforeClose: _propTypes2.default.func,
    /**
     * 弹层关闭时触发事件的回调函数
     */
    onClose: _propTypes2.default.func,
    /**
     * 弹层关闭后触发事件的回调函数, 如果有动画，则在动画结束后触发
     */
    afterClose: _propTypes2.default.func,
    /**
     * 弹层定位完成前触发的事件
     */
    beforePosition: _propTypes2.default.func,
    /**
     * 弹层定位完成时触发的事件
     * @param {Object} config 定位的参数
     * @param {Array} config.align 对齐方式，如 ['cc', 'cc']（如果开启 needAdjust，可能和预先设置的 align 不同）
     * @param {Number} config.top 距离视口顶部距离
     * @param {Number} config.left 距离视口左侧距离
     * @param {Object} node 定位参照的容器节点
     */
    onPosition: _propTypes2.default.func,
    /**
     * 是否在每次弹层重新渲染后强制更新定位信息，一般用于弹层内容区域大小发生变化时，仍需保持原来的定位方式
     */
    shouldUpdatePosition: _propTypes2.default.bool,
    /**
     * 弹层打开时是否让其中的元素自动获取焦点
     */
    autoFocus: _propTypes2.default.bool,
    /**
     * 当弹层由于页面滚动等情况不在可视区域时，是否自动调整定位以出现在可视区域
     */
    needAdjust: _propTypes2.default.bool,
    /**
     * 是否禁用页面滚动
     */
    disableScroll: _propTypes2.default.bool,
    /**
     * 隐藏时是否保留子节点
     */
    cache: _propTypes2.default.bool,
    /**
     * 安全节点，当点击 document 的时候，如果包含该节点则不会关闭弹层，如果是函数需要返回 ref，如果是字符串则是该 DOM 的 id，也可以直接传入 DOM 节点，或者以上值组成的数组
     */
    safeNode: _propTypes2.default.any,
    /**
     * 弹层的根节点的样式类
     */
    wrapperClassName: _propTypes2.default.string,
    /**
     * 弹层的根节点的内联样式
     */
    wrapperStyle: _propTypes2.default.object,
    /**
     * 配置动画的播放方式，支持 { in: 'enter-class', out: 'leave-class' } 的对象参数，如果设置为 false，则不播放动画
     * @default { in: 'expandInDown', out: 'expandOutUp' }
     */
    animation: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.bool]),
    onMaskMouseEnter: _propTypes2.default.func,
    onMaskMouseLeave: _propTypes2.default.func
}, _class.defaultProps = {
    prefix: 'next-',
    pure: false,
    visible: false,
    onRequestClose: noop,
    target: _position2.default.VIEWPORT,
    align: 'tl bl',
    offset: [0, 0],
    hasMask: false,
    canCloseByEsc: true,
    canCloseByOutSideClick: true,
    canCloseByMask: true,
    beforeOpen: noop,
    onOpen: noop,
    afterOpen: noop,
    beforeClose: noop,
    onClose: noop,
    afterClose: noop,
    beforePosition: noop,
    onPosition: noop,
    onMaskMouseEnter: noop,
    onMaskMouseLeave: noop,
    shouldUpdatePosition: false,
    autoFocus: false,
    needAdjust: true,
    disableScroll: false,
    cache: false
}, _temp);
Overlay.displayName = 'Overlay';
exports.default = Overlay;
module.exports = exports['default'];

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

var _findNode = __webpack_require__(21);

var _findNode2 = _interopRequireDefault(_findNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var makeChain = _util.func.makeChain;
var Gateway = (_temp2 = _class = function (_Component) {
    _inherits(Gateway, _Component);

    function Gateway() {
        var _temp, _this, _ret;

        _classCallCheck(this, Gateway);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.saveChildRef = function (ref) {
            _this.child = ref;
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Gateway.prototype.componentDidMount = function componentDidMount() {
        this.containerNode = this.getContainerNode(this.props);
        this.forceUpdate();
    };

    Gateway.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        this.containerNode = this.getContainerNode(nextProps);
    };

    Gateway.prototype.getContainerNode = function getContainerNode(props) {
        var targetNode = (0, _findNode2.default)(props.target);
        return (0, _findNode2.default)(props.container, targetNode);
    };

    Gateway.prototype.getChildNode = function getChildNode() {
        return (0, _reactDom.findDOMNode)(this.child);
    };

    Gateway.prototype.render = function render() {
        if (!this.containerNode) {
            return null;
        }

        var children = this.props.children;

        var child = children ? _react.Children.only(children) : null;
        if (!child) {
            return null;
        }

        if (typeof child.ref === 'string') {
            throw new Error('Can not set ref by string in Gateway, use function instead.');
        }
        child = _react2.default.cloneElement(child, {
            ref: makeChain(this.saveChildRef, child.ref)
        });

        return (0, _reactDom.createPortal)(child, this.containerNode);
    };

    return Gateway;
}(_react.Component), _class.propTypes = {
    children: _propTypes2.default.node,
    container: _propTypes2.default.any,
    target: _propTypes2.default.any
}, _class.defaultProps = {
    container: function container() {
        return document.body;
    }
}, _temp2);
Gateway.displayName = 'Gateway';
exports.default = Gateway;
module.exports = exports['default'];

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

var _position = __webpack_require__(98);

var _position2 = _interopRequireDefault(_position);

var _findNode = __webpack_require__(21);

var _findNode2 = _interopRequireDefault(_findNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = _util.func.noop,
    bindCtx = _util.func.bindCtx;
var getStyle = _util.dom.getStyle;

var place = _position2.default.place;

var Position = (_temp = _class = function (_Component) {
    _inherits(Position, _Component);

    function Position(props) {
        _classCallCheck(this, Position);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        bindCtx(_this, ['handleResize']);
        return _this;
    }

    Position.prototype.componentDidMount = function componentDidMount() {
        this.setPosition();

        if (this.props.needListenResize) {
            _util.events.on(window, 'resize', this.handleResize);
        }
    };

    Position.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if ('align' in nextProps && nextProps.align !== this.props.align || nextProps.shouldUpdatePosition) {
            this.shouldUpdatePosition = true;
        }
    };

    Position.prototype.componentDidUpdate = function componentDidUpdate() {
        if (this.shouldUpdatePosition) {
            this.setPosition();
            this.shouldUpdatePosition = false;
        }
    };

    Position.prototype.componentWillUnmount = function componentWillUnmount() {
        if (this.props.needListenResize) {
            _util.events.off(window, 'resize', this.handleResize);
        }

        clearTimeout(this.resizeTimeout);
    };

    Position.prototype.setPosition = function setPosition() {
        var _props = this.props,
            align = _props.align,
            offset = _props.offset,
            beforePosition = _props.beforePosition,
            onPosition = _props.onPosition,
            needAdjust = _props.needAdjust,
            rtl = _props.rtl;


        beforePosition();

        var contentNode = this.getContentNode();
        var targetNode = this.getTargetNode();
        if (contentNode && targetNode) {
            var resultAlign = place({
                pinElement: contentNode,
                baseElement: targetNode,
                align: align,
                offset: offset,
                needAdjust: needAdjust,
                isRtl: rtl
            });
            var top = getStyle(contentNode, 'top');
            var left = getStyle(contentNode, 'left');

            onPosition({
                align: resultAlign.split(' '),
                top: top,
                left: left
            }, contentNode);
        }
    };

    Position.prototype.getContentNode = function getContentNode() {
        return (0, _reactDom.findDOMNode)(this);
    };

    Position.prototype.getTargetNode = function getTargetNode() {
        var target = this.props.target;


        return target === _position2.default.VIEWPORT ? _position2.default.VIEWPORT : (0, _findNode2.default)(target, this.props);
    };

    Position.prototype.handleResize = function handleResize() {
        var _this2 = this;

        clearTimeout(this.resizeTimeout);

        this.resizeTimeout = setTimeout(function () {
            _this2.setPosition();
        }, 200);
    };

    Position.prototype.render = function render() {
        return _react.Children.only(this.props.children);
    };

    return Position;
}(_react.Component), _class.VIEWPORT = _position2.default.VIEWPORT, _class.propTypes = {
    children: _propTypes2.default.node,
    target: _propTypes2.default.any,
    align: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.bool]),
    offset: _propTypes2.default.array,
    beforePosition: _propTypes2.default.func,
    onPosition: _propTypes2.default.func,
    needAdjust: _propTypes2.default.bool,
    needListenResize: _propTypes2.default.bool,
    shouldUpdatePosition: _propTypes2.default.bool,
    rtl: _propTypes2.default.bool
}, _class.defaultProps = {
    align: 'tl bl',
    offset: [0, 0],
    beforePosition: noop,
    onPosition: noop,
    needAdjust: true,
    needListenResize: true,
    shouldUpdatePosition: false,
    rtl: false
}, _temp);
Position.displayName = 'Position';
exports.default = Position;
module.exports = exports['default'];

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _filter = __webpack_require__(49);

var _filter2 = _interopRequireDefault(_filter);

var _sort = __webpack_require__(63);

var _sort2 = _interopRequireDefault(_sort);

var _cell = __webpack_require__(18);

var _cell2 = _interopRequireDefault(_cell);

var _resize = __webpack_require__(120);

var _resize2 = _interopRequireDefault(_resize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};
var Header = (_temp2 = _class = function (_React$Component) {
    _inherits(Header, _React$Component);

    function Header() {
        var _temp, _this, _ret;

        _classCallCheck(this, Header);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.getCellRef = function (i, j, cell) {
            _this.props.headerCellRef(i, j, cell);
        }, _this.onSort = function (dataIndex, order, sort) {
            _this.props.onSort(dataIndex, order, sort);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Header.prototype.render = function render() {
        var _this2 = this;

        /*eslint-disable no-unused-vars */
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            children = _props.children,
            Tag = _props.component,
            colGroup = _props.colGroup,
            columns = _props.columns,
            locale = _props.locale,
            filterParams = _props.filterParams,
            onFilter = _props.onFilter,
            components = _props.components,
            affixRef = _props.affixRef,
            headerCellRef = _props.headerCellRef,
            onSort = _props.onSort,
            sort = _props.sort,
            onResizeChange = _props.onResizeChange,
            pure = _props.pure,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'children', 'component', 'colGroup', 'columns', 'locale', 'filterParams', 'onFilter', 'components', 'affixRef', 'headerCellRef', 'onSort', 'sort', 'onResizeChange', 'pure']);

        var _components$Cell = components.Cell,
            Cell = _components$Cell === undefined ? _cell2.default : _components$Cell,
            _components$Filter = components.Filter,
            Filter = _components$Filter === undefined ? _filter2.default : _components$Filter,
            _components$Sort = components.Sort,
            Sort = _components$Sort === undefined ? _sort2.default : _components$Sort,
            _components$Resize = components.Resize,
            Resize = _components$Resize === undefined ? _resize2.default : _components$Resize;

        var rowSpan = columns.length;

        var header = columns.map(function (cols, index) {
            var col = cols.map(function (col, j) {
                var _classnames;

                /* eslint-disable no-unused-vars, prefer-const */
                var title = col.title,
                    colSpan = col.colSpan,
                    sortable = col.sortable,
                    resizable = col.resizable,
                    dataIndex = col.dataIndex,
                    filters = col.filters,
                    filterMode = col.filterMode,
                    width = col.width,
                    align = col.align,
                    className = col.className,
                    __normalized = col.__normalized,
                    lock = col.lock,
                    others = _objectWithoutProperties(col, ['title', 'colSpan', 'sortable', 'resizable', 'dataIndex', 'filters', 'filterMode', 'width', 'align', 'className', '__normalized', 'lock']);

                className = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-header-node'] = true, _classnames[prefix + 'table-header-resizable'] = resizable, _classnames[className] = className, _classnames));
                var attrs = {},
                    sortElement = void 0,
                    filterElement = void 0,
                    resizeElement = void 0;
                if (col.children && col.children.length) {
                    attrs.colSpan = colSpan;
                } else {
                    if (sortable) {
                        sortElement = _react2.default.createElement(Sort, { prefix: prefix,
                            dataIndex: dataIndex,
                            onSort: _this2.onSort,
                            sort: sort,
                            locale: locale });
                    }
                    if (resizable) {
                        resizeElement = _react2.default.createElement(Resize, { prefix: prefix, dataIndex: dataIndex, onChange: onResizeChange });
                    }

                    if (filters) {
                        filterElement = filters.length ? _react2.default.createElement(Filter, { dataIndex: dataIndex,
                            filters: filters,
                            prefix: prefix,
                            locale: locale,
                            filterParams: filterParams,
                            filterMode: filterMode,
                            onFilter: onFilter }) : null;
                    }
                    attrs.rowSpan = rowSpan - index;
                }
                return _react2.default.createElement(
                    Cell,
                    _extends({}, others, attrs, {
                        key: j,
                        prefix: prefix,
                        pure: pure,
                        cell: title,
                        component: 'th',
                        align: align,
                        className: className,
                        ref: _this2.getCellRef.bind(_this2, index, j),
                        type: 'header' }),
                    sortElement,
                    filterElement,
                    resizeElement
                );
            });
            return _react2.default.createElement(
                'tr',
                { key: index },
                col
            );
        });

        return _react2.default.createElement(
            Tag,
            _extends({ className: className }, others),
            header,
            children
        );
    };

    return Header;
}(_react2.default.Component), _class.propTypes = {
    children: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    className: _propTypes2.default.string,
    component: _propTypes2.default.string,
    columns: _propTypes2.default.array,
    colGroup: _propTypes2.default.object,
    headerCellRef: _propTypes2.default.func,
    locale: _propTypes2.default.object,
    filterParams: _propTypes2.default.object,
    onFilter: _propTypes2.default.func,
    components: _propTypes2.default.object,
    sort: _propTypes2.default.object,
    onSort: _propTypes2.default.func,
    onResizeChange: _propTypes2.default.func
}, _class.defaultProps = {
    component: 'thead',
    columns: [],
    headerCellRef: noop,
    onFilter: noop,
    components: {},
    onSort: noop,
    onResizeChange: noop
}, _temp2);
Header.displayName = 'Header';
exports.default = Header;
module.exports = exports['default'];

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp, _initialiseProps;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _dropdown = __webpack_require__(100);

var _dropdown2 = _interopRequireDefault(_dropdown);

var _menu = __webpack_require__(76);

var _menu2 = _interopRequireDefault(_menu);

var _button = __webpack_require__(71);

var _button2 = _interopRequireDefault(_button);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

// 共享状态的组件需要变成非受控组件
var Filter = (_temp = _class = function (_React$Component) {
    _inherits(Filter, _React$Component);

    function Filter(props) {
        _classCallCheck(this, Filter);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

        _initialiseProps.call(_this);

        var filterParams = props.filterParams || {};
        var filterConfig = filterParams[props.dataIndex] || {};
        _this.state = {
            visible: filterConfig.visible || false,
            selectedKeys: filterConfig.selectedKeys || []
        };
        _this._selectedKeys = [].concat(_this.state.selectedKeys);
        return _this;
    }

    Filter.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (nextProps.hasOwnProperty('filterParams') && typeof nextProps.filterParams !== 'undefined') {
            var dataIndex = nextProps.dataIndex || this.props.dataIndex;
            var filterParams = nextProps.filterParams || {};
            var filterConfig = filterParams[dataIndex] || {};
            var selectedKeys = filterConfig.selectedKeys || [];
            this.setState({
                selectedKeys: selectedKeys
            });
            this._selectedKeys = [].concat(selectedKeys);
        }
    };

    Filter.prototype.render = function render() {
        var _props = this.props,
            filters = _props.filters,
            prefix = _props.prefix,
            locale = _props.locale,
            filterMode = _props.filterMode;
        var _state = this.state,
            visible = _state.visible,
            selectedKeys = _state.selectedKeys;


        function renderMenuItem(item) {
            return _react2.default.createElement(
                _menu2.default.Item,
                { key: item.value },
                item.label
            );
        }

        function renderSubMenu(parent, children) {
            return _react2.default.createElement(
                _menu2.default.SubMenu,
                { label: parent.label, key: parent.value, selectable: false },
                renderMenuContent(children)
            );
        }

        function renderMenuContent(list) {
            return list.map(function (item) {
                if (item.children) {
                    return renderSubMenu(item, item.children);
                } else {
                    return renderMenuItem(item);
                }
            });
        }

        var content = renderMenuContent(filters),
            footer = _react2.default.createElement(
            'div',
            { className: prefix + 'table-filter-footer' },
            _react2.default.createElement(
                _button2.default,
                { type: 'primary', onClick: this.onFilterConfirm },
                locale.ok
            ),
            _react2.default.createElement(
                _button2.default,
                { onClick: this.onFilterClear },
                locale.reset
            )
        );

        return _react2.default.createElement(
            _dropdown2.default,
            { trigger: _react2.default.createElement(
                    'span',
                    { role: 'button',
                        'aria-label': locale.filter,
                        onKeyDown: this.filterKeydown,
                        tabIndex: '0',
                        className: prefix + 'table-filter' },
                    _react2.default.createElement(_icon2.default, { type: 'filter', size: 'small' })
                ),
                triggerType: 'click',
                visible: visible,
                autoFocus: true,
                container: function container(node) {
                    return node.parentNode;
                },
                onVisibleChange: this.onFilterVisible },
            _react2.default.createElement(
                _menu2.default,
                { footer: footer,
                    selectedKeys: selectedKeys,
                    selectMode: filterMode,
                    onSelect: this.onFilterSelect },
                content
            )
        );
    };

    return Filter;
}(_react2.default.Component), _class.propTypes = {
    dataIndex: _propTypes2.default.string,
    filters: _propTypes2.default.array,
    filterMode: _propTypes2.default.string,
    filterParams: _propTypes2.default.object,
    locale: _propTypes2.default.object,
    onFilter: _propTypes2.default.func,
    prefix: _propTypes2.default.string
}, _class.defaultProps = {
    onFilter: function onFilter() {}
}, _initialiseProps = function _initialiseProps() {
    var _this2 = this;

    this.filterKeydown = function (e) {
        e.preventDefault();
        e.stopPropagation();

        if (e.keyCode === _util.KEYCODE.ENTER) {
            _this2.setState({
                visible: !_this2.state.visible
            });
        }
    };

    this.onFilterVisible = function (visible) {
        _this2.setState({
            visible: visible
        });

        if (!visible) {
            var selectedKeys = [].concat(_this2._selectedKeys);

            _this2.setState({
                selectedKeys: selectedKeys
            });
        }
    };

    this.onFilterSelect = function (selectedKeys) {
        _this2.setState({
            visible: true,
            selectedKeys: selectedKeys
        });
    };

    this.onFilterConfirm = function () {
        var selectedKeys = _this2.state.selectedKeys;
        var filterParams = {},
            dataIndex = _this2.props.dataIndex;

        filterParams[dataIndex] = {
            visible: false,
            selectedKeys: selectedKeys
        };
        _this2._selectedKeys = [].concat(selectedKeys);
        _this2.setState({
            visible: false
        });
        // 兼容之前的格式
        _this2.props.onFilter(filterParams);
    };

    this.onFilterClear = function () {
        var filterParams = {},
            dataIndex = _this2.props.dataIndex;

        filterParams[dataIndex] = {
            visible: false,
            selectedKeys: []
        };
        _this2._selectedKeys = [];
        _this2.setState({
            selectedKeys: [],
            visible: false
        });
        // 兼容之前的格式
        _this2.props.onFilter(filterParams);
    };
}, _temp);
Filter.displayName = 'Filter';
exports.default = Filter;
module.exports = exports['default'];

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var bindCtx = _util.func.bindCtx;
var pickOthers = _util.obj.pickOthers;

var noop = function noop() {};

/**
 * Menu
 */
var Menu = (_temp = _class = function (_Component) {
    _inherits(Menu, _Component);

    function Menu(props) {
        _classCallCheck(this, Menu);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        var _this$props = _this.props,
            children = _this$props.children,
            selectedKeys = _this$props.selectedKeys,
            defaultSelectedKeys = _this$props.defaultSelectedKeys,
            focusedKey = _this$props.focusedKey,
            focusable = _this$props.focusable,
            autoFocus = _this$props.autoFocus;


        _this.newChildren = _this.getNewChildren(children);

        if (focusable) {
            _this.tabbableKey = _this.getFirstAvaliablelChildKey('0');
        }
        _this.state = {
            openKeys: _this.getInitOpenKeys(props),
            selectedKeys: _this.normalizeToArray(selectedKeys || defaultSelectedKeys),
            focusedKey: 'focusedKey' in _this.props ? focusedKey : focusable && autoFocus ? _this.tabbableKey : null
        };

        bindCtx(_this, ['handleOpen', 'handleSelect', 'handleItemClick', 'handleItemKeyDown', 'onBlur']);

        _this.popupNodes = [];
        return _this;
    }

    Menu.prototype.componentDidMount = function componentDidMount() {
        this.menuNode = (0, _reactDom.findDOMNode)(this);
    };

    Menu.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var state = {};

        if ('openKeys' in nextProps) {
            state.openKeys = this.normalizeToArray(nextProps.openKeys);
        }
        if ('selectedKeys' in nextProps) {
            state.selectedKeys = this.normalizeToArray(nextProps.selectedKeys);
        }
        if ('focusedKey' in nextProps) {
            state.focusedKey = nextProps.focusedKey;
        }

        if (Object.keys(state).length) {
            this.setState(state);
        }
    };

    Menu.prototype.componentWillUpdate = function componentWillUpdate(nextProps) {
        this.newChildren = this.getNewChildren(nextProps.children);
        if (this.props.focusable) {
            if (this.tabbableKey in this.k2n) {
                if (this.state.focusedKey) {
                    this.tabbableKey = this.state.focusedKey;
                }
            } else {
                this.tabbableKey = this.getFirstAvaliablelChildKey('0');
            }
        }
    };

    Menu.prototype.onBlur = function onBlur(e) {
        this.setState({
            focusedKey: ''
        });

        this.props.onBlur && this.props.onBlur(e);
    };

    Menu.prototype.getInitOpenKeys = function getInitOpenKeys(props) {
        var _this2 = this;

        var initOpenKeys = void 0;

        var openKeys = props.openKeys,
            defaultOpenKeys = props.defaultOpenKeys,
            defaultOpenAll = props.defaultOpenAll,
            mode = props.mode,
            openMode = props.openMode;

        if (openKeys) {
            initOpenKeys = openKeys;
        } else if (defaultOpenAll && mode === 'inline' && openMode === 'multiple') {
            initOpenKeys = Object.keys(this.k2n).filter(function (key) {
                return _this2.k2n[key].type === 'submenu';
            });
        } else {
            initOpenKeys = defaultOpenKeys;
        }

        return this.normalizeToArray(initOpenKeys);
    };

    Menu.prototype.getNewChildren = function getNewChildren(children) {
        var _this3 = this;

        this.k2n = {};
        this.p2n = {};
        var loop = function loop(children, posPrefix) {
            var indexWrapper = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { index: 0 };

            return _react.Children.map(children, function (child) {
                if (child && typeof child.type === 'function' && 'menuChildType' in child.type) {
                    var newChild = void 0;

                    var pos = void 0;
                    var props = { root: _this3 };

                    if (['item', 'submenu', 'group'].indexOf(child.type.menuChildType) > -1) {
                        pos = posPrefix + '-' + indexWrapper.index++;
                        var key = typeof child.key === 'string' ? child.key : pos;
                        var level = pos.split('-').length - 1;
                        _this3.k2n[key] = _this3.p2n[pos] = {
                            key: key,
                            pos: pos,
                            type: child.type.menuChildType,
                            disabled: child.props.disabled,
                            label: child.props.label || child.props.children
                        };

                        props._key = key;
                        props.level = level;
                        props.groupIndent = child.type.menuChildType === 'group' ? 1 : 0;
                    }

                    switch (child.type.menuChildType) {
                        case 'submenu':
                            newChild = (0, _react.cloneElement)(child, props, loop(child.props.children, pos));
                            break;
                        case 'group':
                            newChild = (0, _react.cloneElement)(child, props, loop(child.props.children, posPrefix, indexWrapper));
                            break;
                        case 'item':
                        case 'divider':
                            newChild = (0, _react.cloneElement)(child, props);
                            break;
                        default:
                            newChild = child;
                            break;
                    }

                    return newChild;
                }

                return child;
            });
        };

        return loop(children, '0');
    };

    Menu.prototype.normalizeToArray = function normalizeToArray(items) {
        if (items) {
            if (Array.isArray(items)) {
                return items;
            }
            return [items];
        }

        return [];
    };

    Menu.prototype.isSibling = function isSibling(currentPos, targetPos) {
        var currentNums = currentPos.split('-').slice(0, -1);
        var targetNums = targetPos.split('-').slice(0, -1);

        return currentNums.length === targetNums.length && currentNums.every(function (num, index) {
            return num === targetNums[index];
        });
    };

    Menu.prototype.isAncestor = function isAncestor(currentPos, targetPos) {
        var currentNums = currentPos.split('-');
        var targetNums = targetPos.split('-');

        return currentNums.length > targetNums.length && targetNums.every(function (num, index) {
            return num === currentNums[index];
        });
    };

    Menu.prototype.handleOpen = function handleOpen(key, open, triggerType, e) {
        var _this4 = this;

        var newOpenKeys = void 0;

        var _props = this.props,
            mode = _props.mode,
            openMode = _props.openMode;
        var openKeys = this.state.openKeys;

        var index = openKeys.indexOf(key);
        if (open && index === -1) {
            if (mode === 'inline') {
                if (openMode === 'single') {
                    newOpenKeys = openKeys.filter(function (k) {
                        return !_this4.isSibling(_this4.k2n[key].pos, _this4.k2n[k].pos);
                    });
                    newOpenKeys.push(key);
                } else {
                    newOpenKeys = openKeys.concat(key);
                }
            } else {
                newOpenKeys = openKeys.filter(function (k) {
                    return _this4.isAncestor(_this4.k2n[key].pos, _this4.k2n[k].pos);
                });
                newOpenKeys.push(key);
            }
        } else if (!open && index > -1) {
            if (mode === 'inline') {
                newOpenKeys = [].concat(openKeys.slice(0, index), openKeys.slice(index + 1));
            } else if (triggerType === 'docClick') {
                if (!this.popupNodes.concat(this.menuNode).some(function (node) {
                    return node.contains(e.target);
                })) {
                    newOpenKeys = [];
                }
            } else {
                newOpenKeys = openKeys.filter(function (k) {
                    return k !== key && !_this4.isAncestor(_this4.k2n[k].pos, _this4.k2n[key].pos);
                });
            }
        }

        if (newOpenKeys) {
            if (!('openKeys' in this.props)) {
                this.setState({
                    openKeys: newOpenKeys
                });
            }

            this.props.onOpen(newOpenKeys, {
                key: key,
                open: open
            });
        }
    };

    Menu.prototype.getPath = function getPath(key) {
        var keyPath = [];
        var labelPath = [];

        var pos = this.k2n[key].pos;
        var nums = pos.split('-');
        for (var i = 1; i < nums.length - 1; i++) {
            var parentNums = nums.slice(0, i + 1);
            var parentPos = parentNums.join('-');
            var parent = this.p2n[parentPos];
            keyPath.push(parent.key);
            labelPath.push(parent.label);
        }

        return {
            keyPath: keyPath,
            labelPath: labelPath
        };
    };

    Menu.prototype.handleSelect = function handleSelect(key, select, menuItem) {
        var pos = this.k2n[key].pos;
        var level = pos.split('-').length - 1;
        if (this.props.shallowSelect && level > 1) {
            return;
        }

        var newSelectedKeys = void 0;

        var selectMode = this.props.selectMode;
        var selectedKeys = this.state.selectedKeys;

        var index = selectedKeys.indexOf(key);
        if (select && index === -1) {
            if (selectMode === 'single') {
                newSelectedKeys = [key];
            } else if (selectMode === 'multiple') {
                newSelectedKeys = selectedKeys.concat(key);
            }
        } else if (!select && index > -1 && selectMode === 'multiple') {
            newSelectedKeys = [].concat(selectedKeys.slice(0, index), selectedKeys.slice(index + 1));
        }

        if (newSelectedKeys) {
            if (!('selectedKeys' in this.props)) {
                this.setState({
                    selectedKeys: newSelectedKeys
                });
            }

            this.props.onSelect(newSelectedKeys, menuItem, _extends({
                key: key,
                select: select,
                label: this.k2n[key].label
            }, this.getPath(key)));
        }
    };

    Menu.prototype.handleItemClick = function handleItemClick(key, item, e) {
        var _this5 = this;

        if (this.props.focusable) {
            if (!('focusedKey' in this.props)) {
                this.setState({
                    focusedKey: key
                });
            }

            this.props.onItemFocus(key, item, e);
        }

        if (item.props.type === 'item') {
            if (item.props.parentMode === 'popup' && this.state.openKeys.length) {
                if (!('openKeys' in this.props)) {
                    this.setState({
                        openKeys: []
                    });
                }

                this.props.onOpen([], {
                    key: this.state.openKeys.sort(function (prevKey, nextKey) {
                        return _this5.k2n[nextKey].pos.split('-').length - _this5.k2n[prevKey].pos.split('-').length;
                    })[0],
                    open: false
                });
            }

            this.props.onItemClick(key, item, e);
        }
    };

    Menu.prototype.isAvailablePos = function isAvailablePos(refPos, targetPos) {
        var _p2n$targetPos = this.p2n[targetPos],
            type = _p2n$targetPos.type,
            disabled = _p2n$targetPos.disabled;


        return this.isSibling(refPos, targetPos) && (type === 'item' && !disabled || type === 'submenu');
    };

    Menu.prototype.getAvailableKey = function getAvailableKey(pos, prev) {
        var _this6 = this;

        var ps = Object.keys(this.p2n).filter(function (p) {
            return _this6.isAvailablePos(pos, p);
        });
        if (ps.length > 1) {
            var index = ps.indexOf(pos);
            var targetIndex = void 0;
            if (prev) {
                targetIndex = index === 0 ? ps.length - 1 : index - 1;
            } else {
                targetIndex = index === ps.length - 1 ? 0 : index + 1;
            }

            return this.p2n[ps[targetIndex]].key;
        }

        return null;
    };

    Menu.prototype.getFirstAvaliablelChildKey = function getFirstAvaliablelChildKey(parentPos) {
        var _this7 = this;

        var pos = Object.keys(this.p2n).find(function (p) {
            return _this7.isAvailablePos(parentPos + '-0', p);
        });
        return pos ? this.p2n[pos].key : null;
    };

    Menu.prototype.getParentKey = function getParentKey(pos) {
        return this.p2n[pos.slice(0, pos.length - 2)].key;
    };

    Menu.prototype.handleItemKeyDown = function handleItemKeyDown(key, type, item, e) {
        if ([_util.KEYCODE.UP, _util.KEYCODE.DOWN, _util.KEYCODE.RIGHT, _util.KEYCODE.LEFT, _util.KEYCODE.ENTER, _util.KEYCODE.ESC, _util.KEYCODE.SPACE].indexOf(e.keyCode) > -1) {
            e.preventDefault();
            e.stopPropagation();
        }

        var focusedKey = this.state.focusedKey;

        var direction = this.props.direction;

        var pos = this.k2n[key].pos;
        var level = pos.split('-').length - 1;
        switch (e.keyCode) {
            case _util.KEYCODE.UP:
                {
                    var avaliableKey = this.getAvailableKey(pos, true);
                    if (avaliableKey) {
                        focusedKey = avaliableKey;
                    }
                    break;
                }
            case _util.KEYCODE.DOWN:
                {
                    var _avaliableKey = void 0;
                    if (direction === 'hoz' && level === 1 && type === 'submenu') {
                        this.handleOpen(key, true);
                        _avaliableKey = this.getFirstAvaliablelChildKey(pos);
                    } else {
                        _avaliableKey = this.getAvailableKey(pos, false);
                    }
                    if (_avaliableKey) {
                        focusedKey = _avaliableKey;
                    }
                    break;
                }
            case _util.KEYCODE.RIGHT:
                {
                    var _avaliableKey2 = void 0;
                    if (direction === 'hoz' && level === 1) {
                        _avaliableKey2 = this.getAvailableKey(pos, false);
                    } else if (type === 'submenu') {
                        this.handleOpen(key, true);
                        _avaliableKey2 = this.getFirstAvaliablelChildKey(pos);
                    }
                    if (_avaliableKey2) {
                        focusedKey = _avaliableKey2;
                    }
                    break;
                }
            case _util.KEYCODE.ENTER:
                {
                    if (type === 'submenu') {
                        this.handleOpen(key, true);
                        var _avaliableKey3 = this.getFirstAvaliablelChildKey(pos);
                        if (_avaliableKey3) {
                            focusedKey = _avaliableKey3;
                        }
                    }
                    break;
                }
            case _util.KEYCODE.LEFT:
                {
                    if (direction === 'hoz' && level === 1) {
                        var _avaliableKey4 = this.getAvailableKey(pos, true);
                        if (_avaliableKey4) {
                            focusedKey = _avaliableKey4;
                        }
                    } else if (level > 1) {
                        var parentKey = this.getParentKey(pos);
                        this.handleOpen(parentKey, false);
                        focusedKey = parentKey;
                    }
                    break;
                }
            case _util.KEYCODE.ESC:
                if (level > 1) {
                    var _parentKey = this.getParentKey(pos);
                    this.handleOpen(_parentKey, false);
                    focusedKey = _parentKey;
                }
                break;

            case _util.KEYCODE.TAB:
                focusedKey = null;
                break;
            default:
                break;
        }

        if (focusedKey !== this.state.focusedKey) {
            if (!('focusedKey' in this.props)) {
                this.setState({
                    focusedKey: focusedKey
                });
            }

            this.props.onItemKeyDown(focusedKey, item, e);
            this.props.onItemFocus(focusedKey, e);
        }
    };

    Menu.prototype.render = function render() {
        var _cx;

        var _props2 = this.props,
            prefix = _props2.prefix,
            className = _props2.className,
            direction = _props2.direction,
            hozAlign = _props2.hozAlign,
            header = _props2.header,
            footer = _props2.footer,
            selectMode = _props2.selectMode,
            rtl = _props2.rtl;

        var others = pickOthers(Object.keys(Menu.propTypes), this.props);

        var newClassName = (0, _classnames2.default)((_cx = {}, _cx[prefix + 'menu'] = true, _cx[prefix + 'ver'] = direction === 'ver', _cx[prefix + 'hoz'] = direction === 'hoz', _cx[className] = !!className, _cx));

        var role = direction === 'hoz' ? 'menubar' : 'menu';
        var headerElement = header ? _react2.default.createElement(
            'li',
            { className: prefix + 'menu-header' },
            header
        ) : null;
        var itemsElement = header || footer ? _react2.default.createElement(
            'ul',
            { className: prefix + 'menu-content' },
            this.newChildren
        ) : this.newChildren;
        var footerElement = footer ? _react2.default.createElement(
            'li',
            { className: prefix + 'menu-footer' },
            footer
        ) : null;
        var shouldWrapItemsAndFooter = hozAlign === 'right' && !!header;

        if (rtl) {
            others.dir = 'rtl';
        }

        return _react2.default.createElement(
            'ul',
            _extends({ role: role, onBlur: this.onBlur, className: newClassName, onKeyDown: this.handleEnter, 'aria-multiselectable': selectMode === 'multiple' }, others),
            headerElement,
            shouldWrapItemsAndFooter ? _react2.default.createElement(
                'div',
                { className: prefix + 'menu-hoz-right' },
                itemsElement,
                footerElement
            ) : null,
            !shouldWrapItemsAndFooter ? itemsElement : null,
            !shouldWrapItemsAndFooter ? footerElement : null
        );
    };

    return Menu;
}(_react.Component), _class.isNextMenu = true, _class.propTypes = {
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    rtl: _propTypes2.default.bool,
    className: _propTypes2.default.string,
    /**
     * 菜单项和子菜单
     */
    children: _propTypes2.default.node,
    /**
     * 点击菜单项触发的回调函数
     * @param {String} key 点击的菜单项的 key 值
     * @param {Object} item 点击的菜单项对象
     * @param {Object} event 点击的事件对象
     */
    onItemClick: _propTypes2.default.func,
    /**
     * 当前打开的子菜单的 key 值
     */
    openKeys: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),
    /**
     * 初始打开的子菜单的 key 值
     */
    defaultOpenKeys: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),
    /**
     * 初始展开所有的子菜单，只在 mode 设置为 'inline' 以及 openMode 设置为 'multiple' 下生效，优先级高于 defaultOpenKeys
     */
    defaultOpenAll: _propTypes2.default.bool,
    /**
     * 打开或关闭子菜单触发的回调函数
     * @param {String} key 打开的所有子菜单的 key 值
     * @param {Object} extra 额外参数
     * @param {String} extra.key 当前操作子菜单的 key 值
     * @param {Boolean} extra.open 是否是打开
     */
    onOpen: _propTypes2.default.func,
    /**
     * 子菜单打开的模式
     */
    mode: _propTypes2.default.oneOf(['inline', 'popup']),
    /**
     * 子菜单打开的触发行为
     */
    triggerType: _propTypes2.default.oneOf(['click', 'hover']),
    /**
     * 展开内连子菜单的模式，同时可以展开一个子菜单还是多个子菜单，该属性仅在 mode 为 inline 时生效
     */
    openMode: _propTypes2.default.oneOf(['single', 'multiple']),
    /**
     * 内连子菜单缩进距离
     */
    inlineIndent: _propTypes2.default.number,
    inlineArrowDirection: _propTypes2.default.oneOf(['down', 'right']),
    /**
     * 是否自动让弹层的宽度和菜单项保持一致，如果弹层的宽度比菜单项小则和菜单项保持一致，如果宽度大于菜单项则不做处理
     */
    popupAutoWidth: _propTypes2.default.bool,
    /**
     * 弹层的对齐方式
     */
    popupAlign: _propTypes2.default.oneOf(['follow', 'outside']),
    /**
     * 弹层自定义 props
     */
    popupProps: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    /**
     * 弹出子菜单自定义 className
     */
    popupClassName: _propTypes2.default.string,
    /**
     * 弹出子菜单自定义 style
     */
    popupStyle: _propTypes2.default.object,
    /**
     * 当前选中菜单项的 key 值
     */
    selectedKeys: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),
    /**
     * 初始选中菜单项的 key 值
     */
    defaultSelectedKeys: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),
    /**
     * 选中或取消选中菜单项触发的回调函数
     * @param {Array} selectedKeys 选中的所有菜单项的值
     * @param {Object} item 选中或取消选中的菜单项
     * @param {Object} extra 额外参数
     * @param {Boolean} extra.select 是否是选中
     * @param {Array} extra.key 菜单项的 key
     * @param {Object} extra.label 菜单项的文本
     * @param {Array} extra.keyPath 菜单项 key 的路径
     */
    onSelect: _propTypes2.default.func,
    /**
     * 选中模式，单选还是多选，默认无值，不可选
     */
    selectMode: _propTypes2.default.oneOf(['single', 'multiple']),
    /**
     * 是否只能选择第一层菜单项（不能选择子菜单中的菜单项）
     */
    shallowSelect: _propTypes2.default.bool,
    /**
     * 是否显示选中图标，如果设置为 false 需配合配置平台设置选中时的背景色以示区分
     */
    hasSelectedIcon: _propTypes2.default.bool,
    labelToggleChecked: _propTypes2.default.bool,
    /**
     * 菜单第一层展示方向
     */
    direction: _propTypes2.default.oneOf(['ver', 'hoz']),
    /**
     * 横向菜单条 item 和 footer 的对齐方向，在 direction 设置为 'hoz' 并且 header 存在时生效
     */
    hozAlign: _propTypes2.default.oneOf(['left', 'right']),
    /**
     * 自定义菜单头部
     */
    header: _propTypes2.default.node,
    /**
     * 自定义菜单尾部
     */
    footer: _propTypes2.default.node,
    /**
     * 是否自动获得焦点
     */
    autoFocus: _propTypes2.default.bool,
    /**
     * 当前获得焦点的子菜单或菜单项 key 值
     */
    focusedKey: _propTypes2.default.string,
    focusable: _propTypes2.default.bool,
    onItemFocus: _propTypes2.default.func,
    onBlur: _propTypes2.default.func,
    onItemKeyDown: _propTypes2.default.func,
    expandAnimation: _propTypes2.default.bool,
    itemClassName: _propTypes2.default.string
}, _class.defaultProps = {
    prefix: 'next-',
    pure: false,
    defaultOpenKeys: [],
    defaultOpenAll: false,
    onOpen: noop,
    mode: 'inline',
    triggerType: 'click',
    openMode: 'multiple',
    inlineIndent: 20,
    inlineArrowDirection: 'down',
    popupAutoWidth: false,
    popupAlign: 'follow',
    popupProps: {},
    defaultSelectedKeys: [],
    onSelect: noop,
    shallowSelect: false,
    hasSelectedIcon: true,
    labelToggleChecked: true,
    direction: 'ver',
    hozAlign: 'left',
    autoFocus: false,
    focusable: true,
    onItemFocus: noop,
    onItemKeyDown: noop,
    onItemClick: noop,
    expandAnimation: true
}, _temp);
Menu.displayName = 'Menu';
exports.default = Menu;
module.exports = exports['default'];

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactTransitionGroup = __webpack_require__(52);

var _child = __webpack_require__(109);

var _child2 = _interopRequireDefault(_child);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};
var FirstChild = function FirstChild(props) {
    var childrenArray = _react2.default.Children.toArray(props.children);
    return childrenArray[0] || null;
};

/**
 * Animate
 */
var Animate = (_temp = _class = function (_Component) {
    _inherits(Animate, _Component);

    function Animate() {
        _classCallCheck(this, Animate);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    Animate.prototype.normalizeNames = function normalizeNames(names) {
        if (typeof names === 'string') {
            return {
                appear: names + '-appear',
                appearActive: names + '-appear-active',
                enter: names + '-enter',
                enterActive: names + '-enter-active',
                leave: names + '-leave',
                leaveActive: names + '-leave-active'
            };
        }
        if ((typeof names === 'undefined' ? 'undefined' : _typeof(names)) === 'object') {
            return {
                appear: names.appear,
                appearActive: names.appear + '-active',
                enter: '' + names.enter,
                enterActive: names.enter + '-active',
                leave: '' + names.leave,
                leaveActive: names.leave + '-active'
            };
        }
    };

    Animate.prototype.render = function render() {
        var _this2 = this;

        /* eslint-disable no-unused-vars */
        var _props = this.props,
            animation = _props.animation,
            children = _props.children,
            animationAppear = _props.animationAppear,
            singleMode = _props.singleMode,
            component = _props.component,
            beforeAppear = _props.beforeAppear,
            onAppear = _props.onAppear,
            afterAppear = _props.afterAppear,
            beforeEnter = _props.beforeEnter,
            onEnter = _props.onEnter,
            afterEnter = _props.afterEnter,
            beforeLeave = _props.beforeLeave,
            onLeave = _props.onLeave,
            afterLeave = _props.afterLeave,
            others = _objectWithoutProperties(_props, ['animation', 'children', 'animationAppear', 'singleMode', 'component', 'beforeAppear', 'onAppear', 'afterAppear', 'beforeEnter', 'onEnter', 'afterEnter', 'beforeLeave', 'onLeave', 'afterLeave']);
        /* eslint-enable no-unused-vars */

        var animateChildren = _react.Children.map(children, function (child) {
            return _react2.default.createElement(
                _child2.default,
                { key: child.key,
                    names: _this2.normalizeNames(animation),
                    onAppear: beforeAppear,
                    onAppearing: onAppear,
                    onAppeared: afterAppear,
                    onEnter: beforeEnter,
                    onEntering: onEnter,
                    onEntered: afterEnter,
                    onExit: beforeLeave,
                    onExiting: onLeave,
                    onExited: afterLeave },
                child
            );
        });

        return _react2.default.createElement(
            _reactTransitionGroup.TransitionGroup,
            _extends({ appear: animationAppear, component: singleMode ? FirstChild : component }, others),
            animateChildren
        );
    };

    return Animate;
}(_react.Component), _class.propTypes = {
    /**
     * 动画 className
     */
    animation: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),
    /**
     * 子元素第一次挂载时是否执行动画
     */
    animationAppear: _propTypes2.default.bool,
    /**
     * 包裹子元素的标签
     */
    component: _propTypes2.default.any,
    /**
     * 是否只有单个子元素，如果有多个子元素，请设置为 false
     */
    singleMode: _propTypes2.default.bool,
    /**
     * 子元素
     */
    children: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.arrayOf(_propTypes2.default.element)]),
    /**
     * 执行第一次挂载动画前触发的回调函数
     */
    beforeAppear: _propTypes2.default.func,
    /**
     * 执行第一次挂载动画，添加 xxx-appear-active 类名后触发的回调函数
     *  @param {HTMLElement} node 执行动画的 dom 元素
     */
    onAppear: _propTypes2.default.func,
    /**
     * 执行完第一次挂载动画后触发的函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    afterAppear: _propTypes2.default.func,
    /**
     * 执行进场动画前触发的回调函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    beforeEnter: _propTypes2.default.func,
    /**
     * 执行进场动画，添加 xxx-enter-active 类名后触发的回调函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    onEnter: _propTypes2.default.func,
    /**
     * 执行完进场动画后触发的回调函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    afterEnter: _propTypes2.default.func,
    /**
     * 执行离场动画前触发的回调函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    beforeLeave: _propTypes2.default.func,
    /**
     * 执行离场动画，添加 xxx-leave-active 类名后触发的回调函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    onLeave: _propTypes2.default.func,
    /**
     * 执行完离场动画后触发的回调函数
     * @param {HTMLElement} node 执行动画的 dom 元素
     */
    afterLeave: _propTypes2.default.func
}, _class.defaultProps = {
    animationAppear: true,
    component: 'div',
    singleMode: true,
    beforeAppear: noop,
    onAppear: noop,
    afterAppear: noop,
    beforeEnter: noop,
    onEnter: noop,
    afterEnter: noop,
    beforeLeave: noop,
    onLeave: noop,
    afterLeave: noop
}, _temp);
Animate.displayName = 'Animate';
exports.default = Animate;
module.exports = exports['default'];

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _CSSTransition = _interopRequireDefault(__webpack_require__(102));

var _ReplaceTransition = _interopRequireDefault(__webpack_require__(107));

var _TransitionGroup = _interopRequireDefault(__webpack_require__(56));

var _Transition = _interopRequireDefault(__webpack_require__(53));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

module.exports = {
  Transition: _Transition.default,
  TransitionGroup: _TransitionGroup.default,
  ReplaceTransition: _ReplaceTransition.default,
  CSSTransition: _CSSTransition.default
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

exports.__esModule = true;
exports.default = exports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = void 0;

var PropTypes = _interopRequireWildcard(__webpack_require__(1));

var _react = _interopRequireDefault(__webpack_require__(0));

var _reactDom = _interopRequireDefault(__webpack_require__(4));

var _reactLifecyclesCompat = __webpack_require__(54);

var _PropTypes = __webpack_require__(55);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }newObj.default = obj;return newObj;
  }
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];
  }return target;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;
  _defaults(subClass, superClass);
}

var UNMOUNTED = 'unmounted';
exports.UNMOUNTED = UNMOUNTED;
var EXITED = 'exited';
exports.EXITED = EXITED;
var ENTERING = 'entering';
exports.ENTERING = ENTERING;
var ENTERED = 'entered';
exports.ENTERED = ENTERED;
var EXITING = 'exiting';
/**
 * The Transition component lets you describe a transition from one component
 * state to another _over time_ with a simple declarative API. Most commonly
 * it's used to animate the mounting and unmounting of a component, but can also
 * be used to describe in-place transition states as well.
 *
 * By default the `Transition` component does not alter the behavior of the
 * component it renders, it only tracks "enter" and "exit" states for the components.
 * It's up to you to give meaning and effect to those states. For example we can
 * add styles to a component when it enters or exits:
 *
 * ```jsx
 * import Transition from 'react-transition-group/Transition';
 *
 * const duration = 300;
 *
 * const defaultStyle = {
 *   transition: `opacity ${duration}ms ease-in-out`,
 *   opacity: 0,
 * }
 *
 * const transitionStyles = {
 *   entering: { opacity: 0 },
 *   entered:  { opacity: 1 },
 * };
 *
 * const Fade = ({ in: inProp }) => (
 *   <Transition in={inProp} timeout={duration}>
 *     {(state) => (
 *       <div style={{
 *         ...defaultStyle,
 *         ...transitionStyles[state]
 *       }}>
 *         I'm a fade Transition!
 *       </div>
 *     )}
 *   </Transition>
 * );
 * ```
 *
 * As noted the `Transition` component doesn't _do_ anything by itself to its child component.
 * What it does do is track transition states over time so you can update the
 * component (such as by adding styles or classes) when it changes states.
 *
 * There are 4 main states a Transition can be in:
 *  - `'entering'`
 *  - `'entered'`
 *  - `'exiting'`
 *  - `'exited'`
 *
 * Transition state is toggled via the `in` prop. When `true` the component begins the
 * "Enter" stage. During this stage, the component will shift from its current transition state,
 * to `'entering'` for the duration of the transition and then to the `'entered'` stage once
 * it's complete. Let's take the following example:
 *
 * ```jsx
 * state = { in: false };
 *
 * toggleEnterState = () => {
 *   this.setState({ in: true });
 * }
 *
 * render() {
 *   return (
 *     <div>
 *       <Transition in={this.state.in} timeout={500} />
 *       <button onClick={this.toggleEnterState}>Click to Enter</button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the button is clicked the component will shift to the `'entering'` state and
 * stay there for 500ms (the value of `timeout`) before it finally switches to `'entered'`.
 *
 * When `in` is `false` the same thing happens except the state moves from `'exiting'` to `'exited'`.
 *
 * ## Timing
 *
 * Timing is often the trickiest part of animation, mistakes can result in slight delays
 * that are hard to pin down. A common example is when you want to add an exit transition,
 * you should set the desired final styles when the state is `'exiting'`. That's when the
 * transition to those styles will start and, if you matched the `timeout` prop with the
 * CSS Transition duration, it will end exactly when the state changes to `'exited'`.
 *
 * > **Note**: For simpler transitions the `Transition` component might be enough, but
 * > take into account that it's platform-agnostic, while the `CSSTransition` component
 * > [forces reflows](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
 * > in order to make more complex transitions more predictable. For example, even though
 * > classes `example-enter` and `example-enter-active` are applied immediately one after
 * > another, you can still transition from one to the other because of the forced reflow
 * > (read [this issue](https://github.com/reactjs/react-transition-group/issues/159#issuecomment-322761171)
 * > for more info). Take this into account when choosing between `Transition` and
 * > `CSSTransition`.
 */

exports.EXITING = EXITING;

var Transition =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Transition, _React$Component);

  function Transition(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context.transitionGroup; // In the context of a TransitionGroup all enters are really appears

    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;

    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }

    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }

  var _proto = Transition.prototype;

  _proto.getChildContext = function getChildContext() {
    return {
      transitionGroup: null // allows for nested Transitions

    };
  };

  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;

    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }

    return null;
  }; // getSnapshotBeforeUpdate(prevProps) {
  //   let nextStatus = null
  //   if (prevProps !== this.props) {
  //     const { status } = this.state
  //     if (this.props.in) {
  //       if (status !== ENTERING && status !== ENTERED) {
  //         nextStatus = ENTERING
  //       }
  //     } else {
  //       if (status === ENTERING || status === ENTERED) {
  //         nextStatus = EXITING
  //       }
  //     }
  //   }
  //   return { nextStatus }
  // }


  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;

    if (prevProps !== this.props) {
      var status = this.state.status;

      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }

    this.updateStatus(false, nextStatus);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };

  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;

    if (timeout != null && typeof timeout !== 'number') {
      exit = timeout.exit;
      enter = timeout.enter;
      appear = timeout.appear;
    }

    return {
      exit: exit,
      enter: enter,
      appear: appear
    };
  };

  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }

    if (nextStatus !== null) {
      // nextStatus will always be ENTERING or EXITING.
      this.cancelNextCallback();

      var node = _reactDom.default.findDOMNode(this);

      if (nextStatus === ENTERING) {
        this.performEnter(node, mounting);
      } else {
        this.performExit(node);
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };

  _proto.performEnter = function performEnter(node, mounting) {
    var _this2 = this;

    var enter = this.props.enter;
    var appearing = this.context.transitionGroup ? this.context.transitionGroup.isMounting : mounting;
    var timeouts = this.getTimeouts(); // no enter animation skip right to ENTERED
    // if we are mounting and running this it means appear _must_ be set

    if (!mounting && !enter) {
      this.safeSetState({
        status: ENTERED
      }, function () {
        _this2.props.onEntered(node);
      });
      return;
    }

    this.props.onEnter(node, appearing);
    this.safeSetState({
      status: ENTERING
    }, function () {
      _this2.props.onEntering(node, appearing); // FIXME: appear timeout?


      _this2.onTransitionEnd(node, timeouts.enter, function () {
        _this2.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(node, appearing);
        });
      });
    });
  };

  _proto.performExit = function performExit(node) {
    var _this3 = this;

    var exit = this.props.exit;
    var timeouts = this.getTimeouts(); // no exit animation skip right to EXITED

    if (!exit) {
      this.safeSetState({
        status: EXITED
      }, function () {
        _this3.props.onExited(node);
      });
      return;
    }

    this.props.onExit(node);
    this.safeSetState({
      status: EXITING
    }, function () {
      _this3.props.onExiting(node);

      _this3.onTransitionEnd(node, timeouts.exit, function () {
        _this3.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(node);
        });
      });
    });
  };

  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };

  _proto.safeSetState = function safeSetState(nextState, callback) {
    // This shouldn't be necessary, but there are weird race conditions with
    // setState callbacks and unmounting in testing, so always make sure that
    // we can cancel any pending setState callbacks after we unmount.
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };

  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;

    var active = true;

    this.nextCallback = function (event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };

    this.nextCallback.cancel = function () {
      active = false;
    };

    return this.nextCallback;
  };

  _proto.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {
    this.setNextCallback(handler);

    if (node) {
      if (this.props.addEndListener) {
        this.props.addEndListener(node, this.nextCallback);
      }

      if (timeout != null) {
        setTimeout(this.nextCallback, timeout);
      }
    } else {
      setTimeout(this.nextCallback, 0);
    }
  };

  _proto.render = function render() {
    var status = this.state.status;

    if (status === UNMOUNTED) {
      return null;
    }

    var _this$props = this.props,
        children = _this$props.children,
        childProps = _objectWithoutPropertiesLoose(_this$props, ["children"]); // filter props for Transtition


    delete childProps.in;
    delete childProps.mountOnEnter;
    delete childProps.unmountOnExit;
    delete childProps.appear;
    delete childProps.enter;
    delete childProps.exit;
    delete childProps.timeout;
    delete childProps.addEndListener;
    delete childProps.onEnter;
    delete childProps.onEntering;
    delete childProps.onEntered;
    delete childProps.onExit;
    delete childProps.onExiting;
    delete childProps.onExited;

    if (typeof children === 'function') {
      return children(status, childProps);
    }

    var child = _react.default.Children.only(children);

    return _react.default.cloneElement(child, childProps);
  };

  return Transition;
}(_react.default.Component);

Transition.contextTypes = {
  transitionGroup: PropTypes.object
};
Transition.childContextTypes = {
  transitionGroup: function transitionGroup() {}
};
Transition.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * A `function` child can be used instead of a React element.
   * This function is called with the current transition status
   * ('entering', 'entered', 'exiting', 'exited', 'unmounted'), which can be used
   * to apply context specific props to a component.
   *
   * ```jsx
   * <Transition timeout={150}>
   *   {(status) => (
   *     <MyComponent className={`fade fade-${status}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,

  /**
   * Show the component; triggers the enter or exit states
   */
  in: PropTypes.bool,

  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: PropTypes.bool,

  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: PropTypes.bool,

  /**
   * Normally a component is not transitioned if it is shown when the `<Transition>` component mounts.
   * If you want to transition on the first mount set `appear` to `true`, and the
   * component will transition in as soon as the `<Transition>` mounts.
   *
   * > Note: there are no specific "appear" states. `appear` only adds an additional `enter` transition.
   */
  appear: PropTypes.bool,

  /**
   * Enable or disable enter transitions.
   */
  enter: PropTypes.bool,

  /**
   * Enable or disable exit transitions.
   */
  exit: PropTypes.bool,

  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided
   *
   * You may specify a single timeout for all transitions like: `timeout={500}`,
   * or individually like:
   *
   * ```jsx
   * timeout={{
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * @type {number | { enter?: number, exit?: number }}
   */
  timeout: function timeout(props) {
    var pt = process.env.NODE_ENV !== "production" ? _PropTypes.timeoutsShape : {};;
    if (!props.addEndListener) pt = pt.isRequired;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return pt.apply(void 0, [props].concat(args));
  },

  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. **Note:** Timeouts are still used as a fallback if provided.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: PropTypes.func,

  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: PropTypes.func,

  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,

  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: PropTypes.func,

  /**
   * Callback fired before the "exiting" status is applied.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: PropTypes.func,

  /**
   * Callback fired after the "exiting" status is applied.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: PropTypes.func,

  /**
   * Callback fired after the "exited" status is applied.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: PropTypes.func // Name the function so it is clearer in the documentation

} : {};

function noop() {}

Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = 0;
Transition.EXITED = 1;
Transition.ENTERING = 2;
Transition.ENTERED = 3;
Transition.EXITING = 4;

var _default = (0, _reactLifecyclesCompat.polyfill)(Transition);

exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function componentWillMount() {
  // Call this.constructor.gDSFP to support sub-classes.
  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
  if (state !== null && state !== undefined) {
    this.setState(state);
  }
}

function componentWillReceiveProps(nextProps) {
  // Call this.constructor.gDSFP to support sub-classes.
  // Use the setState() updater to ensure state isn't stale in certain edge cases.
  function updater(prevState) {
    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
    return state !== null && state !== undefined ? state : null;
  }
  // Binding "this" is important for shallow renderer support.
  this.setState(updater.bind(this));
}

function componentWillUpdate(nextProps, nextState) {
  try {
    var prevProps = this.props;
    var prevState = this.state;
    this.props = nextProps;
    this.state = nextState;
    this.__reactInternalSnapshotFlag = true;
    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(prevProps, prevState);
  } finally {
    this.props = prevProps;
    this.state = prevState;
  }
}

// React may warn about cWM/cWRP/cWU methods being deprecated.
// Add a flag to suppress these warnings for this special case.
componentWillMount.__suppressDeprecationWarning = true;
componentWillReceiveProps.__suppressDeprecationWarning = true;
componentWillUpdate.__suppressDeprecationWarning = true;

function polyfill(Component) {
  var prototype = Component.prototype;

  if (!prototype || !prototype.isReactComponent) {
    throw new Error('Can only polyfill class components');
  }

  if (typeof Component.getDerivedStateFromProps !== 'function' && typeof prototype.getSnapshotBeforeUpdate !== 'function') {
    return Component;
  }

  // If new component APIs are defined, "unsafe" lifecycles won't be called.
  // Error if any of these lifecycles are present,
  // Because they would work differently between older and newer (16.3+) versions of React.
  var foundWillMountName = null;
  var foundWillReceivePropsName = null;
  var foundWillUpdateName = null;
  if (typeof prototype.componentWillMount === 'function') {
    foundWillMountName = 'componentWillMount';
  } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {
    foundWillMountName = 'UNSAFE_componentWillMount';
  }
  if (typeof prototype.componentWillReceiveProps === 'function') {
    foundWillReceivePropsName = 'componentWillReceiveProps';
  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {
    foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
  }
  if (typeof prototype.componentWillUpdate === 'function') {
    foundWillUpdateName = 'componentWillUpdate';
  } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {
    foundWillUpdateName = 'UNSAFE_componentWillUpdate';
  }
  if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
    var componentName = Component.displayName || Component.name;
    var newApiName = typeof Component.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';

    throw Error('Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' + componentName + ' uses ' + newApiName + ' but also contains the following legacy lifecycles:' + (foundWillMountName !== null ? '\n  ' + foundWillMountName : '') + (foundWillReceivePropsName !== null ? '\n  ' + foundWillReceivePropsName : '') + (foundWillUpdateName !== null ? '\n  ' + foundWillUpdateName : '') + '\n\nThe above lifecycles should be removed. Learn more about this warning here:\n' + 'https://fb.me/react-async-component-lifecycle-hooks');
  }

  // React <= 16.2 does not support static getDerivedStateFromProps.
  // As a workaround, use cWM and cWRP to invoke the new static lifecycle.
  // Newer versions of React will ignore these lifecycles if gDSFP exists.
  if (typeof Component.getDerivedStateFromProps === 'function') {
    prototype.componentWillMount = componentWillMount;
    prototype.componentWillReceiveProps = componentWillReceiveProps;
  }

  // React <= 16.2 does not support getSnapshotBeforeUpdate.
  // As a workaround, use cWU to invoke the new lifecycle.
  // Newer versions of React will ignore that lifecycle if gSBU exists.
  if (typeof prototype.getSnapshotBeforeUpdate === 'function') {
    if (typeof prototype.componentDidUpdate !== 'function') {
      throw new Error('Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype');
    }

    prototype.componentWillUpdate = componentWillUpdate;

    var componentDidUpdate = prototype.componentDidUpdate;

    prototype.componentDidUpdate = function componentDidUpdatePolyfill(prevProps, prevState, maybeSnapshot) {
      // 16.3+ will not execute our will-update method;
      // It will pass a snapshot value to did-update though.
      // Older versions will require our polyfilled will-update value.
      // We need to handle both cases, but can't just check for the presence of "maybeSnapshot",
      // Because for <= 15.x versions this might be a "prevContext" object.
      // We also can't just check "__reactInternalSnapshot",
      // Because get-snapshot might return a falsy value.
      // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.
      var snapshot = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : maybeSnapshot;

      componentDidUpdate.call(this, prevProps, prevState, snapshot);
    };
  }

  return Component;
}

exports.polyfill = polyfill;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.transitionTimeout = transitionTimeout;
exports.classNamesShape = exports.timeoutsShape = void 0;

var _propTypes = _interopRequireDefault(__webpack_require__(1));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function transitionTimeout(transitionType) {
  var timeoutPropName = 'transition' + transitionType + 'Timeout';
  var enabledPropName = 'transition' + transitionType;
  return function (props) {
    // If the transition is enabled
    if (props[enabledPropName]) {
      // If no timeout duration is provided
      if (props[timeoutPropName] == null) {
        return new Error(timeoutPropName + ' wasn\'t supplied to CSSTransitionGroup: ' + 'this can cause unreliable animations and won\'t be supported in ' + 'a future version of React. See ' + 'https://fb.me/react-animation-transition-group-timeout for more ' + 'information.'); // If the duration isn't a number
      } else if (typeof props[timeoutPropName] !== 'number') {
        return new Error(timeoutPropName + ' must be a number (in milliseconds)');
      }
    }

    return null;
  };
}

var timeoutsShape = _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.shape({
  enter: _propTypes.default.number,
  exit: _propTypes.default.number
}).isRequired]);

exports.timeoutsShape = timeoutsShape;

var classNamesShape = _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.shape({
  enter: _propTypes.default.string,
  exit: _propTypes.default.string,
  active: _propTypes.default.string
}), _propTypes.default.shape({
  enter: _propTypes.default.string,
  enterDone: _propTypes.default.string,
  enterActive: _propTypes.default.string,
  exit: _propTypes.default.string,
  exitDone: _propTypes.default.string,
  exitActive: _propTypes.default.string
})]);

exports.classNamesShape = classNamesShape;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

exports.__esModule = true;
exports.default = void 0;

var _propTypes = _interopRequireDefault(__webpack_require__(1));

var _react = _interopRequireDefault(__webpack_require__(0));

var _reactLifecyclesCompat = __webpack_require__(54);

var _ChildMapping = __webpack_require__(108);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];
  }return target;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;
  _defaults(subClass, superClass);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return self;
}

var values = Object.values || function (obj) {
  return Object.keys(obj).map(function (k) {
    return obj[k];
  });
};

var propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: _propTypes.default.any,

  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   */
  children: _propTypes.default.node,

  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: _propTypes.default.bool,

  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: _propTypes.default.bool,

  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: _propTypes.default.bool,

  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: _propTypes.default.func
} : {};;
var defaultProps = {
  component: 'div',
  childFactory: function childFactory(child) {
    return child;
  }
  /**
   * The `<TransitionGroup>` component manages a set of transition components
   * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
   * components, `<TransitionGroup>` is a state machine for managing the mounting
   * and unmounting of components over time.
   *
   * Consider the example below. As items are removed or added to the TodoList the
   * `in` prop is toggled automatically by the `<TransitionGroup>`.
   *
   * Note that `<TransitionGroup>`  does not define any animation behavior!
   * Exactly _how_ a list item animates is up to the individual transition
   * component. This means you can mix and match animations across different list
   * items.
   */

};

var TransitionGroup =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(TransitionGroup, _React$Component);

  function TransitionGroup(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;

    var handleExited = _this.handleExited.bind(_assertThisInitialized(_assertThisInitialized(_this))); // Initial children should all be entering, dependent on appear


    _this.state = {
      handleExited: handleExited,
      firstRender: true
    };
    return _this;
  }

  var _proto = TransitionGroup.prototype;

  _proto.getChildContext = function getChildContext() {
    return {
      transitionGroup: {
        isMounting: !this.appeared
      }
    };
  };

  _proto.componentDidMount = function componentDidMount() {
    this.appeared = true;
    this.mounted = true;
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };

  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children,
        handleExited = _ref.handleExited,
        firstRender = _ref.firstRender;
    return {
      children: firstRender ? (0, _ChildMapping.getInitialChildMapping)(nextProps, handleExited) : (0, _ChildMapping.getNextChildMapping)(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };

  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = (0, _ChildMapping.getChildMapping)(this.props.children);
    if (child.key in currentChildMapping) return;

    if (child.props.onExited) {
      child.props.onExited(node);
    }

    if (this.mounted) {
      this.setState(function (state) {
        var children = _extends({}, state.children);

        delete children[child.key];
        return {
          children: children
        };
      });
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        Component = _this$props.component,
        childFactory = _this$props.childFactory,
        props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);

    var children = values(this.state.children).map(childFactory);
    delete props.appear;
    delete props.enter;
    delete props.exit;

    if (Component === null) {
      return children;
    }

    return _react.default.createElement(Component, props, children);
  };

  return TransitionGroup;
}(_react.default.Component);

TransitionGroup.childContextTypes = {
  transitionGroup: _propTypes.default.object.isRequired
};
TransitionGroup.propTypes = process.env.NODE_ENV !== "production" ? propTypes : {};
TransitionGroup.defaultProps = defaultProps;

var _default = (0, _reactLifecyclesCompat.polyfill)(TransitionGroup);

exports.default = _default;
module.exports = exports["default"];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _overlay = __webpack_require__(15);

var _overlay2 = _interopRequireDefault(_overlay);

var _util = __webpack_require__(2);

var _item = __webpack_require__(14);

var _item2 = _interopRequireDefault(_item);

var _selectableItem = __webpack_require__(22);

var _selectableItem2 = _interopRequireDefault(_selectableItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var bindCtx = _util.func.bindCtx;
var setStyle = _util.dom.setStyle;

var Popup = _overlay2.default.Popup;

/**
 * Menu.PopupItem
 * @order 2
 */
var PopupItem = (_temp = _class = function (_Component) {
    _inherits(PopupItem, _Component);

    function PopupItem(props) {
        _classCallCheck(this, PopupItem);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        bindCtx(_this, ['handleOpen', 'handlePopupOpen', 'handlePopupClose', 'getPopup']);
        return _this;
    }

    PopupItem.prototype.getPopup = function getPopup(ref) {
        this.popup = ref;
    };

    PopupItem.prototype.getOpen = function getOpen() {
        var _props = this.props,
            _key = _props._key,
            root = _props.root;
        var openKeys = root.state.openKeys;


        return openKeys.indexOf(_key) > -1;
    };

    PopupItem.prototype.getPopupProps = function getPopupProps() {
        var popupProps = this.props.root.props.popupProps;

        if (typeof popupProps === 'function') {
            popupProps = popupProps(this.props);
        }
        return popupProps;
    };

    PopupItem.prototype.handleOpen = function handleOpen(open, triggerType, e) {
        var _props2 = this.props,
            _key = _props2._key,
            root = _props2.root;

        root.handleOpen(_key, open, triggerType, e);

        var popupProps = this.popupProps;
        popupProps.onVisibleChange && popupProps.onVisibleChange(open, triggerType, e);
    };

    PopupItem.prototype.handlePopupOpen = function handlePopupOpen() {
        var _props3 = this.props,
            root = _props3.root,
            level = _props3.level,
            align = _props3.align,
            autoWidth = _props3.autoWidth;
        var _root$props = root.props,
            rootPopupAutoWidth = _root$props.popupAutoWidth,
            rootPopupAlign = _root$props.popupAlign,
            direction = _root$props.direction;

        var popupAlign = align || rootPopupAlign;
        var popupAutoWidth = 'autoWidth' in this.props ? autoWidth : rootPopupAutoWidth;
        var itemNode = (0, _reactDom.findDOMNode)(this);
        var menuNode = itemNode.parentNode;
        this.popupNode = this.popup.getInstance().overlay.getInstance().getContentNode();
        root.popupNodes.push(this.popupNode);

        if (popupAutoWidth) {
            var targetNode = direction === 'hoz' && level === 1 ? itemNode : menuNode;

            if (targetNode.offsetWidth > this.popupNode.offsetWidth) {
                setStyle(this.popupNode, 'width', targetNode.offsetWidth + 'px');
            }
        }
        if (popupAlign === 'outside' && !(direction === 'hoz' && level === 1)) {
            setStyle(this.popupNode, 'height', menuNode.offsetHeight + 'px');
            setStyle(this.popupNode, 'overflow-y', 'scroll');
        }
        // removeClass(this.popupNode, `${prefix}hide`);

        var popupProps = this.popupProps;
        popupProps.onOpen && popupProps.onOpen();
    };

    PopupItem.prototype.handlePopupClose = function handlePopupClose() {
        var root = this.props.root;

        var popupNodes = root.popupNodes;
        var index = popupNodes.indexOf(this.popupNode);
        index > -1 && popupNodes.splice(index, 1);

        var popupProps = this.popupProps;
        popupProps.onClose && popupProps.onClose();
    };

    PopupItem.prototype.renderItem = function renderItem(selectable, children, others) {
        var _props4 = this.props,
            _key = _props4._key,
            root = _props4.root,
            level = _props4.level,
            label = _props4.label,
            className = _props4.className;
        var prefix = root.props.prefix;

        var NewItem = selectable ? _selectableItem2.default : _item2.default;
        var open = this.getOpen();

        var itemProps = {
            'aria-haspopup': true,
            'aria-expanded': open,
            _key: _key,
            root: root,
            level: level,
            type: 'submenu'
        };
        if (open) {
            var _cx;

            itemProps.className = (0, _classnames2.default)((_cx = {}, _cx[prefix + 'opened'] = true, _cx[className] = !!className, _cx));
        } else {
            itemProps.className = className;
        }

        return _react2.default.createElement(
            NewItem,
            _extends({}, itemProps, others),
            _react2.default.createElement(
                'span',
                { className: prefix + 'menu-item-text' },
                label
            ),
            children
        );
    };

    PopupItem.prototype.renderPopup = function renderPopup(trigger, triggerType, positionProps, children) {
        var _this2 = this;

        var _props5 = this.props,
            root = _props5.root,
            level = _props5.level,
            selectable = _props5.selectable;
        var direction = root.props.direction;

        this.popupProps = this.getPopupProps();
        var open = this.getOpen();

        if (direction === 'hoz' && level === 1 && selectable) {
            positionProps.target = function () {
                return (0, _reactDom.findDOMNode)(_this2);
            };
        }

        return _react2.default.createElement(
            Popup,
            _extends({ ref: this.getPopup
            }, positionProps, this.popupProps, {
                canCloseByEsc: false,
                trigger: trigger,
                triggerType: triggerType,
                visible: open,
                onVisibleChange: this.handleOpen,
                onOpen: this.handlePopupOpen,
                onClose: this.handlePopupClose }),
            children
        );
    };

    PopupItem.prototype.render = function render() {
        var _this3 = this;

        var _props6 = this.props,
            root = _props6.root,
            level = _props6.level,
            hasSubMenu = _props6.hasSubMenu,
            selectableFromProps = _props6.selectable,
            children = _props6.children,
            triggerType = _props6.triggerType,
            align = _props6.align,
            rtl = _props6.rtl;

        var others = _util.obj.pickOthers(Object.keys(PopupItem.propTypes), this.props);
        var _root$props2 = root.props,
            prefix = _root$props2.prefix,
            selectMode = _root$props2.selectMode,
            direction = _root$props2.direction,
            rootPopupAlign = _root$props2.popupAlign,
            rootTriggerType = _root$props2.triggerType;

        var popupAlign = align || rootPopupAlign;
        var newTriggerType = triggerType || (hasSubMenu ? rootTriggerType : 'hover');
        var newChildren = Array.isArray(children) ? children[0] : children;
        // let newChildren = Array.isArray(children) ? children[0] : children;
        // newChildren = cloneElement(newChildren, {
        //     className: cx({
        //         [`${prefix}menu-popup-content`]: true,
        //         [newChildren.props.className]: !!newChildren.props.className,
        //         [`${prefix}hide`]: popupAutoWidth || popupAlign === 'outside'
        //     })
        // });
        var selectable = selectMode && selectableFromProps;
        var triggerIsIcon = selectable && newTriggerType === 'click';
        var open = this.getOpen();

        var positionProps = {};
        var arrowProps = void 0;

        if (direction === 'hoz' && level === 1) {
            var _cx2;

            positionProps.align = 'tl bl';
            positionProps.offset = [0, 0];

            arrowProps = {
                type: 'arrow-down',
                className: (0, _classnames2.default)((_cx2 = {}, _cx2[prefix + 'menu-hoz-icon-arrow'] = true, _cx2[prefix + 'open'] = open, _cx2))
            };
        } else {
            if (popupAlign === 'outside') {
                positionProps.target = function () {
                    return (0, _reactDom.findDOMNode)(root);
                };
                positionProps.align = 'tl tr';

                rtl ? positionProps.offset = [-2, 0] : positionProps.offset = [2, 0];
            } else {
                if (triggerIsIcon) {
                    positionProps.target = function () {
                        return (0, _reactDom.findDOMNode)(_this3);
                    };
                }
                positionProps.align = 'tl tr';

                rtl ? positionProps.offset = [2, -8] : positionProps.offset = [-2, -8];
            }

            arrowProps = {
                type: 'arrow-right',
                className: prefix + 'menu-icon-arrow'
            };
        }

        var arrow = _react2.default.createElement(_icon2.default, arrowProps);
        var trigger = triggerIsIcon ? arrow : this.renderItem(selectable, arrow, others);
        var popup = this.renderPopup(trigger, newTriggerType, positionProps, newChildren);
        return triggerIsIcon ? this.renderItem(selectable, popup, others) : popup;
    };

    return PopupItem;
}(_react.Component), _class.menuChildType = 'submenu', _class.propTypes = {
    _key: _propTypes2.default.string,
    root: _propTypes2.default.object,
    level: _propTypes2.default.number,
    hasSubMenu: _propTypes2.default.bool,
    rtl: _propTypes2.default.bool,
    selectable: _propTypes2.default.bool,
    /**
     * 标签内容
     */
    label: _propTypes2.default.node,
    /**
     * 自定义弹层内容
     */
    children: _propTypes2.default.node,
    className: _propTypes2.default.string,
    triggerType: _propTypes2.default.oneOf(['click', 'hover']),
    align: _propTypes2.default.oneOf(['outside', 'follow']),
    autoWidth: _propTypes2.default.bool
}, _class.defaultProps = {
    selectable: false
}, _temp);
PopupItem.displayName = 'PopupItem';
exports.default = PopupItem;
module.exports = exports['default'];

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _checkbox = __webpack_require__(37);

var _checkbox2 = _interopRequireDefault(_checkbox);

var _radio = __webpack_require__(61);

var _radio2 = _interopRequireDefault(_radio);

var _util = __webpack_require__(2);

var _item = __webpack_require__(14);

var _item2 = _interopRequireDefault(_item);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = {};
var bindCtx = _util.func.bindCtx;
var pickOthers = _util.obj.pickOthers;
var CheckableItem = (_temp = _class = function (_Component) {
    _inherits(CheckableItem, _Component);

    function CheckableItem(props) {
        _classCallCheck(this, CheckableItem);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        bindCtx(_this, ['stopPropagation', 'handleKeyDown', 'handleClick']);
        return _this;
    }

    CheckableItem.prototype.stopPropagation = function stopPropagation(e) {
        e.stopPropagation();
    };

    CheckableItem.prototype.handleCheck = function handleCheck(e) {
        var _props = this.props,
            checkType = _props.checkType,
            checked = _props.checked,
            onChange = _props.onChange;

        if (!(checkType === 'radio' && checked)) {
            onChange(!checked, e);
        }
    };

    CheckableItem.prototype.handleKeyDown = function handleKeyDown(e) {
        if (e.keyCode === _util.KEYCODE.SPACE && !this.props.checkDisabled) {
            this.handleCheck(e);
        }

        this.props.onKeyDown && this.props.onKeyDown(e);
    };

    CheckableItem.prototype.handleClick = function handleClick(e) {
        this.handleCheck(e);

        this.props.onClick && this.props.onClick(e);
    };

    CheckableItem.prototype.renderCheck = function renderCheck() {
        var _props2 = this.props,
            root = _props2.root,
            checked = _props2.checked,
            indeterminate = _props2.indeterminate,
            disabled = _props2.disabled,
            checkType = _props2.checkType,
            checkDisabled = _props2.checkDisabled,
            onChange = _props2.onChange;
        var labelToggleChecked = root.props.labelToggleChecked;

        var Check = checkType === 'radio' ? _radio2.default : _checkbox2.default;

        var checkProps = {
            tabIndex: '-1',
            checked: checked,
            disabled: disabled || checkDisabled
        };
        if (checkType === 'checkbox') {
            checkProps.indeterminate = indeterminate;
        }
        if (!labelToggleChecked) {
            checkProps.onChange = onChange;
            checkProps.onClick = this.stopPropagation;
        }

        return _react2.default.createElement(Check, checkProps);
    };

    CheckableItem.prototype.render = function render() {
        var _props3 = this.props,
            _key = _props3._key,
            root = _props3.root,
            checked = _props3.checked,
            disabled = _props3.disabled,
            onClick = _props3.onClick,
            helper = _props3.helper,
            children = _props3.children;
        var _root$props = root.props,
            prefix = _root$props.prefix,
            labelToggleChecked = _root$props.labelToggleChecked;

        var others = pickOthers(Object.keys(CheckableItem.propTypes), this.props);

        var newProps = _extends({
            _key: _key,
            root: root,
            disabled: disabled,
            type: 'item',
            onClick: onClick,
            onKeyDown: this.handleKeyDown
        }, others);
        if (labelToggleChecked && !disabled) {
            newProps.onClick = this.handleClick;
        }

        return _react2.default.createElement(
            _item2.default,
            _extends({ 'aria-checked': checked }, newProps),
            this.renderCheck(),
            _react2.default.createElement(
                'span',
                { className: prefix + 'menu-item-text' },
                children
            ),
            helper ? _react2.default.createElement(
                'div',
                { className: prefix + 'menu-item-helper' },
                helper
            ) : null
        );
    };

    return CheckableItem;
}(_react.Component), _class.propTypes = {
    _key: _propTypes2.default.string,
    root: _propTypes2.default.object,
    disabled: _propTypes2.default.bool,
    inlineIndent: _propTypes2.default.number,
    checked: _propTypes2.default.bool,
    indeterminate: _propTypes2.default.bool,
    onChange: _propTypes2.default.func,
    checkType: _propTypes2.default.oneOf(['checkbox', 'radio']),
    checkDisabled: _propTypes2.default.bool,
    helper: _propTypes2.default.node,
    children: _propTypes2.default.node,
    onKeyDown: _propTypes2.default.func,
    onClick: _propTypes2.default.func
}, _class.defaultProps = {
    disabled: false,
    checked: false,
    indeterminate: false,
    checkType: 'checkbox',
    checkDisabled: false,
    onChange: noop
}, _temp);
CheckableItem.displayName = 'CheckableItem';
exports.default = CheckableItem;
module.exports = exports['default'];

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _mixinUiState = __webpack_require__(60);

var _mixinUiState2 = _interopRequireDefault(_mixinUiState);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = _util.func.noop;
function isChecked(selectedValue, value) {
    return selectedValue.indexOf(value) > -1;
}
/**
 * Checkbox
 * @order 1
 */
var Checkbox = (_temp = _class = function (_UIState) {
    _inherits(Checkbox, _UIState);

    function Checkbox(props, context) {
        _classCallCheck(this, Checkbox);

        var _this = _possibleConstructorReturn(this, _UIState.call(this, props));

        var checked = void 0,
            indeterminate = void 0;
        if (context.__group__) {
            indeterminate = false;
            checked = isChecked(context.selectedValue, props.value);
        } else {
            if ('checked' in props) {
                checked = props.checked;
            } else {
                checked = props.defaultChecked;
            }

            if ('indeterminate' in props) {
                indeterminate = props.indeterminate;
            } else {
                indeterminate = props.defaultIndeterminate;
            }
        }

        _this.state = {
            checked: checked,
            indeterminate: indeterminate
        };

        _this.disabled = props.disabled || context.__group__ && 'disabled' in context && context.disabled;
        _this.onChange = _this.onChange.bind(_this);
        return _this;
    }

    Checkbox.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
        if (nextContext.__group__) {
            if ('selectedValue' in nextContext) {
                this.setState({
                    checked: isChecked(nextContext.selectedValue, nextProps.value)
                });
            }
            this.disabled = nextProps.disabled || 'disabled' in nextContext && nextContext.disabled;
        } else {
            if ('checked' in nextProps) {
                this.setState({
                    checked: nextProps.checked
                });
            }
            if ('indeterminate' in nextProps) {
                this.setState({
                    indeterminate: nextProps.indeterminate
                });
            }
            this.disabled = nextProps.disabled;
        }
    };

    Checkbox.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState, nextContext) {
        var shallowEqual = _util.obj.shallowEqual;

        return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState) || !shallowEqual(this.context, nextContext);
    };

    Checkbox.prototype.onChange = function onChange(e) {
        var checked = e.target.checked;
        var value = this.props.value;
        if (this.disabled) {
            return;
        }
        if (this.context.__group__) {
            this.context.onChange(value, e);
        } else {
            if (!('checked' in this.props)) {
                this.setState({
                    checked: checked
                });
            }

            if (!('indeterminate' in this.props)) {
                this.setState({
                    indeterminate: false
                });
            }
            this.props.onChange(checked, e);
        }
    };

    Checkbox.prototype.render = function render() {
        var _classnames;

        /* eslint-disable no-unused-vars */
        var _props = this.props,
            id = _props.id,
            className = _props.className,
            children = _props.children,
            style = _props.style,
            label = _props.label,
            onMouseEnter = _props.onMouseEnter,
            onMouseLeave = _props.onMouseLeave,
            rtl = _props.rtl,
            otherProps = _objectWithoutProperties(_props, ['id', 'className', 'children', 'style', 'label', 'onMouseEnter', 'onMouseLeave', 'rtl']);

        var checked = !!this.state.checked;
        var disabled = this.disabled;
        var indeterminate = !!this.state.indeterminate;
        var prefix = this.context.prefix || this.props.prefix;

        var others = _util.obj.pickOthers(Checkbox.propTypes, otherProps);
        var othersData = _util.obj.pickAttrsWith(others, 'data-');

        var childInput = _react2.default.createElement('input', _extends({}, _util.obj.pickOthers(Checkbox.propTypes, otherProps), {
            id: id,
            disabled: disabled,
            checked: checked,
            type: 'checkbox',
            onChange: this.onChange,
            'aria-checked': indeterminate ? 'mixed' : checked,
            className: prefix + 'checkbox-input'
        }));

        // disable 无状态操作
        if (!disabled) {
            childInput = this.getStateElement(childInput);
        }
        var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'checkbox-wrapper'] = true, _classnames[className] = !!className, _classnames.checked = checked, _classnames.disabled = disabled, _classnames.indeterminate = indeterminate, _classnames[this.getStateClassName()] = true, _classnames));
        var labelCls = prefix + 'checkbox-label';
        var type = indeterminate ? 'semi-select' : 'select';

        return _react2.default.createElement(
            'label',
            _extends({}, othersData, {
                className: cls,
                style: style,
                onMouseEnter: onMouseEnter,
                onMouseLeave: onMouseLeave
            }),
            _react2.default.createElement(
                'span',
                { className: prefix + 'checkbox' },
                _react2.default.createElement(
                    'span',
                    { className: prefix + 'checkbox-inner' },
                    _react2.default.createElement(_icon2.default, { type: type, size: 'xs', className: indeterminate ? 'zoomIn' : '' })
                ),
                childInput
            ),
            [label, children].map(function (item, i) {
                return item ? _react2.default.createElement(
                    'span',
                    { key: i, className: labelCls },
                    item
                ) : null;
            })
        );
    };

    return Checkbox;
}(_mixinUiState2.default), _class.displayName = 'Checkbox', _class.propTypes = {
    prefix: _propTypes2.default.string,
    rtl: _propTypes2.default.bool,
    /**
     * 自定义类名
     */
    className: _propTypes2.default.string,
    /**
     * checkbox id, 挂载在input上
     */
    id: _propTypes2.default.string,
    /**
     * 自定义内敛样式
     */
    style: _propTypes2.default.object,
    /**
     * 选中状态
     */
    checked: _propTypes2.default.bool,
    /**
     * 默认选中状态
     */
    defaultChecked: _propTypes2.default.bool,
    /**
     * 禁用
     */
    disabled: _propTypes2.default.bool,
    /**
     * 通过属性配置label，
     */
    label: _propTypes2.default.node,
    /**
     * Checkbox 的中间状态，只会影响到 Checkbox 的样式，并不影响其 checked 属性
     */
    indeterminate: _propTypes2.default.bool,
    /**
     *  Checkbox 的默认中间态，只会影响到 Checkbox 的样式，并不影响其 checked 属性
     */
    defaultIndeterminate: _propTypes2.default.bool,
    /**
     * 状态变化时触发的事件
     * @param {Boolean} checked 是否选中
     * @param {Event} e Dom 事件对象
     */
    onChange: _propTypes2.default.func,
    /**
     * 鼠标进入enter事件
     * @param {Event} e Dom 事件对象
     */
    onMouseEnter: _propTypes2.default.func,
    /**
     * 鼠标离开Leave事件
     * @param {Event} e Dom 事件对象
     */
    onMouseLeave: _propTypes2.default.func
}, _class.defaultProps = {
    defaultChecked: false,
    defaultIndeterminate: false,
    onChange: noop,
    onMouseEnter: noop,
    onMouseLeave: noop,
    prefix: 'next-'
}, _class.contextTypes = {
    onChange: _propTypes2.default.func,
    __group__: _propTypes2.default.bool,
    selectedValue: _propTypes2.default.array,
    disabled: _propTypes2.default.bool,
    prefix: _propTypes2.default.string
}, _temp);
exports.default = _configProvider2.default.config(Checkbox);
module.exports = exports['default'];

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var makeChain = _util.func.makeChain;
// UIState 为一些特殊元素的状态响应提供了标准的方式，
// 尤其适合CSS无法完全定制的控件，比如checkbox，radio等。
// 若组件 disable 则自行判断是否需要绑定状态管理。
// 注意：disable 不会触发事件，请使用resetUIState还原状态
/* eslint-disable react/prop-types */

var UIState = function (_Component) {
    _inherits(UIState, _Component);

    function UIState(props) {
        _classCallCheck(this, UIState);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        _this.state = {};
        ['_onUIFocus', '_onUIBlur'].forEach(function (item) {
            _this[item] = _this[item].bind(_this);
        });
        return _this;
    }
    // base 事件绑定的元素


    UIState.prototype.getStateElement = function getStateElement(base) {
        var _props = this.props,
            onFocus = _props.onFocus,
            onBlur = _props.onBlur;

        return _react2.default.cloneElement(base, {
            onFocus: makeChain(this._onUIFocus, onFocus),
            onBlur: makeChain(this._onUIBlur, onBlur)
        });
    };
    // 获取状态classname


    UIState.prototype.getStateClassName = function getStateClassName() {
        var focused = this.state.focused;

        return (0, _classnames2.default)({
            focused: focused
        });
    };
    // 复原状态


    UIState.prototype.resetUIState = function resetUIState() {
        this.setState({
            focused: false
        });
    };

    UIState.prototype._onUIFocus = function _onUIFocus() {
        this.setState({
            focused: true
        });
    };

    UIState.prototype._onUIBlur = function _onUIBlur() {
        this.setState({
            focused: false
        });
    };

    return UIState;
}(_react.Component);

UIState.displayName = 'UIState';
exports.default = UIState;
module.exports = exports['default'];

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _radio = __webpack_require__(62);

var _radio2 = _interopRequireDefault(_radio);

var _radioGroup = __webpack_require__(113);

var _radioGroup2 = _interopRequireDefault(_radioGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_radio2.default.Group = _radioGroup2.default;

exports.default = _radio2.default;
module.exports = exports['default'];

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames4 = __webpack_require__(3);

var _classnames5 = _interopRequireDefault(_classnames4);

var _mixinUiState = __webpack_require__(60);

var _mixinUiState2 = _interopRequireDefault(_mixinUiState);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var makeChain = _util.func.makeChain,
    noop = _util.func.noop;
/**
 * Radio
 * @order 1
 */

var Radio = (_temp = _class = function (_UIState) {
    _inherits(Radio, _UIState);

    function Radio(props, context) {
        _classCallCheck(this, Radio);

        var _this = _possibleConstructorReturn(this, _UIState.call(this, props));

        var checked = void 0;
        if (context.__group__) {
            checked = context.selectedValue === props.value;
        } else if ('checked' in props) {
            checked = props.checked;
        } else {
            checked = props.defaultChecked;
        }

        _this.state = { checked: checked };

        _this.onChange = _this.onChange.bind(_this);
        _this.disabled = props.disabled || context.__group__ && 'disabled' in context && context.disabled;

        return _this;
    }

    Radio.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
        if (nextContext.__group__) {
            var selectedValue = nextContext.selectedValue;

            if ('selectedValue' in nextContext) {
                this.setState({
                    checked: selectedValue === nextProps.value
                });
            }
        } else if ('checked' in nextProps) {
            this.setState({
                checked: nextProps.checked
            });
        }

        this.disabled = nextProps.disabled || nextContext.__group__ && 'disabled' in nextContext && nextContext.disabled;

        // when disabled, reset UIState
        if (this.disabled) {
            // only class has an impact, no effect on visual
            this.resetUIState();
        }
    };

    Radio.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState, nextContext) {
        var shallowEqual = _util.obj.shallowEqual;

        return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState) || !shallowEqual(this.nextContext, nextContext);
    };

    Radio.prototype.onChange = function onChange(e) {
        var checked = e.target.checked;
        var value = this.props.value;

        if (this.context.__group__) {
            this.context.onChange(value, e);
        } else if (this.state.checked !== checked) {
            if (!('checked' in this.props)) {
                this.setState({
                    checked: checked
                });
            }
            this.props.onChange(checked, e);
        }
    };

    Radio.prototype.render = function render() {
        var _classnames, _classnames2, _classnames3;

        /* eslint-disable no-unused-vars */
        var _props = this.props,
            id = _props.id,
            className = _props.className,
            children = _props.children,
            style = _props.style,
            label = _props.label,
            onMouseEnter = _props.onMouseEnter,
            onMouseLeave = _props.onMouseLeave,
            tabIndex = _props.tabIndex,
            rtl = _props.rtl,
            otherProps = _objectWithoutProperties(_props, ['id', 'className', 'children', 'style', 'label', 'onMouseEnter', 'onMouseLeave', 'tabIndex', 'rtl']);

        var checked = !!this.state.checked;
        var disabled = this.disabled;
        var isButton = this.context.isButton;
        var prefix = this.context.prefix || this.props.prefix;

        var others = _util.obj.pickOthers(Radio.propTypes, otherProps);
        var othersData = _util.obj.pickAttrsWith(others, 'data-');

        var input = _react2.default.createElement('input', _extends({}, _util.obj.pickOthers(othersData, others), {
            id: id,
            disabled: disabled,
            checked: checked,
            type: 'radio',
            onChange: this.onChange,
            'aria-checked': checked,
            className: prefix + 'radio-input'
        }));

        // disabled do not hove focus state
        if (!disabled) {
            input = this.getStateElement(input);
        }

        var cls = (0, _classnames5.default)((_classnames = {}, _classnames[prefix + 'radio'] = true, _classnames.checked = checked, _classnames.disabled = disabled, _classnames[this.getStateClassName()] = true, _classnames));
        var clsInner = (0, _classnames5.default)((_classnames2 = {}, _classnames2[prefix + 'radio-inner'] = true, _classnames2.press = checked, _classnames2.unpress = !checked, _classnames2));
        var clsWrapper = (0, _classnames5.default)((_classnames3 = {}, _classnames3[prefix + 'radio-wrapper'] = true, _classnames3[className] = !!className, _classnames3.checked = checked, _classnames3.disabled = disabled, _classnames3[this.getStateClassName()] = true, _classnames3));
        var childrenCls = prefix + 'radio-label';

        var radioComp = !isButton ? _react2.default.createElement(
            'span',
            { className: cls },
            _react2.default.createElement('span', { className: clsInner }),
            input
        ) : _react2.default.createElement(
            'span',
            { className: prefix + 'radio-single-input' },
            input
        );

        return _react2.default.createElement(
            'label',
            _extends({}, othersData, {
                role: 'radio',
                dir: rtl ? 'rtl' : 'ltr',
                style: style,
                tabIndex: tabIndex,
                'aria-checked': checked,
                'aria-disabled': disabled,
                className: clsWrapper,
                onMouseEnter: disabled ? onMouseEnter : makeChain(this._onUIMouseEnter, onMouseEnter),
                onMouseLeave: disabled ? onMouseLeave : makeChain(this._onUIMouseLeave, onMouseLeave)
            }),
            radioComp,
            [children, label].map(function (d, i) {
                return d !== undefined ? _react2.default.createElement(
                    'span',
                    { key: i, className: childrenCls },
                    d
                ) : null;
            })
        );
    };

    return Radio;
}(_mixinUiState2.default), _class.displayName = 'Radio', _class.propTypes = {
    prefix: _propTypes2.default.string,
    rtl: _propTypes2.default.bool,
    /**
     * 自定义类名
     */
    className: _propTypes2.default.string,
    /**
     * 组件input的id
     */
    id: _propTypes2.default.string,
    /**
     * 自定义内敛样式
     */
    style: _propTypes2.default.object,
    /**
     * 设置radio是否选中
     */
    checked: _propTypes2.default.bool,
    /**
     * 设置radio是否默认选中
     */
    defaultChecked: _propTypes2.default.bool,
    /**
     * 通过属性配置label
     */
    label: _propTypes2.default.node,
    /**
     * 状态变化时触发的事件
     * @param {Boolean} checked 是否选中
     * @param {Event} e Dom 事件对象
     */
    onChange: _propTypes2.default.func,
    /**
     * 鼠标进入enter事件
     * @param {Event} e Dom 事件对象
     */
    onMouseEnter: _propTypes2.default.func,
    /**
     * 鼠标离开事件
     * @param {Event} e Dom 事件对象
     */
    onMouseLeave: _propTypes2.default.func,
    /**
     * radio是否被禁用
     */
    disabled: _propTypes2.default.bool,
    /**
     * radio 的value
     */
    value: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number, _propTypes2.default.bool]),
    /**
     * name
     */
    name: _propTypes2.default.string
}, _class.defaultProps = {
    onChange: noop,
    onMouseLeave: noop,
    onMouseEnter: noop,
    tabIndex: 0,
    prefix: 'next-'
}, _class.contextTypes = {
    onChange: _propTypes2.default.func,
    __group__: _propTypes2.default.bool,
    isButton: _propTypes2.default.bool,
    selectedValue: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number, _propTypes2.default.bool]),
    disabled: _propTypes2.default.bool
}, _temp);
exports.default = _configProvider2.default.config(Radio);
module.exports = exports['default'];

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var Sort = (_temp2 = _class = function (_React$Component) {
    _inherits(Sort, _React$Component);

    function Sort() {
        var _temp, _this, _ret;

        _classCallCheck(this, Sort);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function () {
            var _this$props = _this.props,
                sort = _this$props.sort,
                dataIndex = _this$props.dataIndex;

            _this.onSort(dataIndex, sort[dataIndex] === 'desc' ? 'asc' : 'desc');
        }, _this.keydownHandler = function (e) {
            e.preventDefault();
            e.stopPropagation();

            if (e.keyCode === _util.KEYCODE.ENTER) {
                _this.handleClick();
            }
        }, _this.onSort = function (dataIndex, order) {
            var sort = {};
            sort[dataIndex] = order;

            _this.props.onSort(dataIndex, order, sort);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    // 渲染排序
    Sort.prototype.renderSort = function renderSort() {
        var _props = this.props,
            prefix = _props.prefix,
            sort = _props.sort,
            dataIndex = _props.dataIndex,
            locale = _props.locale,
            sortStatus = sort[dataIndex],
            map = {
            desc: 'descending',
            asc: 'ascending'
        };


        var icons = ['asc', 'desc'].map(function (sortOrder) {
            return _react2.default.createElement(
                'a',
                { href: 'javascript:;',
                    key: sortOrder,
                    className: sortStatus === sortOrder ? 'current' : '' },
                _react2.default.createElement(_icon2.default, { type: map[sortOrder], size: 'small' })
            );
        });

        return _react2.default.createElement(
            'span',
            { role: 'button',
                tabIndex: '0',
                'aria-label': locale[sortStatus],
                className: prefix + 'table-sort',
                onClick: this.handleClick.bind(this),
                onKeyDown: this.keydownHandler },
            icons
        );
    };

    Sort.prototype.render = function render() {
        return this.renderSort();
    };

    return Sort;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    className: _propTypes2.default.string,
    sort: _propTypes2.default.object,
    onSort: _propTypes2.default.func,
    dataIndex: _propTypes2.default.string,
    locale: _propTypes2.default.object
}, _class.defaultProps = {
    sort: {} }, _temp2);
Sort.displayName = 'Sort';
exports.default = Sort;
module.exports = exports['default'];

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _row = __webpack_require__(65);

var _row2 = _interopRequireDefault(_row);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var SelectionRow = (_temp = _class = function (_React$Component) {
    _inherits(SelectionRow, _React$Component);

    function SelectionRow() {
        _classCallCheck(this, SelectionRow);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    SelectionRow.prototype.render = function render() {
        var _classnames;

        /* eslint-disable no-unused-vars*/
        var _props = this.props,
            className = _props.className,
            record = _props.record,
            primaryKey = _props.primaryKey;
        var selectedRowKeys = this.context.selectedRowKeys;

        var cls = (0, _classnames3.default)((_classnames = {
            selected: selectedRowKeys.indexOf(record[primaryKey]) > -1
        }, _classnames[className] = className, _classnames));
        return _react2.default.createElement(_row2.default, _extends({}, this.props, { className: cls }));
    };

    return SelectionRow;
}(_react2.default.Component), _class.propTypes = _extends({}, _row2.default.propTypes), _class.defaultProps = _extends({}, _row2.default.defaultProps), _class.contextTypes = {
    selectedRowKeys: _propTypes2.default.array
}, _temp);
SelectionRow.displayName = 'SelectionRow';
exports.default = SelectionRow;
module.exports = exports['default'];

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

var _row = __webpack_require__(66);

var _row2 = _interopRequireDefault(_row);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var ExpandedRow = (_temp = _class = function (_React$Component) {
    _inherits(ExpandedRow, _React$Component);

    function ExpandedRow() {
        _classCallCheck(this, ExpandedRow);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    ExpandedRow.prototype.renderExpandedRow = function renderExpandedRow(record, index, colSpan) {
        var _context = this.context,
            expandedRowRender = _context.expandedRowRender,
            expandedRowIndent = _context.expandedRowIndent,
            openRowKeys = _context.openRowKeys,
            lockType = _context.lockType;
        var _props = this.props,
            columns = _props.columns,
            cellRef = _props.cellRef;

        if (expandedRowRender) {
            var _props2 = this.props,
                primaryKey = _props2.primaryKey,
                prefix = _props2.prefix,
                leftIndent = expandedRowIndent[0],
                rightIndent = expandedRowIndent[1],
                totalIndent = leftIndent + rightIndent,
                renderCols = function renderCols(number) {
                var ret = [];

                var _loop = function _loop(i) {
                    ret.push(_react2.default.createElement(
                        'td',
                        { key: i, ref: function ref(cell) {
                                return cellRef(index, i, cell);
                            } },
                        '\xA0'
                    ));
                };

                for (var i = 0; i < number; i++) {
                    _loop(i);
                }
                return ret;
            };

            var content = void 0;

            if (totalIndent > colSpan && !lockType) {
                _util.log.warning('It\'s not allowed expandedRowIndent is more than the number of columns.');
            }
            if (leftIndent < columns.length && lockType === 'left') {
                _util.log.warning('expandedRowIndent left is less than the number of left lock columns.');
            }
            if (rightIndent < columns.length && lockType === 'right') {
                _util.log.warning('expandedRowIndent right is less than the number of right lock columns.');
            }
            if (lockType) {
                return openRowKeys.indexOf(record[primaryKey]) > -1 ? _react2.default.createElement(
                    'tr',
                    { className: prefix + 'table-expanded-row', key: 'expanded-' + index },
                    _react2.default.createElement(
                        'td',
                        { colSpan: colSpan, ref: function ref(cell) {
                                return cellRef(index, 0, cell);
                            } },
                        '\xA0'
                    )
                ) : null;
            }
            content = expandedRowRender(record, index);
            if (!_react2.default.isValidElement(content)) {
                content = _react2.default.createElement(
                    'div',
                    { className: prefix + 'table-cell-wrapper' },
                    content
                );
            }
            return openRowKeys.indexOf(record[primaryKey]) > -1 ? _react2.default.createElement(
                'tr',
                { className: prefix + 'table-expanded-row', key: 'expanded-' + (record[primaryKey] || index) },
                renderCols(leftIndent),
                _react2.default.createElement(
                    'td',
                    { colSpan: colSpan - totalIndent },
                    content
                ),
                renderCols(rightIndent)
            ) : null;
        } else {
            return null;
        }
    };

    ExpandedRow.prototype.render = function render() {
        /* eslint-disable no-unused-vars*/
        var _props3 = this.props,
            record = _props3.record,
            rowIndex = _props3.rowIndex,
            columns = _props3.columns;

        if (record.__expanded) {
            return this.renderExpandedRow(record, rowIndex, columns.length);
        }
        return _react2.default.createElement(_row2.default, this.props);
    };

    return ExpandedRow;
}(_react2.default.Component), _class.propTypes = _extends({}, _row2.default.propTypes), _class.defaultProps = _extends({}, _row2.default.defaultProps), _class.contextTypes = {
    openRowKeys: _propTypes2.default.array,
    expandedRowRender: _propTypes2.default.func,
    expandedRowIndent: _propTypes2.default.array,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}, _temp);
ExpandedRow.displayName = 'ExpandedRow';
exports.default = ExpandedRow;
module.exports = exports['default'];

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _row = __webpack_require__(17);

var _row2 = _interopRequireDefault(_row);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var LockRow = (_temp2 = _class = function (_React$Component) {
    _inherits(LockRow, _React$Component);

    function LockRow() {
        var _temp, _this, _ret;

        _classCallCheck(this, LockRow);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onMouseEnter = function (record, index, e) {
            var onRowMouseEnter = _this.context.onRowMouseEnter;
            var onMouseEnter = _this.props.onMouseEnter;

            onRowMouseEnter && onRowMouseEnter(record, index, e);
            onMouseEnter(record, index, e);
        }, _this.onMouseLeave = function (record, index, e) {
            var onRowMouseLeave = _this.context.onRowMouseLeave;
            var onMouseLeave = _this.props.onMouseLeave;

            onRowMouseLeave && onRowMouseLeave(record, index, e);
            onMouseLeave(record, index, e);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    LockRow.prototype.render = function render() {
        /* eslint-disable no-unused-vars*/
        return _react2.default.createElement(_row2.default, _extends({}, this.props, { onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave }));
    };

    return LockRow;
}(_react2.default.Component), _class.propTypes = _extends({}, _row2.default.propTypes), _class.contextTypes = {
    onRowMouseEnter: _propTypes2.default.func,
    onRowMouseLeave: _propTypes2.default.func
}, _class.defaultProps = _extends({}, _row2.default.defaultProps), _temp2);
LockRow.displayName = 'LockRow';
exports.default = LockRow;
module.exports = exports['default'];

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _body = __webpack_require__(16);

var _body2 = _interopRequireDefault(_body);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var FixedBody = (_temp2 = _class = function (_React$Component) {
    _inherits(FixedBody, _React$Component);

    function FixedBody() {
        var _temp, _this, _ret;

        _classCallCheck(this, FixedBody);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onBodyScroll = function () {
            var onBodyScroll = _this.context.onBodyScroll;

            onBodyScroll && onBodyScroll();
            _this.props.onScroll();
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    FixedBody.prototype.componentDidMount = function componentDidMount() {
        var getNode = this.context.getNode;

        getNode && getNode('body', (0, _reactDom.findDOMNode)(this));
    };

    FixedBody.prototype.render = function render() {
        var _props = this.props,
            className = _props.className,
            colGroup = _props.colGroup,
            others = _objectWithoutProperties(_props, ['className', 'colGroup']);

        var _context = this.context,
            maxBodyHeight = _context.maxBodyHeight,
            fixedHeader = _context.fixedHeader;

        var style = {};
        if (fixedHeader) {
            style.maxHeight = maxBodyHeight;
        }
        return _react2.default.createElement(
            'div',
            { style: style, className: className, onScroll: this.onBodyScroll },
            _react2.default.createElement(
                'table',
                null,
                colGroup,
                _react2.default.createElement(_body2.default, _extends({}, others, { colGroup: colGroup }))
            )
        );
    };

    return FixedBody;
}(_react2.default.Component), _class.propTypes = {
    children: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    className: _propTypes2.default.string,
    colGroup: _propTypes2.default.any,
    onScroll: _propTypes2.default.func
}, _class.defaultProps = {
    onScroll: function onScroll() {}
}, _class.contextTypes = {
    fixedHeader: _propTypes2.default.bool,
    maxBodyHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    onBodyScroll: _propTypes2.default.func,
    getNode: _propTypes2.default.func
}, _temp2);
FixedBody.displayName = 'FixedBody';
exports.default = FixedBody;
module.exports = exports['default'];

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Table.GroupHeader
 * @order 2
 **/
var ListHeader = (_temp = _class = function (_React$Component) {
  _inherits(ListHeader, _React$Component);

  function ListHeader() {
    _classCallCheck(this, ListHeader);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  ListHeader.prototype.render = function render() {
    return null;
  };

  return ListHeader;
}(_react2.default.Component), _class.propTypes = {
  /**
   * 行渲染的逻辑
   */
  cell: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.node, _propTypes2.default.func]),
  /**
   * 是否在Children上面渲染selection
   */
  hasChildrenSelection: _propTypes2.default.bool,
  /**
   * 是否在GroupHeader上面渲染selection
   */
  hasSelection: _propTypes2.default.bool
}, _class.defaultProps = {
  cell: function cell() {
    return '';
  },
  hasSelection: true,
  hasChildrenSelection: false
}, _class._typeMark = 'listHeader', _temp);
ListHeader.displayName = 'ListHeader';
exports.default = ListHeader;
module.exports = exports['default'];

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Table.GroupFooter
 * @order 3
 **/
var ListFooter = (_temp = _class = function (_React$Component) {
    _inherits(ListFooter, _React$Component);

    function ListFooter() {
        _classCallCheck(this, ListFooter);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    ListFooter.prototype.render = function render() {
        return null;
    };

    return ListFooter;
}(_react2.default.Component), _class.propTypes = {
    /**
     * 行渲染的逻辑
     */
    cell: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.node, _propTypes2.default.func])
}, _class.defaultProps = {
    cell: function cell() {
        return '';
    }
}, _class._typeMark = 'listFooter', _temp);
ListFooter.displayName = 'ListFooter';
exports.default = ListFooter;
module.exports = exports['default'];

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(12);

__webpack_require__(146);

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _button = __webpack_require__(118);

var _button2 = _interopRequireDefault(_button);

var _group = __webpack_require__(119);

var _group2 = _interopRequireDefault(_group);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

_button2.default.Group = _group2.default;

exports.default = _configProvider2.default.config(_button2.default, {
    transform: function transform(props, deprecated) {
        if ('shape' in props) {
            deprecated('shape', 'text | warning | ghost', 'Button');

            var _props = props,
                shape = _props.shape,
                type = _props.type,
                others = _objectWithoutProperties(_props, ['shape', 'type']);

            var newType = type;
            if (type === 'light' || type === 'dark' || type === 'secondary' && shape === 'warning') {
                newType = 'normal';
            }

            var ghost = void 0;
            if (shape === 'ghost') {
                ghost = {
                    primary: 'dark',
                    secondary: 'dark',
                    normal: 'light',
                    dark: 'dark',
                    light: 'light'
                }[type || _button2.default.defaultProps.type];
            }

            var text = shape === 'text';
            var warning = shape === 'warning';

            props = _extends({ type: newType, ghost: ghost, text: text, warning: warning }, others);
        }

        return props;
    }
});
module.exports = exports['default'];

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(11);

__webpack_require__(148);

/***/ }),
/* 73 */,
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _animate = __webpack_require__(51);

var _animate2 = _interopRequireDefault(_animate);

var _expand = __webpack_require__(110);

var _expand2 = _interopRequireDefault(_expand);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_animate2.default.Expand = _expand2.default;

exports.default = _animate2.default;
module.exports = exports['default'];

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _overlay = __webpack_require__(15);

var _overlay2 = _interopRequireDefault(_overlay);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/** Loading */
var Loading = (_temp = _class = function (_React$Component) {
    _inherits(Loading, _React$Component);

    function Loading() {
        _classCallCheck(this, Loading);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    Loading.prototype.render = function render() {
        var _classNames2, _classNames3, _classNames4;

        var _props = this.props,
            tip = _props.tip,
            visible = _props.visible,
            children = _props.children,
            className = _props.className,
            style = _props.style,
            indicator = _props.indicator,
            color = _props.color,
            prefix = _props.prefix,
            fullScreen = _props.fullScreen,
            onVisibleChange = _props.onVisibleChange,
            tipAlign = _props.tipAlign,
            size = _props.size;


        var indicatorDom = null;
        var dotCls = prefix + 'loading-dot';

        if (indicator) {
            indicatorDom = indicator;
        } else {
            var _classNames;

            var backgroundColor = color;
            var fusionReactorCls = (0, _classnames2.default)((_classNames = {}, _classNames[prefix + 'loading-fusion-reactor'] = true, _classNames[prefix + 'loading-medium-fusion-reactor'] = size === 'medium', _classNames));
            indicatorDom = _react2.default.createElement(
                'div',
                { className: fusionReactorCls },
                _react2.default.createElement('span', { className: dotCls, style: { backgroundColor: backgroundColor } }),
                _react2.default.createElement('span', { className: dotCls, style: { backgroundColor: backgroundColor } }),
                _react2.default.createElement('span', { className: dotCls, style: { backgroundColor: backgroundColor } }),
                _react2.default.createElement('span', { className: dotCls, style: { backgroundColor: backgroundColor } })
            );
        }

        var loadingCls = (0, _classnames2.default)((_classNames2 = {}, _classNames2[prefix + 'loading'] = true, _classNames2[prefix + 'open'] = visible, _classNames2[className] = className, _classNames2));

        var tipCls = (0, _classnames2.default)((_classNames3 = {}, _classNames3[prefix + 'loading-tip'] = true, _classNames3[prefix + 'loading-right-tip'] = tipAlign === 'right', _classNames3));

        var others = _util.obj.pickOthers(Loading.propTypes, this.props);

        var contentCls = (0, _classnames2.default)((_classNames4 = {}, _classNames4[prefix + 'loading-component'] = visible, _classNames4[prefix + 'loading-wrap'] = true, _classNames4));

        return fullScreen ? [children, _react2.default.createElement(
            _overlay2.default,
            _extends({ key: 'overlay', hasMask: true, align: 'cc cc' }, others, {
                className: className,
                style: style,
                visible: visible,
                onRequestClose: onVisibleChange }),
            _react2.default.createElement(
                'div',
                { className: tipCls },
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'loading-indicator' },
                    indicatorDom
                ),
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'loading-tip-content' },
                    tip
                ),
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'loading-tip-placeholder' },
                    tip
                )
            )
        )] : _react2.default.createElement(
            'div',
            _extends({ className: loadingCls, style: style }, others),
            visible ? _react2.default.createElement(
                'div',
                { className: tipCls },
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'loading-indicator' },
                    indicatorDom
                ),
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'loading-tip-content' },
                    tip
                ),
                _react2.default.createElement(
                    'div',
                    { className: prefix + 'loading-tip-placeholder' },
                    tip
                )
            ) : null,
            _react2.default.createElement(
                'div',
                { className: contentCls },
                visible ? _react2.default.createElement('div', { className: prefix + 'loading-masker' }) : null,
                children
            )
        );
    };

    return Loading;
}(_react2.default.Component), _class.propTypes = {
    /**
     * 样式前缀
     */
    prefix: _propTypes2.default.string,
    /**
     * 自定义内容
     */
    tip: _propTypes2.default.any,
    /**
     * 自定义内容位置
     * @enumdesc 出现在动画右边, 出现在动画下面
     */
    tipAlign: _propTypes2.default.oneOf(['right', 'bottom']),
    /**
     * loading 状态, 默认 true
     */
    visible: _propTypes2.default.bool,
    onVisibleChange: _propTypes2.default.func,
    /**
     * 自定义class
     */
    className: _propTypes2.default.string,
    /**
     * 自定义内联样式
     */
    style: _propTypes2.default.object,
    /**
     * 设置动画尺寸
     * @description 仅仅对默认动画效果起作用
     * @enumdesc 大号, 中号
     */
    size: _propTypes2.default.oneOf(['large', 'medium']),
    /**
     * 自定义动画
     */
    indicator: _propTypes2.default.any,
    /**
     * 动画颜色
     */
    color: _propTypes2.default.string,
    /**
     * 全屏展示
     */
    fullScreen: _propTypes2.default.bool,
    /**
     * 子元素
     */
    children: _propTypes2.default.any
}, _class.defaultProps = {
    prefix: 'next-',
    visible: true,
    onVisibleChange: _util.func.noop,
    animate: null,
    tipAlign: 'bottom',
    size: 'large'
}, _temp);
Loading.displayName = 'Loading';
exports.default = _configProvider2.default.config(Loading);
module.exports = exports['default'];

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _menu = __webpack_require__(50);

var _menu2 = _interopRequireDefault(_menu);

var _subMenu = __webpack_require__(101);

var _subMenu2 = _interopRequireDefault(_subMenu);

var _selectableItem = __webpack_require__(22);

var _selectableItem2 = _interopRequireDefault(_selectableItem);

var _checkboxItem = __webpack_require__(111);

var _checkboxItem2 = _interopRequireDefault(_checkboxItem);

var _radioItem = __webpack_require__(114);

var _radioItem2 = _interopRequireDefault(_radioItem);

var _popupItem = __webpack_require__(57);

var _popupItem2 = _interopRequireDefault(_popupItem);

var _group = __webpack_require__(115);

var _group2 = _interopRequireDefault(_group);

var _divider = __webpack_require__(116);

var _divider2 = _interopRequireDefault(_divider);

var _create = __webpack_require__(117);

var _create2 = _interopRequireDefault(_create);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

_menu2.default.SubMenu = _subMenu2.default;
_menu2.default.Item = _selectableItem2.default;
_menu2.default.CheckboxItem = _checkboxItem2.default;
_menu2.default.RadioItem = _radioItem2.default;
_menu2.default.PopupItem = _popupItem2.default;
_menu2.default.Group = _group2.default;
_menu2.default.Divider = _divider2.default;
_menu2.default.create = _create2.default;

/* istanbul ignore next */
var transform = function transform(props, deprecated) {
    if ('indentSize' in props) {
        deprecated('indentSize', 'inlineIndent', 'Menu');

        var _props = props,
            indentSize = _props.indentSize,
            others = _objectWithoutProperties(_props, ['indentSize']);

        props = _extends({ inlineIndent: indentSize }, others);
    }

    if ('onDeselect' in props) {
        deprecated('onDeselect', 'onSelect', 'Menu');
        if (props.onDeselect) {
            var _props2 = props,
                onDeselect = _props2.onDeselect,
                onSelect = _props2.onSelect,
                _others = _objectWithoutProperties(_props2, ['onDeselect', 'onSelect']);

            var newOnSelect = function newOnSelect(selectedKeys, item, extra) {
                if (!extra.select) {
                    onDeselect(extra.key);
                }
                if (onSelect) {
                    onSelect(selectedKeys, item, extra);
                }
            };

            props = _extends({ onSelect: newOnSelect }, _others);
        }
    }

    return props;
};

exports.default = _configProvider2.default.config(_menu2.default, {
    transform: transform
});
module.exports = exports['default'];

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(11);

__webpack_require__(12);

__webpack_require__(70);

__webpack_require__(38);

__webpack_require__(147);

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(11);

__webpack_require__(12);

__webpack_require__(36);

__webpack_require__(152);

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _base = __webpack_require__(95);

var _base2 = _interopRequireDefault(_base);

var _tree = __webpack_require__(123);

var _tree2 = _interopRequireDefault(_tree);

var _fixed = __webpack_require__(126);

var _fixed2 = _interopRequireDefault(_fixed);

var _selection = __webpack_require__(127);

var _selection2 = _interopRequireDefault(_selection);

var _expanded = __webpack_require__(128);

var _expanded2 = _interopRequireDefault(_expanded);

var _virtual = __webpack_require__(129);

var _virtual2 = _interopRequireDefault(_virtual);

var _lock = __webpack_require__(131);

var _lock2 = _interopRequireDefault(_lock);

var _list = __webpack_require__(134);

var _list2 = _interopRequireDefault(_list);

var _sticky = __webpack_require__(137);

var _sticky2 = _interopRequireDefault(_sticky);

var _listHeader = __webpack_require__(68);

var _listHeader2 = _interopRequireDefault(_listHeader);

var _listFooter = __webpack_require__(69);

var _listFooter2 = _interopRequireDefault(_listFooter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var ORDER_LIST = [_fixed2.default, _lock2.default, _selection2.default, _expanded2.default, _tree2.default, _virtual2.default, _list2.default, _sticky2.default];
var Table = ORDER_LIST.reduce(function (ret, current) {
    ret = current(ret);
    return ret;
}, _base2.default);
Table.Base = _base2.default;
Table.fixed = _fixed2.default;
Table.lock = _lock2.default;
Table.selection = _selection2.default;
Table.expanded = _expanded2.default;
Table.tree = _tree2.default;
Table.virtual = _virtual2.default;
Table.list = _list2.default;
Table.sticky = _sticky2.default;

Table.GroupHeader = _listHeader2.default;
Table.GroupFooter = _listFooter2.default;

exports.default = _configProvider2.default.config(Table, {
    componentName: 'Table',
    transform: function transform(props, deprecated) {
        if ('expandedRowKeys' in props) {
            deprecated('expandedRowKeys', 'openRowKeys', 'Table');

            var _props = props,
                expandedRowKeys = _props.expandedRowKeys,
                others = _objectWithoutProperties(_props, ['expandedRowKeys']);

            props = _extends({ openRowKeys: expandedRowKeys }, others);
        }
        if ('onExpandedChange' in props) {
            deprecated('onExpandedChange', 'onRowOpen', 'Table');

            var _props2 = props,
                onExpandedChange = _props2.onExpandedChange,
                _others = _objectWithoutProperties(_props2, ['onExpandedChange']);

            props = _extends({ onRowOpen: onExpandedChange }, _others);
        }
        if ('isLoading' in props) {
            deprecated('isLoading', 'loading', 'Table');

            var _props3 = props,
                isLoading = _props3.isLoading,
                _others2 = _objectWithoutProperties(_props3, ['isLoading']);

            props = _extends({ loading: isLoading }, _others2);
        }
        if ('indentSize' in props) {
            deprecated('indentSize', 'indent', 'Table');

            var _props4 = props,
                indentSize = _props4.indentSize,
                _others3 = _objectWithoutProperties(_props4, ['indentSize']);

            props = _extends({ indent: indentSize }, _others3);
        }
        if ('optimization' in props) {
            deprecated('optimization', 'pure', 'Table');

            var _props5 = props,
                optimization = _props5.optimization,
                _others4 = _objectWithoutProperties(_props5, ['optimization']);

            props = _extends({ pure: optimization }, _others4);
        }
        if ('getRowClassName' in props) {
            deprecated('getRowClassName', 'getRowProps', 'Table');

            var _props6 = props,
                getRowClassName = _props6.getRowClassName,
                getRowProps = _props6.getRowProps,
                _others5 = _objectWithoutProperties(_props6, ['getRowClassName', 'getRowProps']);

            if (getRowClassName) {
                var newGetRowProps = function newGetRowProps() {
                    return _extends({
                        className: getRowClassName.apply(undefined, arguments)
                    }, getRowProps ? getRowProps.apply(undefined, arguments) : {});
                };

                props = _extends({ getRowProps: newGetRowProps }, _others5);
            } else {
                props = _extends({ getRowProps: getRowProps }, _others5);
            }
        }

        return props;
    }
});
module.exports = exports['default'];

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var assign = __webpack_require__(81);

var ReactPropTypesSecret = __webpack_require__(20);
var checkPropTypes = __webpack_require__(82);

var printWarning = function printWarning() {};

if (process.env.NODE_ENV !== 'production') {
  printWarning = function printWarning(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function (isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
          err.name = 'Invariant Violation';
          throw err;
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (!manualPropTypeCallCache[cacheKey] &&
          // Avoid spamming the console because they are often not actionable except for lib authors
          manualPropTypeWarningCount < 3) {
            printWarning('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(_extends({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var printWarning = function printWarning() {};

if (process.env.NODE_ENV !== 'production') {
  var ReactPropTypesSecret = __webpack_require__(20);
  var loggedTypeFailures = {};

  printWarning = function printWarning(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + _typeof(typeSpecs[typeSpecName]) + '`.');
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + (typeof error === 'undefined' ? 'undefined' : _typeof(error)) + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
        }
      }
    }
  }
}

module.exports = checkPropTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__(20);

function emptyFunction() {}

module.exports = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.initLocales = initLocales;
exports.setLanguage = setLanguage;
exports.setLocale = setLocale;
exports.setDirection = setDirection;
exports.getLocale = getLocale;
exports.getLanguage = getLanguage;
exports.getDirection = getDirection;
exports.config = config;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _hoistNonReactStatics = __webpack_require__(85);

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _util = __webpack_require__(2);

var _getContextProps = __webpack_require__(39);

var _getContextProps2 = _interopRequireDefault(_getContextProps);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var shallowEqual = _util.obj.shallowEqual;


function getDisplayName(Component) {
    return Component.displayName || Component.name || 'Component';
}

var globalLocales = void 0;
var currentGlobalLanguage = 'zh-cn';
var currentGlobalLocale = {};
var currentGlobalRtl = false;

function initLocales(locales) {
    globalLocales = locales;
    currentGlobalLocale = locales[currentGlobalLanguage];
}

function setLanguage(language) {
    if (globalLocales) {
        currentGlobalLanguage = language;
        currentGlobalLocale = globalLocales[language];
    }
}

function setLocale(locale) {
    currentGlobalLocale = _extends({}, globalLocales ? globalLocales[currentGlobalLanguage] : {}, locale);
}

function setDirection(dir) {
    currentGlobalRtl = dir === 'rtl';
}

function getLocale() {
    return currentGlobalLocale;
}

function getLanguage() {
    return currentGlobalLanguage;
}

function getDirection() {
    return currentGlobalRtl;
}

function config(Component) {
    var _class, _temp;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (Component.prototype.shouldComponentUpdate === undefined) {
        Component.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
            if (this.props.pure) {
                return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);
            }

            return true;
        };
    }

    var ConfigedComponent = (_temp = _class = function (_React$Component) {
        _inherits(ConfigedComponent, _React$Component);

        function ConfigedComponent(props, context) {
            _classCallCheck(this, ConfigedComponent);

            var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

            _this._getInstance = _this._getInstance.bind(_this);
            _this._deprecated = _this._deprecated.bind(_this);
            return _this;
        }

        ConfigedComponent.prototype._getInstance = function _getInstance(ref) {
            var _this2 = this;

            this._instance = ref;

            if (this._instance && options.exportNames) {
                options.exportNames.forEach(function (name) {
                    var field = _this2._instance[name];
                    if (typeof field === 'function') {
                        _this2[name] = field.bind(_this2._instance);
                    } else {
                        _this2[name] = field;
                    }
                });
            }
        };

        ConfigedComponent.prototype._deprecated = function _deprecated() {
            if (this.context.nextWarning !== false) {
                _util.log.deprecated.apply(_util.log, arguments);
            }
        };

        ConfigedComponent.prototype.getInstance = function getInstance() {
            return this._instance;
        };

        ConfigedComponent.prototype.render = function render() {
            var _props = this.props,
                prefix = _props.prefix,
                locale = _props.locale,
                pure = _props.pure,
                rtl = _props.rtl,
                others = _objectWithoutProperties(_props, ['prefix', 'locale', 'pure', 'rtl']);

            var _context = this.context,
                nextPrefix = _context.nextPrefix,
                _context$nextLocale = _context.nextLocale,
                nextLocale = _context$nextLocale === undefined ? {} : _context$nextLocale,
                nextPure = _context.nextPure,
                nextRtl = _context.nextRtl;


            var displayName = options.componentName || getDisplayName(Component);
            var contextProps = (0, _getContextProps2.default)({ prefix: prefix, locale: locale, pure: pure, rtl: rtl }, {
                nextPrefix: nextPrefix,
                nextLocale: _extends({}, currentGlobalLocale, nextLocale),
                nextPure: nextPure,
                nextRtl: typeof nextRtl === 'boolean' ? nextRtl : currentGlobalRtl === true ? true : undefined
            }, displayName);

            var newContextProps = ['prefix', 'locale', 'pure', 'rtl'].reduce(function (ret, name) {
                if (typeof contextProps[name] !== 'undefined') {
                    ret[name] = contextProps[name];
                }
                return ret;
            }, {});

            var newOthers = options.transform ? options.transform(others, this._deprecated) : others;

            return _react2.default.createElement(Component, _extends({}, newOthers, newContextProps, {
                ref: this._getInstance
            }));
        };

        return ConfigedComponent;
    }(_react2.default.Component), _class.propTypes = _extends({}, Component.propTypes || {}, {
        prefix: _propTypes2.default.string,
        locale: _propTypes2.default.object,
        pure: _propTypes2.default.bool,
        rtl: _propTypes2.default.bool
    }), _class.contextTypes = _extends({}, Component.contextTypes || {}, {
        nextPrefix: _propTypes2.default.string,
        nextLocale: _propTypes2.default.object,
        nextPure: _propTypes2.default.bool,
        nextRtl: _propTypes2.default.bool,
        nextWarning: _propTypes2.default.bool
    }), _temp);
    ConfigedComponent.displayName = 'ConfigedComponent';


    ConfigedComponent.displayName = 'Config(' + getDisplayName(Component) + ')';

    (0, _hoistNonReactStatics2.default)(ConfigedComponent, Component);

    return ConfigedComponent;
}

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
        // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
}

module.exports = hoistNonReactStatics;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.on = on;
exports.once = once;
/**
 * 取消事件绑定
 * @param  {*}   node       DOM节点或任何可以绑定事件的对象
 * @param  {String}   eventName  事件名
 * @param  {Function} callback   回调方法
 * @param  {Boolean}   [useCapture=false] 是否开启事件捕获优先
 */
function _off(node, eventName, callback, useCapture) {
    /* istanbul ignore else */
    if (node.removeEventListener) {
        node.removeEventListener(eventName, callback, useCapture || false);
    }
}

/**
 * 绑定事件
 * @param  {*}   node       DOM节点或任何可以绑定事件的对象
 * @param  {String}   eventName  事件名
 * @param  {Function} callback   回调方法
 * @param  {Boolean}   useCapture 是否开启事件捕获优先
 * @return {Object}               返回的object中包含一个off方法，用于取消事件监听
 *
 * @example
 * const handler = events.on(document.body, 'click', e => {
 *     // handle click ...
 * });
 * // 取消事件绑定
 * handler.off();
 */
exports.off = _off;
function on(node, eventName, callback, useCapture) {
    /* istanbul ignore else */
    if (node.addEventListener) {
        node.addEventListener(eventName, callback, useCapture || false);
    }

    return {
        off: function off() {
            return _off(node, eventName, callback, useCapture);
        }
    };
}

/**
 * 绑定事件，只执行一次后销毁
 * @param  {*}   node       DOM节点或任何可以绑定事件的对象
 * @param  {String}   eventName  事件名
 * @param  {Function} callback   回调方法
 * @param  {Boolean}   useCapture 是否开启事件捕获优先
 * @return {Function}             返回的object中包含一个off方法，用于取消事件监听
 */
function once(node, eventName, callback, useCapture) {
    return on(node, eventName, function __fn() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        callback.apply(this, args);

        // 由于addEventListener中的参数options只在Chrome 55、Firefox(Gecko)以上版本支持，故还是用传统的方法实现once
        _off(node, eventName, __fn, useCapture);
    }, useCapture);
}

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.noop = undefined;
exports.makeChain = makeChain;
exports.bindCtx = bindCtx;
exports.promiseCall = promiseCall;

var _object = __webpack_require__(13);

/**
 * 一个空方法，返回入参本身或空对象
 */
var noop = exports.noop = function noop() {};

/**
 * 将N个方法合并为一个链式调用的方法
 * @return {Function}     合并后的方法
 * 参考 https://github.com/react-component/util/
 *
 * @example
 * func.makeChain(this.handleChange, this.props.onChange);
 */
function makeChain() {
    for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
        fns[_key] = arguments[_key];
    }

    if (fns.length === 1) {
        return fns[0];
    }

    return function chainedFunction() {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
        }

        for (var i = 0, j = fns.length; i < j; i++) {
            if (fns[i] && fns[i].apply) {
                fns[i].apply(this, args);
            }
        }
    };
}

/**
 * 批量改变方法的上下文
 * 此方法在react组件中很有用，在constructor中批量将组件上的方法执行上下文绑定到组件本身
 * 注意：用bind改变函数运行的上下文只会生效一次
 * @param  {Object} ctx 方法挂载的对象以及执行的上下文
 * @param  {Array<String>} fns 方法名列表
 *
 * @example
 * func.bindCtx(this, ['handleClick', 'handleChange']);
 */
function bindCtx(ctx, fns, ns) {
    if (typeof fns === 'string') {
        fns = [fns];
    }

    // 方法的挂载空间，如果不传，默认与ctx相同
    ns = ns || ctx;

    fns.forEach(function (fnName) {
        // 这里不要添加空方法判断，由调用者保证正确性，否则出了问题无法排查
        ns[fnName] = ns[fnName].bind(ctx);
    });
}

/**
 * 用于执行回调方法后的逻辑
 * @param  {*} ret            回调方法执行结果
 * @param  {Function} success 执行结果返回非false的回调
 * @param  {Function} [failure=noop] 执行结果返回false的回调
 */
function promiseCall(ret, success) {
    var failure = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

    if ((0, _object.isPromise)(ret)) {
        return ret.then(function (result) {
            success(result);
            return result;
        }).catch(function (e) {
            failure(e);
            // throw e;
        });
    }

    return ret !== false ? success(ret) : failure(ret);
}

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.deprecated = deprecated;
exports.warning = warning;

var _env = __webpack_require__(42);

/* eslint no-console: 0 */

/**
 * 反对使用某一方法或属性的警告
 * @param  {String} props     过时的属性或方法名
 * @param  {String} instead   替代的属性或方法名
 * @param  {String} component 组件名
 *
 * @example
 * log.deprecated('onBeforeClose', 'beforeClose', 'Dialog');
 * // Warning: onBeforeClose is deprecated at [ Dialog ], use [ beforeClose ] instead of it.
 */
function deprecated(props, instead, component) {
    /* istanbul ignore else */
    if (!(0, _env.isProduction)() && typeof console !== 'undefined' && console.error) {
        return console.error('Warning: [ ' + props + ' ] is deprecated at [ ' + component + ' ], ' + ('use [ ' + instead + ' ] instead of it.'));
    }
}

/**
 * 控制台警告日志
 * @param  {String} msg
 */
function warning(msg) {
    /* istanbul ignore else */
    if (typeof console !== 'undefined' && console.error) {
        return console.error('Warning: ' + msg);
    }
}

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.flex = exports.transition = exports.animation = undefined;

var _dom = __webpack_require__(40);

var _object = __webpack_require__(13);

var animationEndEventNames = {
    WebkitAnimation: 'webkitAnimationEnd',
    OAnimation: 'oAnimationEnd',
    animation: 'animationend'
};

var transitionEventNames = {
    WebkitTransition: 'webkitTransitionEnd',
    OTransition: 'oTransitionEnd',
    transition: 'transitionend'
};

/**
 * 是否支持某些动效事件，如果支持，返回相应的end事件名
 * @private
 * @param  {Object<String>} names
 * @return {Object|false}
 */
function _supportEnd(names) {
    /* istanbul ignore if */
    if (!_dom.hasDOM) {
        return false;
    }

    var el = document.createElement('div');
    var ret = false;

    (0, _object.each)(names, function (val, key) {
        /* istanbul ignore else */
        if (el.style[key] !== undefined) {
            ret = { end: val };
            return false;
        }
    });

    return ret;
}

/**
 * 是否支持某些CSS属性
 * @private
 * @param  {Object<Array<String>>} names
 * @return {Boolean}       is support
 */
function _supportCSS(names) {
    /* istanbul ignore if */
    if (!_dom.hasDOM) {
        return false;
    }

    var el = document.createElement('div');
    var ret = false;

    (0, _object.each)(names, function (val, key) {
        (0, _object.each)(val, function (item) {
            try {
                el.style[key] = item;
                ret = ret || el.style[key] === item;
            } catch (e) {
                // It will be throw error when set unknown property under IE8
            }
            return !ret; // 如果有一个支持就返回false，后面不需要再判断
        });

        return !ret;
    });

    return ret;
}

/**
 * 是否支持animation以及动画结束事件名
 * @type {Object|false}
 * @property {String} end 动画结束事件名
 */
var animation = exports.animation = _supportEnd(animationEndEventNames);

/**
 * 是否支持transition以及过滤效果结束事件名
 * @type {Object|false}
 * @property {String} end 过渡效果结束事件名
 */
var transition = exports.transition = _supportEnd(transitionEventNames);

/**
 * 是否支持flex属性
 * @type {Boolean}
 */
var flex = exports.flex = _supportCSS({
    display: ['flex', '-webkit-flex', '-moz-flex', '-ms-flexbox']
});

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getFocusNodeList = getFocusNodeList;
exports.saveLastFocusNode = saveLastFocusNode;
exports.clearLastFocusNode = clearLastFocusNode;
exports.backLastFocusNode = backLastFocusNode;
exports.limitTabRange = limitTabRange;

var _keycode = __webpack_require__(43);

var _keycode2 = _interopRequireDefault(_keycode);

var _object = __webpack_require__(13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 用于切换页面元素的焦点
 */

/**
 * 元素是否可见
 * @private
 * @param   {Element}  node
 * @return  {Boolean}
 */
function _isVisible(node) {
    while (node) {
        if (node === document.body || node === document.documentElement) {
            break;
        }
        if (node.style.display === 'none' || node.style.visibility === 'hidden') {
            return false;
        }
        node = node.parentNode;
    }
    return true;
}

/**
 * 元素是否可以获取焦点
 * @private
 * @param   {Element}  node
 * @return  {Boolean}
 */
function _isFocusable(node) {
    var nodeName = node.nodeName.toLowerCase();
    var tabIndex = parseInt(node.getAttribute('tabindex'), 10);
    var hasTabIndex = !isNaN(tabIndex) && tabIndex > -1;

    if (_isVisible(node)) {
        if (nodeName === 'input') {
            return !node.disabled && node.type !== 'hidden';
        } else if (['select', 'textarea', 'button'].indexOf(nodeName) > -1) {
            return !node.disabled;
        } else if (nodeName === 'a') {
            return node.getAttribute('href') || hasTabIndex;
        } else {
            return hasTabIndex;
        }
    }
    return false;
}

/**
 * 列出能获取焦点的子节点
 * @param  {Element} node 容器节点
 * @return {Array<Element>}
 */
function getFocusNodeList(node) {
    var res = [];
    var nodeList = node.querySelectorAll('*');

    (0, _object.each)(nodeList, function (item) {
        if (_isFocusable(item)) {
            var method = item.getAttribute('data-auto-focus') ? 'unshift' : 'push';
            res[method](item);
        }
    });

    if (_isFocusable(node)) {
        res.unshift(node);
    }

    return res;
}

// 用于记录上一次获得焦点的无素
var lastFocusElement = null;

/**
 * 保存最近一次获得焦点的无素
 */
function saveLastFocusNode() {
    lastFocusElement = document.activeElement;
}

/**
 * 清除焦点记录
 */
function clearLastFocusNode() {
    lastFocusElement = null;
}

/**
 * 尝试将焦点切换到上一个元素
 */
function backLastFocusNode() {
    if (lastFocusElement) {
        try {
            // 元素可能已经被移动了
            lastFocusElement.focus();
        } catch (e) {
            // ignore ...
        }
    }
}

/**
 * 在限制的范围内切换焦点
 * @param  {Element} node 容器节点
 * @param  {Event} e      键盘事件
 */
function limitTabRange(node, e) {
    if (e.keyCode === _keycode2.default.TAB) {
        var tabNodeList = getFocusNodeList(node);
        var maxIndex = tabNodeList.length - 1;
        var index = tabNodeList.indexOf(document.activeElement);

        if (index > -1) {
            var targetIndex = index + (e.shiftKey ? -1 : 1);
            targetIndex < 0 && (targetIndex = maxIndex);
            targetIndex > maxIndex && (targetIndex = 0);
            tabNodeList[targetIndex].focus();
            e.preventDefault();
        }
    }
}

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (prefix) {
  prefix = prefix || '';

  return prefix + (timestamp++).toString(36);
};

var timestamp = Date.now();

/**
 * 生成全局唯一的id
 * @param  {String} [prefix=''] 前缀字符串
 * @return {String}
 *
 * @example
 * guid(); // j7jv509c
 * guid('prefix-'); // prefix-j7jv509d
 */
module.exports = exports['default'];

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates an object with the same values as object and keys
 * generated by running each own enumerable string keyed property
 * of object thru iteratee.
 * @param {Object} obj
 * @param {Function} fn
 * @return {Object}
 */
var mapKeys = function mapKeys(obj, fn) {
    var result = {};
    for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var value = obj[key];
            var newKey = fn(key, value);
            result[newKey] = value;
        }
    }

    return result;
};

/**
 * Replace specific key with prefix `next`
 * and lowercase first character of the result.
 * @param {String} key
 * @return {String}
 */
var replaceKey = function replaceKey(key) {
    return key.replace(/^(next)([A-Z])/, function (match, p1, p2) {
        return p2.toLowerCase();
    });
};

/**
 * @param {Object} source
 * @return {Object}
 */
var transformContext = function transformContext(source) {
    return mapKeys(source, replaceKey);
};

/**
 * Consumer
 * @param {Object} prop
 * @param {Object} context
 */
var Consumer = function Consumer(_ref, context) {
    var children = _ref.children;
    return typeof children === 'function' ? children(transformContext(context)) : null;
};

/**
 * PropTypes
 * @type {Object}
 * @static
 */
Consumer.propTypes = {
    // Render context as function
    // Function(context: object): ReactElement
    children: _propTypes2.default.func
};

/**
 * ContextTypes (legacy context)
 * @type {Object}
 * @static
 */
Consumer.contextTypes = {
    nextPrefix: _propTypes2.default.string,
    nextLocale: _propTypes2.default.object,
    nextPure: _propTypes2.default.bool,
    newRtl: _propTypes2.default.bool,
    nextWarning: _propTypes2.default.bool
};

exports.default = Consumer;
module.exports = exports['default'];

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Cache = function () {
    function Cache() {
        _classCallCheck(this, Cache);

        this._root = null;
        this._store = new Map();
    }

    Cache.prototype.empty = function empty() {
        return this._store.size === 0;
    };

    Cache.prototype.has = function has(key) {
        return this._store.has(key);
    };

    Cache.prototype.get = function get(key, defaultValue) {
        var res = this.has(key) ? this._store.get(key) : this.root();
        return typeof res === 'undefined' || res === null ? defaultValue : res;
    };

    Cache.prototype.add = function add(key, value) {
        if (this.empty()) {
            this._root = key;
        }
        this._store.set(key, value);
    };

    Cache.prototype.update = function update(key, value) {
        if (this.has(key)) {
            this._store.set(key, value);
        }
    };

    Cache.prototype.remove = function remove(key) {
        this._store.delete(key);
    };

    Cache.prototype.root = function root() {
        return this._store.get(this._root);
    };

    return Cache;
}();

exports.default = Cache;
module.exports = exports['default'];

/***/ }),
/* 94 */
/***/ (function(module, exports) {

if(typeof window.moment === 'undefined') {var e = new Error("Cannot find module \"window.moment\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
module.exports = window.moment;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _shallowElementEquals = __webpack_require__(44);

var _shallowElementEquals2 = _interopRequireDefault(_shallowElementEquals);

var _loading = __webpack_require__(75);

var _loading2 = _interopRequireDefault(_loading);

var _zhCn = __webpack_require__(35);

var _zhCn2 = _interopRequireDefault(_zhCn);

var _util = __webpack_require__(2);

var _body = __webpack_require__(16);

var _body2 = _interopRequireDefault(_body);

var _header = __webpack_require__(48);

var _header2 = _interopRequireDefault(_header);

var _wrapper = __webpack_require__(121);

var _wrapper2 = _interopRequireDefault(_wrapper);

var _row = __webpack_require__(17);

var _row2 = _interopRequireDefault(_row);

var _cell = __webpack_require__(18);

var _cell2 = _interopRequireDefault(_cell);

var _filter = __webpack_require__(49);

var _filter2 = _interopRequireDefault(_filter);

var _sort = __webpack_require__(63);

var _sort2 = _interopRequireDefault(_sort);

var _column = __webpack_require__(23);

var _column2 = _interopRequireDefault(_column);

var _columnGroup = __webpack_require__(122);

var _columnGroup2 = _interopRequireDefault(_columnGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var Children = _react2.default.Children,
    noop = function noop() {};

//<Table>
//    <Table.Column/>
//    <Table.ColumnGroup>
//      <Table.Column/>
//      <Table.Column/>
//    </Table.ColumnGroup>
//</Table>

/** Table */
var Table = (_temp = _class = function (_React$Component) {
    _inherits(Table, _React$Component);

    function Table(props, context) {
        _classCallCheck(this, Table);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

        _this.state = {
            sort: _this.props.sort || {}
        };

        _this.onSort = function (dataIndex, order, sort) {
            if (typeof _this.props.sort === 'undefined') {
                _this.setState({
                    sort: sort
                }, function () {
                    _this.props.onSort(dataIndex, order, sort);
                });
            } else {
                _this.props.onSort(dataIndex, order, sort);
            }
        };

        _this.onFilter = function (filterParams) {
            _this.props.onFilter(filterParams);
        };

        _this.onResizeChange = function (dataIndex, value) {
            _this.props.onResizeChange(dataIndex, value);
        };

        _this.getWrapperRef = function (wrapper) {
            if (!wrapper) {
                return _this.wrapper;
            }
            _this.wrapper = wrapper;
        };

        _this.getAffixRef = function (affixRef) {
            if (!affixRef) {
                return _this.affixRef;
            }
            _this.affixRef = affixRef;
        };

        _this.getHeaderCellRef = function (i, j, cell) {
            var cellRef = 'header_cell_' + i + '_' + j;
            if (!cell) {
                return _this[cellRef];
            }
            _this[cellRef] = cell;
        };

        _this.getRowRef = function (i, row) {
            var rowRef = 'row_' + i;
            if (!row) {
                return _this[rowRef];
            }
            _this[rowRef] = row;
        };

        _this.getCellRef = function (i, j, cell) {
            var cellRef = 'cell_' + i + '_' + j;
            if (!cell) {
                return _this[cellRef];
            }
            _this[cellRef] = cell;
        };

        var _this$context = _this.context,
            getTableInstance = _this$context.getTableInstance,
            getTableInstanceForVirtual = _this$context.getTableInstanceForVirtual;

        getTableInstance && getTableInstance(props.lockType, _this);
        getTableInstanceForVirtual && getTableInstanceForVirtual(props.lockType, _this);
        _this.notRenderCellIndex = [];
        return _this;
    }

    Table.prototype.getChildContext = function getChildContext() {
        return {
            notRenderCellIndex: this.notRenderCellIndex,
            lockType: this.props.lockType
        };
    };

    Table.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (typeof this.props.sort !== 'undefined') {
            this.setState({
                sort: nextProps.sort
            });
        }
    };

    Table.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState, nextContext) {
        if (nextProps.pure) {
            var isEqual = (0, _shallowElementEquals2.default)(nextProps, this.props) && _util.obj.shallowEqual(nextState, this.state) && _util.obj.shallowEqual(nextContext, this.context);
            return !isEqual;
        }

        return true;
    };

    Table.prototype.componentWillUpdate = function componentWillUpdate() {
        this.notRenderCellIndex = [];
    };

    Table.prototype.normalizeChildrenState = function normalizeChildrenState(props) {
        var columns = props.columns;
        if (props.children) {
            columns = this.normalizeChildren(props);
        }
        return this.fetchInfoFromBinaryChildren(columns);
    };

    // 将React结构化数据提取props转换成数组


    Table.prototype.normalizeChildren = function normalizeChildren(props) {
        var columns = props.columns;

        var getChildren = function getChildren(children) {
            var ret = [];
            Children.forEach(children, function (child) {
                if (child) {
                    var _props = _extends({}, child.props);

                    if (!(child && typeof child.type === 'function' && (child.type._typeMark === 'column' || child.type._typeMark === 'columnGroup'))) {
                        _util.log.warning('Use <Table.Column/>, <Table.ColumnGroup/> as child.');
                    }
                    ret.push(_props);
                    if (child.props.children) {
                        _props.children = getChildren(child.props.children);
                    }
                }
            });
            return ret;
        };
        if (props.children) {
            columns = getChildren(props.children);
        }
        return columns;
    };

    Table.prototype.fetchInfoFromBinaryChildren = function fetchInfoFromBinaryChildren(children) {
        var hasGroupHeader = false;
        var flatChildren = [],
            groupChildren = [],
            getChildren = function getChildren(propsChildren, level) {
            groupChildren[level] = groupChildren[level] || [];
            propsChildren.forEach(function (child) {
                if (child.children) {
                    hasGroupHeader = true;
                    getChildren(child.children, level + 1);
                } else {
                    flatChildren.push(child);
                }
                groupChildren[level].push(child);
            });
        },
            getColSpan = function getColSpan(children, colSpan) {
            colSpan = colSpan || 0;
            children.forEach(function (child) {
                if (child.children) {
                    colSpan = getColSpan(child.children, colSpan);
                } else {
                    colSpan += 1;
                }
            });
            return colSpan;
        };

        getChildren(children, 0);

        groupChildren.forEach(function (groupChild, i) {
            groupChild.forEach(function (child, j) {
                var colSpan = void 0;
                var children = child.children;

                if (children) {
                    colSpan = getColSpan(children);
                    child.colSpan = colSpan;
                    groupChildren[i][j] = child;
                }
            });
        });

        return {
            flatChildren: flatChildren,
            groupChildren: groupChildren,
            hasGroupHeader: hasGroupHeader
        };
    };

    Table.prototype.renderColGroup = function renderColGroup(flatChildren) {
        var cols = flatChildren.map(function (col, index) {
            var width = col.width;
            var style = {};
            if (width) {
                style = {
                    width: width
                };
            }

            return _react2.default.createElement('col', { style: style, key: index });
        });
        return _react2.default.createElement(
            'colgroup',
            { key: 'table-colgroup' },
            cols
        );
    };

    // 通过头部和扁平的结构渲染表格
    Table.prototype.renderTable = function renderTable(groupChildren, flatChildren) {
        if (flatChildren.length || !flatChildren.length && !this.props.lockType) {
            var _props2 = this.props,
                hasHeader = _props2.hasHeader,
                components = _props2.components,
                prefix = _props2.prefix,
                wrapperContent = _props2.wrapperContent,
                filterParams = _props2.filterParams,
                locale = _props2.locale,
                dataSource = _props2.dataSource,
                emptyContent = _props2.emptyContent,
                loading = _props2.loading,
                getCellProps = _props2.getCellProps,
                primaryKey = _props2.primaryKey,
                getRowProps = _props2.getRowProps,
                onRowClick = _props2.onRowClick,
                onRowMouseEnter = _props2.onRowMouseEnter,
                onRowMouseLeave = _props2.onRowMouseLeave,
                pure = _props2.pure;
            var sort = this.state.sort;
            var _components$Header = components.Header,
                Header = _components$Header === undefined ? _header2.default : _components$Header,
                _components$Wrapper = components.Wrapper,
                Wrapper = _components$Wrapper === undefined ? _wrapper2.default : _components$Wrapper,
                _components$Body = components.Body,
                Body = _components$Body === undefined ? _body2.default : _components$Body;

            var colGroup = this.renderColGroup(flatChildren);

            return _react2.default.createElement(
                Wrapper,
                {
                    colGroup: colGroup,
                    ref: this.getWrapperRef,
                    prefix: prefix
                },
                hasHeader ? _react2.default.createElement(Header, {
                    prefix: prefix,
                    pure: pure,
                    affixRef: this.getAffixRef,
                    colGroup: colGroup,
                    className: prefix + 'table-header',
                    filterParams: filterParams,
                    columns: groupChildren,
                    locale: locale,
                    headerCellRef: this.getHeaderCellRef,
                    components: components,
                    onFilter: this.onFilter,
                    sort: sort,
                    onResizeChange: this.onResizeChange,
                    onSort: this.onSort
                }) : null,
                _react2.default.createElement(Body, {
                    prefix: prefix,
                    pure: pure,
                    colGroup: colGroup,
                    className: prefix + 'table-body',
                    components: components,
                    loading: loading,
                    emptyContent: emptyContent,
                    getCellProps: getCellProps,
                    primaryKey: primaryKey,
                    getRowProps: getRowProps,
                    columns: flatChildren,
                    rowRef: this.getRowRef,
                    cellRef: this.getCellRef,
                    onRowClick: onRowClick,
                    onRowMouseEnter: onRowMouseEnter,
                    onRowMouseLeave: onRowMouseLeave,
                    dataSource: dataSource,
                    locale: locale
                }),
                wrapperContent
            );
        } else {
            return null;
        }
    };

    Table.prototype.render = function render() {
        var _classnames;

        var ret = this.normalizeChildrenState(this.props);
        this.groupChildren = ret.groupChildren;
        this.flatChildren = ret.flatChildren;
        /* eslint-disable no-unused-vars, prefer-const */
        var table = this.renderTable(ret.groupChildren, ret.flatChildren),
            _props3 = this.props,
            className = _props3.className,
            hasBorder = _props3.hasBorder,
            isZebra = _props3.isZebra,
            loading = _props3.loading,
            hasHeader = _props3.hasHeader,
            prefix = _props3.prefix,
            dataSource = _props3.dataSource,
            entireDataSource = _props3.entireDataSource,
            onSort = _props3.onSort,
            onResizeChange = _props3.onResizeChange,
            onRowClick = _props3.onRowClick,
            onRowMouseEnter = _props3.onRowMouseEnter,
            onRowMouseLeave = _props3.onRowMouseLeave,
            onFilter = _props3.onFilter,
            getRowProps = _props3.getRowProps,
            getCellProps = _props3.getCellProps,
            primaryKey = _props3.primaryKey,
            components = _props3.components,
            wrapperContent = _props3.wrapperContent,
            lockType = _props3.lockType,
            locale = _props3.locale,
            refs = _props3.refs,
            pure = _props3.pure,
            rtl = _props3.rtl,
            emptyContent = _props3.emptyContent,
            filterParams = _props3.filterParams,
            _props3$loadingCompon = _props3.loadingComponent,
            LoadingComponent = _props3$loadingCompon === undefined ? _loading2.default : _props3$loadingCompon,
            others = _objectWithoutProperties(_props3, ['className', 'hasBorder', 'isZebra', 'loading', 'hasHeader', 'prefix', 'dataSource', 'entireDataSource', 'onSort', 'onResizeChange', 'onRowClick', 'onRowMouseEnter', 'onRowMouseLeave', 'onFilter', 'getRowProps', 'getCellProps', 'primaryKey', 'components', 'wrapperContent', 'lockType', 'locale', 'refs', 'pure', 'rtl', 'emptyContent', 'filterParams', 'loadingComponent']),
            cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table'] = true, _classnames['only-bottom-border'] = !hasBorder, _classnames['no-header'] = !hasHeader, _classnames.zebra = isZebra, _classnames[className] = className, _classnames));


        if (rtl) {
            others.dir = 'rtl';
        }
        var content = _react2.default.createElement(
            'div',
            _extends({ className: cls }, others),
            table
        );
        if (loading) {
            var loadingClassName = prefix + 'table-loading';
            return _react2.default.createElement(
                LoadingComponent,
                { className: loadingClassName },
                content
            );
        }
        return content;
    };

    return Table;
}(_react2.default.Component), _class.Column = _column2.default, _class.ColumnGroup = _columnGroup2.default, _class.Header = _header2.default, _class.Body = _body2.default, _class.Wrapper = _wrapper2.default, _class.Row = _row2.default, _class.Cell = _cell2.default, _class.Filter = _filter2.default, _class.Sort = _sort2.default, _class.propTypes = {
    /**
     * 样式类名的品牌前缀
     */
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    rtl: _propTypes2.default.bool,
    /**
     * 自定义类名
     */
    className: _propTypes2.default.string,
    /**
     * 自定义内联样式
     */
    style: _propTypes2.default.object,
    /**
     * 表格展示的数据源
     */
    dataSource: _propTypes2.default.array,
    entireDataSource: _propTypes2.default.array,
    /**
     * 点击表格每一行触发的事件
     * @param {Object} record 该行所对应的数据
     * @param {Number} index 该行所对应的序列
     * @param {Event} e DOM事件对象
     */
    onRowClick: _propTypes2.default.func,
    /**
     * 悬浮在表格每一行的时候触发的事件
     * @param {Object} record 该行所对应的数据
     * @param {Number} index 该行所对应的序列
     * @param {Event} e DOM事件对象
     */
    onRowMouseEnter: _propTypes2.default.func,
    /**
     * 离开表格每一行的时候触发的事件
     * @param {Object} record 该行所对应的数据
     * @param {Number} index 该行所对应的序列
     * @param {Event} e DOM事件对象
     */
    onRowMouseLeave: _propTypes2.default.func,
    /**
     * 点击列排序触发的事件
     * @param {String} dataIndex 指定的排序的字段
     * @param {String} order 排序对应的顺序, 有`desc`和`asc`两种
     */
    onSort: _propTypes2.default.func,
    /**
     * 点击过滤确认按钮触发的事件
     * @param {Object} filterParams 过滤的字段信息
     */
    onFilter: _propTypes2.default.func,
    /**
     * 重设列尺寸的时候触发的事件
     * @param {String} dataIndex 指定重设的字段
     * @param {Number} value 列宽变动的数值
     */
    onResizeChange: _propTypes2.default.func,
    /**
     * 设置每一行的属性，如果返回值和其他针对行操作的属性冲突则无效。
     * @param {Object} record 该行所对应的数据
     * @param {Number} index 该行所对应的序列
     * @returns {Object} 需要设置的行属性
     */
    getRowProps: _propTypes2.default.func,
    /**
     * 设置单元格的属性，通过该属性可以进行合并单元格
     * @param {Number} rowIndex 该行所对应的序列
     * @param {Number} colIndex 该列所对应的序列
     * @param {String} dataIndex 该列所对应的字段名称
     * @param {Object} record 该行对应的记录
     * @returns {Object} 返回td元素的所支持的属性对象
     */
    getCellProps: _propTypes2.default.func,
    /**
     * 表格是否具有边框
     */
    hasBorder: _propTypes2.default.bool,
    /**
     * 表格是否具有头部
     */
    hasHeader: _propTypes2.default.bool,
    /**
     * 表格是否是斑马线
     */
    isZebra: _propTypes2.default.bool,
    /**
     * 表格是否在加载中
     */
    loading: _propTypes2.default.bool,
    /**
     * 自定义 Loading 组件
     * @type {Function}
     */
    loadingComponent: _propTypes2.default.func,
    /**
     * 当前过滤的的keys,使用此属性可以控制表格的头部的过滤选项中哪个菜单被选中,格式为 {dataIndex: {selectedKeys:[]}}
     * 示例:
     * 假设要控制dataIndex为id的列的过滤菜单中key为one的菜单项选中
     * `<Table filterParams={{id: {selectedKeys: ['one']}}}/>`
     */
    filterParams: _propTypes2.default.object,
    /**
     * 当前排序的字段,使用此属性可以控制表格的字段的排序,格式为{dataIndex: 'asc'}
     */
    sort: _propTypes2.default.object,
    /**
     * 自定义国际化文案对象
     * @property {String} ok 过滤器中确认按钮文案
     * @property {String} reset 过滤器中重置按钮文案
     * @property {String} empty 没有数据情况下 table内的文案
     * @property {String} asc 排序升序状态下的文案
     * @property {String} desc 排序将序状态下的文案
     * @property {String} expanded 可折叠行，展开状态下的文案
     * @property {String} folded 可折叠行，折叠状态下的文案
     * @property {String} filter 过滤器文案
     * @property {String} selectAll header里全选的按钮文案
     */
    locale: _propTypes2.default.object,
    components: _propTypes2.default.object,
    columns: _propTypes2.default.array,
    /**
     * 设置数据为空的时候的表格内容展现
     */
    emptyContent: _propTypes2.default.node,
    /**
     * dataSource当中数据的主键，如果给定的数据源中的属性不包含该主键，会造成选择状态全部选中
     */
    primaryKey: _propTypes2.default.string,
    lockType: _propTypes2.default.oneOf(['left', 'right']),
    wrapperContent: _propTypes2.default.any,
    refs: _propTypes2.default.object,
    /**
     * 额外渲染行的渲染函数
     * @param {Object} record 该行所对应的数据
     * @param {Number} index 该行所对应的序列
     * @returns {Element} 渲染内容
     */
    expandedRowRender: _propTypes2.default.func,
    /**
     * 额外渲染行的缩进
     */
    expandedRowIndent: _propTypes2.default.array,
    /**
     * 默认情况下展开的渲染行或者Tree, 传入此属性为受控状态
     */
    openRowKeys: _propTypes2.default.array,
    /**
     * 是否显示点击展开额外渲染行的+号按钮
     */
    hasExpandedRowCtrl: _propTypes2.default.bool,
    /**
     * 设置额外渲染行的属性
     */
    getExpandedColProps: _propTypes2.default.func,
    /**
     * 在额外渲染行或者Tree展开或者收起的时候触发的事件
     * @param {Array} openRowKeys 展开的渲染行的key
     * @param {String} currentRowKey 当前点击的渲染行的key
     * @param {Boolean} expanded 当前点击是展开还是收起
     * @param {Object} currentRecord 当前点击额外渲染行的记录
     */
    onRowOpen: _propTypes2.default.func,
    /**
     * 点击额外渲染行触发的事件
     * @param {Object} record 该行所对应的数据
     * @param {Number} index 该行所对应的序列
     * @param {Event} e DOM事件对象
     */
    onExpandedRowClick: _propTypes2.default.func,
    /**
     * 表头是否固定，该属性配合maxBodyHeight使用，当内容区域的高度超过maxBodyHeight的时候，在内容区域会出现滚动条
     */
    fixedHeader: _propTypes2.default.bool,
    /**
     * 最大内容区域的高度,在`fixedHeader`为`true`的时候,超过这个高度会出现滚动条
     */
    maxBodyHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    /**
     * 是否启用选择模式
     * @property {Function} getProps `Function(record, index)=>Object` 获取selection的默认属性
     * @property {Function} onChange `Function(selectedRowKeys:Array, records:Array)` 选择改变的时候触发的事件，**注意:** 其中records只会包含当前dataSource的数据，很可能会小于selectedRowKeys的长度。
     * @property {Function} onSelect `Function(selected:Boolean, record:Object, records:Array)` 用户手动选择/取消选择某行的回调
     * @property {Function} onSelectAll `Function(selected:Boolean, records:Array)` 用户手动选择/取消选择所有行的回调
     * @property {Array} selectedRowKeys 设置了此属性,将rowSelection变为受控状态,接收值为该行数据的primaryKey的值
     * @property {String} mode 选择selection的模式, 可选值为`single`, `multiple`，默认为`multiple`
     */
    rowSelection: _propTypes2.default.object,
    /**
     * 表头是否是sticky
     */
    stickyHeader: _propTypes2.default.bool,
    /**
     * 距离窗口顶部达到指定偏移量后触发
     */
    offsetTop: _propTypes2.default.number,
    /**
     * affix组件的的属性
     */
    affixProps: _propTypes2.default.object,
    /**
     * 在tree模式下的缩进尺寸， 仅在isTree为true时候有效
     */
    indent: _propTypes2.default.number,
    /**
     * 开启Table的tree模式, 接收的数据格式中包含children则渲染成tree table
     */
    isTree: _propTypes2.default.bool,
    /**
     * 是否开启虚拟滚动
     */
    useVirtual: _propTypes2.default.bool,
    /**
     * 设置行高
     */
    rowHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.func]),
    /**
     * 在内容区域滚动的时候触发的函数
     */
    onBodyScroll: _propTypes2.default.func
}, _class.defaultProps = {
    dataSource: [],
    onRowClick: noop,
    onRowMouseEnter: noop,
    onRowMouseLeave: noop,
    onSort: noop,
    onFilter: noop,
    onResizeChange: noop,
    getRowProps: noop,
    getCellProps: noop,
    prefix: 'next-',
    hasBorder: true,
    hasHeader: true,
    isZebra: false,
    loading: false,
    primaryKey: 'id',
    components: {},
    locale: _zhCn2.default.Table
}, _class.childContextTypes = {
    notRenderCellIndex: _propTypes2.default.array,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}, _class.contextTypes = {
    getTableInstance: _propTypes2.default.func,
    getTableInstanceForVirtual: _propTypes2.default.func
}, _temp);
Table.displayName = 'Table';
exports.default = Table;
module.exports = exports['default'];

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var hasOwnProperty = Object.prototype.hasOwnProperty;

function transformEntryEqual(a, b) {
  for (var k in a) {
    if (hasOwnProperty.call(a, k)) {
      return a[k] === b[k];
    }
  }
  return false;
}

function transformEqual(a, b) {
  if (!a && !b || a === b) {
    return true;
  }
  if (!a !== !b) {
    return false;
  }
  if (a.length !== b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!transformEntryEqual(a[i], b[i])) {
      return false;
    }
  }
  return true;
}

function shallowObjectEquals(a, b) {
  var k;
  var i = 0;
  var j = 0;
  for (k in a) {
    if (hasOwnProperty.call(a, k)) {
      switch (k) {
        case 'transform':
          if (!transformEqual(a[k], b[k])) {
            return false;
          }
          break;
        case 'shadowOffset':
          if (!shallowObjectEquals(a[k], b[k])) {
            return false;
          }
          break;
        default:
          if (a[k] !== b[k]) {
            return false;
          }
          break;
      }
      i++;
    }
  }
  for (k in b) {
    if (hasOwnProperty.call(b, k)) {
      j++;
    }
  }
  return i === j;
}

function styleEqual(a, b) {
  if (!a && !b || a === b) {
    return true;
  }
  if (!a !== !b) {
    return false;
  }
  switch (typeof a === 'undefined' ? 'undefined' : _typeof(a)) {
    case 'object':
      if (a instanceof Array) {
        for (var i = 0; i < a.length; i++) {
          if (!styleEqual(a[i], b[i])) {
            return false;
          }
        }
        return a.length === b.length;
      } else {
        return shallowObjectEquals(a, b);
      }
      break;
    case 'number':
    default:
      return a === b;
  }
}

module.exports = styleEqual;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var overlayManager = {
    allOverlays: [],

    addOverlay: function addOverlay(overlay) {
        this.removeOverlay(overlay);
        this.allOverlays.unshift(overlay);
    },
    isCurrentOverlay: function isCurrentOverlay(overlay) {
        return overlay && this.allOverlays[0] === overlay;
    },
    removeOverlay: function removeOverlay(overlay) {
        var i = this.allOverlays.indexOf(overlay);
        if (i > -1) {
            this.allOverlays.splice(i, 1);
        }
    }
};

exports.default = overlayManager;
module.exports = exports["default"];

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _util = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var VIEWPORT = 'viewport';

// IE8 not support pageXOffset
var getPageX = function getPageX() {
    return window.pageXOffset || document.documentElement.scrollLeft;
};
var getPageY = function getPageY() {
    return window.pageYOffset || document.documentElement.scrollTop;
};

/**
 * @private get element rect
 * @param       {Element} elem
 * @return      {Object}
 */
function _getElementRect(elem) {
    var offsetTop = 0,
        offsetLeft = 0;

    var offsetHeight = elem.offsetHeight;
    var offsetWidth = elem.offsetWidth;

    do {
        if (!isNaN(elem.offsetTop)) {
            offsetTop += elem.offsetTop;
        }
        if (!isNaN(elem.offsetLeft)) {
            offsetLeft += elem.offsetLeft;
        }
    } while ((elem = elem.offsetParent) !== null);

    return {
        top: offsetTop - (document.documentElement.scrollTop || document.body.scrollTop),
        left: offsetLeft - (document.documentElement.scrollLeft || document.body.scrollLeft),
        height: offsetHeight,
        width: offsetWidth
    };
}

/**
 * @private get viewport size
 * @return {Object}
 */
function _getViewportSize() {
    return {
        width: document.documentElement.clientWidth,
        height: document.documentElement.clientHeight
    };
}
var Position = (_temp = _class = function () {
    function Position(props) {
        _classCallCheck(this, Position);

        this.pinElement = props.pinElement;
        this.baseElement = props.baseElement;
        this.align = props.align || 'tl tl';
        this.offset = props.offset || [0, 0];
        this.needAdjust = props.needAdjust || false;
        this.isRtl = props.isRtl || false;
    }

    /**
     * @public static place method
     * @param  {Object}       props
     *     @param  {DOM}      props.pinElement
     *     @param  {DOM}      props.baseElement
     *     @param  {String}   props.align
     *     @param  {Number}   props.offset
     *     @param  {Boolean}  props.needAdjust
     *     @param  {Boolean}  props.isRtl
     * @return {Position}
     */


    Position.prototype.setPosition = function setPosition() {
        var pinElement = this.pinElement;
        var baseElement = this.baseElement;
        var expectedAlign = this._getExpectedAlign();
        var isPinFixed = void 0,
            isBaseFixed = void 0,
            firstPositionResult = void 0;
        if (pinElement === VIEWPORT) {
            return;
        }
        if (_util.dom.getStyle(pinElement, 'position') !== 'fixed') {
            _util.dom.setStyle(pinElement, 'position', 'absolute');
            isPinFixed = false;
        } else {
            isPinFixed = true;
        }
        if (baseElement === VIEWPORT || _util.dom.getStyle(baseElement, 'position') !== 'fixed') {
            isBaseFixed = false;
        } else {
            isBaseFixed = true;
        }
        // 根据期望的定位
        for (var i = 0; i < expectedAlign.length; i++) {
            var align = expectedAlign[i];
            var pinElementPoints = this._normalizePosition(pinElement, align.split(' ')[0], isPinFixed);
            var baseElementPoints = this._normalizePosition(baseElement, align.split(' ')[1], isPinFixed);
            var pinElementParentOffset = this._getParentOffset(pinElement);
            var baseElementOffset = isPinFixed && isBaseFixed ? this._getLeftTop(baseElement) : baseElementPoints.offset();
            var top = baseElementOffset.top + baseElementPoints.y - pinElementParentOffset.top - pinElementPoints.y;
            var left = baseElementOffset.left + baseElementPoints.x - pinElementParentOffset.left - pinElementPoints.x;
            this._setPinElementPostion(pinElement, { left: left, top: top }, this.offset);

            if (!firstPositionResult) {
                firstPositionResult = { left: left, top: top };
            }
            if (this._isInViewport(pinElement)) {
                return align;
            }
        }

        var inViewportLeft = this._makeElementInViewport(pinElement, firstPositionResult.left, 'Left', isPinFixed);
        var inViewportTop = this._makeElementInViewport(pinElement, firstPositionResult.top, 'Top', isPinFixed);

        this._setPinElementPostion(pinElement, { left: inViewportLeft, top: inViewportTop });
        return expectedAlign[0];
    };

    Position.prototype._getParentOffset = function _getParentOffset(element) {
        var parent = element.offsetParent || document.documentElement;
        var offset = void 0;
        if (parent === document.body && _util.dom.getStyle(parent, 'position') === 'static') {
            offset = {
                top: 0,
                left: 0
            };
        } else {
            offset = this._getElementOffset(parent);
        }

        offset.top += parseFloat(_util.dom.getStyle(parent, 'border-top-width'), 10);
        offset.left += parseFloat(_util.dom.getStyle(parent, 'border-left-width'), 10);
        offset.offsetParent = parent;
        return offset;
    };

    Position.prototype._makeElementInViewport = function _makeElementInViewport(pinElement, number, type, isPinFixed) {
        var result = number;
        var docElement = document.documentElement;
        var offsetParent = pinElement.offsetParent || document.documentElement;

        if (result < 0) {
            if (isPinFixed) {
                result = 0;
            } else if (offsetParent === document.body && _util.dom.getStyle(offsetParent, 'position') === 'static') {
                // Only when div's offsetParent is document.body, we set new position result.
                result = Math.max(docElement['scroll' + type], document.body['scroll' + type]);
            }
        }

        return result;
    };

    Position.prototype._normalizePosition = function _normalizePosition(element, align, isPinFixed) {
        var points = this._normalizeElement(element, isPinFixed);
        this._normalizeXY(points, align);

        return points;
    };

    Position.prototype._normalizeXY = function _normalizeXY(points, align) {
        var x = align.split('')[1];
        var y = align.split('')[0];

        points.x = this._xyConverter(x, points, 'width');
        points.y = this._xyConverter(y, points, 'height');

        return points;
    };

    Position.prototype._xyConverter = function _xyConverter(align, points, type) {
        var res = align.replace(/t|l/gi, '0%').replace(/c/gi, '50%').replace(/b|r/gi, '100%').replace(/(\d+)%/gi, function (m, d) {
            return points.size()[type] * (d / 100);
        });

        return parseFloat(res, 10) || 0;
    };

    Position.prototype._getLeftTop = function _getLeftTop(element) {
        return {
            left: parseFloat(_util.dom.getStyle(element, 'left')) || 0,
            top: parseFloat(_util.dom.getStyle(element, 'top')) || 0
        };
    };

    Position.prototype._normalizeElement = function _normalizeElement(element, isPinFixed) {
        var _this = this;

        var result = {
            element: element,
            x: 0,
            y: 0
        },
            isViewport = element === VIEWPORT,
            docElement = document.documentElement;

        result.offset = function () {
            if (isPinFixed) {
                return {
                    left: 0,
                    top: 0
                };
            } else if (isViewport) {
                return {
                    left: getPageX(),
                    top: getPageY()
                };
            } else {
                return _this._getElementOffset(element);
            }
        };

        result.size = function () {
            if (isViewport) {
                return {
                    width: docElement.clientWidth,
                    height: docElement.clientHeight
                };
            } else {
                return {
                    width: element.offsetWidth,
                    height: element.offsetHeight
                };
            }
        };

        return result;
    };

    Position.prototype._getElementOffset = function _getElementOffset(element) {
        var rect = element.getBoundingClientRect();
        var docElement = document.documentElement;
        var body = document.body;
        var docClientLeft = docElement.clientLeft || body.clientLeft || 0;
        var docClientTop = docElement.clientTop || body.clientTop || 0;

        return {
            left: rect.left + (getPageX() - docClientLeft),
            top: rect.top + (getPageY() - docClientTop)
        };
    };

    // According to the location of the overflow to calculate the desired positioning


    Position.prototype._getExpectedAlign = function _getExpectedAlign() {
        var align = this.isRtl ? this._replaceAlignDir(this.align, /l|r/g, { l: 'r', r: 'l' }) : this.align;
        var expectedAlign = [align];

        if (this.needAdjust) {
            if (/t|b/g.test(align)) {
                expectedAlign.push(this._replaceAlignDir(align, /t|b/g, { t: 'b', b: 't' }));
            }
            if (/l|r/g.test(align)) {
                expectedAlign.push(this._replaceAlignDir(align, /l|r/g, { l: 'r', r: 'l' }));
            }
            if (/c/g.test(align)) {
                expectedAlign.push(this._replaceAlignDir(align, /c(?= |$)/g, { c: 'l' }));
                expectedAlign.push(this._replaceAlignDir(align, /c(?= |$)/g, { c: 'r' }));
            }
            expectedAlign.push(this._replaceAlignDir(align, /l|r|t|b/g, { l: 'r', r: 'l', t: 'b', b: 't' }));
        }
        return expectedAlign;
    };

    // Transform align order.


    Position.prototype._replaceAlignDir = function _replaceAlignDir(align, regExp, map) {
        return align.replace(regExp, function (res) {
            return map[res];
        });
    };

    // Detecting element is in the window， we want to adjust position later.


    Position.prototype._isInViewport = function _isInViewport(element) {
        var viewportSize = _getViewportSize();
        // Avoid animate problem that use offsetWidth instead of getBoundingClientRect.
        var elementRect = _getElementRect(element);
        return elementRect.left >= 0 && elementRect.left + element.offsetWidth <= viewportSize.width && elementRect.top >= 0 && elementRect.top + element.offsetHeight <= viewportSize.height;
    };
    // 在这里做RTL判断 top-left 定位转化为等效的 top-right定位


    Position.prototype._setPinElementPostion = function _setPinElementPostion(pinElement, postion) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];
        var top = postion.top,
            left = postion.left;

        if (!this.isRtl) {
            _util.dom.setStyle(pinElement, {
                left: left + offset[0] + 'px',
                top: top + offset[1] + 'px'
            });
            return;
        }

        // transfer {left,top} equaly to {right,top}
        var pinElementParentOffset = this._getParentOffset(pinElement);

        var _getElementRect2 = _getElementRect(pinElementParentOffset.offsetParent),
            offsetParentWidth = _getElementRect2.width;

        var _getElementRect3 = _getElementRect(pinElement),
            width = _getElementRect3.width;

        var right = offsetParentWidth - (left + width);
        _util.dom.setStyle(pinElement, {
            left: 'auto',
            right: right + offset[0] + 'px',
            top: top + offset[1] + 'px'
        });
    };

    return Position;
}(), _class.VIEWPORT = VIEWPORT, _class.place = function (props) {
    return new Position(props).setPosition();
}, _temp);
exports.default = Position;
module.exports = exports['default'];

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

var _overlay = __webpack_require__(45);

var _overlay2 = _interopRequireDefault(_overlay);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = _util.func.noop,
    makeChain = _util.func.makeChain,
    bindCtx = _util.func.bindCtx;

/**
 * Overlay.Popup
 * @description 继承 Overlay 的 API，除非特别说明
 * */

var Popup = (_temp = _class = function (_Component) {
    _inherits(Popup, _Component);

    function Popup(props) {
        _classCallCheck(this, Popup);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        _this.state = {
            visible: typeof props.visible === 'undefined' ? props.defaultVisible : props.visible
        };

        bindCtx(_this, ['handleTriggerClick', 'handleTriggerKeyDown', 'handleTriggerMouseEnter', 'handleTriggerMouseLeave', 'handleTriggerFocus', 'handleTriggerBlur', 'handleContentMouseEnter', 'handleContentMouseLeave', 'handleContentMouseDown', 'handleRequestClose', 'handleMaskMouseEnter', 'handleMaskMouseLeave']);
        return _this;
    }

    Popup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if ('visible' in nextProps) {
            this.setState({
                visible: nextProps.visible
            });
        }
    };

    Popup.prototype.componentWillUnmount = function componentWillUnmount() {
        var _this2 = this;

        ['_timer', '_hideTimer', '_showTimer'].forEach(function (time) {
            _this2[time] && clearTimeout(_this2[time]);
        });
    };

    Popup.prototype.handleVisibleChange = function handleVisibleChange(visible, type, e) {
        if (!('visible' in this.props)) {
            this.setState({
                visible: visible
            });
        }

        this.props.onVisibleChange(visible, type, e);
    };

    Popup.prototype.handleTriggerClick = function handleTriggerClick(e) {
        if (this.state.visible && !this.props.canCloseByTrigger) {
            return;
        }

        this.handleVisibleChange(!this.state.visible, 'fromTrigger', e);
    };

    Popup.prototype.handleTriggerKeyDown = function handleTriggerKeyDown(e) {
        if (e.keyCode === _util.KEYCODE.SPACE || e.keyCode === _util.KEYCODE.ENTER) {
            e.preventDefault();
            this.handleTriggerClick(e);
        }
    };

    Popup.prototype.handleTriggerMouseEnter = function handleTriggerMouseEnter(e) {
        var _this3 = this;

        this._mouseNotFirstOnMask = false;

        if (this._hideTimer) {
            clearTimeout(this._hideTimer);
            this._hideTimer = null;
        }
        if (this._showTimer) {
            clearTimeout(this._showTimer);
            this._showTimer = null;
        }
        if (!this.state.visible) {
            this._showTimer = setTimeout(function () {
                _this3.handleVisibleChange(true, 'fromTrigger', e);
            }, this.props.delay);
        }
    };

    Popup.prototype.handleTriggerMouseLeave = function handleTriggerMouseLeave(e, type) {
        var _this4 = this;

        if (this._showTimer) {
            clearTimeout(this._showTimer);
            this._showTimer = null;
        }
        if (this.state.visible) {
            this._hideTimer = setTimeout(function () {
                _this4.handleVisibleChange(false, type || 'fromTrigger', e);
            }, this.props.delay);
        }
    };

    Popup.prototype.handleTriggerFocus = function handleTriggerFocus(e) {
        this.handleVisibleChange(true, 'fromTrigger', e);
    };

    Popup.prototype.handleTriggerBlur = function handleTriggerBlur(e) {
        if (!this._isForwardContent) {
            this.handleVisibleChange(false, 'fromTrigger', e);
        }
        this._isForwardContent = false;
    };

    Popup.prototype.handleContentMouseDown = function handleContentMouseDown() {
        this._isForwardContent = true;
    };

    Popup.prototype.handleContentMouseEnter = function handleContentMouseEnter() {
        clearTimeout(this._hideTimer);
    };

    Popup.prototype.handleContentMouseLeave = function handleContentMouseLeave(e) {
        this.handleTriggerMouseLeave(e, 'fromContent');
    };

    Popup.prototype.handleMaskMouseEnter = function handleMaskMouseEnter() {
        if (!this._mouseNotFirstOnMask) {
            clearTimeout(this._hideTimer);
            this._hideTimer = null;
            this._mouseNotFirstOnMask = false;
        }
    };

    Popup.prototype.handleMaskMouseLeave = function handleMaskMouseLeave() {
        this._mouseNotFirstOnMask = true;
    };

    Popup.prototype.handleRequestClose = function handleRequestClose(type, e) {
        this.handleVisibleChange(false, type, e);
    };

    Popup.prototype.renderTrigger = function renderTrigger() {
        var _this5 = this;

        var _props = this.props,
            trigger = _props.trigger,
            disabled = _props.disabled;

        var props = {
            key: 'trigger',
            'aria-haspopup': true,
            'aria-expanded': this.state.visible
        };

        if (!disabled) {
            var triggerType = this.props.triggerType;

            var triggerTypes = Array.isArray(triggerType) ? triggerType : [triggerType];
            var _trigger$props = trigger.props,
                onClick = _trigger$props.onClick,
                onKeyDown = _trigger$props.onKeyDown,
                onMouseEnter = _trigger$props.onMouseEnter,
                onMouseLeave = _trigger$props.onMouseLeave,
                onFocus = _trigger$props.onFocus,
                onBlur = _trigger$props.onBlur;

            triggerTypes.forEach(function (triggerType) {
                switch (triggerType) {
                    case 'click':
                        props.onClick = makeChain(_this5.handleTriggerClick, onClick);
                        props.onKeyDown = makeChain(_this5.handleTriggerKeyDown, onKeyDown);
                        break;
                    case 'hover':
                        props.onMouseEnter = makeChain(_this5.handleTriggerMouseEnter, onMouseEnter);
                        props.onMouseLeave = makeChain(_this5.handleTriggerMouseLeave, onMouseLeave);
                        break;
                    case 'focus':
                        props.onFocus = makeChain(_this5.handleTriggerFocus, onFocus);
                        props.onBlur = makeChain(_this5.handleTriggerBlur, onBlur);
                        break;
                    default:
                        break;
                }
            });
        }

        return _react2.default.cloneElement(trigger, props);
    };

    Popup.prototype.renderContent = function renderContent() {
        var _this6 = this;

        var _props2 = this.props,
            children = _props2.children,
            triggerType = _props2.triggerType;

        var triggerTypes = Array.isArray(triggerType) ? triggerType : [triggerType];
        var content = _react.Children.only(children);
        var _content$props = content.props,
            onMouseDown = _content$props.onMouseDown,
            onMouseEnter = _content$props.onMouseEnter,
            onMouseLeave = _content$props.onMouseLeave;

        var props = {
            key: 'portal'
        };

        triggerTypes.forEach(function (triggerType) {
            switch (triggerType) {
                case 'focus':
                    props.onMouseDown = makeChain(_this6.handleContentMouseDown, onMouseDown);
                    break;
                case 'hover':
                    props.onMouseEnter = makeChain(_this6.handleContentMouseEnter, onMouseEnter);
                    props.onMouseLeave = makeChain(_this6.handleContentMouseLeave, onMouseLeave);
                    break;
                default:
                    break;
            }
        });

        return _react2.default.cloneElement(content, props);
    };

    Popup.prototype.renderPortal = function renderPortal() {
        var _this7 = this;

        var _props3 = this.props,
            target = _props3.target,
            safeNode = _props3.safeNode,
            followTrigger = _props3.followTrigger,
            triggerType = _props3.triggerType,
            hasMask = _props3.hasMask,
            wrapperStyle = _props3.wrapperStyle,
            others = _objectWithoutProperties(_props3, ['target', 'safeNode', 'followTrigger', 'triggerType', 'hasMask', 'wrapperStyle']);

        var container = this.props.container;

        var findTriggerNode = function findTriggerNode() {
            return (0, _reactDom.findDOMNode)(_this7) || {};
        };
        var safeNodes = Array.isArray(safeNode) ? [].concat(safeNode) : [safeNode];
        safeNodes.unshift(findTriggerNode);

        var newWrapperStyle = wrapperStyle || {};

        if (followTrigger) {
            container = function container(trigger) {
                return trigger.parentNode;
            };
            newWrapperStyle.position = 'relative';
        }

        if (triggerType === 'hover' && hasMask) {
            others.onMaskMouseEnter = this.handleMaskMouseEnter;
            others.onMaskMouseLeave = this.handleMaskMouseLeave;
        }

        return _react2.default.createElement(
            _overlay2.default,
            _extends({}, others, {
                key: 'overlay',
                ref: function ref(overlay) {
                    return _this7.overlay = overlay;
                },
                visible: this.state.visible,
                target: target || findTriggerNode,
                container: container,
                safeNode: safeNodes,
                wrapperStyle: newWrapperStyle,
                triggerType: triggerType,
                hasMask: hasMask,
                onRequestClose: this.handleRequestClose }),
            this.renderContent()
        );
    };

    Popup.prototype.render = function render() {
        return [this.renderTrigger(), this.renderPortal()];
    };

    return Popup;
}(_react.Component), _class.propTypes = {
    /**
     * 弹层内容
     */
    children: _propTypes2.default.node,
    /**
     * 触发弹层显示或隐藏的元素
     */
    trigger: _propTypes2.default.element,
    /**
     * 触发弹层显示或隐藏的操作类型，可以是 'click'，'hover'，'focus'，或者它们组成的数组，如 ['hover', 'focus']
     */
    triggerType: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),
    /**
     * 弹层当前是否显示
     */
    visible: _propTypes2.default.bool,
    /**
     * 弹层默认是否显示
     */
    defaultVisible: _propTypes2.default.bool,
    /**
     * 弹层显示或隐藏时触发的回调函数
     * @param {Boolean} visible 弹层是否显示
     * @param {String} type 触发弹层显示或隐藏的来源
     * @param {Object} e DOM事件
     */
    onVisibleChange: _propTypes2.default.func,
    /**
     * 设置此属性，弹层无法显示或隐藏
     */
    disabled: _propTypes2.default.bool,
    /**
     * 弹层显示或隐藏的延时时间（以毫秒为单位），在 triggerType 被设置为 hover 时生效
     */
    delay: _propTypes2.default.number,
    /**
     * 触发元素是否可以关闭弹层
     */
    canCloseByTrigger: _propTypes2.default.bool,
    /**
     * 弹层定位的参照元素
     * @default target 属性，即触发元素
     */
    target: _propTypes2.default.any,
    safeNode: _propTypes2.default.any,
    /**
     * 是否跟随trigger滚动
     */
    followTrigger: _propTypes2.default.bool,
    container: _propTypes2.default.any,
    hasMask: _propTypes2.default.bool,
    wrapperStyle: _propTypes2.default.object,
    rtl: _propTypes2.default.bool
}, _class.defaultProps = {
    triggerType: 'hover',
    defaultVisible: false,
    onVisibleChange: noop,
    disabled: false,
    delay: 200,
    canCloseByTrigger: true,
    followTrigger: false,
    container: function container() {
        return document.body;
    },
    rtl: false
}, _temp);
Popup.displayName = 'Popup';
exports.default = Popup;
module.exports = exports['default'];

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _overlay = __webpack_require__(15);

var _overlay2 = _interopRequireDefault(_overlay);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = _util.func.noop,
    makeChain = _util.func.makeChain,
    bindCtx = _util.func.bindCtx;

var Popup = _overlay2.default.Popup;

/**
 * Dropdown
 * @description 继承 Popup 的 API，除非特别说明
 */
var Dropdown = (_temp = _class = function (_Component) {
  _inherits(Dropdown, _Component);

  function Dropdown(props) {
    _classCallCheck(this, Dropdown);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.state = {
      visible: 'visible' in props ? props.visible : props.defaultVisible || false
    };

    bindCtx(_this, ['onMenuClick', 'onVisibleChange']);
    return _this;
  }

  Dropdown.prototype.getVisible = function getVisible() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;

    return 'visible' in props ? props.visible : this.state.visible;
  };

  Dropdown.prototype.onMenuClick = function onMenuClick() {
    this.onVisibleChange(false, 'fromContent');
  };

  Dropdown.prototype.onVisibleChange = function onVisibleChange(visible, from) {
    this.setState({ visible: visible });

    this.props.onVisibleChange(visible, from);
  };

  Dropdown.prototype.render = function render() {
    var child = _react.Children.only(this.props.children);
    if (typeof child.type === 'function' && child.type.isNextMenu) {
      child = _react2.default.cloneElement(child, {
        onItemClick: makeChain(this.onMenuClick, child.props.onItemClick)
      });
    }

    return _react2.default.createElement(
      Popup,
      _extends({}, this.props, {
        visible: this.getVisible(),
        onVisibleChange: this.onVisibleChange,
        canCloseByOutSideClick: true }),
      child
    );
  };

  return Dropdown;
}(_react.Component), _class.propTypes = {
  prefix: _propTypes2.default.string,
  pure: _propTypes2.default.bool,
  className: _propTypes2.default.string,
  /**
   * 弹层内容
   */
  children: _propTypes2.default.node,
  /**
   * 弹层当前是否显示
   */
  visible: _propTypes2.default.bool,
  /**
   * 弹层默认是否显示
   */
  defaultVisible: _propTypes2.default.bool,
  /**
   * 弹层显示或隐藏时触发的回调函数
   * @param {Boolean} visible 弹层是否显示
   * @param {String} type 触发弹层显示或隐藏的来源
   * @param {Object} e DOM事件
   */
  onVisibleChange: _propTypes2.default.func,
  /**
   * 触发弹层显示或者隐藏的元素
   */
  trigger: _propTypes2.default.node,
  /**
   * 触发弹层显示或隐藏的操作类型
   */
  triggerType: _propTypes2.default.oneOf(['hover', 'click', 'focus']),
  /**
   * 设置此属性，弹层无法显示或隐藏
   */
  disabled: _propTypes2.default.bool,
  /**
   * 弹层相对于触发元素的定位, 详见 Overlay 的定位部分
   */
  align: _propTypes2.default.string,
  /**
   * 弹层相对于触发元素定位的微调
   */
  offset: _propTypes2.default.array,
  /**
   * 弹层显示或隐藏的延时时间（以毫秒为单位），在 triggerType 被设置为 hover 时生效
   */
  delay: _propTypes2.default.number,
  /**
   * 弹层打开时是否让其中的元素自动获取焦点
   */
  autoFocus: _propTypes2.default.bool,
  /**
   * 是否显示遮罩
   */
  hasMask: _propTypes2.default.bool,
  /**
   * 隐藏时是否保留子节点
   */
  cache: _propTypes2.default.bool,
  /**
   * 配置动画的播放方式，支持 { in: 'enter-class', out: 'leave-class' } 的对象参数，如果设置为 false，则不播放动画
   * @default { in: 'expandInDown', out: 'expandOutUp' }
   */
  animation: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.bool])
}, _class.defaultProps = {
  prefix: 'next-',
  pure: false,
  defaultVisible: false,
  onVisibleChange: noop,
  triggerType: 'hover',
  disabled: false,
  align: 'tl bl',
  offset: [0, 0],
  delay: 200,
  autoFocus: true,
  hasMask: false,
  cache: false,
  onPosition: noop
}, _temp);
Dropdown.displayName = 'Dropdown';
exports.default = _configProvider2.default.config(Dropdown);
module.exports = exports['default'];

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _animate = __webpack_require__(74);

var _animate2 = _interopRequireDefault(_animate);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

var _item = __webpack_require__(14);

var _item2 = _interopRequireDefault(_item);

var _selectableItem = __webpack_require__(22);

var _selectableItem2 = _interopRequireDefault(_selectableItem);

var _popupItem = __webpack_require__(57);

var _popupItem2 = _interopRequireDefault(_popupItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var Expand = _animate2.default.Expand;
var bindCtx = _util.func.bindCtx;

/**
 * Menu.SubMenu
 * @order 1
 */

var SubMenu = (_temp = _class = function (_Component) {
    _inherits(SubMenu, _Component);

    function SubMenu(props) {
        _classCallCheck(this, SubMenu);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        bindCtx(_this, ['handleMouseEnter', 'handleMouseLeave', 'handleClick', 'handleOpen', 'afterLeave']);
        return _this;
    }

    SubMenu.prototype.componentDidMount = function componentDidMount() {
        this.itemNode = (0, _reactDom.findDOMNode)(this);
    };

    SubMenu.prototype.afterLeave = function afterLeave() {
        var _props = this.props,
            focused = _props.focused,
            root = _props.root;
        var focusable = root.props.focusable;

        if (focusable && focused) {
            this.itemNode.focus();
        }
    };

    SubMenu.prototype.getOpen = function getOpen() {
        var _props2 = this.props,
            _key = _props2._key,
            root = _props2.root;
        var openKeys = root.state.openKeys;


        return openKeys.indexOf(_key) > -1;
    };

    SubMenu.prototype.handleMouseEnter = function handleMouseEnter(e) {
        this.handleOpen(true);

        this.props.onMouseEnter && this.props.onMouseEnter(e);
    };

    SubMenu.prototype.handleMouseLeave = function handleMouseLeave(e) {
        this.handleOpen(false);

        this.props.onMouseLeave && this.props.onMouseLeave(e);
    };

    SubMenu.prototype.handleClick = function handleClick(e) {
        var _props3 = this.props,
            root = _props3.root,
            selectable = _props3.selectable;
        var selectMode = root.props.selectMode;

        if (selectMode && selectable) {
            e.stopPropagation();
        }

        var open = this.getOpen();
        this.handleOpen(!open);
    };

    SubMenu.prototype.handleOpen = function handleOpen(open, triggerType, e) {
        var _props4 = this.props,
            _key = _props4._key,
            root = _props4.root;

        root.handleOpen(_key, open, triggerType, e);
    };

    SubMenu.prototype.passParentToChildren = function passParentToChildren(children) {
        var _this2 = this;

        var _props5 = this.props,
            mode = _props5.mode,
            root = _props5.root;


        return _react.Children.map(children, function (child) {
            return (0, _react.cloneElement)(child, {
                parent: _this2,
                parentMode: mode || root.props.mode
            });
        });
    };

    SubMenu.prototype.renderInline = function renderInline() {
        var _cx, _cx2, _cx3;

        var _props6 = this.props,
            _key = _props6._key,
            level = _props6.level,
            root = _props6.root,
            className = _props6.className,
            selectableFromProps = _props6.selectable,
            label = _props6.label,
            children = _props6.children,
            subMenuContentClassName = _props6.subMenuContentClassName,
            propsTriggerType = _props6.triggerType,
            parentMode = _props6.parentMode;
        var _root$props = root.props,
            prefix = _root$props.prefix,
            selectMode = _root$props.selectMode,
            rootTriggerType = _root$props.triggerType,
            inlineArrowDirection = _root$props.inlineArrowDirection,
            expandAnimation = _root$props.expandAnimation,
            rtl = _root$props.rtl;

        var triggerType = propsTriggerType || rootTriggerType;
        var open = this.getOpen();
        var others = _util.obj.pickOthers(Object.keys(SubMenu.propTypes), this.props);

        var liProps = {
            className: (0, _classnames2.default)((_cx = {}, _cx[prefix + 'menu-sub-menu-wrapper'] = true, _cx[className] = !!className, _cx))
        };
        var itemProps = {
            'aria-expanded': open,
            _key: _key,
            level: level,
            root: root,
            type: 'submenu',
            component: 'div',
            parentMode: parentMode
        };
        var arrorProps = {
            type: inlineArrowDirection === 'right' ? 'arrow-right' : 'arrow-down',
            className: (0, _classnames2.default)((_cx2 = {}, _cx2[prefix + 'menu-icon-arrow'] = true, _cx2[prefix + 'menu-icon-arrow-down'] = inlineArrowDirection === 'down', _cx2[prefix + 'menu-icon-arrow-right'] = inlineArrowDirection === 'right', _cx2[prefix + 'open'] = open, _cx2))
        };

        var selectable = !!selectMode && selectableFromProps;
        var NewItem = selectable ? _selectableItem2.default : _item2.default;

        if (triggerType === 'hover') {
            liProps.onMouseEnter = this.handleMouseEnter;
            liProps.onMouseLeave = this.handleMouseLeave;
        } else if (selectable) {
            arrorProps.onClick = this.handleClick;
        } else {
            itemProps.onClick = this.handleClick;
        }
        if (open) {
            itemProps.className = prefix + 'opened';
        }

        var newSubMenuContentClassName = (0, _classnames2.default)((_cx3 = {}, _cx3[prefix + 'menu-sub-menu'] = true, _cx3[subMenuContentClassName] = !!subMenuContentClassName, _cx3));

        var subMenu = open ? _react2.default.createElement(
            'ul',
            { role: 'menu', dir: rtl ? 'rtl' : undefined, ref: 'subMenu', className: newSubMenuContentClassName },
            this.passParentToChildren(children)
        ) : null;

        return _react2.default.createElement(
            'li',
            _extends({}, others, liProps),
            _react2.default.createElement(
                NewItem,
                itemProps,
                _react2.default.createElement(
                    'span',
                    { className: prefix + 'menu-item-text' },
                    label
                ),
                _react2.default.createElement(_icon2.default, arrorProps)
            ),
            expandAnimation ? _react2.default.createElement(
                Expand,
                { animationAppear: false, afterLeave: this.afterLeave },
                subMenu
            ) : subMenu
        );
    };

    SubMenu.prototype.renderPopup = function renderPopup() {
        var _cx4;

        var _props7 = this.props,
            children = _props7.children,
            subMenuContentClassName = _props7.subMenuContentClassName,
            others = _objectWithoutProperties(_props7, ['children', 'subMenuContentClassName']);

        var root = this.props.root;
        var _root$props2 = root.props,
            prefix = _root$props2.prefix,
            popupClassName = _root$props2.popupClassName,
            popupStyle = _root$props2.popupStyle,
            rtl = _root$props2.rtl;


        var newClassName = (0, _classnames2.default)((_cx4 = {}, _cx4[prefix + 'menu'] = true, _cx4[prefix + 'ver'] = true, _cx4[popupClassName] = !!popupClassName, _cx4[subMenuContentClassName] = !!subMenuContentClassName, _cx4));

        others.rtl = rtl;

        return _react2.default.createElement(
            _popupItem2.default,
            _extends({}, others, { hasSubMenu: true }),
            _react2.default.createElement(
                'ul',
                { role: 'menu', dir: rtl ? 'rtl' : undefined, className: newClassName, style: popupStyle },
                this.passParentToChildren(children)
            )
        );
    };

    SubMenu.prototype.render = function render() {
        var _props8 = this.props,
            mode = _props8.mode,
            root = _props8.root;

        var newMode = mode || root.props.mode;

        return newMode === 'popup' ? this.renderPopup() : this.renderInline();
    };

    return SubMenu;
}(_react.Component), _class.menuChildType = 'submenu', _class.propTypes = {
    _key: _propTypes2.default.string,
    root: _propTypes2.default.object,
    level: _propTypes2.default.number,
    groupIndent: _propTypes2.default.number,
    /**
     * 标签内容
     */
    label: _propTypes2.default.node,
    /**
     * 是否可选，该属性仅在设置 Menu 组件 selectMode 属性后生效
     */
    selectable: _propTypes2.default.bool,
    /**
     * 子菜单打开方式，如果设置会覆盖 Menu 上的同名属性
     * @default Menu 的 mode 属性值
     */
    mode: _propTypes2.default.oneOf(['inline', 'popup']),
    /**
     * 菜单项或下一级子菜单
     */
    children: _propTypes2.default.node,
    onMouseEnter: _propTypes2.default.func,
    onMouseLeave: _propTypes2.default.func,
    subMenuContentClassName: _propTypes2.default.string,
    triggerType: _propTypes2.default.oneOf(['click', 'hover']),
    align: _propTypes2.default.oneOf(['outside', 'follow']),
    parentMode: _propTypes2.default.oneOf(['inline', 'popup'])
}, _class.defaultProps = {
    groupIndent: 0,
    selectable: false
}, _temp);
SubMenu.displayName = 'SubMenu';
exports.default = SubMenu;
module.exports = exports['default'];

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

exports.__esModule = true;
exports.default = void 0;

var PropTypes = _interopRequireWildcard(__webpack_require__(1));

var _addClass = _interopRequireDefault(__webpack_require__(103));

var _removeClass = _interopRequireDefault(__webpack_require__(106));

var _react = _interopRequireDefault(__webpack_require__(0));

var _Transition = _interopRequireDefault(__webpack_require__(53));

var _PropTypes = __webpack_require__(55);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }newObj.default = obj;return newObj;
  }
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;
  _defaults(subClass, superClass);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var addClass = function addClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return (0, _addClass.default)(node, c);
  });
};

var removeClass = function removeClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return (0, _removeClass.default)(node, c);
  });
};

var propTypes = process.env.NODE_ENV !== "production" ? _extends({}, _Transition.default.propTypes, {
  /**
   * The animation classNames applied to the component as it enters, exits or has finished the transition.
   * A single name can be provided and it will be suffixed for each stage: e.g.
   *
   * `classNames="fade"` applies `fade-enter`, `fade-enter-active`, `fade-enter-done`,
   * `fade-exit`, `fade-exit-active`, `fade-exit-done`, `fade-appear`, and `fade-appear-active`.
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply spread
   * them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */
  classNames: _PropTypes.classNamesShape,

  /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEnter: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntered: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * @type Function(node: HtmlElement)
   */
  onExit: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * @type Function(node: HtmlElement)
   */
  onExiting: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * @type Function(node: HtmlElement)
   */
  onExited: PropTypes.func
}) : {};;
/**
 * A `Transition` component using CSS transitions and animations.
 * It's inspired by the excellent [ng-animate](http://www.nganimate.org/) library.
 *
 * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
 * and `exit` stages of the transition. The first class is applied and then a
 * second "active" class in order to activate the css animation. After the animation,
 * matching `done` class names are applied to persist the animation state.
 *
 * When the `in` prop is toggled to `true` the Component will get
 * the `example-enter` CSS class and the `example-enter-active` CSS class
 * added in the next tick. This is a convention based on the `classNames` prop.
 */

var CSSTransition =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(CSSTransition, _React$Component);

  function CSSTransition() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

    _this.onEnter = function (node, appearing) {
      var _this$getClassNames = _this.getClassNames(appearing ? 'appear' : 'enter'),
          className = _this$getClassNames.className;

      _this.removeClasses(node, 'exit');

      addClass(node, className);

      if (_this.props.onEnter) {
        _this.props.onEnter(node, appearing);
      }
    };

    _this.onEntering = function (node, appearing) {
      var _this$getClassNames2 = _this.getClassNames(appearing ? 'appear' : 'enter'),
          activeClassName = _this$getClassNames2.activeClassName;

      _this.reflowAndAddClass(node, activeClassName);

      if (_this.props.onEntering) {
        _this.props.onEntering(node, appearing);
      }
    };

    _this.onEntered = function (node, appearing) {
      var _this$getClassNames3 = _this.getClassNames('enter'),
          doneClassName = _this$getClassNames3.doneClassName;

      _this.removeClasses(node, appearing ? 'appear' : 'enter');

      addClass(node, doneClassName);

      if (_this.props.onEntered) {
        _this.props.onEntered(node, appearing);
      }
    };

    _this.onExit = function (node) {
      var _this$getClassNames4 = _this.getClassNames('exit'),
          className = _this$getClassNames4.className;

      _this.removeClasses(node, 'appear');

      _this.removeClasses(node, 'enter');

      addClass(node, className);

      if (_this.props.onExit) {
        _this.props.onExit(node);
      }
    };

    _this.onExiting = function (node) {
      var _this$getClassNames5 = _this.getClassNames('exit'),
          activeClassName = _this$getClassNames5.activeClassName;

      _this.reflowAndAddClass(node, activeClassName);

      if (_this.props.onExiting) {
        _this.props.onExiting(node);
      }
    };

    _this.onExited = function (node) {
      var _this$getClassNames6 = _this.getClassNames('exit'),
          doneClassName = _this$getClassNames6.doneClassName;

      _this.removeClasses(node, 'exit');

      addClass(node, doneClassName);

      if (_this.props.onExited) {
        _this.props.onExited(node);
      }
    };

    _this.getClassNames = function (type) {
      var classNames = _this.props.classNames;
      var className = typeof classNames !== 'string' ? classNames[type] : classNames + '-' + type;
      var activeClassName = typeof classNames !== 'string' ? classNames[type + 'Active'] : className + '-active';
      var doneClassName = typeof classNames !== 'string' ? classNames[type + 'Done'] : className + '-done';
      return {
        className: className,
        activeClassName: activeClassName,
        doneClassName: doneClassName
      };
    };

    return _this;
  }

  var _proto = CSSTransition.prototype;

  _proto.removeClasses = function removeClasses(node, type) {
    var _this$getClassNames7 = this.getClassNames(type),
        className = _this$getClassNames7.className,
        activeClassName = _this$getClassNames7.activeClassName,
        doneClassName = _this$getClassNames7.doneClassName;

    className && removeClass(node, className);
    activeClassName && removeClass(node, activeClassName);
    doneClassName && removeClass(node, doneClassName);
  };

  _proto.reflowAndAddClass = function reflowAndAddClass(node, className) {
    // This is for to force a repaint,
    // which is necessary in order to transition styles when adding a class name.
    if (className) {
      /* eslint-disable no-unused-expressions */
      node && node.scrollTop;
      /* eslint-enable no-unused-expressions */

      addClass(node, className);
    }
  };

  _proto.render = function render() {
    var props = _extends({}, this.props);

    delete props.classNames;
    return _react.default.createElement(_Transition.default, _extends({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };

  return CSSTransition;
}(_react.default.Component);

CSSTransition.propTypes = process.env.NODE_ENV !== "production" ? propTypes : {};
var _default = CSSTransition;
exports.default = _default;
module.exports = exports["default"];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(104);

exports.__esModule = true;
exports.default = addClass;

var _hasClass = _interopRequireDefault(__webpack_require__(105));

function addClass(element, className) {
  if (element.classList) element.classList.add(className);else if (!(0, _hasClass.default)(element, className)) if (typeof element.className === 'string') element.className = element.className + ' ' + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + ' ' + className);
}

module.exports = exports["default"];

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = hasClass;

function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);else return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}

module.exports = exports["default"];

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp('(^|\\s)' + classToRemove + '(?:\\s|$)', 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
}

module.exports = function removeClass(element, className) {
  if (element.classList) element.classList.remove(className);else if (typeof element.className === 'string') element.className = replaceClassName(element.className, className);else element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

exports.__esModule = true;
exports.default = void 0;

var _propTypes = _interopRequireDefault(__webpack_require__(1));

var _react = _interopRequireDefault(__webpack_require__(0));

var _reactDom = __webpack_require__(4);

var _TransitionGroup = _interopRequireDefault(__webpack_require__(56));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];
  }return target;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;
  _defaults(subClass, superClass);
}

var propTypes = process.env.NODE_ENV !== "production" ? {
  in: _propTypes.default.bool.isRequired,
  children: function children(props, propName) {
    if (_react.default.Children.count(props[propName]) !== 2) return new Error("\"" + propName + "\" must be exactly two transition components.");
    return null;
  }
} : {};;
/**
 * The `<ReplaceTransition>` component is a specialized `Transition` component
 * that animates between two children.
 *
 * ```jsx
 * <ReplaceTransition in>
 *   <Fade><div>I appear first</div></Fade>
 *   <Fade><div>I replace the above</div></Fade>
 * </ReplaceTransition>
 * ```
 */

var ReplaceTransition =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(ReplaceTransition, _React$Component);

  function ReplaceTransition() {
    var _this;

    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;

    _this.handleEnter = function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return _this.handleLifecycle('onEnter', 0, args);
    };

    _this.handleEntering = function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return _this.handleLifecycle('onEntering', 0, args);
    };

    _this.handleEntered = function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return _this.handleLifecycle('onEntered', 0, args);
    };

    _this.handleExit = function () {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      return _this.handleLifecycle('onExit', 1, args);
    };

    _this.handleExiting = function () {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      return _this.handleLifecycle('onExiting', 1, args);
    };

    _this.handleExited = function () {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      return _this.handleLifecycle('onExited', 1, args);
    };

    return _this;
  }

  var _proto = ReplaceTransition.prototype;

  _proto.handleLifecycle = function handleLifecycle(handler, idx, originalArgs) {
    var _child$props;

    var children = this.props.children;

    var child = _react.default.Children.toArray(children)[idx];

    if (child.props[handler]) (_child$props = child.props)[handler].apply(_child$props, originalArgs);
    if (this.props[handler]) this.props[handler]((0, _reactDom.findDOMNode)(this));
  };

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        inProp = _this$props.in,
        props = _objectWithoutPropertiesLoose(_this$props, ["children", "in"]);

    var _React$Children$toArr = _react.default.Children.toArray(children),
        first = _React$Children$toArr[0],
        second = _React$Children$toArr[1];

    delete props.onEnter;
    delete props.onEntering;
    delete props.onEntered;
    delete props.onExit;
    delete props.onExiting;
    delete props.onExited;
    return _react.default.createElement(_TransitionGroup.default, props, inProp ? _react.default.cloneElement(first, {
      key: 'first',
      onEnter: this.handleEnter,
      onEntering: this.handleEntering,
      onEntered: this.handleEntered
    }) : _react.default.cloneElement(second, {
      key: 'second',
      onEnter: this.handleExit,
      onEntering: this.handleExiting,
      onEntered: this.handleExited
    }));
  };

  return ReplaceTransition;
}(_react.default.Component);

ReplaceTransition.propTypes = process.env.NODE_ENV !== "production" ? propTypes : {};
var _default = ReplaceTransition;
exports.default = _default;
module.exports = exports["default"];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getChildMapping = getChildMapping;
exports.mergeChildMappings = mergeChildMappings;
exports.getInitialChildMapping = getInitialChildMapping;
exports.getNextChildMapping = getNextChildMapping;

var _react = __webpack_require__(0);

/**
 * Given `this.props.children`, return an object mapping key to child.
 *
 * @param {*} children `this.props.children`
 * @return {object} Mapping of key to child
 */
function getChildMapping(children, mapFn) {
  var mapper = function mapper(child) {
    return mapFn && (0, _react.isValidElement)(child) ? mapFn(child) : child;
  };

  var result = Object.create(null);
  if (children) _react.Children.map(children, function (c) {
    return c;
  }).forEach(function (child) {
    // run the map function here instead so that the key is the computed one
    result[child.key] = mapper(child);
  });
  return result;
}
/**
 * When you're adding or removing children some may be added or removed in the
 * same render pass. We want to show *both* since we want to simultaneously
 * animate elements in and out. This function takes a previous set of keys
 * and a new set of keys and merges them with its best guess of the correct
 * ordering. In the future we may expose some of the utilities in
 * ReactMultiChild to make this easy, but for now React itself does not
 * directly have this concept of the union of prevChildren and nextChildren
 * so we implement it here.
 *
 * @param {object} prev prev children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @param {object} next next children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @return {object} a key set that contains all keys in `prev` and all keys
 * in `next` in a reasonable order.
 */

function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};

  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  } // For each key of `next`, the list of keys to insert before that key in
  // the combined list


  var nextKeysPending = Object.create(null);
  var pendingKeys = [];

  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }

  var i;
  var childMapping = {};

  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }

    childMapping[nextKey] = getValueForKey(nextKey);
  } // Finally, add the keys which didn't appear before any key in `next`


  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }

  return childMapping;
}

function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}

function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function (child) {
    return (0, _react.cloneElement)(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, 'appear', props),
      enter: getProp(child, 'enter', props),
      exit: getProp(child, 'exit', props)
    });
  });
}

function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function (key) {
    var child = children[key];
    if (!(0, _react.isValidElement)(child)) return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = (0, _react.isValidElement)(prevChild) && !prevChild.props.in; // item is new (entering)

    if (hasNext && (!hasPrev || isLeaving)) {
      // console.log('entering', key)
      children[key] = (0, _react.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      // item is old (exiting)
      // console.log('leaving', key)
      children[key] = (0, _react.cloneElement)(child, {
        in: false
      });
    } else if (hasNext && hasPrev && (0, _react.isValidElement)(prevChild)) {
      // item hasn't changed transition states
      // copy over the last transition props;
      // console.log('unchanged', key)
      children[key] = (0, _react.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    }
  });
  return children;
}

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactTransitionGroup = __webpack_require__(52);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};
var on = _util.events.on,
    off = _util.events.off;
var addClass = _util.dom.addClass,
    removeClass = _util.dom.removeClass;

var prefixes = ['-webkit-', '-moz-', '-o-', 'ms-', ''];

function getStyleProperty(node, name) {
    var style = window.getComputedStyle(node);
    var ret = '';
    for (var i = 0; i < prefixes.length; i++) {
        ret = style.getPropertyValue(prefixes[i] + name);
        if (ret) {
            break;
        }
    }
    return ret;
}

var AnimateChild = (_temp = _class = function (_Component) {
    _inherits(AnimateChild, _Component);

    function AnimateChild(props) {
        _classCallCheck(this, AnimateChild);

        var _this2 = _possibleConstructorReturn(this, _Component.call(this, props));

        _util.func.bindCtx(_this2, ['handleEnter', 'handleEntering', 'handleEntered', 'handleExit', 'handleExiting', 'handleExited', 'addEndListener']);
        _this2.endListeners = {
            transitionend: [],
            animationend: []
        };
        _this2.timeoutMap = {};
        return _this2;
    }

    AnimateChild.prototype.componentWillUnmount = function componentWillUnmount() {
        var _this3 = this;

        Object.keys(this.endListeners).forEach(function (eventName) {
            _this3.endListeners[eventName].forEach(function (listener) {
                off(_this3.node, eventName, listener);
            });
        });
        this.endListeners = {
            transitionend: [],
            animationend: []
        };
    };

    AnimateChild.prototype.generateEndListener = function generateEndListener(node, done, eventName, id) {
        var _this = this;
        return function endListener(e) {

            if (e && e.target === node) {
                if (_this.timeoutMap[id]) {
                    clearTimeout(_this.timeoutMap[id]);
                    delete _this.timeoutMap[id];
                }

                done();
                off(node, eventName, endListener);
                var listeners = _this.endListeners[eventName];
                var index = listeners.indexOf(endListener);
                index > -1 && listeners.splice(index, 1);
            }
        };
    };

    AnimateChild.prototype.addEndListener = function addEndListener(node, done) {
        var _this4 = this;

        if (_util.support.transition || _util.support.animation) {
            var id = (0, _util.guid)();

            this.node = node;
            if (_util.support.transition) {
                var transitionEndListener = this.generateEndListener(node, done, 'transitionend', id);
                on(node, 'transitionend', transitionEndListener);
                this.endListeners.transitionend.push(transitionEndListener);
            }
            if (_util.support.animation) {
                var animationEndListener = this.generateEndListener(node, done, 'animationend', id);
                on(node, 'animationend', animationEndListener);
                this.endListeners.animationend.push(animationEndListener);
            }

            setTimeout(function () {
                var transitionDelay = parseFloat(getStyleProperty(node, 'transition-delay')) || 0;
                var transitionDuration = parseFloat(getStyleProperty(node, 'transition-duration')) || 0;
                var animationDelay = parseFloat(getStyleProperty(node, 'animation-delay')) || 0;
                var animationDuration = parseFloat(getStyleProperty(node, 'animation-duration')) || 0;
                var time = Math.max(transitionDuration + transitionDelay, animationDuration + animationDelay);
                if (time) {
                    _this4.timeoutMap[id] = setTimeout(function () {
                        done();
                    }, time * 1000 + 200);
                }
            }, 15);
        } else {
            done();
        }
    };

    AnimateChild.prototype.removeEndtListener = function removeEndtListener() {
        this.transitionOff && this.transitionOff();
        this.animationOff && this.animationOff();
    };

    AnimateChild.prototype.removeClassNames = function removeClassNames(node, names) {
        Object.keys(names).forEach(function (key) {
            removeClass(node, names[key]);
        });
    };

    AnimateChild.prototype.handleEnter = function handleEnter(node, isAppearing) {
        var names = this.props.names;

        if (names) {
            this.removeClassNames(node, names);
            var className = isAppearing ? 'appear' : 'enter';
            addClass(node, names[className]);
        }

        var hook = isAppearing ? this.props.onAppear : this.props.onEnter;
        hook(node);
    };

    AnimateChild.prototype.handleEntering = function handleEntering(node, isAppearing) {
        var _this5 = this;

        setTimeout(function () {
            var names = _this5.props.names;

            if (names) {
                var className = isAppearing ? 'appearActive' : 'enterActive';
                addClass(node, names[className]);
            }

            var hook = isAppearing ? _this5.props.onAppearing : _this5.props.onEntering;
            hook(node);
        }, 10);
    };

    AnimateChild.prototype.handleEntered = function handleEntered(node, isAppearing) {
        var names = this.props.names;

        if (names) {
            var classNames = isAppearing ? [names.appear, names.appearActive] : [names.enter, names.enterActive];
            classNames.forEach(function (className) {
                removeClass(node, className);
            });
        }

        var hook = isAppearing ? this.props.onAppeared : this.props.onEntered;
        hook(node);
    };

    AnimateChild.prototype.handleExit = function handleExit(node) {
        var names = this.props.names;

        if (names) {
            this.removeClassNames(node, names);
            addClass(node, names.leave);
        }

        this.props.onExit(node);
    };

    AnimateChild.prototype.handleExiting = function handleExiting(node) {
        var _this6 = this;

        setTimeout(function () {
            var names = _this6.props.names;

            if (names) {
                addClass(node, names.leaveActive);
            }
            _this6.props.onExiting(node);
        }, 10);
    };

    AnimateChild.prototype.handleExited = function handleExited(node) {
        var names = this.props.names;

        if (names) {
            [names.leave, names.leaveActive].forEach(function (className) {
                removeClass(node, className);
            });
        }

        this.props.onExited(node);
    };

    AnimateChild.prototype.render = function render() {
        /* eslint-disable no-unused-vars */
        var _props = this.props,
            names = _props.names,
            onAppear = _props.onAppear,
            onAppeared = _props.onAppeared,
            onAppearing = _props.onAppearing,
            onEnter = _props.onEnter,
            onEntering = _props.onEntering,
            onEntered = _props.onEntered,
            onExit = _props.onExit,
            onExiting = _props.onExiting,
            onExited = _props.onExited,
            others = _objectWithoutProperties(_props, ['names', 'onAppear', 'onAppeared', 'onAppearing', 'onEnter', 'onEntering', 'onEntered', 'onExit', 'onExiting', 'onExited']);
        /* eslint-enable no-unused-vars */

        return _react2.default.createElement(_reactTransitionGroup.Transition, _extends({}, others, {
            onEnter: this.handleEnter,
            onEntering: this.handleEntering,
            onEntered: this.handleEntered,
            onExit: this.handleExit,
            onExiting: this.handleExiting,
            onExited: this.handleExited,
            addEndListener: this.addEndListener }));
    };

    return AnimateChild;
}(_react.Component), _class.propTypes = {
    names: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),
    onAppear: _propTypes2.default.func,
    onAppearing: _propTypes2.default.func,
    onAppeared: _propTypes2.default.func,
    onEnter: _propTypes2.default.func,
    onEntering: _propTypes2.default.func,
    onEntered: _propTypes2.default.func,
    onExit: _propTypes2.default.func,
    onExiting: _propTypes2.default.func,
    onExited: _propTypes2.default.func
}, _class.defaultProps = {
    onAppear: noop,
    onAppearing: noop,
    onAppeared: noop,
    onEnter: noop,
    onEntering: noop,
    onEntered: noop,
    onExit: noop,
    onExiting: noop,
    onExited: noop
}, _temp);
AnimateChild.displayName = 'AnimateChild';
exports.default = AnimateChild;
module.exports = exports['default'];

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

var _animate = __webpack_require__(51);

var _animate2 = _interopRequireDefault(_animate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};
var getStyle = _util.dom.getStyle;
var Expand = (_temp = _class = function (_Component) {
    _inherits(Expand, _Component);

    function Expand(props) {
        _classCallCheck(this, Expand);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        _util.func.bindCtx(_this, ['beforeEnter', 'onEnter', 'afterEnter', 'beforeLeave', 'onLeave', 'afterLeave']);
        return _this;
    }

    Expand.prototype.beforeEnter = function beforeEnter(node) {
        if (this.leaving) {
            this.afterLeave(node);
        }

        this.cacheCurrentStyle(node);
        this.cacheComputedStyle(node);
        this.setCurrentStyleToZero(node);

        this.props.beforeEnter(node);
    };

    Expand.prototype.onEnter = function onEnter(node) {
        this.setCurrentStyleToComputedStyle(node);

        this.props.onEnter(node);
    };

    Expand.prototype.afterEnter = function afterEnter(node) {
        this.restoreCurrentStyle(node);

        this.props.afterEnter(node);
    };

    Expand.prototype.beforeLeave = function beforeLeave(node) {
        this.leaving = true;

        this.cacheCurrentStyle(node);
        this.cacheComputedStyle(node);
        this.setCurrentStyleToComputedStyle(node);

        this.props.beforeLeave(node);
    };

    Expand.prototype.onLeave = function onLeave(node) {
        this.setCurrentStyleToZero(node);

        this.props.onLeave(node);
    };

    Expand.prototype.afterLeave = function afterLeave(node) {
        this.leaving = false;

        this.restoreCurrentStyle(node);

        this.props.afterLeave(node);
    };

    Expand.prototype.cacheCurrentStyle = function cacheCurrentStyle(node) {
        this.styleBorderTopWidth = node.style.borderTopWidth;
        this.stylePaddingTop = node.style.paddingTop;
        this.styleHeight = node.style.height;
        this.stylePaddingBottom = node.style.paddingBottom;
        this.styleBorderBottomWidth = node.style.borderBottomWidth;
    };

    Expand.prototype.cacheComputedStyle = function cacheComputedStyle(node) {
        this.borderTopWidth = getStyle(node, 'borderTopWidth');
        this.paddingTop = getStyle(node, 'paddingTop');
        this.height = node.offsetHeight;
        this.paddingBottom = getStyle(node, 'paddingBottom');
        this.borderBottomWidth = getStyle(node, 'borderBottomWidth');
    };

    Expand.prototype.setCurrentStyleToZero = function setCurrentStyleToZero(node) {
        node.style.borderTopWidth = '0px';
        node.style.paddingTop = '0px';
        node.style.height = '0px';
        node.style.paddingBottom = '0px';
        node.style.borderBottomWidth = '0px';
    };

    Expand.prototype.setCurrentStyleToComputedStyle = function setCurrentStyleToComputedStyle(node) {
        node.style.borderTopWidth = this.borderTopWidth + 'px';
        node.style.paddingTop = this.paddingTop + 'px';
        node.style.height = this.height + 'px';
        node.style.paddingBottom = this.paddingBottom + 'px';
        node.style.borderBottomWidth = this.borderBottomWidth + 'px';
    };

    Expand.prototype.restoreCurrentStyle = function restoreCurrentStyle(node) {
        node.style.borderTopWidth = this.styleBorderTopWidth;
        node.style.paddingTop = this.stylePaddingTop;
        node.style.height = this.styleHeight;
        node.style.paddingBottom = this.stylePaddingBottom;
        node.style.borderBottomWidth = this.styleBorderBottomWidth;
    };

    Expand.prototype.render = function render() {
        var _props = this.props,
            animation = _props.animation,
            others = _objectWithoutProperties(_props, ['animation']);

        var newAnimation = animation || 'expand';

        return _react2.default.createElement(_animate2.default, _extends({}, others, {
            animation: newAnimation,
            beforeEnter: this.beforeEnter,
            onEnter: this.onEnter,
            afterEnter: this.afterEnter,
            beforeLeave: this.beforeLeave,
            onLeave: this.onLeave,
            afterLeave: this.afterLeave }));
    };

    return Expand;
}(_react.Component), _class.propTypes = {
    animation: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),
    beforeEnter: _propTypes2.default.func,
    onEnter: _propTypes2.default.func,
    afterEnter: _propTypes2.default.func,
    beforeLeave: _propTypes2.default.func,
    onLeave: _propTypes2.default.func,
    afterLeave: _propTypes2.default.func
}, _class.defaultProps = {
    beforeEnter: noop,
    onEnter: noop,
    afterEnter: noop,
    beforeLeave: noop,
    onLeave: noop,
    afterLeave: noop
}, _temp);
Expand.displayName = 'Expand';
exports.default = Expand;
module.exports = exports['default'];

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _checkableItem = __webpack_require__(58);

var _checkableItem2 = _interopRequireDefault(_checkableItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Menu.CheckboxItem
 * @order 3
 * @description 该子组件选中情况不受 defaultSelectedKeys/selectedKeys 控制，请自行控制选中逻辑
 */
var CheckboxItem = (_temp = _class = function (_Component) {
  _inherits(CheckboxItem, _Component);

  function CheckboxItem() {
    _classCallCheck(this, CheckboxItem);

    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  CheckboxItem.prototype.render = function render() {
    var _props = this.props,
        checkboxDisabled = _props.checkboxDisabled,
        others = _objectWithoutProperties(_props, ['checkboxDisabled']);

    return _react2.default.createElement(_checkableItem2.default, _extends({ role: 'menuitemcheckbox', checkType: 'checkbox', checkDisabled: checkboxDisabled }, others));
  };

  return CheckboxItem;
}(_react.Component), _class.menuChildType = 'item', _class.propTypes = {
  /**
   * 是否选中
   */
  checked: _propTypes2.default.bool,
  /**
   * 是否半选中
   */
  indeterminate: _propTypes2.default.bool,
  /**
   * 是否禁用
   */
  disabled: _propTypes2.default.bool,
  /**
   * 选中或取消选中触发的回调函数
   * @param {Boolean} checked 是否选中
   * @param {Object} event 选中事件对象
   */
  onChange: _propTypes2.default.func,
  /**
   * 帮助文本
   */
  helper: _propTypes2.default.node,
  /**
   * 标签内容
   */
  children: _propTypes2.default.node,
  checkboxDisabled: _propTypes2.default.bool
}, _class.defaultProps = {
  checked: false,
  indeterminate: false,
  disabled: false,
  onChange: function onChange() {},
  checkboxDisabled: false
}, _temp);
CheckboxItem.displayName = 'CheckboxItem';
exports.default = CheckboxItem;
module.exports = exports['default'];

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _util = __webpack_require__(2);

var _checkbox = __webpack_require__(59);

var _checkbox2 = _interopRequireDefault(_checkbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var pickOthers = _util.obj.pickOthers;

/** Checkbox.Group */

var CheckboxGroup = (_temp = _class = function (_Component) {
    _inherits(CheckboxGroup, _Component);

    function CheckboxGroup(props) {
        _classCallCheck(this, CheckboxGroup);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        var value = [];
        if ('value' in props) {
            value = props.value;
        } else if ('defaultValue' in props) {
            value = props.defaultValue;
        }
        if (!Array.isArray(value)) {
            if (value === null || value === undefined) {
                value = [];
            } else {
                value = [value];
            }
        }
        _this.state = {
            value: [].concat(value)
        };

        _this.onChange = _this.onChange.bind(_this);
        return _this;
    }

    CheckboxGroup.prototype.getChildContext = function getChildContext() {
        return {
            __group__: true,
            onChange: this.onChange,
            selectedValue: this.state.value,
            disabled: this.props.disabled
        };
    };

    CheckboxGroup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if ('value' in nextProps) {
            var value = nextProps.value;

            if (!Array.isArray(value)) {
                if (value === null || value === undefined) {
                    value = [];
                } else {
                    value = [value];
                }
            }
            this.setState({
                value: value
            });
        }
    };

    CheckboxGroup.prototype.onChange = function onChange(currentValue, e) {
        var value = this.state.value;

        var index = value.indexOf(currentValue);
        var valTemp = [].concat(value);

        if (index === -1) {
            valTemp.push(currentValue);
        } else {
            valTemp.splice(index, 1);
        }

        if (!('value' in this.props)) {
            this.setState({ value: valTemp });
        }
        this.props.onChange(valTemp, e);
    };

    CheckboxGroup.prototype.render = function render() {
        var _this2 = this,
            _classnames;

        var _props = this.props,
            className = _props.className,
            style = _props.style,
            prefix = _props.prefix,
            disabled = _props.disabled,
            itemDirection = _props.itemDirection;

        var others = pickOthers(CheckboxGroup.propTypes, this.props);

        // 如果内嵌标签跟dataSource同时存在，以内嵌标签为主
        var children = void 0;
        if (this.props.children) {
            children = this.props.children;
        } else {
            children = this.props.dataSource.map(function (item, index) {
                var option = item;
                if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) !== 'object') {
                    option = {
                        label: item,
                        value: item,
                        disabled: disabled
                    };
                }
                var checked = _this2.state.value && _this2.state.value.indexOf(option.value) > -1;

                return _react2.default.createElement(_checkbox2.default, { key: index,
                    value: option.value,
                    checked: checked,
                    disabled: disabled || option.disabled,
                    label: option.label
                });
            });
        }

        var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'checkbox-group'] = true, _classnames[prefix + 'checkbox-group-' + itemDirection] = true, _classnames[className] = !!className, _classnames.disabled = disabled, _classnames));

        return _react2.default.createElement(
            'span',
            _extends({}, others, { className: cls, style: style }),
            children
        );
    };

    return CheckboxGroup;
}(_react.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    rtl: _propTypes2.default.bool,
    /**
     * 自定义类名
     */
    className: _propTypes2.default.string,
    /**
     * 自定义内敛样式
     */
    style: _propTypes2.default.object,
    /**
     * 整体禁用
     */
    disabled: _propTypes2.default.bool,
    /**
     * 可选项列表, 数据项可为 String 或者 Object, 如 `['apple', 'pear', 'orange']` 或者 `[{value: 'apple', label: '苹果',}, {value: 'pear', label: '梨'}, {value: 'orange', label: '橙子'}]`
     */
    dataSource: _propTypes2.default.arrayOf(_propTypes2.default.any),
    /**
     * 被选中的值列表
     */
    value: _propTypes2.default.oneOfType([_propTypes2.default.array, _propTypes2.default.string, _propTypes2.default.number]),
    /**
     * 默认被选中的值列表
     */
    defaultValue: _propTypes2.default.oneOfType([_propTypes2.default.array, _propTypes2.default.string, _propTypes2.default.number]),
    /**
     * 通过子元素方式设置内部 checkbox
     */
    children: _propTypes2.default.arrayOf(_propTypes2.default.element),
    /**
     * 选中值改变时的事件
     * @param {Array} value 选中项列表
     * @param {Event} e Dom 事件对象
     */
    onChange: _propTypes2.default.func,

    /**
     * 子项目的排列方式
     * - hoz: 水平排列 (default)
     * - ver: 垂直排列
     */
    itemDirection: _propTypes2.default.oneOf(['hoz', 'ver'])
}, _class.defaultProps = {
    dataSource: [],
    onChange: function onChange() {},
    prefix: 'next-',
    itemDirection: 'hoz'
}, _class.childContextTypes = {
    onChange: _propTypes2.default.func,
    __group__: _propTypes2.default.bool,
    selectedValue: _propTypes2.default.array,
    disabled: _propTypes2.default.bool
}, _temp);
CheckboxGroup.displayName = 'CheckboxGroup';
exports.default = _configProvider2.default.config(CheckboxGroup);
module.exports = exports['default'];

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _util = __webpack_require__(2);

var _radio = __webpack_require__(62);

var _radio2 = _interopRequireDefault(_radio);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var pickOthers = _util.obj.pickOthers;

/**
 * Radio.Group
 * @order 2
 */

var RadioGroup = (_temp = _class = function (_Component) {
    _inherits(RadioGroup, _Component);

    function RadioGroup(props) {
        _classCallCheck(this, RadioGroup);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        var value = '';
        if ('value' in props) {
            value = props.value;
        } else if ('defaultValue' in props) {
            value = props.defaultValue;
        }
        _this.state = { value: value };
        _this.onChange = _this.onChange.bind(_this);
        return _this;
    }

    RadioGroup.prototype.getChildContext = function getChildContext() {
        return {
            __group__: true,
            isButton: this.props.shape === 'button',
            onChange: this.onChange,
            selectedValue: this.state.value,
            disabled: this.props.disabled
        };
    };

    RadioGroup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var value = nextProps.value;

        if ('value' in nextProps) {
            if (value === undefined) {
                value = '';
            }
            this.setState({
                value: value
            });
        }
    };

    RadioGroup.prototype.onChange = function onChange(currentValue, e) {
        if (!('value' in this.props)) {
            this.setState({ value: currentValue });
        }
        if (currentValue !== this.state.value) {
            this.props.onChange(currentValue, e);
        }
    };

    RadioGroup.prototype.render = function render() {
        var _this2 = this,
            _classnames;

        var _props = this.props,
            rtl = _props.rtl,
            className = _props.className,
            shape = _props.shape,
            size = _props.size,
            style = _props.style,
            prefix = _props.prefix,
            itemDirection = _props.itemDirection;

        var others = pickOthers(Object.keys(RadioGroup.propTypes), this.props);
        var disabled = this.props.disabled;

        if (rtl) {
            others.dir = 'rtl';
        }

        var children = void 0;
        if (this.props.children) {
            children = this.props.children;
        } else {
            children = this.props.dataSource.map(function (item, index) {
                var option = item;
                if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) !== 'object') {
                    option = {
                        label: item,
                        value: item,
                        disabled: disabled
                    };
                }
                var checked = _this2.state.value === option.value;
                return _react2.default.createElement(_radio2.default, {
                    key: index,
                    tabIndex: index === 0 && !_this2.state.value || checked ? 0 : -1,
                    value: option.value,
                    checked: checked,
                    label: option.label,
                    disabled: disabled || option.disabled
                });
            });
        }

        var isButtonShape = shape === 'button';

        var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'radio-group'] = true, _classnames[prefix + 'radio-group-' + itemDirection] = !isButtonShape, _classnames[prefix + 'radio-button'] = isButtonShape, _classnames[prefix + 'radio-button-' + size] = isButtonShape, _classnames[className] = !!className, _classnames.disabled = disabled, _classnames));

        return _react2.default.createElement(
            'div',
            _extends({}, others, { 'aria-disabled': disabled, role: 'radiogroup', className: cls, style: style }),
            children
        );
    };

    return RadioGroup;
}(_react.Component), _class.propTypes = {
    /**
     * 样式类名的品牌前缀
     */
    prefix: _propTypes2.default.string,
    rtl: _propTypes2.default.bool,
    /**
     * 自定义类名
     */
    className: _propTypes2.default.string,
    /**
     * 自定义内敛样式
     */
    style: _propTypes2.default.object,
    /**
     * name
     */
    name: _propTypes2.default.string,
    /**
     * radio group的选中项的值
     */
    value: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number, _propTypes2.default.bool]),
    /**
     * radio group的默认值
     */
    defaultValue: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number, _propTypes2.default.bool]),
    /**
     * 选中值改变时的事件
     * @param {String/Number} value 选中项的值
     * @param {Event} e Dom 事件对象
     */
    onChange: _propTypes2.default.func,
    /**
     * 表示radio被禁用
     */
    disabled: _propTypes2.default.bool,
    /**
     * 可以设置成 button 展示形状
     * @enumdesc 按钮状
     */
    shape: _propTypes2.default.oneOf(['button']),
    /**
     * 与 `shape` 属性配套使用，shape设为button时有效
     * @enumdesc 大, 中, 小
     */
    size: _propTypes2.default.oneOf(['large', 'medium', 'small']),
    /**
     * 可选项列表, 数据项可为 String 或者 Object, 如 `['apple', 'pear', 'orange']`
     */
    dataSource: _propTypes2.default.arrayOf(_propTypes2.default.any),
    /**
     * 通过子元素方式设置内部radio
     */
    children: _propTypes2.default.oneOfType([_propTypes2.default.arrayOf(_propTypes2.default.element), _propTypes2.default.element]),

    /**
     * 子项目的排列方式
     * - hoz: 水平排列 (default)
     * - ver: 垂直排列
     */
    itemDirection: _propTypes2.default.oneOf(['hoz', 'ver'])
}, _class.defaultProps = {
    dataSource: [],
    size: 'medium',
    onChange: function onChange() {},
    prefix: 'next-',
    itemDirection: 'hoz'
}, _class.childContextTypes = {
    onChange: _propTypes2.default.func,
    __group__: _propTypes2.default.bool,
    isButton: _propTypes2.default.bool,
    selectedValue: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number, _propTypes2.default.bool]),
    disabled: _propTypes2.default.bool
}, _temp);
RadioGroup.displayName = 'RadioGroup';
exports.default = _configProvider2.default.config(RadioGroup);
module.exports = exports['default'];

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _checkableItem = __webpack_require__(58);

var _checkableItem2 = _interopRequireDefault(_checkableItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Menu.RadioItem
 * @order 4
 * @description 该子组件选中情况不受 defaultSelectedKeys/selectedKeys 控制，请自行控制选中逻辑
 */
var RadioItem = (_temp = _class = function (_Component) {
  _inherits(RadioItem, _Component);

  function RadioItem() {
    _classCallCheck(this, RadioItem);

    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  RadioItem.prototype.render = function render() {
    return _react2.default.createElement(_checkableItem2.default, _extends({ role: 'menuitemradio', checkType: 'radio' }, this.props));
  };

  return RadioItem;
}(_react.Component), _class.menuChildType = 'item', _class.propTypes = {
  /**
   * 是否选中
   */
  checked: _propTypes2.default.bool,
  /**
   * 是否禁用
   */
  disabled: _propTypes2.default.bool,
  /**
   * 选中或取消选中触发的回调函数
   * @param {Boolean} checked 是否选中
   * @param {Object} event 选中事件对象
   */
  onChange: _propTypes2.default.func,
  /**
   * 帮助文本
   */
  helper: _propTypes2.default.node,
  /**
   * 标签内容
   */
  children: _propTypes2.default.node
}, _class.defaultProps = {
  checked: false,
  disabled: false,
  onChange: function onChange() {}
}, _temp);
RadioItem.displayName = 'RadioItem';
exports.default = RadioItem;
module.exports = exports['default'];

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _item = __webpack_require__(14);

var _item2 = _interopRequireDefault(_item);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Menu.Group
 * @order 5
 */
var Group = (_temp = _class = function (_Component) {
    _inherits(Group, _Component);

    function Group() {
        _classCallCheck(this, Group);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    Group.prototype.render = function render() {
        var _cx;

        var _props = this.props,
            root = _props.root,
            className = _props.className,
            label = _props.label,
            children = _props.children,
            parentMode = _props.parentMode,
            others = _objectWithoutProperties(_props, ['root', 'className', 'label', 'children', 'parentMode']);

        var prefix = root.props.prefix;


        var newClassName = (0, _classnames2.default)((_cx = {}, _cx[prefix + 'menu-group-label'] = true, _cx[className] = !!className, _cx));

        var newChildren = children.map(function (child) {
            var _cx2;

            var className = child.props.className;

            var newChildClassName = (0, _classnames2.default)((_cx2 = {}, _cx2[prefix + 'menu-group-item'] = true, _cx2[className] = !!className, _cx2));

            return (0, _react.cloneElement)(child, {
                parentMode: parentMode,
                className: newChildClassName
            });
        });

        return [_react2.default.createElement(
            _item2.default,
            _extends({
                key: 'menu-group-label',
                className: newClassName,
                replaceClassName: true,
                root: root,
                parentMode: parentMode
            }, others),
            label
        )].concat(newChildren);
    };

    return Group;
}(_react.Component), _class.menuChildType = 'group', _class.propTypes = {
    root: _propTypes2.default.object,
    className: _propTypes2.default.string,
    /**
     * 标签内容
     */
    label: _propTypes2.default.node,
    /**
     * 菜单项
     */
    children: _propTypes2.default.node,
    parentMode: _propTypes2.default.oneOf(['inline', 'popup'])
}, _temp);
Group.displayName = 'Group';
exports.default = Group;
module.exports = exports['default'];

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Menu.Divider
 * @order 6
 */
var Divider = (_temp = _class = function (_Component) {
    _inherits(Divider, _Component);

    function Divider() {
        _classCallCheck(this, Divider);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    Divider.prototype.render = function render() {
        var _cx;

        var _props = this.props,
            root = _props.root,
            className = _props.className,
            others = _objectWithoutProperties(_props, ['root', 'className']);

        var prefix = root.props.prefix;


        var newClassName = (0, _classnames2.default)((_cx = {}, _cx[prefix + 'menu-divider'] = true, _cx[className] = !!className, _cx));

        return _react2.default.createElement('li', _extends({ role: 'separator', className: newClassName }, others));
    };

    return Divider;
}(_react.Component), _class.menuChildType = 'divider', _class.propTypes = {
    root: _propTypes2.default.object,
    className: _propTypes2.default.string
}, _temp);
Divider.displayName = 'Divider';
exports.default = Divider;
module.exports = exports['default'];

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

exports.default = create;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _overlay = __webpack_require__(15);

var _overlay2 = _interopRequireDefault(_overlay);

var _util = __webpack_require__(2);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _menu = __webpack_require__(50);

var _menu2 = _interopRequireDefault(_menu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var bindCtx = _util.func.bindCtx;
var getContextProps = _configProvider2.default.getContextProps;

var Menu = _configProvider2.default.config(_menu2.default);

var menuInstance = void 0;

var ContextMenu = (_temp = _class = function (_Component) {
    _inherits(ContextMenu, _Component);

    function ContextMenu(props) {
        _classCallCheck(this, ContextMenu);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        _this.state = {
            visible: true
        };

        bindCtx(_this, ['handleOverlayClose', 'handleOverlayOpen', 'handleItemClick', 'getOverlay']);
        return _this;
    }

    ContextMenu.prototype.getOverlay = function getOverlay(ref) {
        this.overlay = ref;
    };

    ContextMenu.prototype.close = function close() {
        this.setState({
            visible: false
        });
        menuInstance = null;
    };

    ContextMenu.prototype.handleOverlayClose = function handleOverlayClose(triggerType, e) {
        var clickedPopupMenu = triggerType === 'docClick' && this.popupNodes.some(function (node) {
            return node.contains(e.target);
        });
        if (!clickedPopupMenu) {
            this.close();
            var overlayProps = this.props.overlayProps;

            if (overlayProps && overlayProps.onRequestClose) {
                for (var _len = arguments.length, others = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                    others[_key - 2] = arguments[_key];
                }

                overlayProps.onRequestClose.apply(overlayProps, [triggerType, e].concat(others));
            }
        }
    };

    ContextMenu.prototype.handleOverlayOpen = function handleOverlayOpen() {
        this.popupNodes = this.overlay.getInstance().getContent().getInstance().popupNodes;
        var overlayProps = this.props.overlayProps;

        if (overlayProps && overlayProps.onOpen) {
            overlayProps.onOpen();
        }
    };

    ContextMenu.prototype.handleItemClick = function handleItemClick() {
        var _props;

        this.close();

        this.props.onItemClick && (_props = this.props).onItemClick.apply(_props, arguments);
    };

    ContextMenu.prototype.render = function render() {
        var _cx, _cx2;

        var _props2 = this.props,
            className = _props2.className,
            popupClassName = _props2.popupClassName,
            target = _props2.target,
            align = _props2.align,
            offset = _props2.offset,
            afterClose = _props2.afterClose,
            _props2$overlayProps = _props2.overlayProps,
            overlayProps = _props2$overlayProps === undefined ? {} : _props2$overlayProps,
            others = _objectWithoutProperties(_props2, ['className', 'popupClassName', 'target', 'align', 'offset', 'afterClose', 'overlayProps']);

        var contextProps = getContextProps(this.props);
        var prefix = contextProps.prefix;
        var visible = this.state.visible;


        var newOverlayProps = _extends({}, contextProps, overlayProps, {
            target: target, align: align, offset: offset, afterClose: afterClose, visible: visible,
            onRequestClose: this.handleOverlayClose,
            onOpen: this.handleOverlayOpen,
            ref: this.getOverlay
        });
        var menuProps = _extends({}, contextProps, {
            triggerType: 'hover'
        }, others, {
            className: (0, _classnames2.default)((_cx = {}, _cx[prefix + 'context'] = true, _cx[className] = !!className, _cx)),
            popupClassName: (0, _classnames2.default)((_cx2 = {}, _cx2[prefix + 'context'] = true, _cx2[popupClassName] = !!popupClassName, _cx2)),
            onItemClick: this.handleItemClick
        });

        newOverlayProps.rtl = false;

        return _react2.default.createElement(
            _overlay2.default,
            newOverlayProps,
            _react2.default.createElement(Menu, menuProps)
        );
    };

    return ContextMenu;
}(_react.Component), _class.propTypes = {
    className: _propTypes2.default.string,
    popupClassName: _propTypes2.default.string,
    target: _propTypes2.default.any,
    align: _propTypes2.default.string,
    offset: _propTypes2.default.array,
    overlayProps: _propTypes2.default.object,
    afterClose: _propTypes2.default.func,
    mode: _propTypes2.default.oneOf(['inline', 'popup']),
    onOpen: _propTypes2.default.func,
    onItemClick: _propTypes2.default.func
}, _class.defaultProps = {
    prefix: 'next-',
    align: 'tl tl',
    mode: 'popup'
}, _temp);

/**
 * 创建上下文菜单
 * @exportName create
 * @param {Object} props 属性对象
 */

ContextMenu.displayName = 'ContextMenu';
function create(props) {
    if (menuInstance) {
        menuInstance.destroy();
    }

    /* eslint-disable no-unused-vars */

    var afterClose = props.afterClose,
        others = _objectWithoutProperties(props, ['afterClose']);
    /* eslint-enable no-unused-vars */

    var div = document.createElement('div');
    document.body.appendChild(div);

    var closeChain = function closeChain() {
        (0, _reactDom.unmountComponentAtNode)(div);
        document.body.removeChild(div);

        afterClose && afterClose();
    };

    var newContext = _configProvider2.default.getContext();

    var menu = void 0;
    (0, _reactDom.render)(_react2.default.createElement(
        _configProvider2.default,
        newContext,
        _react2.default.createElement(ContextMenu, _extends({ ref: function ref(_ref) {
                menu = _ref;
            }, afterClose: closeChain }, others))
    ), div);

    menuInstance = {
        destroy: function destroy() {
            if (menu) {
                menu.close();
            }
        }
    };

    return menuInstance;
}
module.exports = exports['default'];

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function mapIconSize(size) {
    return {
        large: 'small',
        medium: 'xs',
        small: 'xs'
    }[size];
}

/** Button */
var Button = (_temp2 = _class = function (_Component) {
    _inherits(Button, _Component);

    function Button() {
        var _temp, _this, _ret;

        _classCallCheck(this, Button);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.onMouseUp = function (e) {
            _this.button.blur();

            if (_this.props.onMouseUp) {
                _this.props.onMouseUp(e);
            }
        }, _this.buttonRefHandler = function (button) {
            _this.button = button;
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Button.prototype.render = function render() {
        var _classNames;

        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            type = _props.type,
            size = _props.size,
            htmlType = _props.htmlType,
            loading = _props.loading,
            text = _props.text,
            warning = _props.warning,
            ghost = _props.ghost,
            component = _props.component,
            iconSize = _props.iconSize,
            children = _props.children,
            rtl = _props.rtl,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'type', 'size', 'htmlType', 'loading', 'text', 'warning', 'ghost', 'component', 'iconSize', 'children', 'rtl']);

        var ghostType = ['light', 'dark'].indexOf(ghost) >= 0 ? ghost : 'dark';

        var btnCls = (0, _classnames2.default)((_classNames = {}, _classNames[prefix + 'btn'] = true, _classNames['' + prefix + size] = size, _classNames[prefix + 'btn-' + type] = type && !ghost, _classNames[prefix + 'btn-text'] = text, _classNames[prefix + 'btn-warning'] = warning, _classNames[prefix + 'btn-loading'] = loading, _classNames[prefix + 'btn-ghost'] = ghost, _classNames[prefix + 'btn-' + ghostType] = ghost, _classNames[className] = className, _classNames));

        var count = _react.Children.count(children);
        var clonedChildren = _react.Children.map(children, function (child, index) {
            if (child && typeof child.type === 'function' && child.type._typeMark === 'icon') {
                var _classNames2;

                var iconCls = (0, _classnames2.default)((_classNames2 = {}, _classNames2[prefix + 'btn-icon'] = !iconSize, _classNames2[prefix + 'icon-first'] = count > 1 && index === 0, _classNames2[prefix + 'icon-last'] = count > 1 && index === count - 1, _classNames2[prefix + 'icon-alone'] = count === 1, _classNames2[child.props.className] = !!child.props.className, _classNames2));
                return _react2.default.cloneElement(child, {
                    className: iconCls,
                    size: iconSize || mapIconSize(size)
                });
            }

            return child;
        });

        var TagName = component;
        var tagAttrs = _extends({}, others, {
            type: htmlType,
            className: btnCls
        });

        if (TagName === 'a') {
            delete tagAttrs.type;

            if (tagAttrs.disabled) {
                delete tagAttrs.onClick; // a 标签的 onClick 浏览器默认不会禁用
                tagAttrs.href && delete tagAttrs.href; // a 标签在禁用状态下无跳转
            }
        }

        return _react2.default.createElement(
            TagName,
            _extends({}, tagAttrs, { dir: rtl ? 'rtl' : undefined, onMouseUp: this.onMouseUp, ref: this.buttonRefHandler, role: 'button' }),
            clonedChildren
        );
    };

    return Button;
}(_react.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    rtl: _propTypes2.default.bool,
    /**
     * 按钮的类型
     */
    type: _propTypes2.default.oneOf(['primary', 'secondary', 'normal']),
    /**
     * 按钮的尺寸
     */
    size: _propTypes2.default.oneOf(['small', 'medium', 'large']),
    /**
     * 按钮中 Icon 的尺寸，用于替代 Icon 的默认大小
     */
    iconSize: _propTypes2.default.oneOf(['xxs', 'xs', 'small', 'medium', 'large', 'xl', 'xxl', 'xxxl']),
    /**
     * 当 component = 'button' 时，设置 button 标签的 type 值
     */
    htmlType: _propTypes2.default.oneOf(['submit', 'reset', 'button']),
    /**
     * 设置标签类型
     */
    component: _propTypes2.default.oneOf(['button', 'a']),
    /**
     * 设置按钮的载入状态
     */
    loading: _propTypes2.default.bool,
    /**
     * 是否为幽灵按钮
     */
    ghost: _propTypes2.default.oneOf([true, false, 'light', 'dark']),
    /**
     * 是否为文本按钮
     */
    text: _propTypes2.default.bool,
    /**
     * 是否为警告按钮
     */
    warning: _propTypes2.default.bool,
    /**
     * 是否禁用
     */
    disabled: _propTypes2.default.bool,
    /**
     * 点击按钮的回调
     * @param {Object} e Event Object
     */
    onClick: _propTypes2.default.func,
    className: _propTypes2.default.string,
    onMouseUp: _propTypes2.default.func,
    children: _propTypes2.default.node
}, _class.defaultProps = {
    prefix: 'next-',
    type: 'normal',
    size: 'medium',
    htmlType: 'button',
    component: 'button',
    loading: false,
    ghost: false,
    text: false,
    warning: false,
    disabled: false,
    onClick: function onClick() {}
}, _temp2);
Button.displayName = 'Button';
exports.default = Button;
module.exports = exports['default'];

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Button.Group
 */
var ButtonGroup = (_temp = _class = function (_Component) {
    _inherits(ButtonGroup, _Component);

    function ButtonGroup() {
        _classCallCheck(this, ButtonGroup);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    ButtonGroup.prototype.render = function render() {
        var _classNames;

        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            size = _props.size,
            children = _props.children,
            rtl = _props.rtl,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'size', 'children', 'rtl']);

        var groupCls = (0, _classnames2.default)((_classNames = {}, _classNames[prefix + 'btn-group'] = true, _classNames[className] = className, _classNames));

        var cloneChildren = _react.Children.map(children, function (child) {
            if (child) {
                return _react2.default.cloneElement(child, {
                    size: size
                });
            }
        });

        if (rtl) {
            others.dir = 'rtl';
        }

        return _react2.default.createElement(
            'div',
            _extends({}, others, { className: groupCls }),
            cloneChildren
        );
    };

    return ButtonGroup;
}(_react.Component), _class.propTypes = {
    rtl: _propTypes2.default.bool,
    prefix: _propTypes2.default.string,
    /**
     * 统一设置 Button 组件的按钮大小
     */
    size: _propTypes2.default.string,
    className: _propTypes2.default.string,
    children: _propTypes2.default.node
}, _class.defaultProps = {
    prefix: 'next-',
    size: 'medium'
}, _temp);
ButtonGroup.displayName = 'ButtonGroup';
exports.default = _configProvider2.default.config(ButtonGroup);
module.exports = exports['default'];

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var Resize = (_temp2 = _class = function (_React$Component) {
    _inherits(Resize, _React$Component);

    function Resize() {
        var _temp, _this, _ret;

        _classCallCheck(this, Resize);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onMouseDown = function (e) {
            _this.lastPageX = e.pageX;
            _util.events.on(document, 'mousemove', _this.onMouseMove);
            _util.events.on(document, 'mouseup', _this.onMouseUp);
            _this.unSelect();
        }, _this.onMouseMove = function (e) {
            var pageX = e.pageX;
            var changedPageX = pageX - _this.lastPageX;
            _this.props.onChange(_this.props.dataIndex, changedPageX);
            _this.lastPageX = pageX;
        }, _this.onMouseUp = function () {
            _this.destory();
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Resize.prototype.componentWillUnmount = function componentWillUnmount() {
        this.destory();
    };

    Resize.prototype.destory = function destory() {
        _util.events.off(document, 'mousemove', this.onMouseMove);
        _util.events.off(document, 'mouseup', this.onMouseMove);
        this.select();
    };

    Resize.prototype.unSelect = function unSelect() {
        _util.dom.setStyle(document.body, {
            userSelect: 'none',
            cursor: 'ew-resize'
        });
        document.body.setAttribute('unselectable', 'on');
    };

    Resize.prototype.select = function select() {
        _util.dom.setStyle(document.body, {
            userSelect: '',
            cursor: ''
        });
        document.body.removeAttribute('unselectable');
    };

    Resize.prototype.render = function render() {
        var prefix = this.props.prefix;

        return _react2.default.createElement('a', { className: prefix + 'table-resize-handler', onMouseDown: this.onMouseDown });
    };

    return Resize;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    onChange: _propTypes2.default.func,
    dataIndex: _propTypes2.default.string
}, _class.defaultProps = {
    onChange: function onChange() {}
}, _temp2);
Resize.displayName = 'Resize';
exports.default = Resize;
module.exports = exports['default'];

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var Wrapper = function (_Component) {
    _inherits(Wrapper, _Component);

    function Wrapper() {
        _classCallCheck(this, Wrapper);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    Wrapper.prototype.render = function render() {
        var _props = this.props,
            colGroup = _props.colGroup,
            children = _props.children,
            Tag = _props.component;

        return _react2.default.createElement(
            Tag,
            { role: 'table' },
            colGroup,
            children
        );
    };

    return Wrapper;
}(_react.Component);

Wrapper.displayName = 'Wrapper';
exports.default = Wrapper;


Wrapper.defaultProps = {
    component: 'table'
};

Wrapper.propTypes = {
    children: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    colGroup: _propTypes2.default.any,
    component: _propTypes2.default.string
};
module.exports = exports['default'];

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Table.ColumnGroup
 * @order 1
 **/
var ColumnGroup = (_temp = _class = function (_React$Component) {
    _inherits(ColumnGroup, _React$Component);

    function ColumnGroup() {
        _classCallCheck(this, ColumnGroup);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    ColumnGroup.prototype.getChildContext = function getChildContext() {
        return {
            parent: this
        };
    };

    ColumnGroup.prototype.render = function render() {
        return null;
    };

    return ColumnGroup;
}(_react2.default.Component), _class.propTypes = {
    /**
     * 表头显示的内容
     */
    title: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.node, _propTypes2.default.func])
}, _class.childContextTypes = {
    parent: _propTypes2.default.any
}, _class.defaultProps = {
    title: 'column-group'
}, _class._typeMark = 'columnGroup', _temp);
ColumnGroup.displayName = 'ColumnGroup';
exports.default = ColumnGroup;
module.exports = exports['default'];

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = tree;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _row = __webpack_require__(124);

var _row2 = _interopRequireDefault(_row);

var _cell = __webpack_require__(125);

var _cell2 = _interopRequireDefault(_cell);

var _util = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};

function tree(BaseComponent) {
    var _class, _temp;

    var TreeTable = (_temp = _class = function (_React$Component) {
        _inherits(TreeTable, _React$Component);

        function TreeTable(props, context) {
            _classCallCheck(this, TreeTable);

            var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

            _this.onTreeNodeClick = function (record) {
                var primaryKey = _this.props.primaryKey,
                    id = record[primaryKey],
                    dataSource = _this.ds,
                    openRowKeys = [].concat(_this.state.openRowKeys),
                    index = openRowKeys.indexOf(id),
                    getChildrenKeyById = function getChildrenKeyById(id) {
                    var ret = [id];
                    var loop = function loop(data) {
                        data.forEach(function (item) {
                            ret.push(item[primaryKey]);
                            if (item.children) {
                                loop(item.children);
                            }
                        });
                    };
                    dataSource.forEach(function (item) {
                        if (item[primaryKey] === id) {
                            if (item.children) {
                                loop(item.children);
                            }
                        }
                    });
                    return ret;
                };


                if (index > -1) {
                    // 不仅要删除当前的openRowKey，还需要删除关联子节点的openRowKey
                    var ids = getChildrenKeyById(id);
                    ids.forEach(function (id) {
                        var i = openRowKeys.indexOf(id);
                        if (i > -1) {
                            openRowKeys.splice(i, 1);
                        }
                    });
                } else {
                    openRowKeys.push(id);
                }

                if (!('openRowKeys' in _this.props)) {
                    _this.setState({
                        openRowKeys: openRowKeys
                    });
                }
                _this.props.onRowOpen(openRowKeys, id, index === -1, record);
            };

            _this.state = {
                openRowKeys: props.openRowKeys || []
            };
            return _this;
        }

        TreeTable.prototype.getChildContext = function getChildContext() {
            return {
                openTreeRowKeys: this.state.openRowKeys,
                indent: this.props.indent,
                treeStatus: this.getTreeNodeStatus(this.ds),
                onTreeNodeClick: this.onTreeNodeClick,
                isTree: this.props.isTree
            };
        };

        TreeTable.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
            if ('openRowKeys' in nextProps) {
                var openRowKeys = nextProps.openRowKeys;

                this.setState({
                    openRowKeys: openRowKeys
                });
            }
        };

        TreeTable.prototype.normalizeDataSource = function normalizeDataSource(dataSource) {
            var ret = [],
                loop = function loop(dataSource, level) {
                dataSource.forEach(function (item) {
                    item.__level = level;
                    ret.push(item);
                    if (item.children) {
                        loop(item.children, level + 1);
                    }
                });
            };
            loop(dataSource, 0);
            this.ds = ret;
            return ret;
        };

        TreeTable.prototype.getTreeNodeStatus = function getTreeNodeStatus() {
            var dataSource = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            var openRowKeys = this.state.openRowKeys,
                primaryKey = this.props.primaryKey,
                ret = [];


            openRowKeys.forEach(function (openKey) {
                dataSource.forEach(function (item) {
                    if (item[primaryKey] === openKey) {
                        if (item.children) {
                            item.children.forEach(function (child) {
                                ret.push(child[primaryKey]);
                            });
                        }
                    }
                });
            });
            return ret;
        };

        TreeTable.prototype.render = function render() {
            /* eslint-disable no-unused-vars, prefer-const */
            var _props = this.props,
                components = _props.components,
                isTree = _props.isTree,
                dataSource = _props.dataSource,
                indent = _props.indent,
                others = _objectWithoutProperties(_props, ['components', 'isTree', 'dataSource', 'indent']);

            if (isTree) {
                components = _extends({}, components);
                if (!components.Row) {
                    components.Row = _row2.default;
                }
                if (!components.Cell) {
                    components.Cell = _cell2.default;
                }

                dataSource = this.normalizeDataSource(dataSource);
            }
            return _react2.default.createElement(BaseComponent, _extends({}, others, { dataSource: dataSource, components: components }));
        };

        return TreeTable;
    }(_react2.default.Component), _class.TreeRow = _row2.default, _class.TreeCell = _cell2.default, _class.propTypes = _extends({
        /**
         * 默认情况下展开的树形表格，传入了此属性代表tree的展开为受控操作
         */
        openRowKeys: _propTypes2.default.array,
        /**
         * 点击tree展开或者关闭的时候触发的事件
         * @param {Array} openRowKeys tree模式下展开的key
         * @param {String} currentRowKey 当前点击行的key
         * @param {Boolean} opened 当前点击是展开还是收起
         * @param {Object} currentRecord 当前点击行的记录
         */
        onRowOpen: _propTypes2.default.func,
        /**
         * dataSource当中数据的主键，如果给定的数据源中的属性不包含该主键，会造成选择状态全部选中
         */
        primaryKey: _propTypes2.default.string,
        /**
         * 在tree模式下的缩进尺寸， 仅在isTree为true时候有效
         */
        indent: _propTypes2.default.number,
        /**
         * 开启Table的tree模式, 接收的数据格式中包含children则渲染成tree table
         */
        isTree: _propTypes2.default.bool,
        locale: _propTypes2.default.object
    }, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps, {
        primaryKey: 'id',
        onRowOpen: noop,
        components: {},
        indent: 12
    }), _class.childContextTypes = {
        openTreeRowKeys: _propTypes2.default.array,
        indent: _propTypes2.default.number,
        treeStatus: _propTypes2.default.array,
        onTreeNodeClick: _propTypes2.default.func,
        isTree: _propTypes2.default.bool
    }, _temp);
    TreeTable.displayName = 'TreeTable';

    (0, _util.statics)(TreeTable, BaseComponent);
    return TreeTable;
}
module.exports = exports['default'];

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _row = __webpack_require__(64);

var _row2 = _interopRequireDefault(_row);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var TreeRow = (_temp = _class = function (_React$Component) {
    _inherits(TreeRow, _React$Component);

    function TreeRow() {
        _classCallCheck(this, TreeRow);

        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }

    TreeRow.prototype.render = function render() {
        var _classnames;

        /* eslint-disable no-unused-vars*/
        var _props = this.props,
            className = _props.className,
            record = _props.record,
            primaryKey = _props.primaryKey,
            prefix = _props.prefix,
            others = _objectWithoutProperties(_props, ['className', 'record', 'primaryKey', 'prefix']);

        var _context = this.context,
            treeStatus = _context.treeStatus,
            openRowKeys = _context.openRowKeys;

        var cls = (0, _classnames3.default)((_classnames = {
            hidden: !(treeStatus.indexOf(record[primaryKey]) > -1) && record.__level !== 0
        }, _classnames[prefix + 'table-row-level-' + record.__level] = true, _classnames.opened = openRowKeys.indexOf(record[primaryKey]) > -1, _classnames));
        return _react2.default.createElement(_row2.default, _extends({}, others, { record: record, className: cls, primaryKey: primaryKey, prefix: prefix }));
    };

    return TreeRow;
}(_react2.default.Component), _class.propTypes = _extends({}, _row2.default.propTypes), _class.defaultProps = _extends({}, _row2.default.defaultProps), _class.contextTypes = {
    treeStatus: _propTypes2.default.array,
    openRowKeys: _propTypes2.default.array
}, _temp);
TreeRow.displayName = 'TreeRow';
exports.default = TreeRow;
module.exports = exports['default'];

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

var _cell = __webpack_require__(18);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var TreeCell = (_temp2 = _class = function (_React$Component) {
    _inherits(TreeCell, _React$Component);

    function TreeCell() {
        var _temp, _this, _ret;

        _classCallCheck(this, TreeCell);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onTreeNodeClick = function (record, e) {
            e.stopPropagation();
            _this.context.onTreeNodeClick(record);
        }, _this.expandedKeydown = function (record, e) {
            e.preventDefault();
            e.stopPropagation();

            if (e.keyCode === _util.KEYCODE.ENTER) {
                _this.onTreeNodeClick(record, e);
            }
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    TreeCell.prototype.render = function render() {
        var _this2 = this;

        var _props = this.props,
            colIndex = _props.colIndex,
            record = _props.record,
            prefix = _props.prefix,
            primaryKey = _props.primaryKey,
            locale = _props.locale;
        var _context = this.context,
            openRowKeys = _context.openTreeRowKeys,
            indent = _context.indent,
            isTree = _context.isTree,
            rowSelection = _context.rowSelection;

        var treeArrowNodeIndex = rowSelection ? 1 : 0;
        var firstCellStyle = void 0,
            treeArrowNode = void 0;
        if (colIndex === treeArrowNodeIndex) {
            var treeArrowType = void 0;
            if (isTree) {
                firstCellStyle = {
                    paddingLeft: indent * (record.__level + 1)
                };
                treeArrowNode = _react2.default.createElement(_icon2.default, { size: 'xs', className: prefix + 'table-tree-placeholder' });
                if (record.children && record.children.length) {
                    var hasExpanded = openRowKeys.indexOf(record[primaryKey]) > -1;

                    treeArrowType = hasExpanded ? 'arrow-down' : 'arrow-right';

                    treeArrowNode = _react2.default.createElement(_icon2.default, {
                        className: prefix + 'table-tree-arrow',
                        type: treeArrowType,
                        size: 'xs',
                        onClick: function onClick(e) {
                            return _this2.onTreeNodeClick(record, e);
                        },
                        onKeyDown: function onKeyDown(e) {
                            return _this2.expandedKeydown(record, e);
                        },
                        role: 'button',
                        tabIndex: '0',
                        'aria-expanded': hasExpanded,
                        'aria-label': hasExpanded ? locale.expanded : locale.folded });
                }
            }
        }
        return _react2.default.createElement(
            _cell2.default,
            _extends({}, this.props, { innerStyle: firstCellStyle }),
            treeArrowNode
        );
    };

    return TreeCell;
}(_react2.default.Component), _class.propTypes = _extends({
    indent: _propTypes2.default.number,
    locale: _propTypes2.default.object
}, _cell2.default.propTypes), _class.defaultProps = _extends({}, _cell2.default.defaultProps, {
    component: 'td',
    indent: 20
}), _class.contextTypes = {
    openTreeRowKeys: _propTypes2.default.array,
    indent: _propTypes2.default.number,
    onTreeNodeClick: _propTypes2.default.func,
    isTree: _propTypes2.default.bool,
    rowSelection: _propTypes2.default.object
}, _temp2);
TreeCell.displayName = 'TreeCell';
exports.default = TreeCell;
module.exports = exports['default'];

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = fixed;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _util = __webpack_require__(2);

var _header = __webpack_require__(19);

var _header2 = _interopRequireDefault(_header);

var _body = __webpack_require__(67);

var _body2 = _interopRequireDefault(_body);

var _wrapper = __webpack_require__(24);

var _wrapper2 = _interopRequireDefault(_wrapper);

var _util2 = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function fixed(BaseComponent) {
    var _class, _temp2;

    /** Table */
    var FixedTable = (_temp2 = _class = function (_React$Component) {
        _inherits(FixedTable, _React$Component);

        function FixedTable() {
            var _temp, _this, _ret;

            _classCallCheck(this, FixedTable);

            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.getNode = function (type, node, lockType) {
                lockType = lockType ? lockType.charAt(0).toUpperCase() + lockType.substr(1) : '';
                _this['' + type + lockType + 'Node'] = node;
                if (type === 'header' && !lockType) {
                    _this.innerHeaderNode = _this.headerNode.querySelector('div');
                }
            }, _this.onBodyScroll = function () {
                _this.scrollTo(_this.bodyNode.scrollLeft, _this.bodyNode.scrollTop);
            }, _temp), _possibleConstructorReturn(_this, _ret);
        }

        FixedTable.prototype.getChildContext = function getChildContext() {
            return {
                fixedHeader: this.props.fixedHeader,
                maxBodyHeight: this.props.maxBodyHeight,
                onBodyScroll: this.onBodyScroll,
                getNode: this.getNode
            };
        };

        FixedTable.prototype.componentDidMount = function componentDidMount() {
            this.adjustFixedHeaderSize();
        };

        FixedTable.prototype.componentDidUpdate = function componentDidUpdate() {
            this.adjustFixedHeaderSize();
        };

        FixedTable.prototype.adjustFixedHeaderSize = function adjustFixedHeaderSize() {
            var _props = this.props,
                hasHeader = _props.hasHeader,
                fixedHeader = _props.fixedHeader,
                maxBodyHeight = _props.maxBodyHeight;

            if (hasHeader && fixedHeader && !this.props.lockType) {
                if (this.bodyNode.scrollHeight <= maxBodyHeight) {
                    _util.dom.setStyle(this.headerNode, 'paddingRight', 0);
                } else {
                    _util.dom.setStyle(this.headerNode, 'paddingRight', _util.dom.scrollbar().width);
                }
            }
        };

        FixedTable.prototype.scrollTo = function scrollTo(x) {
            if (this.innerHeaderNode) {
                this.innerHeaderNode.scrollLeft = x;
            }
        };

        FixedTable.prototype.render = function render() {
            /* eslint-disable no-unused-vars, prefer-const */
            var _props2 = this.props,
                components = _props2.components,
                className = _props2.className,
                prefix = _props2.prefix,
                fixedHeader = _props2.fixedHeader,
                maxBodyHeight = _props2.maxBodyHeight,
                others = _objectWithoutProperties(_props2, ['components', 'className', 'prefix', 'fixedHeader', 'maxBodyHeight']);

            if (fixedHeader) {
                var _classnames;

                components = _extends({}, components);
                if (!components.Header) {
                    components.Header = _header2.default;
                }
                if (!components.Body) {
                    components.Body = _body2.default;
                }
                if (!components.Wrapper) {
                    components.Wrapper = _wrapper2.default;
                }
                className = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-fixed'] = true, _classnames[className] = className, _classnames));
            }
            return _react2.default.createElement(BaseComponent, _extends({}, others, { components: components, className: className, prefix: prefix }));
        };

        return FixedTable;
    }(_react2.default.Component), _class.FixedHeader = _header2.default, _class.FixedBody = _body2.default, _class.FixedWrapper = _wrapper2.default, _class.propTypes = _extends({
        /**
          * 是否具有表头
          */
        hasHeader: _propTypes2.default.bool,
        /**
          * 表头是否固定，该属性配合maxBodyHeight使用，当内容区域的高度超过maxBodyHeight的时候，在内容区域会出现滚动条
          */
        fixedHeader: _propTypes2.default.bool,
        /**
         * 最大内容区域的高度,在`fixedHeader`为`true`的时候,超过这个高度会出现滚动条
         */
        maxBodyHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string])
    }, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps, {
        hasHeader: true,
        fixedHeader: false,
        maxBodyHeight: 200,
        components: {},
        refs: {},
        prefix: 'next-'
    }), _class.childContextTypes = {
        fixedHeader: _propTypes2.default.bool,
        maxBodyHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
        onBodyScroll: _propTypes2.default.func,
        getNode: _propTypes2.default.func
    }, _temp2);
    FixedTable.displayName = 'FixedTable';

    (0, _util2.statics)(FixedTable, BaseComponent);
    return FixedTable;
}
module.exports = exports['default'];

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = selection;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _checkbox = __webpack_require__(37);

var _checkbox2 = _interopRequireDefault(_checkbox);

var _radio = __webpack_require__(61);

var _radio2 = _interopRequireDefault(_radio);

var _util = __webpack_require__(2);

var _zhCn = __webpack_require__(35);

var _zhCn2 = _interopRequireDefault(_zhCn);

var _row = __webpack_require__(64);

var _row2 = _interopRequireDefault(_row);

var _column = __webpack_require__(23);

var _column2 = _interopRequireDefault(_column);

var _util2 = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var makeChain = _util.func.makeChain;


var unique = function unique(arr) {
    var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'this';

    var temp = {},
        ret = [];
    arr.forEach(function (item) {
        var value = void 0;
        if (key === 'this') {
            value = item;
        } else {
            value = item[key];
        }
        if (!temp[value]) {
            ret.push(item);
            temp[value] = true;
        }
    });
    return ret;
};

function selection(BaseComponent) {
    var _class, _temp;

    /** Table */
    var SelectionTable = (_temp = _class = function (_React$Component) {
        _inherits(SelectionTable, _React$Component);

        function SelectionTable(props, context) {
            _classCallCheck(this, SelectionTable);

            var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

            _this.renderSelectionHeader = function () {
                var onChange = _this.selectAllRow,
                    attrs = {},
                    _this$props = _this.props,
                    rowSelection = _this$props.rowSelection,
                    primaryKey = _this$props.primaryKey,
                    dataSource = _this$props.dataSource,
                    locale = _this$props.locale,
                    selectedRowKeys = _this.state.selectedRowKeys,
                    mode = rowSelection.mode ? rowSelection.mode : 'multiple';

                var checked = !!selectedRowKeys.length;
                var indeterminate = false;
                _this.flatDataSource(dataSource).filter(function (record, index) {
                    if (!rowSelection.getProps) {
                        return true;
                    } else {
                        return !(rowSelection.getProps(record, index) || {}).disabled;
                    }
                }).map(function (record) {
                    return record[primaryKey];
                }).forEach(function (id) {
                    if (selectedRowKeys.indexOf(id) === -1) {
                        checked = false;
                    } else {
                        indeterminate = true;
                    }
                });
                attrs.onClick = makeChain(function (e) {
                    e.stopPropagation();
                }, attrs.onClick);

                if (checked) {
                    indeterminate = false;
                }
                return mode === 'multiple' ? _react2.default.createElement(_checkbox2.default, _extends({ indeterminate: indeterminate, 'aria-label': locale.selectAll, checked: checked, onChange: onChange }, attrs)) : null;
            };

            _this.renderSelectionBody = function (value, index, record) {
                var _this$props2 = _this.props,
                    rowSelection = _this$props2.rowSelection,
                    primaryKey = _this$props2.primaryKey;
                var selectedRowKeys = _this.state.selectedRowKeys;

                var mode = rowSelection.mode ? rowSelection.mode : 'multiple';
                var checked = selectedRowKeys.indexOf(record[primaryKey]) > -1;
                var onChange = _this.selectOneRow.bind(_this, index, record);
                var attrs = rowSelection.getProps ? rowSelection.getProps(record, index) || {} : {};

                attrs.onClick = makeChain(function (e) {
                    e.stopPropagation();
                }, attrs.onClick);
                return mode === 'multiple' ? _react2.default.createElement(_checkbox2.default, _extends({ checked: checked, onChange: onChange }, attrs)) : _react2.default.createElement(_radio2.default, _extends({ checked: checked, onChange: onChange }, attrs));
            };

            _this.selectAllRow = function (checked, e) {
                var ret = [].concat(_this.state.selectedRowKeys),
                    _this$props3 = _this.props,
                    rowSelection = _this$props3.rowSelection,
                    primaryKey = _this$props3.primaryKey,
                    dataSource = _this$props3.dataSource,
                    entireDataSource = _this$props3.entireDataSource,
                    selectedRowKeys = _this.state.selectedRowKeys,
                    getProps = rowSelection.getProps;

                var attrs = {},
                    records = [];

                var source = entireDataSource ? entireDataSource : dataSource;

                _this.flatDataSource(source).forEach(function (record, index) {
                    var id = record[primaryKey];
                    if (getProps) {
                        attrs = getProps(record, index) || {};
                    }
                    // 反选和全选的时候不要丢弃禁用项的选中状态
                    if (checked && (!attrs.disabled || selectedRowKeys.indexOf(id) > -1)) {
                        ret.push(id);
                        records.push(record);
                    } else if (attrs.disabled && selectedRowKeys.indexOf(id) > -1) {
                        ret.push(id);
                        records.push(record);
                    } else {
                        var i = ret.indexOf(id);
                        i > -1 && ret.splice(i, 1);
                    }
                });

                records = unique(records, primaryKey);
                if (typeof rowSelection.onSelectAll === 'function') {
                    rowSelection.onSelectAll(checked, records);
                }
                _this.triggerSelection(rowSelection, unique(ret), records);
                e.stopPropagation();
            };

            _this.state = {
                selectedRowKeys: props.rowSelection && 'selectedRowKeys' in props.rowSelection ? props.rowSelection.selectedRowKeys || [] : []
            };
            return _this;
        }

        SelectionTable.prototype.getChildContext = function getChildContext() {
            return {
                rowSelection: this.props.rowSelection,
                selectedRowKeys: this.state.selectedRowKeys
            };
        };

        SelectionTable.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
            if (nextProps.rowSelection && 'selectedRowKeys' in nextProps.rowSelection) {
                var selectedRowKeys = nextProps.rowSelection.selectedRowKeys || [];
                this.setState({
                    selectedRowKeys: selectedRowKeys
                });
            }
        };

        SelectionTable.prototype.normalizeChildren = function normalizeChildren(children) {
            var _props = this.props,
                prefix = _props.prefix,
                rowSelection = _props.rowSelection;

            if (rowSelection) {
                children = _react.Children.map(children, function (child, index) {
                    return _react2.default.cloneElement(child, {
                        key: index
                    });
                });
                children.unshift(_react2.default.createElement(_column2.default, { key: 'selection', title: this.renderSelectionHeader.bind(this),
                    cell: this.renderSelectionBody.bind(this),
                    width: 50,
                    className: prefix + 'table-selection', __normalized: true }));
                return children;
            }
            return children;
        };

        SelectionTable.prototype.selectOneRow = function selectOneRow(index, record, checked, e) {
            var selectedRowKeys = [].concat(this.state.selectedRowKeys),
                i = void 0;
            var _props2 = this.props,
                primaryKey = _props2.primaryKey,
                rowSelection = _props2.rowSelection,
                dataSource = _props2.dataSource,
                mode = rowSelection.mode ? rowSelection.mode : 'multiple',
                id = record[primaryKey];

            if (!id) {
                _util.log.warning('Can\'t get value from record using given ' + primaryKey + ' as primaryKey.');
            }
            if (mode === 'multiple') {
                if (checked) {
                    selectedRowKeys.push(id);
                } else {
                    i = selectedRowKeys.indexOf(id);
                    selectedRowKeys.splice(i, 1);
                }
            } else if (checked) {
                selectedRowKeys = [id];
            }
            var records = unique(dataSource.filter(function (item) {
                return selectedRowKeys.indexOf(item[primaryKey]) > -1;
            }), primaryKey);
            if (typeof rowSelection.onSelect === 'function') {
                rowSelection.onSelect(checked, record, records);
            }

            this.triggerSelection(rowSelection, selectedRowKeys, records);

            e.stopPropagation();
        };

        SelectionTable.prototype.triggerSelection = function triggerSelection(rowSelection, selectedRowKeys, records) {
            if (!('selectedRowKeys' in rowSelection)) {
                this.setState({
                    selectedRowKeys: selectedRowKeys
                });
            }
            if (typeof rowSelection.onChange === 'function') {
                rowSelection.onChange(selectedRowKeys, records);
            }
        };

        SelectionTable.prototype.flatDataSource = function flatDataSource(dataSource) {
            var ret = dataSource;
            var listHeader = this.context.listHeader;


            if (listHeader) {
                ret = [];
                var hasChildrenSelection = listHeader.hasChildrenSelection,
                    hasSelection = listHeader.hasSelection;

                dataSource.forEach(function (item) {
                    var children = item.children;
                    // 如果需要渲染selection才将这条记录插入到dataSource
                    // 或者没有孩子节点
                    if (hasSelection) {
                        ret.push(item);
                    }
                    if (children && hasChildrenSelection) {
                        ret = ret.concat(children);
                    }
                });
            }
            return ret;
        };

        SelectionTable.prototype.render = function render() {
            /* eslint-disable prefer-const */
            var _props3 = this.props,
                rowSelection = _props3.rowSelection,
                components = _props3.components,
                children = _props3.children,
                others = _objectWithoutProperties(_props3, ['rowSelection', 'components', 'children']);

            if (rowSelection) {
                children = this.normalizeChildren(children);
                components = _extends({}, components);
                components.Row = components.Row || _row2.default;
            }
            return _react2.default.createElement(
                BaseComponent,
                _extends({}, others, { components: components }),
                children
            );
        };

        return SelectionTable;
    }(_react2.default.Component), _class.SelectionRow = _row2.default, _class.propTypes = _extends({
        /**
        * 是否启用选择模式
        * @property {Function} getProps `Function(record, index)=>Object` 获取selection的默认属性
        * @property {Function} onChange `Function(selectedRowKeys:Array, records:Array)` 选择改变的时候触发的事件，**注意:** 其中records只会包含当前dataSource的数据，很可能会小于selectedRowKeys的长度。
        * @property {Function} onSelect `Function(selected:Boolean, record:Object, records:Array)` 用户手动选择/取消选择某行的回调
        * @property {Function} onSelectAll `Function(selected:Boolean, records:Array)` 用户手动选择/取消选择所有行的回调
        * @property {Array} selectedRowKeys 设置了此属性,将rowSelection变为受控状态,接收值为该行数据的primaryKey的值
        * @property {String} mode 选择selection的模式, 可选值为`single`, `multiple`，默认为`multiple`
        */
        rowSelection: _propTypes2.default.object,
        primaryKey: _propTypes2.default.string,
        dataSource: _propTypes2.default.array,
        entireDataSource: _propTypes2.default.array
    }, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps, {
        locale: _zhCn2.default.Table,
        primaryKey: 'id',
        prefix: 'next-'
    }), _class.contextTypes = {
        listHeader: _propTypes2.default.any
    }, _class.childContextTypes = {
        rowSelection: _propTypes2.default.object,
        selectedRowKeys: _propTypes2.default.array
    }, _temp);
    SelectionTable.displayName = 'SelectionTable';

    (0, _util2.statics)(SelectionTable, BaseComponent);
    return SelectionTable;
}
module.exports = exports['default'];

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = expanded;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _icon = __webpack_require__(9);

var _icon2 = _interopRequireDefault(_icon);

var _util = __webpack_require__(2);

var _row = __webpack_require__(65);

var _row2 = _interopRequireDefault(_row);

var _column = __webpack_require__(23);

var _column2 = _interopRequireDefault(_column);

var _util2 = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};

function expanded(BaseComponent) {
    var _class, _temp2;

    /** Table */
    var ExpandedTable = (_temp2 = _class = function (_React$Component) {
        _inherits(ExpandedTable, _React$Component);

        function ExpandedTable() {
            var _temp, _this, _ret;

            _classCallCheck(this, ExpandedTable);

            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
                openRowKeys: _this.props.openRowKeys || []
            }, _this.expandedKeydown = function (value, record, index, e) {
                e.preventDefault();
                e.stopPropagation();

                if (e.keyCode === _util.KEYCODE.ENTER) {
                    _this.onExpandedClick(value, record, index, e);
                }
            }, _this.renderExpandedCell = function (value, index, record) {
                var _classnames;

                var _this$props = _this.props,
                    getExpandedColProps = _this$props.getExpandedColProps,
                    prefix = _this$props.prefix,
                    locale = _this$props.locale;
                var openRowKeys = _this.state.openRowKeys,
                    primaryKey = _this.props.primaryKey,
                    hasExpanded = openRowKeys.indexOf(record[primaryKey]) > -1,
                    switchNode = hasExpanded ? _react2.default.createElement(_icon2.default, { type: 'minus', size: 'xs' }) : _react2.default.createElement(_icon2.default, { type: 'add', size: 'xs' }),
                    attrs = getExpandedColProps(record, index) || {};

                var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-expanded-ctrl'] = true, _classnames.disabled = attrs.disabled, _classnames[attrs.className] = attrs.className, _classnames));

                if (!attrs.disabled) {
                    attrs.onClick = _this.onExpandedClick.bind(_this, value, record, index);
                }
                return _react2.default.createElement(
                    'span',
                    _extends({}, attrs, {
                        role: 'button',
                        tabIndex: '0',
                        onKeyDown: _this.expandedKeydown.bind(_this, value, record, index),
                        'aria-label': hasExpanded ? locale.expanded : locale.folded,
                        'aria-expanded': hasExpanded,
                        className: cls }),
                    switchNode
                );
            }, _temp), _possibleConstructorReturn(_this, _ret);
        }

        ExpandedTable.prototype.getChildContext = function getChildContext() {
            return {
                openRowKeys: this.state.openRowKeys,
                expandedRowRender: this.props.expandedRowRender,
                expandedRowIndent: this.props.expandedRowIndent
            };
        };

        ExpandedTable.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
            if ('openRowKeys' in nextProps) {
                var openRowKeys = nextProps.openRowKeys;

                this.setState({
                    openRowKeys: openRowKeys
                });
            }
        };

        ExpandedTable.prototype.onExpandedClick = function onExpandedClick(value, record, i, e) {
            var openRowKeys = [].concat(this.state.openRowKeys),
                primaryKey = this.props.primaryKey,
                id = record[primaryKey],
                index = openRowKeys.indexOf(id);

            if (index > -1) {
                openRowKeys.splice(index, 1);
            } else {
                openRowKeys.push(id);
            }
            if (!('openRowKeys' in this.props)) {
                this.setState({
                    openRowKeys: openRowKeys
                });
            }
            this.props.onRowOpen(openRowKeys, id, index === -1, record);
            e.stopPropagation();
        };

        ExpandedTable.prototype.normalizeChildren = function normalizeChildren(children) {
            var toArrayChildren = _react.Children.map(children, function (child, index) {
                return _react2.default.cloneElement(child, {
                    key: index
                });
            });
            var prefix = this.props.prefix;

            toArrayChildren.unshift(_react2.default.createElement(_column2.default, { title: '', key: 'expanded', cell: this.renderExpandedCell.bind(this), width: 50, className: prefix + 'table-expanded', __normalized: true }));
            return toArrayChildren;
        };

        ExpandedTable.prototype.normalizeDataSource = function normalizeDataSource(ds) {
            var ret = [];
            ds.forEach(function (item) {
                var itemCopy = _extends({}, item);
                itemCopy.__expanded = true;
                ret.push(item, itemCopy);
            });
            return ret;
        };

        ExpandedTable.prototype.render = function render() {
            /* eslint-disable no-unused-vars, prefer-const */
            var _props = this.props,
                components = _props.components,
                openRowKeys = _props.openRowKeys,
                expandedRowRender = _props.expandedRowRender,
                hasExpandedRowCtrl = _props.hasExpandedRowCtrl,
                children = _props.children,
                dataSource = _props.dataSource,
                getExpandedColProps = _props.getExpandedColProps,
                expandedRowIndent = _props.expandedRowIndent,
                onRowOpen = _props.onRowOpen,
                onExpandedRowClick = _props.onExpandedRowClick,
                others = _objectWithoutProperties(_props, ['components', 'openRowKeys', 'expandedRowRender', 'hasExpandedRowCtrl', 'children', 'dataSource', 'getExpandedColProps', 'expandedRowIndent', 'onRowOpen', 'onExpandedRowClick']);

            if (expandedRowRender && !components.Row) {
                components = _extends({}, components);
                components.Row = _row2.default;
                dataSource = this.normalizeDataSource(dataSource);
            }
            if (expandedRowRender && hasExpandedRowCtrl) {
                children = this.normalizeChildren(children);
            }

            return _react2.default.createElement(
                BaseComponent,
                _extends({}, others, { dataSource: dataSource, components: components }),
                children
            );
        };

        return ExpandedTable;
    }(_react2.default.Component), _class.ExpandedRow = _row2.default, _class.propTypes = _extends({
        /**
         * 额外渲染行的渲染函数
         * @param {Object} record 该行所对应的数据
         * @param {Number} index 该行所对应的序列
         * @returns {Element}
         */
        expandedRowRender: _propTypes2.default.func,
        /**
         * 额外渲染行的缩进
         */
        expandedRowIndent: _propTypes2.default.array,
        /**
         * 默认情况下展开的渲染行或者Tree, 传入此属性为受控状态
         */
        openRowKeys: _propTypes2.default.array,
        /**
         * 是否显示点击展开额外渲染行的+号按钮
         */
        hasExpandedRowCtrl: _propTypes2.default.bool,
        /**
         * 设置额外渲染行的属性
         */
        getExpandedColProps: _propTypes2.default.func,
        /**
         * 在额外渲染行或者Tree展开或者收起的时候触发的事件
         * @param {Array} openRowKeys 展开的渲染行的key
         * @param {String} currentRowKey 当前点击的渲染行的key
         * @param {Boolean} expanded 当前点击是展开还是收起
         * @param {Object} currentRecord 当前点击额外渲染行的记录
         */
        onRowOpen: _propTypes2.default.func,
        /**
         * 点击额外渲染行触发的事件
         * @param {Object} record 该行所对应的数据
         * @param {Number} index 该行所对应的序列
         * @param {Event} e DOM事件对象
         */
        onExpandedRowClick: _propTypes2.default.func,
        locale: _propTypes2.default.object
    }, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps, {
        getExpandedColProps: noop,
        onRowOpen: noop,
        hasExpandedRowCtrl: true,
        components: {},
        expandedRowIndent: [1, 0],
        prefix: 'next-'
    }), _class.childContextTypes = {
        openRowKeys: _propTypes2.default.array,
        expandedRowRender: _propTypes2.default.func,
        expandedRowIndent: _propTypes2.default.array
    }, _temp2);
    ExpandedTable.displayName = 'ExpandedTable';

    (0, _util2.statics)(ExpandedTable, BaseComponent);
    return ExpandedTable;
}
module.exports = exports['default'];

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = virtual;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(2);

var _body = __webpack_require__(130);

var _body2 = _interopRequireDefault(_body);

var _util2 = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};
function virtual(BaseComponent) {
    var _class, _temp2;

    var VirtualTable = (_temp2 = _class = function (_React$Component) {
        _inherits(VirtualTable, _React$Component);

        function VirtualTable() {
            var _temp, _this, _ret;

            _classCallCheck(this, VirtualTable);

            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
                rowHeight: _this.props.rowHeight,
                scrollToRow: _this.props.scrollToRow,
                height: _this.props.maxBodyHeight
            }, _this.onScroll = function () {
                // 避免横向滚动带来的性能问题
                var scrollTop = _this.bodyNode.scrollTop;
                if (scrollTop === _this.lastScrollTop) {
                    return;
                }
                var start = _this.computeScrollToRow(scrollTop);
                if (!('scrollToRow' in _this.props)) {
                    _this.setState({
                        scrollToRow: start
                    });
                }
                _this.props.onBodyScroll(start);
                _this.lastScrollTop = scrollTop;
            }, _this.getBodyNode = function (node, lockType) {
                lockType = lockType ? lockType.charAt(0).toUpperCase() + lockType.substr(1) : '';
                _this['body' + lockType + 'Node'] = node;
            }, _this.getTableInstance = function (type, instance) {
                type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';
                _this['table' + type + 'Inc'] = instance;
            }, _temp), _possibleConstructorReturn(_this, _ret);
        }

        VirtualTable.prototype.getChildContext = function getChildContext() {
            return {
                onVirtualScroll: this.onScroll,
                bodyHeight: this.computeBodyHeight(),
                innerTop: this.computeInnerTop(),
                getBodyNode: this.getBodyNode,
                getTableInstanceForVirtual: this.getTableInstance,
                rowSelection: this.rowSelection
            };
        };

        VirtualTable.prototype.componentWillMount = function componentWillMount() {
            var _props = this.props,
                useVirtual = _props.useVirtual,
                dataSource = _props.dataSource;


            this.hasVirtualData = useVirtual && dataSource && dataSource.length > 0;
        };

        VirtualTable.prototype.componentDidMount = function componentDidMount() {

            if (this.hasVirtualData) {
                this.lastScrollTop = this.bodyNode.scrollTop;
            }

            this.adjustScrollTop();
            this.adjustSize();
            this.reComputeSize();
        };

        VirtualTable.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
            var useVirtual = nextProps.useVirtual,
                dataSource = nextProps.dataSource;


            this.hasVirtualData = useVirtual && dataSource && dataSource.length > 0;

            if ('maxBodyHeight' in nextProps) {
                if (this.state.height !== nextProps.maxBodyHeight) {
                    this.setState({
                        height: nextProps.maxBodyHeight
                    });
                }
            }

            if ('scrollToRow' in nextProps) {
                this.setState({
                    scrollToRow: nextProps.scrollToRow
                });
            }

            if (this.state.rowHeight && 'rowHeight' in nextProps) {
                var row = this.getRowNode();
                var rowClientHeight = row && row.clientHeight;
                if (rowClientHeight && rowClientHeight !== this.state.rowHeight) {
                    this.setState({
                        rowHeight: rowClientHeight
                    });
                }
            }
        };

        VirtualTable.prototype.componentDidUpdate = function componentDidUpdate() {
            this.adjustScrollTop();
            this.adjustSize();
            this.reComputeSize();
        };

        VirtualTable.prototype.reComputeSize = function reComputeSize() {
            var rowHeight = this.state.rowHeight;

            if (typeof rowHeight === 'function' && this.hasVirtualData) {
                var row = this.getRowNode();
                var rowClientHeight = row && row.clientHeight;
                if (rowClientHeight !== this.state.rowHeight) {
                    this.setState({
                        rowHeight: rowClientHeight
                    });
                }
            }
        };

        VirtualTable.prototype.computeBodyHeight = function computeBodyHeight() {
            var rowHeight = this.state.rowHeight;
            var dataSource = this.props.dataSource;

            if (typeof rowHeight === 'function') {
                return 0;
            }
            return dataSource.length * rowHeight;
        };

        VirtualTable.prototype.computeInnerTop = function computeInnerTop() {
            var rowHeight = this.state.rowHeight;

            if (typeof rowHeight === 'function') {
                return 0;
            }
            return this.start * rowHeight;
        };

        VirtualTable.prototype.getVisibleRange = function getVisibleRange(ExpectStart) {
            var _state = this.state,
                height = _state.height,
                rowHeight = _state.rowHeight;

            var len = this.props.dataSource.length;

            var end = void 0,
                visibleCount = 0;
            var start = 0;
            if (typeof rowHeight === 'function') {
                // try get cell height;
                end = 1;
            } else {
                visibleCount = parseInt(height / rowHeight, 10);

                if ('number' === typeof ExpectStart) {
                    start = ExpectStart < len ? ExpectStart : 0;
                }

                end = Math.min(+start + 1 + visibleCount + 10, len);
            }
            this.end = end;
            this.visibleCount = visibleCount;
            return {
                start: start,
                end: end
            };
        };

        VirtualTable.prototype.adjustScrollTop = function adjustScrollTop() {
            if (this.hasVirtualData) {
                this.bodyNode.scrollTop = this.lastScrollTop % this.state.rowHeight + this.state.rowHeight * this.state.scrollToRow;
            }
        };

        VirtualTable.prototype.adjustSize = function adjustSize() {
            if (this.hasVirtualData) {
                var body = this.bodyNode;
                var virtualScrollNode = body.querySelector('div');
                var clientHeight = body.clientHeight,
                    clientWidth = body.clientWidth;


                var tableInc = this.tableInc;
                var tableNode = (0, _reactDom.findDOMNode)(tableInc);
                var prefix = this.props.prefix;

                var headerNode = tableNode.querySelector('.' + prefix + 'table-header table');
                var headerClientWidth = headerNode && headerNode.clientWidth;

                if (clientWidth < headerClientWidth) {
                    _util.dom.setStyle(virtualScrollNode, 'min-width', headerClientWidth);
                    var leftNode = this.bodyLeftNode;
                    var rightNode = this.bodyRightNode;
                    leftNode && _util.dom.setStyle(leftNode, 'max-height', clientHeight);
                    rightNode && _util.dom.setStyle(rightNode, 'max-height', clientHeight);
                    this.hasScrollbar = true;
                } else {
                    this.hasScrollbar = false;
                }
            }
        };

        VirtualTable.prototype.computeScrollToRow = function computeScrollToRow(offset) {
            var rowHeight = this.state.rowHeight;

            var start = parseInt(offset / rowHeight);
            this.start = start;
            return start;
        };

        VirtualTable.prototype.getRowNode = function getRowNode() {
            try {
                // in case of finding an unmounted component due to cached data
                // need to clear refs of this.tableInc when dataSource Changed
                // use try catch for temporary
                return (0, _reactDom.findDOMNode)(this.tableInc.getRowRef(0));
            } catch (error) {
                return null;
            }
        };

        VirtualTable.prototype.render = function render() {
            /* eslint-disable no-unused-vars, prefer-const */
            var _props2 = this.props,
                useVirtual = _props2.useVirtual,
                components = _props2.components,
                dataSource = _props2.dataSource,
                fixedHeader = _props2.fixedHeader,
                rowHeight = _props2.rowHeight,
                scrollToRow = _props2.scrollToRow,
                onBodyScroll = _props2.onBodyScroll,
                others = _objectWithoutProperties(_props2, ['useVirtual', 'components', 'dataSource', 'fixedHeader', 'rowHeight', 'scrollToRow', 'onBodyScroll']);

            var entireDataSource = dataSource;

            this.rowSelection = this.props.rowSelection;
            if (this.hasVirtualData) {
                components = _extends({}, components);

                var _getVisibleRange = this.getVisibleRange(this.state.scrollToRow),
                    start = _getVisibleRange.start,
                    end = _getVisibleRange.end;

                dataSource = dataSource.slice(start, end);

                if (!components.Body) {
                    components.Body = _body2.default;
                }
                fixedHeader = true;
            }

            return _react2.default.createElement(BaseComponent, _extends({}, others, { dataSource: dataSource, entireDataSource: entireDataSource, components: components, fixedHeader: fixedHeader }));
        };

        return VirtualTable;
    }(_react2.default.Component), _class.VirtualBody = _body2.default, _class.propTypes = _extends({
        /**
         * 是否开启虚拟滚动
         */
        useVirtual: _propTypes2.default.bool,
        /**
         * 设置行高
         */
        rowHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.func]),
        maxBodyHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
        primaryKey: _propTypes2.default.string,
        dataSource: _propTypes2.default.array,
        /**
         * 在内容区域滚动的时候触发的函数
         */
        onBodyScroll: _propTypes2.default.func
    }, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps, {
        primaryKey: 'id',
        rowHeight: noop,
        maxBodyHeight: 200,
        components: {},
        prefix: 'next-',
        onBodyScroll: noop
    }), _class.childContextTypes = {
        onVirtualScroll: _propTypes2.default.func,
        bodyHeight: _propTypes2.default.number,
        innerTop: _propTypes2.default.number,
        getBodyNode: _propTypes2.default.func,
        getTableInstanceForVirtual: _propTypes2.default.func,
        rowSelection: _propTypes2.default.object
    }, _temp2);
    VirtualTable.displayName = 'VirtualTable';

    (0, _util2.statics)(VirtualTable, BaseComponent);
    return VirtualTable;
}
module.exports = exports['default'];

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _body = __webpack_require__(16);

var _body2 = _interopRequireDefault(_body);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var VirtualBody = (_temp2 = _class = function (_React$Component) {
    _inherits(VirtualBody, _React$Component);

    function VirtualBody() {
        var _temp, _this, _ret;

        _classCallCheck(this, VirtualBody);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.tableRef = function (table) {
            _this.tableNode = table;
        }, _this.virtualScrollRef = function (virtualScroll) {
            _this.virtualScrollNode = virtualScroll;
        }, _this.onScroll = function () {
            // for fixed
            _this.context.onBodyScroll();
            // for lock
            _this.context.onLockBodyScroll();
            // for virtual
            _this.context.onVirtualScroll();
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    VirtualBody.prototype.componentDidMount = function componentDidMount() {
        var bodyNode = (0, _reactDom.findDOMNode)(this);
        // // for fixed
        this.context.getNode('body', bodyNode);
        // for virtual
        this.context.getBodyNode(bodyNode, this.context.lockType);
        // for lock
        this.context.getLockNode('body', bodyNode, this.context.lockType);
    };

    VirtualBody.prototype.render = function render() {
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            colGroup = _props.colGroup,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'colGroup']);

        var _context = this.context,
            maxBodyHeight = _context.maxBodyHeight,
            bodyHeight = _context.bodyHeight,
            innerTop = _context.innerTop;

        return _react2.default.createElement(
            'div',
            { style: { maxHeight: maxBodyHeight }, className: className, onScroll: this.onScroll },
            _react2.default.createElement(
                'div',
                { style: { height: bodyHeight, overflow: 'hidden', position: 'relative' }, ref: this.virtualScrollRef },
                _react2.default.createElement(
                    'div',
                    { style: { height: '100%', position: 'relative', transform: 'translateY(' + innerTop + 'px)' } },
                    _react2.default.createElement(
                        'table',
                        { ref: this.tableRef },
                        colGroup,
                        _react2.default.createElement(_body2.default, _extends({}, others, { prefix: prefix }))
                    )
                )
            )
        );
    };

    return VirtualBody;
}(_react2.default.Component), _class.propTypes = {
    children: _propTypes2.default.any,
    prefix: _propTypes2.default.string,
    className: _propTypes2.default.string,
    colGroup: _propTypes2.default.any
}, _class.contextTypes = {
    maxBodyHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    onBodyScroll: _propTypes2.default.func,
    onVirtualScroll: _propTypes2.default.func,
    onLockBodyScroll: _propTypes2.default.func,
    bodyHeight: _propTypes2.default.number,
    innerTop: _propTypes2.default.number,
    getNode: _propTypes2.default.func,
    getBodyNode: _propTypes2.default.func,
    getLockNode: _propTypes2.default.func,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}, _temp2);
VirtualBody.displayName = 'VirtualBody';
exports.default = VirtualBody;
module.exports = exports['default'];

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = lock;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _shallowElementEquals = __webpack_require__(44);

var _shallowElementEquals2 = _interopRequireDefault(_shallowElementEquals);

var _util = __webpack_require__(2);

var _row = __webpack_require__(66);

var _row2 = _interopRequireDefault(_row);

var _body = __webpack_require__(132);

var _body2 = _interopRequireDefault(_body);

var _header = __webpack_require__(133);

var _header2 = _interopRequireDefault(_header);

var _wrapper = __webpack_require__(24);

var _wrapper2 = _interopRequireDefault(_wrapper);

var _util2 = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function lock(BaseComponent) {
    var _class, _temp;

    /** Table */
    var LockTable = (_temp = _class = function (_React$Component) {
        _inherits(LockTable, _React$Component);

        function LockTable(props, context) {
            _classCallCheck(this, LockTable);

            var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

            _this.getTableInstance = function (type, instance) {
                type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';
                _this['table' + type + 'Inc'] = instance;
            };

            _this.getNode = function (type, node, lockType) {
                lockType = lockType ? lockType.charAt(0).toUpperCase() + lockType.substr(1) : '';
                _this['' + type + lockType + 'Node'] = node;
                if (type === 'header' && !_this.innerHeaderNode && !lockType) {
                    _this.innerHeaderNode = _this.headerNode.querySelector('div');
                }
            };

            _this.onRowMouseEnter = function (record, index) {
                if (_this.isLock()) {
                    var row = _this.getRowNode(index);
                    var leftRow = _this.getRowNode(index, 'left');
                    var rightRow = _this.getRowNode(index, 'right');
                    [row, leftRow, rightRow].forEach(function (row) {
                        row && _util.dom.addClass(row, 'hovered');
                    });
                }
            };

            _this.onRowMouseLeave = function (record, index) {
                if (_this.isLock()) {
                    var row = _this.getRowNode(index);
                    var leftRow = _this.getRowNode(index, 'left');
                    var rightRow = _this.getRowNode(index, 'right');
                    [row, leftRow, rightRow].forEach(function (row) {
                        row && _util.dom.removeClass(row, 'hovered');
                    });
                }
            };

            _this.onLockBodyWheel = function (e) {
                var y = e.deltaY;
                if (_this.isLock()) {
                    var lockRightBody = _this.bodyRightNode,
                        lockLeftBody = _this.bodyLeftNode,
                        scrollNode = _this.bodyNode,
                        scrollTop = scrollNode.scrollTop,
                        clientHeight = scrollNode.clientHeight,
                        scrollHeight = scrollNode.scrollHeight;


                    if (lockLeftBody) {
                        lockLeftBody.scrollTop = y;
                    }
                    if (lockRightBody) {
                        lockRightBody.scrollTop = y;
                    }
                    scrollNode.scrollTop = scrollTop + y;
                    var newScrollTop = scrollNode.scrollTop;

                    if (newScrollTop + clientHeight < scrollHeight && newScrollTop) {
                        e.preventDefault();
                    }
                }
            };

            _this.onLockBodyScroll = function () {
                if (_this.isLock()) {
                    var lockRightBody = _this.bodyRightNode,
                        lockLeftBody = _this.bodyLeftNode,
                        lockRightTable = _this.getWrapperNode('right'),
                        lockLeftTable = _this.getWrapperNode('left'),
                        shadowClassName = 'shadow';

                    var x = _this.bodyNode.scrollLeft,
                        y = _this.bodyNode.scrollTop;

                    if (lockLeftBody) {
                        lockLeftBody.scrollTop = y;
                    }
                    if (lockRightBody) {
                        lockRightBody.scrollTop = y;
                    }
                    if (x === 0) {
                        lockLeftTable && _util.dom.removeClass(lockLeftTable, shadowClassName);
                        lockRightTable && _util.dom.addClass(lockRightTable, shadowClassName);
                    } else if (x === _this.bodyNode.scrollWidth - _this.bodyNode.clientWidth) {
                        lockLeftTable && _util.dom.addClass(lockLeftTable, shadowClassName);
                        lockRightTable && _util.dom.removeClass(lockRightTable, shadowClassName);
                    } else {
                        lockLeftTable && _util.dom.addClass(lockLeftTable, shadowClassName);
                        lockRightTable && _util.dom.addClass(lockRightTable, shadowClassName);
                    }
                }
            };

            _this.lockLeftChildren = [];
            _this.lockRightChildren = [];
            return _this;
        }

        LockTable.prototype.getChildContext = function getChildContext() {
            return {
                getTableInstance: this.getTableInstance,
                getLockNode: this.getNode,
                onLockBodyWheel: this.onLockBodyWheel,
                onLockBodyScroll: this.onLockBodyScroll,
                onRowMouseEnter: this.onRowMouseEnter,
                onRowMouseLeave: this.onRowMouseLeave
            };
        };

        LockTable.prototype.componentDidMount = function componentDidMount() {
            this.adjustSize = this.adjustSize.bind(this);

            this.adjustSize();
            this.scroll();

            _util.events.on(window, 'resize', this.adjustSize);
        };

        LockTable.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState, nextContext) {
            if (nextProps.pure) {
                var isEqual = (0, _shallowElementEquals2.default)(nextProps, this.props);
                return !(isEqual && _util.obj.shallowEqual(nextContext, this.context));
            }

            return true;
        };

        LockTable.prototype.componentWillUpdate = function componentWillUpdate() {
            this._isLock = false;
        };

        LockTable.prototype.componentDidUpdate = function componentDidUpdate() {
            this.adjustSize();
        };

        LockTable.prototype.componentWillUnmount = function componentWillUnmount() {
            _util.events.off(window, 'resize', this.adjustSize);
        };

        LockTable.prototype.normalizeChildrenState = function normalizeChildrenState(props) {
            var children = props.children;

            children = this.normalizeChildren(children);
            var splitChildren = this.splitFromNormalizeChildren(children);
            var lockLeftChildren = splitChildren.lockLeftChildren,
                lockRightChildren = splitChildren.lockRightChildren;

            return {
                lockLeftChildren: lockLeftChildren,
                lockRightChildren: lockRightChildren,
                children: this.mergeFromSplitLockChildren(splitChildren)
            };
        };

        // 将React结构化数据提取props转换成数组


        LockTable.prototype.normalizeChildren = function normalizeChildren(children) {
            var isLock = false;
            var getChildren = function getChildren(children) {
                var ret = [];
                _react.Children.forEach(children, function (child) {
                    if (child) {
                        var props = _extends({}, child.props);
                        if ([true, 'left', 'right'].indexOf(props.lock) > -1) {
                            isLock = true;
                            if (!('width' in props)) {
                                _util.log.warning('Should config width for lock column named [ ' + props.dataIndex + ' ].');
                            }
                        }
                        ret.push(props);
                        if (child.props.children) {
                            props.children = getChildren(child.props.children);
                        }
                    }
                });
                return ret;
            };
            var ret = getChildren(children);
            ret.forEach(function (child) {
                // 为自定义的列特殊处理
                if (child.__normalized && isLock) {
                    child.lock = 'left';
                    delete child.__normalized;
                }
            });
            this._isLock = isLock;
            return ret;
        };

        //从数组中分离出lock的列和正常的列


        LockTable.prototype.splitFromNormalizeChildren = function splitFromNormalizeChildren(children) {
            var originChildren = deepCopy(children);
            var lockLeftChildren = deepCopy(children);
            var lockRightChildren = deepCopy(children);
            var loop = function loop(lockChildren, condition) {
                var ret = [];
                lockChildren.forEach(function (child) {
                    if (child.children) {
                        var res = loop(child.children, condition);
                        if (!res.length) {
                            ret.push(child);
                        }
                    } else {
                        var order = condition(child);
                        if (!order) {
                            ret.push(child);
                        }
                    }
                });
                ret.forEach(function (res) {
                    var index = lockChildren.indexOf(res);
                    lockChildren.splice(index, 1);
                });
                return lockChildren;
            };
            loop(lockLeftChildren, function (child) {
                if (child.lock === true || child.lock === 'left') {
                    return 'left';
                }
            });
            loop(lockRightChildren, function (child) {
                if (child.lock === 'right') {
                    return 'right';
                }
            });
            loop(originChildren, function (child) {
                return child.lock !== true && child.lock !== 'left' && child.lock !== 'right';
            });
            return {
                lockLeftChildren: lockLeftChildren,
                lockRightChildren: lockRightChildren,
                originChildren: originChildren
            };
        };

        //将左侧的锁列树和中间的普通树及右侧的锁列树进行合并


        LockTable.prototype.mergeFromSplitLockChildren = function mergeFromSplitLockChildren(splitChildren) {
            var lockLeftChildren = splitChildren.lockLeftChildren,
                lockRightChildren = splitChildren.lockRightChildren;
            var originChildren = splitChildren.originChildren;

            Array.prototype.unshift.apply(originChildren, lockLeftChildren);
            originChildren = originChildren.concat(lockRightChildren);
            return originChildren;
        };

        LockTable.prototype.scroll = function scroll() {
            var _props = this.props,
                _props$scrollToCol = _props.scrollToCol,
                scrollToCol = _props$scrollToCol === undefined ? 0 : _props$scrollToCol,
                _props$scrollToRow = _props.scrollToRow,
                scrollToRow = _props$scrollToRow === undefined ? 0 : _props$scrollToRow;

            if (!scrollToCol && !scrollToRow) {
                return;
            }
            var colCellNode = this.getCellNode(0, scrollToCol);
            var rowCellNode = this.getCellNode(scrollToRow, 0);
            var bodyNodeOffset = this.bodyNode.getBoundingClientRect();
            if (colCellNode) {
                var cellNodeoffset = colCellNode.getBoundingClientRect();
                var scrollLeft = cellNodeoffset.left - bodyNodeOffset.left;
                this.bodyNode.scrollLeft = scrollLeft;
            }
            if (rowCellNode) {
                var _cellNodeoffset = rowCellNode.getBoundingClientRect();
                var scrollTop = _cellNodeoffset.top - bodyNodeOffset.top;
                this.bodyNode.scrollTop = scrollTop;
            }
        };

        // Table处理过后真实的lock状态
        LockTable.prototype.isLock = function isLock() {
            return this.lockLeftChildren.length || this.lockRightChildren.length;
        };

        // 用户设置的lock状态


        LockTable.prototype.isOriginLock = function isOriginLock() {
            return this._isLock;
        };

        LockTable.prototype.adjustSize = function adjustSize() {
            if (!this.adjustIfTableNotNeedLock()) {
                this.adjustHeaderSize();
                this.adjustBodySize();
                this.adjustCellSize();
                this.onLockBodyScroll();
            }
        };

        LockTable.prototype.adjustIfTableNotNeedLock = function adjustIfTableNotNeedLock() {
            var _this2 = this;

            if (this.isOriginLock() && this.tableInc.props.dataSource.length) {
                var configWidths = this.tableInc.flatChildren.map(function (item, index) {
                    var row = _this2.getCellNode(0, index);
                    return row && row.clientWidth || 0;
                }).reduce(function (a, b) {
                    return a + b;
                }, 0);

                var node = (0, _reactDom.findDOMNode)(this);
                var width = node.clientWidth;
                var lockLeftLen = this.lockLeftChildren.length;
                var lockRightLen = this.lockRightChildren.length;

                if (configWidths <= width && configWidths > 0) {
                    if (lockLeftLen) {
                        this._notNeedAdjustLockLeft = true;
                    }
                    if (lockRightLen) {
                        this._notNeedAdjustLockRight = true;
                    }
                    if (lockRightLen || lockLeftLen) {
                        this.forceUpdate();
                        return true;
                    }
                } else if (this._notNeedAdjustLockLeft || this._notNeedAdjustLockRight) {
                    this._notNeedAdjustLockLeft = this._notNeedAdjustLockRight = false;
                    this.forceUpdate();
                } else {
                    this._notNeedAdjustLockLeft = this._notNeedAdjustLockRight = false;
                    return false;
                }
            }

            return false;
        };

        LockTable.prototype.adjustBodySize = function adjustBodySize() {
            if (this.isLock()) {
                var body = this.bodyNode,
                    lockLeftBody = this.bodyLeftNode,
                    lockRightBody = this.bodyRightNode,
                    lockRightBodyWrapper = this.getWrapperNode('right'),
                    scrollbar = _util.dom.scrollbar(),
                    bodyHeight = body.offsetHeight,
                    hasHozScroll = body.scrollWidth > body.clientWidth,
                    hasVerScroll = body.scrollHeight > body.clientHeight,
                    width = hasVerScroll ? scrollbar.width : 0,
                    lockBodyHeight = bodyHeight - (hasHozScroll ? scrollbar.height : 0);

                lockLeftBody && _util.dom.setStyle(lockLeftBody, 'max-height', lockBodyHeight);
                lockRightBody && _util.dom.setStyle(lockRightBody, 'max-height', lockBodyHeight);
                lockRightBodyWrapper && _util.dom.setStyle(lockRightBodyWrapper, 'right', width);
            }
        };

        LockTable.prototype.adjustHeaderSize = function adjustHeaderSize() {
            var _this3 = this;

            if (this.isLock()) {
                this.tableInc.groupChildren.forEach(function (child, index) {
                    var lastIndex = _this3.tableInc.groupChildren[index].length - 1;
                    var headerRightRow = _this3.getHeaderCellNode(index, lastIndex),
                        headerLeftRow = _this3.getHeaderCellNode(index, 0),
                        headerRightLockRow = _this3.getHeaderCellNode(index, 0, 'right'),
                        headerLeftLockRow = _this3.getHeaderCellNode(index, 0, 'left');

                    if (headerRightRow && headerRightLockRow) {
                        var maxRightRowHeight = headerRightRow.offsetHeight;

                        _util.dom.setStyle(headerRightLockRow, 'height', maxRightRowHeight);

                        setTimeout(function () {
                            _this3.tableRightInc.affixRef && _this3.tableRightInc.affixRef.getInstance().updatePosition();
                        });
                    }

                    if (headerLeftRow && headerLeftLockRow) {
                        var maxLeftRowHeight = headerLeftRow.offsetHeight;

                        _util.dom.setStyle(headerLeftLockRow, 'height', maxLeftRowHeight);

                        setTimeout(function () {
                            _this3.tableLeftInc.affixRef && _this3.tableLeftInc.affixRef.getInstance().updatePosition();
                        });
                    }
                });
            }
        };

        LockTable.prototype.adjustCellSize = function adjustCellSize() {
            var _this4 = this;

            if (this.isLock()) {
                this.tableInc.props.dataSource.forEach(function (item, index) {
                    var lockLeftRow = _this4.getCellNode(index, 0, 'left'),
                        lockRightRow = _this4.getCellNode(index, 0, 'right'),
                        row = _this4.getFirstNormalCellNode(index),
                        rowHeight = row && parseFloat(getComputedStyle(row).height) || 0;
                    var lockLeftHeight = 0,
                        lockRightHeight = 0;

                    if (lockLeftRow) {
                        lockLeftHeight = lockLeftRow.offsetHeight;
                    }
                    if (lockRightRow) {
                        lockRightHeight = lockRightRow.offsetHeight;
                    }
                    if (lockLeftRow && rowHeight !== lockLeftHeight) {
                        _util.dom.setStyle(lockLeftRow, 'height', rowHeight);
                    }
                    if (lockRightRow && rowHeight !== lockRightHeight) {
                        _util.dom.setStyle(lockRightRow, 'height', rowHeight);
                    }
                });
            }
        };

        LockTable.prototype.getWrapperNode = function getWrapperNode(type) {
            type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';
            try {
                // in case of finding an unmounted component due to cached data
                // need to clear refs of table when dataSource Changed
                // use try catch for temporary
                return (0, _reactDom.findDOMNode)(this.refs['lock' + type]);
            } catch (error) {
                return null;
            }
        };

        LockTable.prototype.getFirstNormalCellNode = function getFirstNormalCellNode(index) {
            var i = 0;
            var row = void 0;
            do {
                row = this.getCellNode(index, i);
                i++;
            } while ((!row || row && row.rowSpan && row.rowSpan > 1) && this.tableInc.flatChildren.length > i);

            return row;
        };

        LockTable.prototype.getRowNode = function getRowNode(index, type) {
            type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';
            var table = this['table' + type + 'Inc'];

            try {
                // in case of finding an unmounted component due to cached data
                // need to clear refs of table when dataSource Changed
                // use try catch for temporary
                return (0, _reactDom.findDOMNode)(table.getRowRef(index));
            } catch (error) {
                return null;
            }
        };

        LockTable.prototype.getHeaderCellNode = function getHeaderCellNode(index, i, type) {
            type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';
            var table = this['table' + type + 'Inc'];

            try {
                // in case of finding an unmounted component due to cached data
                // need to clear refs of table when dataSource Changed
                // use try catch for temporary
                return (0, _reactDom.findDOMNode)(table.getHeaderCellRef(index, i));
            } catch (error) {
                return null;
            }
        };

        LockTable.prototype.getCellNode = function getCellNode(index, i, type) {
            type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';
            var table = this['table' + type + 'Inc'];

            try {
                // in case of finding an unmounted component due to cached data
                // need to clear refs of table when dataSource Changed
                // use try catch for temporary
                return (0, _reactDom.findDOMNode)(table.getCellRef(index, i));
            } catch (error) {
                return null;
            }
        };

        LockTable.prototype.render = function render() {
            /* eslint-disable no-unused-vars, prefer-const */
            var _props2 = this.props,
                children = _props2.children,
                prefix = _props2.prefix,
                components = _props2.components,
                className = _props2.className,
                others = _objectWithoutProperties(_props2, ['children', 'prefix', 'components', 'className']);

            var _normalizeChildrenSta = this.normalizeChildrenState(this.props),
                lockLeftChildren = _normalizeChildrenSta.lockLeftChildren,
                lockRightChildren = _normalizeChildrenSta.lockRightChildren,
                normalizedChildren = _normalizeChildrenSta.children;

            if (this._notNeedAdjustLockLeft) {
                lockLeftChildren = [];
            }
            if (this._notNeedAdjustLockRight) {
                lockRightChildren = [];
            }
            this.lockLeftChildren = lockLeftChildren;
            this.lockRightChildren = lockRightChildren;

            if (this.isOriginLock()) {
                var _classnames;

                components = _extends({}, components);
                components.Body = components.Body || _body2.default;
                components.Header = components.Header || _header2.default;
                components.Wrapper = components.Wrapper || _wrapper2.default;
                components.Row = components.Row || _row2.default;
                className = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-lock'] = true, _classnames[className] = className, _classnames));
                var content = [_react2.default.createElement(BaseComponent, _extends({}, others, { key: 'lock-left', columns: lockLeftChildren, className: prefix + 'table-lock-left', prefix: prefix, lockType: 'left', components: components, ref: 'lockLeft', loading: false })), _react2.default.createElement(BaseComponent, _extends({}, others, { key: 'lock-right', columns: lockRightChildren, className: prefix + 'table-lock-right', prefix: prefix, lockType: 'right', components: components, ref: 'lockRight', loading: false }))];
                return _react2.default.createElement(BaseComponent, _extends({}, others, { columns: normalizedChildren, prefix: prefix, wrapperContent: content, components: components, className: className }));
            }
            return _react2.default.createElement(BaseComponent, this.props);
        };

        return LockTable;
    }(_react2.default.Component), _class.LockRow = _row2.default, _class.LockBody = _body2.default, _class.LockHeader = _header2.default, _class.propTypes = _extends({
        scrollToCol: _propTypes2.default.number,
        /**
         * 指定滚动到某一行，仅在`useVirtual`的时候生效
         */
        scrollToRow: _propTypes2.default.number
    }, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps), _class.childContextTypes = {
        getTableInstance: _propTypes2.default.func,
        getLockNode: _propTypes2.default.func,
        onLockBodyScroll: _propTypes2.default.func,
        onLockBodyWheel: _propTypes2.default.func,
        onRowMouseEnter: _propTypes2.default.func,
        onRowMouseLeave: _propTypes2.default.func
    }, _temp);
    LockTable.displayName = 'LockTable';

    (0, _util2.statics)(LockTable, BaseComponent);
    return LockTable;
}

function deepCopy(arr) {
    var copy = function copy(arr) {
        return arr.map(function (item) {
            var newItem = _extends({}, item);
            if (item.children) {
                item.children = copy(item.children);
            }
            return newItem;
        });
    };
    return copy(arr);
}
module.exports = exports['default'];

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _body = __webpack_require__(67);

var _body2 = _interopRequireDefault(_body);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function */
var LockBody = (_temp2 = _class = function (_React$Component) {
    _inherits(LockBody, _React$Component);

    function LockBody() {
        var _temp, _this, _ret;

        _classCallCheck(this, LockBody);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onBodyScroll = function () {
            _this.context.onLockBodyScroll();
        }, _this.onBodyWheel = function (e) {
            _this.context.onLockBodyWheel(e);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    LockBody.prototype.componentDidMount = function componentDidMount() {
        this.context.getLockNode('body', (0, _reactDom.findDOMNode)(this), this.context.lockType);
    };

    LockBody.prototype.render = function render() {
        return _react2.default.createElement(_body2.default, _extends({}, this.props, { onScroll: this.onBodyScroll, onWheel: this.onBodyWheel }));
    };

    return LockBody;
}(_react2.default.Component), _class.propTypes = _extends({}, _body2.default.propTypes), _class.contextTypes = _extends({}, _body2.default.contextTypes, {
    getLockNode: _propTypes2.default.func,
    onLockBodyScroll: _propTypes2.default.func,
    onLockBodyWheel: _propTypes2.default.func,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}), _temp2);
LockBody.displayName = 'LockBody';
exports.default = LockBody;
module.exports = exports['default'];

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _reactDom = __webpack_require__(4);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _header = __webpack_require__(19);

var _header2 = _interopRequireDefault(_header);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var LockHeader = (_temp = _class = function (_FixedHeader) {
    _inherits(LockHeader, _FixedHeader);

    function LockHeader() {
        _classCallCheck(this, LockHeader);

        return _possibleConstructorReturn(this, _FixedHeader.apply(this, arguments));
    }

    LockHeader.prototype.componentDidMount = function componentDidMount() {
        var _context = this.context,
            getNode = _context.getNode,
            getLockNode = _context.getLockNode;

        getNode && getNode('header', (0, _reactDom.findDOMNode)(this), this.context.lockType);
        getLockNode && getLockNode('header', (0, _reactDom.findDOMNode)(this), this.context.lockType);
    };

    return LockHeader;
}(_header2.default), _class.propTypes = _extends({}, _header2.default.propTypes), _class.contextTypes = _extends({}, _header2.default.contextTypes, {
    getLockNode: _propTypes2.default.func,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}), _temp);
exports.default = LockHeader;
module.exports = exports['default'];

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = list;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _listHeader = __webpack_require__(68);

var _listHeader2 = _interopRequireDefault(_listHeader);

var _listFooter = __webpack_require__(69);

var _listFooter2 = _interopRequireDefault(_listFooter);

var _row = __webpack_require__(135);

var _row2 = _interopRequireDefault(_row);

var _body = __webpack_require__(136);

var _body2 = _interopRequireDefault(_body);

var _header = __webpack_require__(19);

var _header2 = _interopRequireDefault(_header);

var _wrapper = __webpack_require__(24);

var _wrapper2 = _interopRequireDefault(_wrapper);

var _util = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function list(BaseComponent) {
    var _class, _temp;

    var ListTable = (_temp = _class = function (_React$Component) {
        _inherits(ListTable, _React$Component);

        function ListTable() {
            _classCallCheck(this, ListTable);

            return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
        }

        ListTable.prototype.getChildContext = function getChildContext() {
            return {
                listHeader: this.listHeader,
                listFooter: this.listFooter,
                rowSelection: this.rowSelection
            };
        };

        ListTable.prototype.normalizeDataSource = function normalizeDataSource(dataSource) {
            var ret = [];
            var loop = function loop(dataSource, level) {
                dataSource.forEach(function (item) {
                    item.__level = level;
                    ret.push(item);
                    if (item.children) {
                        loop(item.children, level + 1);
                    }
                });
            };
            loop(dataSource, 0);
            this.ds = ret;
            return ret;
        };

        ListTable.prototype.render = function render() {
            var _this2 = this;

            /* eslint-disable prefer-const */
            var _props = this.props,
                components = _props.components,
                children = _props.children,
                className = _props.className,
                prefix = _props.prefix,
                others = _objectWithoutProperties(_props, ['components', 'children', 'className', 'prefix']);

            var isList = false,
                ret = [];
            _react.Children.forEach(children, function (child) {
                if (child) {
                    if (typeof child.type === 'function') {
                        if (child.type._typeMark === 'listHeader') {
                            _this2.listHeader = child.props;
                            isList = true;
                        } else if (child.type._typeMark === 'listFooter') {
                            _this2.listFooter = child.props;
                        } else {
                            ret.push(child);
                        }
                    } else {
                        ret.push(child);
                    }
                }
            });
            this.rowSelection = this.props.rowSelection;
            if (isList) {
                var _classnames;

                components = _extends({}, components);
                components.Row = components.Row || _row2.default;
                components.Body = components.Body || _body2.default;
                components.Header = components.Header || _header2.default;
                components.Wrapper = components.Wrapper || _wrapper2.default;
                className = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-group'] = true, _classnames[className] = className, _classnames));
            }
            return _react2.default.createElement(BaseComponent, _extends({}, others, { components: components, children: ret, className: className, prefix: prefix }));
        };

        return ListTable;
    }(_react2.default.Component), _class.ListHeader = _listHeader2.default, _class.ListFooter = _listFooter2.default, _class.ListRow = _row2.default, _class.ListBody = _body2.default, _class.propTypes = _extends({}, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps), _class.childContextTypes = {
        listHeader: _propTypes2.default.any,
        listFooter: _propTypes2.default.any,
        rowSelection: _propTypes2.default.object
    }, _temp);
    ListTable.displayName = 'ListTable';

    (0, _util.statics)(ListTable, BaseComponent);
    return ListTable;
}
module.exports = exports['default'];

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _util = __webpack_require__(2);

var _row = __webpack_require__(17);

var _row2 = _interopRequireDefault(_row);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var GroupListRow = (_temp = _class = function (_Row) {
    _inherits(GroupListRow, _Row);

    function GroupListRow() {
        _classCallCheck(this, GroupListRow);

        return _possibleConstructorReturn(this, _Row.apply(this, arguments));
    }

    GroupListRow.prototype.render = function render() {
        var _classnames;

        /* eslint-disable no-unused-vars*/
        var _props = this.props,
            prefix = _props.prefix,
            className = _props.className,
            onClick = _props.onClick,
            onMouseEnter = _props.onMouseEnter,
            onMouseLeave = _props.onMouseLeave,
            columns = _props.columns,
            Cell = _props.Cell,
            rowIndex = _props.rowIndex,
            record = _props.record,
            children = _props.children,
            primaryKey = _props.primaryKey,
            colGroup = _props.colGroup,
            cellRef = _props.cellRef,
            getCellProps = _props.getCellProps,
            others = _objectWithoutProperties(_props, ['prefix', 'className', 'onClick', 'onMouseEnter', 'onMouseLeave', 'columns', 'Cell', 'rowIndex', 'record', 'children', 'primaryKey', 'colGroup', 'cellRef', 'getCellProps']);

        var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-row'] = true, _classnames[className] = className, _classnames));
        return _react2.default.createElement(
            'table',
            _extends({ className: cls, role: 'row' }, others, {
                onClick: this.onClick, onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave }),
            colGroup,
            _react2.default.createElement(
                'tbody',
                null,
                this.renderContent('header'),
                this.renderChildren(),
                this.renderContent('footer')
            )
        );
    };

    GroupListRow.prototype.isChildrenSelection = function isChildrenSelection() {
        return this.context.listHeader && this.context.listHeader.hasChildrenSelection;
    };

    GroupListRow.prototype.isSelection = function isSelection() {
        return this.context.listHeader && this.context.listHeader.hasSelection;
    };

    GroupListRow.prototype.renderChildren = function renderChildren() {
        var _this2 = this;

        var _props2 = this.props,
            record = _props2.record,
            primaryKey = _props2.primaryKey;
        var children = record.children;

        if (children) {
            return children.map(function (child, index) {
                var cells = _this2.renderCells(child);
                if (_this2.isChildrenSelection()) {
                    if (!child[primaryKey]) {
                        _util.log.warning('record.children should contains primaryKey when childrenSelection is true.');
                    }
                    return _react2.default.createElement(
                        'tr',
                        { key: child[primaryKey] },
                        cells
                    );
                }
                if (_this2.context.rowSelection) {
                    cells.shift();
                    cells[0] = _react2.default.cloneElement(cells[0], _extends({
                        colSpan: 2
                    }, cells[0].props));
                }
                return _react2.default.createElement(
                    'tr',
                    { key: index },
                    cells
                );
            });
        }
        return null;
    };

    GroupListRow.prototype.renderContent = function renderContent(type) {
        var _props3 = this.props,
            columns = _props3.columns,
            prefix = _props3.prefix,
            record = _props3.record,
            rowIndex = _props3.rowIndex;

        var cameType = type.charAt(0).toUpperCase() + type.substr(1);
        var list = this.context['list' + cameType];
        var listNode = void 0;
        if (list) {
            if (_react2.default.isValidElement(list.cell)) {
                listNode = _react2.default.cloneElement(list.cell, { record: record, index: rowIndex });
            } else if (typeof list.cell === 'function') {
                listNode = list.cell(record, rowIndex);
            }
            if (listNode) {
                var cells = this.renderCells(record);
                if (type === 'header' && this.context.rowSelection && this.isSelection()) {
                    cells = cells.slice(0, 1);
                    cells.push(_react2.default.createElement(
                        'td',
                        { colSpan: columns.length - 1, key: 'listNode' },
                        _react2.default.createElement(
                            'div',
                            { className: prefix + 'table-cell-wrapper' },
                            listNode
                        )
                    ));
                    listNode = _react2.default.createElement(
                        'tr',
                        { className: prefix + 'table-group-' + type },
                        cells
                    );
                } else {
                    listNode = _react2.default.createElement(
                        'tr',
                        { className: prefix + 'table-group-' + type },
                        _react2.default.createElement(
                            'td',
                            { colSpan: columns.length },
                            _react2.default.createElement(
                                'div',
                                { className: prefix + 'table-cell-wrapper' },
                                listNode
                            )
                        )
                    );
                }
            }
        }
        return listNode;
    };

    return GroupListRow;
}(_row2.default), _class.contextTypes = {
    listHeader: _propTypes2.default.any,
    listFooter: _propTypes2.default.any,
    rowSelection: _propTypes2.default.object,
    notRenderCellIndex: _propTypes2.default.array,
    lockType: _propTypes2.default.oneOf(['left', 'right'])
}, _temp);
exports.default = GroupListRow;
module.exports = exports['default'];

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = ListBody;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _body = __webpack_require__(16);

var _body2 = _interopRequireDefault(_body);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ListBody(props) {
    return _react2.default.createElement(_body2.default, _extends({ component: 'div' }, props));
}
module.exports = exports['default'];

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = sticky;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _header = __webpack_require__(19);

var _header2 = _interopRequireDefault(_header);

var _header3 = __webpack_require__(138);

var _header4 = _interopRequireDefault(_header3);

var _util = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function sticky(BaseComponent) {
    var _class, _temp;

    /** Table */
    var StickyTable = (_temp = _class = function (_React$Component) {
        _inherits(StickyTable, _React$Component);

        function StickyTable() {
            _classCallCheck(this, StickyTable);

            return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
        }

        StickyTable.prototype.getChildContext = function getChildContext() {
            return {
                Header: this.props.components.Header || _header2.default,
                offsetTop: this.props.offsetTop,
                affixProps: this.props.affixProps
            };
        };

        StickyTable.prototype.render = function render() {
            /* eslint-disable no-unused-vars */
            var _props = this.props,
                stickyHeader = _props.stickyHeader,
                offsetTop = _props.offsetTop,
                affixProps = _props.affixProps,
                others = _objectWithoutProperties(_props, ['stickyHeader', 'offsetTop', 'affixProps']);

            var _props2 = this.props,
                components = _props2.components,
                maxBodyHeight = _props2.maxBodyHeight,
                fixedHeader = _props2.fixedHeader;

            if (stickyHeader) {
                components = _extends({}, components);
                components.Header = _header4.default;
                fixedHeader = true;
                maxBodyHeight = Math.max(maxBodyHeight, 10000);
            }
            return _react2.default.createElement(BaseComponent, _extends({}, others, { components: components, fixedHeader: fixedHeader, maxBodyHeight: maxBodyHeight }));
        };

        return StickyTable;
    }(_react2.default.Component), _class.StickyHeader = _header4.default, _class.propTypes = _extends({
        /**
         * 表头是否是sticky
         */
        stickyHeader: _propTypes2.default.bool,
        /**
         * 距离窗口顶部达到指定偏移量后触发
         */
        offsetTop: _propTypes2.default.number,
        /**
         * affix组件的的属性
         */
        affixProps: _propTypes2.default.object,
        components: _propTypes2.default.object
    }, BaseComponent.propTypes), _class.defaultProps = _extends({
        components: {}
    }, BaseComponent.defaultProps), _class.childContextTypes = {
        Header: _propTypes2.default.any,
        offsetTop: _propTypes2.default.number,
        affixProps: _propTypes2.default.object
    }, _temp);
    StickyTable.displayName = 'StickyTable';

    (0, _util.statics)(StickyTable, BaseComponent);
    return StickyTable;
}
module.exports = exports['default'];

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp2;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _affix = __webpack_require__(139);

var _affix2 = _interopRequireDefault(_affix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable react/prefer-stateless-function*/
var StickHeader = (_temp2 = _class = function (_React$Component) {
    _inherits(StickHeader, _React$Component);

    function StickHeader() {
        var _temp, _this, _ret;

        _classCallCheck(this, StickHeader);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.getAffixRef = function (ref) {
            _this.props.affixRef && _this.props.affixRef(ref);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    StickHeader.prototype.render = function render() {
        var _classnames;

        var prefix = this.props.prefix;
        var _context = this.context,
            Header = _context.Header,
            offsetTop = _context.offsetTop,
            affixProps = _context.affixProps;


        var newAffixProps = affixProps || {};

        var className = newAffixProps.className,
            others = _objectWithoutProperties(newAffixProps, ['className']);

        var cls = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'table-affix'] = true, _classnames.className = className, _classnames));

        return _react2.default.createElement(
            _affix2.default,
            _extends({ ref: this.getAffixRef }, others, { className: cls, offsetTop: offsetTop }),
            _react2.default.createElement(Header, this.props)
        );
    };

    return StickHeader;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string
}, _class.contextTypes = {
    Header: _propTypes2.default.any,
    offsetTop: _propTypes2.default.number,
    affixProps: _propTypes2.default.object
}, _temp2);
StickHeader.displayName = 'StickHeader';
exports.default = StickHeader;
module.exports = exports['default'];

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__(4);

var _classnames2 = __webpack_require__(3);

var _classnames3 = _interopRequireDefault(_classnames2);

var _util = __webpack_require__(2);

var _configProvider = __webpack_require__(5);

var _configProvider2 = _interopRequireDefault(_configProvider);

var _util2 = __webpack_require__(140);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/** Affix */
var Affix = (_temp = _class = function (_React$Component) {
    _inherits(Affix, _React$Component);

    function Affix(props, context) {
        _classCallCheck(this, Affix);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

        _this.updatePosition = function () {
            _this._updateNodePosition();
        };

        _this._updateNodePosition = function () {
            var _this$props = _this.props,
                container = _this$props.container,
                useAbsolute = _this$props.useAbsolute;

            var affixContainer = container();

            if (!affixContainer) {
                return false;
            }
            var containerScrollTop = (0, _util2.getScroll)(affixContainer, true); // 容器在垂直位置上的滚动 offset
            var affixOffset = _this._getOffset(_this.affixNode, affixContainer); // 目标节点当前相对于容器的 offset
            var containerHeight = (0, _util2.getNodeHeight)(affixContainer); // 容器的高度
            var affixHeight = _this.affixNode.offsetHeight;
            var containerRect = (0, _util2.getRect)(affixContainer);

            var affixChildHeight = _this.affixChildNode.offsetHeight;

            var affixMode = _this.affixMode;
            var affixStyle = {
                width: affixOffset.width
            };
            var containerStyle = {
                width: affixOffset.width,
                height: affixChildHeight
            };

            if (affixMode.top && containerScrollTop > affixOffset.top - affixMode.offset) {
                // affix top
                if (useAbsolute) {
                    affixStyle.position = 'absolute';
                    affixStyle.top = containerScrollTop - (affixOffset.top - affixMode.offset);
                    containerStyle.position = 'relative';
                } else {
                    affixStyle.position = 'fixed';
                    affixStyle.top = affixMode.offset + containerRect.top;
                }
                _this._setAffixStyle(affixStyle, true);
                _this._setContainerStyle(containerStyle);
            } else if (affixMode.bottom && containerScrollTop < affixOffset.top + affixHeight + affixMode.offset - containerHeight) {
                // affix bottom
                affixStyle.height = affixHeight;
                if (useAbsolute) {
                    affixStyle.position = 'absolute';
                    affixStyle.top = containerScrollTop - (affixOffset.top + affixHeight + affixMode.offset - containerHeight);
                    containerStyle.position = 'relative';
                } else {
                    affixStyle.position = 'fixed';
                    affixStyle.bottom = affixMode.offset;
                }
                _this._setAffixStyle(affixStyle, true);
                _this._setContainerStyle(containerStyle);
            } else {
                _this._setAffixStyle(null);
                _this._setContainerStyle(null);
            }
        };

        _this._affixNodeRefHandler = function (ref) {
            _this.affixNode = (0, _reactDom.findDOMNode)(ref);
        };

        _this._affixChildNodeRefHandler = function (ref) {
            _this.affixChildNode = (0, _reactDom.findDOMNode)(ref);
        };

        _this.state = {
            style: null,
            containerStyle: null
        };
        _this.affixMode = _this._getAffixMode(props);
        return _this;
    }

    Affix.prototype.componentDidMount = function componentDidMount() {
        var _this2 = this;

        var container = this.props.container;

        this._updateNodePosition();
        // wait for parent rendered
        this.timeout = setTimeout(function () {
            _this2._setEventHandlerForContainer(container);
        });
    };

    Affix.prototype.componentWillUnmount = function componentWillUnmount() {
        if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
        var container = this.props.container;

        this._removeEventHandlerForContainer(container);
    };

    Affix.prototype._setEventHandlerForContainer = function _setEventHandlerForContainer(getContainer) {
        var container = getContainer();
        if (!container) {
            return;
        }
        _util.events.on(container, 'scroll', this._updateNodePosition, false);
        _util.events.on(container, 'resize', this._updateNodePosition, false);
    };

    Affix.prototype._removeEventHandlerForContainer = function _removeEventHandlerForContainer(getContainer) {
        var container = getContainer();
        if (container) {
            _util.events.off(container, 'scroll', this._updateNodePosition);
            _util.events.off(container, 'resize', this._updateNodePosition);
        }
    };

    Affix.prototype._getAffixMode = function _getAffixMode() {
        var _props = this.props,
            offsetTop = _props.offsetTop,
            offsetBottom = _props.offsetBottom;

        var affixMode = {
            top: false,
            bottom: false,
            offset: 0
        };

        if (typeof offsetTop !== 'number' && typeof offsetBottom !== 'number') {
            // set default
            affixMode.top = true;
        } else if (typeof offsetTop === 'number') {
            affixMode.top = true;
            affixMode.offset = offsetTop;
        } else if (typeof offsetBottom === 'number') {
            affixMode.bottom = true;
            affixMode.offset = offsetBottom;
        }

        return affixMode;
    };

    Affix.prototype._setAffixStyle = function _setAffixStyle(affixStyle) {
        var affixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (_util.obj.shallowEqual(affixStyle, this.state.style)) {
            return;
        }

        this.setState({
            style: affixStyle
        });

        var onAffix = this.props.onAffix;


        if (affixed) {
            onAffix(true);
        } else if (!affixStyle) {
            onAffix(false);
        }
    };

    Affix.prototype._setContainerStyle = function _setContainerStyle(containerStyle) {
        if (_util.obj.shallowEqual(containerStyle, this.state.containerStyle)) {
            return;
        }
        this.setState({ containerStyle: containerStyle });
    };

    Affix.prototype._getOffset = function _getOffset(affixNode, affixContainer) {
        var affixRect = affixNode.getBoundingClientRect(); // affix 元素 相对浏览器窗口的位置
        var containerRect = (0, _util2.getRect)(affixContainer); // affix 容器 相对浏览器窗口的位置
        var containerScrollTop = (0, _util2.getScroll)(affixContainer, true);
        var containerScrollLeft = (0, _util2.getScroll)(affixContainer, false);

        return {
            top: affixRect.top - containerRect.top + containerScrollTop,
            left: affixRect.left - containerRect.left + containerScrollLeft,
            width: affixRect.width,
            height: affixRect.height
        };
    };

    Affix.prototype.render = function render() {
        var _classnames;

        var _props2 = this.props,
            prefix = _props2.prefix,
            className = _props2.className,
            style = _props2.style,
            children = _props2.children;

        var state = this.state;
        var classNames = (0, _classnames3.default)((_classnames = {}, _classnames[prefix + 'affix'] = state.style, _classnames[prefix + 'affix-top'] = !state.style && this.affixMode.top, _classnames[prefix + 'affix-bottom'] = !state.style && this.affixMode.bottom, _classnames[className] = className, _classnames));
        var combinedStyle = _extends({}, state.containerStyle, style);

        return _react2.default.createElement(
            'div',
            { ref: this._affixNodeRefHandler, style: combinedStyle },
            _react2.default.createElement(
                'div',
                { ref: this._affixChildNodeRefHandler, className: classNames, style: state.style },
                children
            )
        );
    };

    return Affix;
}(_react2.default.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    /**
     * 设置 Affix 需要监听滚动事件的容器元素
     * @return {ReactElement} 目标容器元素的实例
     */
    container: _propTypes2.default.func,
    /**
     * 距离窗口顶部达到指定偏移量后触发
     */
    offsetTop: _propTypes2.default.number,
    /**
     * 距离窗口底部达到制定偏移量后触发
     */
    offsetBottom: _propTypes2.default.number,
    /**
     * 当元素的样式发生固钉样式变化时触发的回调函数
     * @param {Boolean} 元素是否被固钉
     */
    onAffix: _propTypes2.default.func,
    /**
     * 是否启用绝对布局实现 affix
     * @param {Boolean} 是否启用绝对布局
     */
    useAbsolute: _propTypes2.default.bool,
    className: _propTypes2.default.string,
    style: _propTypes2.default.object,
    children: _propTypes2.default.any
}, _class.defaultProps = {
    prefix: 'next-',
    container: function container() {
        return window;
    },
    onAffix: _util.func.noop
}, _temp);
Affix.displayName = 'Affix';
exports.default = _configProvider2.default.config(Affix);
module.exports = exports['default'];

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getScroll = getScroll;
exports.getRect = getRect;
exports.getNodeHeight = getNodeHeight;
function getScroll(node, isVertical) {
    if (typeof window === 'undefined') {
        return 0;
    }
    var windowProp = isVertical ? 'pageYOffset' : 'pageXOffset';
    var elementProp = isVertical ? 'scrollTop' : 'scrollLeft';
    return node === window ? node[windowProp] : node[elementProp];
}

function getRect(node) {
    return node !== window ? node.getBoundingClientRect() : { top: 0, left: 0, bottom: 0 };
}

function getNodeHeight(node) {
    if (!node) {
        return 0;
    }
    if (node === window) {
        return window.innerHeight;
    }
    return node.clientHeight;
}

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(11);

__webpack_require__(38);

__webpack_require__(70);

__webpack_require__(77);

__webpack_require__(72);

__webpack_require__(149);

__webpack_require__(78);

__webpack_require__(153);

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(25);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(25, function () {
			var newContent = __webpack_require__(25);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
	// get current location
	var location = typeof window !== "undefined" && window.location;

	if (!location) {
		throw new Error("fixUrls requires window.location");
	}

	// blank or null?
	if (!css || typeof css !== "string") {
		return css;
	}

	var baseUrl = location.protocol + "//" + location.host;
	var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
 This regular expression is just a way to recursively match brackets within
 a string.
 	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
    (  = Start a capturing group
      (?:  = Start a non-capturing group
          [^)(]  = Match anything that isn't a parentheses
          |  = OR
          \(  = Match a start parentheses
              (?:  = Start another non-capturing groups
                  [^)(]+  = Match anything that isn't a parentheses
                  |  = OR
                  \(  = Match a start parentheses
                      [^)(]*  = Match anything that isn't a parentheses
                  \)  = Match a end parentheses
              )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
  \)  = Match a close parens
 	 /gi  = Get all matches, not the first.  Be case insensitive.
  */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
			return $1;
		}).replace(/^'(.*)'$/, function (o, $1) {
			return $1;
		});

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
			return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
			//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(26);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(26, function () {
			var newContent = __webpack_require__(26);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(27);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(27, function () {
			var newContent = __webpack_require__(27);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(28);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(28, function () {
			var newContent = __webpack_require__(28);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(29);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(29, function () {
			var newContent = __webpack_require__(29);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(30);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(30, function () {
			var newContent = __webpack_require__(30);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(36);

__webpack_require__(151);

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(31);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(31, function () {
			var newContent = __webpack_require__(31);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(32);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(32, function () {
			var newContent = __webpack_require__(32);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(33);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(33, function () {
			var newContent = __webpack_require__(33);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(34);
if (typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {};
options.transform = transform;
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if (content.locals) module.exports = content.locals;
// Hot Module Replacement
if (true) {
	// When the styles change, update the <style> tags
	if (!content.locals) {
		module.hot.accept(34, function () {
			var newContent = __webpack_require__(34);
			if (typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function () {
		update();
	});
}

/***/ }),
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(155);
module.exports = __webpack_require__(259);


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _class, _temp2;

var _table = __webpack_require__(79);

var _table2 = _interopRequireDefault(_table);

__webpack_require__(141);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);for (var i = 0; i < keys.length; i++) {
        var key = keys[i];var value = Object.getOwnPropertyDescriptor(defaults, key);if (value && value.configurable && obj[key] === undefined) {
            Object.defineProperty(obj, key, value);
        }
    }return obj;
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
}

/* eslint-disable react/no-multi-comp,react/prop-types */
var Header = _table2.default.Header,
    Cell = _table2.default.Cell;

var dataSource = function dataSource() {
    var result = [];
    for (var i = 0; i < 5; i++) {
        result.push({
            title: 'Quotation for 1PCS Nano ' + (3 + i) + '.0 controller compatible',
            id: 100306660940 + i,
            time: 2000 + i
        });
    }
    return result;
};

var AppHeader = function AppHeader(props, context) {
    var columns = props.columns;
    var onChange = context.onChange;

    var length = columns[columns.length - 1].length;
    return React.createElement(Header, props, React.createElement('tr', null, React.createElement(Cell, { colSpan: length }, React.createElement('a', { onClick: function onClick() {
            return onChange(true);
        }, href: 'javascript:;' }, 'Select all'), '\xA0', React.createElement('a', { onClick: function onClick() {
            return onChange(false);
        }, href: 'javascript:;' }, 'Unselect all'))));
};

AppHeader.contextTypes = {
    onChange: _propTypes2.default.func
};

var App = (_temp2 = _class = function (_React$Component) {
    _inherits(App, _React$Component);

    function App() {
        var _temp, _this, _ret;

        _classCallCheck(this, App);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
            selectedKeys: []
        }, _this.dataSource = dataSource(), _this.onChange = function (checked) {
            var selectedKeys = [];
            if (checked) {
                selectedKeys = _this.dataSource.map(function (item) {
                    return item.id;
                });
            }
            _this.onRowChange(selectedKeys);
        }, _this.onRowChange = function (selectedKeys) {
            _this.setState({
                selectedKeys: selectedKeys
            });
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    App.prototype.getChildContext = function getChildContext() {
        return {
            onChange: this.onChange
        };
    };

    App.prototype.render = function render() {
        return React.createElement('span', null, React.createElement(_table2.default, { dataSource: this.dataSource,
            components: {
                Header: AppHeader
            },
            rowSelection: {
                selectedRowKeys: this.state.selectedKeys,
                onChange: this.onRowChange
            } }, React.createElement(_table2.default.Column, { title: 'Id', dataIndex: 'id' }), React.createElement(_table2.default.Column, { title: 'Title', dataIndex: 'title' }), React.createElement(_table2.default.Column, { title: 'Time', dataIndex: 'time' })));
    };

    return App;
}(React.Component), _class.childContextTypes = {
    onChange: _propTypes2.default.func
}, _temp2);
App.displayName = 'App';

ReactDOM.render(React.createElement(App, null), mountNode);

// HOT RELOAD CODE
var componentDesc = document.querySelector('#component-desc');
componentDesc.innerHTML = '\u901A\u8FC7Table\u66B4\u9732\u7684\u5B50\u7EC4\u4EF6\u8FDB\u884C\u6269\u5C55';
var componentBody = document.querySelector('#component-body');
componentBody.innerHTML = '<pre><code class="language-jsx"><div class="hljs"><span class="hljs-keyword">import</span> { Table } <span class="hljs-keyword">from</span> <span class="hljs-string">\'@alifd/next\'</span>;\n<span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">\'prop-types\'</span>;\n<span class="hljs-comment">/* eslint-disable react/no-multi-comp,react/prop-types */</span>\n<span class="hljs-keyword">const</span> {Header, Cell} = Table;\n<span class="hljs-keyword">const</span> dataSource = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">const</span> result = [];\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {\n        result.push({\n            <span class="hljs-attr">title</span>: <span class="hljs-string">{backquote}Quotation for 1PCS Nano <span class="hljs-subst">{dollar}{<span class="hljs-number">3</span> + i}</span>.0 controller compatible{backquote}</span>,\n            <span class="hljs-attr">id</span>: <span class="hljs-number">100306660940</span> + i,\n            <span class="hljs-attr">time</span>: <span class="hljs-number">2000</span> + i\n        });\n    }\n    <span class="hljs-keyword">return</span> result;\n};\n\n<span class="hljs-keyword">const</span> AppHeader = <span class="hljs-function">(<span class="hljs-params">props, context</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> {columns} = props;\n    <span class="hljs-keyword">const</span> {onChange} = context;\n    <span class="hljs-keyword">const</span> length = columns[columns.length - <span class="hljs-number">1</span>].length;\n    <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Header</span> {<span class="hljs-attr">...props</span>}&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>\n            <span class="hljs-tag">&lt;<span class="hljs-name">Cell</span> <span class="hljs-attr">colSpan</span>=<span class="hljs-string">{length}</span>&gt;</span>\n                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> onChange(true)} href="javascript:;"&gt;Select all<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>&amp;nbsp;\n                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> onChange(false)} href="javascript:;"&gt;Unselect all<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>\n            <span class="hljs-tag">&lt;/<span class="hljs-name">Cell</span>&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">Header</span>&gt;</span></span>);\n};\n\nAppHeader.contextTypes = {\n    <span class="hljs-attr">onChange</span>: PropTypes.func\n};\n\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n    <span class="hljs-keyword">static</span> childContextTypes = {\n        <span class="hljs-attr">onChange</span>: PropTypes.func\n    }\n    state = {\n        <span class="hljs-attr">selectedKeys</span>: []\n    }\n    getChildContext() {\n        <span class="hljs-keyword">return</span> {\n            <span class="hljs-attr">onChange</span>: <span class="hljs-keyword">this</span>.onChange\n        };\n    }\n    dataSource = dataSource()\n    onChange = <span class="hljs-function">(<span class="hljs-params">checked</span>) =&gt;</span> {\n        <span class="hljs-keyword">let</span> selectedKeys = [];\n        <span class="hljs-keyword">if</span> (checked) {\n            selectedKeys = <span class="hljs-keyword">this</span>.dataSource.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.id);\n        }\n        <span class="hljs-keyword">this</span>.onRowChange(selectedKeys);\n    }\n    onRowChange = <span class="hljs-function">(<span class="hljs-params">selectedKeys</span>) =&gt;</span> {\n        <span class="hljs-keyword">this</span>.setState({\n            selectedKeys\n        });\n    }\n    render() {\n        <span class="hljs-keyword">return</span> (&lt;span&gt;\n            &lt;Table dataSource={this.dataSource}\n                components={{\n                    Header: AppHeader\n                }}\n                rowSelection={{\n                    selectedRowKeys: this.state.selectedKeys,\n                    onChange: this.onRowChange\n                }}&gt;\n                &lt;Table.Column title="Id" dataIndex="id" /&gt;\n                &lt;Table.Column title="Title" dataIndex="title"/&gt;\n                &lt;Table.Column title="Time" dataIndex="time"/&gt;\n            &lt;/Table&gt;\n        &lt;/span&gt;);\n    }\n}\n\nReactDOM.render(&lt;App/&gt;, mountNode);\n</div></code></pre>\n'.replace(/{backquote}/g, '`').replace(/{dollar}/g, '$');

if (true) {
    module.hot.accept();

    var reloading = document.querySelector('#next-demo-reloading');

    if (!window.hasAddStatusHandler) {
        module.hot.addStatusHandler(function (status) {
            window.hasAddStatusHandler = true;
            if (status === 'check') {
                reloading.style.display = 'block';
            } else if (status === 'idle') {
                reloading.style.display = 'none';
            }
        });
    }
}

/***/ })
],[258]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ3aW5kb3cuUmVhY3RcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3Byb3AtdHlwZXNAMTUuNi4yQHByb3AtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19jbGFzc25hbWVzQDIuMi42QGNsYXNzbmFtZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwid2luZG93LlJlYWN0RE9NXCIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy1wcm92aWRlci9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL3NyYy90YWJsZS91dGlsLmpzIiwid2VicGFjazovLy8uL3NyYy9pY29uL2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvaWNvbi9zdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYW5pbWF0ZS9zdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21lbnUvdmlldy9pdGVtLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvb3ZlcmxheS9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2Jhc2UvYm9keS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2Jhc2Uvcm93LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvYmFzZS9jZWxsLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvZml4ZWQvaGVhZGVyLmpzeCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3Byb3AtdHlwZXNAMTUuNi4yQHByb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL3NyYy9vdmVybGF5L3V0aWxzL2ZpbmQtbm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWVudS92aWV3L3NlbGVjdGFibGUtaXRlbS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2NvbHVtbi5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2ZpeGVkL3dyYXBwZXIuanN4Iiwid2VicGFjazovLy8uL3NyYy9pY29uL21haW4uc2Nzcz83MDIyIiwid2VicGFjazovLy8uL3NyYy9hbmltYXRlL21haW4uc2Nzcz9lYmE4Iiwid2VicGFjazovLy8uL3NyYy9jaGVja2JveC9tYWluLnNjc3M/ZWZlYSIsIndlYnBhY2s6Ly8vLi9zcmMvcmFkaW8vbWFpbi5zY3NzPzhiNTQiLCJ3ZWJwYWNrOi8vLy4vc3JjL21lbnUvbWFpbi5zY3NzPzVkZTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2J1dHRvbi9tYWluLnNjc3M/MGFkNCIsIndlYnBhY2s6Ly8vLi9zcmMvb3ZlcmxheS9tYWluLnNjc3M/MmM2ZCIsIndlYnBhY2s6Ly8vLi9zcmMvZHJvcGRvd24vbWFpbi5zY3NzPzY1ODAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvYWRpbmcvbWFpbi5zY3NzP2M1NDIiLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL21haW4uc2Nzcz83ZGRlIiwid2VicGFjazovLy8uL3NyYy9sb2NhbGUvemgtY24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL292ZXJsYXkvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NoZWNrYm94L2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY2hlY2tib3gvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy1wcm92aWRlci9nZXQtY29udGV4dC1wcm9wcy5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvZG9tLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlsL3N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9lbnYuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwva2V5Y29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3NoYWxsb3ctZWxlbWVudC1lcXVhbHNAMS4wLjFAc2hhbGxvdy1lbGVtZW50LWVxdWFscy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvb3ZlcmxheS9vdmVybGF5LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvb3ZlcmxheS9nYXRld2F5LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvb3ZlcmxheS9wb3NpdGlvbi5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2Jhc2UvaGVhZGVyLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvYmFzZS9maWx0ZXIuanN4Iiwid2VicGFjazovLy8uL3NyYy9tZW51L3ZpZXcvbWVudS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2FuaW1hdGUvYW5pbWF0ZS5qc3giLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19yZWFjdC10cmFuc2l0aW9uLWdyb3VwQDIuNS4yQHJlYWN0LXRyYW5zaXRpb24tZ3JvdXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19yZWFjdC10cmFuc2l0aW9uLWdyb3VwQDIuNS4yQHJlYWN0LXRyYW5zaXRpb24tZ3JvdXAvVHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3JlYWN0LWxpZmVjeWNsZXMtY29tcGF0QDMuMC40QHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0L3JlYWN0LWxpZmVjeWNsZXMtY29tcGF0LmVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9fcmVhY3QtdHJhbnNpdGlvbi1ncm91cEAyLjUuMkByZWFjdC10cmFuc2l0aW9uLWdyb3VwL3V0aWxzL1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3JlYWN0LXRyYW5zaXRpb24tZ3JvdXBAMi41LjJAcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9UcmFuc2l0aW9uR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21lbnUvdmlldy9wb3B1cC1pdGVtLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvbWVudS92aWV3L2NoZWNrYWJsZS1pdGVtLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY2hlY2tib3gvY2hlY2tib3guanN4Iiwid2VicGFjazovLy8uL3NyYy9taXhpbi11aS1zdGF0ZS9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3JhZGlvL2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvcmFkaW8vcmFkaW8uanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS9iYXNlL3NvcnQuanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS9zZWxlY3Rpb24vcm93LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvZXhwYW5kZWQvcm93LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvbG9jay9yb3cuanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS9maXhlZC9ib2R5LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvbGlzdC1oZWFkZXIuanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS9saXN0LWZvb3Rlci5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3JhZGlvL3N0eWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9idXR0b24vaW5kZXguanN4Iiwid2VicGFjazovLy8uL3NyYy9idXR0b24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FuaW1hdGUvaW5kZXguanN4Iiwid2VicGFjazovLy8uL3NyYy9sb2FkaW5nL2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvbWVudS9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL21lbnUvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvYWRpbmcvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3Byb3AtdHlwZXNAMTUuNi4yQHByb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19vYmplY3QtYXNzaWduQDQuMS4xQG9iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19wcm9wLXR5cGVzQDE1LjYuMkBwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9fcHJvcC10eXBlc0AxNS42LjJAcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy1wcm92aWRlci9jb25maWcuanN4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9faG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3NAMi41LjVAaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvZGlzdC9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy5janMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlsL2Z1bmMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvbG9nLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlsL3N1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvZm9jdXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvZ3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnLXByb3ZpZGVyL2NvbnN1bWVyLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnLXByb3ZpZGVyL2NhY2hlLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcIndpbmRvdy5tb21lbnRcIiIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvYmFzZS5qc3giLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19zdHlsZS1lcXVhbEAxLjAuMEBzdHlsZS1lcXVhbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvb3ZlcmxheS9tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9vdmVybGF5L3V0aWxzL3Bvc2l0aW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9vdmVybGF5L3BvcHVwLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvZHJvcGRvd24vaW5kZXguanN4Iiwid2VicGFjazovLy8uL3NyYy9tZW51L3ZpZXcvc3ViLW1lbnUuanN4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9fcmVhY3QtdHJhbnNpdGlvbi1ncm91cEAyLjUuMkByZWFjdC10cmFuc2l0aW9uLWdyb3VwL0NTU1RyYW5zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19kb20taGVscGVyc0AzLjQuMEBkb20taGVscGVycy9jbGFzcy9hZGRDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX0BiYWJlbF9ydW50aW1lQDcuMi4wQEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9fZG9tLWhlbHBlcnNAMy40LjBAZG9tLWhlbHBlcnMvY2xhc3MvaGFzQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19kb20taGVscGVyc0AzLjQuMEBkb20taGVscGVycy9jbGFzcy9yZW1vdmVDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3JlYWN0LXRyYW5zaXRpb24tZ3JvdXBAMi41LjJAcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9SZXBsYWNlVHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3JlYWN0LXRyYW5zaXRpb24tZ3JvdXBAMi41LjJAcmVhY3QtdHJhbnNpdGlvbi1ncm91cC91dGlscy9DaGlsZE1hcHBpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FuaW1hdGUvY2hpbGQuanN4Iiwid2VicGFjazovLy8uL3NyYy9hbmltYXRlL2V4cGFuZC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL21lbnUvdmlldy9jaGVja2JveC1pdGVtLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY2hlY2tib3gvY2hlY2tib3gtZ3JvdXAuanN4Iiwid2VicGFjazovLy8uL3NyYy9yYWRpby9yYWRpby1ncm91cC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL21lbnUvdmlldy9yYWRpby1pdGVtLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvbWVudS92aWV3L2dyb3VwLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvbWVudS92aWV3L2RpdmlkZXIuanN4Iiwid2VicGFjazovLy8uL3NyYy9tZW51L3ZpZXcvY3JlYXRlLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvYnV0dG9uL3ZpZXcvYnV0dG9uLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvYnV0dG9uL3ZpZXcvZ3JvdXAuanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS9iYXNlL3Jlc2l6ZS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2Jhc2Uvd3JhcHBlci5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2NvbHVtbi1ncm91cC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL3RyZWUuanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS90cmVlL3Jvdy5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL3RyZWUvY2VsbC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2ZpeGVkLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvc2VsZWN0aW9uLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvZXhwYW5kZWQuanN4Iiwid2VicGFjazovLy8uL3NyYy90YWJsZS92aXJ0dWFsLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvdmlydHVhbC9ib2R5LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvbG9jay5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2xvY2svYm9keS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2xvY2svaGVhZGVyLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvbGlzdC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3RhYmxlL2xpc3Qvcm93LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvbGlzdC9ib2R5LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvc3RpY2t5LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvc3RpY2t5L2hlYWRlci5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2FmZml4L2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvYWZmaXgvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ljb24vbWFpbi5zY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDAuMTguMkBzdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FuaW1hdGUvbWFpbi5zY3NzIiwid2VicGFjazovLy8uL3NyYy9jaGVja2JveC9tYWluLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JhZGlvL21haW4uc2NzcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWVudS9tYWluLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2J1dHRvbi9tYWluLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Ryb3Bkb3duL3N0eWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9vdmVybGF5L21haW4uc2NzcyIsIndlYnBhY2s6Ly8vLi9zcmMvZHJvcGRvd24vbWFpbi5zY3NzIiwid2VicGFjazovLy8uL3NyYy9sb2FkaW5nL21haW4uc2NzcyIsIndlYnBhY2s6Ly8vLi9zcmMvdGFibGUvbWFpbi5zY3NzIiwid2VicGFjazovLy8uL2RvY3MvdGFibGUvZGVtby9hZHZhbmNlZC5tZCJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJpc1ZhbGlkRWxlbWVudCIsIm9iamVjdCIsIiQkdHlwZW9mIiwidGhyb3dPbkRpcmVjdEFjY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiX2RvbSIsIl9lbnYiLCJfZXZlbnRzIiwiX2Z1bmMiLCJfbG9nIiwiX29iamVjdCIsIl9zdHJpbmciLCJfc3VwcG9ydCIsIl9mb2N1cyIsImRvbSIsImV2ZW50cyIsImZ1bmMiLCJsb2ciLCJvYmoiLCJzdHIiLCJzdXBwb3J0IiwiZm9jdXMiLCJndWlkIiwiX2d1aWQiLCJLRVlDT0RFIiwiX0tFWUNPREUiLCJoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsImNsYXNzTmFtZXMiLCJjbGFzc2VzIiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZyIsImFyZ1R5cGUiLCJwdXNoIiwiQXJyYXkiLCJpc0FycmF5IiwiaW5uZXIiLCJhcHBseSIsImtleSIsImNhbGwiLCJqb2luIiwiZGVmYXVsdCIsImRlZmluZSIsIndpbmRvdyIsImNoaWxkQ29udGV4dENhY2hlIiwiQ2FjaGUiLCJDb25maWdQcm92aWRlciIsImFyZ3MiLCJhZGQiLCJnZXQiLCJnZXRDaGlsZENvbnRleHQiLCJwcm9wcyIsInByZWZpeCIsImxvY2FsZSIsInB1cmUiLCJ3YXJuaW5nIiwicnRsIiwibmV4dFByZWZpeCIsIm5leHRMb2NhbGUiLCJuZXh0UHVyZSIsIm5leHRSdGwiLCJuZXh0V2FybmluZyIsImNvbXBvbmVudFdpbGxNb3VudCIsInNldE1vbWVudExvY2FsZSIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJuZXh0UHJvcHMiLCJjb21wb25lbnREaWRVcGRhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlbW92ZSIsIm1vbWVudCIsImUiLCJtb21lbnRMb2NhbGUiLCJyZW5kZXIiLCJDaGlsZHJlbiIsIm9ubHkiLCJjaGlsZHJlbiIsIkNvbXBvbmVudCIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsInN0cmluZyIsImJvb2wiLCJlbGVtZW50IiwiZGVmYXVsdFByb3BzIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJjb25maWciLCJvcHRpb25zIiwiZ2V0Q29udGV4dFByb3BzIiwiZGlzcGxheU5hbWUiLCJyb290IiwiaW5pdExvY2FsZXMiLCJzZXRMYW5ndWFnZSIsInNldExvY2FsZSIsInNldERpcmVjdGlvbiIsImdldExhbmd1YWdlIiwiZ2V0TG9jYWxlIiwiZ2V0RGlyZWN0aW9uIiwiQ29uc3VtZXIiLCJnZXRDb250ZXh0IiwidXNlU291cmNlTWFwIiwibGlzdCIsInRvU3RyaW5nIiwibWFwIiwiaXRlbSIsImNvbnRlbnQiLCJjc3NXaXRoTWFwcGluZ1RvU3RyaW5nIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwiaWQiLCJjc3NNYXBwaW5nIiwiYnRvYSIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlcyIsInNvdXJjZSIsInNvdXJjZVJvb3QiLCJjb25jYXQiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIiwiYmxhY2tMaXN0Iiwic3RhdGljcyIsIlRhcmdldCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiaW5kZXhPZiIsInByb3BlcnR5IiwiZmV0Y2hEYXRhQnlQYXRoIiwicGF0aCIsImZpZWxkIiwic3BsaXQiLCJ2YWwiLCJtYXRjaCIsImNvbEluZGV4IiwiSWNvbiIsInR5cGUiLCJzaXplIiwiY2xhc3NOYW1lIiwib3RoZXIiLCJkaXIiLCJvbmVPZiIsIl90eXBlTWFyayIsInR5cGVPZiIsImlzQXJyYXlMaWtlIiwiaXNQcm9taXNlIiwiaXNQbGFpbk9iamVjdCIsInNoYWxsb3dFcXVhbCIsImVhY2giLCJwaWNrT3RoZXJzIiwicGlja0F0dHJzV2l0aCIsInByb3RvdHlwZSIsInJlcGxhY2UiLCJ0aGVuIiwiY3RvciIsImNvbnN0cnVjdG9yIiwicHJvdCIsIm9iakEiLCJvYmpCIiwiY29tcGFyZSIsImtleUEiLCJrZXlCIiwibGVuIiwiaGFzQ2FsbGJhY2siLCJ2YWxBIiwidmFsQiIsInJldCIsImNhbGxiYWNrIiwiZGlyZWN0aW9uIiwicmV2ZXJzZWQiLCJ2YWx1ZSIsIl9pc0luT2JqIiwiaG9sZFByb3BzIiwib3RoZXJzIiwiYmluZEN0eCIsIkl0ZW0iLCJjb21wb25lbnREaWRNb3VudCIsIml0ZW1Ob2RlIiwicGFyZW50TW9kZSIsIm1lbnVOb2RlIiwicGFyZW50Tm9kZSIsImhlYWRlciIsImZvb3RlciIsInF1ZXJ5U2VsZWN0b3IiLCJzZXRGb2N1cyIsImZvY3VzYWJsZSIsImRpc2FibGVkIiwiZ2V0Rm9jdXNlZCIsIl9rZXkiLCJmb2N1c2VkS2V5Iiwic3RhdGUiLCJmb2N1c2VkIiwicHJldmVudFNjcm9sbCIsInNjcm9sbEhlaWdodCIsImNsaWVudEhlaWdodCIsInNjcm9sbEJvdHRvbSIsInNjcm9sbFRvcCIsIml0ZW1Cb3R0b20iLCJvZmZzZXRUb3AiLCJvZmZzZXRIZWlnaHQiLCJoYW5kbGVDbGljayIsInN0b3BQcm9wYWdhdGlvbiIsImhhbmRsZUl0ZW1DbGljayIsIm9uQ2xpY2siLCJwcmV2ZW50RGVmYXVsdCIsImhhbmRsZUtleURvd24iLCJoYW5kbGVJdGVtS2V5RG93biIsIm9uS2V5RG93biIsImdldFRpdGxlIiwibGFiZWxTdHJpbmciLCJsb29wIiwiY2hpbGQiLCJsZXZlbCIsInJlcGxhY2VDbGFzc05hbWUiLCJncm91cEluZGVudCIsImNvbXBvbmVudCIsIm5lZWRJbmRlbnQiLCJpbmxpbmVJbmRlbnQiLCJpdGVtQ2xhc3NOYW1lIiwibmV3Q2xhc3NOYW1lIiwidGFiSW5kZXgiLCJ0YWJiYWJsZUtleSIsInN0eWxlIiwiVGFnTmFtZSIsIm51bWJlciIsInBhcmVudCIsIk92ZXJsYXkiLCJHYXRld2F5IiwiUG9zaXRpb24iLCJQb3B1cCIsImV4cG9ydE5hbWVzIiwibm9vcCIsIkJvZHkiLCJnZXRSb3dSZWYiLCJyb3ciLCJyb3dSZWYiLCJvblJvd0NsaWNrIiwicmVjb3JkIiwiaW5kZXgiLCJvblJvd01vdXNlRW50ZXIiLCJvblJvd01vdXNlTGVhdmUiLCJUYWciLCJjb2xHcm91cCIsImxvYWRpbmciLCJlbXB0eUNvbnRlbnQiLCJjb21wb25lbnRzIiwiZ2V0Q2VsbFByb3BzIiwicHJpbWFyeUtleSIsImdldFJvd1Byb3BzIiwiZGF0YVNvdXJjZSIsImNlbGxSZWYiLCJjb2x1bW5zIiwiUm93IiwiUm93Q29tcG9uZW50IiwiQ2VsbCIsIkNlbGxDb21wb25lbnQiLCJlbXB0eSIsInJvd3MiLCJyb3dQcm9wcyIsInJvd0NsYXNzIiwiZmlyc3QiLCJsYXN0IiwiZXhwYW5kZWQiLCJfX2V4cGFuZGVkIiwiYmluZCIsIlJlYWN0IiwiYW55IiwiYXJyYXkiLCJyb3dJbmRleCIsIm9uTW91c2VFbnRlciIsIm9uUm93SG92ZXIiLCJvbk1vdXNlTGVhdmUiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJpc0VxdWFsIiwiaXNFbnRlciIsImN1cnJlbnRSb3ciLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwicmVuZGVyQ2VsbHMiLCJsb2NrVHlwZSIsImNvbnRleHQiLCJkYXRhSW5kZXgiLCJhbGlnbiIsIndpZHRoIiwiYXR0cnMiLCJub3RSZW5kZXJDZWxsSW5kZXgiLCJtYXRjaENlbGxJbmRleCIsImNlbGxJbmRleCIsInNwbGljZSIsImNvbFNwYW4iLCJyb3dTcGFuIiwiX2dldE5vdFJlbmRlckNlbGxJbmRleCIsImNlbGwiLCJtYXhDb2xJbmRleCIsIm1heFJvd0luZGV4IiwiaiIsImNscyIsImNvbnRleHRUeXBlcyIsInJlc2l6YWJsZSIsInRpdGxlIiwiaW5uZXJTdHlsZSIsIl9fbm9ybWFsaXplZCIsImZpbHRlck1vZGUiLCJmaWx0ZXJzIiwic29ydGFibGUiLCJsb2NrIiwidGFnU3R5bGUiLCJjZWxsUHJvcHMiLCJjbG9uZUVsZW1lbnQiLCJ0ZXh0QWxpZ24iLCJvbmVPZlR5cGUiLCJub2RlIiwiRml4ZWRIZWFkZXIiLCJnZXROb2RlIiwiUmVhY3RQcm9wVHlwZXNTZWNyZXQiLCJmaW5kTm9kZSIsInRhcmdldCIsInBhcmFtIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImVyciIsIlNlbGVjdGFibGVJdGVtIiwiZ2V0U2VsZWN0ZWQiLCJzZWxlY3RlZCIsInNlbGVjdE1vZGUiLCJzZWxlY3RlZEtleXMiLCJoYW5kbGVTZWxlY3QiLCJvblNlbGVjdCIsImtleUNvZGUiLCJTUEFDRSIsInJlbmRlclNlbGVjdGVkSWNvbiIsImhhc1NlbGVjdGVkSWNvbiIsInJvb3RTZWxlY3RlZEljb24iLCJsZWZ0IiwiaGVscGVyIiwibmV3UHJvcHMiLCJtZW51Q2hpbGRUeXBlIiwiQ29sdW1uIiwiYXJyYXlPZiIsInNoYXBlIiwibGFiZWwiLCJGaXhlZFdyYXBwZXIiLCJ3cmFwcGVyQ29udGVudCIsIlRpbWVsaW5lIiwiZXhwYW5kIiwiZm9sZCIsIkNhcmQiLCJDYWxlbmRhciIsInRvZGF5Iiwibm93Iiwib2siLCJjbGVhciIsIm1vbnRoIiwieWVhciIsInByZXZZZWFyIiwibmV4dFllYXIiLCJwcmV2TW9udGgiLCJuZXh0TW9udGgiLCJwcmV2RGVjYWRlIiwibmV4dERlY2FkZSIsIkRhdGVQaWNrZXIiLCJwbGFjZWhvbGRlciIsImRhdGV0aW1lUGxhY2Vob2xkZXIiLCJtb250aFBsYWNlaG9sZGVyIiwieWVhclBsYWNlaG9sZGVyIiwic2VsZWN0VGltZSIsInNlbGVjdERhdGUiLCJzdGFydFBsYWNlaG9sZGVyIiwiZW5kUGxhY2Vob2xkZXIiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwiRGlhbG9nIiwiY2FuY2VsIiwiUGFnaW5hdGlvbiIsInByZXYiLCJuZXh0IiwiZ29UbyIsInBhZ2UiLCJnbyIsInBhZ2VTaXplIiwiSW5wdXQiLCJTZWxlY3QiLCJzZWxlY3RQbGFjZWhvbGRlciIsImF1dG9Db21wbGV0ZVBsYWNlaG9sZGVyIiwibm90Rm91bmRDb250ZW50IiwiVGFibGUiLCJyZXNldCIsImFzYyIsImRlc2MiLCJmb2xkZWQiLCJmaWx0ZXIiLCJzZWxlY3RBbGwiLCJUaW1lUGlja2VyIiwiVHJhbnNmZXIiLCJpdGVtcyIsIm1vdmVBbGwiLCJzZWFyY2hQbGFjZWhvbGRlciIsIlVwbG9hZCIsImNhcmQiLCJhZGRQaG90byIsImRyYWciLCJ0ZXh0IiwiaGludCIsIlNlYXJjaCIsImJ1dHRvblRleHQiLCJDaGVja2JveCIsIkdyb3VwIiwibmV3UHJlZml4IiwibG9jYWxlRnJvbUNvbnRleHQiLCJuZXdMb2NhbGUiLCJuZXdQdXJlIiwibmV3UnRsIiwiaGFzQ2xhc3MiLCJ0b2dnbGVDbGFzcyIsImdldFN0eWxlIiwic2V0U3R5bGUiLCJzY3JvbGxiYXIiLCJnZXRPZmZzZXQiLCJoYXNET00iLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJfZm9yY2UiLCJ0cmltIiwidG9nZ2xlIiwiZmxhZyIsIm1hdGNoZXMiLCJtYXRjaGVzRm4iLCJfYm9keSIsImJvZHkiLCJoZWFkIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJzZWxlY3RvciIsIl9nZXRDb21wdXRlZFN0eWxlIiwibm9kZVR5cGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiUElYRUxfUEFUVEVSTiIsInJlbW92ZVBpeGVsIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJfZ2V0U3R5bGVWYWx1ZSIsInRvTG93ZXJDYXNlIiwib2Zmc2V0V2lkdGgiLCJ0ZXN0IiwicGFyc2VGbG9hdCIsImZsb2F0TWFwIiwiY3NzRmxvYXQiLCJzdHlsZUZsb2F0IiwiZmxvYXQiLCJuYW1lIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInNjcm9sbERpdiIsInBvc2l0aW9uIiwiaGVpZ2h0Iiwib3ZlcmZsb3ciLCJhcHBlbmRDaGlsZCIsInNjcm9sbGJhcldpZHRoIiwiY2xpZW50V2lkdGgiLCJzY3JvbGxiYXJIZWlnaHQiLCJyZW1vdmVDaGlsZCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aW4iLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJwYWdlWU9mZnNldCIsInBhZ2VYT2Zmc2V0IiwiY2FtZWxjYXNlIiwiaHlwaGVuYXRlIiwiJDAiLCIkMSIsInRvVXBwZXJDYXNlIiwiaWVWZXJzaW9uIiwiZG9jdW1lbnRNb2RlIiwidW5kZWZpbmVkIiwiaXNQcm9kdWN0aW9uIiwiUFJPRFVDVElPTl9FTlYiLCJyZXN1bHQiLCJCQUNLU1BBQ0UiLCJUQUIiLCJFTlRFUiIsIlNISUZUIiwiQ1RSTCIsIkFMVCIsIkVTQyIsIkVORCIsIkhPTUUiLCJMRUZUIiwiVVAiLCJSSUdIVCIsIkRPV04iLCJFU0NBUEUiLCJMRUZUX0FSUk9XIiwiVVBfQVJST1ciLCJSSUdIVF9BUlJPVyIsIkRPV05fQVJST1ciLCJDT05UUk9MIiwiT1BUSU9OIiwiQ01EIiwiQ09NTUFORCIsIkRFTEVURSIsInN0eWxlRXF1YWwiLCJhIiwiZWxlbWVudEVxdWFscyIsImIiLCJ0eXBlT2ZBIiwidHlwZU9mQiIsInJlZiIsInNoYWxsb3dFbGVtZW50RXF1YWxzIiwiYUNvdW50IiwiYkNvdW50Iiwic2F2ZUxhc3RGb2N1c05vZGUiLCJnZXRGb2N1c05vZGVMaXN0IiwiYmFja0xhc3RGb2N1c05vZGUiLCJtYWtlQ2hhaW4iLCJpc1Njcm9sbERpc3BsYXkiLCJzY3JvbGxiYXJTdHlsZSIsImhhc1Njcm9sbCIsImRvYyIsImRvY3VtZW50RWxlbWVudCIsInByZWZpeGVzIiwiZ2V0U3R5bGVQcm9wZXJ0eSIsIm1vZGFscyIsImJvZHlPdmVyZmxvd1kiLCJib2R5UGFkZGluZ1JpZ2h0Iiwic2F2ZUNvbnRlbnRSZWYiLCJjb250ZW50UmVmIiwic2F2ZUdhdGV3YXlSZWYiLCJnYXRld2F5UmVmIiwidmlzaWJsZSIsInN0YXR1cyIsImFuaW1hdGlvbiIsImdldEFuaW1hdGlvbiIsImxhc3RBbGlnbiIsInRpbWVvdXRNYXAiLCJiZWZvcmVPcGVuIiwiZW50ZXIiLCJhZGREb2N1bWVudEV2ZW50cyIsIm92ZXJsYXlNYW5hZ2VyIiwiYWRkT3ZlcmxheSIsIl9pc01vdW50ZWQiLCJ3aWxsT3BlbiIsIndpbGxDbG9zZSIsImJlZm9yZUNsb3NlIiwic2V0U3RhdGUiLCJsZWF2ZSIsInByZXZQcm9wcyIsIm9wZW4iLCJjbG9zZSIsImFkZEFuaW1hdGlvbkV2ZW50cyIsIndyYXBwZXJOb2RlIiwiZ2V0V3JhcHBlck5vZGUiLCJzZXRUaW1lb3V0Iiwib25PcGVuIiwiYWZ0ZXJPcGVuIiwib25DbG9zZSIsImFmdGVyQ2xvc2UiLCJyZW1vdmVPdmVybGF5Iiwic2V0Rm9jdXNOb2RlIiwiX2lzRGVzdHJveWVkIiwicmVtb3ZlRG9jdW1lbnRFdmVudHMiLCJmb2N1c1RpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJfYW5pbWF0aW9uIiwib2ZmIiwiZ2V0QW5pbWF0aW9uQnlBbGlnbiIsImluIiwib3V0IiwiZ2V0Q29udGVudE5vZGUiLCJvbiIsImVuZCIsImhhbmRsZUFuaW1hdGVFbmQiLCJhbmltYXRpb25EZWxheSIsImFuaW1hdGlvbkR1cmF0aW9uIiwidGltZSIsImhhbmRsZVBvc2l0aW9uIiwibmVlZEFkanVzdCIsIm9uTGVhdmVkIiwib25FbnRlcmVkIiwib25FbnRlcmluZyIsIm9uTGVhdmluZyIsImRpc2FibGVTY3JvbGwiLCJvdmVyZmxvd1kiLCJwYWRkaW5nUmlnaHQiLCJhdXRvRm9jdXMiLCJfaGFzRm9jdXNlZCIsImZvY3VzTm9kZUxpc3QiLCJnZXRDb250ZW50IiwiZ2V0Q2hpbGROb2RlIiwiY2FuQ2xvc2VCeUVzYyIsIl9rZXlkb3duRXZlbnRzIiwiaGFuZGxlRG9jdW1lbnRLZXlEb3duIiwiY2FuQ2xvc2VCeU91dFNpZGVDbGljayIsIl9jbGlja0V2ZW50cyIsImhhbmRsZURvY3VtZW50Q2xpY2siLCJpc0N1cnJlbnRPdmVybGF5Iiwib25SZXF1ZXN0Q2xvc2UiLCJzYWZlTm9kZSIsInNhZmVOb2RlcyIsInVuc2hpZnQiLCJoYW5kbGVNYXNrQ2xpY2siLCJjYW5DbG9zZUJ5TWFzayIsImdldEluc3RhbmNlIiwicHJvcENoaWxkcmVuIiwib2Zmc2V0IiwiY29udGFpbmVyIiwiaGFzTWFzayIsImJlZm9yZVBvc2l0aW9uIiwib25Qb3NpdGlvbiIsIndyYXBwZXJTdHlsZSIsInByb3BTaG91bGRVcGRhdGVQb3NpdGlvbiIsInNob3VsZFVwZGF0ZVBvc2l0aW9uIiwiY2FjaGUiLCJ3cmFwcGVyQ2xhc3NOYW1lIiwib25NYXNrTW91c2VFbnRlciIsIm9uTWFza01vdXNlTGVhdmUiLCJzdGF0ZVZpc2libGUiLCJjaGlsZENsYXp6IiwiRXJyb3IiLCJ3cmFwcGVyQ2xhenoiLCJuZXdXcmFwcGVyU3R5bGUiLCJkaXNwbGF5IiwiVklFV1BPUlQiLCJzYXZlQ2hpbGRSZWYiLCJjb250YWluZXJOb2RlIiwiZ2V0Q29udGFpbmVyTm9kZSIsImZvcmNlVXBkYXRlIiwidGFyZ2V0Tm9kZSIsInBsYWNlIiwic2V0UG9zaXRpb24iLCJuZWVkTGlzdGVuUmVzaXplIiwiaGFuZGxlUmVzaXplIiwicmVzaXplVGltZW91dCIsImNvbnRlbnROb2RlIiwiZ2V0VGFyZ2V0Tm9kZSIsInJlc3VsdEFsaWduIiwicGluRWxlbWVudCIsImJhc2VFbGVtZW50IiwiaXNSdGwiLCJIZWFkZXIiLCJnZXRDZWxsUmVmIiwiaGVhZGVyQ2VsbFJlZiIsIm9uU29ydCIsIm9yZGVyIiwic29ydCIsImZpbHRlclBhcmFtcyIsIm9uRmlsdGVyIiwiYWZmaXhSZWYiLCJvblJlc2l6ZUNoYW5nZSIsIkZpbHRlciIsIkZpbHRlckNvbXBvbmVudCIsIlNvcnQiLCJTb3J0Q29tcG9uZW50IiwiUmVzaXplIiwiUmVzaXplQ29tcG9uZW50IiwiY29scyIsImNvbCIsInNvcnRFbGVtZW50IiwiZmlsdGVyRWxlbWVudCIsInJlc2l6ZUVsZW1lbnQiLCJmaWx0ZXJDb25maWciLCJfc2VsZWN0ZWRLZXlzIiwicmVuZGVyTWVudUl0ZW0iLCJyZW5kZXJTdWJNZW51IiwicmVuZGVyTWVudUNvbnRlbnQiLCJvbkZpbHRlckNvbmZpcm0iLCJvbkZpbHRlckNsZWFyIiwiZmlsdGVyS2V5ZG93biIsIm9uRmlsdGVyVmlzaWJsZSIsIm9uRmlsdGVyU2VsZWN0IiwiTWVudSIsImRlZmF1bHRTZWxlY3RlZEtleXMiLCJuZXdDaGlsZHJlbiIsImdldE5ld0NoaWxkcmVuIiwiZ2V0Rmlyc3RBdmFsaWFibGVsQ2hpbGRLZXkiLCJvcGVuS2V5cyIsImdldEluaXRPcGVuS2V5cyIsIm5vcm1hbGl6ZVRvQXJyYXkiLCJwb3B1cE5vZGVzIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsImsybiIsIm9uQmx1ciIsImluaXRPcGVuS2V5cyIsImRlZmF1bHRPcGVuS2V5cyIsImRlZmF1bHRPcGVuQWxsIiwibW9kZSIsIm9wZW5Nb2RlIiwicDJuIiwicG9zUHJlZml4IiwiaW5kZXhXcmFwcGVyIiwibmV3Q2hpbGQiLCJwb3MiLCJpc1NpYmxpbmciLCJjdXJyZW50UG9zIiwidGFyZ2V0UG9zIiwiY3VycmVudE51bXMiLCJzbGljZSIsInRhcmdldE51bXMiLCJldmVyeSIsIm51bSIsImlzQW5jZXN0b3IiLCJoYW5kbGVPcGVuIiwidHJpZ2dlclR5cGUiLCJuZXdPcGVuS2V5cyIsImsiLCJzb21lIiwiZ2V0UGF0aCIsImtleVBhdGgiLCJsYWJlbFBhdGgiLCJudW1zIiwicGFyZW50TnVtcyIsInBhcmVudFBvcyIsInNlbGVjdCIsIm1lbnVJdGVtIiwic2hhbGxvd1NlbGVjdCIsIm5ld1NlbGVjdGVkS2V5cyIsIm9uSXRlbUZvY3VzIiwicHJldktleSIsIm5leHRLZXkiLCJvbkl0ZW1DbGljayIsImlzQXZhaWxhYmxlUG9zIiwicmVmUG9zIiwiZ2V0QXZhaWxhYmxlS2V5IiwicHMiLCJwIiwidGFyZ2V0SW5kZXgiLCJmaW5kIiwiZ2V0UGFyZW50S2V5IiwiYXZhbGlhYmxlS2V5IiwicGFyZW50S2V5Iiwib25JdGVtS2V5RG93biIsImhvekFsaWduIiwicm9sZSIsImhlYWRlckVsZW1lbnQiLCJpdGVtc0VsZW1lbnQiLCJmb290ZXJFbGVtZW50Iiwic2hvdWxkV3JhcEl0ZW1zQW5kRm9vdGVyIiwiaGFuZGxlRW50ZXIiLCJpc05leHRNZW51IiwiaW5saW5lQXJyb3dEaXJlY3Rpb24iLCJwb3B1cEF1dG9XaWR0aCIsInBvcHVwQWxpZ24iLCJwb3B1cFByb3BzIiwicG9wdXBDbGFzc05hbWUiLCJwb3B1cFN0eWxlIiwibGFiZWxUb2dnbGVDaGVja2VkIiwiZXhwYW5kQW5pbWF0aW9uIiwiRmlyc3RDaGlsZCIsImNoaWxkcmVuQXJyYXkiLCJ0b0FycmF5IiwiQW5pbWF0ZSIsIm5vcm1hbGl6ZU5hbWVzIiwibmFtZXMiLCJhcHBlYXIiLCJhcHBlYXJBY3RpdmUiLCJlbnRlckFjdGl2ZSIsImxlYXZlQWN0aXZlIiwiYW5pbWF0aW9uQXBwZWFyIiwic2luZ2xlTW9kZSIsImJlZm9yZUFwcGVhciIsIm9uQXBwZWFyIiwiYWZ0ZXJBcHBlYXIiLCJiZWZvcmVFbnRlciIsIm9uRW50ZXIiLCJhZnRlckVudGVyIiwiYmVmb3JlTGVhdmUiLCJvbkxlYXZlIiwiYWZ0ZXJMZWF2ZSIsImFuaW1hdGVDaGlsZHJlbiIsIl9DU1NUcmFuc2l0aW9uIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9SZXBsYWNlVHJhbnNpdGlvbiIsIl9UcmFuc2l0aW9uR3JvdXAiLCJfVHJhbnNpdGlvbiIsIl9fZXNNb2R1bGUiLCJUcmFuc2l0aW9uIiwiVHJhbnNpdGlvbkdyb3VwIiwiUmVwbGFjZVRyYW5zaXRpb24iLCJDU1NUcmFuc2l0aW9uIiwiRVhJVElORyIsIkVOVEVSRUQiLCJFTlRFUklORyIsIkVYSVRFRCIsIlVOTU9VTlRFRCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwiX3JlYWN0IiwiX3JlYWN0RG9tIiwiX3JlYWN0TGlmZWN5Y2xlc0NvbXBhdCIsIl9Qcm9wVHlwZXMiLCJuZXdPYmoiLCJkZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInNldCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiZXhjbHVkZWQiLCJzb3VyY2VLZXlzIiwiX2luaGVyaXRzTG9vc2UiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfUmVhY3QkQ29tcG9uZW50IiwiX3RoaXMiLCJwYXJlbnRHcm91cCIsInRyYW5zaXRpb25Hcm91cCIsImlzTW91bnRpbmciLCJpbml0aWFsU3RhdHVzIiwiYXBwZWFyU3RhdHVzIiwidW5tb3VudE9uRXhpdCIsIm1vdW50T25FbnRlciIsIm5leHRDYWxsYmFjayIsIl9wcm90byIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIl9yZWYiLCJwcmV2U3RhdGUiLCJuZXh0SW4iLCJ1cGRhdGVTdGF0dXMiLCJuZXh0U3RhdHVzIiwiY2FuY2VsTmV4dENhbGxiYWNrIiwiZ2V0VGltZW91dHMiLCJ0aW1lb3V0IiwiZXhpdCIsIm1vdW50aW5nIiwiZmluZERPTU5vZGUiLCJwZXJmb3JtRW50ZXIiLCJwZXJmb3JtRXhpdCIsIl90aGlzMiIsImFwcGVhcmluZyIsInRpbWVvdXRzIiwic2FmZVNldFN0YXRlIiwib25UcmFuc2l0aW9uRW5kIiwiX3RoaXMzIiwib25FeGl0ZWQiLCJvbkV4aXQiLCJvbkV4aXRpbmciLCJuZXh0U3RhdGUiLCJzZXROZXh0Q2FsbGJhY2siLCJfdGhpczQiLCJhY3RpdmUiLCJldmVudCIsImhhbmRsZXIiLCJhZGRFbmRMaXN0ZW5lciIsIl90aGlzJHByb3BzIiwiY2hpbGRQcm9wcyIsImlzUmVxdWlyZWQiLCJwdCIsInRpbWVvdXRzU2hhcGUiLCJfbGVuIiwiX2RlZmF1bHQiLCJwb2x5ZmlsbCIsInVwZGF0ZXIiLCJfX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEZsYWciLCJfX3JlYWN0SW50ZXJuYWxTbmFwc2hvdCIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyIsImlzUmVhY3RDb21wb25lbnQiLCJmb3VuZFdpbGxNb3VudE5hbWUiLCJmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIiwiZm91bmRXaWxsVXBkYXRlTmFtZSIsIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIiwiY29tcG9uZW50TmFtZSIsIm5ld0FwaU5hbWUiLCJjb21wb25lbnREaWRVcGRhdGVQb2x5ZmlsbCIsIm1heWJlU25hcHNob3QiLCJzbmFwc2hvdCIsInRyYW5zaXRpb25UaW1lb3V0IiwiY2xhc3NOYW1lc1NoYXBlIiwiX3Byb3BUeXBlcyIsInRyYW5zaXRpb25UeXBlIiwidGltZW91dFByb3BOYW1lIiwiZW5hYmxlZFByb3BOYW1lIiwiZW50ZXJEb25lIiwiZXhpdERvbmUiLCJleGl0QWN0aXZlIiwiX0NoaWxkTWFwcGluZyIsIl9leHRlbmRzIiwiYXNzaWduIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsInZhbHVlcyIsImNoaWxkRmFjdG9yeSIsImhhbmRsZUV4aXRlZCIsImZpcnN0UmVuZGVyIiwiYXBwZWFyZWQiLCJtb3VudGVkIiwicHJldkNoaWxkTWFwcGluZyIsImdldEluaXRpYWxDaGlsZE1hcHBpbmciLCJnZXROZXh0Q2hpbGRNYXBwaW5nIiwiY3VycmVudENoaWxkTWFwcGluZyIsImdldENoaWxkTWFwcGluZyIsIlBvcHVwSXRlbSIsImdldFBvcHVwIiwicG9wdXAiLCJnZXRPcGVuIiwiZ2V0UG9wdXBQcm9wcyIsIm9uVmlzaWJsZUNoYW5nZSIsImhhbmRsZVBvcHVwT3BlbiIsImF1dG9XaWR0aCIsInJvb3RQb3B1cEF1dG9XaWR0aCIsInJvb3RQb3B1cEFsaWduIiwicG9wdXBOb2RlIiwib3ZlcmxheSIsImhhbmRsZVBvcHVwQ2xvc2UiLCJyZW5kZXJJdGVtIiwic2VsZWN0YWJsZSIsIk5ld0l0ZW0iLCJpdGVtUHJvcHMiLCJyZW5kZXJQb3B1cCIsInRyaWdnZXIiLCJwb3NpdGlvblByb3BzIiwiaGFzU3ViTWVudSIsInNlbGVjdGFibGVGcm9tUHJvcHMiLCJyb290VHJpZ2dlclR5cGUiLCJuZXdUcmlnZ2VyVHlwZSIsInRyaWdnZXJJc0ljb24iLCJhcnJvd1Byb3BzIiwiYXJyb3ciLCJDaGVja2FibGVJdGVtIiwiaGFuZGxlQ2hlY2siLCJjaGVja1R5cGUiLCJjaGVja2VkIiwib25DaGFuZ2UiLCJjaGVja0Rpc2FibGVkIiwicmVuZGVyQ2hlY2siLCJpbmRldGVybWluYXRlIiwiQ2hlY2siLCJSYWRpbyIsImNoZWNrUHJvcHMiLCJpc0NoZWNrZWQiLCJzZWxlY3RlZFZhbHVlIiwiX19ncm91cF9fIiwiZGVmYXVsdENoZWNrZWQiLCJkZWZhdWx0SW5kZXRlcm1pbmF0ZSIsIm5leHRDb250ZXh0Iiwib3RoZXJQcm9wcyIsIm90aGVyc0RhdGEiLCJjaGlsZElucHV0IiwiZ2V0U3RhdGVFbGVtZW50IiwiZ2V0U3RhdGVDbGFzc05hbWUiLCJsYWJlbENscyIsIlVJU3RhdGUiLCJiYXNlIiwib25Gb2N1cyIsIl9vblVJRm9jdXMiLCJfb25VSUJsdXIiLCJyZXNldFVJU3RhdGUiLCJSYWRpb0dyb3VwIiwiaXNCdXR0b24iLCJpbnB1dCIsImNsc0lubmVyIiwicHJlc3MiLCJ1bnByZXNzIiwiY2xzV3JhcHBlciIsImNoaWxkcmVuQ2xzIiwicmFkaW9Db21wIiwiX29uVUlNb3VzZUVudGVyIiwiX29uVUlNb3VzZUxlYXZlIiwiZCIsImtleWRvd25IYW5kbGVyIiwicmVuZGVyU29ydCIsInNvcnRTdGF0dXMiLCJpY29ucyIsInNvcnRPcmRlciIsIlNlbGVjdGlvblJvdyIsInNlbGVjdGVkUm93S2V5cyIsIkV4cGFuZGVkUm93IiwicmVuZGVyRXhwYW5kZWRSb3ciLCJleHBhbmRlZFJvd1JlbmRlciIsImV4cGFuZGVkUm93SW5kZW50Iiwib3BlblJvd0tleXMiLCJsZWZ0SW5kZW50IiwicmlnaHRJbmRlbnQiLCJ0b3RhbEluZGVudCIsInJlbmRlckNvbHMiLCJMb2NrUm93IiwiRml4ZWRCb2R5Iiwib25Cb2R5U2Nyb2xsIiwib25TY3JvbGwiLCJtYXhCb2R5SGVpZ2h0IiwiZml4ZWRIZWFkZXIiLCJtYXhIZWlnaHQiLCJMaXN0SGVhZGVyIiwiaGFzQ2hpbGRyZW5TZWxlY3Rpb24iLCJoYXNTZWxlY3Rpb24iLCJMaXN0Rm9vdGVyIiwiQnV0dG9uIiwiQnV0dG9uR3JvdXAiLCJ0cmFuc2Zvcm0iLCJkZXByZWNhdGVkIiwibmV3VHlwZSIsImdob3N0IiwicHJpbWFyeSIsInNlY29uZGFyeSIsIm5vcm1hbCIsImRhcmsiLCJsaWdodCIsIkV4cGFuZCIsIkxvYWRpbmciLCJ0aXAiLCJpbmRpY2F0b3IiLCJjb2xvciIsImZ1bGxTY3JlZW4iLCJ0aXBBbGlnbiIsImluZGljYXRvckRvbSIsImRvdENscyIsImJhY2tncm91bmRDb2xvciIsImZ1c2lvblJlYWN0b3JDbHMiLCJsb2FkaW5nQ2xzIiwidGlwQ2xzIiwiY29udGVudENscyIsImFuaW1hdGUiLCJTdWJNZW51IiwiQ2hlY2tib3hJdGVtIiwiUmFkaW9JdGVtIiwiRGl2aWRlciIsImluZGVudFNpemUiLCJvbkRlc2VsZWN0IiwibmV3T25TZWxlY3QiLCJleHRyYSIsIk9SREVSX0xJU1QiLCJmaXhlZCIsInNlbGVjdGlvbiIsInRyZWUiLCJ2aXJ0dWFsIiwic3RpY2t5IiwicmVkdWNlIiwiY3VycmVudCIsIkJhc2UiLCJHcm91cEhlYWRlciIsIkdyb3VwRm9vdGVyIiwiZXhwYW5kZWRSb3dLZXlzIiwib25FeHBhbmRlZENoYW5nZSIsIm9uUm93T3BlbiIsImlzTG9hZGluZyIsImluZGVudCIsIm9wdGltaXphdGlvbiIsImdldFJvd0NsYXNzTmFtZSIsIm5ld0dldFJvd1Byb3BzIiwiY2hlY2tQcm9wVHlwZXMiLCJwcmludFdhcm5pbmciLCJtZXNzYWdlIiwiY29uc29sZSIsImVycm9yIiwieCIsImVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwiLCJJVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJpdGVyYXRvckZuIiwiQU5PTllNT1VTIiwiUmVhY3RQcm9wVHlwZXMiLCJjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlciIsInN5bWJvbCIsImNyZWF0ZUFueVR5cGVDaGVja2VyIiwiY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyIiwiY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyIiwiaW5zdGFuY2VPZiIsImNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIiLCJjcmVhdGVOb2RlQ2hlY2tlciIsIm9iamVjdE9mIiwiY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlciIsImNyZWF0ZUVudW1UeXBlQ2hlY2tlciIsImNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIiLCJjcmVhdGVTaGFwZVR5cGVDaGVja2VyIiwiZXhhY3QiLCJjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyIiwiaXMiLCJ5IiwiUHJvcFR5cGVFcnJvciIsInN0YWNrIiwiY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIiLCJ2YWxpZGF0ZSIsIm1hbnVhbFByb3BUeXBlQ2FsbENhY2hlIiwibWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQiLCJwcm9wTmFtZSIsImxvY2F0aW9uIiwicHJvcEZ1bGxOYW1lIiwic2VjcmV0IiwiY2FjaGVLZXkiLCJjaGFpbmVkQ2hlY2tUeXBlIiwiZXhwZWN0ZWRUeXBlIiwicHJvcFZhbHVlIiwicHJvcFR5cGUiLCJnZXRQcm9wVHlwZSIsInByZWNpc2VUeXBlIiwiZ2V0UHJlY2lzZVR5cGUiLCJ0eXBlQ2hlY2tlciIsImV4cGVjdGVkQ2xhc3MiLCJleHBlY3RlZENsYXNzTmFtZSIsImFjdHVhbENsYXNzTmFtZSIsImdldENsYXNzTmFtZSIsImV4cGVjdGVkVmFsdWVzIiwidmFsdWVzU3RyaW5nIiwiYXJyYXlPZlR5cGVDaGVja2VycyIsImNoZWNrZXIiLCJnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmciLCJpc05vZGUiLCJzaGFwZVR5cGVzIiwiYWxsS2V5cyIsInN0ZXAiLCJlbnRyaWVzIiwiZG9uZSIsImVudHJ5IiwiaXNTeW1ib2wiLCJSZWdFeHAiLCJEYXRlIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvcElzRW51bWVyYWJsZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwidG9PYmplY3QiLCJUeXBlRXJyb3IiLCJzaG91bGRVc2VOYXRpdmUiLCJ0ZXN0MSIsIlN0cmluZyIsImdldE93blByb3BlcnR5TmFtZXMiLCJ0ZXN0MiIsImZyb21DaGFyQ29kZSIsIm9yZGVyMiIsIm4iLCJ0ZXN0MyIsImxldHRlciIsImZyb20iLCJ0byIsInN5bWJvbHMiLCJzIiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwidHlwZVNwZWNzIiwiZ2V0U3RhY2siLCJ0eXBlU3BlY05hbWUiLCJleCIsImVtcHR5RnVuY3Rpb24iLCJzaGltIiwiZ2V0U2hpbSIsImdldERpc3BsYXlOYW1lIiwiZ2xvYmFsTG9jYWxlcyIsImN1cnJlbnRHbG9iYWxMYW5ndWFnZSIsImN1cnJlbnRHbG9iYWxMb2NhbGUiLCJjdXJyZW50R2xvYmFsUnRsIiwibG9jYWxlcyIsImxhbmd1YWdlIiwiQ29uZmlnZWRDb21wb25lbnQiLCJfZ2V0SW5zdGFuY2UiLCJfZGVwcmVjYXRlZCIsIl9pbnN0YW5jZSIsImNvbnRleHRQcm9wcyIsIm5ld0NvbnRleHRQcm9wcyIsIm5ld090aGVycyIsIlJFQUNUX1NUQVRJQ1MiLCJnZXREZWZhdWx0UHJvcHMiLCJtaXhpbnMiLCJLTk9XTl9TVEFUSUNTIiwiY2FsbGVyIiwiY2FsbGVlIiwiYXJpdHkiLCJnZXRQcm90b3R5cGVPZiIsIm9iamVjdFByb3RvdHlwZSIsImhvaXN0Tm9uUmVhY3RTdGF0aWNzIiwidGFyZ2V0Q29tcG9uZW50Iiwic291cmNlQ29tcG9uZW50IiwiYmxhY2tsaXN0IiwiaW5oZXJpdGVkQ29tcG9uZW50IiwiZGVzY3JpcHRvciIsIm9uY2UiLCJldmVudE5hbWUiLCJ1c2VDYXB0dXJlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJfX2ZuIiwicHJvbWlzZUNhbGwiLCJmbnMiLCJjaGFpbmVkRnVuY3Rpb24iLCJjdHgiLCJucyIsImZuTmFtZSIsInN1Y2Nlc3MiLCJmYWlsdXJlIiwiY2F0Y2giLCJpbnN0ZWFkIiwibXNnIiwiYW5pbWF0aW9uRW5kRXZlbnROYW1lcyIsIldlYmtpdEFuaW1hdGlvbiIsIk9BbmltYXRpb24iLCJ0cmFuc2l0aW9uRXZlbnROYW1lcyIsIldlYmtpdFRyYW5zaXRpb24iLCJPVHJhbnNpdGlvbiIsInRyYW5zaXRpb24iLCJfc3VwcG9ydEVuZCIsImVsIiwiX3N1cHBvcnRDU1MiLCJmbGV4IiwiY2xlYXJMYXN0Rm9jdXNOb2RlIiwibGltaXRUYWJSYW5nZSIsIl9pc1Zpc2libGUiLCJ2aXNpYmlsaXR5IiwiX2lzRm9jdXNhYmxlIiwibm9kZU5hbWUiLCJwYXJzZUludCIsImdldEF0dHJpYnV0ZSIsImhhc1RhYkluZGV4IiwiaXNOYU4iLCJyZXMiLCJub2RlTGlzdCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJtZXRob2QiLCJsYXN0Rm9jdXNFbGVtZW50IiwiYWN0aXZlRWxlbWVudCIsInRhYk5vZGVMaXN0IiwibWF4SW5kZXgiLCJzaGlmdEtleSIsInRpbWVzdGFtcCIsIm1hcEtleXMiLCJmbiIsIm5ld0tleSIsInJlcGxhY2VLZXkiLCJwMSIsInAyIiwidHJhbnNmb3JtQ29udGV4dCIsIl9yb290IiwiX3N0b3JlIiwiTWFwIiwiaGFzIiwiZGVmYXVsdFZhbHVlIiwidXBkYXRlIiwiZGVsZXRlIiwiZ2V0V3JhcHBlclJlZiIsIndyYXBwZXIiLCJnZXRBZmZpeFJlZiIsImdldEhlYWRlckNlbGxSZWYiLCJnZXRUYWJsZUluc3RhbmNlIiwiZ2V0VGFibGVJbnN0YW5jZUZvclZpcnR1YWwiLCJub3JtYWxpemVDaGlsZHJlblN0YXRlIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJmZXRjaEluZm9Gcm9tQmluYXJ5Q2hpbGRyZW4iLCJnZXRDaGlsZHJlbiIsImhhc0dyb3VwSGVhZGVyIiwiZmxhdENoaWxkcmVuIiwiZ3JvdXBDaGlsZHJlbiIsInByb3BzQ2hpbGRyZW4iLCJnZXRDb2xTcGFuIiwiZ3JvdXBDaGlsZCIsInJlbmRlckNvbEdyb3VwIiwicmVuZGVyVGFibGUiLCJoYXNIZWFkZXIiLCJIZWFkZXJDb21wb25lbnQiLCJXcmFwcGVyIiwiV3JhcHBlckNvbXBvbmVudCIsIkJvZHlDb21wb25lbnQiLCJoYXNCb3JkZXIiLCJpc1plYnJhIiwiZW50aXJlRGF0YVNvdXJjZSIsInJlZnMiLCJsb2FkaW5nQ29tcG9uZW50IiwiTG9hZGluZ0NvbXBvbmVudCIsInplYnJhIiwidGFibGUiLCJsb2FkaW5nQ2xhc3NOYW1lIiwiQ29sdW1uR3JvdXAiLCJoYXNFeHBhbmRlZFJvd0N0cmwiLCJnZXRFeHBhbmRlZENvbFByb3BzIiwib25FeHBhbmRlZFJvd0NsaWNrIiwicm93U2VsZWN0aW9uIiwic3RpY2t5SGVhZGVyIiwiYWZmaXhQcm9wcyIsImlzVHJlZSIsInVzZVZpcnR1YWwiLCJyb3dIZWlnaHQiLCJ6aENOIiwidHJhbnNmb3JtRW50cnlFcXVhbCIsInRyYW5zZm9ybUVxdWFsIiwic2hhbGxvd09iamVjdEVxdWFscyIsImFsbE92ZXJsYXlzIiwiZ2V0UGFnZVgiLCJzY3JvbGxMZWZ0IiwiZ2V0UGFnZVkiLCJfZ2V0RWxlbWVudFJlY3QiLCJlbGVtIiwib2Zmc2V0TGVmdCIsIm9mZnNldFBhcmVudCIsIl9nZXRWaWV3cG9ydFNpemUiLCJleHBlY3RlZEFsaWduIiwiX2dldEV4cGVjdGVkQWxpZ24iLCJpc1BpbkZpeGVkIiwiaXNCYXNlRml4ZWQiLCJmaXJzdFBvc2l0aW9uUmVzdWx0IiwicGluRWxlbWVudFBvaW50cyIsIl9ub3JtYWxpemVQb3NpdGlvbiIsImJhc2VFbGVtZW50UG9pbnRzIiwicGluRWxlbWVudFBhcmVudE9mZnNldCIsIl9nZXRQYXJlbnRPZmZzZXQiLCJiYXNlRWxlbWVudE9mZnNldCIsIl9nZXRMZWZ0VG9wIiwiX3NldFBpbkVsZW1lbnRQb3N0aW9uIiwiX2lzSW5WaWV3cG9ydCIsImluVmlld3BvcnRMZWZ0IiwiX21ha2VFbGVtZW50SW5WaWV3cG9ydCIsImluVmlld3BvcnRUb3AiLCJfZ2V0RWxlbWVudE9mZnNldCIsImRvY0VsZW1lbnQiLCJNYXRoIiwibWF4IiwicG9pbnRzIiwiX25vcm1hbGl6ZUVsZW1lbnQiLCJfbm9ybWFsaXplWFkiLCJfeHlDb252ZXJ0ZXIiLCJtIiwiaXNWaWV3cG9ydCIsImRvY0NsaWVudExlZnQiLCJjbGllbnRMZWZ0IiwiZG9jQ2xpZW50VG9wIiwiY2xpZW50VG9wIiwiX3JlcGxhY2VBbGlnbkRpciIsImwiLCJyIiwidCIsImMiLCJyZWdFeHAiLCJ2aWV3cG9ydFNpemUiLCJlbGVtZW50UmVjdCIsInBvc3Rpb24iLCJvZmZzZXRQYXJlbnRXaWR0aCIsImRlZmF1bHRWaXNpYmxlIiwiaGFuZGxlVmlzaWJsZUNoYW5nZSIsImhhbmRsZVRyaWdnZXJDbGljayIsImNhbkNsb3NlQnlUcmlnZ2VyIiwiaGFuZGxlVHJpZ2dlcktleURvd24iLCJoYW5kbGVUcmlnZ2VyTW91c2VFbnRlciIsIl9tb3VzZU5vdEZpcnN0T25NYXNrIiwiX2hpZGVUaW1lciIsIl9zaG93VGltZXIiLCJkZWxheSIsImhhbmRsZVRyaWdnZXJNb3VzZUxlYXZlIiwiaGFuZGxlVHJpZ2dlckZvY3VzIiwiaGFuZGxlVHJpZ2dlckJsdXIiLCJfaXNGb3J3YXJkQ29udGVudCIsImhhbmRsZUNvbnRlbnRNb3VzZURvd24iLCJoYW5kbGVDb250ZW50TW91c2VFbnRlciIsImhhbmRsZUNvbnRlbnRNb3VzZUxlYXZlIiwiaGFuZGxlTWFza01vdXNlRW50ZXIiLCJoYW5kbGVNYXNrTW91c2VMZWF2ZSIsImhhbmRsZVJlcXVlc3RDbG9zZSIsInJlbmRlclRyaWdnZXIiLCJ0cmlnZ2VyVHlwZXMiLCJyZW5kZXJDb250ZW50Iiwib25Nb3VzZURvd24iLCJyZW5kZXJQb3J0YWwiLCJmb2xsb3dUcmlnZ2VyIiwiZmluZFRyaWdnZXJOb2RlIiwiRHJvcGRvd24iLCJnZXRWaXNpYmxlIiwib25NZW51Q2xpY2siLCJoYW5kbGVNb3VzZUVudGVyIiwiaGFuZGxlTW91c2VMZWF2ZSIsInBhc3NQYXJlbnRUb0NoaWxkcmVuIiwicmVuZGVySW5saW5lIiwic3ViTWVudUNvbnRlbnRDbGFzc05hbWUiLCJwcm9wc1RyaWdnZXJUeXBlIiwibGlQcm9wcyIsImFycm9yUHJvcHMiLCJTZWxlY3RhYmVsSXRlbSIsIm5ld1N1Yk1lbnVDb250ZW50Q2xhc3NOYW1lIiwic3ViTWVudSIsIm5ld01vZGUiLCJfYWRkQ2xhc3MiLCJfcmVtb3ZlQ2xhc3MiLCJfdGhpcyRnZXRDbGFzc05hbWVzIiwiZ2V0Q2xhc3NOYW1lcyIsInJlbW92ZUNsYXNzZXMiLCJfdGhpcyRnZXRDbGFzc05hbWVzMiIsImFjdGl2ZUNsYXNzTmFtZSIsInJlZmxvd0FuZEFkZENsYXNzIiwiX3RoaXMkZ2V0Q2xhc3NOYW1lczMiLCJkb25lQ2xhc3NOYW1lIiwiX3RoaXMkZ2V0Q2xhc3NOYW1lczQiLCJfdGhpcyRnZXRDbGFzc05hbWVzNSIsIl90aGlzJGdldENsYXNzTmFtZXM2IiwiX3RoaXMkZ2V0Q2xhc3NOYW1lczciLCJfaGFzQ2xhc3MiLCJzZXRBdHRyaWJ1dGUiLCJiYXNlVmFsIiwib3JpZ0NsYXNzIiwiY2xhc3NUb1JlbW92ZSIsImNvdW50IiwiX2FyZ3MiLCJfbGVuMiIsIl9rZXkyIiwiaGFuZGxlTGlmZWN5Y2xlIiwiaGFuZGxlRW50ZXJpbmciLCJfbGVuMyIsIl9rZXkzIiwiaGFuZGxlRW50ZXJlZCIsIl9sZW40IiwiX2tleTQiLCJoYW5kbGVFeGl0IiwiX2xlbjUiLCJfa2V5NSIsImhhbmRsZUV4aXRpbmciLCJfbGVuNiIsIl9rZXk2IiwiX2xlbjciLCJfa2V5NyIsImlkeCIsIm9yaWdpbmFsQXJncyIsIl9jaGlsZCRwcm9wcyIsImluUHJvcCIsIl9SZWFjdCRDaGlsZHJlbiR0b0FyciIsIm1lcmdlQ2hpbGRNYXBwaW5ncyIsIm1hcEZuIiwibWFwcGVyIiwiZ2V0VmFsdWVGb3JLZXkiLCJuZXh0S2V5c1BlbmRpbmciLCJwZW5kaW5nS2V5cyIsImNoaWxkTWFwcGluZyIsInBlbmRpbmdOZXh0S2V5IiwiZ2V0UHJvcCIsInByb3AiLCJuZXh0Q2hpbGRNYXBwaW5nIiwiaGFzUHJldiIsImhhc05leHQiLCJwcmV2Q2hpbGQiLCJpc0xlYXZpbmciLCJBbmltYXRlQ2hpbGQiLCJlbmRMaXN0ZW5lcnMiLCJ0cmFuc2l0aW9uZW5kIiwiYW5pbWF0aW9uZW5kIiwibGlzdGVuZXIiLCJnZW5lcmF0ZUVuZExpc3RlbmVyIiwiZW5kTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJ0cmFuc2l0aW9uRW5kTGlzdGVuZXIiLCJhbmltYXRpb25FbmRMaXN0ZW5lciIsInRyYW5zaXRpb25EZWxheSIsInRyYW5zaXRpb25EdXJhdGlvbiIsInJlbW92ZUVuZHRMaXN0ZW5lciIsInRyYW5zaXRpb25PZmYiLCJhbmltYXRpb25PZmYiLCJyZW1vdmVDbGFzc05hbWVzIiwiaXNBcHBlYXJpbmciLCJob29rIiwib25BcHBlYXJpbmciLCJvbkFwcGVhcmVkIiwibGVhdmluZyIsImNhY2hlQ3VycmVudFN0eWxlIiwiY2FjaGVDb21wdXRlZFN0eWxlIiwic2V0Q3VycmVudFN0eWxlVG9aZXJvIiwic2V0Q3VycmVudFN0eWxlVG9Db21wdXRlZFN0eWxlIiwicmVzdG9yZUN1cnJlbnRTdHlsZSIsInN0eWxlQm9yZGVyVG9wV2lkdGgiLCJib3JkZXJUb3BXaWR0aCIsInN0eWxlUGFkZGluZ1RvcCIsInBhZGRpbmdUb3AiLCJzdHlsZUhlaWdodCIsInN0eWxlUGFkZGluZ0JvdHRvbSIsInBhZGRpbmdCb3R0b20iLCJzdHlsZUJvcmRlckJvdHRvbVdpZHRoIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJuZXdBbmltYXRpb24iLCJjaGVja2JveERpc2FibGVkIiwiQ2hlY2tib3hHcm91cCIsImN1cnJlbnRWYWx1ZSIsInZhbFRlbXAiLCJpdGVtRGlyZWN0aW9uIiwib3B0aW9uIiwiaXNCdXR0b25TaGFwZSIsIm5ld0NoaWxkQ2xhc3NOYW1lIiwibWVudSIsIm1lbnVJbnN0YW5jZSIsIkNvbnRleHRNZW51IiwiZ2V0T3ZlcmxheSIsImhhbmRsZU92ZXJsYXlDbG9zZSIsImNsaWNrZWRQb3B1cE1lbnUiLCJvdmVybGF5UHJvcHMiLCJoYW5kbGVPdmVybGF5T3BlbiIsIm5ld092ZXJsYXlQcm9wcyIsIm1lbnVQcm9wcyIsImRlc3Ryb3kiLCJkaXYiLCJjbG9zZUNoYWluIiwibmV3Q29udGV4dCIsIm1hcEljb25TaXplIiwibGFyZ2UiLCJtZWRpdW0iLCJzbWFsbCIsIm9uTW91c2VVcCIsImJ1dHRvbiIsImJsdXIiLCJidXR0b25SZWZIYW5kbGVyIiwiaHRtbFR5cGUiLCJpY29uU2l6ZSIsImdob3N0VHlwZSIsImJ0bkNscyIsImNsb25lZENoaWxkcmVuIiwiaWNvbkNscyIsInRhZ0F0dHJzIiwiaHJlZiIsImdyb3VwQ2xzIiwiY2xvbmVDaGlsZHJlbiIsImxhc3RQYWdlWCIsInBhZ2VYIiwib25Nb3VzZU1vdmUiLCJ1blNlbGVjdCIsImNoYW5nZWRQYWdlWCIsImRlc3RvcnkiLCJ1c2VyU2VsZWN0IiwiY3Vyc29yIiwicmVtb3ZlQXR0cmlidXRlIiwiVCIsIkJhc2VDb21wb25lbnQiLCJUcmVlVGFibGUiLCJvblRyZWVOb2RlQ2xpY2siLCJkcyIsImdldENoaWxkcmVuS2V5QnlJZCIsImlkcyIsIm9wZW5UcmVlUm93S2V5cyIsInRyZWVTdGF0dXMiLCJnZXRUcmVlTm9kZVN0YXR1cyIsIm5vcm1hbGl6ZURhdGFTb3VyY2UiLCJfX2xldmVsIiwib3BlbktleSIsIlRyZWVSb3ciLCJUcmVlQ2VsbCIsImhpZGRlbiIsIm9wZW5lZCIsImV4cGFuZGVkS2V5ZG93biIsInRyZWVBcnJvd05vZGVJbmRleCIsImZpcnN0Q2VsbFN0eWxlIiwidHJlZUFycm93Tm9kZSIsInRyZWVBcnJvd1R5cGUiLCJwYWRkaW5nTGVmdCIsImhhc0V4cGFuZGVkIiwiRml4ZWRUYWJsZSIsImNoYXJBdCIsInN1YnN0ciIsImlubmVySGVhZGVyTm9kZSIsImhlYWRlck5vZGUiLCJzY3JvbGxUbyIsImJvZHlOb2RlIiwiYWRqdXN0Rml4ZWRIZWFkZXJTaXplIiwidW5pcXVlIiwiYXJyIiwidGVtcCIsIlNlbGVjdGlvblRhYmxlIiwicmVuZGVyU2VsZWN0aW9uSGVhZGVyIiwic2VsZWN0QWxsUm93IiwiZmxhdERhdGFTb3VyY2UiLCJnZXRQcm9wcyIsInJlbmRlclNlbGVjdGlvbkJvZHkiLCJzZWxlY3RPbmVSb3ciLCJyZWNvcmRzIiwib25TZWxlY3RBbGwiLCJ0cmlnZ2VyU2VsZWN0aW9uIiwibGlzdEhlYWRlciIsIkV4cGFuZGVkVGFibGUiLCJvbkV4cGFuZGVkQ2xpY2siLCJyZW5kZXJFeHBhbmRlZENlbGwiLCJzd2l0Y2hOb2RlIiwidG9BcnJheUNoaWxkcmVuIiwiaXRlbUNvcHkiLCJWaXJ0dWFsVGFibGUiLCJzY3JvbGxUb1JvdyIsImxhc3RTY3JvbGxUb3AiLCJzdGFydCIsImNvbXB1dGVTY3JvbGxUb1JvdyIsImdldEJvZHlOb2RlIiwiaW5zdGFuY2UiLCJvblZpcnR1YWxTY3JvbGwiLCJib2R5SGVpZ2h0IiwiY29tcHV0ZUJvZHlIZWlnaHQiLCJpbm5lclRvcCIsImNvbXB1dGVJbm5lclRvcCIsImhhc1ZpcnR1YWxEYXRhIiwiYWRqdXN0U2Nyb2xsVG9wIiwiYWRqdXN0U2l6ZSIsInJlQ29tcHV0ZVNpemUiLCJnZXRSb3dOb2RlIiwicm93Q2xpZW50SGVpZ2h0IiwiZ2V0VmlzaWJsZVJhbmdlIiwiRXhwZWN0U3RhcnQiLCJ2aXNpYmxlQ291bnQiLCJtaW4iLCJ2aXJ0dWFsU2Nyb2xsTm9kZSIsInRhYmxlSW5jIiwidGFibGVOb2RlIiwiaGVhZGVyQ2xpZW50V2lkdGgiLCJsZWZ0Tm9kZSIsImJvZHlMZWZ0Tm9kZSIsInJpZ2h0Tm9kZSIsImJvZHlSaWdodE5vZGUiLCJoYXNTY3JvbGxiYXIiLCJWaXJ0dWFsQm9keSIsInRhYmxlUmVmIiwidmlydHVhbFNjcm9sbFJlZiIsInZpcnR1YWxTY3JvbGwiLCJvbkxvY2tCb2R5U2Nyb2xsIiwiZ2V0TG9ja05vZGUiLCJMb2NrVGFibGUiLCJpc0xvY2siLCJsZWZ0Um93IiwicmlnaHRSb3ciLCJvbkxvY2tCb2R5V2hlZWwiLCJkZWx0YVkiLCJsb2NrTGVmdEJvZHkiLCJzY3JvbGxOb2RlIiwibG9ja1JpZ2h0Qm9keSIsIm5ld1Njcm9sbFRvcCIsImxvY2tSaWdodFRhYmxlIiwibG9ja0xlZnRUYWJsZSIsInNoYWRvd0NsYXNzTmFtZSIsInNjcm9sbFdpZHRoIiwibG9ja0xlZnRDaGlsZHJlbiIsImxvY2tSaWdodENoaWxkcmVuIiwic2Nyb2xsIiwiX2lzTG9jayIsInNwbGl0Q2hpbGRyZW4iLCJzcGxpdEZyb21Ob3JtYWxpemVDaGlsZHJlbiIsIm1lcmdlRnJvbVNwbGl0TG9ja0NoaWxkcmVuIiwib3JpZ2luQ2hpbGRyZW4iLCJkZWVwQ29weSIsImxvY2tDaGlsZHJlbiIsImNvbmRpdGlvbiIsInNjcm9sbFRvQ29sIiwiY29sQ2VsbE5vZGUiLCJnZXRDZWxsTm9kZSIsInJvd0NlbGxOb2RlIiwiYm9keU5vZGVPZmZzZXQiLCJjZWxsTm9kZW9mZnNldCIsImlzT3JpZ2luTG9jayIsImFkanVzdElmVGFibGVOb3ROZWVkTG9jayIsImFkanVzdEhlYWRlclNpemUiLCJhZGp1c3RCb2R5U2l6ZSIsImFkanVzdENlbGxTaXplIiwiY29uZmlnV2lkdGhzIiwibG9ja0xlZnRMZW4iLCJsb2NrUmlnaHRMZW4iLCJfbm90TmVlZEFkanVzdExvY2tMZWZ0IiwiX25vdE5lZWRBZGp1c3RMb2NrUmlnaHQiLCJsb2NrUmlnaHRCb2R5V3JhcHBlciIsImhhc0hvelNjcm9sbCIsImhhc1ZlclNjcm9sbCIsImxvY2tCb2R5SGVpZ2h0IiwibGFzdEluZGV4IiwiaGVhZGVyUmlnaHRSb3ciLCJnZXRIZWFkZXJDZWxsTm9kZSIsImhlYWRlckxlZnRSb3ciLCJoZWFkZXJSaWdodExvY2tSb3ciLCJoZWFkZXJMZWZ0TG9ja1JvdyIsIm1heFJpZ2h0Um93SGVpZ2h0IiwidGFibGVSaWdodEluYyIsInVwZGF0ZVBvc2l0aW9uIiwibWF4TGVmdFJvd0hlaWdodCIsInRhYmxlTGVmdEluYyIsImxvY2tMZWZ0Um93IiwibG9ja1JpZ2h0Um93IiwiZ2V0Rmlyc3ROb3JtYWxDZWxsTm9kZSIsImxvY2tMZWZ0SGVpZ2h0IiwibG9ja1JpZ2h0SGVpZ2h0Iiwibm9ybWFsaXplZENoaWxkcmVuIiwiTG9ja0JvZHkiLCJMb2NrSGVhZGVyIiwiTG9ja1dyYXBwZXIiLCJjb3B5IiwibmV3SXRlbSIsIm9uQm9keVdoZWVsIiwiTGlzdFRhYmxlIiwibGlzdEZvb3RlciIsImlzTGlzdCIsIkxpc3RSb3ciLCJMaXN0Qm9keSIsIkdyb3VwTGlzdFJvdyIsInJlbmRlckNoaWxkcmVuIiwiaXNDaGlsZHJlblNlbGVjdGlvbiIsImlzU2VsZWN0aW9uIiwiY2VsbHMiLCJzaGlmdCIsImNhbWVUeXBlIiwibGlzdE5vZGUiLCJTdGlja3lUYWJsZSIsIlN0aWNreUhlYWRlciIsIlN0aWNrSGVhZGVyIiwibmV3QWZmaXhQcm9wcyIsIkFmZml4IiwiX3VwZGF0ZU5vZGVQb3NpdGlvbiIsInVzZUFic29sdXRlIiwiYWZmaXhDb250YWluZXIiLCJjb250YWluZXJTY3JvbGxUb3AiLCJhZmZpeE9mZnNldCIsIl9nZXRPZmZzZXQiLCJhZmZpeE5vZGUiLCJjb250YWluZXJIZWlnaHQiLCJhZmZpeEhlaWdodCIsImNvbnRhaW5lclJlY3QiLCJhZmZpeENoaWxkSGVpZ2h0IiwiYWZmaXhDaGlsZE5vZGUiLCJhZmZpeE1vZGUiLCJhZmZpeFN0eWxlIiwiY29udGFpbmVyU3R5bGUiLCJfc2V0QWZmaXhTdHlsZSIsIl9zZXRDb250YWluZXJTdHlsZSIsIl9hZmZpeE5vZGVSZWZIYW5kbGVyIiwiX2FmZml4Q2hpbGROb2RlUmVmSGFuZGxlciIsIl9nZXRBZmZpeE1vZGUiLCJfc2V0RXZlbnRIYW5kbGVyRm9yQ29udGFpbmVyIiwiX3JlbW92ZUV2ZW50SGFuZGxlckZvckNvbnRhaW5lciIsImdldENvbnRhaW5lciIsIm9mZnNldEJvdHRvbSIsImFmZml4ZWQiLCJvbkFmZml4IiwiYWZmaXhSZWN0IiwiY29udGFpbmVyU2Nyb2xsTGVmdCIsImNvbWJpbmVkU3R5bGUiLCJnZXRTY3JvbGwiLCJnZXRSZWN0IiwiZ2V0Tm9kZUhlaWdodCIsImlzVmVydGljYWwiLCJ3aW5kb3dQcm9wIiwiZWxlbWVudFByb3AiLCJpbm5lckhlaWdodCIsImxvY2FscyIsImhvdCIsImFjY2VwdCIsIm5ld0NvbnRlbnQiLCJkaXNwb3NlIiwiY3NzIiwiYmFzZVVybCIsInByb3RvY29sIiwiaG9zdCIsImN1cnJlbnREaXIiLCJwYXRobmFtZSIsImZpeGVkQ3NzIiwiZnVsbE1hdGNoIiwib3JpZ1VybCIsInVucXVvdGVkT3JpZ1VybCIsIm8iLCJuZXdVcmwiLCJBcHBIZWFkZXIiLCJBcHAiLCJvblJvd0NoYW5nZSIsIlJlYWN0RE9NIiwiY29tcG9uZW50RGVzYyIsImNvbXBvbmVudEJvZHkiLCJyZWxvYWRpbmciXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSw4Qjs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7OztBQU9BLElBQUlBLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxNQUFJQyxxQkFBc0IsT0FBT0MsTUFBUCxLQUFrQixVQUFsQixJQUN4QkEsT0FBT0MsR0FEaUIsSUFFeEJELE9BQU9DLEdBQVAsQ0FBVyxlQUFYLENBRnVCLElBR3ZCLE1BSEY7O0FBS0EsTUFBSUMsaUJBQWlCLFNBQWpCQSxjQUFpQixDQUFTQyxNQUFULEVBQWlCO0FBQ3BDLFdBQU8sUUFBT0EsTUFBUCx5Q0FBT0EsTUFBUCxPQUFrQixRQUFsQixJQUNMQSxXQUFXLElBRE4sSUFFTEEsT0FBT0MsUUFBUCxLQUFvQkwsa0JBRnRCO0FBR0QsR0FKRDs7QUFNQTtBQUNBO0FBQ0EsTUFBSU0sc0JBQXNCLElBQTFCO0FBQ0FDLFNBQU9DLE9BQVAsR0FBaUJDLG1CQUFPQSxDQUFDLEVBQVIsRUFBcUNOLGNBQXJDLEVBQXFERyxtQkFBckQsQ0FBakI7QUFDRCxDQWhCRCxNQWdCTztBQUNMO0FBQ0E7QUFDQUMsU0FBT0MsT0FBUCxHQUFpQkMsbUJBQU9BLENBQUMsRUFBUixHQUFqQjtBQUNELEM7Ozs7Ozs7Ozs7Ozs7QUMzQkQ7O0lBQVlDLEk7O0FBQ1o7O0lBQVlDLEk7O0FBQ1o7O0lBQVlDLE87O0FBQ1o7O0lBQVlDLEs7O0FBQ1o7O0lBQVlDLEk7O0FBQ1o7O0lBQVlDLE87O0FBQ1o7O0lBQVlDLE87O0FBQ1o7O0lBQVlDLFE7O0FBQ1o7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QUFNQyxnQkFBZ0JwNUMsdUJBQXRCLGlCQUFzQkEsQ0FBdEI7QUFDQW81QywwQkFBMEIsK3NLQUExQkEsR0FBMEIsQ0FBMUJBOztBQWlGQSxJQUFJdnRELElBQUosRUFBZ0I7QUFDZEE7O0FBRUEsUUFBTXd0RCxZQUFZcjVDLHVCQUFsQixzQkFBa0JBLENBQWxCOztBQUVBLFFBQUksQ0FBQ3hSLE9BQUwscUJBQWlDO0FBQy9CM0Msb0NBQTRCLGtCQUFVO0FBQ3BDMkM7QUFDQSxnQkFBSWdmLFdBQUosU0FBd0I7QUFDdEI2ckM7QUFERixtQkFFTyxJQUFJN3JDLFdBQUosUUFBdUI7QUFDNUI2ckM7QUFDRDtBQU5IeHREO0FBUUQ7QUFDRixDIiwiZmlsZSI6Ii9Vc2Vycy96aGFvZ3VveWFuL2dpdGh1Yi9wdWIvZG9jcy90YWJsZS9kZW1vL2FkdmFuY2VkLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cuUmVhY3Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ3aW5kb3cuUmVhY3RcIlxuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkgMTAgMTEgMTIgMTMgMTQgMTUgMTYgMTcgMTggMTkgMjAgMjEgMjIiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIFN5bWJvbC5mb3IgJiZcbiAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgMHhlYWM3O1xuXG4gIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX3Byb3AtdHlwZXNAMTUuNi4yQHByb3AtdHlwZXMvaW5kZXguanMiLCJpbXBvcnQgKiBhcyBfZG9tIGZyb20gJy4vZG9tJztcbmltcG9ydCAqIGFzIF9lbnYgZnJvbSAnLi9lbnYnO1xuaW1wb3J0ICogYXMgX2V2ZW50cyBmcm9tICcuL2V2ZW50cyc7XG5pbXBvcnQgKiBhcyBfZnVuYyBmcm9tICcuL2Z1bmMnO1xuaW1wb3J0ICogYXMgX2xvZyBmcm9tICcuL2xvZyc7XG5pbXBvcnQgKiBhcyBfb2JqZWN0IGZyb20gJy4vb2JqZWN0JztcbmltcG9ydCAqIGFzIF9zdHJpbmcgZnJvbSAnLi9zdHJpbmcnO1xuaW1wb3J0ICogYXMgX3N1cHBvcnQgZnJvbSAnLi9zdXBwb3J0JztcbmltcG9ydCAqIGFzIF9mb2N1cyBmcm9tICcuL2ZvY3VzJztcbmltcG9ydCBfZ3VpZCBmcm9tICcuL2d1aWQnO1xuaW1wb3J0IF9LRVlDT0RFIGZyb20gJy4va2V5Y29kZSc7XG5cbmV4cG9ydCBjb25zdCBkb20gPSBfZG9tO1xuZXhwb3J0IGNvbnN0IGVudiA9IF9lbnY7XG5leHBvcnQgY29uc3QgZXZlbnRzID0gX2V2ZW50cztcbmV4cG9ydCBjb25zdCBmdW5jID0gX2Z1bmM7XG5leHBvcnQgY29uc3QgbG9nID0gX2xvZztcbmV4cG9ydCBjb25zdCBvYmogPSBfb2JqZWN0O1xuZXhwb3J0IGNvbnN0IHN0ciA9IF9zdHJpbmc7XG5leHBvcnQgY29uc3Qgc3VwcG9ydCA9IF9zdXBwb3J0O1xuZXhwb3J0IGNvbnN0IGZvY3VzID0gX2ZvY3VzO1xuZXhwb3J0IGNvbnN0IGd1aWQgPSBfZ3VpZDtcbmV4cG9ydCBjb25zdCBLRVlDT0RFID0gX0tFWUNPREU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbC9pbmRleC5qcyIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTcgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykgJiYgYXJnLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgaW5uZXIgPSBjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZyk7XG5cdFx0XHRcdGlmIChpbm5lcikge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChpbm5lcik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZykge1xuXHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzLmpvaW4oJyAnKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdGNsYXNzTmFtZXMuZGVmYXVsdCA9IGNsYXNzTmFtZXM7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fY2xhc3NuYW1lc0AyLjIuNkBjbGFzc25hbWVzL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cuUmVhY3RET007XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ3aW5kb3cuUmVhY3RET01cIlxuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkgMTAgMTEgMTIgMTMgMTQgMTUgMTYgMTcgMTggMTkgMjAgMjEgMjIiLCJpbXBvcnQgeyBDb21wb25lbnQsIENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBnZXRDb250ZXh0UHJvcHMgZnJvbSAnLi9nZXQtY29udGV4dC1wcm9wcyc7XG5pbXBvcnQge1xuICAgIGNvbmZpZyxcbiAgICBpbml0TG9jYWxlcyxcbiAgICBzZXRMYW5ndWFnZSxcbiAgICBzZXRMb2NhbGUsXG4gICAgc2V0RGlyZWN0aW9uLFxuICAgIGdldExvY2FsZSxcbiAgICBnZXRMYW5ndWFnZSxcbiAgICBnZXREaXJlY3Rpb25cbn0gZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IENvbnN1bWVyIGZyb20gJy4vY29uc3VtZXInO1xuaW1wb3J0IENhY2hlIGZyb20gJy4vY2FjaGUnO1xuXG5jb25zdCBjaGlsZENvbnRleHRDYWNoZSA9IG5ldyBDYWNoZSgpO1xuXG4vKipcbiAqIENvbmZpZ1Byb3ZpZGVyXG4gKiBAcHJvcHNFeHRlbmRzIGZhbHNlXG4gKi9cbmNsYXNzIENvbmZpZ1Byb3ZpZGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5qC35byP57G75ZCN55qE5ZOB54mM5YmN57yAXG4gICAgICAgICAqL1xuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlm73pmYXljJbmlofmoYjlr7nosaHvvIzlsZ7mgKfkuLrnu4Tku7bnmoQgZGlzcGxheU5hbWVcbiAgICAgICAgICovXG4gICAgICAgIGxvY2FsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuW8gOWQryBQdXJlIFJlbmRlciDmqKHlvI/vvIzkvJrmj5Dpq5jmgKfog73vvIzkvYbmmK/kuZ/kvJrluKbmnaXlia/kvZznlKhcbiAgICAgICAgICovXG4gICAgICAgIHB1cmU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5Zyo5byA5Y+R5qih5byP5LiL5pi+56S657uE5Lu25bGe5oCn6KKr5bqf5byD55qEIHdhcm5pbmcg5o+Q56S6XG4gICAgICAgICAqL1xuICAgICAgICB3YXJuaW5nOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuW8gOWQryBydGwg5qih5byPXG4gICAgICAgICAqL1xuICAgICAgICBydGw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog57uE5Lu25qCRXG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmVsZW1lbnRcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgd2FybmluZzogdHJ1ZVxuICAgIH07XG5cbiAgICBzdGF0aWMgY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIG5leHRQcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIG5leHRMb2NhbGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIG5leHRQdXJlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgbmV4dFJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIG5leHRXYXJuaW5nOiBQcm9wVHlwZXMuYm9vbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDkvKDlhaXnu4Tku7bvvIznlJ/miJDlj5cgQ29uZmlnUHJvdmlkZXIg5o6n5Yi255qEIEhPQyDnu4Tku7ZcbiAgICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gQ29tcG9uZW50IOe7hOS7tuexu1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIOWPr+mAiemhuVxuICAgICAqIEByZXR1cm5zIHtDb21wb25lbnR9IEhPQ1xuICAgICAqL1xuICAgIHN0YXRpYyBjb25maWcgPSAoQ29tcG9uZW50LCBvcHRpb25zKSA9PiB7XG4gICAgICAgIHJldHVybiBjb25maWcoQ29tcG9uZW50LCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5Lyg5YWl57uE5Lu255qEIHByb3BzIOWSjCBkaXNwbGF5TmFtZe+8jOW+l+WIsOWSjCBjaGlsZENvbnRleHQg6K6h566X6L+H55qE5YyF5ZCr5pyJIHByZWlmeC9sb2NhbGUvcHVyZSDnmoTlr7nosaHvvIzkuIDoiKznlKjkuo7pgJrov4fpnZnmgIHmlrnms5XnlJ/miJDohLHnprvnu4Tku7bmoJHnmoTnu4Tku7ZcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMg57uE5Lu255qEIHByb3BzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRpc3BsYXlOYW1lIOe7hOS7tueahCBkaXNwbGF5TmFtZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IOaWsOeahCBjb250ZXh0IHByb3BzXG4gICAgICovXG4gICAgc3RhdGljIGdldENvbnRleHRQcm9wcyA9IChwcm9wcywgZGlzcGxheU5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHRQcm9wcyhwcm9wcywgY2hpbGRDb250ZXh0Q2FjaGUucm9vdCgpIHx8IHt9LCBkaXNwbGF5TmFtZSk7XG4gICAgfTtcblxuICAgIHN0YXRpYyBpbml0TG9jYWxlcyA9IGluaXRMb2NhbGVzO1xuICAgIHN0YXRpYyBzZXRMYW5ndWFnZSA9IHNldExhbmd1YWdlO1xuICAgIHN0YXRpYyBzZXRMb2NhbGUgPSBzZXRMb2NhbGU7XG4gICAgc3RhdGljIHNldERpcmVjdGlvbiA9IHNldERpcmVjdGlvbjtcbiAgICBzdGF0aWMgZ2V0TGFuZ3VhZ2UgPSBnZXRMYW5ndWFnZTtcbiAgICBzdGF0aWMgZ2V0TG9jYWxlID0gZ2V0TG9jYWxlO1xuICAgIHN0YXRpYyBnZXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb247XG4gICAgc3RhdGljIENvbnN1bWVyID0gQ29uc3VtZXI7XG5cbiAgICBzdGF0aWMgZ2V0Q29udGV4dCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBuZXh0UHJlZml4LCBuZXh0TG9jYWxlLCBuZXh0UHVyZSwgbmV4dFJ0bCwgbmV4dFdhcm5pbmcgfSA9IGNoaWxkQ29udGV4dENhY2hlLnJvb3QoKSB8fCB7fTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlZml4OiBuZXh0UHJlZml4LFxuICAgICAgICAgICAgbG9jYWxlOiBuZXh0TG9jYWxlLFxuICAgICAgICAgICAgcHVyZTogbmV4dFB1cmUsXG4gICAgICAgICAgICBydGw6IG5leHRSdGwsXG4gICAgICAgICAgICB3YXJuaW5nOiBuZXh0V2FybmluZ1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBjaGlsZENvbnRleHRDYWNoZS5hZGQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgY2hpbGRDb250ZXh0Q2FjaGUuZ2V0KHRoaXMsIHt9KSwgdGhpcy5nZXRDaGlsZENvbnRleHQoKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBsb2NhbGUsIHB1cmUsIHdhcm5pbmcsIHJ0bCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dFByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgbmV4dExvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgbmV4dFB1cmU6IHB1cmUsXG4gICAgICAgICAgICBuZXh0UnRsOiBydGwsXG4gICAgICAgICAgICBuZXh0V2FybmluZzogd2FybmluZ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgdGhpcy5zZXRNb21lbnRMb2NhbGUodGhpcy5wcm9wcy5sb2NhbGUpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmxvY2FsZSAhPT0gbmV4dFByb3BzLmxvY2FsZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRNb21lbnRMb2NhbGUobmV4dFByb3BzLmxvY2FsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIGNoaWxkQ29udGV4dENhY2hlLmFkZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBjaGlsZENvbnRleHRDYWNoZS5nZXQodGhpcywge30pLCB0aGlzLmdldENoaWxkQ29udGV4dCgpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBjaGlsZENvbnRleHRDYWNoZS5yZW1vdmUodGhpcyk7XG4gICAgfVxuXG4gICAgc2V0TW9tZW50TG9jYWxlKGxvY2FsZSkge1xuICAgICAgICBsZXQgbW9tZW50O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vbWVudCAmJiBsb2NhbGUpIHtcbiAgICAgICAgICAgIG1vbWVudC5sb2NhbGUobG9jYWxlLm1vbWVudExvY2FsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBDaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlnUHJvdmlkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29uZmlnLXByb3ZpZGVyL2luZGV4LmpzeCIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0bWVtb1tzZWxlY3Rvcl0gPSBmbi5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWVtb1tzZWxlY3Rvcl1cblx0fTtcbn0pKGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KVxufSk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcyk7XG5cblx0ICAgIGlmIChyZXN1bHQpIHtcblx0ICAgIFx0Ly8gSWYgdHJhbnNmb3JtIHJldHVybnMgYSB2YWx1ZSwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXG5cdCAgICBcdG9iai5jc3MgPSByZXN1bHQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xuXHQgICAgXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICBcdFx0Ly8gbm9vcFxuXHQgICAgXHR9O1xuXHQgICAgfVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cblx0XHRzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cblx0fSBlbHNlIGlmIChcblx0XHRvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIlxuXHQpIHtcblx0XHRzdHlsZSA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblxuXHRcdFx0aWYoc3R5bGUuaHJlZikgVVJMLnJldm9rZU9iamVjdFVSTChzdHlsZS5ocmVmKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmopIHtcblx0XHRpZiAobmV3T2JqKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcblx0XHRcdFx0bmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcblx0XHRcdFx0bmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZS5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcblx0XHR9XG5cblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW5rIChsaW5rLCBvcHRpb25zLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdC8qXG5cdFx0SWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0XHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cblx0XHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpIHtcblx0XHRjc3MgPSBmaXhVcmxzKGNzcyk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGluay5ocmVmO1xuXG5cdGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKSBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDAuMTguMkBzdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkgMTAgMTEgMTIgMTMgMTQgMTUgMTYgMTcgMTggMTkgMjAgMjEgMjIiLCJjb25zdCBibGFja0xpc3QgPSBbJ2RlZmF1bHRQcm9wcycsICdwcm9wVHlwZXMnLCAnY29udGV4dFR5cGVzJywgJ2NoaWxkQ29udGV4dFR5cGVzJywgJ2Rpc3BsYXlOYW1lJ107XG5cbmV4cG9ydCBjb25zdCBzdGF0aWNzID0gKFRhcmdldCwgQ29tcG9uZW50KSA9PiB7XG4gICAgT2JqZWN0LmtleXMoQ29tcG9uZW50KS5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICAgICAgaWYgKGJsYWNrTGlzdC5pbmRleE9mKHByb3BlcnR5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIFRhcmdldFtwcm9wZXJ0eV0gPSBDb21wb25lbnRbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgZmV0Y2hEYXRhQnlQYXRoID0gKG9iamVjdCwgcGF0aCkgPT4ge1xuICAgIGlmICghb2JqZWN0IHx8ICFwYXRoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcGF0aCA9IHBhdGgudG9TdHJpbmcoKTtcbiAgICBjb25zdCBmaWVsZCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICBsZXQgdmFsLCBrZXk7XG4gICAgaWYgKGZpZWxkLmxlbmd0aCkge1xuICAgICAgICBrZXkgPSBmaWVsZFswXTtcbiAgICAgICAgLy8gbGlzdHNbMV0ubmFtZVxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoJ1snKSA+PSAwKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkubWF0Y2goLyguKilcXFsoLiopXFxdLyk7XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFsID0gb2JqZWN0W2tleVsxXV1ba2V5WzJdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9IG9iamVjdFtmaWVsZFswXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgY29sSW5kZXggPSAxOyBjb2xJbmRleCA8IGZpZWxkLmxlbmd0aDsgY29sSW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHZhbCA9IHZhbFtmaWVsZFtjb2xJbmRleF1dO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvdXRpbC5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IENvbmZpZ1Byb3ZpZGVyIGZyb20gJy4uL2NvbmZpZy1wcm92aWRlcic7XG5cbi8qKlxuICogSWNvblxuICovXG5jbGFzcyBJY29uIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmjIflrprmmL7npLrlk6rnp43lm77moIdcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmjIflrprlm77moIflpKflsI9cbiAgICAgICAgICovXG4gICAgICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3h4cycsICd4cycsICdzbWFsbCcsICdtZWRpdW0nLCAnbGFyZ2UnLCAneGwnLCAneHhsJywgJ3h4eGwnXSksXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgICAgICBzaXplOiAnbWVkaXVtJ1xuICAgIH07XG5cbiAgICBzdGF0aWMgX3R5cGVNYXJrID0gJ2ljb24nO1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyovXG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB0eXBlLCBzaXplLCBjbGFzc05hbWUsIHJ0bCwgLi4ub3RoZXIgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgY29uc3QgY2xhc3NlcyA9IGN4KHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9aWNvbmBdOiB0cnVlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1pY29uLSR7dHlwZX1gXTogISF0eXBlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH0ke3NpemV9YF06ICEhc2l6ZSxcbiAgICAgICAgICAgIFtjbGFzc05hbWVdOiAhIWNsYXNzTmFtZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocnRsICYmIFsnYXJyb3ctbGVmdCcsICdhcnJvdy1yaWdodCcsICdhcnJvdy1kb3VibGUtbGVmdCcsICdhcnJvdy1kb3VibGUtcmlnaHQnLCAnc3dpdGNoJywgJ3NvcnRpbmcnLCAnZGVzY2VuZGluZycsICdhc2NlbmRpbmcnXS5pbmRleE9mKHR5cGUpICE9PSAtMSkge1xuICAgICAgICAgICAgb3RoZXIuZGlyID0gJ3J0bCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gPGkgey4uLm90aGVyfSBjbGFzc05hbWU9e2NsYXNzZXN9IC8+O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlnUHJvdmlkZXIuY29uZmlnKEljb24pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2ljb24vaW5kZXguanN4IiwiaW1wb3J0ICcuL21haW4uc2Nzcyc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaWNvbi9zdHlsZS5qcyIsImltcG9ydCAnLi9tYWluLnNjc3MnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FuaW1hdGUvc3R5bGUuanMiLCIvKipcbiAqIOiOt+WPluWvueixoeeahOexu+Wei1xuICogQHBhcmFtICB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKlxuICogQGV4YW1wbGVcbiAqIHR5cGVPZihbXSkgPT09ICdBcnJheSdcbiAqIHR5cGVPZigpID09PSAnVW5kZWZpbmVkJ1xuICogdHlwZU9mKDEpID09PSAnTnVtYmVyJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gdHlwZU9mIChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikucmVwbGFjZSgvXFxbb2JqZWN0XFxzfF0vZywgJycpO1xufVxuXG4vKipcbiAqIOWIpOaWreaYr+WQpuaYr+aVsOe7hOaIluexu+aVsOe7hOWvueixoVxuICogQHBhcmFtICB7Kn0gIG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqXG4gKiBAZXhhbXBsZVxuICogaXNBcnJheUxpa2UoW10pID09PSB0cnVlXG4gKiBpc0FycmF5TGlrZShhcmd1bWVudHMpID09PSB0cnVlXG4gKiBpc0FycmF5TGlrZSh0aGlzLnByb3BzLmNoaWxkcmVuKSA9PT0gdHJ1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheUxpa2UgKG9iaikge1xuICAgIGNvbnN0IGxlbmd0aCA9ICEhb2JqICYmICdsZW5ndGgnIGluIG9iaiAmJiBvYmoubGVuZ3RoO1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlT2Yob2JqKTtcblxuICAgIHJldHVybiB0eXBlID09PSAnQXJyYXknIHx8IGxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAodHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuZ3RoID4gMCAmJiAobGVuZ3RoIC0gMSkgaW4gb2JqKTtcbn1cblxuLyoqXG4gKiDliKTmlq3lr7nosaHmmK/lkKbmmK/kuIDkuKpwcm9taXNl77yM5Y2z5piv5ZCm5Y+v5Lul55SoLnRoZW5cbiAqIEBwYXJhbSAgeyp9ICBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Byb21pc2UgKG9iaikge1xuICAgIHJldHVybiAhIW9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIOaYr+WQpuaYr+S4gOS4que6r+WHgOeahOWvueixoVxuICogQHBhcmFtICB7Kn0gIG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEByZWZlcmVuY2UgaHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtcGxhaW4tb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgICBpZiAodHlwZU9mKG9iaikgIT09ICdPYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKHR5cGVvZiBjdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm90ID0gY3Rvci5wcm90b3R5cGU7XG5cbiAgICBpZiAodHlwZU9mKHByb3QpICE9PSAnT2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFwcm90Lmhhc093blByb3BlcnR5KCdpc1Byb3RvdHlwZU9mJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIOWvueixoea1heavlOi+g1xuICogQHBhcmFtICB7T2JqZWN0fSBvYmpBXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iakJcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgW2NvbXBhcmVdIOaJi+WKqOiwg+eUqOaWueazleavlOi+g1xuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDlr7nosaHmtYXmr5TovoPmmK/lkKbnm7jnrYlcbiAqXG4gKiBAZXhhbXBsZVxuICogb2JqZWN0LnNoYWxsb3dFcXVhbCh7YTogMTAwfSwge2E6IDEwMH0pOyAvLyB0cnVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGFsbG93RXF1YWwgKG9iakEsIG9iakIsIGNvbXBhcmUpIHtcbiAgICBpZiAob2JqQSA9PT0gb2JqQikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyDlhbbkuK3kuIDkuKrkuI3mmK9vYmplY3TvvIzliJnkuI3nm7jnrYlcbiAgICBpZiAoIW9iakEgfHwgIW9iakIgfHwgKHR5cGVvZiBvYmpBICsgdHlwZW9mIG9iakIgIT09ICdvYmplY3RvYmplY3QnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5QSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICAgIGNvbnN0IGtleUIgPSBPYmplY3Qua2V5cyhvYmpCKTtcbiAgICBjb25zdCBsZW4gPSBrZXlBLmxlbmd0aDtcblxuICAgIC8vIGtleSDmlbDph4/kuI3kuIDoh7TliJnkuI3nm7jnrYlcbiAgICBpZiAobGVuICE9PSBrZXlCLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzQ2FsbGJhY2sgPSB0eXBlb2YgY29tcGFyZSA9PT0gJ2Z1bmN0aW9uJztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5QVtpXTtcblxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWxBID0gb2JqQVtrZXldO1xuICAgICAgICBjb25zdCB2YWxCID0gb2JqQltrZXldO1xuXG4gICAgICAgIGNvbnN0IHJldCA9IGhhc0NhbGxiYWNrID8gY29tcGFyZSh2YWxBLCB2YWxCLCBrZXkpIDogdm9pZCAwO1xuXG4gICAgICAgIGlmIChyZXQgPT09IGZhbHNlIHx8IHJldCA9PT0gdm9pZCAwICYmIHZhbEEgIT09IHZhbEIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIOmBjeWOhuWvueixoeaIluaVsOe7hO+8jOaIluiAheexu+aVsOe7hO+8jOS+i+WmglJlYWN05Lit55qEY2hpbGRyZW7lr7nosaHjgIFhcmd1bWVudHPnrYlcbiAqIEBwYXJhbSAge09iamVjdHxBcnJheX0gICBvYmpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayBmbihuLCBpKSBvciBmbih2YWwsIGtleSlcbiAqIEBwYXJhbSAge051bWJlcn0gICBbZGlyZWN0aW9uID0gMV0g5piv5ZCm5YCS5bqP6YGN5Y6G77yM5Y+q5a+55pWw57uE5pyJ5pWIXG4gKiBAcmV0dXJuIHtPYmplY3R8QXJyYXl9XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIOmBjeWOhuaVsOe7hFxuICogb2JqZWN0LmVhY2goWzEwMCwgMjAwLCAzMDBdLCAobiwgaSkgPT4gY29uc29sZS5sb2cobiwgaSkpO1xuICogLy8g6YGN5Y6GanNvbuWvueixoVxuICogb2JqZWN0LmVhY2goe2E6IDEwMCwgYjogMjAwfSwgKHZhbHVlLCBrZXkpID0+IGNvbnNvbGUubG9nKGtleSwgdmFsdWUpKTtcbiAqIC8vIOmBjeWOhlJlYWN05a2Q6IqC54K5XG4gKiBvYmplY3QuZWFjaCh0aGlzLnByb3BzLmNoaWxkcmVuLCAoY2hpbGQsIGluZGV4KSA9PiBjb25zb2xlLmxvZyhjaGlsZCkpO1xuICogLy8g6YGN5Y6GYXJndW1lbnRzXG4gKiBvYmplY3QuZWFjaChhcmd1bWVudHMsIChhcmcsIGkpID0+IGNvbnNvbGUubG9nKGFyZykpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gZWFjaCAob2JqLCBjYWxsYmFjaywgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgcmV2ZXJzZWQgPSBkaXJlY3Rpb24gPT09IC0xO1xuICAgIGNvbnN0IGxlbmd0aCA9IG9iai5sZW5ndGg7XG4gICAgbGV0IHZhbHVlLFxuICAgICAgICBpID0gcmV2ZXJzZWQgPyBsZW5ndGggLSAxIDogMDtcblxuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoICYmIGkgPj0gMDsgcmV2ZXJzZWQgPyBpLS0gOiBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmpbaV0sIG9ialtpXSwgaSk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9ialtpXSwgb2JqW2ldLCBpKTtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn1cblxuLy8gQHByaXZhdGUg5Yik5pata2V55piv5ZCm5Zyo5pWw57uE5oiW5a+56LGh5LitXG5jb25zdCBfaXNJbk9iaiA9IChrZXksIG9iaiwgaXNBcnJheSkgPT4gaXNBcnJheSA/IChvYmouaW5kZXhPZihrZXkpID4gLTEpICA6IChrZXkgaW4gb2JqKTtcblxuLyoqXG4gKiDov4fmu6Tlh7rlhbblroPlsZ7mgKdcbiAqIEBwYXJhbSAge09iamVjdHxBcnJheX0gaG9sZFByb3BzIOi/h+a7pOeahOWPgueFp+Wvueixoe+8jOacgOe7iOeahOe7k+aenOWPquS/neeVmeS4jeWcqOWPgueFp+WvueixoeS4reeahGtleVxuICogQHBhcmFtICB7T2JqZWN0fSBwcm9wcyAgICAg6KKr6L+H5ruk55qE5a+56LGhXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICBvdGhlcnNcbiAqXG4gKiBAZXhhbXBsZVxuICogb2JqZWN0LnBpY2tPdGhlcnMoRm9vQ29tcG9uZW50LnByb3BUeXBlcywgdGhpcy5wcm9wcyk7XG4gKiBvYmplY3QucGlja090aGVycyhbJ2NsYXNzTmFtZScsICdvbkNoYW5nZSddLCB0aGlzLnByb3BzKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBpY2tPdGhlcnMgKGhvbGRQcm9wcywgcHJvcHMpIHtcbiAgICBjb25zdCBvdGhlcnMgPSB7fTtcbiAgICBjb25zdCBpc0FycmF5ID0gdHlwZU9mKGhvbGRQcm9wcykgPT09ICdBcnJheSc7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICBpZiAoIV9pc0luT2JqKGtleSwgaG9sZFByb3BzLCBpc0FycmF5KSkge1xuICAgICAgICAgICAgb3RoZXJzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG90aGVycztcbn1cblxuLyoqXG4gKiDov4fmu6Tlh7rluKZwcmVmaXjnmoTlsZ7mgKdcbiAqIEBwYXJhbSAge09iamVjdH0gaG9sZFByb3BzIOi/h+a7pOeahOWPgueFp+Wvueixoe+8jOacgOe7iOeahOe7k+aenOWPquS/neeVmeS4jeWcqOWPgueFp+WvueixoeS4reeahGtleVxuICogQHBhcmFtICB7c3RyaW5nfSBwcmVmaXggICAg5YyF5ZCr55qE5a2X56ym5LiyXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICBvdGhlcnNcbiAqXG4gKiBAZXhhbXBsZVxuICogb2JqZWN0LnBpY2tBdHRyc1dpdGgoRm9vQ29tcG9uZW50LnByb3BUeXBlcywgJ2RhdGEtJyk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwaWNrQXR0cnNXaXRoIChob2xkUHJvcHMsIHByZWZpeCkge1xuICAgIGNvbnN0IG90aGVycyA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gaG9sZFByb3BzKSB7XG4gICAgICAgIGlmIChrZXkubWF0Y2gocHJlZml4KSkge1xuICAgICAgICAgICAgb3RoZXJzW2tleV0gPSBob2xkUHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdGhlcnM7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbC9vYmplY3QuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBDaGlsZHJlbiwgaXNWYWxpZEVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmaW5kRE9NTm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgZnVuYywgb2JqIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5cbmNvbnN0IHsgYmluZEN0eCB9ID0gZnVuYztcbmNvbnN0IHsgcGlja090aGVycyB9ID0gb2JqO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJdGVtIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBfa2V5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBsZXZlbDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgZ3JvdXBJbmRlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIHJvb3Q6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIHBhcmVudDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgcGFyZW50TW9kZTogUHJvcFR5cGVzLm9uZU9mKFsnaW5saW5lJywgJ3BvcHVwJ10pLFxuICAgICAgICB0eXBlOiBQcm9wVHlwZXMub25lT2YoWydzdWJtZW51JywgJ2l0ZW0nXSksXG4gICAgICAgIGNvbXBvbmVudDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbktleURvd246IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBuZWVkSW5kZW50OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgcmVwbGFjZUNsYXNzTmFtZTogUHJvcFR5cGVzLmJvb2xcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBjb21wb25lbnQ6ICdsaScsXG4gICAgICAgIGdyb3VwSW5kZW50OiAwLFxuICAgICAgICByZXBsYWNlQ2xhc3NOYW1lOiBmYWxzZSxcbiAgICAgICAgbmVlZEluZGVudDogdHJ1ZVxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgYmluZEN0eCh0aGlzLCBbJ2hhbmRsZUNsaWNrJywgJ2hhbmRsZUtleURvd24nXSk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuaXRlbU5vZGUgPSBmaW5kRE9NTm9kZSh0aGlzKTtcblxuICAgICAgICBjb25zdCB7IHBhcmVudE1vZGUsIHJvb3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChwYXJlbnRNb2RlID09PSAncG9wdXAnKSB7XG4gICAgICAgICAgICB0aGlzLm1lbnVOb2RlID0gdGhpcy5pdGVtTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZW51Tm9kZSA9IGZpbmRET01Ob2RlKHJvb3QpO1xuICAgICAgICAgICAgY29uc3QgeyBwcmVmaXgsIGhlYWRlciwgZm9vdGVyIH0gPSByb290LnByb3BzO1xuICAgICAgICAgICAgaWYgKGhlYWRlciB8fCBmb290ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lbnVOb2RlID0gdGhpcy5tZW51Tm9kZS5xdWVyeVNlbGVjdG9yKGAuJHtwcmVmaXh9bWVudS1jb250ZW50YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEZvY3VzKCk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLnNldEZvY3VzKCk7XG4gICAgfVxuXG4gICAgZm9jdXNhYmxlKCkge1xuICAgICAgICBjb25zdCB7IHJvb3QsIHR5cGUsIGRpc2FibGVkIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IGZvY3VzYWJsZSB9ID0gcm9vdC5wcm9wcztcbiAgICAgICAgcmV0dXJuIGZvY3VzYWJsZSAmJiAodHlwZSA9PT0gJ3N1Ym1lbnUnIHx8ICFkaXNhYmxlZCk7XG4gICAgfVxuXG4gICAgZ2V0Rm9jdXNlZCgpIHtcbiAgICAgICAgY29uc3QgeyBfa2V5LCByb290IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IGZvY3VzZWRLZXkgfSA9IHJvb3Quc3RhdGU7XG4gICAgICAgIHJldHVybiBmb2N1c2VkS2V5ID09PSBfa2V5O1xuICAgIH1cblxuICAgIHNldEZvY3VzKCkge1xuICAgICAgICBjb25zdCBmb2N1c2VkID0gdGhpcy5nZXRGb2N1c2VkKCk7XG4gICAgICAgIGlmIChmb2N1c2VkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb2N1c2FibGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbU5vZGUuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubWVudU5vZGUgJiYgdGhpcy5tZW51Tm9kZS5zY3JvbGxIZWlnaHQgPiB0aGlzLm1lbnVOb2RlLmNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcm9sbEJvdHRvbSA9IHRoaXMubWVudU5vZGUuY2xpZW50SGVpZ2h0ICsgdGhpcy5tZW51Tm9kZS5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUJvdHRvbSA9IHRoaXMuaXRlbU5vZGUub2Zmc2V0VG9wICsgdGhpcy5pdGVtTm9kZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1Cb3R0b20gPiBzY3JvbGxCb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW51Tm9kZS5zY3JvbGxUb3AgPSBpdGVtQm90dG9tIC0gdGhpcy5tZW51Tm9kZS5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLml0ZW1Ob2RlLm9mZnNldFRvcCA8IHRoaXMubWVudU5vZGUuc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVudU5vZGUuc2Nyb2xsVG9wID0gdGhpcy5pdGVtTm9kZS5vZmZzZXRUb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlQ2xpY2soZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGNvbnN0IHsgX2tleSwgcm9vdCwgZGlzYWJsZWQgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICAgICAgcm9vdC5oYW5kbGVJdGVtQ2xpY2soX2tleSwgdGhpcywgZSk7XG5cbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DbGljayAmJiB0aGlzLnByb3BzLm9uQ2xpY2soZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVLZXlEb3duKGUpIHtcbiAgICAgICAgY29uc3QgeyBfa2V5LCByb290LCB0eXBlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAodGhpcy5mb2N1c2FibGUoKSkge1xuICAgICAgICAgICAgcm9vdC5oYW5kbGVJdGVtS2V5RG93bihfa2V5LCB0eXBlLCB0aGlzLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJvcHMub25LZXlEb3duICYmIHRoaXMucHJvcHMub25LZXlEb3duKGUpO1xuICAgIH1cblxuICAgIGdldFRpdGxlKGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBsYWJlbFN0cmluZyA9ICcnO1xuXG4gICAgICAgIGNvbnN0IGxvb3AgPSBjaGlsZHJlbiA9PiB7XG4gICAgICAgICAgICBDaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSAmJiAgY2hpbGQucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbG9vcChjaGlsZC5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsU3RyaW5nICs9IGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGxvb3AoY2hpbGRyZW4pO1xuXG4gICAgICAgIHJldHVybiBsYWJlbFN0cmluZztcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgbGV2ZWwsIHJvb3QsIHJlcGxhY2VDbGFzc05hbWUsIGdyb3VwSW5kZW50LCBjb21wb25lbnQsIGRpc2FibGVkLCBjbGFzc05hbWUsIGNoaWxkcmVuLCBuZWVkSW5kZW50LCBwYXJlbnRNb2RlLCBfa2V5IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBvdGhlcnMgPSBwaWNrT3RoZXJzKE9iamVjdC5rZXlzKEl0ZW0ucHJvcFR5cGVzKSwgdGhpcy5wcm9wcyk7XG5cbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIGZvY3VzYWJsZSwgaW5saW5lSW5kZW50LCBpdGVtQ2xhc3NOYW1lLCBydGwgfSA9IHJvb3QucHJvcHM7XG4gICAgICAgIGNvbnN0IGZvY3VzZWQgPSB0aGlzLmdldEZvY3VzZWQoKTtcblxuICAgICAgICBjb25zdCBuZXdDbGFzc05hbWUgPSByZXBsYWNlQ2xhc3NOYW1lID8gY2xhc3NOYW1lIDogY3goe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1tZW51LWl0ZW1gXTogdHJ1ZSxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9ZGlzYWJsZWRgXTogZGlzYWJsZWQsXG4gICAgICAgICAgICBbYCR7cHJlZml4fWZvY3VzZWRgXTogIWZvY3VzYWJsZSAmJiBmb2N1c2VkLFxuICAgICAgICAgICAgW2l0ZW1DbGFzc05hbWVdOiAhIWl0ZW1DbGFzc05hbWUsXG4gICAgICAgICAgICBbY2xhc3NOYW1lXTogISFjbGFzc05hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICAgICAgb3RoZXJzWydhcmlhLWRpc2FibGVkJ10gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXJzLnRhYkluZGV4ID0gcm9vdC50YWJiYWJsZUtleSA9PT0gX2tleSA/ICcwJyA6ICctMSc7XG5cbiAgICAgICAgaWYgKHBhcmVudE1vZGUgPT09ICdpbmxpbmUnICYmIGxldmVsID4gMSAmJiBpbmxpbmVJbmRlbnQgPiAwICYmIG5lZWRJbmRlbnQpIHtcbiAgICAgICAgICAgIG90aGVycy5zdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAuLi4ob3RoZXJzLnN0eWxlIHx8IHt9KSxcbiAgICAgICAgICAgICAgICBbcnRsID8gJ3BhZGRpbmdSaWdodCcgOiAncGFkZGluZ0xlZnQnXTogYCR7KGxldmVsICogaW5saW5lSW5kZW50KSAtICgoZ3JvdXBJbmRlbnQgfHwgMCkgKiAwLjQgKiBpbmxpbmVJbmRlbnQpfXB4YFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBUYWdOYW1lID0gY29tcG9uZW50O1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8VGFnTmFtZSByb2xlPVwibWVudWl0ZW1cIlxuICAgICAgICAgICAgICAgIHRpdGxlPXt0aGlzLmdldFRpdGxlKGNoaWxkcmVuKX1cbiAgICAgICAgICAgICAgICB7Li4ub3RoZXJzfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17bmV3Q2xhc3NOYW1lfVxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9XG4gICAgICAgICAgICAgICAgb25LZXlEb3duPXt0aGlzLmhhbmRsZUtleURvd259PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9bWVudS1pdGVtLWlubmVyYH0+e2NoaWxkcmVufTwvZGl2PlxuICAgICAgICAgICAgPC9UYWdOYW1lPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tZW51L3ZpZXcvaXRlbS5qc3giLCJpbXBvcnQgQ29uZmlnUHJvdmlkZXIgZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCBPdmVybGF5IGZyb20gJy4vb3ZlcmxheSc7XG5pbXBvcnQgR2F0ZXdheSBmcm9tICcuL2dhdGV3YXknO1xuaW1wb3J0IFBvc2l0aW9uIGZyb20gJy4vcG9zaXRpb24nO1xuaW1wb3J0IFBvcHVwIGZyb20gJy4vcG9wdXAnO1xuXG5PdmVybGF5LkdhdGV3YXkgPSBHYXRld2F5O1xuT3ZlcmxheS5Qb3NpdGlvbiA9IFBvc2l0aW9uO1xuT3ZlcmxheS5Qb3B1cCA9IENvbmZpZ1Byb3ZpZGVyLmNvbmZpZyhQb3B1cCwge1xuICAgIGV4cG9ydE5hbWVzOiBbJ292ZXJsYXknXVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZ1Byb3ZpZGVyLmNvbmZpZyhPdmVybGF5LCB7XG4gICAgZXhwb3J0TmFtZXM6IFsnZ2V0Q29udGVudCcsICdnZXRDb250ZW50Tm9kZSddXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9vdmVybGF5L2luZGV4LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgUm93Q29tcG9uZW50IGZyb20gJy4vcm93JztcbmltcG9ydCBDZWxsQ29tcG9uZW50IGZyb20gJy4vY2VsbCc7XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJvZHkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIGxvYWRpbmc6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBlbXB0eUNvbnRlbnQ6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcHVyZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGNvbXBvbmVudHM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIGdldENlbGxQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGNlbGxSZWY6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBwcmltYXJ5S2V5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBnZXRSb3dQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIHJvd1JlZjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGRhdGFTb3VyY2U6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY29tcG9uZW50OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjb2xHcm91cDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgY29sdW1uczogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBvblJvd0NsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25Sb3dNb3VzZUVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25Sb3dNb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgbG9jYWxlOiBQcm9wVHlwZXMub2JqZWN0XG4gICAgfVxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICBwcmVmaXg6ICduZXh0LScsXG4gICAgICAgIGNvbXBvbmVudHM6IHt9LFxuICAgICAgICBnZXRDZWxsUHJvcHM6IG5vb3AsXG4gICAgICAgIGNlbGxSZWY6IG5vb3AsXG4gICAgICAgIHByaW1hcnlLZXk6ICdpZCcsXG4gICAgICAgIGdldFJvd1Byb3BzOiBub29wLFxuICAgICAgICByb3dSZWY6IG5vb3AsXG4gICAgICAgIGRhdGFTb3VyY2U6IFtdLFxuICAgICAgICBjb21wb25lbnQ6ICd0Ym9keScsXG4gICAgICAgIGNvbHVtbnM6IFtdXG4gICAgfVxuXG4gICAgZ2V0Um93UmVmID0gKGksIHJvdykgPT4ge1xuICAgICAgICB0aGlzLnByb3BzLnJvd1JlZihpLCByb3cpO1xuICAgIH1cblxuICAgIG9uUm93Q2xpY2sgPSAocmVjb3JkLCBpbmRleCwgZSkgPT4ge1xuICAgICAgICB0aGlzLnByb3BzLm9uUm93Q2xpY2socmVjb3JkLCBpbmRleCwgZSk7XG4gICAgfVxuXG4gICAgb25Sb3dNb3VzZUVudGVyID0gKHJlY29yZCwgaW5kZXgsIGUpID0+IHtcbiAgICAgICAgdGhpcy5wcm9wcy5vblJvd01vdXNlRW50ZXIocmVjb3JkLCBpbmRleCwgZSk7XG4gICAgfVxuXG4gICAgb25Sb3dNb3VzZUxlYXZlID0gKHJlY29yZCwgaW5kZXgsIGUpID0+IHtcbiAgICAgICAgdGhpcy5wcm9wcy5vblJvd01vdXNlTGVhdmUocmVjb3JkLCBpbmRleCwgZSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvKmVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBjbGFzc05hbWUsIGNoaWxkcmVuLCBjb21wb25lbnQ6IFRhZywgY29sR3JvdXAsIGxvYWRpbmcsIGVtcHR5Q29udGVudCwgY29tcG9uZW50cywgZ2V0Q2VsbFByb3BzLFxuICAgICAgICAgICAgcHJpbWFyeUtleSwgZ2V0Um93UHJvcHMsIGRhdGFTb3VyY2UsIGNlbGxSZWYsIGNvbHVtbnMsIHJvd1JlZiwgb25Sb3dDbGljaywgb25Sb3dNb3VzZUVudGVyLCBvblJvd01vdXNlTGVhdmUsIGxvY2FsZSwgcHVyZSwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGNvbnN0IHsgUm93ID0gUm93Q29tcG9uZW50LCBDZWxsID0gQ2VsbENvbXBvbmVudCB9ID0gY29tcG9uZW50cztcbiAgICAgICAgY29uc3QgZW1wdHkgPSBsb2FkaW5nID8gPHNwYW4+Jm5ic3A7PC9zcGFuPiA6IGVtcHR5Q29udGVudCB8fCBsb2NhbGUuZW1wdHk7XG4gICAgICAgIGxldCByb3dzID0gKDx0cj5cbiAgICAgICAgICAgIDx0ZCBjb2xTcGFuPXtjb2x1bW5zLmxlbmd0aH0+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1lbXB0eWB9PntlbXB0eX08L2Rpdj5cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgIDwvdHI+KTtcbiAgICAgICAgaWYgKFRhZyA9PT0gJ2RpdicpIHtcbiAgICAgICAgICAgIHJvd3MgPSAoPHRhYmxlIHJvbGU9XCJ0YWJsZVwiPjx0Ym9keT57cm93c308L3Rib2R5PjwvdGFibGU+KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVNvdXJjZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJvd3MgPSBkYXRhU291cmNlLm1hcCgocmVjb3JkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvd1Byb3BzID0gZ2V0Um93UHJvcHMocmVjb3JkLCBpbmRleCkgfHwge307XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93Q2xhc3MgPSByb3dQcm9wcy5jbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0OiBpbmRleCA9PT0gMCxcbiAgICAgICAgICAgICAgICAgICAgbGFzdDogaW5kZXggPT09IGRhdGFTb3VyY2UubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgW3Jvd0NsYXNzXTogcm93Q2xhc3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBhbmRlZCA9IHJlY29yZC5fX2V4cGFuZGVkID8gJ2V4cGFuZGVkJyA6ICcnO1xuICAgICAgICAgICAgICAgIHJldHVybiAoPFJvdyBrZXk9e2Ake3JlY29yZFtwcmltYXJ5S2V5XSB8fCBpbmRleH0ke2V4cGFuZGVkfWB9XG4gICAgICAgICAgICAgICAgICAgIHsuLi5yb3dQcm9wc31cbiAgICAgICAgICAgICAgICAgICAgcmVmPXt0aGlzLmdldFJvd1JlZi5iaW5kKHRoaXMsIGluZGV4KX1cbiAgICAgICAgICAgICAgICAgICAgY29sR3JvdXA9e2NvbEdyb3VwfVxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5PXtwcmltYXJ5S2V5fVxuICAgICAgICAgICAgICAgICAgICByZWNvcmQ9e3JlY29yZH1cbiAgICAgICAgICAgICAgICAgICAgcm93SW5kZXg9e2luZGV4fVxuICAgICAgICAgICAgICAgICAgICBwcmVmaXg9e3ByZWZpeH1cbiAgICAgICAgICAgICAgICAgICAgcHVyZT17cHVyZX1cbiAgICAgICAgICAgICAgICAgICAgY2VsbFJlZj17Y2VsbFJlZn1cbiAgICAgICAgICAgICAgICAgICAgZ2V0Q2VsbFByb3BzPXtnZXRDZWxsUHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICAgICAgICAgICAgICBDZWxsPXtDZWxsfVxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uUm93Q2xpY2t9XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZT17bG9jYWxlfVxuICAgICAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXI9e3RoaXMub25Sb3dNb3VzZUVudGVyfVxuICAgICAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU9e3RoaXMub25Sb3dNb3VzZUxlYXZlfVxuICAgICAgICAgICAgICAgIC8+KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoPFRhZyBjbGFzc05hbWU9e2NsYXNzTmFtZX0gey4uLm90aGVyc30+XG4gICAgICAgICAgICB7cm93c31cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9UYWc+KTtcbiAgICB9XG59XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9iYXNlL2JvZHkuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IG9iaiwgZG9tIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBmZXRjaERhdGFCeVBhdGggfSBmcm9tICcuLi91dGlsJztcblxuY29uc3Qgbm9vcCA9ICgpID0+IHsgfTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm93IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHB1cmU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBwcmltYXJ5S2V5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNvbHVtbnM6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgcmVjb3JkOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBDZWxsOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgcm93SW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGdldENlbGxQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbk1vdXNlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgY2VsbFJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGNvbEdyb3VwOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBsb2NhbGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgfVxuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgICAgICBwcmltYXJ5S2V5OiAnaWQnLFxuICAgICAgICBjb2x1bW5zOiBbXSxcbiAgICAgICAgcmVjb3JkOiB7fSxcbiAgICAgICAgZ2V0Q2VsbFByb3BzOiBub29wLFxuICAgICAgICBvbkNsaWNrOiBub29wLFxuICAgICAgICBvbk1vdXNlRW50ZXI6IG5vb3AsXG4gICAgICAgIG9uTW91c2VMZWF2ZTogbm9vcCxcbiAgICAgICAgY2VsbFJlZjogbm9vcCxcbiAgICAgICAgY29sR3JvdXA6IHt9XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgbm90UmVuZGVyQ2VsbEluZGV4OiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIGxvY2tUeXBlOiBQcm9wVHlwZXMub25lT2YoWydsZWZ0JywgJ3JpZ2h0J10pXG4gICAgfVxuXG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuICAgICAgICBpZiAobmV4dFByb3BzLnB1cmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzRXF1YWwgPSBvYmouc2hhbGxvd0VxdWFsKHRoaXMucHJvcHMsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gIWlzRXF1YWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvbkNsaWNrID0gKGUpID0+IHtcbiAgICAgICAgY29uc3QgeyByZWNvcmQsIHJvd0luZGV4IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2xpY2socmVjb3JkLCByb3dJbmRleCwgZSk7XG4gICAgfVxuXG4gICAgb25Nb3VzZUVudGVyID0gKGUpID0+IHtcbiAgICAgICAgY29uc3QgeyByZWNvcmQsIHJvd0luZGV4IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICB0aGlzLm9uUm93SG92ZXIocmVjb3JkLCByb3dJbmRleCwgdHJ1ZSwgZSk7XG4gICAgfVxuXG4gICAgb25Nb3VzZUxlYXZlID0gKGUpID0+IHtcbiAgICAgICAgY29uc3QgeyByZWNvcmQsIHJvd0luZGV4IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICB0aGlzLm9uUm93SG92ZXIocmVjb3JkLCByb3dJbmRleCwgZmFsc2UsIGUpO1xuICAgIH1cblxuICAgIG9uUm93SG92ZXIocmVjb3JkLCBpbmRleCwgaXNFbnRlciwgZSkge1xuICAgICAgICBjb25zdCB7IG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlIH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgY3VycmVudFJvdyA9IGZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgICBpZiAoaXNFbnRlcikge1xuICAgICAgICAgICAgb25Nb3VzZUVudGVyKHJlY29yZCwgaW5kZXgsIGUpO1xuICAgICAgICAgICAgY3VycmVudFJvdyAmJiBkb20uYWRkQ2xhc3MoY3VycmVudFJvdywgJ2hvdmVyZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uTW91c2VMZWF2ZShyZWNvcmQsIGluZGV4LCBlKTtcbiAgICAgICAgICAgIGN1cnJlbnRSb3cgJiYgZG9tLnJlbW92ZUNsYXNzKGN1cnJlbnRSb3csICdob3ZlcmVkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXJDZWxscyhyZWNvcmQpIHtcbiAgICAgICAgY29uc3QgeyBDZWxsLCBjb2x1bW5zLCBnZXRDZWxsUHJvcHMsIGNlbGxSZWYsIHByZWZpeCwgcm93SW5kZXgsIHByaW1hcnlLZXksIHB1cmUsIGxvY2FsZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBsb2NrVHlwZSB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICByZXR1cm4gY29sdW1ucy5tYXAoKGNoaWxkLCBjb2xJbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhSW5kZXgsIGFsaWduLCB3aWR0aCwgLi4ub3RoZXJzIH0gPSBjaGlsZDtcblxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmZXRjaERhdGFCeVBhdGgocmVjb3JkLCBkYXRhSW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBnZXRDZWxsUHJvcHMocm93SW5kZXgsIGNvbEluZGV4LCBkYXRhSW5kZXgsIHJlY29yZCkgfHwge307XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQubm90UmVuZGVyQ2VsbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hDZWxsSW5kZXggPSB0aGlzLmNvbnRleHQubm90UmVuZGVyQ2VsbEluZGV4Lm1hcChjZWxsSW5kZXggPT4gY2VsbEluZGV4LnRvU3RyaW5nKCkpLmluZGV4T2YoW3Jvd0luZGV4LCBjb2xJbmRleF0udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoQ2VsbEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0Lm5vdFJlbmRlckNlbGxJbmRleC5zcGxpY2UobWF0Y2hDZWxsSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXR0cnMuY29sU3BhbiAmJiBhdHRycy5jb2xTcGFuID4gMSB8fCBhdHRycy5yb3dTcGFuICYmIGF0dHJzLnJvd1NwYW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0Tm90UmVuZGVyQ2VsbEluZGV4KGNvbEluZGV4LCByb3dJbmRleCwgYXR0cnMuY29sU3BhbiB8fCAxLCBhdHRycy5yb3dTcGFuIHx8IDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICBmaXJzdDogbG9ja1R5cGUgIT09ICdyaWdodCcgJiYgY29sSW5kZXggPT09IDAsXG4gICAgICAgICAgICAgICAgbGFzdDogbG9ja1R5cGUgIT09ICdsZWZ0JyAmJiAoY29sSW5kZXggPT09IGNvbHVtbnMubGVuZ3RoIC0gMSB8fCBjb2xJbmRleCArIGF0dHJzLmNvbFNwYW4gPT09IGNvbHVtbnMubGVuZ3RoKSwgLy8g6ICD6JmR5ZCI5bm25Y2V5YWD5qC855qE5oOF5Ya1XG4gICAgICAgICAgICAgICAgW2NoaWxkLmNsYXNzTmFtZV06IGNoaWxkLmNsYXNzTmFtZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAoPENlbGwga2V5PXtjb2xJbmRleH1cbiAgICAgICAgICAgICAgICB7Li4ub3RoZXJzfVxuICAgICAgICAgICAgICAgIHsuLi5hdHRyc31cbiAgICAgICAgICAgICAgICByZWY9eyhjZWxsKSA9PiBjZWxsUmVmKHJvd0luZGV4LCBjb2xJbmRleCwgY2VsbCl9XG4gICAgICAgICAgICAgICAgcHJlZml4PXtwcmVmaXh9XG4gICAgICAgICAgICAgICAgcHVyZT17cHVyZX1cbiAgICAgICAgICAgICAgICBwcmltYXJ5S2V5PXtwcmltYXJ5S2V5fVxuICAgICAgICAgICAgICAgIHJlY29yZD17cmVjb3JkfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICAgICAgICBjb2xJbmRleD17Y29sSW5kZXh9XG4gICAgICAgICAgICAgICAgcm93SW5kZXg9e3Jvd0luZGV4fVxuICAgICAgICAgICAgICAgIGFsaWduPXthbGlnbn1cbiAgICAgICAgICAgICAgICBsb2NhbGU9e2xvY2FsZX1cbiAgICAgICAgICAgICAgICB3aWR0aD17d2lkdGh9XG4gICAgICAgICAgICAvPik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9nZXROb3RSZW5kZXJDZWxsSW5kZXgoY29sSW5kZXgsIHJvd0luZGV4LCBjb2xTcGFuLCByb3dTcGFuKSB7XG4gICAgICAgIGNvbnN0IG1heENvbEluZGV4ID0gY29sU3BhbjtcbiAgICAgICAgY29uc3QgbWF4Um93SW5kZXggPSByb3dTcGFuO1xuICAgICAgICBjb25zdCBub3RSZW5kZXJDZWxsSW5kZXggPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhDb2xJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1heFJvd0luZGV4OyBqKyspIHtcbiAgICAgICAgICAgICAgICBub3RSZW5kZXJDZWxsSW5kZXgucHVzaChbcm93SW5kZXggKyBqLCBjb2xJbmRleCArIGldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBbXS5wdXNoLmFwcGx5KHRoaXMuY29udGV4dC5ub3RSZW5kZXJDZWxsSW5kZXgsIG5vdFJlbmRlckNlbGxJbmRleCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyovXG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBjbGFzc05hbWUsIG9uQ2xpY2ssIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlLCBjb2x1bW5zLCBDZWxsLCBnZXRDZWxsUHJvcHMsIHJvd0luZGV4LCByZWNvcmQsIGNoaWxkcmVuLCBwcmltYXJ5S2V5LCBjZWxsUmVmLCBjb2xHcm91cCwgcHVyZSwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBjbHMgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9dGFibGUtcm93YF06IHRydWUsXG4gICAgICAgICAgICBbY2xhc3NOYW1lXTogY2xhc3NOYW1lXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKDx0ciBjbGFzc05hbWU9e2Nsc30gcm9sZT1cInJvd1wiIHsuLi5vdGhlcnN9XG4gICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2t9IG9uTW91c2VFbnRlcj17dGhpcy5vbk1vdXNlRW50ZXJ9IG9uTW91c2VMZWF2ZT17dGhpcy5vbk1vdXNlTGVhdmV9PlxuICAgICAgICAgICAge3RoaXMucmVuZGVyQ2VsbHMocmVjb3JkKX1cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC90cj4pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9iYXNlL3Jvdy5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgb2JqIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENlbGwgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcHVyZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHByaW1hcnlLZXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcmVjb3JkOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICB2YWx1ZTogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgY29sSW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIHJvd0luZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICB0aXRsZTogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgd2lkdGg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgICAgICAgY29udGV4dDogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgY2VsbDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmVsZW1lbnQsIFByb3BUeXBlcy5ub2RlLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgICAgICBhbGlnbjogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXSksXG4gICAgICAgIGNvbXBvbmVudDogUHJvcFR5cGVzLm9uZU9mKFsndGQnLCAndGgnLCAnZGl2J10pLFxuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIGlubmVyU3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIGZpbHRlck1vZGU6IFByb3BUeXBlcy5vbmVPZihbJ3NpbmdsZScsICdtdWx0aXBsZSddKSxcbiAgICAgICAgZmlsdGVyczogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBzb3J0YWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGxvY2s6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIHR5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2hlYWRlcicsICdib2R5J10pLFxuICAgICAgICByZXNpemFibGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBfX25vcm1hbGl6ZWQ6IFByb3BUeXBlcy5ib29sXG4gICAgfVxuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgY29tcG9uZW50OiAndGQnLFxuICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgIGNlbGw6ICh2YWx1ZSkgPT4gdmFsdWUsXG4gICAgICAgIHByZWZpeDogJ25leHQtJ1xuICAgIH1cblxuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wcy5wdXJlKSB7XG4gICAgICAgICAgICBjb25zdCBpc0VxdWFsID0gb2JqLnNoYWxsb3dFcXVhbCh0aGlzLnByb3BzLCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuICFpc0VxdWFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgY29uc3Qge3ByZWZpeCwgY2xhc3NOYW1lLCBjZWxsLCB2YWx1ZSwgcmVzaXphYmxlLCBjb2xJbmRleCwgcm93SW5kZXgsIHJlY29yZCwgY29udGV4dCwgYWxpZ24sIHN0eWxlID0ge30sIGNvbXBvbmVudDogVGFnLFxuICAgICAgICAgICAgY2hpbGRyZW4sIHRpdGxlLCB3aWR0aCwgaW5uZXJTdHlsZSwgcHJpbWFyeUtleSwgX19ub3JtYWxpemVkLCBmaWx0ZXJNb2RlLCBmaWx0ZXJzLCBzb3J0YWJsZSwgbG9jaywgcHVyZSwgLi4ub3RoZXJzfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHRhZ1N0eWxlID0gey4uLnN0eWxlfTtcbiAgICAgICAgY29uc3QgY2VsbFByb3BzID0ge3ZhbHVlLCBpbmRleDogcm93SW5kZXgsIHJlY29yZCwgY29udGV4dH07XG4gICAgICAgIGxldCBjb250ZW50ID0gY2VsbDtcbiAgICAgICAgaWYgKFJlYWN0LmlzVmFsaWRFbGVtZW50KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gUmVhY3QuY2xvbmVFbGVtZW50KGNvbnRlbnQsIGNlbGxQcm9wcyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50KHZhbHVlLCByb3dJbmRleCwgcmVjb3JkLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxpZ24pIHtcbiAgICAgICAgICAgIHRhZ1N0eWxlLnRleHRBbGlnbiA9IGFsaWduO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNscyA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH10YWJsZS1jZWxsYF06IHRydWUsXG4gICAgICAgICAgICBbY2xhc3NOYW1lXTogY2xhc3NOYW1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAoPFRhZyB7Li4ub3RoZXJzfSBjbGFzc05hbWU9e2Nsc30gc3R5bGU9e3RhZ1N0eWxlfSByb2xlPVwiZ3JpZGNlbGxcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtY2VsbC13cmFwcGVyYH0gc3R5bGU9e2lubmVyU3R5bGV9PlxuICAgICAgICAgICAgICAgIHtjb250ZW50fVxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L1RhZz4pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9iYXNlL2NlbGwuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgSGVhZGVyQ29tcG9uZW50IGZyb20gJy4uL2Jhc2UvaGVhZGVyJztcblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcHJlZmVyLXN0YXRlbGVzcy1mdW5jdGlvbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRml4ZWRIZWFkZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY29sR3JvdXA6IFByb3BUeXBlcy5hbnlcbiAgICB9XG5cbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICBnZXROb2RlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgbG9ja1R5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2xlZnQnLCAncmlnaHQnXSlcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmdldE5vZGUoJ2hlYWRlcicsIGZpbmRET01Ob2RlKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBjbGFzc05hbWUsIGNvbEdyb3VwLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLWhlYWRlci1pbm5lcmB9PlxuICAgICAgICAgICAgICAgIDx0YWJsZT5cbiAgICAgICAgICAgICAgICAgICAge2NvbEdyb3VwfVxuICAgICAgICAgICAgICAgICAgICA8SGVhZGVyQ29tcG9uZW50IHsuLi5vdGhlcnN9IHByZWZpeD17cHJlZml4fS8+XG4gICAgICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj4pO1xuICAgIH1cbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2ZpeGVkL2hlYWRlci5qc3giLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fcHJvcC10eXBlc0AxNS42LjJAcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJpbXBvcnQgeyBmaW5kRE9NTm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmROb2RlKHRhcmdldCwgcGFyYW0pIHtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0KHBhcmFtKTtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZmluZERPTU5vZGUodGFyZ2V0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvb3ZlcmxheS91dGlscy9maW5kLW5vZGUuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBJY29uIGZyb20gJy4uLy4uL2ljb24nO1xuaW1wb3J0IHsgZnVuYywgb2JqLCBLRVlDT0RFIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgSXRlbSBmcm9tICcuL2l0ZW0nO1xuXG5jb25zdCB7IGJpbmRDdHggfSA9IGZ1bmM7XG5jb25zdCB7IHBpY2tPdGhlcnMgfSA9IG9iajtcblxuLyoqXG4gKiBNZW51Lkl0ZW1cbiAqIEBvcmRlciAwXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlbGVjdGFibGVJdGVtIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgbWVudUNoaWxkVHlwZSA9ICdpdGVtJztcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIF9rZXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHJvb3Q6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIHNlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgb25TZWxlY3Q6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBpbmxpbmVJbmRlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbnpoHnlKhcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW4ruWKqeaWh+acrFxuICAgICAgICAgKi9cbiAgICAgICAgaGVscGVyOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiPnOWNlemhueagh+etvuWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIG9uS2V5RG93bjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBuZWVkSW5kZW50OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgaGFzU2VsZWN0ZWRJY29uOiBQcm9wVHlwZXMuYm9vbFxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIG5lZWRJbmRlbnQ6IHRydWVcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIGJpbmRDdHgodGhpcywgWydoYW5kbGVLZXlEb3duJywgJ2hhbmRsZUNsaWNrJ10pO1xuICAgIH1cblxuICAgIGdldFNlbGVjdGVkKCkge1xuICAgICAgICBjb25zdCB7IF9rZXksIHJvb3QsIHNlbGVjdGVkIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHNlbGVjdE1vZGUgfSA9IHJvb3QucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0ZWRLZXlzIH0gPSByb290LnN0YXRlO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQgfHwgKCEhc2VsZWN0TW9kZSAmJiBzZWxlY3RlZEtleXMuaW5kZXhPZihfa2V5KSA+IC0xKTtcbiAgICB9XG5cbiAgICBoYW5kbGVTZWxlY3QoZSkge1xuICAgICAgICBjb25zdCB7IF9rZXksIHJvb3QsIG9uU2VsZWN0IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAob25TZWxlY3QpIHtcbiAgICAgICAgICAgIG9uU2VsZWN0KCF0aGlzLmdldFNlbGVjdGVkKCksIHRoaXMsIGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm9vdC5oYW5kbGVTZWxlY3QoX2tleSwgIXRoaXMuZ2V0U2VsZWN0ZWQoKSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVLZXlEb3duKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERS5TUEFDRSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3QoZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3BzLm9uS2V5RG93biAmJiB0aGlzLnByb3BzLm9uS2V5RG93bihlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDbGljayhlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0KGUpO1xuXG4gICAgICAgIHRoaXMucHJvcHMub25DbGljayAmJiB0aGlzLnByb3BzLm9uQ2xpY2soZSk7XG4gICAgfVxuXG4gICAgcmVuZGVyU2VsZWN0ZWRJY29uKHNlbGVjdGVkKSB7XG4gICAgICAgIGNvbnN0IHsgcm9vdCwgaW5saW5lSW5kZW50LCBuZWVkSW5kZW50LCBoYXNTZWxlY3RlZEljb24gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBoYXNTZWxlY3RlZEljb246IHJvb3RTZWxlY3RlZEljb24gfSA9IHJvb3QucHJvcHM7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICgnaGFzU2VsZWN0ZWRJY29uJyBpbiB0aGlzLnByb3BzID8gaGFzU2VsZWN0ZWRJY29uIDogcm9vdFNlbGVjdGVkSWNvbikgJiYgc2VsZWN0ZWQgP1xuICAgICAgICAgICAgICAgIDxJY29uIHN0eWxlPXtuZWVkSW5kZW50ICYmIGlubGluZUluZGVudCA+IDAgPyB7IGxlZnQ6IGAke2lubGluZUluZGVudH1weGAgfSA6IG51bGx9IGNsYXNzTmFtZT17YCR7cHJlZml4fW1lbnUtaWNvbi1zZWxlY3RlZGB9IHR5cGU9XCJzZWxlY3RcIiAvPiA6XG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBfa2V5LCByb290LCBjbGFzc05hbWUsIGRpc2FibGVkLCBoZWxwZXIsIGNoaWxkcmVuLCBuZWVkSW5kZW50IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHByZWZpeCB9ID0gcm9vdC5wcm9wcztcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gcGlja090aGVycyhPYmplY3Qua2V5cyhTZWxlY3RhYmxlSXRlbS5wcm9wVHlwZXMpLCB0aGlzLnByb3BzKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLmdldFNlbGVjdGVkKCk7XG5cbiAgICAgICAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgICAgICAgICBfa2V5LFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgdHlwZTogJ2l0ZW0nLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjeCh7XG4gICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1zZWxlY3RlZGBdOiBzZWxlY3RlZCxcbiAgICAgICAgICAgICAgICBbY2xhc3NOYW1lXTogISFjbGFzc05hbWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb25LZXlEb3duOiB0aGlzLmhhbmRsZUtleURvd24sXG4gICAgICAgICAgICBvbkNsaWNrOiAhZGlzYWJsZWQgPyB0aGlzLmhhbmRsZUNsaWNrIDogdGhpcy5wcm9wcy5vbkNsaWNrLFxuICAgICAgICAgICAgbmVlZEluZGVudCxcbiAgICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogc2VsZWN0ZWQsXG4gICAgICAgICAgICAuLi5vdGhlcnNcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEl0ZW0gey4uLm5ld1Byb3BzfT5cbiAgICAgICAgICAgICAgICB7dGhpcy5yZW5kZXJTZWxlY3RlZEljb24oc2VsZWN0ZWQpfVxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YCR7cHJlZml4fW1lbnUtaXRlbS10ZXh0YH0+e2NoaWxkcmVufTwvc3Bhbj5cbiAgICAgICAgICAgICAgICB7aGVscGVyID8gPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH1tZW51LWl0ZW0taGVscGVyYH0+e2hlbHBlcn08L2Rpdj4gOiBudWxsfVxuICAgICAgICAgICAgPC9JdGVtPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tZW51L3ZpZXcvc2VsZWN0YWJsZS1pdGVtLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG4vKipcbiAqIFRhYmxlLkNvbHVtblxuICogQG9yZGVyIDBcbiAqKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbHVtbiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5oyH5a6a5YiX5a+55bqU55qE5a2X5q6177yM5pSv5oyBYGEuYmDlvaLlvI/nmoTlv6vpgJ/lj5blgLxcbiAgICAgICAgICovXG4gICAgICAgIGRhdGFJbmRleDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOihjOa4suafk+eahOmAu+i+kVxuICAgICAgICAgKiB2YWx1ZSwgcm93SW5kZXgsIHJlY29yZCwgY29udGV4dOWbm+S4quWxnuaAp+WPquWPr+ivu+S4jeWPr+iiq+abtOaUuVxuICAgICAgICAgKiBGdW5jdGlvbih2YWx1ZSwgaW5kZXgsIHJlY29yZCkgPT4gRWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgY2VsbDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmVsZW1lbnQsIFByb3BUeXBlcy5ub2RlLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog6KGo5aS05pi+56S655qE5YaF5a65XG4gICAgICAgICAqIHZhbHVlLCByb3dJbmRleCwgcmVjb3JkLCBjb250ZXh05Zub5Liq5bGe5oCn5Y+q5Y+v6K+75LiN5Y+v6KKr5pu05pS5XG4gICAgICAgICAqL1xuICAgICAgICB0aXRsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmVsZW1lbnQsIFByb3BUeXBlcy5ub2RlLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5pSv5oyB5o6S5bqPXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0YWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliJflrr3vvIzms6jmhI/lnKjplIHliJfnmoTmg4XlhrXkuIvkuIDlrprpnIDopoHphY3nva7lrr3luqZcbiAgICAgICAgICovXG4gICAgICAgIHdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDljZXlhYPmoLznmoTlr7npvZDmlrnlvI9cbiAgICAgICAgICovXG4gICAgICAgIGFsaWduOiBQcm9wVHlwZXMub25lT2YoWydsZWZ0JywgJ2NlbnRlcicsICdyaWdodCddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeUn+aIkOagh+mimOi/h+a7pOeahOiPnOWNlSwg5qC85byP5Li6YFt7bGFiZWw6J3h4eCcsIHZhbHVlOid4eHgnfV1gXG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXJzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgICAgICAgbGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgICAgICB2YWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm5vZGUsIFByb3BUeXBlcy5zdHJpbmddKVxuICAgICAgICB9KSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDov4fmu6TnmoTmqKHlvI/mmK/ljZXpgInov5jmmK/lpJrpgIlcbiAgICAgICAgICovXG4gICAgICAgIGZpbHRlck1vZGU6IFByb3BUeXBlcy5vbmVPZihbJ3NpbmdsZScsICdtdWx0aXBsZSddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuaUr+aMgemUgeWIlyzlj6/pgInlgLzkuLpgbGVmdGAsYHJpZ2h0YCwgYHRydWVgXG4gICAgICAgICAqL1xuICAgICAgICBsb2NrOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5pSv5oyB5YiX5a696LCD5pW0LCDlvZPor6XlgLzorr7kuLp0cnVl77yMdGFibGXnmoTluIPlsYDmlrnlvI/kvJrkv67mlLnkuLpmaXhlZC5cbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6YWJsZTogUHJvcFR5cGVzLmJvb2xcbiAgICB9XG5cbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICBwYXJlbnQ6IFByb3BUeXBlcy5hbnlcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBjZWxsOiAodmFsdWUpID0+IHZhbHVlLFxuICAgICAgICBmaWx0ZXJNb2RlOiAnbXVsdGlwbGUnLFxuICAgICAgICByZXNpemFibGU6IGZhbHNlXG4gICAgfVxuXG4gICAgc3RhdGljIF90eXBlTWFyayA9ICdjb2x1bW4nO1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvY29sdW1uLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9wcmVmZXItc3RhdGVsZXNzLWZ1bmN0aW9uICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXhlZFdyYXBwZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNvbEdyb3VwOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICB3cmFwcGVyQ29udGVudDogUHJvcFR5cGVzLmFueVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4sIHdyYXBwZXJDb250ZW50LCBwcmVmaXggfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1pbm5lcmB9PlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAge3dyYXBwZXJDb250ZW50fVxuICAgICAgICA8L2Rpdj4pO1xuICAgIH1cbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2ZpeGVkL3dyYXBwZXIuanN4IiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBjaGFyc2V0IFxcXCJVVEYtOFxcXCI7XFxuLyoqXFxuICog5bC65a+4IOWfuuehgOWwuuWvuFxcbiAqIOWRveWQjeiDveWcqOivreS5ieeahOWJjeaPkOS4i+eugOWNleWwseWwvemHj+eugOWNlSwg6L+Z6YeM5Y+v5Lul5pivIHNpemUtMngsIHNwYWNlLTJ4LCBzaXplLWJhc2UgLi4uXFxuICog5LiN6L+H5Y+v5Lul5Zyo6K+t5LmJ55qE5YmN5o+Q5LiL5YGa55qE5pu057K+566A5LiA5LqbLCDkuo7mmK/nlKjkuoZzMiwgczHnrYlcXG4gKiDlj6/nlKjlj5jph486IGAkczEgLSAkczhgXFxuICogQGV4YW1wbGUgc2NzcyAtIOS9v+eUqFxcbiAqICAgLmVsZW1lbnQge1xcbiAqICAgICBwYWRkaW5nOiAkczEgIWRlZmF1bHQ7XFxuICogICB9XFxuICpcXG4gKiBAZXhhbXBsZSBjc3MgLSBDU1Mg6L6T5Ye6XFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6IDRweCAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKi9cXG4ubmV4dC1pY29uW2Rpcj1cXFwicnRsXFxcIl06OmJlZm9yZSB7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlWSgxODBkZWcpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZVkoMTgwZGVnKTsgfVxcblxcbkBmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6IE5leHRJY29uO1xcbiAgc3JjOiB1cmwoXFxcIi8vYXQuYWxpY2RuLmNvbS90L2ZvbnRfNTE1NzcxX2VtY25zNTA1NHgzd2hmci5lb3RcXFwiKTtcXG4gIHNyYzogdXJsKFxcXCIvL2F0LmFsaWNkbi5jb20vdC9mb250XzUxNTc3MV9lbWNuczUwNTR4M3doZnIuZW90PyNpZWZpeFxcXCIpIGZvcm1hdChcXFwiZW1iZWRkZWQtb3BlbnR5cGVcXFwiKSwgdXJsKFxcXCIvL2F0LmFsaWNkbi5jb20vdC9mb250XzUxNTc3MV9lbWNuczUwNTR4M3doZnIud29mZlxcXCIpIGZvcm1hdChcXFwid29mZlxcXCIpLCB1cmwoXFxcIi8vYXQuYWxpY2RuLmNvbS90L2ZvbnRfNTE1NzcxX2VtY25zNTA1NHgzd2hmci50dGZcXFwiKSBmb3JtYXQoXFxcInRydWV0eXBlXFxcIiksIHVybChcXFwiLy9hdC5hbGljZG4uY29tL3QvZm9udF81MTU3NzFfZW1jbnM1MDU0eDN3aGZyLnN2ZyNOZXh0SWNvblxcXCIpIGZvcm1hdChcXFwic3ZnXFxcIik7IH1cXG5cXG4ubmV4dC1pY29uIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGZvbnQtZmFtaWx5OiBOZXh0SWNvbjtcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG4gIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbiAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTsgfVxcbiAgLm5leHQtaWNvbjpiZWZvcmUge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjsgfVxcbiAgLm5leHQtaWNvbi1zbWlsZTpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2NUZcXFwiOyB9XFxuICAubmV4dC1pY29uLWNyeTpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2NURcXFwiOyB9XFxuICAubmV4dC1pY29uLXN1Y2Nlc3M6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjBBXFxcIjsgfVxcbiAgLm5leHQtaWNvbi13YXJuaW5nOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYwQlxcXCI7IH1cXG4gIC5uZXh0LWljb24tcHJvbXB0OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYwQ1xcXCI7IH1cXG4gIC5uZXh0LWljb24tZXJyb3I6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjBEXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1oZWxwOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTY3M1xcXCI7IH1cXG4gIC5uZXh0LWljb24tY2xvY2s6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjIxXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1zdWNjZXNzLWZpbGxpbmc6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjNBXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1kZWxldGUtZmlsbGluZzpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MjNcXFwiOyB9XFxuICAubmV4dC1pY29uLWZhdm9yaXRlcy1maWxsaW5nOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYwRVxcXCI7IH1cXG4gIC5uZXh0LWljb24tYWRkOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTY1NVxcXCI7IH1cXG4gIC5uZXh0LWljb24tbWludXM6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjAxXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1hcnJvdy11cDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MjVcXFwiOyB9XFxuICAubmV4dC1pY29uLWFycm93LWRvd246YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjNEXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1hcnJvdy1sZWZ0OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYxRFxcXCI7IH1cXG4gIC5uZXh0LWljb24tYXJyb3ctcmlnaHQ6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjE5XFxcIjsgfVxcbiAgLm5leHQtaWNvbi1hcnJvdy1kb3VibGUtbGVmdDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2NTlcXFwiOyB9XFxuICAubmV4dC1pY29uLWFycm93LWRvdWJsZS1yaWdodDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2NUVcXFwiOyB9XFxuICAubmV4dC1pY29uLXN3aXRjaDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2QjNcXFwiOyB9XFxuICAubmV4dC1pY29uLXNvcnRpbmc6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjM0XFxcIjsgfVxcbiAgLm5leHQtaWNvbi1kZXNjZW5kaW5nOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYxRlxcXCI7IH1cXG4gIC5uZXh0LWljb24tYXNjZW5kaW5nOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYxRVxcXCI7IH1cXG4gIC5uZXh0LWljb24tc2VsZWN0OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYzMlxcXCI7IH1cXG4gIC5uZXh0LWljb24tc2VtaS1zZWxlY3Q6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjMzXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1zZWFyY2g6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjU2XFxcIjsgfVxcbiAgLm5leHQtaWNvbi1jbG9zZTpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MjZcXFwiOyB9XFxuICAubmV4dC1pY29uLWVsbGlwc2lzOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTY1NFxcXCI7IH1cXG4gIC5uZXh0LWljb24tcGljdHVyZTpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MzFcXFwiOyB9XFxuICAubmV4dC1pY29uLWNhbGVuZGFyOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYwN1xcXCI7IH1cXG4gIC5uZXh0LWljb24tYXNoYmluOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYzOVxcXCI7IH1cXG4gIC5uZXh0LWljb24tdXBsb2FkOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTdFRVxcXCI7IH1cXG4gIC5uZXh0LWljb24tZG93bmxvYWQ6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjI4XFxcIjsgfVxcbiAgLm5leHQtaWNvbi1zZXQ6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjgzXFxcIjsgfVxcbiAgLm5leHQtaWNvbi1lZGl0OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYzQlxcXCI7IH1cXG4gIC5uZXh0LWljb24tcmVmcmVzaDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2NzdcXFwiOyB9XFxuICAubmV4dC1pY29uLWZpbHRlcjpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcXEU2MjdcXFwiOyB9XFxuICAubmV4dC1pY29uLWF0dGFjaG1lbnQ6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjY1XFxcIjsgfVxcbiAgLm5leHQtaWNvbi1hY2NvdW50OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTYwOFxcXCI7IH1cXG4gIC5uZXh0LWljb24tZW1haWw6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjA1XFxcIjsgfVxcbiAgLm5leHQtaWNvbi1hdG06YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXFxFNjA2XFxcIjsgfVxcbiAgLm5leHQtaWNvbi1sb2FkaW5nOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFxcRTY0NlxcXCI7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uOiBsb2FkaW5nQ2lyY2xlIDFzIGluZmluaXRlIGxpbmVhcjtcXG4gICAgICAgICAgICBhbmltYXRpb246IGxvYWRpbmdDaXJjbGUgMXMgaW5maW5pdGUgbGluZWFyOyB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIGxvYWRpbmdDaXJjbGUge1xcbiAgMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XFxuICAgICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogNTAlIDUwJTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfVxcbiAgMTAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogNTAlIDUwJTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfSB9XFxuXFxuQGtleWZyYW1lcyBsb2FkaW5nQ2lyY2xlIHtcXG4gIDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7IH1cXG4gIDEwMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XFxuICAgICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogNTAlIDUwJTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH0gfVxcblxcbi5uZXh0LWljb24ubmV4dC14eHM6YmVmb3JlIHtcXG4gIHdpZHRoOiA4cHg7XFxuICBmb250LXNpemU6IDhweDtcXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuXFxuQG1lZGlhIGFsbCBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMCkgYW5kIChtaW4tcmVzb2x1dGlvbjogMC4wMDFkcGNtKSB7XFxuICAubmV4dC1pY29uLm5leHQteHhzIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuNSk7XFxuICAgICAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgwLjUpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC41KTtcXG4gICAgbWFyZ2luLWxlZnQ6IC00cHg7XFxuICAgIG1hcmdpbi1yaWdodDogLTRweDsgfVxcbiAgICAubmV4dC1pY29uLm5leHQteHhzOmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgZm9udC1zaXplOiAxNnB4OyB9IH1cXG5cXG4ubmV4dC1pY29uLm5leHQteHM6YmVmb3JlIHtcXG4gIHdpZHRoOiAxMnB4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG5cXG4ubmV4dC1pY29uLm5leHQtc21hbGw6YmVmb3JlIHtcXG4gIHdpZHRoOiAxNnB4O1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG5cXG4ubmV4dC1pY29uLm5leHQtbWVkaXVtOmJlZm9yZSB7XFxuICB3aWR0aDogMjBweDtcXG4gIGZvbnQtc2l6ZTogMjBweDtcXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuXFxuLm5leHQtaWNvbi5uZXh0LWxhcmdlOmJlZm9yZSB7XFxuICB3aWR0aDogMjRweDtcXG4gIGZvbnQtc2l6ZTogMjRweDtcXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuXFxuLm5leHQtaWNvbi5uZXh0LXhsOmJlZm9yZSB7XFxuICB3aWR0aDogMzJweDtcXG4gIGZvbnQtc2l6ZTogMzJweDtcXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuXFxuLm5leHQtaWNvbi5uZXh0LXh4bDpiZWZvcmUge1xcbiAgd2lkdGg6IDQ4cHg7XFxuICBmb250LXNpemU6IDQ4cHg7XFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcblxcbi5uZXh0LWljb24ubmV4dC14eHhsOmJlZm9yZSB7XFxuICB3aWR0aDogNjRweDtcXG4gIGZvbnQtc2l6ZTogNjRweDtcXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyPz9yZWYtLTItMSEuL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliPz9yZWYtLTItMiEuL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYiEuL3NyYy9pY29uL21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIDEyIDEzIDE0IDE1IDE2IDE3IDE4IDE5IDIwIDIxIDIyIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkAtd2Via2l0LWtleWZyYW1lcyBmYWRlSW4ge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMTsgfSB9XFxuXFxuQGtleWZyYW1lcyBmYWRlSW4ge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMTsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIGZhZGVJbkRvd24ge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMTAwcHgpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDBweCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMTAwcHgpOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTsgfSB9XFxuXFxuQGtleWZyYW1lcyBmYWRlSW5Eb3duIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwMHB4KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMTAwcHgpO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwMHB4KTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBmYWRlSW5MZWZ0IHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTIwcHgpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0yMHB4KTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0yMHB4KTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7IH0gfVxcblxcbkBrZXlmcmFtZXMgZmFkZUluTGVmdCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0yMHB4KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMjBweCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMjBweCk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApOyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZmFkZUluUmlnaHQge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgyMHB4KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgyMHB4KTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDIwcHgpOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTsgfSB9XFxuXFxuQGtleWZyYW1lcyBmYWRlSW5SaWdodCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDIwcHgpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDIwcHgpO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjBweCk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApOyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZmFkZUluVXAge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgyMHB4KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWSgyMHB4KTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDIwcHgpOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTsgfSB9XFxuXFxuQGtleWZyYW1lcyBmYWRlSW5VcCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDIwcHgpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDIwcHgpO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMjBweCk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApOyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZmFkZU91dCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDE7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAwOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIGZhZGVPdXQge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAxOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMDsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIGZhZGVPdXREb3duIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDIwcHgpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDIwcHgpO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMjBweCk7IH0gfVxcblxcbkBrZXlmcmFtZXMgZmFkZU91dERvd24ge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMjBweCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMjBweCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgyMHB4KTsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIGZhZGVPdXRMZWZ0IHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0yMHB4KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMjBweCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMjBweCk7IH0gfVxcblxcbkBrZXlmcmFtZXMgZmFkZU91dExlZnQge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTIwcHgpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0yMHB4KTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0yMHB4KTsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIGZhZGVPdXRSaWdodCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgyMHB4KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgyMHB4KTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDIwcHgpOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIGZhZGVPdXRSaWdodCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgyMHB4KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgyMHB4KTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDIwcHgpOyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZmFkZU91dFVwIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDBweCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwMHB4KTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDBweCk7IH0gfVxcblxcbkBrZXlmcmFtZXMgZmFkZU91dFVwIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDBweCk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwMHB4KTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDBweCk7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyB6b29tSW4ge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUzZCgwLjMsIDAuMywgMC4zKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGUzZCgwLjMsIDAuMywgMC4zKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZTNkKDAuMywgMC4zLCAwLjMpOyB9XFxuICA1MCUge1xcbiAgICBvcGFjaXR5OiAxOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIHpvb21JbiB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZTNkKDAuMywgMC4zLCAwLjMpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZTNkKDAuMywgMC4zLCAwLjMpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlM2QoMC4zLCAwLjMsIDAuMyk7IH1cXG4gIDUwJSB7XFxuICAgIG9wYWNpdHk6IDE7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyB6b29tT3V0IHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMTsgfVxcbiAgNTAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlM2QoMC4zLCAwLjMsIDAuMyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlM2QoMC4zLCAwLjMsIDAuMyk7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUzZCgwLjMsIDAuMywgMC4zKTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDA7IH0gfVxcblxcbkBrZXlmcmFtZXMgem9vbU91dCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDE7IH1cXG4gIDUwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZTNkKDAuMywgMC4zLCAwLjMpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZTNkKDAuMywgMC4zLCAwLjMpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlM2QoMC4zLCAwLjMsIDAuMyk7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAwOyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZXhwYW5kSW5Eb3duIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwO1xcbiAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDtcXG4gICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7IH0gfVxcblxcbkBrZXlmcmFtZXMgZXhwYW5kSW5Eb3duIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwO1xcbiAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDtcXG4gICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBleHBhbmRJblVwIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwO1xcbiAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDtcXG4gICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7IH0gfVxcblxcbkBrZXlmcmFtZXMgZXhwYW5kSW5VcCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDtcXG4gICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7XFxuICAgIC1tcy10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwO1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwOyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZXhwYW5kSW5XaXRoRmFkZSB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDA7IH1cXG4gIDQwJSB7XFxuICAgIG9wYWNpdHk6IC4xOyB9XFxuICA1MCUge1xcbiAgICBvcGFjaXR5OiAuOTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDE7IH0gfVxcblxcbkBrZXlmcmFtZXMgZXhwYW5kSW5XaXRoRmFkZSB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDA7IH1cXG4gIDQwJSB7XFxuICAgIG9wYWNpdHk6IC4xOyB9XFxuICA1MCUge1xcbiAgICBvcGFjaXR5OiAuOTsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDE7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBleHBhbmRPdXRVcCB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDtcXG4gICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7XFxuICAgIC1tcy10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwO1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIGV4cGFuZE91dFVwIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcCAwO1xcbiAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3AgMDtcXG4gICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wIDA7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBleHBhbmRPdXREb3duIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGVZKDEpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwO1xcbiAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDsgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMC42KTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDtcXG4gICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7IH0gfVxcblxcbkBrZXlmcmFtZXMgZXhwYW5kT3V0RG93biB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBib3R0b20gMDtcXG4gICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDAuNik7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgwLjYpO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgYm90dG9tIDA7XFxuICAgIC1tcy10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwO1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGJvdHRvbSAwOyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZXhwYW5kT3V0V2l0aEZhZGUge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAxOyB9XFxuICA3MCUge1xcbiAgICBvcGFjaXR5OiAwOyB9XFxuICAxMDAlIHtcXG4gICAgb3BhY2l0eTogMDsgfSB9XFxuXFxuQGtleWZyYW1lcyBleHBhbmRPdXRXaXRoRmFkZSB7XFxuICAwJSB7XFxuICAgIG9wYWNpdHk6IDE7IH1cXG4gIDcwJSB7XFxuICAgIG9wYWNpdHk6IDA7IH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAwOyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgcHVsc2Uge1xcbiAgZnJvbSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7IH1cXG4gIDIwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxLjIpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgxLjIpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMik7IH1cXG4gIHRvIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxKTsgfSB9XFxuXFxuQGtleWZyYW1lcyBwdWxzZSB7XFxuICBmcm9tIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxKTsgfVxcbiAgMjAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEuMik7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDEuMik7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMS4yKTsgfVxcbiAgdG8ge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpOyB9IH1cXG5cXG4uZmFkZUluIHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGZhZGVJbjtcXG4gIGFuaW1hdGlvbi1uYW1lOiBmYWRlSW47XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogMHM7XFxuICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cXG4uZmFkZUluRG93biB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBmYWRlSW5Eb3duO1xcbiAgYW5pbWF0aW9uLW5hbWU6IGZhZGVJbkRvd247XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogMHM7XFxuICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cXG4uZmFkZUluTGVmdCB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBmYWRlSW5MZWZ0O1xcbiAgYW5pbWF0aW9uLW5hbWU6IGZhZGVJbkxlZnQ7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogMHM7XFxuICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cXG4uZmFkZUluUmlnaHQge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogZmFkZUluUmlnaHQ7XFxuICBhbmltYXRpb24tbmFtZTogZmFkZUluUmlnaHQ7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogMHM7XFxuICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cXG4uZmFkZUluVXAge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogZmFkZUluVXA7XFxuICBhbmltYXRpb24tbmFtZTogZmFkZUluVXA7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogMHM7XFxuICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cXG4uZmFkZU91dCB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBmYWRlT3V0O1xcbiAgYW5pbWF0aW9uLW5hbWU6IGZhZGVPdXQ7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogMHM7XFxuICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC43NTUsIDAuMDUsIDAuODU1LCAwLjA2KTtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjc1NSwgMC4wNSwgMC44NTUsIDAuMDYpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXFxuLmZhZGVPdXREb3duIHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGZhZGVPdXREb3duO1xcbiAgYW5pbWF0aW9uLW5hbWU6IGZhZGVPdXREb3duO1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNik7XFxuICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC43NTUsIDAuMDUsIDAuODU1LCAwLjA2KTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblxcbi5mYWRlT3V0TGVmdCB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBmYWRlT3V0TGVmdDtcXG4gIGFuaW1hdGlvbi1uYW1lOiBmYWRlT3V0TGVmdDtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIGFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjc1NSwgMC4wNSwgMC44NTUsIDAuMDYpO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNik7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cXG4uZmFkZU91dFJpZ2h0IHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGZhZGVPdXRSaWdodDtcXG4gIGFuaW1hdGlvbi1uYW1lOiBmYWRlT3V0UmlnaHQ7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogMHM7XFxuICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC43NTUsIDAuMDUsIDAuODU1LCAwLjA2KTtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjc1NSwgMC4wNSwgMC44NTUsIDAuMDYpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXFxuLmZhZGVPdXRVcCB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBmYWRlT3V0VXA7XFxuICBhbmltYXRpb24tbmFtZTogZmFkZU91dFVwO1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjJzO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjJzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNik7XFxuICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC43NTUsIDAuMDUsIDAuODU1LCAwLjA2KTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblxcbi56b29tSW4ge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogem9vbUluO1xcbiAgYW5pbWF0aW9uLW5hbWU6IHpvb21JbjtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIGFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblxcbi56b29tT3V0IHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IHpvb21PdXQ7XFxuICBhbmltYXRpb24tbmFtZTogem9vbU91dDtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIGFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjc1NSwgMC4wNSwgMC44NTUsIDAuMDYpO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNik7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cXG4uZXhwYW5kSW5Eb3duIHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGV4cGFuZEluRG93bjtcXG4gIGFuaW1hdGlvbi1uYW1lOiBleHBhbmRJbkRvd247XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogMHM7XFxuICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cXG4uZXhwYW5kT3V0VXAge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogZXhwYW5kT3V0VXA7XFxuICBhbmltYXRpb24tbmFtZTogZXhwYW5kT3V0VXA7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuMTVzO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjE1cztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIGFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblxcbi5leHBhbmRJblVwIHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGV4cGFuZEluVXA7XFxuICBhbmltYXRpb24tbmFtZTogZXhwYW5kSW5VcDtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIGFuaW1hdGlvbi1kZWxheTogMHM7XFxuICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblxcbi5leHBhbmRPdXREb3duIHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGV4cGFuZE91dERvd247XFxuICBhbmltYXRpb24tbmFtZTogZXhwYW5kT3V0RG93bjtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4xNXM7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuMTVzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXFxuLnB1bHNlIHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IHB1bHNlO1xcbiAgYW5pbWF0aW9uLW5hbWU6IHB1bHNlO1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXFxuLmV4cGFuZC1lbnRlciB7XFxuICBvdmVyZmxvdzogaGlkZGVuOyB9XFxuXFxuLmV4cGFuZC1lbnRlci1hY3RpdmUge1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgLjNzIGVhc2Utb3V0O1xcbiAgdHJhbnNpdGlvbjogYWxsIC4zcyBlYXNlLW91dDsgfVxcbiAgLmV4cGFuZC1lbnRlci1hY3RpdmUgPiAqIHtcXG4gICAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogZXhwYW5kSW5XaXRoRmFkZTtcXG4gICAgYW5pbWF0aW9uLW5hbWU6IGV4cGFuZEluV2l0aEZhZGU7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gICAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcXG4gICAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuMnM7XFxuICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4ycztcXG4gICAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gICAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IFxcXCJmb3J3YXJkc1xcXCI7XFxuICAgIGFuaW1hdGlvbi1maWxsLW1vZGU6IFxcXCJmb3J3YXJkc1xcXCI7XFxuICAgIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cXG4uZXhwYW5kLWxlYXZlIHtcXG4gIG92ZXJmbG93OiBoaWRkZW47IH1cXG5cXG4uZXhwYW5kLWxlYXZlLWFjdGl2ZSB7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAuMnMgZWFzZS1vdXQ7XFxuICB0cmFuc2l0aW9uOiBhbGwgLjJzIGVhc2Utb3V0OyB9XFxuICAuZXhwYW5kLWxlYXZlLWFjdGl2ZSA+ICoge1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBleHBhbmRPdXRXaXRoRmFkZTtcXG4gICAgYW5pbWF0aW9uLW5hbWU6IGV4cGFuZE91dFdpdGhGYWRlO1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAgIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjJzO1xcbiAgICBhbmltYXRpb24tZHVyYXRpb246IDAuMnM7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gICAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG4gICAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG4gICAgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOiBcXFwiZm9yd2FyZHNcXFwiO1xcbiAgICBhbmltYXRpb24tZmlsbC1tb2RlOiBcXFwiZm9yd2FyZHNcXFwiO1xcbiAgICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXG4gICAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyPz9yZWYtLTItMSEuL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliPz9yZWYtLTItMiEuL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYiEuL3NyYy9hbmltYXRlL21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIDEyIDEzIDE0IDE1IDE2IDE3IDE4IDE5IDIwIDIxIDIyIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBjaGFyc2V0IFxcXCJVVEYtOFxcXCI7XFxuLyoqXFxuICog5bC65a+4IOWfuuehgOWwuuWvuFxcbiAqIOWRveWQjeiDveWcqOivreS5ieeahOWJjeaPkOS4i+eugOWNleWwseWwvemHj+eugOWNlSwg6L+Z6YeM5Y+v5Lul5pivIHNpemUtMngsIHNwYWNlLTJ4LCBzaXplLWJhc2UgLi4uXFxuICog5LiN6L+H5Y+v5Lul5Zyo6K+t5LmJ55qE5YmN5o+Q5LiL5YGa55qE5pu057K+566A5LiA5LqbLCDkuo7mmK/nlKjkuoZzMiwgczHnrYlcXG4gKiDlj6/nlKjlj5jph486IGAkczEgLSAkczhgXFxuICogQGV4YW1wbGUgc2NzcyAtIOS9v+eUqFxcbiAqICAgLmVsZW1lbnQge1xcbiAqICAgICBwYWRkaW5nOiAkczEgIWRlZmF1bHQ7XFxuICogICB9XFxuICpcXG4gKiBAZXhhbXBsZSBjc3MgLSBDU1Mg6L6T5Ye6XFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6IDRweCAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKi9cXG4vKiBzdHlsZWxpbnQtZGlzYWJsZSBtYXgtbmVzdGluZy1kZXB0aCAqL1xcbi5uZXh0LWNoZWNrYm94LXdyYXBwZXIge1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XFxuICAubmV4dC1jaGVja2JveC13cmFwcGVyICosXFxuICAubmV4dC1jaGVja2JveC13cmFwcGVyICo6YmVmb3JlLFxcbiAgLm5leHQtY2hlY2tib3gtd3JhcHBlciAqOmFmdGVyIHtcXG4gICAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH1cXG4gIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIgLm5leHQtY2hlY2tib3gge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGluZS1oZWlnaHQ6IDE7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IH1cXG4gIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIgaW5wdXRbdHlwZT1cXFwiY2hlY2tib3hcXFwiXSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICB3aWR0aDogMTZweDtcXG4gICAgaGVpZ2h0OiAxNnB4O1xcbiAgICBtYXJnaW46IDA7IH1cXG4gIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIgLm5leHQtY2hlY2tib3gtaW5uZXIge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgd2lkdGg6IDE2cHg7XFxuICAgIGhlaWdodDogMTZweDtcXG4gICAgYmFja2dyb3VuZDogI0ZGRkZGRjtcXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjQzRDNkNGO1xcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGVhc2UgYWxsIC4zcyAwcztcXG4gICAgdHJhbnNpdGlvbjogZWFzZSBhbGwgLjNzIDBzO1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICAvKiDpmLLmraLnu6fmib/niLbnuqcgKi9cXG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiBub25lO1xcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IG5vbmU7XFxuICAgIC8qIGJveC1zaXppbmc6IGNvbnRlbnQtYm94OyAqLyB9XFxuICAgIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uIHtcXG4gICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMCk7XFxuICAgICAgICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDApO1xcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwKTtcXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgdG9wOiAwO1xcbiAgICAgIG9wYWNpdHk6IDA7XFxuICAgICAgbGluZS1oZWlnaHQ6IDE2cHg7XFxuICAgICAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgMC4zcyBjdWJpYy1iZXppZXIoMC43OCwgMC4xNCwgMC4xNSwgMC44Nik7XFxuICAgICAgdHJhbnNpdGlvbjogYWxsIDAuM3MgY3ViaWMtYmV6aWVyKDAuNzgsIDAuMTQsIDAuMTUsIDAuODYpO1xcbiAgICAgIGNvbG9yOiAjRkZGRkZGO1xcbiAgICAgIGxlZnQ6IDRweDtcXG4gICAgICBtYXJnaW4tbGVmdDogMDsgfVxcbiAgICAgIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uOmJlZm9yZSB7XFxuICAgICAgICB3aWR0aDogOHB4O1xcbiAgICAgICAgZm9udC1zaXplOiA4cHg7XFxuICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAgIEBtZWRpYSBhbGwgYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDApIGFuZCAobWluLXJlc29sdXRpb246IDAuMDAxZHBjbSkge1xcbiAgICAgICAgLm5leHQtY2hlY2tib3gtd3JhcHBlciAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb24ge1xcbiAgICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC41KTtcXG4gICAgICAgICAgICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDAuNSk7XFxuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjUpO1xcbiAgICAgICAgICBtYXJnaW4tbGVmdDogLTRweDtcXG4gICAgICAgICAgbWFyZ2luLXJpZ2h0OiAtNHB4OyB9XFxuICAgICAgICAgIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uOmJlZm9yZSB7XFxuICAgICAgICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxNnB4OyB9IH1cXG4gICAgLm5leHQtY2hlY2tib3gtd3JhcHBlciAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb246OmJlZm9yZSB7XFxuICAgICAgdmVydGljYWwtYWxpZ246IHRvcDtcXG4gICAgICBtYXJnaW4tdG9wOiAwOyB9XFxuICAubmV4dC1jaGVja2JveC13cmFwcGVyLmNoZWNrZWQgLm5leHQtY2hlY2tib3gtaW5uZXIge1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNTU4NEZGOyB9XFxuICAgIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuY2hlY2tlZCAubmV4dC1jaGVja2JveC1pbm5lcjpob3ZlciwgLm5leHQtY2hlY2tib3gtd3JhcHBlci5jaGVja2VkIC5uZXh0LWNoZWNrYm94LWlubmVyLmhvdmVyZWQge1xcbiAgICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gICAgLm5leHQtY2hlY2tib3gtd3JhcHBlci5jaGVja2VkIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbiB7XFxuICAgICAgb3BhY2l0eTogMTtcXG4gICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgICAgICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gICAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgICAvKiBmb250LXNpemUgPCAxMnB455qE5pe25YCZ6L+b6KGM6KaG55uW44CCICovIH1cXG4gICAgICAubmV4dC1jaGVja2JveC13cmFwcGVyLmNoZWNrZWQgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uOmJlZm9yZSB7XFxuICAgICAgICB3aWR0aDogOHB4O1xcbiAgICAgICAgZm9udC1zaXplOiA4cHg7XFxuICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAgIEBtZWRpYSBhbGwgYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDApIGFuZCAobWluLXJlc29sdXRpb246IDAuMDAxZHBjbSkge1xcbiAgICAgICAgLm5leHQtY2hlY2tib3gtd3JhcHBlci5jaGVja2VkIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbiB7XFxuICAgICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLjUpO1xcbiAgICAgICAgICAgICAgLW1zLXRyYW5zZm9ybTogc2NhbGUoMC41KTtcXG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNSk7XFxuICAgICAgICAgIG1hcmdpbi1sZWZ0OiAtNHB4O1xcbiAgICAgICAgICBtYXJnaW4tcmlnaHQ6IC00cHg7IH1cXG4gICAgICAgICAgLm5leHQtY2hlY2tib3gtd3JhcHBlci5jaGVja2VkIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbjpiZWZvcmUge1xcbiAgICAgICAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTZweDsgfSB9XFxuICAubmV4dC1jaGVja2JveC13cmFwcGVyLmluZGV0ZXJtaW5hdGUgLm5leHQtY2hlY2tib3gtaW5uZXIge1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNTU4NEZGOyB9XFxuICAgIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuaW5kZXRlcm1pbmF0ZSAubmV4dC1jaGVja2JveC1pbm5lcjpob3ZlciwgLm5leHQtY2hlY2tib3gtd3JhcHBlci5pbmRldGVybWluYXRlIC5uZXh0LWNoZWNrYm94LWlubmVyLmhvdmVyZWQge1xcbiAgICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gICAgLm5leHQtY2hlY2tib3gtd3JhcHBlci5pbmRldGVybWluYXRlIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbiB7XFxuICAgICAgb3BhY2l0eTogMTtcXG4gICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUzZCgxLCAxLCAxKTtcXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUzZCgxLCAxLCAxKTtcXG4gICAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgICAvKiBmb250LXNpemUgPCAxMnB455qE5pe25YCZ6L+b6KGM6KaG55uW44CCICovIH1cXG4gICAgICAubmV4dC1jaGVja2JveC13cmFwcGVyLmluZGV0ZXJtaW5hdGUgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uOmJlZm9yZSB7XFxuICAgICAgICB3aWR0aDogOHB4O1xcbiAgICAgICAgZm9udC1zaXplOiA4cHg7XFxuICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAgIEBtZWRpYSBhbGwgYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDApIGFuZCAobWluLXJlc29sdXRpb246IDAuMDAxZHBjbSkge1xcbiAgICAgICAgLm5leHQtY2hlY2tib3gtd3JhcHBlci5pbmRldGVybWluYXRlIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbiB7XFxuICAgICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLjUpO1xcbiAgICAgICAgICAgICAgLW1zLXRyYW5zZm9ybTogc2NhbGUoMC41KTtcXG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNSk7XFxuICAgICAgICAgIG1hcmdpbi1sZWZ0OiAtNHB4O1xcbiAgICAgICAgICBtYXJnaW4tcmlnaHQ6IC00cHg7IH1cXG4gICAgICAgICAgLm5leHQtY2hlY2tib3gtd3JhcHBlci5pbmRldGVybWluYXRlIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbjpiZWZvcmUge1xcbiAgICAgICAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTZweDsgfSB9XFxuICAubmV4dC1jaGVja2JveC13cmFwcGVyLmRpc2FibGVkIGlucHV0W3R5cGU9XFxcImNoZWNrYm94XFxcIl0ge1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkOyB9XFxuICAubmV4dC1jaGVja2JveC13cmFwcGVyLmRpc2FibGVkIC5uZXh0LWNoZWNrYm94LWlubmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjRTZFN0VCO1xcbiAgICBiYWNrZ3JvdW5kOiAjRjdGOEZBOyB9XFxuICAubmV4dC1jaGVja2JveC13cmFwcGVyLmRpc2FibGVkLmNoZWNrZWQgLm5leHQtY2hlY2tib3gtaW5uZXI6aG92ZXIsIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuZGlzYWJsZWQuY2hlY2tlZCAubmV4dC1jaGVja2JveC1pbm5lci5ob3ZlcmVkLCAubmV4dC1jaGVja2JveC13cmFwcGVyLmRpc2FibGVkLmluZGV0ZXJtaW5hdGUgLm5leHQtY2hlY2tib3gtaW5uZXI6aG92ZXIsIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuZGlzYWJsZWQuaW5kZXRlcm1pbmF0ZSAubmV4dC1jaGVja2JveC1pbm5lci5ob3ZlcmVkIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjRTZFN0VCOyB9XFxuICAubmV4dC1jaGVja2JveC13cmFwcGVyLmRpc2FibGVkLmNoZWNrZWQgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uLCAubmV4dC1jaGVja2JveC13cmFwcGVyLmRpc2FibGVkLmluZGV0ZXJtaW5hdGUgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uIHtcXG4gICAgY29sb3I6ICNDQ0NDQ0M7XFxuICAgIG9wYWNpdHk6IDE7IH1cXG4gIC5uZXh0LWNoZWNrYm94LXdyYXBwZXI6bm90KC5kaXNhYmxlZCk6aG92ZXIgLm5leHQtY2hlY2tib3gtaW5uZXIsIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuaG92ZXJlZCAubmV4dC1jaGVja2JveC1pbm5lciwgLm5leHQtY2hlY2tib3gtd3JhcHBlci5mb2N1c2VkIC5uZXh0LWNoZWNrYm94LWlubmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjNTU4NEZGO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjREVFOEZGOyB9XFxuICAubmV4dC1jaGVja2JveC13cmFwcGVyLmluZGV0ZXJtaW5hdGU6bm90KC5kaXNhYmxlZCk6aG92ZXIgLm5leHQtY2hlY2tib3gtaW5uZXIsIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuaW5kZXRlcm1pbmF0ZTpub3QoLmRpc2FibGVkKS5ob3ZlcmVkIC5uZXh0LWNoZWNrYm94LWlubmVyLCAubmV4dC1jaGVja2JveC13cmFwcGVyLmluZGV0ZXJtaW5hdGUuZm9jdXNlZCAubmV4dC1jaGVja2JveC1pbm5lciwgLm5leHQtY2hlY2tib3gtd3JhcHBlci5jaGVja2VkOm5vdCguZGlzYWJsZWQpOmhvdmVyIC5uZXh0LWNoZWNrYm94LWlubmVyLCAubmV4dC1jaGVja2JveC13cmFwcGVyLmNoZWNrZWQ6bm90KC5kaXNhYmxlZCkuaG92ZXJlZCAubmV4dC1jaGVja2JveC1pbm5lciwgLm5leHQtY2hlY2tib3gtd3JhcHBlci5jaGVja2VkLmZvY3VzZWQgLm5leHQtY2hlY2tib3gtaW5uZXIge1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjM0U3MUY3OyB9XFxuICAgIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuaW5kZXRlcm1pbmF0ZTpub3QoLmRpc2FibGVkKTpob3ZlciAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb24sIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuaW5kZXRlcm1pbmF0ZTpub3QoLmRpc2FibGVkKS5ob3ZlcmVkIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbiwgLm5leHQtY2hlY2tib3gtd3JhcHBlci5pbmRldGVybWluYXRlLmZvY3VzZWQgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uLCAubmV4dC1jaGVja2JveC13cmFwcGVyLmNoZWNrZWQ6bm90KC5kaXNhYmxlZCk6aG92ZXIgLm5leHQtY2hlY2tib3gtaW5uZXIgPiAubmV4dC1pY29uLCAubmV4dC1jaGVja2JveC13cmFwcGVyLmNoZWNrZWQ6bm90KC5kaXNhYmxlZCkuaG92ZXJlZCAubmV4dC1jaGVja2JveC1pbm5lciA+IC5uZXh0LWljb24sIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIuY2hlY2tlZC5mb2N1c2VkIC5uZXh0LWNoZWNrYm94LWlubmVyID4gLm5leHQtaWNvbiB7XFxuICAgICAgY29sb3I6ICNGRkZGRkY7XFxuICAgICAgb3BhY2l0eTogMTsgfVxcblxcbi5uZXh0LWNoZWNrYm94LWdyb3VwIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIge1xcbiAgbWFyZ2luLWxlZnQ6IDhweDsgfVxcbiAgLm5leHQtY2hlY2tib3gtZ3JvdXAgLm5leHQtY2hlY2tib3gtd3JhcHBlcjpmaXJzdC1jaGlsZCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwOyB9XFxuXFxuLm5leHQtY2hlY2tib3gtZ3JvdXAtdmVyIC5uZXh0LWNoZWNrYm94LXdyYXBwZXIge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBtYXJnaW4tbGVmdDogMDtcXG4gIG1hcmdpbi1ib3R0b206IDhweDsgfVxcblxcbi5uZXh0LWNoZWNrYm94LWxhYmVsIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBtYXJnaW46IDA7XFxuICBtYXJnaW4tbGVmdDogNHB4O1xcbiAgbGluZS1oZWlnaHQ6IDE7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXI/P3JlZi0tMi0xIS4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWI/P3JlZi0tMi0yIS4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliIS4vc3JjL2NoZWNrYm94L21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIDEyIDEzIDE0IDE1IDE2IDE3IDE4IDE5IDIwIDIxIDIyIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBjaGFyc2V0IFxcXCJVVEYtOFxcXCI7XFxuLyoqXFxuICog5bC65a+4IOWfuuehgOWwuuWvuFxcbiAqIOWRveWQjeiDveWcqOivreS5ieeahOWJjeaPkOS4i+eugOWNleWwseWwvemHj+eugOWNlSwg6L+Z6YeM5Y+v5Lul5pivIHNpemUtMngsIHNwYWNlLTJ4LCBzaXplLWJhc2UgLi4uXFxuICog5LiN6L+H5Y+v5Lul5Zyo6K+t5LmJ55qE5YmN5o+Q5LiL5YGa55qE5pu057K+566A5LiA5LqbLCDkuo7mmK/nlKjkuoZzMiwgczHnrYlcXG4gKiDlj6/nlKjlj5jph486IGAkczEgLSAkczhgXFxuICogQGV4YW1wbGUgc2NzcyAtIOS9v+eUqFxcbiAqICAgLmVsZW1lbnQge1xcbiAqICAgICBwYWRkaW5nOiAkczEgIWRlZmF1bHQ7XFxuICogICB9XFxuICpcXG4gKiBAZXhhbXBsZSBjc3MgLSBDU1Mg6L6T5Ye6XFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6IDRweCAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKi9cXG4ubmV4dC1yYWRpby1idXR0b24tbGFyZ2VbZGlyPSdydGwnXSA+IGxhYmVsOmZpcnN0LWNoaWxkIHtcXG4gIG1hcmdpbi1sZWZ0OiAtMXB4O1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDNweDtcXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAzcHg7XFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMDsgfVxcblxcbi5uZXh0LXJhZGlvLWJ1dHRvbi1sYXJnZVtkaXI9J3J0bCddID4gbGFiZWw6bGFzdC1jaGlsZCB7XFxuICBtYXJnaW4tbGVmdDogMDtcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAzcHg7XFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAzcHg7IH1cXG5cXG4ubmV4dC1yYWRpby1idXR0b24tbGFyZ2VbZGlyPSdydGwnXSAubmV4dC1yYWRpby1sYWJlbCB7XFxuICBoZWlnaHQ6IDM4cHg7XFxuICBsaW5lLWhlaWdodDogMzhweDtcXG4gIGZvbnQtc2l6ZTogMTZweDsgfVxcblxcbi5uZXh0LXJhZGlvLWJ1dHRvbi1tZWRpdW1bZGlyPSdydGwnXSA+IGxhYmVsOmZpcnN0LWNoaWxkIHtcXG4gIG1hcmdpbi1sZWZ0OiAtMXB4O1xcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxuICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogM3B4O1xcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDNweDsgfVxcblxcbi5uZXh0LXJhZGlvLWJ1dHRvbi1tZWRpdW1bZGlyPSdydGwnXSA+IGxhYmVsOmxhc3QtY2hpbGQge1xcbiAgbWFyZ2luLWxlZnQ6IDA7XFxuICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogM3B4O1xcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogM3B4OyB9XFxuXFxuLm5leHQtcmFkaW8tYnV0dG9uLXNtYWxsW2Rpcj0ncnRsJ10gPiBsYWJlbDpmaXJzdC1jaGlsZCB7XFxuICBtYXJnaW4tbGVmdDogLTFweDtcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDA7XFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDNweDtcXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAzcHg7IH1cXG5cXG4ubmV4dC1yYWRpby1idXR0b24tc21hbGxbZGlyPSdydGwnXSA+IGxhYmVsOmxhc3QtY2hpbGQge1xcbiAgbWFyZ2luLWxlZnQ6IDA7XFxuICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogM3B4O1xcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogM3B4OyB9XFxuXFxuLm5leHQtcmFkaW8td3JhcHBlcltkaXI9J3J0bCddIC5uZXh0LXJhZGlvLWxhYmVsIHtcXG4gIG1hcmdpbi1sZWZ0OiAwO1xcbiAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG5cXG4ubmV4dC1yYWRpby1ncm91cFtkaXI9J3J0bCddIC5uZXh0LXJhZGlvLWxhYmVsIHtcXG4gIG1hcmdpbi1yaWdodDogNHB4O1xcbiAgbWFyZ2luLWxlZnQ6IDE2cHg7IH1cXG5cXG4ubmV4dC1yYWRpby1idXR0b25bZGlyPSdydGwnXSA+IGxhYmVsIC5uZXh0LXJhZGlvLWxhYmVsIHtcXG4gIG1hcmdpbjogMDsgfVxcblxcbi5uZXh0LXJhZGlvLXdyYXBwZXIge1xcbiAgb3V0bGluZTogMDsgfVxcbiAgLm5leHQtcmFkaW8td3JhcHBlciAubmV4dC1yYWRpbyB7XFxuICAgIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGluZS1oZWlnaHQ6IDE7IH1cXG4gICAgLm5leHQtcmFkaW8td3JhcHBlciAubmV4dC1yYWRpbyAqLFxcbiAgICAubmV4dC1yYWRpby13cmFwcGVyIC5uZXh0LXJhZGlvICo6YmVmb3JlLFxcbiAgICAubmV4dC1yYWRpby13cmFwcGVyIC5uZXh0LXJhZGlvICo6YWZ0ZXIge1xcbiAgICAgIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH1cXG4gICAgLm5leHQtcmFkaW8td3JhcHBlciAubmV4dC1yYWRpbyBpbnB1dFt0eXBlPVxcXCJyYWRpb1xcXCJdIHtcXG4gICAgICBvcGFjaXR5OiAwO1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICAgIHRvcDogMDtcXG4gICAgICBsZWZ0OiAwO1xcbiAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgIGhlaWdodDogMTZweDtcXG4gICAgICBtYXJnaW46IDA7IH1cXG4gIC5uZXh0LXJhZGlvLXdyYXBwZXIgLm5leHQtcmFkaW8taW5uZXIge1xcbiAgICAvKiDliqjnlLvlvoXlrpogKi9cXG4gICAgLyogJi5tb3VzZURvd24geyAqL1xcbiAgICAvKiAgICAgdHJhbnNmb3JtOiBzY2FsZTNkKC43LCAuNywgLjcpOyAqL1xcbiAgICAvKiAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIC4ycyBsaW5lYXI7ICovXFxuICAgIC8qIH0gKi9cXG4gICAgLyogJi5tb3VzZVVwIHsgKi9cXG4gICAgLyogICAgIHRyYW5zZm9ybTogc2NhbGUzZCgxLCAxLCAxKTsgKi9cXG4gICAgLyogICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAuMnMgbGluZWFyOyAqL1xcbiAgICAvKiB9ICovXFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICB3aWR0aDogMTZweDtcXG4gICAgaGVpZ2h0OiAxNnB4O1xcbiAgICBiYWNrZ3JvdW5kOiAjRkZGRkZGO1xcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNDNEM2Q0Y7XFxuICAgIC13ZWJraXQtdHJhbnNpdGlvbjogZWFzZSBhbGwgLjM2cyAwcztcXG4gICAgdHJhbnNpdGlvbjogZWFzZSBhbGwgLjM2cyAwcztcXG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiBub25lO1xcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IG5vbmU7IH1cXG4gICAgLm5leHQtcmFkaW8td3JhcHBlciAubmV4dC1yYWRpby1pbm5lcjphZnRlciB7XFxuICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDApO1xcbiAgICAgICAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgwKTtcXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gICAgICB0b3A6IDUwJTtcXG4gICAgICBtYXJnaW4tdG9wOiAtMnB4O1xcbiAgICAgIGxlZnQ6IDUwJTtcXG4gICAgICBtYXJnaW4tbGVmdDogLTJweDtcXG4gICAgICBiYWNrZ3JvdW5kOiAjRkZGRkZGO1xcbiAgICAgIGNvbnRlbnQ6ICcgJztcXG4gICAgICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAwLjNzIGN1YmljLWJlemllcigwLjc4LCAwLjE0LCAwLjE1LCAwLjg2KTtcXG4gICAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBjdWJpYy1iZXppZXIoMC43OCwgMC4xNCwgMC4xNSwgMC44Nik7IH1cXG4gIC5uZXh0LXJhZGlvLXdyYXBwZXIuY2hlY2tlZCAubmV4dC1yYWRpby1pbm5lciB7XFxuICAgIGJvcmRlci1jb2xvcjogIzU1ODRGRjtcXG4gICAgYmFja2dyb3VuZDogIzU1ODRGRjsgfVxcbiAgICAubmV4dC1yYWRpby13cmFwcGVyLmNoZWNrZWQgLm5leHQtcmFkaW8taW5uZXI6YWZ0ZXIge1xcbiAgICAgIHdpZHRoOiA0cHg7XFxuICAgICAgaGVpZ2h0OiA0cHg7XFxuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgICAgYmFja2dyb3VuZDogI0ZGRkZGRjtcXG4gICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgICAgICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTsgfVxcbiAgLm5leHQtcmFkaW8td3JhcHBlci5jaGVja2VkOmhvdmVyIC5uZXh0LXJhZGlvLWlubmVyLCAubmV4dC1yYWRpby13cmFwcGVyLmNoZWNrZWQuaG92ZXJlZCAubmV4dC1yYWRpby1pbm5lciB7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gIC5uZXh0LXJhZGlvLXdyYXBwZXIuZGlzYWJsZWQgaW5wdXRbdHlwZT1cXFwicmFkaW9cXFwiXSB7XFxuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7IH1cXG4gIC5uZXh0LXJhZGlvLXdyYXBwZXIuZGlzYWJsZWQgLm5leHQtcmFkaW8taW5uZXIge1xcbiAgICBib3JkZXItY29sb3I6ICNFNkU3RUI7XFxuICAgIGJhY2tncm91bmQ6ICNGN0Y4RkE7IH1cXG4gICAgLm5leHQtcmFkaW8td3JhcHBlci5kaXNhYmxlZCAubmV4dC1yYWRpby1pbm5lcjpob3ZlciwgLm5leHQtcmFkaW8td3JhcHBlci5kaXNhYmxlZCAubmV4dC1yYWRpby1pbm5lci5ob3ZlcmVkIHtcXG4gICAgICBib3JkZXItY29sb3I6ICNFNkU3RUI7IH1cXG4gIC5uZXh0LXJhZGlvLXdyYXBwZXIuZGlzYWJsZWQuY2hlY2tlZCAubmV4dC1yYWRpby1pbm5lcjphZnRlciB7XFxuICAgIGJhY2tncm91bmQ6ICNDQ0NDQ0M7IH1cXG4gIC5uZXh0LXJhZGlvLXdyYXBwZXI6bm90KC5kaXNhYmxlZCk6aG92ZXIgLm5leHQtcmFkaW8taW5uZXIsIC5uZXh0LXJhZGlvLXdyYXBwZXI6bm90KC5kaXNhYmxlZCkuaG92ZXJlZCAubmV4dC1yYWRpby1pbm5lciwgLm5leHQtcmFkaW8td3JhcHBlcjpub3QoLmRpc2FibGVkKTpmb2N1cyAubmV4dC1yYWRpby1pbm5lciwgLm5leHQtcmFkaW8td3JhcHBlcjpub3QoLmRpc2FibGVkKS5mb2N1c2VkIC5uZXh0LXJhZGlvLWlubmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjNTU4NEZGO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjREVFOEZGOyB9XFxuICAubmV4dC1yYWRpby13cmFwcGVyLmNoZWNrZWQ6bm90KC5kaXNhYmxlZCk6aG92ZXIgLm5leHQtcmFkaW8taW5uZXIsIC5uZXh0LXJhZGlvLXdyYXBwZXIuY2hlY2tlZDpub3QoLmRpc2FibGVkKS5ob3ZlcmVkIC5uZXh0LXJhZGlvLWlubmVyLCAubmV4dC1yYWRpby13cmFwcGVyLmNoZWNrZWQ6bm90KC5kaXNhYmxlZCk6Zm9jdXMgLm5leHQtcmFkaW8taW5uZXIsIC5uZXh0LXJhZGlvLXdyYXBwZXIuY2hlY2tlZC5mb2N1c2VkIC5uZXh0LXJhZGlvLWlubmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgYmFja2dyb3VuZDogIzNFNzFGNzsgfVxcbiAgICAubmV4dC1yYWRpby13cmFwcGVyLmNoZWNrZWQ6bm90KC5kaXNhYmxlZCk6aG92ZXIgLm5leHQtcmFkaW8taW5uZXI6YWZ0ZXIsIC5uZXh0LXJhZGlvLXdyYXBwZXIuY2hlY2tlZDpub3QoLmRpc2FibGVkKS5ob3ZlcmVkIC5uZXh0LXJhZGlvLWlubmVyOmFmdGVyLCAubmV4dC1yYWRpby13cmFwcGVyLmNoZWNrZWQ6bm90KC5kaXNhYmxlZCk6Zm9jdXMgLm5leHQtcmFkaW8taW5uZXI6YWZ0ZXIsIC5uZXh0LXJhZGlvLXdyYXBwZXIuY2hlY2tlZC5mb2N1c2VkIC5uZXh0LXJhZGlvLWlubmVyOmFmdGVyIHtcXG4gICAgICBiYWNrZ3JvdW5kOiAjRkZGRkZGOyB9XFxuXFxuLm5leHQtcmFkaW8tYnV0dG9uIC5uZXh0LXJhZGlvIHtcXG4gIHdpZHRoOiAwO1xcbiAgaGVpZ2h0OiAwOyB9XFxuXFxuLm5leHQtcmFkaW8tYnV0dG9uIGlucHV0W3R5cGU9XFxcInJhZGlvXFxcIl0ge1xcbiAgd2lkdGg6IDA7XFxuICBoZWlnaHQ6IDA7IH1cXG5cXG4ubmV4dC1yYWRpby1idXR0b24gPiBsYWJlbCB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB6LWluZGV4OiAxO1xcbiAgbWFyZ2luOiAwIDAgMCAtMXB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI0M0QzZDRjtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkY7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGVhc2UgYWxsIC4zcyAwcztcXG4gIHRyYW5zaXRpb246IGVhc2UgYWxsIC4zcyAwczsgfVxcbiAgLm5leHQtcmFkaW8tYnV0dG9uID4gbGFiZWwgLm5leHQtcmFkaW8tbGFiZWwge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgY29sb3I6ICMzMzMzMzM7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBlYXNlIGFsbCAuM3MgMHM7XFxuICAgIHRyYW5zaXRpb246IGVhc2UgYWxsIC4zcyAwczsgfVxcbiAgLm5leHQtcmFkaW8tYnV0dG9uID4gbGFiZWw6aG92ZXIsIC5uZXh0LXJhZGlvLWJ1dHRvbiA+IGxhYmVsOmZvY3VzLCAubmV4dC1yYWRpby1idXR0b24gPiBsYWJlbC5ob3ZlcmVkIHtcXG4gICAgei1pbmRleDogMTA7XFxuICAgIGJvcmRlci1jb2xvcjogI0EwQTJBRDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0YyRjNGNzsgfVxcbiAgICAubmV4dC1yYWRpby1idXR0b24gPiBsYWJlbDpob3ZlciAubmV4dC1yYWRpby1sYWJlbCwgLm5leHQtcmFkaW8tYnV0dG9uID4gbGFiZWw6Zm9jdXMgLm5leHQtcmFkaW8tbGFiZWwsIC5uZXh0LXJhZGlvLWJ1dHRvbiA+IGxhYmVsLmhvdmVyZWQgLm5leHQtcmFkaW8tbGFiZWwge1xcbiAgICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuICAubmV4dC1yYWRpby1idXR0b24gPiBsYWJlbC5jaGVja2VkIHtcXG4gICAgei1pbmRleDogMTA7XFxuICAgIGJvcmRlci1jb2xvcjogIzU1ODRGRjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRjsgfVxcbiAgICAubmV4dC1yYWRpby1idXR0b24gPiBsYWJlbC5jaGVja2VkIC5uZXh0LXJhZGlvLWxhYmVsIHtcXG4gICAgICBjb2xvcjogIzU1ODRGRjsgfVxcbiAgLm5leHQtcmFkaW8tYnV0dG9uID4gbGFiZWwuZGlzYWJsZWQge1xcbiAgICB6LWluZGV4OiAwO1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgICBib3JkZXItY29sb3I6ICNFNkU3RUI7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y4RkE7IH1cXG4gICAgLm5leHQtcmFkaW8tYnV0dG9uID4gbGFiZWwuZGlzYWJsZWQgLm5leHQtcmFkaW8tbGFiZWwge1xcbiAgICAgIGNvbG9yOiAjQ0NDQ0NDOyB9XFxuICAubmV4dC1yYWRpby1idXR0b24gPiBsYWJlbC5jaGVja2VkLmRpc2FibGVkIHtcXG4gICAgei1pbmRleDogMDtcXG4gICAgYm9yZGVyLWNvbG9yOiAjRTZFN0VCO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjJGM0Y3OyB9XFxuICAgIC5uZXh0LXJhZGlvLWJ1dHRvbiA+IGxhYmVsLmNoZWNrZWQuZGlzYWJsZWQgLm5leHQtcmFkaW8tbGFiZWwge1xcbiAgICAgIGNvbG9yOiAjQ0NDQ0NDOyB9XFxuXFxuLm5leHQtcmFkaW8tYnV0dG9uLWxhcmdlID4gbGFiZWwge1xcbiAgcGFkZGluZzogMCA4cHg7XFxuICBoZWlnaHQ6IDQwcHg7XFxuICBsaW5lLWhlaWdodDogNDBweDsgfVxcbiAgLm5leHQtcmFkaW8tYnV0dG9uLWxhcmdlID4gbGFiZWw6Zmlyc3QtY2hpbGQge1xcbiAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogM3B4O1xcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAzcHg7IH1cXG4gIC5uZXh0LXJhZGlvLWJ1dHRvbi1sYXJnZSA+IGxhYmVsOmxhc3QtY2hpbGQge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogM3B4O1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogM3B4OyB9XFxuXFxuLm5leHQtcmFkaW8tYnV0dG9uLWxhcmdlIC5uZXh0LXJhZGlvLWxhYmVsIHtcXG4gIGhlaWdodDogMzhweDtcXG4gIGxpbmUtaGVpZ2h0OiAzOHB4O1xcbiAgZm9udC1zaXplOiAxNnB4OyB9XFxuXFxuLm5leHQtcmFkaW8tYnV0dG9uLW1lZGl1bSA+IGxhYmVsIHtcXG4gIHBhZGRpbmc6IDAgOHB4O1xcbiAgaGVpZ2h0OiAyOHB4O1xcbiAgbGluZS1oZWlnaHQ6IDI4cHg7IH1cXG4gIC5uZXh0LXJhZGlvLWJ1dHRvbi1tZWRpdW0gPiBsYWJlbDpmaXJzdC1jaGlsZCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAzcHg7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDNweDsgfVxcbiAgLm5leHQtcmFkaW8tYnV0dG9uLW1lZGl1bSA+IGxhYmVsOmxhc3QtY2hpbGQge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogM3B4O1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogM3B4OyB9XFxuXFxuLm5leHQtcmFkaW8tYnV0dG9uLW1lZGl1bSAubmV4dC1yYWRpby1sYWJlbCB7XFxuICBoZWlnaHQ6IDI2cHg7XFxuICBsaW5lLWhlaWdodDogMjZweDtcXG4gIGZvbnQtc2l6ZTogMTJweDsgfVxcblxcbi5uZXh0LXJhZGlvLWJ1dHRvbi1zbWFsbCA+IGxhYmVsIHtcXG4gIHBhZGRpbmc6IDAgOHB4O1xcbiAgaGVpZ2h0OiAyMHB4O1xcbiAgbGluZS1oZWlnaHQ6IDIwcHg7IH1cXG4gIC5uZXh0LXJhZGlvLWJ1dHRvbi1zbWFsbCA+IGxhYmVsOmZpcnN0LWNoaWxkIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDNweDtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogM3B4OyB9XFxuICAubmV4dC1yYWRpby1idXR0b24tc21hbGwgPiBsYWJlbDpsYXN0LWNoaWxkIHtcXG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDNweDtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDNweDsgfVxcblxcbi5uZXh0LXJhZGlvLWJ1dHRvbi1zbWFsbCAubmV4dC1yYWRpby1sYWJlbCB7XFxuICBoZWlnaHQ6IDE4cHg7XFxuICBsaW5lLWhlaWdodDogMThweDtcXG4gIGZvbnQtc2l6ZTogMTJweDsgfVxcblxcbi5uZXh0LXJhZGlvLXNpbmdsZS1pbnB1dCBpbnB1dFt0eXBlPVxcXCJyYWRpb1xcXCJdIHtcXG4gIG9wYWNpdHk6IDA7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgbWFyZ2luOiAwOyB9XFxuXFxuLm5leHQtcmFkaW8tZ3JvdXAge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9XFxuICAubmV4dC1yYWRpby1ncm91cCAubmV4dC1yYWRpby1sYWJlbCB7XFxuICAgIGNvbG9yOiAjMzMzMzMzO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDE2cHg7IH1cXG4gIC5uZXh0LXJhZGlvLWdyb3VwLmRpc2FibGVkIC5uZXh0LXJhZGlvLWxhYmVsIHtcXG4gICAgY29sb3I6ICNDQ0NDQ0M7IH1cXG5cXG4ubmV4dC1yYWRpby1ncm91cC12ZXIgLm5leHQtcmFkaW8td3JhcHBlciB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIG1hcmdpbi1ib3R0b206IDhweDsgfVxcblxcbi5uZXh0LXJhZGlvLWxhYmVsIHtcXG4gIG1hcmdpbjogMDtcXG4gIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICBmb250LXNpemU6IDEycHg7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgbGluZS1oZWlnaHQ6IDE7IH1cXG5cXG5ALW1vei1kb2N1bWVudCB1cmwtcHJlZml4KCkge1xcbiAgLm5leHQtcmFkaW8ge1xcbiAgICBtYXJnaW4tdG9wOiAtMXB4OyB9XFxuICBAc3VwcG9ydHMgKCgtd2Via2l0LWFuaW1hdGlvbjogY2FsYygwcykpIG9yIChhbmltYXRpb246IGNhbGMoMHMpKSkge1xcbiAgICAvKiBmaXJlZm94IDU3KyAqL1xcbiAgICAubmV4dC1yYWRpbyB7XFxuICAgICAgbWFyZ2luLXRvcDogLTNweDsgfSB9IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXI/P3JlZi0tMi0xIS4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWI/P3JlZi0tMi0yIS4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliIS4vc3JjL3JhZGlvL21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIDEyIDEzIDE0IDE1IDE2IDE3IDE4IDE5IDIwIDIxIDIyIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBjaGFyc2V0IFxcXCJVVEYtOFxcXCI7XFxuLyoqXFxuICog5bC65a+4IOWfuuehgOWwuuWvuFxcbiAqIOWRveWQjeiDveWcqOivreS5ieeahOWJjeaPkOS4i+eugOWNleWwseWwvemHj+eugOWNlSwg6L+Z6YeM5Y+v5Lul5pivIHNpemUtMngsIHNwYWNlLTJ4LCBzaXplLWJhc2UgLi4uXFxuICog5LiN6L+H5Y+v5Lul5Zyo6K+t5LmJ55qE5YmN5o+Q5LiL5YGa55qE5pu057K+566A5LiA5LqbLCDkuo7mmK/nlKjkuoZzMiwgczHnrYlcXG4gKiDlj6/nlKjlj5jph486IGAkczEgLSAkczhgXFxuICogQGV4YW1wbGUgc2NzcyAtIOS9v+eUqFxcbiAqICAgLmVsZW1lbnQge1xcbiAqICAgICBwYWRkaW5nOiAkczEgIWRlZmF1bHQ7XFxuICogICB9XFxuICpcXG4gKiBAZXhhbXBsZSBjc3MgLSBDU1Mg6L6T5Ye6XFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6IDRweCAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKi9cXG4ubmV4dC1tZW51W2Rpcj1cXFwicnRsXFxcIl0gLm5leHQtbWVudS1pdGVtLWhlbHBlciB7XFxuICBmbG9hdDogbGVmdDsgfVxcblxcbi5uZXh0LW1lbnVbZGlyPVxcXCJydGxcXFwiXSAubmV4dC1tZW51LWl0ZW0gLm5leHQtY2hlY2tib3gsXFxuLm5leHQtbWVudVtkaXI9XFxcInJ0bFxcXCJdIC5uZXh0LW1lbnUtaXRlbSAubmV4dC1yYWRpbyB7XFxuICBtYXJnaW4tbGVmdDogNHB4O1xcbiAgbWFyZ2luLXJpZ2h0OiAwOyB9XFxuXFxuLm5leHQtbWVudVtkaXI9XFxcInJ0bFxcXCJdIC5uZXh0LW1lbnUtaG96LXJpZ2h0IHtcXG4gIGZsb2F0OiByaWdodDsgfVxcblxcbi5uZXh0LW1lbnVbZGlyPVxcXCJydGxcXFwiXSAubmV4dC1tZW51LWljb24tYXJyb3cubmV4dC1pY29uIHtcXG4gIGxlZnQ6IDEwcHg7XFxuICByaWdodDogYXV0bzsgfVxcblxcbi5uZXh0LW1lbnVbZGlyPVxcXCJydGxcXFwiXSAubmV4dC1tZW51LWhvei1pY29uLWFycm93Lm5leHQtaWNvbiB7XFxuICBsZWZ0OiA2cHg7XFxuICByaWdodDogYXV0bzsgfVxcblxcbi5uZXh0LW1lbnVbZGlyPVxcXCJydGxcXFwiXSAubmV4dC1tZW51LWljb24tc2VsZWN0ZWQubmV4dC1pY29uIHtcXG4gIG1hcmdpbi1sZWZ0OiAwO1xcbiAgbWFyZ2luLXJpZ2h0OiAtMTZweDsgfVxcbiAgLm5leHQtbWVudVtkaXI9XFxcInJ0bFxcXCJdIC5uZXh0LW1lbnUtaWNvbi1zZWxlY3RlZC5uZXh0LWljb246YmVmb3JlIHtcXG4gICAgd2lkdGg6IDEycHg7XFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG5cXG4ubmV4dC1tZW51W2Rpcj1cXFwicnRsXFxcIl0gLm5leHQtbWVudS1pY29uLWFycm93Lm5leHQtaWNvbiB7XFxuICBsZWZ0OiAxMHB4O1xcbiAgcmlnaHQ6IGF1dG87IH1cXG5cXG4ubmV4dC1tZW51IHtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIG1pbi13aWR0aDogMTAwcHg7XFxuICBwYWRkaW5nOiA4cHggMDtcXG4gIG1hcmdpbjogMDtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjRENERUUzO1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiBub25lO1xcbiAgICAgICAgICBib3gtc2hhZG93OiBub25lO1xcbiAgYmFja2dyb3VuZDogI0ZGRkZGRjtcXG4gIGxpbmUtaGVpZ2h0OiAzMnB4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgLyogJi1wb3B1cC1jb250ZW50Lm5leHQtaGlkZSB7ICovXFxuICAvKiAgICAgZGlzcGxheTogbm9uZTsgKi9cXG4gIC8qIH0gKi8gfVxcbiAgLm5leHQtbWVudSAqLFxcbiAgLm5leHQtbWVudSAqOmJlZm9yZSxcXG4gIC5uZXh0LW1lbnUgKjphZnRlciB7XFxuICAgIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XFxuICAubmV4dC1tZW51OmZvY3VzLFxcbiAgLm5leHQtbWVudSAqOmZvY3VzIHtcXG4gICAgb3V0bGluZTogMDsgfVxcbiAgLm5leHQtbWVudS1jb250ZW50IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIGxpc3Qtc3R5bGU6IG5vbmU7IH1cXG4gIC5uZXh0LW1lbnUtc3ViLW1lbnUge1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIGxpc3Qtc3R5bGU6IG5vbmU7IH1cXG4gICAgLm5leHQtbWVudS1zdWItbWVudS5uZXh0LWV4cGFuZC1lbnRlciB7XFxuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjsgfVxcbiAgICAubmV4dC1tZW51LXN1Yi1tZW51Lm5leHQtZXhwYW5kLWVudGVyLWFjdGl2ZSB7XFxuICAgICAgLXdlYmtpdC10cmFuc2l0aW9uOiBoZWlnaHQgLjNzIGVhc2Utb3V0O1xcbiAgICAgIHRyYW5zaXRpb246IGhlaWdodCAuM3MgZWFzZS1vdXQ7IH1cXG4gICAgLm5leHQtbWVudS1zdWItbWVudS5uZXh0LWV4cGFuZC1sZWF2ZSB7XFxuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjsgfVxcbiAgICAubmV4dC1tZW51LXN1Yi1tZW51Lm5leHQtZXhwYW5kLWxlYXZlLWFjdGl2ZSB7XFxuICAgICAgLXdlYmtpdC10cmFuc2l0aW9uOiBoZWlnaHQgLjNzIGVhc2Utb3V0O1xcbiAgICAgIHRyYW5zaXRpb246IGhlaWdodCAuM3MgZWFzZS1vdXQ7IH1cXG4gIC5uZXh0LW1lbnUtaXRlbSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgcGFkZGluZzogMCAyMHB4O1xcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGJhY2tncm91bmQgLjJzIGVhc2U7XFxuICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQgLjJzIGVhc2U7XFxuICAgIGNvbG9yOiAjMzMzMzMzO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7IH1cXG4gICAgLm5leHQtbWVudS1pdGVtLWhlbHBlciB7XFxuICAgICAgZmxvYXQ6IHJpZ2h0O1xcbiAgICAgIGNvbG9yOiAjOTk5OTk5O1xcbiAgICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gICAgICBmb250LXNpemU6IDEycHg7IH1cXG4gICAgLm5leHQtbWVudS1pdGVtIC5uZXh0LWNoZWNrYm94LFxcbiAgICAubmV4dC1tZW51LWl0ZW0gLm5leHQtcmFkaW8ge1xcbiAgICAgIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuICAgIC5uZXh0LW1lbnUtaXRlbS5uZXh0LXNlbGVjdGVkIHtcXG4gICAgICBjb2xvcjogIzMzMzMzMztcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGOyB9XFxuICAgICAgLm5leHQtbWVudS1pdGVtLm5leHQtc2VsZWN0ZWQgLm5leHQtbWVudS1pY29uLWFycm93IHtcXG4gICAgICAgIGNvbG9yOiAjNjY2NjY2OyB9XFxuICAgICAgLm5leHQtbWVudS1pdGVtLm5leHQtc2VsZWN0ZWQgLm5leHQtbWVudS1pY29uLXNlbGVjdGVkIHtcXG4gICAgICAgIGNvbG9yOiAjNTU4NEZGOyB9XFxuICAgIC5uZXh0LW1lbnUtaXRlbS5uZXh0LWRpc2FibGVkLFxcbiAgICAubmV4dC1tZW51LWl0ZW0ubmV4dC1kaXNhYmxlZCAubmV4dC1tZW51LWl0ZW0tdGV4dCA+IGEge1xcbiAgICAgIGNvbG9yOiAjQ0NDQ0NDO1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkY7XFxuICAgICAgY3Vyc29yOiBub3QtYWxsb3dlZDsgfVxcbiAgICAgIC5uZXh0LW1lbnUtaXRlbS5uZXh0LWRpc2FibGVkIC5uZXh0LW1lbnUtaWNvbi1hcnJvdyxcXG4gICAgICAubmV4dC1tZW51LWl0ZW0ubmV4dC1kaXNhYmxlZCAubmV4dC1tZW51LWl0ZW0tdGV4dCA+IGEgLm5leHQtbWVudS1pY29uLWFycm93IHtcXG4gICAgICAgIGNvbG9yOiAjQ0NDQ0NDOyB9XFxuICAgICAgLm5leHQtbWVudS1pdGVtLm5leHQtZGlzYWJsZWQgLm5leHQtbWVudS1pY29uLXNlbGVjdGVkLFxcbiAgICAgIC5uZXh0LW1lbnUtaXRlbS5uZXh0LWRpc2FibGVkIC5uZXh0LW1lbnUtaXRlbS10ZXh0ID4gYSAubmV4dC1tZW51LWljb24tc2VsZWN0ZWQge1xcbiAgICAgICAgY29sb3I6ICNDQ0NDQ0M7IH1cXG4gICAgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCk6aG92ZXIsIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpLm5leHQtc2VsZWN0ZWQ6aG92ZXIsIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpLm5leHQtc2VsZWN0ZWQubmV4dC1mb2N1c2VkOmhvdmVyLCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKS5uZXh0LXNlbGVjdGVkOmZvY3VzOmhvdmVyLCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKS5uZXh0LWZvY3VzZWQsIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpOmZvY3VzLCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKS5uZXh0LXNlbGVjdGVkLm5leHQtZm9jdXNlZCwgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCkubmV4dC1zZWxlY3RlZDpmb2N1cyB7XFxuICAgICAgY29sb3I6ICMzMzMzMzM7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0YyRjNGNzsgfVxcbiAgICAgIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpOmhvdmVyIC5uZXh0LW1lbnUtaWNvbi1hcnJvdywgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCkubmV4dC1zZWxlY3RlZDpob3ZlciAubmV4dC1tZW51LWljb24tYXJyb3csIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpLm5leHQtc2VsZWN0ZWQubmV4dC1mb2N1c2VkOmhvdmVyIC5uZXh0LW1lbnUtaWNvbi1hcnJvdywgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCkubmV4dC1zZWxlY3RlZDpmb2N1czpob3ZlciAubmV4dC1tZW51LWljb24tYXJyb3csIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpLm5leHQtZm9jdXNlZCAubmV4dC1tZW51LWljb24tYXJyb3csIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpOmZvY3VzIC5uZXh0LW1lbnUtaWNvbi1hcnJvdywgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCkubmV4dC1zZWxlY3RlZC5uZXh0LWZvY3VzZWQgLm5leHQtbWVudS1pY29uLWFycm93LCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKS5uZXh0LXNlbGVjdGVkOmZvY3VzIC5uZXh0LW1lbnUtaWNvbi1hcnJvdyB7XFxuICAgICAgICBjb2xvcjogIzMzMzMzMzsgfVxcbiAgICAgIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpOmhvdmVyIC5uZXh0LW1lbnUtaWNvbi1zZWxlY3RlZCwgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCkubmV4dC1zZWxlY3RlZDpob3ZlciAubmV4dC1tZW51LWljb24tc2VsZWN0ZWQsIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpLm5leHQtc2VsZWN0ZWQubmV4dC1mb2N1c2VkOmhvdmVyIC5uZXh0LW1lbnUtaWNvbi1zZWxlY3RlZCwgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCkubmV4dC1zZWxlY3RlZDpmb2N1czpob3ZlciAubmV4dC1tZW51LWljb24tc2VsZWN0ZWQsIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpLm5leHQtZm9jdXNlZCAubmV4dC1tZW51LWljb24tc2VsZWN0ZWQsIC5uZXh0LW1lbnUtaXRlbTpub3QoLm5leHQtZGlzYWJsZWQpOmZvY3VzIC5uZXh0LW1lbnUtaWNvbi1zZWxlY3RlZCwgLm5leHQtbWVudS1pdGVtOm5vdCgubmV4dC1kaXNhYmxlZCkubmV4dC1zZWxlY3RlZC5uZXh0LWZvY3VzZWQgLm5leHQtbWVudS1pY29uLXNlbGVjdGVkLCAubmV4dC1tZW51LWl0ZW06bm90KC5uZXh0LWRpc2FibGVkKS5uZXh0LXNlbGVjdGVkOmZvY3VzIC5uZXh0LW1lbnUtaWNvbi1zZWxlY3RlZCB7XFxuICAgICAgICBjb2xvcjogIzU1ODRGRjsgfVxcbiAgLm5leHQtbWVudS1pdGVtLWlubmVyIHtcXG4gICAgaGVpZ2h0OiAzMnB4O1xcbiAgICBmb250LXNpemU6IDEycHg7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgICB3b3JkLXdyYXA6IG5vcm1hbDsgfVxcbiAgLm5leHQtbWVudS1pdGVtLXRleHQge1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB9XFxuICAgIC5uZXh0LW1lbnUtaXRlbS10ZXh0ID4gYSB7XFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICBjb2xvcjogIzMzMzMzMzsgfVxcbiAgICAgIC5uZXh0LW1lbnUtaXRlbS10ZXh0ID4gYTo6YmVmb3JlIHtcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgdG9wOiAwO1xcbiAgICAgICAgbGVmdDogMDtcXG4gICAgICAgIGJvdHRvbTogMDtcXG4gICAgICAgIHJpZ2h0OiAwO1xcbiAgICAgICAgY29udGVudDogJyc7IH1cXG4gIC5uZXh0LW1lbnUubmV4dC1ob3oge1xcbiAgICBwYWRkaW5nOiAwOyB9XFxuICAgIC5uZXh0LW1lbnUubmV4dC1ob3ogPiAubmV4dC1tZW51LWl0ZW0sXFxuICAgIC5uZXh0LW1lbnUubmV4dC1ob3ogLm5leHQtbWVudS1jb250ZW50ID4gLm5leHQtbWVudS1pdGVtIHtcXG4gICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgdmVydGljYWwtYWxpZ246IHRvcDsgfVxcbiAgICAubmV4dC1tZW51Lm5leHQtaG96IC5uZXh0LW1lbnUtaGVhZGVyLFxcbiAgICAubmV4dC1tZW51Lm5leHQtaG96IC5uZXh0LW1lbnUtY29udGVudCxcXG4gICAgLm5leHQtbWVudS5uZXh0LWhveiAubmV4dC1tZW51LWZvb3RlciB7XFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9XFxuICAubmV4dC1tZW51LWhvei1yaWdodCB7XFxuICAgIGZsb2F0OiByaWdodDsgfVxcbiAgLm5leHQtbWVudS1ncm91cC1sYWJlbCB7XFxuICAgIHBhZGRpbmc6IDAgMTJweDtcXG4gICAgY29sb3I6ICM5OTk5OTk7IH1cXG4gIC5uZXh0LW1lbnUtZGl2aWRlciB7XFxuICAgIG1hcmdpbjogOHB4IDEycHg7XFxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjRTZFN0VCOyB9XFxuICAubmV4dC1tZW51IC5uZXh0LW1lbnUtaWNvbi1zZWxlY3RlZC5uZXh0LWljb24ge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgbWFyZ2luLWxlZnQ6IC0xNnB4OyB9XFxuICAgIC5uZXh0LW1lbnUgLm5leHQtbWVudS1pY29uLXNlbGVjdGVkLm5leHQtaWNvbjpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgLm5leHQtbWVudSAubmV4dC1tZW51LWljb24tYXJyb3cubmV4dC1pY29uIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIHJpZ2h0OiAxMHB4O1xcbiAgICBjb2xvcjogIzY2NjY2NjtcXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgZWFzZSAuM3M7XFxuICAgIHRyYW5zaXRpb246IGFsbCBlYXNlIC4zczsgfVxcbiAgICAubmV4dC1tZW51IC5uZXh0LW1lbnUtaWNvbi1hcnJvdy5uZXh0LWljb246YmVmb3JlIHtcXG4gICAgICB3aWR0aDogOHB4O1xcbiAgICAgIGZvbnQtc2l6ZTogOHB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgIEBtZWRpYSBhbGwgYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDApIGFuZCAobWluLXJlc29sdXRpb246IDAuMDAxZHBjbSkge1xcbiAgICAgIC5uZXh0LW1lbnUgLm5leHQtbWVudS1pY29uLWFycm93Lm5leHQtaWNvbiB7XFxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC41KTtcXG4gICAgICAgICAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgwLjUpO1xcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNSk7XFxuICAgICAgICBtYXJnaW4tbGVmdDogLTRweDtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogLTRweDsgfVxcbiAgICAgICAgLm5leHQtbWVudSAubmV4dC1tZW51LWljb24tYXJyb3cubmV4dC1pY29uOmJlZm9yZSB7XFxuICAgICAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgICAgICBmb250LXNpemU6IDE2cHg7IH0gfVxcbiAgLm5leHQtbWVudSAubmV4dC1tZW51LWljb24tYXJyb3ctZG93bi5uZXh0LW9wZW4ge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XFxuICAgICAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpOyB9XFxuICAgIC5uZXh0LW1lbnUgLm5leHQtbWVudS1pY29uLWFycm93LWRvd24ubmV4dC1vcGVuOmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDhweDtcXG4gICAgICBmb250LXNpemU6IDhweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICBAbWVkaWEgYWxsIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAwKSBhbmQgKG1pbi1yZXNvbHV0aW9uOiAwLjAwMWRwY20pIHtcXG4gICAgICAubmV4dC1tZW51IC5uZXh0LW1lbnUtaWNvbi1hcnJvdy1kb3duLm5leHQtb3BlbiB7XFxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC41KSByb3RhdGUoMTgwZGVnKTtcXG4gICAgICAgICAgICAtbXMtdHJhbnNmb3JtOiBzY2FsZSgwLjUpIHJvdGF0ZSgxODBkZWcpO1xcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNSkgcm90YXRlKDE4MGRlZyk7XFxuICAgICAgICBtYXJnaW4tbGVmdDogLTRweDtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogLTRweDsgfVxcbiAgICAgICAgLm5leHQtbWVudSAubmV4dC1tZW51LWljb24tYXJyb3ctZG93bi5uZXh0LW9wZW46YmVmb3JlIHtcXG4gICAgICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMTZweDsgfSB9XFxuICAubmV4dC1tZW51IC5uZXh0LW1lbnUtaWNvbi1hcnJvdy1yaWdodC5uZXh0LW9wZW4ge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKC05MGRlZyk7XFxuICAgICAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoLTkwZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtOTBkZWcpOyB9XFxuICAgIC5uZXh0LW1lbnUgLm5leHQtbWVudS1pY29uLWFycm93LXJpZ2h0Lm5leHQtb3BlbjpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiA4cHg7XFxuICAgICAgZm9udC1zaXplOiA4cHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgQG1lZGlhIGFsbCBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMCkgYW5kIChtaW4tcmVzb2x1dGlvbjogMC4wMDFkcGNtKSB7XFxuICAgICAgLm5leHQtbWVudSAubmV4dC1tZW51LWljb24tYXJyb3ctcmlnaHQubmV4dC1vcGVuIHtcXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLjUpIHJvdGF0ZSgtOTBkZWcpO1xcbiAgICAgICAgICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDAuNSkgcm90YXRlKC05MGRlZyk7XFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC41KSByb3RhdGUoLTkwZGVnKTtcXG4gICAgICAgIG1hcmdpbi1sZWZ0OiAtNHB4O1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAtNHB4OyB9XFxuICAgICAgICAubmV4dC1tZW51IC5uZXh0LW1lbnUtaWNvbi1hcnJvdy1yaWdodC5uZXh0LW9wZW46YmVmb3JlIHtcXG4gICAgICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMTZweDsgfSB9XFxuICAubmV4dC1tZW51IC5uZXh0LW1lbnUtaG96LWljb24tYXJyb3cubmV4dC1pY29uIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIHJpZ2h0OiA2cHg7XFxuICAgIGNvbG9yOiAjNjY2NjY2O1xcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCBlYXNlIC4zcztcXG4gICAgdHJhbnNpdGlvbjogYWxsIGVhc2UgLjNzOyB9XFxuICAgIC5uZXh0LW1lbnUgLm5leHQtbWVudS1ob3otaWNvbi1hcnJvdy5uZXh0LWljb246YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTJweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gIC5uZXh0LW1lbnUgLm5leHQtbWVudS1ob3otaWNvbi1hcnJvdy5uZXh0LW9wZW4ge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XFxuICAgICAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpOyB9XFxuICAgIC5uZXh0LW1lbnUgLm5leHQtbWVudS1ob3otaWNvbi1hcnJvdy5uZXh0LW9wZW46YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTJweDtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gIC5uZXh0LW1lbnUubmV4dC1jb250ZXh0IHtcXG4gICAgbGluZS1oZWlnaHQ6IDI0cHg7IH1cXG4gICAgLm5leHQtbWVudS5uZXh0LWNvbnRleHQgLm5leHQtbWVudS1pdGVtLWlubmVyIHtcXG4gICAgICBoZWlnaHQ6IDI0cHg7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXI/P3JlZi0tMi0xIS4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWI/P3JlZi0tMi0yIS4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliIS4vc3JjL21lbnUvbWFpbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkgMTAgMTEgMTIgMTMgMTQgMTUgMTYgMTcgMTggMTkgMjAgMjEgMjIiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGNoYXJzZXQgXFxcIlVURi04XFxcIjtcXG4vKipcXG4gKiDlsLrlr7gg5Z+656GA5bC65a+4XFxuICog5ZG95ZCN6IO95Zyo6K+t5LmJ55qE5YmN5o+Q5LiL566A5Y2V5bCx5bC96YeP566A5Y2VLCDov5nph4zlj6/ku6XmmK8gc2l6ZS0yeCwgc3BhY2UtMngsIHNpemUtYmFzZSAuLi5cXG4gKiDkuI3ov4flj6/ku6XlnKjor63kuYnnmoTliY3mj5DkuIvlgZrnmoTmm7Tnsr7nroDkuIDkupssIOS6juaYr+eUqOS6hnMyLCBzMeetiVxcbiAqIOWPr+eUqOWPmOmHjzogYCRzMSAtICRzOGBcXG4gKiBAZXhhbXBsZSBzY3NzIC0g5L2/55SoXFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6ICRzMSAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKlxcbiAqIEBleGFtcGxlIGNzcyAtIENTUyDovpPlh7pcXG4gKiAgIC5lbGVtZW50IHtcXG4gKiAgICAgcGFkZGluZzogNHB4ICFkZWZhdWx0O1xcbiAqICAgfVxcbiAqL1xcbi5uZXh0LWJ0biB7XFxuICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH1cXG4gIC5uZXh0LWJ0biAqLFxcbiAgLm5leHQtYnRuICo6YmVmb3JlLFxcbiAgLm5leHQtYnRuICo6YWZ0ZXIge1xcbiAgICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDsgfVxcbiAgLm5leHQtYnRuOjotbW96LWZvY3VzLWlubmVyIHtcXG4gICAgYm9yZGVyOiAwO1xcbiAgICBwYWRkaW5nOiAwOyB9XFxuICAubmV4dC1idG4sIC5uZXh0LWJ0bjphY3RpdmUsIC5uZXh0LWJ0bjpmb2N1cywgLm5leHQtYnRuOmhvdmVyIHtcXG4gICAgb3V0bGluZTogMDsgfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBsb2FkaW5nQ2lyY2xlIHtcXG4gIDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7IH1cXG4gIDEwMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XFxuICAgICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogNTAlIDUwJTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH0gfVxcblxcbkBrZXlmcmFtZXMgbG9hZGluZ0NpcmNsZSB7XFxuICAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogNTAlIDUwJTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpOyB9XFxuICAxMDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpOyB9IH1cXG5cXG4ubmV4dC1idG4ge1xcbiAgLyog5bC65a+457u05bqmICovXFxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuICAvKiDmma7pgJrmjInpkq4gKi9cXG4gIC8qIOaZrumAmuaAgeemgeeUqOagt+W8jyAqL1xcbiAgLyog6K2m5ZGK5oyJ6ZKuICovXFxuICAvKiDmlofmnKzmjInpkq4gKi9cXG4gIC8qIGxvYWRpbmcgKi9cXG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXG4gIC8qIOW5veeBteaMiemSriAqL1xcbiAgLyog57uE5ZCIICovXFxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovIH1cXG4gIC5uZXh0LWJ0biB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IG5vbmU7XFxuICAgICAgICAgICAgYm94LXNoYWRvdzogbm9uZTtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIHRleHQtdHJhbnNmb3JtOiBub25lO1xcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAuM3MgZWFzZS1vdXQ7XFxuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZS1vdXQ7XFxuICAgIGN1cnNvcjogcG9pbnRlcjsgfVxcbiAgICAubmV4dC1idG46YWZ0ZXIge1xcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgb3BhY2l0eTogMDtcXG4gICAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICAgICAgLXdlYmtpdC10cmFuc2l0aW9uOiBvcGFjaXR5IC41cyBlYXNlO1xcbiAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgLjVzIGVhc2U7IH1cXG4gICAgLm5leHQtYnRuIC5uZXh0LWljb24ubmV4dC14czpiZWZvcmUge1xcbiAgICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTsgfVxcbiAgICAubmV4dC1idG4uaG92ZXIsIC5uZXh0LWJ0bjpob3ZlciB7XFxuICAgICAgLXdlYmtpdC1ib3gtc2hhZG93OiBub25lO1xcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogbm9uZTsgfVxcbiAgLm5leHQtYnRuLm5leHQtc21hbGwge1xcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICAgIHBhZGRpbmc6IDAgOHB4O1xcbiAgICBoZWlnaHQ6IDIwcHg7XFxuICAgIGxpbmUtaGVpZ2h0OiAxOHB4O1xcbiAgICBmb250LXNpemU6IDEycHg7XFxuICAgIGJvcmRlci13aWR0aDogMXB4OyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LXNtYWxsID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0IHtcXG4gICAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgICAgIC5uZXh0LWJ0bi5uZXh0LXNtYWxsID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0OmJlZm9yZSB7XFxuICAgICAgICB3aWR0aDogMTJweDtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LXNtYWxsID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Qge1xcbiAgICAgIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAwOyB9XFxuICAgICAgLm5leHQtYnRuLm5leHQtc21hbGwgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdDpiZWZvcmUge1xcbiAgICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1zbWFsbCA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1hbG9uZTpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1zbWFsbC5uZXh0LWJ0bi1sb2FkaW5nIHtcXG4gICAgICBwYWRkaW5nLWxlZnQ6IDI0cHg7IH1cXG4gICAgICAubmV4dC1idG4ubmV4dC1zbWFsbC5uZXh0LWJ0bi1sb2FkaW5nOmFmdGVyIHtcXG4gICAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgICAgaGVpZ2h0OiAxMnB4O1xcbiAgICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IDEycHg7XFxuICAgICAgICBsZWZ0OiA4cHg7XFxuICAgICAgICB0b3A6IDUwJTtcXG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgIG1hcmdpbi10b3A6IC02cHg7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgICAgIC5uZXh0LWJ0bi5uZXh0LXNtYWxsLm5leHQtYnRuLWxvYWRpbmcgPiAubmV4dC1pY29uIHtcXG4gICAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gIC5uZXh0LWJ0bi5uZXh0LW1lZGl1bSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gICAgcGFkZGluZzogMCAxMnB4O1xcbiAgICBoZWlnaHQ6IDI4cHg7XFxuICAgIGxpbmUtaGVpZ2h0OiAyNnB4O1xcbiAgICBmb250LXNpemU6IDEycHg7XFxuICAgIGJvcmRlci13aWR0aDogMXB4OyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LW1lZGl1bSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdCB7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gICAgICAubmV4dC1idG4ubmV4dC1tZWRpdW0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Q6YmVmb3JlIHtcXG4gICAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtbWVkaXVtID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Qge1xcbiAgICAgIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAwOyB9XFxuICAgICAgLm5leHQtYnRuLm5leHQtbWVkaXVtID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Q6YmVmb3JlIHtcXG4gICAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtbWVkaXVtID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWFsb25lOmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LW1lZGl1bS5uZXh0LWJ0bi1sb2FkaW5nIHtcXG4gICAgICBwYWRkaW5nLWxlZnQ6IDI4cHg7IH1cXG4gICAgICAubmV4dC1idG4ubmV4dC1tZWRpdW0ubmV4dC1idG4tbG9hZGluZzphZnRlciB7XFxuICAgICAgICB3aWR0aDogMTJweDtcXG4gICAgICAgIGhlaWdodDogMTJweDtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxMnB4O1xcbiAgICAgICAgbGVmdDogMTJweDtcXG4gICAgICAgIHRvcDogNTAlO1xcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICAgICAgbWFyZ2luLXRvcDogLTZweDtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuICAgICAgLm5leHQtYnRuLm5leHQtbWVkaXVtLm5leHQtYnRuLWxvYWRpbmcgPiAubmV4dC1pY29uIHtcXG4gICAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gIC5uZXh0LWJ0bi5uZXh0LWxhcmdlIHtcXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgICBwYWRkaW5nOiAwIDE2cHg7XFxuICAgIGhlaWdodDogNDBweDtcXG4gICAgbGluZS1oZWlnaHQ6IDM4cHg7XFxuICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gICAgYm9yZGVyLXdpZHRoOiAxcHg7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtbGFyZ2UgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Qge1xcbiAgICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICAgIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuICAgICAgLm5leHQtYnRuLm5leHQtbGFyZ2UgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Q6YmVmb3JlIHtcXG4gICAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtbGFyZ2UgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdCB7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG4gICAgICAubmV4dC1idG4ubmV4dC1sYXJnZSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0OmJlZm9yZSB7XFxuICAgICAgICB3aWR0aDogMTZweDtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LWxhcmdlID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWFsb25lOmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LWxhcmdlLm5leHQtYnRuLWxvYWRpbmcge1xcbiAgICAgIHBhZGRpbmctbGVmdDogMzZweDsgfVxcbiAgICAgIC5uZXh0LWJ0bi5uZXh0LWxhcmdlLm5leHQtYnRuLWxvYWRpbmc6YWZ0ZXIge1xcbiAgICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgICBoZWlnaHQ6IDE2cHg7XFxuICAgICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgICBsaW5lLWhlaWdodDogMTZweDtcXG4gICAgICAgIGxlZnQ6IDE2cHg7XFxuICAgICAgICB0b3A6IDUwJTtcXG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgIG1hcmdpbi10b3A6IC04cHg7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgICAgIC5uZXh0LWJ0bi5uZXh0LWxhcmdlLm5leHQtYnRuLWxvYWRpbmcgPiAubmV4dC1pY29uIHtcXG4gICAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gIC5uZXh0LWJ0bi5uZXh0LWJ0bi1ub3JtYWwge1xcbiAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGO1xcbiAgICBib3JkZXItY29sb3I6ICNDNEM2Q0Y7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtYnRuLW5vcm1hbCwgLm5leHQtYnRuLm5leHQtYnRuLW5vcm1hbDpsaW5rLCAubmV4dC1idG4ubmV4dC1idG4tbm9ybWFsOnZpc2l0ZWQsIC5uZXh0LWJ0bi5uZXh0LWJ0bi1ub3JtYWwudmlzaXRlZCB7XFxuICAgICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtYnRuLW5vcm1hbDpmb2N1cywgLm5leHQtYnRuLm5leHQtYnRuLW5vcm1hbDpob3ZlciwgLm5leHQtYnRuLm5leHQtYnRuLW5vcm1hbC5ob3ZlciwgLm5leHQtYnRuLm5leHQtYnRuLW5vcm1hbDphY3RpdmUsIC5uZXh0LWJ0bi5uZXh0LWJ0bi1ub3JtYWwuYWN0aXZlIHtcXG4gICAgICBjb2xvcjogIzMzMzMzMztcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjJGM0Y3O1xcbiAgICAgIGJvcmRlci1jb2xvcjogI0EwQTJBRDtcXG4gICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG4gIC5uZXh0LWJ0bi5uZXh0LWJ0bi1wcmltYXJ5IHtcXG4gICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzU1ODRGRjtcXG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1idG4tcHJpbWFyeSwgLm5leHQtYnRuLm5leHQtYnRuLXByaW1hcnk6bGluaywgLm5leHQtYnRuLm5leHQtYnRuLXByaW1hcnk6dmlzaXRlZCwgLm5leHQtYnRuLm5leHQtYnRuLXByaW1hcnkudmlzaXRlZCB7XFxuICAgICAgY29sb3I6ICNGRkZGRkY7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtYnRuLXByaW1hcnk6Zm9jdXMsIC5uZXh0LWJ0bi5uZXh0LWJ0bi1wcmltYXJ5OmhvdmVyLCAubmV4dC1idG4ubmV4dC1idG4tcHJpbWFyeS5ob3ZlciwgLm5leHQtYnRuLm5leHQtYnRuLXByaW1hcnk6YWN0aXZlLCAubmV4dC1idG4ubmV4dC1idG4tcHJpbWFyeS5hY3RpdmUge1xcbiAgICAgIGNvbG9yOiAjRkZGRkZGO1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICMzRTcxRjc7XFxuICAgICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG4gIC5uZXh0LWJ0bi5uZXh0LWJ0bi1zZWNvbmRhcnkge1xcbiAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGO1xcbiAgICBib3JkZXItY29sb3I6ICM1NTg0RkY7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtYnRuLXNlY29uZGFyeSwgLm5leHQtYnRuLm5leHQtYnRuLXNlY29uZGFyeTpsaW5rLCAubmV4dC1idG4ubmV4dC1idG4tc2Vjb25kYXJ5OnZpc2l0ZWQsIC5uZXh0LWJ0bi5uZXh0LWJ0bi1zZWNvbmRhcnkudmlzaXRlZCB7XFxuICAgICAgY29sb3I6ICM1NTg0RkY7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtYnRuLXNlY29uZGFyeTpmb2N1cywgLm5leHQtYnRuLm5leHQtYnRuLXNlY29uZGFyeTpob3ZlciwgLm5leHQtYnRuLm5leHQtYnRuLXNlY29uZGFyeS5ob3ZlciwgLm5leHQtYnRuLm5leHQtYnRuLXNlY29uZGFyeTphY3RpdmUsIC5uZXh0LWJ0bi5uZXh0LWJ0bi1zZWNvbmRhcnkuYWN0aXZlIHtcXG4gICAgICBjb2xvcjogI0ZGRkZGRjtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjM0U3MUY3O1xcbiAgICAgIGJvcmRlci1jb2xvcjogIzNFNzFGNztcXG4gICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG4gIC5uZXh0LWJ0bi5kaXNhYmxlZCwgLm5leHQtYnRuW2Rpc2FibGVkXSB7XFxuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y4RkE7XFxuICAgIGJvcmRlci1jb2xvcjogI0U2RTdFQjsgfVxcbiAgICAubmV4dC1idG4uZGlzYWJsZWQsIC5uZXh0LWJ0bi5kaXNhYmxlZDpsaW5rLCAubmV4dC1idG4uZGlzYWJsZWQ6dmlzaXRlZCwgLm5leHQtYnRuLmRpc2FibGVkLnZpc2l0ZWQsIC5uZXh0LWJ0bltkaXNhYmxlZF0sIC5uZXh0LWJ0bltkaXNhYmxlZF06bGluaywgLm5leHQtYnRuW2Rpc2FibGVkXTp2aXNpdGVkLCAubmV4dC1idG5bZGlzYWJsZWRdLnZpc2l0ZWQge1xcbiAgICAgIGNvbG9yOiAjQ0NDQ0NDOyB9XFxuICAgIC5uZXh0LWJ0bi5kaXNhYmxlZDpmb2N1cywgLm5leHQtYnRuLmRpc2FibGVkOmhvdmVyLCAubmV4dC1idG4uZGlzYWJsZWQuaG92ZXIsIC5uZXh0LWJ0bi5kaXNhYmxlZDphY3RpdmUsIC5uZXh0LWJ0bi5kaXNhYmxlZC5hY3RpdmUsIC5uZXh0LWJ0bltkaXNhYmxlZF06Zm9jdXMsIC5uZXh0LWJ0bltkaXNhYmxlZF06aG92ZXIsIC5uZXh0LWJ0bltkaXNhYmxlZF0uaG92ZXIsIC5uZXh0LWJ0bltkaXNhYmxlZF06YWN0aXZlLCAubmV4dC1idG5bZGlzYWJsZWRdLmFjdGl2ZSB7XFxuICAgICAgY29sb3I6ICNDQ0NDQ0M7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjhGQTtcXG4gICAgICBib3JkZXItY29sb3I6ICNFNkU3RUI7XFxuICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuICAubmV4dC1idG4td2FybmluZyB7XFxuICAgIGJvcmRlci1zdHlsZTogc29saWQ7IH1cXG4gICAgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeSB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGMzAwMDtcXG4gICAgICBib3JkZXItY29sb3I6ICNGRjMwMDA7IH1cXG4gICAgICAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5LCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5OmxpbmssIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnk6dmlzaXRlZCwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeS52aXNpdGVkIHtcXG4gICAgICAgIGNvbG9yOiAjRkZGRkZGOyB9XFxuICAgICAgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeTpmb2N1cywgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeTpob3ZlciwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeS5ob3ZlciwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeTphY3RpdmUsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnkuYWN0aXZlIHtcXG4gICAgICAgIGNvbG9yOiAjRkZGRkZGO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0U3MkIwMDtcXG4gICAgICAgIGJvcmRlci1jb2xvcjogI0U3MkIwMDtcXG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbiAgICAgIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnkuZGlzYWJsZWQsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnlbZGlzYWJsZWRdIHtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y4RkE7XFxuICAgICAgICBib3JkZXItY29sb3I6ICNEQ0RFRTM7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnkuZGlzYWJsZWQsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnkuZGlzYWJsZWQ6bGluaywgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeS5kaXNhYmxlZDp2aXNpdGVkLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5LmRpc2FibGVkLnZpc2l0ZWQsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnlbZGlzYWJsZWRdLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5W2Rpc2FibGVkXTpsaW5rLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5W2Rpc2FibGVkXTp2aXNpdGVkLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5W2Rpc2FibGVkXS52aXNpdGVkIHtcXG4gICAgICAgICAgY29sb3I6ICNDQ0NDQ0M7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnkuZGlzYWJsZWQ6Zm9jdXMsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnkuZGlzYWJsZWQ6aG92ZXIsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnkuZGlzYWJsZWQuaG92ZXIsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnkuZGlzYWJsZWQ6YWN0aXZlLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5LmRpc2FibGVkLmFjdGl2ZSwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeVtkaXNhYmxlZF06Zm9jdXMsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLXByaW1hcnlbZGlzYWJsZWRdOmhvdmVyLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5W2Rpc2FibGVkXS5ob3ZlciwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tcHJpbWFyeVtkaXNhYmxlZF06YWN0aXZlLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1wcmltYXJ5W2Rpc2FibGVkXS5hY3RpdmUge1xcbiAgICAgICAgICBjb2xvcjogI0NDQ0NDQztcXG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjhGQTtcXG4gICAgICAgICAgYm9yZGVyLWNvbG9yOiAjRENERUUzO1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG4gICAgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGO1xcbiAgICAgIGJvcmRlci1jb2xvcjogI0ZGMzAwMDsgfVxcbiAgICAgIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbCwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsOmxpbmssIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbDp2aXNpdGVkLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWwudmlzaXRlZCB7XFxuICAgICAgICBjb2xvcjogI0ZGMzAwMDsgfVxcbiAgICAgIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbDpmb2N1cywgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsOmhvdmVyLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWwuaG92ZXIsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbDphY3RpdmUsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbC5hY3RpdmUge1xcbiAgICAgICAgY29sb3I6ICNGRkZGRkY7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRTcyQjAwO1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiAjRTcyQjAwO1xcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuICAgICAgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsLmRpc2FibGVkLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWxbZGlzYWJsZWRdIHtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y4RkE7XFxuICAgICAgICBib3JkZXItY29sb3I6ICNFNkU3RUI7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbC5kaXNhYmxlZCwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsLmRpc2FibGVkOmxpbmssIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbC5kaXNhYmxlZDp2aXNpdGVkLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWwuZGlzYWJsZWQudmlzaXRlZCwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsW2Rpc2FibGVkXSwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsW2Rpc2FibGVkXTpsaW5rLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWxbZGlzYWJsZWRdOnZpc2l0ZWQsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbFtkaXNhYmxlZF0udmlzaXRlZCB7XFxuICAgICAgICAgIGNvbG9yOiAjQ0NDQ0NDOyB9XFxuICAgICAgICAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWwuZGlzYWJsZWQ6Zm9jdXMsIC5uZXh0LWJ0bi13YXJuaW5nLm5leHQtYnRuLW5vcm1hbC5kaXNhYmxlZDpob3ZlciwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsLmRpc2FibGVkLmhvdmVyLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWwuZGlzYWJsZWQ6YWN0aXZlLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWwuZGlzYWJsZWQuYWN0aXZlLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWxbZGlzYWJsZWRdOmZvY3VzLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWxbZGlzYWJsZWRdOmhvdmVyLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWxbZGlzYWJsZWRdLmhvdmVyLCAubmV4dC1idG4td2FybmluZy5uZXh0LWJ0bi1ub3JtYWxbZGlzYWJsZWRdOmFjdGl2ZSwgLm5leHQtYnRuLXdhcm5pbmcubmV4dC1idG4tbm9ybWFsW2Rpc2FibGVkXS5hY3RpdmUge1xcbiAgICAgICAgICBjb2xvcjogI0NDQ0NDQztcXG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjhGQTtcXG4gICAgICAgICAgYm9yZGVyLWNvbG9yOiAjRTZFN0VCO1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG4gIC5uZXh0LWJ0bi10ZXh0IHtcXG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiBub25lO1xcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IG5vbmU7XFxuICAgIGJvcmRlci1yYWRpdXM6IDA7IH1cXG4gICAgLm5leHQtYnRuLXRleHQuaG92ZXIsIC5uZXh0LWJ0bi10ZXh0OmhvdmVyIHtcXG4gICAgICAtd2Via2l0LWJveC1zaGFkb3c6IG5vbmU7XFxuICAgICAgICAgICAgICBib3gtc2hhZG93OiBub25lOyB9XFxuICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXByaW1hcnkge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1wcmltYXJ5LCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1wcmltYXJ5OmxpbmssIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXByaW1hcnk6dmlzaXRlZCwgLm5leHQtYnRuLXRleHQubmV4dC1idG4tcHJpbWFyeS52aXNpdGVkIHtcXG4gICAgICAgIGNvbG9yOiAjNTU4NEZGOyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1idG4tcHJpbWFyeTpmb2N1cywgLm5leHQtYnRuLXRleHQubmV4dC1idG4tcHJpbWFyeTpob3ZlciwgLm5leHQtYnRuLXRleHQubmV4dC1idG4tcHJpbWFyeS5ob3ZlciwgLm5leHQtYnRuLXRleHQubmV4dC1idG4tcHJpbWFyeTphY3RpdmUsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXByaW1hcnkuYWN0aXZlIHtcXG4gICAgICAgIGNvbG9yOiAjM0U3MUY3O1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXNlY29uZGFyeSB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXNlY29uZGFyeSwgLm5leHQtYnRuLXRleHQubmV4dC1idG4tc2Vjb25kYXJ5OmxpbmssIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXNlY29uZGFyeTp2aXNpdGVkLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1zZWNvbmRhcnkudmlzaXRlZCB7XFxuICAgICAgICBjb2xvcjogIzY2NjY2NjsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXNlY29uZGFyeTpmb2N1cywgLm5leHQtYnRuLXRleHQubmV4dC1idG4tc2Vjb25kYXJ5OmhvdmVyLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1zZWNvbmRhcnkuaG92ZXIsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXNlY29uZGFyeTphY3RpdmUsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLXNlY29uZGFyeS5hY3RpdmUge1xcbiAgICAgICAgY29sb3I6ICM1NTg0RkY7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG4gICAgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbm9ybWFsIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbm9ybWFsLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1ub3JtYWw6bGluaywgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbm9ybWFsOnZpc2l0ZWQsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLW5vcm1hbC52aXNpdGVkIHtcXG4gICAgICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbm9ybWFsOmZvY3VzLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1ub3JtYWw6aG92ZXIsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLW5vcm1hbC5ob3ZlciwgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbm9ybWFsOmFjdGl2ZSwgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbm9ybWFsLmFjdGl2ZSB7XFxuICAgICAgICBjb2xvcjogIzU1ODRGRjtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbiAgICAubmV4dC1idG4tdGV4dC5uZXh0LWxhcmdlIHtcXG4gICAgICBib3JkZXItcmFkaXVzOiAwO1xcbiAgICAgIHBhZGRpbmc6IDAgMDtcXG4gICAgICBoZWlnaHQ6IDI0cHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IDI0cHg7XFxuICAgICAgZm9udC1zaXplOiAxNHB4O1xcbiAgICAgIGJvcmRlci13aWR0aDogMDsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtbGFyZ2UgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Qge1xcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1sYXJnZSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdDpiZWZvcmUge1xcbiAgICAgICAgICB3aWR0aDogMTZweDtcXG4gICAgICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtbGFyZ2UgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdCB7XFxuICAgICAgICBtYXJnaW4tbGVmdDogNHB4O1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAwOyB9XFxuICAgICAgICAubmV4dC1idG4tdGV4dC5uZXh0LWxhcmdlID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Q6YmVmb3JlIHtcXG4gICAgICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LWxhcmdlID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWFsb25lOmJlZm9yZSB7XFxuICAgICAgICB3aWR0aDogMTZweDtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1sYXJnZS5uZXh0LWJ0bi1sb2FkaW5nIHtcXG4gICAgICAgIHBhZGRpbmctbGVmdDogMjBweDsgfVxcbiAgICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1sYXJnZS5uZXh0LWJ0bi1sb2FkaW5nOmFmdGVyIHtcXG4gICAgICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgICAgIGhlaWdodDogMTZweDtcXG4gICAgICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogMTZweDtcXG4gICAgICAgICAgbGVmdDogMDtcXG4gICAgICAgICAgdG9wOiA1MCU7XFxuICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgICAgbWFyZ2luLXRvcDogLThweDtcXG4gICAgICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtbGFyZ2UubmV4dC1idG4tbG9hZGluZyA+IC5uZXh0LWljb24ge1xcbiAgICAgICAgICBkaXNwbGF5OiBub25lOyB9XFxuICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtbWVkaXVtIHtcXG4gICAgICBib3JkZXItcmFkaXVzOiAwO1xcbiAgICAgIHBhZGRpbmc6IDAgMDtcXG4gICAgICBoZWlnaHQ6IDIwcHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IDIwcHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGJvcmRlci13aWR0aDogMDsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtbWVkaXVtID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0IHtcXG4gICAgICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtbWVkaXVtID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0OmJlZm9yZSB7XFxuICAgICAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1tZWRpdW0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdCB7XFxuICAgICAgICBtYXJnaW4tbGVmdDogNHB4O1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAwOyB9XFxuICAgICAgICAubmV4dC1idG4tdGV4dC5uZXh0LW1lZGl1bSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0OmJlZm9yZSB7XFxuICAgICAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1tZWRpdW0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tYWxvbmU6YmVmb3JlIHtcXG4gICAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LW1lZGl1bS5uZXh0LWJ0bi1sb2FkaW5nIHtcXG4gICAgICAgIHBhZGRpbmctbGVmdDogMTZweDsgfVxcbiAgICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1tZWRpdW0ubmV4dC1idG4tbG9hZGluZzphZnRlciB7XFxuICAgICAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgICAgICBoZWlnaHQ6IDEycHg7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IDEycHg7XFxuICAgICAgICAgIGxlZnQ6IDA7XFxuICAgICAgICAgIHRvcDogNTAlO1xcbiAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgICAgICAgIG1hcmdpbi10b3A6IC02cHg7XFxuICAgICAgICAgIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuICAgICAgICAubmV4dC1idG4tdGV4dC5uZXh0LW1lZGl1bS5uZXh0LWJ0bi1sb2FkaW5nID4gLm5leHQtaWNvbiB7XFxuICAgICAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gICAgLm5leHQtYnRuLXRleHQubmV4dC1zbWFsbCB7XFxuICAgICAgYm9yZGVyLXJhZGl1czogMDtcXG4gICAgICBwYWRkaW5nOiAwIDA7XFxuICAgICAgaGVpZ2h0OiAxNnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiAxNnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBib3JkZXItd2lkdGg6IDA7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LXNtYWxsID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0IHtcXG4gICAgICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtc21hbGwgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Q6YmVmb3JlIHtcXG4gICAgICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LXNtYWxsID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Qge1xcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogMDsgfVxcbiAgICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1zbWFsbCA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0OmJlZm9yZSB7XFxuICAgICAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1zbWFsbCA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1hbG9uZTpiZWZvcmUge1xcbiAgICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtc21hbGwubmV4dC1idG4tbG9hZGluZyB7XFxuICAgICAgICBwYWRkaW5nLWxlZnQ6IDE2cHg7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtc21hbGwubmV4dC1idG4tbG9hZGluZzphZnRlciB7XFxuICAgICAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgICAgICBoZWlnaHQ6IDEycHg7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IDEycHg7XFxuICAgICAgICAgIGxlZnQ6IDA7XFxuICAgICAgICAgIHRvcDogNTAlO1xcbiAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgICAgICAgIG1hcmdpbi10b3A6IC02cHg7XFxuICAgICAgICAgIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuICAgICAgICAubmV4dC1idG4tdGV4dC5uZXh0LXNtYWxsLm5leHQtYnRuLWxvYWRpbmcgPiAubmV4dC1pY29uIHtcXG4gICAgICAgICAgZGlzcGxheTogbm9uZTsgfVxcbiAgICAubmV4dC1idG4tdGV4dC5kaXNhYmxlZCwgLm5leHQtYnRuLXRleHRbZGlzYWJsZWRdIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQuZGlzYWJsZWQsIC5uZXh0LWJ0bi10ZXh0LmRpc2FibGVkOmxpbmssIC5uZXh0LWJ0bi10ZXh0LmRpc2FibGVkOnZpc2l0ZWQsIC5uZXh0LWJ0bi10ZXh0LmRpc2FibGVkLnZpc2l0ZWQsIC5uZXh0LWJ0bi10ZXh0W2Rpc2FibGVkXSwgLm5leHQtYnRuLXRleHRbZGlzYWJsZWRdOmxpbmssIC5uZXh0LWJ0bi10ZXh0W2Rpc2FibGVkXTp2aXNpdGVkLCAubmV4dC1idG4tdGV4dFtkaXNhYmxlZF0udmlzaXRlZCB7XFxuICAgICAgICBjb2xvcjogI0NDQ0NDQzsgfVxcbiAgICAgIC5uZXh0LWJ0bi10ZXh0LmRpc2FibGVkOmZvY3VzLCAubmV4dC1idG4tdGV4dC5kaXNhYmxlZDpob3ZlciwgLm5leHQtYnRuLXRleHQuZGlzYWJsZWQuaG92ZXIsIC5uZXh0LWJ0bi10ZXh0LmRpc2FibGVkOmFjdGl2ZSwgLm5leHQtYnRuLXRleHQuZGlzYWJsZWQuYWN0aXZlLCAubmV4dC1idG4tdGV4dFtkaXNhYmxlZF06Zm9jdXMsIC5uZXh0LWJ0bi10ZXh0W2Rpc2FibGVkXTpob3ZlciwgLm5leHQtYnRuLXRleHRbZGlzYWJsZWRdLmhvdmVyLCAubmV4dC1idG4tdGV4dFtkaXNhYmxlZF06YWN0aXZlLCAubmV4dC1idG4tdGV4dFtkaXNhYmxlZF0uYWN0aXZlIHtcXG4gICAgICAgIGNvbG9yOiAjQ0NDQ0NDO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuICAgIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLWxvYWRpbmcge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gICAgICAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1sb2FkaW5nLCAubmV4dC1idG4tdGV4dC5uZXh0LWJ0bi1sb2FkaW5nOmxpbmssIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLWxvYWRpbmc6dmlzaXRlZCwgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbG9hZGluZy52aXNpdGVkIHtcXG4gICAgICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuICAgICAgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbG9hZGluZzpmb2N1cywgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbG9hZGluZzpob3ZlciwgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbG9hZGluZy5ob3ZlciwgLm5leHQtYnRuLXRleHQubmV4dC1idG4tbG9hZGluZzphY3RpdmUsIC5uZXh0LWJ0bi10ZXh0Lm5leHQtYnRuLWxvYWRpbmcuYWN0aXZlIHtcXG4gICAgICAgIGNvbG9yOiAjMzMzMzMzO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuICAubmV4dC1idG4tbG9hZGluZyB7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lOyB9XFxuICAgIC5uZXh0LWJ0bi1sb2FkaW5nOmFmdGVyIHtcXG4gICAgICBmb250LWZhbWlseTogTmV4dEljb247XFxuICAgICAgY29udGVudDogXFxcIlxcXFxFNjQ2XFxcIjtcXG4gICAgICBvcGFjaXR5OiAxO1xcbiAgICAgIHZpc2liaWxpdHk6IHZpc2libGU7XFxuICAgICAgLXdlYmtpdC1hbmltYXRpb246IGxvYWRpbmdDaXJjbGUgMnMgaW5maW5pdGUgbGluZWFyO1xcbiAgICAgICAgICAgICAgYW5pbWF0aW9uOiBsb2FkaW5nQ2lyY2xlIDJzIGluZmluaXRlIGxpbmVhcjsgfVxcbiAgLm5leHQtYnRuLWdob3N0IHtcXG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiBub25lO1xcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IG5vbmU7XFxuICAgIGJvcmRlci1zdHlsZTogc29saWQ7IH1cXG4gICAgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmsge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgIGJvcmRlci1jb2xvcjogI0ZGRkZGRjsgfVxcbiAgICAgIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyazpsaW5rLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyazp2aXNpdGVkLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyay52aXNpdGVkIHtcXG4gICAgICAgIGNvbG9yOiAjRkZGRkZGOyB9XFxuICAgICAgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcms6Zm9jdXMsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrOmhvdmVyLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyay5ob3ZlciwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcms6YWN0aXZlLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyay5hY3RpdmUge1xcbiAgICAgICAgY29sb3I6ICNGRkZGRkY7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XFxuICAgICAgICBib3JkZXItY29sb3I6ICNGRkZGRkY7XFxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG4gICAgICAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyay5kaXNhYmxlZCwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmtbZGlzYWJsZWRdIHtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNCk7IH1cXG4gICAgICAgIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrLmRpc2FibGVkLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyay5kaXNhYmxlZDpsaW5rLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyay5kaXNhYmxlZDp2aXNpdGVkLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyay5kaXNhYmxlZC52aXNpdGVkLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFya1tkaXNhYmxlZF0sIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrW2Rpc2FibGVkXTpsaW5rLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFya1tkaXNhYmxlZF06dmlzaXRlZCwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmtbZGlzYWJsZWRdLnZpc2l0ZWQge1xcbiAgICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjQpOyB9XFxuICAgICAgICAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyay5kaXNhYmxlZDpmb2N1cywgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmsuZGlzYWJsZWQ6aG92ZXIsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrLmRpc2FibGVkLmhvdmVyLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFyay5kaXNhYmxlZDphY3RpdmUsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrLmRpc2FibGVkLmFjdGl2ZSwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmtbZGlzYWJsZWRdOmZvY3VzLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tZGFya1tkaXNhYmxlZF06aG92ZXIsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1kYXJrW2Rpc2FibGVkXS5ob3ZlciwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmtbZGlzYWJsZWRdOmFjdGl2ZSwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWRhcmtbZGlzYWJsZWRdLmFjdGl2ZSB7XFxuICAgICAgICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNCk7XFxuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgICBib3JkZXItY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC40KTtcXG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuICAgIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodCB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgYm9yZGVyLWNvbG9yOiAjMzMzMzMzOyB9XFxuICAgICAgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0LCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQ6bGluaywgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0OnZpc2l0ZWQsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodC52aXNpdGVkIHtcXG4gICAgICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuICAgICAgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0OmZvY3VzLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQ6aG92ZXIsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodC5ob3ZlciwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0OmFjdGl2ZSwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0LmFjdGl2ZSB7XFxuICAgICAgICBjb2xvcjogIzk5OTk5OTtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC45Mik7XFxuICAgICAgICBib3JkZXItY29sb3I6ICMzMzMzMzM7XFxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG4gICAgICAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQuZGlzYWJsZWQsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodFtkaXNhYmxlZF0ge1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICBib3JkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4xKTsgfVxcbiAgICAgICAgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0LmRpc2FibGVkLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQuZGlzYWJsZWQ6bGluaywgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0LmRpc2FibGVkOnZpc2l0ZWQsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodC5kaXNhYmxlZC52aXNpdGVkLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHRbZGlzYWJsZWRdLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHRbZGlzYWJsZWRdOmxpbmssIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodFtkaXNhYmxlZF06dmlzaXRlZCwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0W2Rpc2FibGVkXS52aXNpdGVkIHtcXG4gICAgICAgICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4xKTsgfVxcbiAgICAgICAgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0LmRpc2FibGVkOmZvY3VzLCAubmV4dC1idG4tZ2hvc3QubmV4dC1idG4tbGlnaHQuZGlzYWJsZWQ6aG92ZXIsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodC5kaXNhYmxlZC5ob3ZlciwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0LmRpc2FibGVkOmFjdGl2ZSwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0LmRpc2FibGVkLmFjdGl2ZSwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0W2Rpc2FibGVkXTpmb2N1cywgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0W2Rpc2FibGVkXTpob3ZlciwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0W2Rpc2FibGVkXS5ob3ZlciwgLm5leHQtYnRuLWdob3N0Lm5leHQtYnRuLWxpZ2h0W2Rpc2FibGVkXTphY3RpdmUsIC5uZXh0LWJ0bi1naG9zdC5uZXh0LWJ0bi1saWdodFtkaXNhYmxlZF0uYWN0aXZlIHtcXG4gICAgICAgICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4xKTtcXG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICAgIGJvcmRlci1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjEpO1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG4gIC5uZXh0LWJ0bi1ncm91cCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB9XFxuICAgIC5uZXh0LWJ0bi1ncm91cCA+IC5uZXh0LWJ0biB7XFxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgIGZsb2F0OiBsZWZ0O1xcbiAgICAgIC13ZWJraXQtYm94LXNoYWRvdzogbm9uZTtcXG4gICAgICAgICAgICAgIGJveC1zaGFkb3c6IG5vbmU7IH1cXG4gICAgICAubmV4dC1idG4tZ3JvdXAgPiAubmV4dC1idG46aG92ZXIsIC5uZXh0LWJ0bi1ncm91cCA+IC5uZXh0LWJ0bjpmb2N1cywgLm5leHQtYnRuLWdyb3VwID4gLm5leHQtYnRuOmFjdGl2ZSwgLm5leHQtYnRuLWdyb3VwID4gLm5leHQtYnRuLmFjdGl2ZSB7XFxuICAgICAgICB6LWluZGV4OiAxOyB9XFxuICAgICAgLm5leHQtYnRuLWdyb3VwID4gLm5leHQtYnRuLmRpc2FibGVkLCAubmV4dC1idG4tZ3JvdXAgPiAubmV4dC1idG5bZGlzYWJsZWRdIHtcXG4gICAgICAgIHotaW5kZXg6IDA7IH1cXG4gICAgLm5leHQtYnRuLWdyb3VwIC5uZXh0LWJ0bi5uZXh0LWJ0biB7XFxuICAgICAgbWFyZ2luOiAwIDAgMCAtMXB4OyB9XFxuICAgIC5uZXh0LWJ0bi1ncm91cCAubmV4dC1idG46bm90KDpmaXJzdC1jaGlsZCk6bm90KDpsYXN0LWNoaWxkKSB7XFxuICAgICAgYm9yZGVyLXJhZGl1czogMDsgfVxcbiAgICAubmV4dC1idG4tZ3JvdXAgPiAubmV4dC1idG46Zmlyc3QtY2hpbGQge1xcbiAgICAgIG1hcmdpbjogMDsgfVxcbiAgICAubmV4dC1idG4tZ3JvdXAgPiAubmV4dC1idG46Zmlyc3QtY2hpbGQ6bm90KDpsYXN0LWNoaWxkKSB7XFxuICAgICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuICAgICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7IH1cXG4gICAgLm5leHQtYnRuLWdyb3VwID4gLm5leHQtYnRuOmxhc3QtY2hpbGQ6bm90KDpmaXJzdC1jaGlsZCkge1xcbiAgICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxuICAgICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDsgfVxcbiAgICAubmV4dC1idG4tZ3JvdXAgPiAubmV4dC1idG4tcHJpbWFyeTpub3QoOmZpcnN0LWNoaWxkKSB7XFxuICAgICAgYm9yZGVyLWxlZnQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTsgfVxcbiAgICAgIC5uZXh0LWJ0bi1ncm91cCA+IC5uZXh0LWJ0bi1wcmltYXJ5Om5vdCg6Zmlyc3QtY2hpbGQpOmhvdmVyIHtcXG4gICAgICAgIGJvcmRlci1sZWZ0LWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbiAgICAgIC5uZXh0LWJ0bi1ncm91cCA+IC5uZXh0LWJ0bi1wcmltYXJ5Om5vdCg6Zmlyc3QtY2hpbGQpLmRpc2FibGVkLCAubmV4dC1idG4tZ3JvdXAgPiAubmV4dC1idG4tcHJpbWFyeTpub3QoOmZpcnN0LWNoaWxkKVtkaXNhYmxlZF0ge1xcbiAgICAgICAgYm9yZGVyLWxlZnQtY29sb3I6ICNFNkU3RUI7IH1cXG5cXG4vKiDnu4TlkIggKi9cXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuLm5leHQtYnRuLWdyb3VwW2Rpcj1cXFwicnRsXFxcIl0gPiAubmV4dC1idG4ge1xcbiAgZmxvYXQ6IHJpZ2h0OyB9XFxuXFxuLm5leHQtYnRuLWdyb3VwW2Rpcj1cXFwicnRsXFxcIl0gLm5leHQtYnRuLm5leHQtYnRuIHtcXG4gIG1hcmdpbjogMCAtMXB4IDAgMDsgfVxcblxcbi5uZXh0LWJ0bi1ncm91cFtkaXI9XFxcInJ0bFxcXCJdID4gLm5leHQtYnRuOmZpcnN0LWNoaWxkOm5vdCg6bGFzdC1jaGlsZCkge1xcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMDtcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDA7IH1cXG5cXG4ubmV4dC1idG4tZ3JvdXBbZGlyPVxcXCJydGxcXFwiXSA+IC5uZXh0LWJ0bjpsYXN0LWNoaWxkOm5vdCg6Zmlyc3QtY2hpbGQpIHtcXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7IH1cXG5cXG4ubmV4dC1idG4tZ3JvdXBbZGlyPVxcXCJydGxcXFwiXSA+IC5uZXh0LWJ0bi1wcmltYXJ5Om5vdCg6Zmlyc3QtY2hpbGQpIHtcXG4gIGJvcmRlci1yaWdodC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpOyB9XFxuICAubmV4dC1idG4tZ3JvdXBbZGlyPVxcXCJydGxcXFwiXSA+IC5uZXh0LWJ0bi1wcmltYXJ5Om5vdCg6Zmlyc3QtY2hpbGQpOmhvdmVyIHtcXG4gICAgYm9yZGVyLXJpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbiAgLm5leHQtYnRuLWdyb3VwW2Rpcj1cXFwicnRsXFxcIl0gPiAubmV4dC1idG4tcHJpbWFyeTpub3QoOmZpcnN0LWNoaWxkKS5kaXNhYmxlZCwgLm5leHQtYnRuLWdyb3VwW2Rpcj1cXFwicnRsXFxcIl0gPiAubmV4dC1idG4tcHJpbWFyeTpub3QoOmZpcnN0LWNoaWxkKVtkaXNhYmxlZF0ge1xcbiAgICBib3JkZXItcmlnaHQtY29sb3I6ICNFNkU3RUI7IH1cXG5cXG4vKiDlsLrlr7jnu7TluqYgKi9cXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuLm5leHQtYnRuLm5leHQtc21hbGxbZGlyPVxcXCJydGxcXFwiXSB7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7IH1cXG4gIC5uZXh0LWJ0bi5uZXh0LXNtYWxsW2Rpcj1cXFwicnRsXFxcIl0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Qge1xcbiAgICBtYXJnaW4tbGVmdDogNHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtc21hbGxbZGlyPVxcXCJydGxcXFwiXSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdDpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgLm5leHQtYnRuLm5leHQtc21hbGxbZGlyPVxcXCJydGxcXFwiXSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LXNtYWxsW2Rpcj1cXFwicnRsXFxcIl0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdDpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgLm5leHQtYnRuLm5leHQtc21hbGxbZGlyPVxcXCJydGxcXFwiXS5uZXh0LWJ0bi1sb2FkaW5nIHtcXG4gICAgcGFkZGluZy1sZWZ0OiA4cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDI0cHg7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtc21hbGxbZGlyPVxcXCJydGxcXFwiXS5uZXh0LWJ0bi1sb2FkaW5nOmFmdGVyIHtcXG4gICAgICByaWdodDogOHB4O1xcbiAgICAgIHRvcDogNTAlO1xcbiAgICAgIG1hcmdpbi1yaWdodDogMDtcXG4gICAgICBtYXJnaW4tbGVmdDogNHB4OyB9XFxuXFxuLm5leHQtYnRuLm5leHQtbWVkaXVtW2Rpcj1cXFwicnRsXFxcIl0ge1xcbiAgYm9yZGVyLXJhZGl1czogM3B4OyB9XFxuICAubmV4dC1idG4ubmV4dC1tZWRpdW1bZGlyPVxcXCJydGxcXFwiXSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICAgIG1hcmdpbi1yaWdodDogMDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1tZWRpdW1bZGlyPVxcXCJydGxcXFwiXSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdDpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgLm5leHQtYnRuLm5leHQtbWVkaXVtW2Rpcj1cXFwicnRsXFxcIl0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgICAubmV4dC1idG4ubmV4dC1tZWRpdW1bZGlyPVxcXCJydGxcXFwiXSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0OmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC1idG4ubmV4dC1tZWRpdW1bZGlyPVxcXCJydGxcXFwiXS5uZXh0LWJ0bi1sb2FkaW5nIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAxMnB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAyOHB4OyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LW1lZGl1bVtkaXI9XFxcInJ0bFxcXCJdLm5leHQtYnRuLWxvYWRpbmc6YWZ0ZXIge1xcbiAgICAgIHJpZ2h0OiAxMnB4O1xcbiAgICAgIHRvcDogNTAlO1xcbiAgICAgIG1hcmdpbi1yaWdodDogMDtcXG4gICAgICBtYXJnaW4tbGVmdDogNHB4OyB9XFxuXFxuLm5leHQtYnRuLm5leHQtbGFyZ2VbZGlyPVxcXCJydGxcXFwiXSB7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7IH1cXG4gIC5uZXh0LWJ0bi5uZXh0LWxhcmdlW2Rpcj1cXFwicnRsXFxcIl0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Qge1xcbiAgICBtYXJnaW4tbGVmdDogNHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG4gICAgLm5leHQtYnRuLm5leHQtbGFyZ2VbZGlyPVxcXCJydGxcXFwiXSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdDpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgLm5leHQtYnRuLm5leHQtbGFyZ2VbZGlyPVxcXCJydGxcXFwiXSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIG1hcmdpbi1yaWdodDogNHB4OyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LWxhcmdlW2Rpcj1cXFwicnRsXFxcIl0gPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdDpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgLm5leHQtYnRuLm5leHQtbGFyZ2VbZGlyPVxcXCJydGxcXFwiXS5uZXh0LWJ0bi1sb2FkaW5nIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAxNnB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAzNnB4OyB9XFxuICAgIC5uZXh0LWJ0bi5uZXh0LWxhcmdlW2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1idG4tbG9hZGluZzphZnRlciB7XFxuICAgICAgcmlnaHQ6IDE2cHg7XFxuICAgICAgdG9wOiA1MCU7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgICAgIG1hcmdpbi1sZWZ0OiA0cHg7IH1cXG5cXG4vKiDmlofmnKzmjInpkq4gKi9cXG4ubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtbGFyZ2Uge1xcbiAgYm9yZGVyLXJhZGl1czogMDsgfVxcbiAgLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LWxhcmdlID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwOyB9XFxuICAgIC5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1sYXJnZSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdDpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LWxhcmdlID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Qge1xcbiAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gICAgLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LWxhcmdlID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Q6YmVmb3JlIHtcXG4gICAgICB3aWR0aDogMTZweDtcXG4gICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gIC5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1sYXJnZS5uZXh0LWJ0bi1sb2FkaW5nIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAwO1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAyMHB4OyB9XFxuICAgIC5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1sYXJnZS5uZXh0LWJ0bi1sb2FkaW5nOmFmdGVyIHtcXG4gICAgICByaWdodDogMDtcXG4gICAgICB0b3A6IDUwJTtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDA7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDRweDsgfVxcblxcbi5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1tZWRpdW0ge1xcbiAgYm9yZGVyLXJhZGl1czogMDsgfVxcbiAgLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LW1lZGl1bSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1maXJzdCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICAgIG1hcmdpbi1yaWdodDogMDsgfVxcbiAgICAubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtbWVkaXVtID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0OmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtbWVkaXVtID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWxhc3Qge1xcbiAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgbWFyZ2luLXJpZ2h0OiA0cHg7IH1cXG4gICAgLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LW1lZGl1bSA+IC5uZXh0LWJ0bi1pY29uLm5leHQtaWNvbi1sYXN0OmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtbWVkaXVtLm5leHQtYnRuLWxvYWRpbmcge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDA7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDE2cHg7IH1cXG4gICAgLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LW1lZGl1bS5uZXh0LWJ0bi1sb2FkaW5nOmFmdGVyIHtcXG4gICAgICByaWdodDogMDtcXG4gICAgICB0b3A6IDUwJTtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDA7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDRweDsgfVxcblxcbi5uZXh0LWJ0bi10ZXh0W2Rpcj1cXFwicnRsXFxcIl0ubmV4dC1zbWFsbCB7XFxuICBib3JkZXItcmFkaXVzOiAwOyB9XFxuICAubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtc21hbGwgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tZmlyc3Qge1xcbiAgICBtYXJnaW4tbGVmdDogNHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG4gICAgLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LXNtYWxsID4gLm5leHQtYnRuLWljb24ubmV4dC1pY29uLWZpcnN0OmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuICAubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtc21hbGwgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDRweDsgfVxcbiAgICAubmV4dC1idG4tdGV4dFtkaXI9XFxcInJ0bFxcXCJdLm5leHQtc21hbGwgPiAubmV4dC1idG4taWNvbi5uZXh0LWljb24tbGFzdDpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LXNtYWxsLm5leHQtYnRuLWxvYWRpbmcge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDA7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDE2cHg7IH1cXG4gICAgLm5leHQtYnRuLXRleHRbZGlyPVxcXCJydGxcXFwiXS5uZXh0LXNtYWxsLm5leHQtYnRuLWxvYWRpbmc6YWZ0ZXIge1xcbiAgICAgIHJpZ2h0OiAwO1xcbiAgICAgIHRvcDogNTAlO1xcbiAgICAgIG1hcmdpbi1yaWdodDogMDtcXG4gICAgICBtYXJnaW4tbGVmdDogNHB4OyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyPz9yZWYtLTItMSEuL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliPz9yZWYtLTItMiEuL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYiEuL3NyYy9idXR0b24vbWFpbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkgMTAgMTEgMTIgMTMgMTQgMTUgMTYgMTcgMTggMTkgMjAgMjEgMjIiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGNoYXJzZXQgXFxcIlVURi04XFxcIjtcXG4vKipcXG4gKiDlsLrlr7gg5Z+656GA5bC65a+4XFxuICog5ZG95ZCN6IO95Zyo6K+t5LmJ55qE5YmN5o+Q5LiL566A5Y2V5bCx5bC96YeP566A5Y2VLCDov5nph4zlj6/ku6XmmK8gc2l6ZS0yeCwgc3BhY2UtMngsIHNpemUtYmFzZSAuLi5cXG4gKiDkuI3ov4flj6/ku6XlnKjor63kuYnnmoTliY3mj5DkuIvlgZrnmoTmm7Tnsr7nroDkuIDkupssIOS6juaYr+eUqOS6hnMyLCBzMeetiVxcbiAqIOWPr+eUqOWPmOmHjzogYCRzMSAtICRzOGBcXG4gKiBAZXhhbXBsZSBzY3NzIC0g5L2/55SoXFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6ICRzMSAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKlxcbiAqIEBleGFtcGxlIGNzcyAtIENTUyDovpPlh7pcXG4gKiAgIC5lbGVtZW50IHtcXG4gKiAgICAgcGFkZGluZzogNHB4ICFkZWZhdWx0O1xcbiAqICAgfVxcbiAqL1xcbi5uZXh0LW92ZXJsYXktd3JhcHBlciAubmV4dC1vdmVybGF5LWlubmVyIHtcXG4gIHotaW5kZXg6IDEwMDE7IH1cXG5cXG4ubmV4dC1vdmVybGF5LXdyYXBwZXIgLm5leHQtb3ZlcmxheS1iYWNrZHJvcCB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB6LWluZGV4OiAxMDAxO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgYmFja2dyb3VuZDogIzAwMDAwMDtcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAuM3M7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IC4zcztcXG4gIG9wYWNpdHk6IDA7IH1cXG5cXG4ubmV4dC1vdmVybGF5LXdyYXBwZXIub3BlbmVkIC5uZXh0LW92ZXJsYXktYmFja2Ryb3Age1xcbiAgb3BhY2l0eTogMC4yOyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyPz9yZWYtLTItMSEuL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliPz9yZWYtLTItMiEuL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYiEuL3NyYy9vdmVybGF5L21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIDEyIDEzIDE0IDE1IDE2IDE3IDE4IDE5IDIwIDIxIDIyIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlcj8/cmVmLS0yLTEhLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYj8/cmVmLS0yLTIhLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIhLi9zcmMvZHJvcGRvd24vbWFpbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkgMTAgMTEgMTIgMTMgMTQgMTUgMTYgMTcgMTggMTkgMjAgMjEgMjIiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGNoYXJzZXQgXFxcIlVURi04XFxcIjtcXG4vKipcXG4gKiDlsLrlr7gg5Z+656GA5bC65a+4XFxuICog5ZG95ZCN6IO95Zyo6K+t5LmJ55qE5YmN5o+Q5LiL566A5Y2V5bCx5bC96YeP566A5Y2VLCDov5nph4zlj6/ku6XmmK8gc2l6ZS0yeCwgc3BhY2UtMngsIHNpemUtYmFzZSAuLi5cXG4gKiDkuI3ov4flj6/ku6XlnKjor63kuYnnmoTliY3mj5DkuIvlgZrnmoTmm7Tnsr7nroDkuIDkupssIOS6juaYr+eUqOS6hnMyLCBzMeetiVxcbiAqIOWPr+eUqOWPmOmHjzogYCRzMSAtICRzOGBcXG4gKiBAZXhhbXBsZSBzY3NzIC0g5L2/55SoXFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6ICRzMSAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKlxcbiAqIEBleGFtcGxlIGNzcyAtIENTUyDovpPlh7pcXG4gKiAgIC5lbGVtZW50IHtcXG4gKiAgICAgcGFkZGluZzogNHB4ICFkZWZhdWx0O1xcbiAqICAgfVxcbiAqL1xcbi8qIHB1dCB5b3VyIGNvZGUgaGVyZSAqL1xcbi5uZXh0LWxvYWRpbmcge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgLyog6YGu572p5bGCICovXFxuICAvKiBmb3IgSUU5LDEwICovXFxuICAvKiB0ZXh0IG9uIHRoZSByaWdodCBzaWRlIG9mICovXFxuICAvKiDliqjmlYggKi8gfVxcbiAgLm5leHQtbG9hZGluZy5uZXh0LW9wZW4ge1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTsgfVxcbiAgLm5leHQtbG9hZGluZyAubmV4dC1sb2FkaW5nLWNvbXBvbmVudCB7XFxuICAgIG9wYWNpdHk6IC43O1xcbiAgICAtd2Via2l0LWZpbHRlcjogYmx1cigxcHgpO1xcbiAgICBmaWx0ZXI6IGJsdXIoMXB4KTtcXG4gICAgLXdlYmtpdC1maWx0ZXI6IFxcXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQmx1cihQaXhlbFJhZGl1cz0xLCBNYWtlU2hhZG93PWZhbHNlKVxcXCI7XFxuICAgICAgICAgICAgZmlsdGVyOiBcXFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkJsdXIoUGl4ZWxSYWRpdXM9MSwgTWFrZVNoYWRvdz1mYWxzZSlcXFwiO1xcbiAgICAvKiBJRTZ+SUU5ICovXFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7IH1cXG4gIC5uZXh0LWxvYWRpbmctbWFza2VyIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIHotaW5kZXg6IDk5O1xcbiAgICBvcGFjaXR5OiAuMjtcXG4gICAgYmFja2dyb3VuZDogI0ZGRjsgfVxcbiAgLm5leHQtbG9hZGluZy10aXAge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDUwJTtcXG4gICAgbGVmdDogNTAlO1xcbiAgICB6LWluZGV4OiA0O1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbiAgICAgICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IH1cXG4gIC5uZXh0LWxvYWRpbmctdGlwLXBsYWNlaG9sZGVyIHtcXG4gICAgZGlzcGxheTogbm9uZTsgfVxcbiAgLm5leHQtbG9hZGluZy1yaWdodC10aXAgLm5leHQtbG9hZGluZy1pbmRpY2F0b3Ige1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IH1cXG4gIC5uZXh0LWxvYWRpbmctcmlnaHQtdGlwIC5uZXh0LWxvYWRpbmctdGlwLWNvbnRlbnQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICB0b3A6IDUwJTtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgLTUwJSk7XFxuICAgICAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgLTUwJSk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgLTUwJSk7IH1cXG4gIC5uZXh0LWxvYWRpbmctcmlnaHQtdGlwIC5uZXh0LWxvYWRpbmctdGlwLXBsYWNlaG9sZGVyIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICAgIG1hcmdpbi1sZWZ0OiAxZW07IH1cXG4gIC5uZXh0LWxvYWRpbmctZnVzaW9uLXJlYWN0b3Ige1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIHdpZHRoOiA0OHB4O1xcbiAgICBoZWlnaHQ6IDQ4cHg7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogNS42cztcXG4gICAgYW5pbWF0aW9uLWR1cmF0aW9uOiA1LjZzO1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IGluZmluaXRlO1xcbiAgICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiBpbmZpbml0ZTtcXG4gICAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBsaW5lYXI7XFxuICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGxpbmVhcjtcXG4gICAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogbmV4dFZlY3RvclJvdXRlO1xcbiAgICBhbmltYXRpb24tbmFtZTogbmV4dFZlY3RvclJvdXRlOyB9XFxuICAgIC5uZXh0LWxvYWRpbmctZnVzaW9uLXJlYWN0b3IgLm5leHQtbG9hZGluZy1kb3Qge1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICBtYXJnaW46IGF1dG87XFxuICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgaGVpZ2h0OiAxMnB4O1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gICAgICBiYWNrZ3JvdW5kOiAjNTU4NEZGO1xcbiAgICAgIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1pbi1vdXQ7XFxuICAgICAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1pbi1vdXQ7XFxuICAgICAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiBpbmZpbml0ZTtcXG4gICAgICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiBpbmZpbml0ZTtcXG4gICAgICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMS40cztcXG4gICAgICBhbmltYXRpb24tZHVyYXRpb246IDEuNHM7IH1cXG4gICAgICAubmV4dC1sb2FkaW5nLWZ1c2lvbi1yZWFjdG9yIC5uZXh0LWxvYWRpbmctZG90Om50aC1jaGlsZCgxKSB7XFxuICAgICAgICB0b3A6IDA7XFxuICAgICAgICBib3R0b206IDA7XFxuICAgICAgICBsZWZ0OiAwO1xcbiAgICAgICAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogbmV4dFZlY3RvckRvdHNYO1xcbiAgICAgICAgYW5pbWF0aW9uLW5hbWU6IG5leHRWZWN0b3JEb3RzWDsgfVxcbiAgICAgIC5uZXh0LWxvYWRpbmctZnVzaW9uLXJlYWN0b3IgLm5leHQtbG9hZGluZy1kb3Q6bnRoLWNoaWxkKDIpIHtcXG4gICAgICAgIGxlZnQ6IDA7XFxuICAgICAgICByaWdodDogMDtcXG4gICAgICAgIHRvcDogMDtcXG4gICAgICAgIG9wYWNpdHk6IC44O1xcbiAgICAgICAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogbmV4dFZlY3RvckRvdHNZO1xcbiAgICAgICAgYW5pbWF0aW9uLW5hbWU6IG5leHRWZWN0b3JEb3RzWTsgfVxcbiAgICAgIC5uZXh0LWxvYWRpbmctZnVzaW9uLXJlYWN0b3IgLm5leHQtbG9hZGluZy1kb3Q6bnRoLWNoaWxkKDMpIHtcXG4gICAgICAgIHRvcDogMDtcXG4gICAgICAgIGJvdHRvbTogMDtcXG4gICAgICAgIHJpZ2h0OiAwO1xcbiAgICAgICAgb3BhY2l0eTogLjY7XFxuICAgICAgICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBuZXh0VmVjdG9yRG90c1hSO1xcbiAgICAgICAgYW5pbWF0aW9uLW5hbWU6IG5leHRWZWN0b3JEb3RzWFI7IH1cXG4gICAgICAubmV4dC1sb2FkaW5nLWZ1c2lvbi1yZWFjdG9yIC5uZXh0LWxvYWRpbmctZG90Om50aC1jaGlsZCg0KSB7XFxuICAgICAgICBsZWZ0OiAwO1xcbiAgICAgICAgcmlnaHQ6IDA7XFxuICAgICAgICBib3R0b206IDA7XFxuICAgICAgICBvcGFjaXR5OiAuMjtcXG4gICAgICAgIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IG5leHRWZWN0b3JEb3RzWVI7XFxuICAgICAgICBhbmltYXRpb24tbmFtZTogbmV4dFZlY3RvckRvdHNZUjsgfVxcbiAgLm5leHQtbG9hZGluZy1tZWRpdW0tZnVzaW9uLXJlYWN0b3Ige1xcbiAgICB3aWR0aDogMzJweDtcXG4gICAgaGVpZ2h0OiAzMnB4OyB9XFxuICAgIC5uZXh0LWxvYWRpbmctbWVkaXVtLWZ1c2lvbi1yZWFjdG9yIC5uZXh0LWxvYWRpbmctZG90IHtcXG4gICAgICB3aWR0aDogOHB4O1xcbiAgICAgIGhlaWdodDogOHB4OyB9XFxuICAgICAgLm5leHQtbG9hZGluZy1tZWRpdW0tZnVzaW9uLXJlYWN0b3IgLm5leHQtbG9hZGluZy1kb3Q6bnRoLWNoaWxkKDEpIHtcXG4gICAgICAgIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IG5leHRWZWN0b3JEb3RzWC1tZWRpdW07XFxuICAgICAgICBhbmltYXRpb24tbmFtZTogbmV4dFZlY3RvckRvdHNYLW1lZGl1bTsgfVxcbiAgICAgIC5uZXh0LWxvYWRpbmctbWVkaXVtLWZ1c2lvbi1yZWFjdG9yIC5uZXh0LWxvYWRpbmctZG90Om50aC1jaGlsZCgyKSB7XFxuICAgICAgICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBuZXh0VmVjdG9yRG90c1ktbWVkaXVtO1xcbiAgICAgICAgYW5pbWF0aW9uLW5hbWU6IG5leHRWZWN0b3JEb3RzWS1tZWRpdW07IH1cXG4gICAgICAubmV4dC1sb2FkaW5nLW1lZGl1bS1mdXNpb24tcmVhY3RvciAubmV4dC1sb2FkaW5nLWRvdDpudGgtY2hpbGQoMykge1xcbiAgICAgICAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogbmV4dFZlY3RvckRvdHNYUi1tZWRpdW07XFxuICAgICAgICBhbmltYXRpb24tbmFtZTogbmV4dFZlY3RvckRvdHNYUi1tZWRpdW07IH1cXG4gICAgICAubmV4dC1sb2FkaW5nLW1lZGl1bS1mdXNpb24tcmVhY3RvciAubmV4dC1sb2FkaW5nLWRvdDpudGgtY2hpbGQoNCkge1xcbiAgICAgICAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogbmV4dFZlY3RvckRvdHNZUi1tZWRpdW07XFxuICAgICAgICBhbmltYXRpb24tbmFtZTogbmV4dFZlY3RvckRvdHNZUi1tZWRpdW07IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgbmV4dFZlY3RvclJvdXRlIHtcXG4gIDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfVxcbiAgNSUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpOyB9XFxuICAyNSUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpOyB9XFxuICAzMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpOyB9XFxuICA1MCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpOyB9XFxuICA1NSUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpOyB9XFxuICA3NSUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpOyB9XFxuICA4MCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpOyB9XFxuICAxMDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfSB9XFxuXFxuQGtleWZyYW1lcyBuZXh0VmVjdG9yUm91dGUge1xcbiAgMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpOyB9XFxuICA1JSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7IH1cXG4gIDI1JSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7IH1cXG4gIDMwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7IH1cXG4gIDUwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7IH1cXG4gIDU1JSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMjcwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7IH1cXG4gIDc1JSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMjcwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7IH1cXG4gIDgwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH1cXG4gIDEwMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpOyB9IH1cXG5cXG4vKiAyMCUg55qE5pe26Ze05Zyo5peL6L2sICovXFxuQC13ZWJraXQta2V5ZnJhbWVzIG5leHRWZWN0b3JEb3RzWVIge1xcbiAgMjUlIHtcXG4gICAgYm90dG9tOiAwOyB9XFxuICA0NSUsXFxuICA1MCUge1xcbiAgICBib3R0b206IDE2LjhweDtcXG4gICAgaGVpZ2h0OiAxNC40cHg7XFxuICAgIHdpZHRoOiAxNC40cHg7IH1cXG4gIDkwJSB7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgaGVpZ2h0OiAxMnB4O1xcbiAgICB3aWR0aDogMTJweDsgfSB9XFxuXFxuQGtleWZyYW1lcyBuZXh0VmVjdG9yRG90c1lSIHtcXG4gIDI1JSB7XFxuICAgIGJvdHRvbTogMDsgfVxcbiAgNDUlLFxcbiAgNTAlIHtcXG4gICAgYm90dG9tOiAxNi44cHg7XFxuICAgIGhlaWdodDogMTQuNHB4O1xcbiAgICB3aWR0aDogMTQuNHB4OyB9XFxuICA5MCUge1xcbiAgICBib3R0b206IDA7XFxuICAgIGhlaWdodDogMTJweDtcXG4gICAgd2lkdGg6IDEycHg7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBuZXh0VmVjdG9yRG90c1kge1xcbiAgMjUlIHtcXG4gICAgdG9wOiAwOyB9XFxuICA0NSUsXFxuICA1MCUge1xcbiAgICB0b3A6IDE2LjhweDtcXG4gICAgaGVpZ2h0OiAxNC40cHg7XFxuICAgIHdpZHRoOiAxNC40cHg7IH1cXG4gIDkwJSB7XFxuICAgIHRvcDogMDtcXG4gICAgaGVpZ2h0OiAxMnB4O1xcbiAgICB3aWR0aDogMTJweDsgfSB9XFxuXFxuQGtleWZyYW1lcyBuZXh0VmVjdG9yRG90c1kge1xcbiAgMjUlIHtcXG4gICAgdG9wOiAwOyB9XFxuICA0NSUsXFxuICA1MCUge1xcbiAgICB0b3A6IDE2LjhweDtcXG4gICAgaGVpZ2h0OiAxNC40cHg7XFxuICAgIHdpZHRoOiAxNC40cHg7IH1cXG4gIDkwJSB7XFxuICAgIHRvcDogMDtcXG4gICAgaGVpZ2h0OiAxMnB4O1xcbiAgICB3aWR0aDogMTJweDsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIG5leHRWZWN0b3JEb3RzWCB7XFxuICAyNSUge1xcbiAgICBsZWZ0OiAwOyB9XFxuICA0NSUsXFxuICA1MCUge1xcbiAgICBsZWZ0OiAxNi44cHg7XFxuICAgIHdpZHRoOiAxNC40cHg7XFxuICAgIGhlaWdodDogMTQuNHB4OyB9XFxuICA5MCUge1xcbiAgICBsZWZ0OiAwO1xcbiAgICBoZWlnaHQ6IDEycHg7XFxuICAgIHdpZHRoOiAxMnB4OyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIG5leHRWZWN0b3JEb3RzWCB7XFxuICAyNSUge1xcbiAgICBsZWZ0OiAwOyB9XFxuICA0NSUsXFxuICA1MCUge1xcbiAgICBsZWZ0OiAxNi44cHg7XFxuICAgIHdpZHRoOiAxNC40cHg7XFxuICAgIGhlaWdodDogMTQuNHB4OyB9XFxuICA5MCUge1xcbiAgICBsZWZ0OiAwO1xcbiAgICBoZWlnaHQ6IDEycHg7XFxuICAgIHdpZHRoOiAxMnB4OyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgbmV4dFZlY3RvckRvdHNYUiB7XFxuICAyNSUge1xcbiAgICByaWdodDogMDsgfVxcbiAgNDUlLFxcbiAgNTAlIHtcXG4gICAgcmlnaHQ6IDE2LjhweDtcXG4gICAgd2lkdGg6IDE0LjRweDtcXG4gICAgaGVpZ2h0OiAxNC40cHg7IH1cXG4gIDkwJSB7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBoZWlnaHQ6IDEycHg7XFxuICAgIHdpZHRoOiAxMnB4OyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIG5leHRWZWN0b3JEb3RzWFIge1xcbiAgMjUlIHtcXG4gICAgcmlnaHQ6IDA7IH1cXG4gIDQ1JSxcXG4gIDUwJSB7XFxuICAgIHJpZ2h0OiAxNi44cHg7XFxuICAgIHdpZHRoOiAxNC40cHg7XFxuICAgIGhlaWdodDogMTQuNHB4OyB9XFxuICA5MCUge1xcbiAgICByaWdodDogMDtcXG4gICAgaGVpZ2h0OiAxMnB4O1xcbiAgICB3aWR0aDogMTJweDsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIG5leHRWZWN0b3JEb3RzWVItbWVkaXVtIHtcXG4gIDI1JSB7XFxuICAgIGJvdHRvbTogMDsgfVxcbiAgNDUlLFxcbiAgNTAlIHtcXG4gICAgYm90dG9tOiAxMS4ycHg7XFxuICAgIGhlaWdodDogOS42cHg7XFxuICAgIHdpZHRoOiA5LjZweDsgfVxcbiAgOTAlIHtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBoZWlnaHQ6IDhweDtcXG4gICAgd2lkdGg6IDhweDsgfSB9XFxuXFxuQGtleWZyYW1lcyBuZXh0VmVjdG9yRG90c1lSLW1lZGl1bSB7XFxuICAyNSUge1xcbiAgICBib3R0b206IDA7IH1cXG4gIDQ1JSxcXG4gIDUwJSB7XFxuICAgIGJvdHRvbTogMTEuMnB4O1xcbiAgICBoZWlnaHQ6IDkuNnB4O1xcbiAgICB3aWR0aDogOS42cHg7IH1cXG4gIDkwJSB7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgaGVpZ2h0OiA4cHg7XFxuICAgIHdpZHRoOiA4cHg7IH0gfVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBuZXh0VmVjdG9yRG90c1ktbWVkaXVtIHtcXG4gIDI1JSB7XFxuICAgIHRvcDogMDsgfVxcbiAgNDUlLFxcbiAgNTAlIHtcXG4gICAgdG9wOiAxMS4ycHg7XFxuICAgIGhlaWdodDogOS42cHg7XFxuICAgIHdpZHRoOiA5LjZweDsgfVxcbiAgOTAlIHtcXG4gICAgdG9wOiAwO1xcbiAgICBoZWlnaHQ6IDhweDtcXG4gICAgd2lkdGg6IDhweDsgfSB9XFxuXFxuQGtleWZyYW1lcyBuZXh0VmVjdG9yRG90c1ktbWVkaXVtIHtcXG4gIDI1JSB7XFxuICAgIHRvcDogMDsgfVxcbiAgNDUlLFxcbiAgNTAlIHtcXG4gICAgdG9wOiAxMS4ycHg7XFxuICAgIGhlaWdodDogOS42cHg7XFxuICAgIHdpZHRoOiA5LjZweDsgfVxcbiAgOTAlIHtcXG4gICAgdG9wOiAwO1xcbiAgICBoZWlnaHQ6IDhweDtcXG4gICAgd2lkdGg6IDhweDsgfSB9XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIG5leHRWZWN0b3JEb3RzWC1tZWRpdW0ge1xcbiAgMjUlIHtcXG4gICAgbGVmdDogMDsgfVxcbiAgNDUlLFxcbiAgNTAlIHtcXG4gICAgbGVmdDogMTEuMnB4O1xcbiAgICB3aWR0aDogOS42cHg7XFxuICAgIGhlaWdodDogOS42cHg7IH1cXG4gIDkwJSB7XFxuICAgIGxlZnQ6IDA7XFxuICAgIGhlaWdodDogOHB4O1xcbiAgICB3aWR0aDogOHB4OyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIG5leHRWZWN0b3JEb3RzWC1tZWRpdW0ge1xcbiAgMjUlIHtcXG4gICAgbGVmdDogMDsgfVxcbiAgNDUlLFxcbiAgNTAlIHtcXG4gICAgbGVmdDogMTEuMnB4O1xcbiAgICB3aWR0aDogOS42cHg7XFxuICAgIGhlaWdodDogOS42cHg7IH1cXG4gIDkwJSB7XFxuICAgIGxlZnQ6IDA7XFxuICAgIGhlaWdodDogOHB4O1xcbiAgICB3aWR0aDogOHB4OyB9IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgbmV4dFZlY3RvckRvdHNYUi1tZWRpdW0ge1xcbiAgMjUlIHtcXG4gICAgcmlnaHQ6IDA7IH1cXG4gIDQ1JSxcXG4gIDUwJSB7XFxuICAgIHJpZ2h0OiAxMS4ycHg7XFxuICAgIHdpZHRoOiA5LjZweDtcXG4gICAgaGVpZ2h0OiA5LjZweDsgfVxcbiAgOTAlIHtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGhlaWdodDogOHB4O1xcbiAgICB3aWR0aDogOHB4OyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIG5leHRWZWN0b3JEb3RzWFItbWVkaXVtIHtcXG4gIDI1JSB7XFxuICAgIHJpZ2h0OiAwOyB9XFxuICA0NSUsXFxuICA1MCUge1xcbiAgICByaWdodDogMTEuMnB4O1xcbiAgICB3aWR0aDogOS42cHg7XFxuICAgIGhlaWdodDogOS42cHg7IH1cXG4gIDkwJSB7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBoZWlnaHQ6IDhweDtcXG4gICAgd2lkdGg6IDhweDsgfSB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyPz9yZWYtLTItMSEuL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliPz9yZWYtLTItMiEuL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYiEuL3NyYy9sb2FkaW5nL21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIDEyIDEzIDE0IDE1IDE2IDE3IDE4IDE5IDIwIDIxIDIyIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBjaGFyc2V0IFxcXCJVVEYtOFxcXCI7XFxuLyoqXFxuICog5bC65a+4IOWfuuehgOWwuuWvuFxcbiAqIOWRveWQjeiDveWcqOivreS5ieeahOWJjeaPkOS4i+eugOWNleWwseWwvemHj+eugOWNlSwg6L+Z6YeM5Y+v5Lul5pivIHNpemUtMngsIHNwYWNlLTJ4LCBzaXplLWJhc2UgLi4uXFxuICog5LiN6L+H5Y+v5Lul5Zyo6K+t5LmJ55qE5YmN5o+Q5LiL5YGa55qE5pu057K+566A5LiA5LqbLCDkuo7mmK/nlKjkuoZzMiwgczHnrYlcXG4gKiDlj6/nlKjlj5jph486IGAkczEgLSAkczhgXFxuICogQGV4YW1wbGUgc2NzcyAtIOS9v+eUqFxcbiAqICAgLmVsZW1lbnQge1xcbiAqICAgICBwYWRkaW5nOiAkczEgIWRlZmF1bHQ7XFxuICogICB9XFxuICpcXG4gKiBAZXhhbXBsZSBjc3MgLSBDU1Mg6L6T5Ye6XFxuICogICAuZWxlbWVudCB7XFxuICogICAgIHBhZGRpbmc6IDRweCAhZGVmYXVsdDtcXG4gKiAgIH1cXG4gKi9cXG4vKiBwdXQgeW91ciBjb2RlIGhlcmUgKi9cXG4ubmV4dC10YWJsZSB7XFxuICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG4gIC5uZXh0LXRhYmxlICosXFxuICAubmV4dC10YWJsZSAqOmJlZm9yZSxcXG4gIC5uZXh0LXRhYmxlICo6YWZ0ZXIge1xcbiAgICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDsgfVxcbiAgLm5leHQtdGFibGUgdGFibGUge1xcbiAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbiAgICBib3JkZXItc3BhY2luZzogMDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGJhY2tncm91bmQ6ICNGRkZGRkY7IH1cXG4gICAgLm5leHQtdGFibGUgdGFibGUgdHI6Zmlyc3QtY2hpbGQgdGQge1xcbiAgICAgIGJvcmRlci10b3Atd2lkdGg6IDA7IH1cXG4gIC5uZXh0LXRhYmxlIHRoIHtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgYmFja2dyb3VuZDogI0VCRUNGMDtcXG4gICAgY29sb3I6ICMzMzMzMzM7XFxuICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICAgIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNEQ0RFRTM7IH1cXG4gICAgLm5leHQtdGFibGUgdGggLm5leHQtdGFibGUtY2VsbC13cmFwcGVyIHtcXG4gICAgICBwYWRkaW5nOiAxMnB4IDE2cHg7XFxuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcXG4gICAgICB3b3JkLWJyZWFrOiBicmVhay1hbGw7IH1cXG4gIC5uZXh0LXRhYmxlLWFmZml4IHtcXG4gICAgei1pbmRleDogMTsgfVxcbiAgLm5leHQtdGFibGUtaGVhZGVyLXJlc2l6YWJsZSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcbiAgICAubmV4dC10YWJsZS1oZWFkZXItcmVzaXphYmxlIC5uZXh0LXRhYmxlLXJlc2l6ZS1oYW5kbGVyIHtcXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgcmlnaHQ6IDA7XFxuICAgICAgdG9wOiAwO1xcbiAgICAgIGJvdHRvbTogMDtcXG4gICAgICB3aWR0aDogM3B4O1xcbiAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgICAgIGN1cnNvcjogZXctcmVzaXplOyB9XFxuICAubmV4dC10YWJsZSB0ZCB7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNEQ0RFRTM7IH1cXG4gICAgLm5leHQtdGFibGUgdGQgLm5leHQtdGFibGUtY2VsbC13cmFwcGVyIHtcXG4gICAgICBwYWRkaW5nOiAxMnB4IDE2cHg7XFxuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcXG4gICAgICB3b3JkLWJyZWFrOiBicmVhay1hbGw7IH1cXG4gICAgICAubmV4dC10YWJsZSB0ZCAubmV4dC10YWJsZS1jZWxsLXdyYXBwZXIgLm5leHQtaWNvbi1hcnJvdy1kb3duLm5leHQtdGFibGUtdHJlZS1hcnJvdyxcXG4gICAgICAubmV4dC10YWJsZSB0ZCAubmV4dC10YWJsZS1jZWxsLXdyYXBwZXIgLm5leHQtaWNvbi1hcnJvdy1yaWdodC5uZXh0LXRhYmxlLXRyZWUtYXJyb3csXFxuICAgICAgLm5leHQtdGFibGUgdGQgLm5leHQtdGFibGUtY2VsbC13cmFwcGVyIC5uZXh0LXRhYmxlLXRyZWUtcGxhY2Vob2xkZXIge1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAzcHg7XFxuICAgICAgICBmbG9hdDogbGVmdDsgfVxcbiAgICAgIC5uZXh0LXRhYmxlIHRkIC5uZXh0LXRhYmxlLWNlbGwtd3JhcHBlciAubmV4dC1pY29uLWFycm93LWRvd24ubmV4dC10YWJsZS10cmVlLWFycm93OmJlZm9yZSxcXG4gICAgICAubmV4dC10YWJsZSB0ZCAubmV4dC10YWJsZS1jZWxsLXdyYXBwZXIgLm5leHQtaWNvbi1hcnJvdy1yaWdodC5uZXh0LXRhYmxlLXRyZWUtYXJyb3c6YmVmb3JlIHtcXG4gICAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG4gIC5uZXh0LXRhYmxlIC5uZXh0LXRhYmxlLWV4cGFuZGVkIC5uZXh0LXRhYmxlLWNlbGwtd3JhcHBlcixcXG4gIC5uZXh0LXRhYmxlIC5uZXh0LXRhYmxlLXNlbGVjdGlvbiAubmV4dC10YWJsZS1jZWxsLXdyYXBwZXIge1xcbiAgICBvdmVyZmxvdzogdmlzaWJsZTsgfVxcbiAgLm5leHQtdGFibGUubm8taGVhZGVyIHRhYmxlIHRyOmZpcnN0LWNoaWxkIHRkIHtcXG4gICAgYm9yZGVyLXRvcC13aWR0aDogMXB4OyB9XFxuICAubmV4dC10YWJsZS5vbmx5LWJvdHRvbS1ib3JkZXIge1xcbiAgICBib3JkZXItd2lkdGg6IDA7IH1cXG4gICAgLm5leHQtdGFibGUub25seS1ib3R0b20tYm9yZGVyIHRoIHtcXG4gICAgICBib3JkZXItd2lkdGg6IDAgMCAxcHggMDsgfVxcbiAgICAubmV4dC10YWJsZS5vbmx5LWJvdHRvbS1ib3JkZXIgdGQge1xcbiAgICAgIGJvcmRlci13aWR0aDogMCAwIDFweCAwOyB9XFxuICAgIC5uZXh0LXRhYmxlLm9ubHktYm90dG9tLWJvcmRlciAubmV4dC10YWJsZS1leHBhbmRlZC1yb3cgdGgge1xcbiAgICAgIGJvcmRlci13aWR0aDogMCAwIDFweCAwOyB9XFxuICAgIC5uZXh0LXRhYmxlLm9ubHktYm90dG9tLWJvcmRlciAubmV4dC10YWJsZS1leHBhbmRlZC1yb3cgdGQge1xcbiAgICAgIGJvcmRlci13aWR0aDogMCAwIDFweCAwOyB9XFxuICAubmV4dC10YWJsZS1sb2FkaW5nIHtcXG4gICAgZGlzcGxheTogYmxvY2s7IH1cXG4gIC5uZXh0LXRhYmxlLnplYnJhIHRyOm50aC1jaGlsZChvZGQpIHRkIHtcXG4gICAgYmFja2dyb3VuZDogI0ZGRkZGRjsgfVxcbiAgLm5leHQtdGFibGUuemVicmEgdHI6bnRoLWNoaWxkKGV2ZW4pIHRkIHtcXG4gICAgYmFja2dyb3VuZDogI0Y3RjhGQTsgfVxcbiAgLm5leHQtdGFibGUuemVicmEgLm5leHQtdGFibGUtcm93LmhvdmVyZWQgdGQge1xcbiAgICBiYWNrZ3JvdW5kOiAjRjJGM0Y3O1xcbiAgICBjb2xvcjogIzMzMzMzMzsgfVxcbiAgLm5leHQtdGFibGUuemVicmEgLm5leHQtdGFibGUtcm93LnNlbGVjdGVkIHRkIHtcXG4gICAgYmFja2dyb3VuZDogI0YyRjNGNztcXG4gICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gIC5uZXh0LXRhYmxlLWVtcHR5IHtcXG4gICAgY29sb3I6ICNBMEEyQUQ7XFxuICAgIHBhZGRpbmc6IDMycHggMDtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyOyB9XFxuICAubmV4dC10YWJsZS1leHBhbmRlZC1yb3cgdGQge1xcbiAgICBib3JkZXItd2lkdGg6IDA7IH1cXG4gICAgLm5leHQtdGFibGUtZXhwYW5kZWQtcm93IHRkOmZpcnN0LWNoaWxkIHtcXG4gICAgICBib3JkZXItbGVmdC13aWR0aDogMXB4OyB9XFxuICAgIC5uZXh0LXRhYmxlLWV4cGFuZGVkLXJvdyB0ZDpsYXN0LWNoaWxkIHtcXG4gICAgICBib3JkZXItcmlnaHQtd2lkdGg6IDFweDsgfVxcbiAgLm5leHQtdGFibGUtZXhwYW5kZWQtcm93Omxhc3QtY2hpbGQgdGQge1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAxcHg7IH1cXG4gIC5uZXh0LXRhYmxlLWV4cGFuZGVkLXJvdyAubmV4dC10YWJsZSAubGFzdCB0ZCB7XFxuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDA7IH1cXG4gIC5uZXh0LXRhYmxlLWZpbHRlci1mb290ZXIge1xcbiAgICBtYXJnaW46IDEwcHggMTBweCAwOyB9XFxuICAgIC5uZXh0LXRhYmxlLWZpbHRlci1mb290ZXIgYnV0dG9uIHtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDVweDsgfVxcbiAgLm5leHQtdGFibGUtcm93IHtcXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgZWFzZSAuM3M7XFxuICAgIHRyYW5zaXRpb246IGFsbCBlYXNlIC4zcztcXG4gICAgYmFja2dyb3VuZDogI0ZGRkZGRjtcXG4gICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gICAgLm5leHQtdGFibGUtcm93LmhpZGRlbiB7XFxuICAgICAgZGlzcGxheTogbm9uZTsgfVxcbiAgICAubmV4dC10YWJsZS1yb3cuaG92ZXJlZCB7XFxuICAgICAgYmFja2dyb3VuZDogI0YyRjNGNztcXG4gICAgICBjb2xvcjogIzMzMzMzMzsgfVxcbiAgICAubmV4dC10YWJsZS1yb3cuc2VsZWN0ZWQge1xcbiAgICAgIGJhY2tncm91bmQ6ICNGMkYzRjc7XFxuICAgICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gIC5uZXh0LXRhYmxlLXRyZWUtcGxhY2Vob2xkZXIge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIHdpZHRoOiAxMnB4OyB9XFxuXFxuLmxhc3QgLm5leHQtdGFibGUtZXhwYW5kZWQtcm93IHRkIHtcXG4gIGJvcmRlci1ib3R0b20td2lkdGg6IDFweDsgfVxcblxcbi5uZXh0LXRhYmxlLWJvZHksXFxuLm5leHQtdGFibGUtaGVhZGVyIHtcXG4gIG92ZXJmbG93OiBhdXRvO1xcbiAgZm9udC1zaXplOiAxMnB4OyB9XFxuXFxuLm5leHQtdGFibGUtYm9keSB7XFxuICBmb250LXNpemU6IDEycHg7IH1cXG5cXG4ubmV4dC10YWJsZS1maXhlZCB7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjRENERUUzOyB9XFxuICAubmV4dC10YWJsZS1maXhlZCB0YWJsZSB7XFxuICAgIHRhYmxlLWxheW91dDogZml4ZWQ7IH1cXG4gIC5uZXh0LXRhYmxlLWZpeGVkIC5uZXh0LXRhYmxlLWhlYWRlciB7XFxuICAgIGJhY2tncm91bmQ6ICNFQkVDRjA7IH1cXG4gIC5uZXh0LXRhYmxlLWZpeGVkIHRhYmxlIHRyIHRkOmZpcnN0LWNoaWxkLFxcbiAgLm5leHQtdGFibGUtZml4ZWQgdGFibGUgdHIgdGg6Zmlyc3QtY2hpbGQge1xcbiAgICBib3JkZXItbGVmdC13aWR0aDogMDsgfVxcbiAgLm5leHQtdGFibGUtZml4ZWQgLm5leHQtdGFibGUtaGVhZGVyIHRoIHtcXG4gICAgYm9yZGVyLXRvcC13aWR0aDogMDsgfVxcbiAgLm5leHQtdGFibGUtZml4ZWQgLm5leHQtdGFibGUtaGVhZGVyIHRyIHRoOmxhc3QtY2hpbGQge1xcbiAgICBib3JkZXItcmlnaHQtd2lkdGg6IDA7IH1cXG4gIC5uZXh0LXRhYmxlLWZpeGVkIC5uZXh0LXRhYmxlLWJvZHkgdGQge1xcbiAgICBib3JkZXItdG9wLXdpZHRoOiAwOyB9XFxuICAubmV4dC10YWJsZS1maXhlZCAubmV4dC10YWJsZS1ib2R5IHRyOmxhc3QtY2hpbGQgdGQge1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAwOyB9XFxuICAubmV4dC10YWJsZS1maXhlZCAubmV4dC10YWJsZS1ib2R5IHRyIHRkOmxhc3QtY2hpbGQge1xcbiAgICBib3JkZXItcmlnaHQtd2lkdGg6IDA7IH1cXG4gIC5uZXh0LXRhYmxlLWZpeGVkLm5leHQtdGFibGUtZ3JvdXAgdGFibGUgdHIgdGQ6Zmlyc3QtY2hpbGQsXFxuICAubmV4dC10YWJsZS1maXhlZC5uZXh0LXRhYmxlLWdyb3VwIHRhYmxlIHRyIHRoOmZpcnN0LWNoaWxkIHtcXG4gICAgYm9yZGVyLWxlZnQtd2lkdGg6IDFweDsgfVxcbiAgLm5leHQtdGFibGUtZml4ZWQubmV4dC10YWJsZS1ncm91cCAubmV4dC10YWJsZS1oZWFkZXIgdGgge1xcbiAgICBib3JkZXItdG9wLXdpZHRoOiAxcHg7IH1cXG4gIC5uZXh0LXRhYmxlLWZpeGVkLm5leHQtdGFibGUtZ3JvdXAgLm5leHQtdGFibGUtaGVhZGVyIHRyIHRoOmxhc3QtY2hpbGQge1xcbiAgICBib3JkZXItcmlnaHQtd2lkdGg6IDFweDsgfVxcbiAgLm5leHQtdGFibGUtZml4ZWQubmV4dC10YWJsZS1ncm91cCAubmV4dC10YWJsZS1ib2R5IHRkIHtcXG4gICAgYm9yZGVyLXRvcC13aWR0aDogMXB4OyB9XFxuICAubmV4dC10YWJsZS1maXhlZC5uZXh0LXRhYmxlLWdyb3VwIC5uZXh0LXRhYmxlLWJvZHkgdHI6bGFzdC1jaGlsZCB0ZCB7XFxuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDFweDsgfVxcbiAgLm5leHQtdGFibGUtZml4ZWQubmV4dC10YWJsZS1ncm91cCAubmV4dC10YWJsZS1ib2R5IHRyIHRkOmxhc3QtY2hpbGQge1xcbiAgICBib3JkZXItcmlnaHQtd2lkdGg6IDFweDsgfVxcblxcbi5uZXh0LXRhYmxlLWxvY2sgLm5leHQtdGFibGUtYm9keSB7XFxuICBvdmVyZmxvdy14OiBhdXRvO1xcbiAgb3ZlcmZsb3cteTogdmlzaWJsZTsgfVxcblxcbi5uZXh0LXRhYmxlLWdyb3VwIHtcXG4gIGJvcmRlci13aWR0aDogMDsgfVxcbiAgLm5leHQtdGFibGUtZ3JvdXAgLm5leHQtdGFibGUtYm9keSB7XFxuICAgIG1hcmdpbi10b3A6IDhweDsgfVxcbiAgICAubmV4dC10YWJsZS1ncm91cCAubmV4dC10YWJsZS1ib2R5IHRhYmxlIHtcXG4gICAgICBtYXJnaW4tYm90dG9tOiA4cHg7IH1cXG4gICAgICAubmV4dC10YWJsZS1ncm91cCAubmV4dC10YWJsZS1ib2R5IHRhYmxlIHRyOmZpcnN0LWNoaWxkIHRkIHtcXG4gICAgICAgIGJvcmRlci10b3Atd2lkdGg6IDFweDsgfVxcbiAgLm5leHQtdGFibGUtZ3JvdXAgLm5leHQtdGFibGUtZ3JvdXAtaGVhZGVyIHRkIHtcXG4gICAgYmFja2dyb3VuZDogI0VCRUNGMDtcXG4gICAgY29sb3I6ICMzMzMzMzM7IH1cXG4gIC5uZXh0LXRhYmxlLWdyb3VwIC5uZXh0LXRhYmxlLWdyb3VwLWZvb3RlciB0ZCB7XFxuICAgIGJhY2tncm91bmQ6ICNFQkVDRjA7XFxuICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuICAubmV4dC10YWJsZS1ncm91cCAubmV4dC10YWJsZS1yb3cuaG92ZXJlZCxcXG4gIC5uZXh0LXRhYmxlLWdyb3VwIC5uZXh0LXRhYmxlLXJvdy5zZWxlY3RlZCB7XFxuICAgIGJhY2tncm91bmQ6ICNGRkZGRkY7XFxuICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuXFxuLm5leHQtdGFibGUtbG9jayB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG4gIC5uZXh0LXRhYmxlLWxvY2sgdGFibGUge1xcbiAgICB0YWJsZS1sYXlvdXQ6IGZpeGVkOyB9XFxuXFxuLm5leHQtdGFibGUtaGVhZGVyLWlubmVyIHtcXG4gIG92ZXJmbG93OiBoaWRkZW47IH1cXG5cXG4ubmV4dC10YWJsZS1sb2NrLWxlZnQsXFxuLm5leHQtdGFibGUtbG9jay1yaWdodCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiAwO1xcbiAgdG9wOiAwO1xcbiAgei1pbmRleDogMTtcXG4gIGJvcmRlcjogMDsgfVxcbiAgLm5leHQtdGFibGUtbG9jay1sZWZ0IHRhYmxlLFxcbiAgLm5leHQtdGFibGUtbG9jay1yaWdodCB0YWJsZSB7XFxuICAgIHdpZHRoOiBhdXRvOyB9XFxuICAubmV4dC10YWJsZS1sb2NrLWxlZnQgLm5leHQtdGFibGUtYm9keSxcXG4gIC5uZXh0LXRhYmxlLWxvY2stcmlnaHQgLm5leHQtdGFibGUtYm9keSB7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47IH1cXG5cXG4ubmV4dC10YWJsZS1sb2NrLXJpZ2h0IHtcXG4gIHJpZ2h0OiAwO1xcbiAgbGVmdDogYXV0bzsgfVxcbiAgLm5leHQtdGFibGUtbG9jay1yaWdodCB0YWJsZSB0ciB0ZDpmaXJzdC1jaGlsZCxcXG4gIC5uZXh0LXRhYmxlLWxvY2stcmlnaHQgdGFibGUgdHIgdGg6Zmlyc3QtY2hpbGQge1xcbiAgICBib3JkZXItbGVmdC13aWR0aDogMXB4OyB9XFxuICAubmV4dC10YWJsZS1sb2NrLXJpZ2h0LnNoYWRvdyB7XFxuICAgIC13ZWJraXQtYm94LXNoYWRvdzogLTJweCAwIDNweCByZ2JhKDAsIDAsIDAsIDAuMTIpO1xcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IC0ycHggMCAzcHggcmdiYSgwLCAwLCAwLCAwLjEyKTsgfVxcblxcbi5uZXh0LXRhYmxlLWxvY2stbGVmdC5zaGFkb3cge1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiAycHggMCAzcHggcmdiYSgwLCAwLCAwLCAwLjEyKTtcXG4gICAgICAgICAgYm94LXNoYWRvdzogMnB4IDAgM3B4IHJnYmEoMCwgMCwgMCwgMC4xMik7IH1cXG5cXG4ubmV4dC10YWJsZS1maWx0ZXIge1xcbiAgbGluZS1oZWlnaHQ6IDE7IH1cXG5cXG4ubmV4dC10YWJsZS1zb3J0IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHdpZHRoOiAxNnB4O1xcbiAgaGVpZ2h0OiAxNXB4O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIGxpbmUtaGVpZ2h0OiAxOyB9XFxuICAubmV4dC10YWJsZS1zb3J0IC5uZXh0LWljb24ge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGxlZnQ6IDA7XFxuICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuICAgIC5uZXh0LXRhYmxlLXNvcnQgLm5leHQtaWNvbjpiZWZvcmUge1xcbiAgICAgIHdpZHRoOiAxMnB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcbiAgLm5leHQtdGFibGUtc29ydCAuY3VycmVudCAubmV4dC1pY29uIHtcXG4gICAgY29sb3I6ICM1NTg0RkY7IH1cXG4gIC5uZXh0LXRhYmxlLXNvcnQgLm5leHQtaWNvbi1hc2NlbmRpbmcge1xcbiAgICBsZWZ0OiA0cHg7IH1cXG5cXG4ubmV4dC10YWJsZS1maWx0ZXIge1xcbiAgbWFyZ2luLWxlZnQ6IDVweDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIHdpZHRoOiAyMHB4O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9XFxuICAubmV4dC10YWJsZS1maWx0ZXIgLm5leHQtaWNvbiB7XFxuICAgIGNvbG9yOiAjMzMzMzMzOyB9XFxuICAgIC5uZXh0LXRhYmxlLWZpbHRlciAubmV4dC1pY29uOmJlZm9yZSB7XFxuICAgICAgd2lkdGg6IDEycHg7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuXFxuLm5leHQtdGFibGUtZXhwYW5kZWQtY3RybC5kaXNhYmxlZCB7XFxuICBjb2xvcjogIzk5OTk5OTsgfVxcblxcbi5uZXh0LXRhYmxlLWV4cGFuZGVkLWN0cmwgLm5leHQtaWNvbjpiZWZvcmUge1xcbiAgd2lkdGg6IDEycHg7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlcj8/cmVmLS0yLTEhLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYj8/cmVmLS0yLTIhLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIhLi9zcmMvdGFibGUvbWFpbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkgMTAgMTEgMTIgMTMgMTQgMTUgMTYgMTcgMTggMTkgMjAgMjEgMjIiLCJleHBvcnQgZGVmYXVsdCB7XG4gICAgbW9tZW50TG9jYWxlOiAnemgtY24nLFxuICAgIFRpbWVsaW5lOiB7XG4gICAgICAgIGV4cGFuZDogJ+WxleW8gCcsXG4gICAgICAgIGZvbGQ6ICfmlLbotbcnLFxuICAgIH0sXG4gICAgQ2FyZDoge1xuICAgICAgICBleHBhbmQ6ICflsZXlvIAnLFxuICAgICAgICBmb2xkOiAn5pS26LW3JyxcbiAgICB9LFxuICAgIENhbGVuZGFyOiB7XG4gICAgICAgIHRvZGF5OiAn5LuK5aSpJyxcbiAgICAgICAgbm93OiAn5q2k5Yi7JyxcbiAgICAgICAgb2s6ICfnoa7lrponLFxuICAgICAgICBjbGVhcjogJ+a4hemZpCcsXG4gICAgICAgIG1vbnRoOiAn5pyIJyxcbiAgICAgICAgeWVhcjogJ+W5tCcsXG4gICAgICAgIHByZXZZZWFyOiAn5LiK5LiA5bm0JyxcbiAgICAgICAgbmV4dFllYXI6ICfkuIvkuIDlubQnLFxuICAgICAgICBwcmV2TW9udGg6ICfkuIrkuKrmnIgnLFxuICAgICAgICBuZXh0TW9udGg6ICfkuIvkuKrmnIgnLFxuICAgICAgICBwcmV2RGVjYWRlOiAn5LiK5Y2B5bm0JyxcbiAgICAgICAgbmV4dERlY2FkZTogJ+WQjuWNgeW5tCcsXG4gICAgfSxcbiAgICBEYXRlUGlja2VyOiB7XG4gICAgICAgIHBsYWNlaG9sZGVyOiAn6K+36YCJ5oup5pel5pyfJyxcbiAgICAgICAgZGF0ZXRpbWVQbGFjZWhvbGRlcjogJ+ivt+mAieaLqeaXpeacn+WSjOaXtumXtCcsXG4gICAgICAgIG1vbnRoUGxhY2Vob2xkZXI6ICfor7fpgInmi6nmnIgnLFxuICAgICAgICB5ZWFyUGxhY2Vob2xkZXI6ICfor7fpgInmi6nlubQnLFxuICAgICAgICBub3c6ICfmraTliLsnLFxuICAgICAgICBzZWxlY3RUaW1lOiAn6YCJ5oup5pe26Ze0JyxcbiAgICAgICAgc2VsZWN0RGF0ZTogJ+mAieaLqeaXpeacnycsXG4gICAgICAgIG9rOiAn56Gu5a6aJyxcbiAgICAgICAgY2xlYXI6ICfmuIXpmaQnLFxuICAgICAgICBzdGFydFBsYWNlaG9sZGVyOiAn6LW35aeL5pel5pyfJyxcbiAgICAgICAgZW5kUGxhY2Vob2xkZXI6ICfnu5PmnZ/ml6XmnJ8nLFxuICAgICAgICBob3VyOiAn5pe2JyxcbiAgICAgICAgbWludXRlOiAn5YiGJyxcbiAgICAgICAgc2Vjb25kOiAn56eSJ1xuICAgIH0sXG4gICAgRGlhbG9nOiB7XG4gICAgICAgIG9rOiAn56Gu6K6kJyxcbiAgICAgICAgY2FuY2VsOiAn5Y+W5raIJ1xuICAgIH0sXG4gICAgUGFnaW5hdGlvbjoge1xuICAgICAgICBwcmV2OiAn5LiK5LiA6aG1JyxcbiAgICAgICAgbmV4dDogJ+S4i+S4gOmhtScsXG4gICAgICAgIGdvVG86ICfliLDnrKwnLFxuICAgICAgICBwYWdlOiAn6aG1JyxcbiAgICAgICAgZ286ICfnoa7lrponLFxuICAgICAgICBwYWdlU2l6ZTogJ+avj+mhteaYvuekuu+8midcbiAgICB9LFxuICAgIElucHV0OiB7XG4gICAgICAgIGNsZWFyOiAn5riF6ZmkJ1xuICAgIH0sXG4gICAgU2VsZWN0OiB7XG4gICAgICAgIHNlbGVjdFBsYWNlaG9sZGVyOiAn6K+36YCJ5oupJyxcbiAgICAgICAgYXV0b0NvbXBsZXRlUGxhY2Vob2xkZXI6ICfor7fovpPlhaUnLFxuICAgICAgICBub3RGb3VuZENvbnRlbnQ6ICfml6DpgInpobknXG4gICAgfSxcbiAgICBUYWJsZToge1xuICAgICAgICBlbXB0eTogJ+ayoeacieaVsOaNricsXG4gICAgICAgIG9rOiAn56Gu6K6kJyxcbiAgICAgICAgcmVzZXQ6ICfph43nva4nLFxuICAgICAgICBhc2M6ICfljYfluo8nLFxuICAgICAgICBkZXNjOiAn6ZmN5bqPJyxcbiAgICAgICAgZXhwYW5kZWQ6ICflt7LlsZXlvIAnLFxuICAgICAgICBmb2xkZWQ6ICflt7Lmipjlj6AnLFxuICAgICAgICBmaWx0ZXI6ICfnrZvpgIknLFxuICAgICAgICBzZWxlY3RBbGw6ICflhajpgIknXG4gICAgfSxcbiAgICBUaW1lUGlja2VyOiB7XG4gICAgICAgIHBsYWNlaG9sZGVyOiAn6K+36YCJ5oup5pe26Ze0JyxcbiAgICAgICAgY2xlYXI6ICfmuIXpmaQnLFxuICAgICAgICBob3VyOiAn5pe2JyxcbiAgICAgICAgbWludXRlOiAn5YiGJyxcbiAgICAgICAgc2Vjb25kOiAn56eSJ1xuICAgIH0sXG4gICAgVHJhbnNmZXI6IHtcbiAgICAgICAgaXRlbXM6ICfpobknLFxuICAgICAgICBpdGVtOiAn6aG5JyxcbiAgICAgICAgbW92ZUFsbDogJ+enu+WKqOWFqOmDqCcsXG4gICAgICAgIHNlYXJjaFBsYWNlaG9sZGVyOiAn6K+36L6T5YWlJ1xuICAgIH0sXG4gICAgVXBsb2FkOiB7XG4gICAgICAgIGNhcmQ6IHtcbiAgICAgICAgICAgIGNhbmNlbDogJ+WPlua2iCcsXG4gICAgICAgICAgICBhZGRQaG90bzogJ+S4iuS8oOWbvueJhydcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZzoge1xuICAgICAgICAgICAgdGV4dDogJ+eCueWHu+aIluiAheaLluWKqOaWh+S7tuWIsOiZmue6v+ahhuWGheS4iuS8oCcsXG4gICAgICAgICAgICBoaW50OiAn5pSv5oyBIGRvY3gsIHhscywgUERGLCByYXIsIHppcCwgUE5HLCBKUEcg562J57G75Z6L55qE5paH5Lu2J1xuICAgICAgICB9XG4gICAgfSxcbiAgICBTZWFyY2g6IHtcbiAgICAgICAgYnV0dG9uVGV4dDogJ+aQnOe0oicsXG4gICAgfSxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbG9jYWxlL3poLWNuLmpzIiwiaW1wb3J0ICcuLi9hbmltYXRlL3N0eWxlLmpzJztcbmltcG9ydCAnLi9tYWluLnNjc3MnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL292ZXJsYXkvc3R5bGUuanMiLCJpbXBvcnQgQ2hlY2tib3ggZnJvbSAnLi9jaGVja2JveCc7XG5pbXBvcnQgR3JvdXAgZnJvbSAnLi9jaGVja2JveC1ncm91cCc7XG5cbkNoZWNrYm94Lkdyb3VwID0gR3JvdXA7XG5cbmV4cG9ydCBkZWZhdWx0IENoZWNrYm94O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NoZWNrYm94L2luZGV4LmpzeCIsImltcG9ydCAnLi4vaWNvbi9zdHlsZS5qcyc7XG5pbXBvcnQgJy4uL2FuaW1hdGUvc3R5bGUuanMnO1xuaW1wb3J0ICcuL21haW4uc2Nzcyc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY2hlY2tib3gvc3R5bGUuanMiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb250ZXh0UHJvcHMocHJvcHMsIGNvbnRleHQsIGRpc3BsYXlOYW1lKSB7XG4gICAgY29uc3QgeyBwcmVmaXgsIGxvY2FsZSwgcHVyZSwgcnRsIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IG5leHRQcmVmaXgsIG5leHRMb2NhbGUsIG5leHRQdXJlLCBuZXh0V2FybmluZywgbmV4dFJ0bCB9ID0gY29udGV4dDtcblxuICAgIGNvbnN0IG5ld1ByZWZpeCA9IHByZWZpeCB8fCBuZXh0UHJlZml4O1xuXG4gICAgbGV0IGxvY2FsZUZyb21Db250ZXh0O1xuICAgIGlmIChuZXh0TG9jYWxlKSB7XG4gICAgICAgIGxvY2FsZUZyb21Db250ZXh0ID0gbmV4dExvY2FsZVtkaXNwbGF5TmFtZV07XG4gICAgICAgIGlmIChsb2NhbGVGcm9tQ29udGV4dCkge1xuICAgICAgICAgICAgbG9jYWxlRnJvbUNvbnRleHQubW9tZW50TG9jYWxlID0gbmV4dExvY2FsZS5tb21lbnRMb2NhbGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG5ld0xvY2FsZTtcbiAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgIG5ld0xvY2FsZSA9IHsgLi4uKGxvY2FsZUZyb21Db250ZXh0IHx8IHt9KSwgLi4ubG9jYWxlIH07XG4gICAgfSBlbHNlIGlmIChsb2NhbGVGcm9tQ29udGV4dCkge1xuICAgICAgICBuZXdMb2NhbGUgPSBsb2NhbGVGcm9tQ29udGV4dDtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdQdXJlID0gdHlwZW9mIHB1cmUgPT09ICdib29sZWFuJyA/IHB1cmUgOiBuZXh0UHVyZTtcbiAgICBjb25zdCBuZXdSdGwgPSB0eXBlb2YgcnRsID09PSAnYm9vbGVhbicgPyBydGwgOiBuZXh0UnRsO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlZml4OiBuZXdQcmVmaXgsXG4gICAgICAgIGxvY2FsZTogbmV3TG9jYWxlLFxuICAgICAgICBwdXJlOiBuZXdQdXJlLFxuICAgICAgICBydGw6IG5ld1J0bCxcbiAgICAgICAgd2FybmluZzogbmV4dFdhcm5pbmdcbiAgICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbmZpZy1wcm92aWRlci9nZXQtY29udGV4dC1wcm9wcy5qc3giLCJpbXBvcnQge2NhbWVsY2FzZSwgaHlwaGVuYXRlfSBmcm9tICcuL3N0cmluZyc7XG5pbXBvcnQge2VhY2h9IGZyb20gJy4vb2JqZWN0JztcblxuLyoqXG4gKiDmmK/lkKbog73kvb/nlKggRE9NIOaWueazlVxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBoYXNET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdy5kb2N1bWVudCAmJiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQ7XG5cbi8qKlxuICog6IqC54K55piv5ZCm5YyF5ZCr5oyH5a6aIGNsYXNzTmFtZVxuICogQHBhcmFtICB7RWxlbWVudH0gIG5vZGVcbiAqIEBwYXJhbSAge1N0cmluZ30gIGNsYXNzTmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqXG4gKiBAZXhhbXBsZVxuICogZG9tLmhhc0NsYXNzKGRvY3VtZW50LmJvZHksICdmb28nKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0NsYXNzIChub2RlLCBjbGFzc05hbWUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWhhc0RPTSB8fCAhbm9kZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuY2xhc3NMaXN0KSB7XG4gICAgICAgIHJldHVybiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBub2RlLmNsYXNzTmFtZS5pbmRleE9mKGNsYXNzTmFtZSkgPiAtMTtcbiAgICB9XG59XG5cbi8qKlxuICog5re75YqgIGNsYXNzTmFtZVxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gKlxuICogQGV4YW1wbGVcbiAqIGRvbS5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAnZm9vJyk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDbGFzcyAobm9kZSwgY2xhc3NOYW1lLCBfZm9yY2UpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWhhc0RPTSB8fCAhbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuY2xhc3NMaXN0KSB7XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgIH0gZWxzZSBpZiAoX2ZvcmNlID09PSB0cnVlIHx8ICFoYXNDbGFzcyhub2RlLCBjbGFzc05hbWUpKSB7XG4gICAgICAgIG5vZGUuY2xhc3NOYW1lICs9IGAgJHtjbGFzc05hbWV9YDtcbiAgICB9XG59XG5cbi8qKlxuICog56e76ZmkIGNsYXNzTmFtZVxuICogQHBhcmFtICB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtICB7U3RyaW5nfSBjbGFzc05hbWVcbiAqXG4gKiBAZXhhbXBsZVxuICogZG9tLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdmb28nKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNsYXNzIChub2RlLCBjbGFzc05hbWUsIF9mb3JjZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaGFzRE9NIHx8ICFub2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5jbGFzc0xpc3QpIHtcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgfSBlbHNlIGlmIChfZm9yY2UgPT09IHRydWUgfHwgaGFzQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKSkge1xuICAgICAgICBub2RlLmNsYXNzTmFtZSA9IG5vZGUuY2xhc3NOYW1lLnJlcGxhY2UoY2xhc3NOYW1lLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKTtcbiAgICB9XG59XG5cbi8qKlxuICog5YiH5o2iIGNsYXNzTmFtZVxuICogQHBhcmFtICB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtICB7U3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICDmiafooYzlkI7oioLngrnkuIrmmK/lkKbov5jmnInmraQgY2xhc3NOYW1lXG4gKlxuICogQGV4YW1wbGVcbiAqIGRvbS50b2dnbGVDbGFzcyhkb2N1bWVudC5ib2R5LCAnZm9vJyk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVDbGFzcyAobm9kZSwgY2xhc3NOYW1lKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFoYXNET00gfHwgIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChub2RlLmNsYXNzTGlzdCkge1xuICAgICAgICByZXR1cm4gbm9kZS5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmxhZyA9IGhhc0NsYXNzKG5vZGUsIGNsYXNzTmFtZSk7XG4gICAgICAgIGZsYWcgPyByZW1vdmVDbGFzcyhub2RlLCBjbGFzc05hbWUsIHRydWUpIDogYWRkQ2xhc3Mobm9kZSwgY2xhc3NOYW1lLCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gIWZsYWc7XG4gICAgfVxufVxuXG4vKipcbiAqIOWFg+e0oOaYr+WQpuWMuemFjSBDU1Mg6YCJ5oup5ZmoXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBub2RlICAgICAgIERPTSDoioLngrlcbiAqIEBwYXJhbSAge1N0cmluZ30gIHNlbGVjdG9yICAgQ1NTIOmAieaLqeWZqFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqXG4gKiBAZXhhbXBsZVxuICogZG9tLm1hdGNoZXMobW91bnROb2RlLCAnLmNvbnRhaW5lcicpOyAvLyBib29sZWFuXG4gKi9cbmV4cG9ydCBjb25zdCBtYXRjaGVzID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBtYXRjaGVzRm4gPSBudWxsO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGhhc0RPTSkge1xuICAgICAgICBjb25zdCBfYm9keSA9IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuaGVhZDtcbiAgICAgICAgbWF0Y2hlc0ZuID0gX2JvZHkubWF0Y2hlcyA/ICdtYXRjaGVzJyA6XG4gICAgICAgICAgICBfYm9keS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgPyAnd2Via2l0TWF0Y2hlc1NlbGVjdG9yJyA6XG4gICAgICAgICAgICAgICAgX2JvZHkubXNNYXRjaGVzU2VsZWN0b3IgPyAnbXNNYXRjaGVzU2VsZWN0b3InIDpcbiAgICAgICAgICAgICAgICAgICAgX2JvZHkubW96TWF0Y2hlc1NlbGVjdG9yID8gJ21vek1hdGNoZXNTZWxlY3RvcicgOiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwgc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKCFoYXNET00gfHwgIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaGVzRm4gPyBub2RlW21hdGNoZXNGbl0oc2VsZWN0b3IpIDogZmFsc2U7XG4gICAgfTtcbn0oKTtcblxuLyoqXG4gKiDojrflj5blhYPntKDorqHnrpflkI7nmoTmoLflvI9cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIF9nZXRDb21wdXRlZFN0eWxlIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSA/IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUsIG51bGwpIDoge307XG59XG5cbmNvbnN0IFBJWEVMX1BBVFRFUk4gPSAvbWFyZ2lufHBhZGRpbmd8d2lkdGh8aGVpZ2h0fG1heHxtaW58b2Zmc2V0fHNpemUvaTtcbmNvbnN0IHJlbW92ZVBpeGVsID0ge2xlZnQ6IDEsIHRvcDogMSwgcmlnaHQ6IDEsIGJvdHRvbTogMX07XG5cbi8qKlxuICog5qCh6aqM5bm25L+u5q2j5YWD57Sg55qE5qC35byP5bGe5oCn5YC8XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIF9nZXRTdHlsZVZhbHVlIChub2RlLCB0eXBlLCB2YWx1ZSkge1xuICAgIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAodmFsdWUgPT09ICdhdXRvJykge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2hlaWdodCcpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLm9mZnNldEhlaWdodCB8fCAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnd2lkdGgnKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5vZmZzZXRXaWR0aCB8fCAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEodHlwZSBpbiByZW1vdmVQaXhlbCkpIHtcbiAgICAgICAgLy8g5bGe5oCn5YC85piv5ZCm6ZyA6KaB5Y675o6JIHB4IOWNleS9je+8jOi/memHjOWBh+WumuatpOexu+eahOWxnuaAp+WAvOmDveaYryBweCDkuLrljZXkvY3nmoRcbiAgICAgICAgcmVtb3ZlUGl4ZWxbdHlwZV0gPSBQSVhFTF9QQVRURVJOLnRlc3QodHlwZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbW92ZVBpeGVsW3R5cGVdID8gKHBhcnNlRmxvYXQodmFsdWUpIHx8IDApIDogdmFsdWU7XG59XG5cbmNvbnN0IGZsb2F0TWFwID0ge2Nzc0Zsb2F0OiAxLCBzdHlsZUZsb2F0OiAxLCBmbG9hdDogMX07XG5cbi8qKlxuICog6I635Y+W5YWD57Sg6K6h566X5ZCO55qE5qC35byPXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBub2RlIERPTSDoioLngrlcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSDlsZ7mgKflkI1cbiAqIEByZXR1cm4ge051bWJlcnxPYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHlsZSAobm9kZSwgbmFtZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaGFzRE9NIHx8ICFub2RlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHN0eWxlID0gX2dldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cbiAgICAvLyDlpoLmnpzkuI3mjIflrprlsZ7mgKflkI3vvIzliJnov5Tlm57lhajpg6jlgLxcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuXG4gICAgbmFtZSA9IGZsb2F0TWFwW25hbWVdID8gJ2Nzc0Zsb2F0JyBpbiBub2RlLnN0eWxlID8gJ2Nzc0Zsb2F0JyA6ICdzdHlsZUZsb2F0JyA6IG5hbWU7XG5cbiAgICByZXR1cm4gX2dldFN0eWxlVmFsdWUobm9kZSwgbmFtZSwgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShoeXBoZW5hdGUobmFtZSkpIHx8IG5vZGUuc3R5bGVbY2FtZWxjYXNlKG5hbWUpXSk7XG59XG5cbi8qKlxuICog6K6+572u5YWD57Sg55qE5qC35byPXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgIERPTSDoioLngrlcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbmFtZSAg5bGe5oCn5ZCN77yM5oiW6ICF5piv5LiA5Liq5a+56LGh77yM5YyF5ZCr5aSa5Liq5bGe5oCnXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlIOWxnuaAp+WAvFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyDorr7nva7ljZXkuKrlsZ7mgKflgLxcbiAqIGRvbS5zZXRTdHlsZShtb3VudE5vZGUsICd3aWR0aCcsIDEwMCk7XG4gKiAvLyDorr7nva7lpJrmnaHlsZ7mgKflgLxcbiAqIGRvbS5zZXRTdHlsZShtb3VudE5vZGUsIHtcbiAqICAgICB3aWR0aDogMTAwLFxuICogICAgIGhlaWdodDogMjAwXG4gKiB9KTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFN0eWxlIChub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaGFzRE9NIHx8ICFub2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyDmibnph4/orr7nva7lpJrkuKrlgLxcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgZWFjaChuYW1lLCAodmFsLCBrZXkpID0+IHNldFN0eWxlKG5vZGUsIGtleSwgdmFsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZSA9IGZsb2F0TWFwW25hbWVdID8gJ2Nzc0Zsb2F0JyBpbiBub2RlLnN0eWxlID8gJ2Nzc0Zsb2F0JyA6ICdzdHlsZUZsb2F0JyA6IG5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIFBJWEVMX1BBVFRFUk4udGVzdChuYW1lKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBgJHt2YWx1ZX1weGA7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zdHlsZVtjYW1lbGNhc2UobmFtZSldID0gdmFsdWU7IC8vIElFOCBzdXBwb3J0XG4gICAgfVxufVxuXG4vKipcbiAqIOiOt+WPlum7mOiupOeahOa7muWKqOadoeWkp+Wwj1xuICogQHJldHVybiB7T2JqZWN0fSB3aWR0aCwgaGVpZ2h0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY3JvbGxiYXIgKCkge1xuICAgIGNvbnN0IHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgc2V0U3R5bGUoc2Nyb2xsRGl2LCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB3aWR0aDogJzEwMHB4JyxcbiAgICAgICAgaGVpZ2h0OiAnMTAwcHgnLFxuICAgICAgICBvdmVyZmxvdzogJ3Njcm9sbCcsXG4gICAgICAgIHRvcDogJy05OTk5cHgnXG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JvbGxEaXYpO1xuICAgIGNvbnN0IHNjcm9sbGJhcldpZHRoID0gc2Nyb2xsRGl2Lm9mZnNldFdpZHRoIC0gc2Nyb2xsRGl2LmNsaWVudFdpZHRoO1xuICAgIGNvbnN0IHNjcm9sbGJhckhlaWdodCA9IHNjcm9sbERpdi5vZmZzZXRIZWlnaHQgLSBzY3JvbGxEaXYuY2xpZW50SGVpZ2h0O1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBzY3JvbGxiYXJXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBzY3JvbGxiYXJIZWlnaHRcbiAgICB9O1xufVxuXG4vKipcbiAqIOiOt+WPluWFg+e0oOi3neemu+inhuWPo+mhtumDqOWSjOW3pui+ueeahOWBj+enu+i3neemu1xuICogQHJldHVybiB7T2JqZWN0fSB0b3AsIGxlZnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9mZnNldCAobm9kZSkge1xuICAgIGNvbnN0IHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHdpbiA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0LFxuICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcbiAgICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWwvZG9tLmpzIiwiLyoqXG4gKiDlsIblrZfnrKbkuLLovazljJbkuLrpqbzls7DlvI/lhpnms5VcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyIOS+i++8mi13ZWJraXQtdHJhbnNpdGlvblxuICogQHJldHVybiB7U3RyaW5nfSAgICAg5L6L77yaV2Via2l0VHJhbnNpdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FtZWxjYXNlIChzdHIpIHtcbiAgICBpZiAoIS8tLy50ZXN0KHN0cikpIHtcbiAgICAgICAgcmV0dXJuIHN0ciB8fCAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oW2Etel0pL2csICgkMCwgJDEpID0+ICQxLnRvVXBwZXJDYXNlKCkpO1xufVxuXG4vKipcbiAqIOWwhumpvOWzsOW8j+Wtl+espuS4sui9rOWMluS4uui/nuWtl+espuWGmeazlVxuICogQHBhcmFtICB7U3RyaW5nfSBzdHIg5L6L77yaV2Via2l0VHJhbnNpdGlvblxuICogQHJldHVybiB7U3RyaW5nfSAgICAg5L6L77yaLXdlYmtpdC10cmFuc2l0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeXBoZW5hdGUgKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFtBLVpdKS9nLCAkMCA9PiBgLSR7JDAudG9Mb3dlckNhc2UoKX1gKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlsL3N0cmluZy5qcyIsIi8qKlxuICogSUXmtY/op4jlmajnmoTmuLLmn5PlvJXmk47niYjmnKzlj7dcbiAqIOazqOaEj++8muatpOWxnuaAp+S4jua1j+iniOWZqOeJiOacrOWPt+S4jeWQjO+8jElF55qE5riy5p+T5byV5pOO54mI5pys5Y+35piv5Y+v5Lul6YCa6L+HSFRNTCBoZWFkZXLmiJbmiYvliqjorr7nva7ljrvmm7TmlLnnmoRcbiAqIEB0eXBlIHtOdW1iZXJ9IDYgfiAxMFxuICovXG5leHBvcnQgY29uc3QgaWVWZXJzaW9uID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiDliKTmlq3mmK/lkKbmmK/nlJ/kuqfnjq/looNcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaXNQcm9kdWN0aW9uID0gKCkgPT4ge1xuICAgIGNvbnN0IFBST0RVQ1RJT05fRU5WID0gJ3Byb2R1Y3Rpb24nO1xuICAgIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFBST0RVQ1RJT05fRU5WKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vXG4gICAgfVxuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cucHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFBST0RVQ1RJT05fRU5WKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGllVmVyc2lvbixcbiAgICBpc1Byb2R1Y3Rpb24sXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWwvZW52LmpzIiwiZXhwb3J0IGRlZmF1bHQge1xuICAgIEJBQ0tTUEFDRTogOCxcbiAgICBUQUI6IDksXG4gICAgRU5URVI6IDEzLFxuICAgIFNISUZUOiAxNixcbiAgICBDVFJMOiAxNyxcbiAgICBBTFQ6IDE4LFxuICAgIEVTQzogMjcsXG4gICAgU1BBQ0U6IDMyLFxuICAgIEVORDogMzUsXG4gICAgSE9NRTogMzYsXG4gICAgTEVGVDogMzcsXG4gICAgVVA6IDM4LFxuICAgIFJJR0hUOiAzOSxcbiAgICBET1dOOiA0MCxcblxuICAgIC8vIHZlcnNpb24gMC54XG4gICAgRVNDQVBFOiAyNyxcbiAgICBMRUZUX0FSUk9XOiAzNyxcbiAgICBVUF9BUlJPVzogMzgsXG4gICAgUklHSFRfQVJST1c6IDM5LFxuICAgIERPV05fQVJST1c6IDQwLFxuXG4gICAgLy8gTWFjT1NcbiAgICBDT05UUk9MOiAxNyxcbiAgICBPUFRJT046IDE4LFxuICAgIENNRDogOTEsXG4gICAgQ09NTUFORDogOTEsXG4gICAgREVMRVRFOiA4LFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlsL2tleWNvZGUuanMiLCJ2YXIgc3R5bGVFcXVhbCA9IHJlcXVpcmUoJ3N0eWxlLWVxdWFsJyk7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB0eXBlKGEpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYSkgPyAnYXJyYXknIDogdHlwZW9mIGE7XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRFcXVhbHMoYSwgYikge1xuICB2YXIgdHlwZU9mQSA9IHR5cGUoYSk7XG4gIHZhciB0eXBlT2ZCID0gdHlwZShiKTtcblxuICBpZiAodHlwZU9mQSAhPT0gdHlwZU9mQikgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaCAodHlwZU9mQSkge1xuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWVsZW1lbnRFcXVhbHMoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBhID09PSBiO1xuICAgICAgaWYgKGEudHlwZSAhPT0gYi50eXBlKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoYS5rZXkgIT09IGIua2V5KSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoYS5yZWYgIT09IGIucmVmKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gc2hhbGxvd0VsZW1lbnRFcXVhbHMoYS5wcm9wcywgYi5wcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hhbGxvd0VsZW1lbnRFcXVhbHMoYSwgYikge1xuICB2YXIgYUNvdW50ID0gMDtcbiAgdmFyIGJDb3VudCA9IDA7XG5cbiAgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhLCBrZXkpKSB7XG4gICAgICBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgIC8vIE5PVEUobG1yKToga2luZCBvZiByaXNreSwgYnV0IGknbSBhc3N1bWluZyB0aGF0IGEgYHN0eWxlYCBwcm9wIGlzIGEgUmVhY3QgTmF0aXZlIHN0eWxlLFxuICAgICAgICAvLyBhbmQgdXNpbmcgdGhlIGBzdHlsZUVxdWFsYCBhbGdvcml0aG0gaGVyZS5cbiAgICAgICAgaWYgKCFzdHlsZUVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdjaGlsZHJlbicpIHtcbiAgICAgICAgLy8gd2lsbCBjb21wYXJlIGNoaWxkcmVuIGxhdGVyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGFDb3VudCsrO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYiwga2V5KSkge1xuICAgICAgYkNvdW50Kys7XG4gICAgfVxuICB9XG5cbiAgaWYgKGFDb3VudCAhPT0gYkNvdW50KSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gY29tcGFyZSBjaGlsZHJlbiBsYXN0Li4uXG4gIHJldHVybiBlbGVtZW50RXF1YWxzKGEuY2hpbGRyZW4sIGIuY2hpbGRyZW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dFbGVtZW50RXF1YWxzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19zaGFsbG93LWVsZW1lbnQtZXF1YWxzQDEuMC4xQHNoYWxsb3ctZWxlbWVudC1lcXVhbHMvaW5kZXguanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IGRvbSwgZXZlbnRzLCBmdW5jLCBzdXBwb3J0LCBmb2N1cywgS0VZQ09ERSwgZ3VpZCB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IG92ZXJsYXlNYW5hZ2VyIGZyb20gJy4vbWFuYWdlcic7XG5pbXBvcnQgR2F0ZXdheSBmcm9tICcuL2dhdGV3YXknO1xuaW1wb3J0IFBvc2l0aW9uIGZyb20gJy4vcG9zaXRpb24nO1xuaW1wb3J0IGZpbmROb2RlIGZyb20gJy4vdXRpbHMvZmluZC1ub2RlJztcblxuY29uc3QgeyBzYXZlTGFzdEZvY3VzTm9kZSwgZ2V0Rm9jdXNOb2RlTGlzdCwgYmFja0xhc3RGb2N1c05vZGUgfSA9IGZvY3VzO1xuY29uc3QgeyBtYWtlQ2hhaW4sIG5vb3AsIGJpbmRDdHggfSA9IGZ1bmM7XG5cbmNvbnN0IGlzU2Nyb2xsRGlzcGxheSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBzY3JvbGxiYXJTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsICc6Oi13ZWJraXQtc2Nyb2xsYmFyJyk7XG4gICAgICAgIHJldHVybiAhc2Nyb2xsYmFyU3R5bGUgfHwgc2Nyb2xsYmFyU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpICE9PSAnbm9uZSc7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpZ25vcmUgZXJyb3IgZm9yIGZpcmVmb3hcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBoYXNTY3JvbGwgPSAoKSA9PiB7XG4gICAgY29uc3QgZG9jID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHJldHVybiBkb2Muc2Nyb2xsSGVpZ2h0ID4gZG9jLmNsaWVudEhlaWdodCAmJiBkb20uc2Nyb2xsYmFyKCkud2lkdGggPiAwICYmIGlzU2Nyb2xsRGlzcGxheShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpICYmIGlzU2Nyb2xsRGlzcGxheShkb2N1bWVudC5ib2R5KTtcbn07XG5jb25zdCBwcmVmaXhlcyA9IFsnLXdlYmtpdC0nLCAnLW1vei0nLCAnLW8tJywgJ21zLScsICcnXTtcbmNvbnN0IGdldFN0eWxlUHJvcGVydHkgPSAobm9kZSwgbmFtZSkgPT4ge1xuICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgbGV0IHJldCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmV0ID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcmVmaXhlc1tpXSArIG5hbWUpO1xuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuY29uc3QgbW9kYWxzID0gW107XG5sZXQgYm9keU92ZXJmbG93WSwgYm9keVBhZGRpbmdSaWdodDtcblxuLyoqXG4gKiBPdmVybGF5XG4gKiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3ZlcmxheSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBwdXJlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgcnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbmmL7npLrlvLnlsYJcbiAgICAgICAgICovXG4gICAgICAgIHZpc2libGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC6K+35rGC5YWz6Zet5pe26Kem5Y+R5LqL5Lu255qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOW8ueWxguWFs+mXreeahOadpea6kFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZSBET00g5LqL5Lu2XG4gICAgICAgICAqL1xuICAgICAgICBvblJlcXVlc3RDbG9zZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLlrprkvY3nmoTlj4LnhaflhYPntKBcbiAgICAgICAgICovXG4gICAgICAgIHRhcmdldDogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguebuOWvueS6juWPgueFp+WFg+e0oOeahOWumuS9jSwg6K+m6KeB5byA5Y+R5oyH5Y2X55qEW+WumuS9jemDqOWIhl0oI+WumuS9jSlcbiAgICAgICAgICovXG4gICAgICAgIGFsaWduOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYm9vbF0pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC55u45a+55LqO5Y+C54Wn5YWD57Sg5a6a5L2N55qE5b6u6LCDXG4gICAgICAgICAqL1xuICAgICAgICBvZmZzZXQ6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4suafk+e7hOS7tueahOWuueWZqO+8jOWmguaenOaYr+WHveaVsOmcgOimgei/lOWbniByZWbvvIzlpoLmnpzmmK/lrZfnrKbkuLLliJnmmK/or6UgRE9NIOeahCBpZO+8jOS5n+WPr+S7peebtOaOpeS8oOWFpSBET00g6IqC54K5XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluZXI6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbmmL7npLrpga7nvalcbiAgICAgICAgICovXG4gICAgICAgIGhhc01hc2s6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5pSv5oyBIGVzYyDmjInplK7lhbPpl63lvLnlsYJcbiAgICAgICAgICovXG4gICAgICAgIGNhbkNsb3NlQnlFc2M6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog54K55Ye75by55bGC5aSW55qE5Yy65Z+f5piv5ZCm5YWz6Zet5by55bGC77yM5LiN5pi+56S66YGu572p5pe255Sf5pWIXG4gICAgICAgICAqL1xuICAgICAgICBjYW5DbG9zZUJ5T3V0U2lkZUNsaWNrOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeCueWHu+mBrue9qeWMuuWfn+aYr+WQpuWFs+mXreW8ueWxgu+8jOaYvuekuumBrue9qeaXtueUn+aViFxuICAgICAgICAgKi9cbiAgICAgICAgY2FuQ2xvc2VCeU1hc2s6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5omT5byA5YmN6Kem5Y+R5LqL5Lu255qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqL1xuICAgICAgICBiZWZvcmVPcGVuOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguaJk+W8gOaXtuinpuWPkeS6i+S7tueahOWbnuiwg+WHveaVsFxuICAgICAgICAgKi9cbiAgICAgICAgb25PcGVuOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguaJk+W8gOWQjuinpuWPkeS6i+S7tueahOWbnuiwg+WHveaVsCwg5aaC5p6c5pyJ5Yqo55S777yM5YiZ5Zyo5Yqo55S757uT5p2f5ZCO6Kem5Y+RXG4gICAgICAgICAqL1xuICAgICAgICBhZnRlck9wZW46IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5YWz6Zet5YmN6Kem5Y+R5LqL5Lu255qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqL1xuICAgICAgICBiZWZvcmVDbG9zZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLlhbPpl63ml7bop6blj5Hkuovku7bnmoTlm57osIPlh73mlbBcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2xvc2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5YWz6Zet5ZCO6Kem5Y+R5LqL5Lu255qE5Zue6LCD5Ye95pWwLCDlpoLmnpzmnInliqjnlLvvvIzliJnlnKjliqjnlLvnu5PmnZ/lkI7op6blj5FcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyQ2xvc2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5a6a5L2N5a6M5oiQ5YmN6Kem5Y+R55qE5LqL5Lu2XG4gICAgICAgICAqL1xuICAgICAgICBiZWZvcmVQb3NpdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLlrprkvY3lrozmiJDml7bop6blj5HnmoTkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyDlrprkvY3nmoTlj4LmlbBcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gY29uZmlnLmFsaWduIOWvuem9kOaWueW8j++8jOWmgiBbJ2NjJywgJ2NjJ13vvIjlpoLmnpzlvIDlkK8gbmVlZEFkanVzdO+8jOWPr+iDveWSjOmihOWFiOiuvue9rueahCBhbGlnbiDkuI3lkIzvvIlcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy50b3Ag6Led56a76KeG5Y+j6aG26YOo6Led56a7XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcubGVmdCDot53nprvop4blj6Plt6bkvqfot53nprtcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUg5a6a5L2N5Y+C54Wn55qE5a655Zmo6IqC54K5XG4gICAgICAgICAqL1xuICAgICAgICBvblBvc2l0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuWcqOavj+asoeW8ueWxgumHjeaWsOa4suafk+WQjuW8uuWItuabtOaWsOWumuS9jeS/oeaBr++8jOS4gOiIrOeUqOS6juW8ueWxguWGheWuueWMuuWfn+Wkp+Wwj+WPkeeUn+WPmOWMluaXtu+8jOS7jemcgOS/neaMgeWOn+adpeeahOWumuS9jeaWueW8j1xuICAgICAgICAgKi9cbiAgICAgICAgc2hvdWxkVXBkYXRlUG9zaXRpb246IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5omT5byA5pe25piv5ZCm6K6p5YW25Lit55qE5YWD57Sg6Ieq5Yqo6I635Y+W54Sm54K5XG4gICAgICAgICAqL1xuICAgICAgICBhdXRvRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5b2T5by55bGC55Sx5LqO6aG16Z2i5rua5Yqo562J5oOF5Ya15LiN5Zyo5Y+v6KeG5Yy65Z+f5pe277yM5piv5ZCm6Ieq5Yqo6LCD5pW05a6a5L2N5Lul5Ye6546w5Zyo5Y+v6KeG5Yy65Z+fXG4gICAgICAgICAqL1xuICAgICAgICBuZWVkQWRqdXN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuemgeeUqOmhtemdoua7muWKqFxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZVNjcm9sbDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpmpDol4/ml7bmmK/lkKbkv53nlZnlrZDoioLngrlcbiAgICAgICAgICovXG4gICAgICAgIGNhY2hlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWuieWFqOiKgueCue+8jOW9k+eCueWHuyBkb2N1bWVudCDnmoTml7blgJnvvIzlpoLmnpzljIXlkKvor6XoioLngrnliJnkuI3kvJrlhbPpl63lvLnlsYLvvIzlpoLmnpzmmK/lh73mlbDpnIDopoHov5Tlm54gcmVm77yM5aaC5p6c5piv5a2X56ym5Liy5YiZ5piv6K+lIERPTSDnmoQgaWTvvIzkuZ/lj6/ku6Xnm7TmjqXkvKDlhaUgRE9NIOiKgueCue+8jOaIluiAheS7peS4iuWAvOe7hOaIkOeahOaVsOe7hFxuICAgICAgICAgKi9cbiAgICAgICAgc2FmZU5vZGU6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLnmoTmoLnoioLngrnnmoTmoLflvI/nsbtcbiAgICAgICAgICovXG4gICAgICAgIHdyYXBwZXJDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLnmoTmoLnoioLngrnnmoTlhoXogZTmoLflvI9cbiAgICAgICAgICovXG4gICAgICAgIHdyYXBwZXJTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmFjee9ruWKqOeUu+eahOaSreaUvuaWueW8j++8jOaUr+aMgSB7IGluOiAnZW50ZXItY2xhc3MnLCBvdXQ6ICdsZWF2ZS1jbGFzcycgfSDnmoTlr7nosaHlj4LmlbDvvIzlpoLmnpzorr7nva7kuLogZmFsc2XvvIzliJnkuI3mkq3mlL7liqjnlLtcbiAgICAgICAgICogQGRlZmF1bHQgeyBpbjogJ2V4cGFuZEluRG93bicsIG91dDogJ2V4cGFuZE91dFVwJyB9XG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRpb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5ib29sXSksXG4gICAgICAgIG9uTWFza01vdXNlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbk1hc2tNb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuY1xuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBwcmVmaXg6ICduZXh0LScsXG4gICAgICAgIHB1cmU6IGZhbHNlLFxuICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgb25SZXF1ZXN0Q2xvc2U6IG5vb3AsXG4gICAgICAgIHRhcmdldDogUG9zaXRpb24uVklFV1BPUlQsXG4gICAgICAgIGFsaWduOiAndGwgYmwnLFxuICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgaGFzTWFzazogZmFsc2UsXG4gICAgICAgIGNhbkNsb3NlQnlFc2M6IHRydWUsXG4gICAgICAgIGNhbkNsb3NlQnlPdXRTaWRlQ2xpY2s6IHRydWUsXG4gICAgICAgIGNhbkNsb3NlQnlNYXNrOiB0cnVlLFxuICAgICAgICBiZWZvcmVPcGVuOiBub29wLFxuICAgICAgICBvbk9wZW46IG5vb3AsXG4gICAgICAgIGFmdGVyT3Blbjogbm9vcCxcbiAgICAgICAgYmVmb3JlQ2xvc2U6IG5vb3AsXG4gICAgICAgIG9uQ2xvc2U6IG5vb3AsXG4gICAgICAgIGFmdGVyQ2xvc2U6IG5vb3AsXG4gICAgICAgIGJlZm9yZVBvc2l0aW9uOiBub29wLFxuICAgICAgICBvblBvc2l0aW9uOiBub29wLFxuICAgICAgICBvbk1hc2tNb3VzZUVudGVyOiBub29wLFxuICAgICAgICBvbk1hc2tNb3VzZUxlYXZlOiBub29wLFxuICAgICAgICBzaG91bGRVcGRhdGVQb3NpdGlvbjogZmFsc2UsXG4gICAgICAgIGF1dG9Gb2N1czogZmFsc2UsXG4gICAgICAgIG5lZWRBZGp1c3Q6IHRydWUsXG4gICAgICAgIGRpc2FibGVTY3JvbGw6IGZhbHNlLFxuICAgICAgICBjYWNoZTogZmFsc2VcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB2aXNpYmxlOiBwcm9wcy52aXNpYmxlLFxuICAgICAgICAgICAgc3RhdHVzOiAnbm9uZScsXG4gICAgICAgICAgICBhbmltYXRpb246IHRoaXMuZ2V0QW5pbWF0aW9uKHByb3BzKVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMubGFzdEFsaWduID0gcHJvcHMuYWxpZ247XG5cbiAgICAgICAgYmluZEN0eCh0aGlzLCBbXG4gICAgICAgICAgICAnaGFuZGxlUG9zaXRpb24nLFxuICAgICAgICAgICAgJ2hhbmRsZUFuaW1hdGVFbmQnLFxuICAgICAgICAgICAgJ2hhbmRsZURvY3VtZW50S2V5RG93bicsXG4gICAgICAgICAgICAnaGFuZGxlRG9jdW1lbnRDbGljaycsXG4gICAgICAgICAgICAnaGFuZGxlTWFza0NsaWNrJyxcbiAgICAgICAgICAgICdiZWZvcmVPcGVuJyxcbiAgICAgICAgICAgICdiZWZvcmVDbG9zZSdcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdGhpcy50aW1lb3V0TWFwID0ge307XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmJlZm9yZU9wZW4oKTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMuYmVmb3JlT3BlbigpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5hbmltYXRpb24gJiYgc3VwcG9ydC5hbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVudGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUoeyB2aXNpYmxlOiBmYWxzZSB9KTtcbiAgICAgICAgdGhpcy5hZGREb2N1bWVudEV2ZW50cygpO1xuXG4gICAgICAgIG92ZXJsYXlNYW5hZ2VyLmFkZE92ZXJsYXkodGhpcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNNb3VudGVkICYmIG5leHRQcm9wcy52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd2lsbE9wZW4gPSAhdGhpcy5wcm9wcy52aXNpYmxlICYmIG5leHRQcm9wcy52aXNpYmxlO1xuICAgICAgICBjb25zdCB3aWxsQ2xvc2UgPSB0aGlzLnByb3BzLnZpc2libGUgJiYgIW5leHRQcm9wcy52aXNpYmxlO1xuICAgICAgICBpZiAod2lsbE9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuYmVmb3JlT3BlbigpO1xuICAgICAgICAgICAgbmV4dFByb3BzLmJlZm9yZU9wZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICh3aWxsQ2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMuYmVmb3JlQ2xvc2UoKTtcbiAgICAgICAgICAgIG5leHRQcm9wcy5iZWZvcmVDbG9zZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQcm9wcy5hbmltYXRpb24gfHwgbmV4dFByb3BzLmFuaW1hdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogbmV4dFByb3BzLmFuaW1hdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dFByb3BzLmFuaW1hdGlvbiAhPT0gZmFsc2UgJiYgc3VwcG9ydC5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh3aWxsT3Blbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW50ZXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2lsbENsb3NlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgdmlzaWJsZTogbmV4dFByb3BzLnZpc2libGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBjb25zdCBvcGVuID0gIXByZXZQcm9wcy52aXNpYmxlICYmIHRoaXMucHJvcHMudmlzaWJsZTtcbiAgICAgICAgY29uc3QgY2xvc2UgPSBwcmV2UHJvcHMudmlzaWJsZSAmJiAhdGhpcy5wcm9wcy52aXNpYmxlO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5hbmltYXRpb24gJiYgc3VwcG9ydC5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChvcGVuIHx8IGNsb3NlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBbmltYXRpb25FdmVudHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXJOb2RlID0gdGhpcy5nZXRXcmFwcGVyTm9kZSgpO1xuICAgICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbk9wZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5hZnRlck9wZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKHdyYXBwZXJOb2RlLCAnb3BlbmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXlNYW5hZ2VyLmFkZE92ZXJsYXkodGhpcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsb3NlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5hZnRlckNsb3NlKCk7XG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKHdyYXBwZXJOb2RlLCAnb3BlbmVkJyk7XG4gICAgICAgICAgICAgICAgb3ZlcmxheU1hbmFnZXIucmVtb3ZlT3ZlcmxheSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0Rm9jdXNOb2RlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgb3ZlcmxheU1hbmFnZXIucmVtb3ZlT3ZlcmxheSh0aGlzKTtcbiAgICAgICAgdGhpcy5yZW1vdmVEb2N1bWVudEV2ZW50cygpO1xuICAgICAgICBpZiAodGhpcy5mb2N1c1RpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmZvY3VzVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uLm9mZigpO1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJlZm9yZUNsb3NlKCk7XG4gICAgfVxuXG4gICAgZ2V0QW5pbWF0aW9uKHByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wcy5hbmltYXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcHMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuYW5pbWF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QW5pbWF0aW9uQnlBbGlnbihwcm9wcy5hbGlnbik7XG4gICAgfVxuXG4gICAgZ2V0QW5pbWF0aW9uQnlBbGlnbihhbGlnbikge1xuICAgICAgICBzd2l0Y2ggKGFsaWduWzBdKSB7XG4gICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbjogJ2V4cGFuZEluRG93bicsXG4gICAgICAgICAgICAgICAgICAgIG91dDogJ2V4cGFuZE91dFVwJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbjogJ2V4cGFuZEluVXAnLFxuICAgICAgICAgICAgICAgICAgICBvdXQ6ICdleHBhbmRPdXREb3duJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGluOiAnZXhwYW5kSW5Eb3duJyxcbiAgICAgICAgICAgICAgICAgICAgb3V0OiAnZXhwYW5kT3V0VXAnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZEFuaW1hdGlvbkV2ZW50cygpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXRDb250ZW50Tm9kZSgpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGd1aWQoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbiA9IGV2ZW50cy5vbihub2RlLCBzdXBwb3J0LmFuaW1hdGlvbi5lbmQsIHRoaXMuaGFuZGxlQW5pbWF0ZUVuZC5iaW5kKHRoaXMsIGlkKSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhbmltYXRpb25EZWxheSA9IHBhcnNlRmxvYXQoZ2V0U3R5bGVQcm9wZXJ0eShub2RlLCAnYW5pbWF0aW9uLWRlbGF5JykpIHx8IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb24gPSBwYXJzZUZsb2F0KGdldFN0eWxlUHJvcGVydHkobm9kZSwgJ2FuaW1hdGlvbi1kdXJhdGlvbicpKSB8fCAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBhbmltYXRpb25EZWxheSArIGFuaW1hdGlvbkR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZW91dE1hcFtpZF0gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQW5pbWF0ZUVuZChpZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRpbWUgKiAxMDAwICsgMjAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGhhbmRsZVBvc2l0aW9uKGNvbmZpZykge1xuICAgICAgICBjb25zdCBhbGlnbiA9IGNvbmZpZy5hbGlnbi5qb2luKCcgJyk7XG5cbiAgICAgICAgaWYgKCEoJ2FuaW1hdGlvbicgaW4gdGhpcy5wcm9wcykgJiYgdGhpcy5wcm9wcy5uZWVkQWRqdXN0ICYmIHRoaXMubGFzdEFsaWduICE9PSBhbGlnbikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uOiB0aGlzLmdldEFuaW1hdGlvbkJ5QWxpZ24oYWxpZ24pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdEFsaWduID0gYWxpZ247XG4gICAgfVxuXG4gICAgaGFuZGxlQW5pbWF0ZUVuZChpZCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0TWFwW2lkXSkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dE1hcFtpZF0pO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRpbWVvdXRNYXBbaWRdO1xuXG4gICAgICAgIGlmICh0aGlzLl9hbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbi5vZmYoKTtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2lzTW91bnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RhdHVzID09PSAnbGVhdmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ25vbmUnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5vbkxlYXZlZCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuc3RhdHVzID09PSAnZW50ZXJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdub25lJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMub25FbnRlcmVkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbnRlcigpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgc3RhdHVzOiAnZW50ZXJpbmcnXG4gICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgIC8vIE5PVEU6IHNldFN0YXRlIGNhbGxiYWNrIChzZWNvbmQgYXJndW1lbnQpIG5vdyBmaXJlcyBpbW1lZGlhdGVseSBhZnRlciBjb21wb25lbnREaWRNb3VudCAvIGNvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkIG9mIGFmdGVyIGFsbCBjb21wb25lbnRzIGhhdmUgcmVuZGVyZWQuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FbnRlcmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBsZWF2ZSgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBzdGF0dXM6ICdsZWF2aW5nJ1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm9uTGVhdmluZygpO1xuICAgIH1cblxuICAgIG9uRW50ZXJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXJOb2RlID0gdGhpcy5nZXRXcmFwcGVyTm9kZSgpO1xuICAgICAgICBkb20uYWRkQ2xhc3Mod3JhcHBlck5vZGUsICdvcGVuZWQnKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbk9wZW4oKTtcbiAgICB9XG5cbiAgICBvbkxlYXZpbmcoKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXJOb2RlID0gdGhpcy5nZXRXcmFwcGVyTm9kZSgpO1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3Mod3JhcHBlck5vZGUsICdvcGVuZWQnKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNsb3NlKCk7XG4gICAgfVxuXG4gICAgb25FbnRlcmVkKCkge1xuICAgICAgICBvdmVybGF5TWFuYWdlci5hZGRPdmVybGF5KHRoaXMpO1xuICAgICAgICB0aGlzLnNldEZvY3VzTm9kZSgpO1xuICAgICAgICB0aGlzLnByb3BzLmFmdGVyT3BlbigpO1xuICAgIH1cblxuICAgIG9uTGVhdmVkKCkge1xuICAgICAgICBvdmVybGF5TWFuYWdlci5yZW1vdmVPdmVybGF5KHRoaXMpO1xuICAgICAgICB0aGlzLnNldEZvY3VzTm9kZSgpO1xuICAgICAgICB0aGlzLnByb3BzLmFmdGVyQ2xvc2UoKTtcbiAgICB9XG5cbiAgICBiZWZvcmVPcGVuKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5kaXNhYmxlU2Nyb2xsKSB7XG4gICAgICAgICAgICBpZiAobW9kYWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd1k6ICdoaWRkZW4nXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgICAgICBib2R5T3ZlcmZsb3dZID0gYm9keS5zdHlsZS5vdmVyZmxvd1k7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1Njcm9sbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlQYWRkaW5nUmlnaHQgPSBib2R5LnN0eWxlLnBhZGRpbmdSaWdodDtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUucGFkZGluZ1JpZ2h0ID0gYCR7ZG9tLmdldFN0eWxlKGJvZHksICdwYWRkaW5nUmlnaHQnKSArIGRvbS5zY3JvbGxiYXIoKS53aWR0aH1weGA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG9tLnNldFN0eWxlKGJvZHksIHN0eWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZGFscy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYmVmb3JlQ2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmRpc2FibGVTY3JvbGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbW9kYWxzLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChtb2RhbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dZOiBib2R5T3ZlcmZsb3dZXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNTY3JvbGwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUucGFkZGluZ1JpZ2h0ID0gYm9keVBhZGRpbmdSaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRvbS5zZXRTdHlsZShkb2N1bWVudC5ib2R5LCBzdHlsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgYm9keU92ZXJmbG93WSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgYm9keVBhZGRpbmdSaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2RhbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldEZvY3VzTm9kZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudmlzaWJsZSAmJiAhdGhpcy5faGFzRm9jdXNlZCkge1xuICAgICAgICAgICAgc2F2ZUxhc3RGb2N1c05vZGUoKTtcbiAgICAgICAgICAgIC8vIOi/meS4quaXtuWAmeW+iOWPr+iDveS4iuS4gOS4quW8ueWxgueahOWFs+mXreS6i+S7tui/mOacquinpuWPke+8jOWvvOiHtOeEpueCueW3sue7j+WbnuWIsOinpuWPkeeahOWFg+e0oFxuICAgICAgICAgICAgLy8g6L+Z6YeM5bu25pe25aSE55CG5LiA5LiL77yM5bu25pe255qE5pe26Ze05Li6IGRvY3VtZW50LmNsaWNrIOaNleiOt+inpuWPkeeahOW7tuaXtuaXtumXtFxuICAgICAgICAgICAgdGhpcy5mb2N1c1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXRDb250ZW50Tm9kZSgpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvY3VzTm9kZUxpc3QgPSBnZXRGb2N1c05vZGVMaXN0KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNOb2RlTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzTm9kZUxpc3RbMF0uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnN0YXRlLnZpc2libGUgJiYgdGhpcy5faGFzRm9jdXNlZCkge1xuICAgICAgICAgICAgYmFja0xhc3RGb2N1c05vZGUoKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRSZWY7XG4gICAgfVxuXG4gICAgZ2V0Q29udGVudE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBmaW5kRE9NTm9kZSh0aGlzLmNvbnRlbnRSZWYpO1xuICAgIH1cblxuICAgIGdldFdyYXBwZXJOb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nYXRld2F5UmVmID8gdGhpcy5nYXRld2F5UmVmLmdldENoaWxkTm9kZSgpIDogbnVsbDtcbiAgICB9XG5cbiAgICBhZGREb2N1bWVudEV2ZW50cygpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuY2FuQ2xvc2VCeUVzYykge1xuICAgICAgICAgICAgdGhpcy5fa2V5ZG93bkV2ZW50cyA9IGV2ZW50cy5vbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50S2V5RG93bik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuY2FuQ2xvc2VCeU91dFNpZGVDbGljaykge1xuICAgICAgICAgICAgdGhpcy5fY2xpY2tFdmVudHMgPSBldmVudHMub24oZG9jdW1lbnQsICdjbGljaycsIHRoaXMuaGFuZGxlRG9jdW1lbnRDbGljayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmVEb2N1bWVudEV2ZW50cygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2tleWRvd25FdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2tleWRvd25FdmVudHMub2ZmKCk7XG4gICAgICAgICAgICB0aGlzLl9rZXlkb3duRXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2xpY2tFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaWNrRXZlbnRzLm9mZigpO1xuICAgICAgICAgICAgdGhpcy5fY2xpY2tFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlRG9jdW1lbnRLZXlEb3duKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudmlzaWJsZSAmJiBlLmtleUNvZGUgPT09IEtFWUNPREUuRVNDICYmIG92ZXJsYXlNYW5hZ2VyLmlzQ3VycmVudE92ZXJsYXkodGhpcykpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25SZXF1ZXN0Q2xvc2UoJ2tleWJvYXJkJywgZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVEb2N1bWVudENsaWNrKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudmlzaWJsZSkge1xuICAgICAgICAgICAgY29uc3QgeyBzYWZlTm9kZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGNvbnN0IHNhZmVOb2RlcyAgPSBBcnJheS5pc0FycmF5KHNhZmVOb2RlKSA/IFsuLi5zYWZlTm9kZV0gOiBbc2FmZU5vZGVdO1xuICAgICAgICAgICAgc2FmZU5vZGVzLnVuc2hpZnQoKCkgPT4gdGhpcy5nZXRXcmFwcGVyTm9kZSgpKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYWZlTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gZmluZE5vZGUoc2FmZU5vZGVzW2ldLCB0aGlzLnByb3BzKTtcbiAgICAgICAgICAgICAgICAvLyBIQUNLOiDlpoLmnpzop6blj5Hngrnlh7vnmoToioLngrnmmK/lvLnlsYLlhoXpg6jnmoToioLngrnvvIzlubbkuJTlnKjooqvngrnlh7vlkI7nq4vljbPplIDmr4HvvIzpgqPkuYjmraTml7bml6Dms5Xkvb/nlKggbm9kZS5jb250YWlucyhlLnRhcmdldClcbiAgICAgICAgICAgICAgICAvLyDmnaXliKTmlq3mraTml7bngrnlh7vnmoToioLngrnmmK/lkKbmmK/lvLnlsYLlhoXpg6jnmoToioLngrnvvIzpop3lpJbliKTmlq1cbiAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiAobm9kZSA9PT0gZS50YXJnZXQgfHwgbm9kZS5jb250YWlucyhlLnRhcmdldCkgfHxcbiAgICAgICAgICAgICAgICAoZS50YXJnZXQgIT09IGRvY3VtZW50ICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZS50YXJnZXQpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblJlcXVlc3RDbG9zZSgnZG9jQ2xpY2snLCBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZU1hc2tDbGljayhlKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmNhbkNsb3NlQnlNYXNrKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uUmVxdWVzdENsb3NlKCdtYXNrQ2xpY2snLCBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNhdmVDb250ZW50UmVmID0gKHJlZikgPT4ge1xuICAgICAgICB0aGlzLmNvbnRlbnRSZWYgPSByZWY7XG4gICAgfVxuXG4gICAgc2F2ZUdhdGV3YXlSZWYgPSAocmVmKSA9PiB7XG4gICAgICAgIHRoaXMuZ2F0ZXdheVJlZiA9IHJlZjtcbiAgICB9XG5cbiAgICAvLyDlhbzlrrnov4fljrvnmoTnlKjms5U6IHRoaXMucG9wdXBSZWYuZ2V0SW5zdGFuY2UoKS5vdmVybGF5LmdldEluc3RhbmNlKCkuZ2V0Q29udGVudE5vZGUoKVxuICAgIGdldEluc3RhbmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHByZWZpeCwgY2xhc3NOYW1lLCBzdHlsZSwgY2hpbGRyZW46IHByb3BDaGlsZHJlbixcbiAgICAgICAgICAgIHRhcmdldCwgYWxpZ24sIG9mZnNldCwgY29udGFpbmVyLCBoYXNNYXNrLCBuZWVkQWRqdXN0LFxuICAgICAgICAgICAgYmVmb3JlUG9zaXRpb24sIG9uUG9zaXRpb24sIHdyYXBwZXJTdHlsZSwgcnRsLFxuICAgICAgICAgICAgc2hvdWxkVXBkYXRlUG9zaXRpb246IHByb3BTaG91bGRVcGRhdGVQb3NpdGlvbixcbiAgICAgICAgICAgIGNhY2hlLCB3cmFwcGVyQ2xhc3NOYW1lLCBvbk1hc2tNb3VzZUVudGVyLCBvbk1hc2tNb3VzZUxlYXZlXG4gICAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHZpc2libGU6IHN0YXRlVmlzaWJsZSwgc3RhdHVzLCBhbmltYXRpb24gfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgbGV0IGNoaWxkcmVuID0gc3RhdGVWaXNpYmxlIHx8IChjYWNoZSAmJiB0aGlzLl9pc01vdW50ZWQpID8gcHJvcENoaWxkcmVuIDogbnVsbDtcbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IENoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRDbGF6eiA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9b3ZlcmxheS1pbm5lcmBdOiB0cnVlLFxuICAgICAgICAgICAgICAgIFthbmltYXRpb24uaW5dOiBzdGF0dXMgPT09ICdlbnRlcmluZycsXG4gICAgICAgICAgICAgICAgW2FuaW1hdGlvbi5vdXRdOiBzdGF0dXMgPT09ICdsZWF2aW5nJyxcbiAgICAgICAgICAgICAgICBbY2hpbGQucHJvcHMuY2xhc3NOYW1lXTogISFjaGlsZC5wcm9wcy5jbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgW2NsYXNzTmFtZV06ICEhY2xhc3NOYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQucmVmID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBzZXQgcmVmIGJ5IHN0cmluZyBpbiBPdmVybGF5LCB1c2UgZnVuY3Rpb24gaW5zdGVhZC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGRyZW4gPSBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNoaWxkQ2xhenosXG4gICAgICAgICAgICAgICAgc3R5bGU6IHsuLi5jaGlsZC5wcm9wcy5zdHlsZSwgLi4uc3R5bGV9LFxuICAgICAgICAgICAgICAgIHJlZjogbWFrZUNoYWluKHRoaXMuc2F2ZUNvbnRlbnRSZWYsIGNoaWxkLnJlZiksXG4gICAgICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogIXN0YXRlVmlzaWJsZSAmJiBjYWNoZSAmJiB0aGlzLl9pc01vdW50ZWRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoYWxpZ24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRVcGRhdGVQb3NpdGlvbiA9IHN0YXR1cyA9PT0gJ2xlYXZpbmcnID8gZmFsc2UgOiBwcm9wU2hvdWxkVXBkYXRlUG9zaXRpb247XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSAoXG4gICAgICAgICAgICAgICAgICAgIDxQb3NpdGlvbiB7Li4uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLCB0YXJnZXQsIGFsaWduLCBvZmZzZXQsIG5lZWRBZGp1c3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmVQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUG9zaXRpb246IG1ha2VDaGFpbih0aGlzLmhhbmRsZVBvc2l0aW9uLCBvblBvc2l0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZVBvc2l0aW9uLCBydGxcbiAgICAgICAgICAgICAgICAgICAgfSl9IC8+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgd3JhcHBlckNsYXp6ID0gY2xhc3NuYW1lcyhbXG4gICAgICAgICAgICAgICAgYCR7cHJlZml4fW92ZXJsYXktd3JhcHBlcmAsXG4gICAgICAgICAgICAgICAgd3JhcHBlckNsYXNzTmFtZVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBjb25zdCBuZXdXcmFwcGVyU3R5bGUgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogc3RhdGVWaXNpYmxlID8gJycgOiAnbm9uZSdcbiAgICAgICAgICAgIH0sIHdyYXBwZXJTdHlsZSk7XG5cbiAgICAgICAgICAgIGNoaWxkcmVuID0gKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXt3cmFwcGVyQ2xhenp9IHN0eWxlPXtuZXdXcmFwcGVyU3R5bGV9IGRpcj17cnRsID8gJ3J0bCcgOiB1bmRlZmluZWR9PlxuICAgICAgICAgICAgICAgICAgICB7aGFzTWFzayA/XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fW92ZXJsYXktYmFja2Ryb3BgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlTWFza0NsaWNrfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlcj17b25NYXNrTW91c2VFbnRlcn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU9e29uTWFza01vdXNlTGVhdmV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyPXtydGwgPyAncnRsJyA6IHVuZGVmaW5lZH0gLz4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbH1cbiAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiA8R2F0ZXdheSB7Li4uKHtjb250YWluZXIsIHRhcmdldCwgY2hpbGRyZW59KX0gcmVmPXt0aGlzLnNhdmVHYXRld2F5UmVmfSAvPjtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvb3ZlcmxheS9vdmVybGF5LmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUsIGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgZnVuYyB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IGZpbmROb2RlIGZyb20gJy4vdXRpbHMvZmluZC1ub2RlJztcblxuY29uc3QgeyBtYWtlQ2hhaW4gfSA9IGZ1bmM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhdGV3YXkgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgY29udGFpbmVyOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICB0YXJnZXQ6IFByb3BUeXBlcy5hbnksXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGNvbnRhaW5lcjogKCkgPT4gZG9jdW1lbnQuYm9keVxuICAgIH07XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXJOb2RlID0gdGhpcy5nZXRDb250YWluZXJOb2RlKHRoaXMucHJvcHMpO1xuICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXJOb2RlID0gdGhpcy5nZXRDb250YWluZXJOb2RlKG5leHRQcm9wcyk7XG4gICAgfVxuXG4gICAgZ2V0Q29udGFpbmVyTm9kZShwcm9wcykge1xuICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gZmluZE5vZGUocHJvcHMudGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIGZpbmROb2RlKHByb3BzLmNvbnRhaW5lciwgdGFyZ2V0Tm9kZSk7XG4gICAgfVxuXG4gICAgZ2V0Q2hpbGROb2RlKCkge1xuICAgICAgICByZXR1cm4gZmluZERPTU5vZGUodGhpcy5jaGlsZCk7XG4gICAgfVxuXG4gICAgc2F2ZUNoaWxkUmVmID0gcmVmID0+IHtcbiAgICAgICAgdGhpcy5jaGlsZCA9IHJlZjtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250YWluZXJOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuID8gQ2hpbGRyZW4ub25seShjaGlsZHJlbikgOiBudWxsO1xuICAgICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQucmVmID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IHNldCByZWYgYnkgc3RyaW5nIGluIEdhdGV3YXksIHVzZSBmdW5jdGlvbiBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgICAgICByZWY6IG1ha2VDaGFpbih0aGlzLnNhdmVDaGlsZFJlZiwgY2hpbGQucmVmKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkLCB0aGlzLmNvbnRhaW5lck5vZGUpO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9vdmVybGF5L2dhdGV3YXkuanN4IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBmdW5jLCBkb20sIGV2ZW50cyB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHBvc2l0aW9uIGZyb20gJy4vdXRpbHMvcG9zaXRpb24nO1xuaW1wb3J0IGZpbmROb2RlIGZyb20gJy4vdXRpbHMvZmluZC1ub2RlJztcblxuY29uc3QgeyBub29wLCBiaW5kQ3R4IH0gPSBmdW5jO1xuY29uc3QgeyBnZXRTdHlsZSB9ID0gZG9tO1xuY29uc3QgcGxhY2UgPSBwb3NpdGlvbi5wbGFjZTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9zaXRpb24gZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBWSUVXUE9SVCA9IHBvc2l0aW9uLlZJRVdQT1JUO1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICB0YXJnZXQ6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIGFsaWduOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYm9vbF0pLFxuICAgICAgICBvZmZzZXQ6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgYmVmb3JlUG9zaXRpb246IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvblBvc2l0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgbmVlZEFkanVzdDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIG5lZWRMaXN0ZW5SZXNpemU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBzaG91bGRVcGRhdGVQb3NpdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHJ0bDogUHJvcFR5cGVzLmJvb2xcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgYWxpZ246ICd0bCBibCcsXG4gICAgICAgIG9mZnNldDogWzAsIDBdLFxuICAgICAgICBiZWZvcmVQb3NpdGlvbjogbm9vcCxcbiAgICAgICAgb25Qb3NpdGlvbjogbm9vcCxcbiAgICAgICAgbmVlZEFkanVzdDogdHJ1ZSxcbiAgICAgICAgbmVlZExpc3RlblJlc2l6ZTogdHJ1ZSxcbiAgICAgICAgc2hvdWxkVXBkYXRlUG9zaXRpb246IGZhbHNlLFxuICAgICAgICBydGw6IGZhbHNlLFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgYmluZEN0eCh0aGlzLCBbJ2hhbmRsZVJlc2l6ZSddKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbigpO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLm5lZWRMaXN0ZW5SZXNpemUpIHtcbiAgICAgICAgICAgIGV2ZW50cy5vbih3aW5kb3csICdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBpZiAoJ2FsaWduJyBpbiBuZXh0UHJvcHMgJiYgbmV4dFByb3BzLmFsaWduICE9PSB0aGlzLnByb3BzLmFsaWduIHx8IG5leHRQcm9wcy5zaG91bGRVcGRhdGVQb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zaG91bGRVcGRhdGVQb3NpdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFVwZGF0ZVBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnNob3VsZFVwZGF0ZVBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMubmVlZExpc3RlblJlc2l6ZSkge1xuICAgICAgICAgICAgZXZlbnRzLm9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICB9XG5cbiAgICBzZXRQb3NpdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBhbGlnbiwgb2Zmc2V0LCBiZWZvcmVQb3NpdGlvbiwgb25Qb3NpdGlvbiwgbmVlZEFkanVzdCwgcnRsIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGJlZm9yZVBvc2l0aW9uKCk7XG5cbiAgICAgICAgY29uc3QgY29udGVudE5vZGUgPSB0aGlzLmdldENvbnRlbnROb2RlKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSB0aGlzLmdldFRhcmdldE5vZGUoKTtcbiAgICAgICAgaWYgKGNvbnRlbnROb2RlICYmIHRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdEFsaWduID0gcGxhY2Uoe1xuICAgICAgICAgICAgICAgIHBpbkVsZW1lbnQ6IGNvbnRlbnROb2RlLFxuICAgICAgICAgICAgICAgIGJhc2VFbGVtZW50OiB0YXJnZXROb2RlLFxuICAgICAgICAgICAgICAgIGFsaWduLFxuICAgICAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgICAgICBuZWVkQWRqdXN0LFxuICAgICAgICAgICAgICAgIGlzUnRsOiBydGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGdldFN0eWxlKGNvbnRlbnROb2RlLCAndG9wJyk7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gZ2V0U3R5bGUoY29udGVudE5vZGUsICdsZWZ0Jyk7XG5cbiAgICAgICAgICAgIG9uUG9zaXRpb24oe1xuICAgICAgICAgICAgICAgIGFsaWduOiByZXN1bHRBbGlnbi5zcGxpdCgnICcpLFxuICAgICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0XG4gICAgICAgICAgICB9LCBjb250ZW50Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRDb250ZW50Tm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRET01Ob2RlKHRoaXMpO1xuICAgIH1cblxuICAgIGdldFRhcmdldE5vZGUoKSB7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQgPT09IHBvc2l0aW9uLlZJRVdQT1JUID8gcG9zaXRpb24uVklFV1BPUlQgOiBmaW5kTm9kZSh0YXJnZXQsIHRoaXMucHJvcHMpO1xuICAgIH1cblxuICAgIGhhbmRsZVJlc2l6ZSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG5cbiAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKCk7XG4gICAgICAgIH0sIDIwMCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvb3ZlcmxheS9wb3NpdGlvbi5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IEZpbHRlckNvbXBvbmVudCBmcm9tICcuL2ZpbHRlcic7XG5pbXBvcnQgU29ydENvbXBvbmVudCBmcm9tICcuL3NvcnQnO1xuaW1wb3J0IENlbGxDb21wb25lbnQgZnJvbSAnLi9jZWxsJztcbmltcG9ydCBSZXNpemVDb21wb25lbnQgZnJvbSAnLi9yZXNpemUnO1xuXG5jb25zdCBub29wID0gKCkgPT4geyB9O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVhZGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBwdXJlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjb21wb25lbnQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNvbHVtbnM6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgY29sR3JvdXA6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIGhlYWRlckNlbGxSZWY6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBsb2NhbGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIGZpbHRlclBhcmFtczogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgb25GaWx0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBjb21wb25lbnRzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBzb3J0OiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBvblNvcnQ6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvblJlc2l6ZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmNcbiAgICB9XG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgY29tcG9uZW50OiAndGhlYWQnLFxuICAgICAgICBjb2x1bW5zOiBbXSxcbiAgICAgICAgaGVhZGVyQ2VsbFJlZjogbm9vcCxcbiAgICAgICAgb25GaWx0ZXI6IG5vb3AsXG4gICAgICAgIGNvbXBvbmVudHM6IHt9LFxuICAgICAgICBvblNvcnQ6IG5vb3AsXG4gICAgICAgIG9uUmVzaXplQ2hhbmdlOiBub29wXG4gICAgfVxuXG4gICAgZ2V0Q2VsbFJlZiA9IChpLCBqLCBjZWxsKSA9PiB7XG4gICAgICAgIHRoaXMucHJvcHMuaGVhZGVyQ2VsbFJlZihpLCBqLCBjZWxsKTtcbiAgICB9XG5cbiAgICBvblNvcnQgPSAoZGF0YUluZGV4LCBvcmRlciwgc29ydCkgPT4ge1xuICAgICAgICB0aGlzLnByb3BzLm9uU29ydChkYXRhSW5kZXgsIG9yZGVyLCBzb3J0KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8qZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIGNsYXNzTmFtZSwgY2hpbGRyZW4sIGNvbXBvbmVudDogVGFnLCBjb2xHcm91cCwgY29sdW1ucywgbG9jYWxlLCBmaWx0ZXJQYXJhbXMsXG4gICAgICAgICAgICBvbkZpbHRlciwgY29tcG9uZW50cywgYWZmaXhSZWYsIGhlYWRlckNlbGxSZWYsIG9uU29ydCwgc29ydCwgb25SZXNpemVDaGFuZ2UsIHB1cmUsIC4uLm90aGVyc1xuICAgICAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBjb25zdCB7IENlbGwgPSBDZWxsQ29tcG9uZW50LCBGaWx0ZXIgPSBGaWx0ZXJDb21wb25lbnQsIFNvcnQgPSBTb3J0Q29tcG9uZW50LCBSZXNpemUgPSBSZXNpemVDb21wb25lbnQgfSA9IGNvbXBvbmVudHM7XG4gICAgICAgIGNvbnN0IHJvd1NwYW4gPSBjb2x1bW5zLmxlbmd0aDtcblxuICAgICAgICBjb25zdCBoZWFkZXIgPSBjb2x1bW5zLm1hcCgoY29scywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IGNvbHMubWFwKChjb2wsIGopID0+IHtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycywgcHJlZmVyLWNvbnN0ICovXG4gICAgICAgICAgICAgICAgbGV0IHsgdGl0bGUsIGNvbFNwYW4sIHNvcnRhYmxlLCByZXNpemFibGUsIGRhdGFJbmRleCwgZmlsdGVycywgZmlsdGVyTW9kZSwgd2lkdGgsIGFsaWduLCBjbGFzc05hbWUsIF9fbm9ybWFsaXplZCwgbG9jaywgLi4ub3RoZXJzIH0gPSBjb2w7XG5cbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgW2Ake3ByZWZpeH10YWJsZS1oZWFkZXItbm9kZWBdOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4fXRhYmxlLWhlYWRlci1yZXNpemFibGVgXTogcmVzaXphYmxlLFxuICAgICAgICAgICAgICAgICAgICBbY2xhc3NOYW1lXTogY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IGF0dHJzID0ge30sIHNvcnRFbGVtZW50LCBmaWx0ZXJFbGVtZW50LCByZXNpemVFbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChjb2wuY2hpbGRyZW4gJiYgY29sLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBhdHRycy5jb2xTcGFuID0gY29sU3BhbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc29ydGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRFbGVtZW50ID0gKDxTb3J0IHByZWZpeD17cHJlZml4fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJbmRleD17ZGF0YUluZGV4fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU29ydD17dGhpcy5vblNvcnR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydD17c29ydH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU9e2xvY2FsZX0vPik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc2l6YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplRWxlbWVudCA9IDxSZXNpemUgcHJlZml4PXtwcmVmaXh9IGRhdGFJbmRleD17ZGF0YUluZGV4fSBvbkNoYW5nZT17b25SZXNpemVDaGFuZ2V9Lz47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyRWxlbWVudCA9IGZpbHRlcnMubGVuZ3RoID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoPEZpbHRlciBkYXRhSW5kZXg9e2RhdGFJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVycz17ZmlsdGVyc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4PXtwcmVmaXh9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZT17bG9jYWxlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJQYXJhbXM9e2ZpbHRlclBhcmFtc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyTW9kZT17ZmlsdGVyTW9kZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25GaWx0ZXI9e29uRmlsdGVyfSAvPikgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLnJvd1NwYW4gPSByb3dTcGFuIC0gaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoPENlbGwgey4uLm90aGVyc30gey4uLmF0dHJzfVxuICAgICAgICAgICAgICAgICAgICBrZXk9e2p9XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeD17cHJlZml4fVxuICAgICAgICAgICAgICAgICAgICBwdXJlPXtwdXJlfVxuICAgICAgICAgICAgICAgICAgICBjZWxsPXt0aXRsZX1cbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50PVwidGhcIlxuICAgICAgICAgICAgICAgICAgICBhbGlnbj17YWxpZ259XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICAgICAgICAgICAgICByZWY9e3RoaXMuZ2V0Q2VsbFJlZi5iaW5kKHRoaXMsIGluZGV4LCBqKX1cbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cImhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICB7c29ydEVsZW1lbnR9e2ZpbHRlckVsZW1lbnR9e3Jlc2l6ZUVsZW1lbnR9XG4gICAgICAgICAgICAgICAgPC9DZWxsPik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiA8dHIga2V5PXtpbmRleH0+e2NvbH08L3RyPjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuICg8VGFnIGNsYXNzTmFtZT17Y2xhc3NOYW1lfSB7Li4ub3RoZXJzfT5cbiAgICAgICAgICAgIHtoZWFkZXJ9XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvVGFnPik7XG4gICAgfVxufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvYmFzZS9oZWFkZXIuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgRHJvcGRvd24gZnJvbSAnLi4vLi4vZHJvcGRvd24nO1xuaW1wb3J0IE1lbnUgZnJvbSAnLi4vLi4vbWVudSc7XG5pbXBvcnQgQnV0dG9uIGZyb20gJy4uLy4uL2J1dHRvbic7XG5pbXBvcnQgSWNvbiBmcm9tICcuLi8uLi9pY29uJztcbmltcG9ydCB7IEtFWUNPREUgfSBmcm9tICcuLi8uLi91dGlsJztcblxuLy8g5YWx5Lqr54q25oCB55qE57uE5Lu26ZyA6KaB5Y+Y5oiQ6Z2e5Y+X5o6n57uE5Lu2XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWx0ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIGRhdGFJbmRleDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgZmlsdGVyczogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBmaWx0ZXJNb2RlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBmaWx0ZXJQYXJhbXM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIGxvY2FsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgb25GaWx0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmdcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBvbkZpbHRlcjogKCkgPT4ge31cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIGNvbnN0IGZpbHRlclBhcmFtcyA9IHByb3BzLmZpbHRlclBhcmFtcyB8fCB7fTtcbiAgICAgICAgY29uc3QgZmlsdGVyQ29uZmlnID0gZmlsdGVyUGFyYW1zW3Byb3BzLmRhdGFJbmRleF0gfHwge307XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB2aXNpYmxlOiBmaWx0ZXJDb25maWcudmlzaWJsZSB8fCBmYWxzZSxcbiAgICAgICAgICAgIHNlbGVjdGVkS2V5czogZmlsdGVyQ29uZmlnLnNlbGVjdGVkS2V5cyB8fCBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZWxlY3RlZEtleXMgPSBbLi4udGhpcy5zdGF0ZS5zZWxlY3RlZEtleXNdO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkoJ2ZpbHRlclBhcmFtcycpICYmIHR5cGVvZiBuZXh0UHJvcHMuZmlsdGVyUGFyYW1zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc3QgZGF0YUluZGV4ID0gbmV4dFByb3BzLmRhdGFJbmRleCB8fCB0aGlzLnByb3BzLmRhdGFJbmRleDtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlclBhcmFtcyA9IG5leHRQcm9wcy5maWx0ZXJQYXJhbXMgfHwge307XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJDb25maWcgPSBmaWx0ZXJQYXJhbXNbZGF0YUluZGV4XSB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkS2V5cyA9IGZpbHRlckNvbmZpZy5zZWxlY3RlZEtleXMgfHwgW107XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEtleXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRLZXlzID0gWy4uLnNlbGVjdGVkS2V5c107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmaWx0ZXJLZXlkb3duID0gZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBLRVlDT0RFLkVOVEVSKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiAhdGhpcy5zdGF0ZS52aXNpYmxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uRmlsdGVyVmlzaWJsZSA9ICh2aXNpYmxlKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdmlzaWJsZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkS2V5cyA9IFsuLi50aGlzLl9zZWxlY3RlZEtleXNdO1xuXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEtleXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25GaWx0ZXJTZWxlY3QgPSAoc2VsZWN0ZWRLZXlzKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHNlbGVjdGVkS2V5c1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbkZpbHRlckNvbmZpcm0gPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkS2V5cyA9IHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzO1xuICAgICAgICBjb25zdCBmaWx0ZXJQYXJhbXMgPSB7fSwgeyBkYXRhSW5kZXggfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgZmlsdGVyUGFyYW1zW2RhdGFJbmRleF0gPSB7XG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHNlbGVjdGVkS2V5czogc2VsZWN0ZWRLZXlzXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkS2V5cyA9IFsuLi5zZWxlY3RlZEtleXNdO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyDlhbzlrrnkuYvliY3nmoTmoLzlvI9cbiAgICAgICAgdGhpcy5wcm9wcy5vbkZpbHRlcihmaWx0ZXJQYXJhbXMpO1xuICAgIH1cblxuICAgIG9uRmlsdGVyQ2xlYXIgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbHRlclBhcmFtcyA9IHt9LCB7IGRhdGFJbmRleCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBmaWx0ZXJQYXJhbXNbZGF0YUluZGV4XSA9IHtcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgc2VsZWN0ZWRLZXlzOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZWxlY3RlZEtleXMgPSBbXTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBzZWxlY3RlZEtleXM6IFtdLFxuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIOWFvOWuueS5i+WJjeeahOagvOW8j1xuICAgICAgICB0aGlzLnByb3BzLm9uRmlsdGVyKGZpbHRlclBhcmFtcyk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGZpbHRlcnMsIHByZWZpeCwgbG9jYWxlLCBmaWx0ZXJNb2RlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHZpc2libGUsIHNlbGVjdGVkS2V5cyB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBmdW5jdGlvbiByZW5kZXJNZW51SXRlbShpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gPE1lbnUuSXRlbSBrZXk9e2l0ZW0udmFsdWV9PntpdGVtLmxhYmVsfTwvTWVudS5JdGVtPjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbmRlclN1Yk1lbnUocGFyZW50LCBjaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8TWVudS5TdWJNZW51IGxhYmVsPXtwYXJlbnQubGFiZWx9IGtleT17cGFyZW50LnZhbHVlfSBzZWxlY3RhYmxlPXtmYWxzZX0+XG4gICAgICAgICAgICAgICAgICAgIHtyZW5kZXJNZW51Q29udGVudChjaGlsZHJlbil9XG4gICAgICAgICAgICAgICAgPC9NZW51LlN1Yk1lbnU+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVuZGVyTWVudUNvbnRlbnQobGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpc3QubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJTdWJNZW51KGl0ZW0sIGl0ZW0uY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJNZW51SXRlbShpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSByZW5kZXJNZW51Q29udGVudChmaWx0ZXJzKSxcbiAgICAgICAgICAgIGZvb3RlciA9IChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLWZpbHRlci1mb290ZXJgfT5cbiAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiB0eXBlPVwicHJpbWFyeVwiIG9uQ2xpY2s9e3RoaXMub25GaWx0ZXJDb25maXJtfT57bG9jYWxlLm9rfTwvQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9e3RoaXMub25GaWx0ZXJDbGVhcn0+e2xvY2FsZS5yZXNldH08L0J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxEcm9wZG93biB0cmlnZ2VyPXtcbiAgICAgICAgICAgICAgICA8c3BhbiByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD17bG9jYWxlLmZpbHRlcn1cbiAgICAgICAgICAgICAgICAgICAgb25LZXlEb3duPXt0aGlzLmZpbHRlcktleWRvd259XG4gICAgICAgICAgICAgICAgICAgIHRhYkluZGV4PVwiMFwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLWZpbHRlcmB9PlxuICAgICAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPVwiZmlsdGVyXCIgc2l6ZT1cInNtYWxsXCIgLz5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyVHlwZT1cImNsaWNrXCJcbiAgICAgICAgICAgIHZpc2libGU9e3Zpc2libGV9XG4gICAgICAgICAgICBhdXRvRm9jdXNcbiAgICAgICAgICAgIGNvbnRhaW5lcj17bm9kZSA9PiBub2RlLnBhcmVudE5vZGV9XG4gICAgICAgICAgICBvblZpc2libGVDaGFuZ2U9e3RoaXMub25GaWx0ZXJWaXNpYmxlfT5cbiAgICAgICAgICAgICAgICA8TWVudSBmb290ZXI9e2Zvb3Rlcn1cbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRLZXlzPXtzZWxlY3RlZEtleXN9XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdE1vZGU9e2ZpbHRlck1vZGV9XG4gICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0PXt0aGlzLm9uRmlsdGVyU2VsZWN0fT5cbiAgICAgICAgICAgICAgICAgICAge2NvbnRlbnR9XG4gICAgICAgICAgICAgICAgPC9NZW51PlxuICAgICAgICAgICAgPC9Ecm9wZG93bj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvYmFzZS9maWx0ZXIuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgQ2hpbGRyZW4sIGNsb25lRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBmdW5jLCBvYmosIEtFWUNPREUgfSBmcm9tICcuLi8uLi91dGlsJztcblxuY29uc3QgeyBiaW5kQ3R4IH0gPSBmdW5jO1xuY29uc3QgeyBwaWNrT3RoZXJzIH0gPSBvYmo7XG5jb25zdCBub29wID0gKCkgPT4ge307XG5cbi8qKlxuICogTWVudVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZW51IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgaXNOZXh0TWVudSA9IHRydWU7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHB1cmU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBydGw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoj5zljZXpobnlkozlrZDoj5zljZVcbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeCueWHu+iPnOWNlemhueinpuWPkeeahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IOeCueWHu+eahOiPnOWNlemhueeahCBrZXkg5YC8XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIOeCueWHu+eahOiPnOWNlemhueWvueixoVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg54K55Ye755qE5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBvbkl0ZW1DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvZPliY3miZPlvIDnmoTlrZDoj5zljZXnmoQga2V5IOWAvFxuICAgICAgICAgKi9cbiAgICAgICAgb3BlbktleXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5hcnJheV0pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5Yid5aeL5omT5byA55qE5a2Q6I+c5Y2V55qEIGtleSDlgLxcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRPcGVuS2V5czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmFycmF5XSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliJ3lp4vlsZXlvIDmiYDmnInnmoTlrZDoj5zljZXvvIzlj6rlnKggbW9kZSDorr7nva7kuLogJ2lubGluZScg5Lul5Y+KIG9wZW5Nb2RlIOiuvue9ruS4uiAnbXVsdGlwbGUnIOS4i+eUn+aViO+8jOS8mOWFiOe6p+mrmOS6jiBkZWZhdWx0T3BlbktleXNcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRPcGVuQWxsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaJk+W8gOaIluWFs+mXreWtkOiPnOWNleinpuWPkeeahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IOaJk+W8gOeahOaJgOacieWtkOiPnOWNleeahCBrZXkg5YC8XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHRyYSDpop3lpJblj4LmlbBcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV4dHJhLmtleSDlvZPliY3mk43kvZzlrZDoj5zljZXnmoQga2V5IOWAvFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV4dHJhLm9wZW4g5piv5ZCm5piv5omT5byAXG4gICAgICAgICAqL1xuICAgICAgICBvbk9wZW46IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5a2Q6I+c5Y2V5omT5byA55qE5qih5byPXG4gICAgICAgICAqL1xuICAgICAgICBtb2RlOiBQcm9wVHlwZXMub25lT2YoWydpbmxpbmUnLCAncG9wdXAnXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlrZDoj5zljZXmiZPlvIDnmoTop6blj5HooYzkuLpcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXJUeXBlOiBQcm9wVHlwZXMub25lT2YoWydjbGljaycsICdob3ZlciddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWxleW8gOWGhei/nuWtkOiPnOWNleeahOaooeW8j++8jOWQjOaXtuWPr+S7peWxleW8gOS4gOS4quWtkOiPnOWNlei/mOaYr+WkmuS4quWtkOiPnOWNle+8jOivpeWxnuaAp+S7heWcqCBtb2RlIOS4uiBpbmxpbmUg5pe255Sf5pWIXG4gICAgICAgICAqL1xuICAgICAgICBvcGVuTW9kZTogUHJvcFR5cGVzLm9uZU9mKFsnc2luZ2xlJywgJ211bHRpcGxlJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5YaF6L+e5a2Q6I+c5Y2V57yp6L+b6Led56a7XG4gICAgICAgICAqL1xuICAgICAgICBpbmxpbmVJbmRlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGlubGluZUFycm93RGlyZWN0aW9uOiBQcm9wVHlwZXMub25lT2YoWydkb3duJywgJ3JpZ2h0J10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm6Ieq5Yqo6K6p5by55bGC55qE5a695bqm5ZKM6I+c5Y2V6aG55L+d5oyB5LiA6Ie077yM5aaC5p6c5by55bGC55qE5a695bqm5q+U6I+c5Y2V6aG55bCP5YiZ5ZKM6I+c5Y2V6aG55L+d5oyB5LiA6Ie077yM5aaC5p6c5a695bqm5aSn5LqO6I+c5Y2V6aG55YiZ5LiN5YGa5aSE55CGXG4gICAgICAgICAqL1xuICAgICAgICBwb3B1cEF1dG9XaWR0aDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLnmoTlr7npvZDmlrnlvI9cbiAgICAgICAgICovXG4gICAgICAgIHBvcHVwQWxpZ246IFByb3BUeXBlcy5vbmVPZihbJ2ZvbGxvdycsICdvdXRzaWRlJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC6Ieq5a6a5LmJIHByb3BzXG4gICAgICAgICAqL1xuICAgICAgICBwb3B1cFByb3BzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuZnVuY10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55Ye65a2Q6I+c5Y2V6Ieq5a6a5LmJIGNsYXNzTmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgcG9wdXBDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlh7rlrZDoj5zljZXoh6rlrprkuYkgc3R5bGVcbiAgICAgICAgICovXG4gICAgICAgIHBvcHVwU3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvZPliY3pgInkuK3oj5zljZXpobnnmoQga2V5IOWAvFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0ZWRLZXlzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYXJyYXldKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIneWni+mAieS4reiPnOWNlemhueeahCBrZXkg5YC8XG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0U2VsZWN0ZWRLZXlzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYXJyYXldKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmAieS4reaIluWPlua2iOmAieS4reiPnOWNlemhueinpuWPkeeahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZEtleXMg6YCJ5Lit55qE5omA5pyJ6I+c5Y2V6aG555qE5YC8XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIOmAieS4reaIluWPlua2iOmAieS4reeahOiPnOWNlemhuVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXh0cmEg6aKd5aSW5Y+C5pWwXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXh0cmEuc2VsZWN0IOaYr+WQpuaYr+mAieS4rVxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBleHRyYS5rZXkg6I+c5Y2V6aG555qEIGtleVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXh0cmEubGFiZWwg6I+c5Y2V6aG555qE5paH5pysXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGV4dHJhLmtleVBhdGgg6I+c5Y2V6aG5IGtleSDnmoTot6/lvoRcbiAgICAgICAgICovXG4gICAgICAgIG9uU2VsZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmAieS4reaooeW8j++8jOWNlemAiei/mOaYr+WkmumAie+8jOm7mOiupOaXoOWAvO+8jOS4jeWPr+mAiVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0TW9kZTogUHJvcFR5cGVzLm9uZU9mKFsnc2luZ2xlJywgJ211bHRpcGxlJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5Y+q6IO96YCJ5oup56ys5LiA5bGC6I+c5Y2V6aG577yI5LiN6IO96YCJ5oup5a2Q6I+c5Y2V5Lit55qE6I+c5Y2V6aG577yJXG4gICAgICAgICAqL1xuICAgICAgICBzaGFsbG93U2VsZWN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuaYvuekuumAieS4reWbvuagh++8jOWmguaenOiuvue9ruS4uiBmYWxzZSDpnIDphY3lkIjphY3nva7lubPlj7Dorr7nva7pgInkuK3ml7bnmoTog4zmma/oibLku6XnpLrljLrliIZcbiAgICAgICAgICovXG4gICAgICAgIGhhc1NlbGVjdGVkSWNvbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGxhYmVsVG9nZ2xlQ2hlY2tlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoj5zljZXnrKzkuIDlsYLlsZXnpLrmlrnlkJFcbiAgICAgICAgICovXG4gICAgICAgIGRpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsndmVyJywgJ2hveiddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaoquWQkeiPnOWNleadoSBpdGVtIOWSjCBmb290ZXIg55qE5a+56b2Q5pa55ZCR77yM5ZyoIGRpcmVjdGlvbiDorr7nva7kuLogJ2hveicg5bm25LiUIGhlYWRlciDlrZjlnKjml7bnlJ/mlYhcbiAgICAgICAgICovXG4gICAgICAgIGhvekFsaWduOiBQcm9wVHlwZXMub25lT2YoWydsZWZ0JywgJ3JpZ2h0J10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ6I+c5Y2V5aS06YOoXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXI6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ6I+c5Y2V5bC+6YOoXG4gICAgICAgICAqL1xuICAgICAgICBmb290ZXI6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm6Ieq5Yqo6I635b6X54Sm54K5XG4gICAgICAgICAqL1xuICAgICAgICBhdXRvRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5b2T5YmN6I635b6X54Sm54K555qE5a2Q6I+c5Y2V5oiW6I+c5Y2V6aG5IGtleSDlgLxcbiAgICAgICAgICovXG4gICAgICAgIGZvY3VzZWRLZXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGZvY3VzYWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIG9uSXRlbUZvY3VzOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25CbHVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25JdGVtS2V5RG93bjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGV4cGFuZEFuaW1hdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGl0ZW1DbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmdcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgICAgICBwdXJlOiBmYWxzZSxcbiAgICAgICAgZGVmYXVsdE9wZW5LZXlzOiBbXSxcbiAgICAgICAgZGVmYXVsdE9wZW5BbGw6IGZhbHNlLFxuICAgICAgICBvbk9wZW46IG5vb3AsXG4gICAgICAgIG1vZGU6ICdpbmxpbmUnLFxuICAgICAgICB0cmlnZ2VyVHlwZTogJ2NsaWNrJyxcbiAgICAgICAgb3Blbk1vZGU6ICdtdWx0aXBsZScsXG4gICAgICAgIGlubGluZUluZGVudDogMjAsXG4gICAgICAgIGlubGluZUFycm93RGlyZWN0aW9uOiAnZG93bicsXG4gICAgICAgIHBvcHVwQXV0b1dpZHRoOiBmYWxzZSxcbiAgICAgICAgcG9wdXBBbGlnbjogJ2ZvbGxvdycsXG4gICAgICAgIHBvcHVwUHJvcHM6IHt9LFxuICAgICAgICBkZWZhdWx0U2VsZWN0ZWRLZXlzOiBbXSxcbiAgICAgICAgb25TZWxlY3Q6IG5vb3AsXG4gICAgICAgIHNoYWxsb3dTZWxlY3Q6IGZhbHNlLFxuICAgICAgICBoYXNTZWxlY3RlZEljb246IHRydWUsXG4gICAgICAgIGxhYmVsVG9nZ2xlQ2hlY2tlZDogdHJ1ZSxcbiAgICAgICAgZGlyZWN0aW9uOiAndmVyJyxcbiAgICAgICAgaG96QWxpZ246ICdsZWZ0JyxcbiAgICAgICAgYXV0b0ZvY3VzOiBmYWxzZSxcbiAgICAgICAgZm9jdXNhYmxlOiB0cnVlLFxuICAgICAgICBvbkl0ZW1Gb2N1czogbm9vcCxcbiAgICAgICAgb25JdGVtS2V5RG93bjogbm9vcCxcbiAgICAgICAgb25JdGVtQ2xpY2s6IG5vb3AsXG4gICAgICAgIGV4cGFuZEFuaW1hdGlvbjogdHJ1ZVxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgc2VsZWN0ZWRLZXlzLCBkZWZhdWx0U2VsZWN0ZWRLZXlzLCBmb2N1c2VkS2V5LCBmb2N1c2FibGUsIGF1dG9Gb2N1cyB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICB0aGlzLm5ld0NoaWxkcmVuID0gdGhpcy5nZXROZXdDaGlsZHJlbihjaGlsZHJlbik7XG5cbiAgICAgICAgaWYgKGZvY3VzYWJsZSkge1xuICAgICAgICAgICAgdGhpcy50YWJiYWJsZUtleSA9IHRoaXMuZ2V0Rmlyc3RBdmFsaWFibGVsQ2hpbGRLZXkoJzAnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgb3BlbktleXM6IHRoaXMuZ2V0SW5pdE9wZW5LZXlzKHByb3BzKSxcbiAgICAgICAgICAgIHNlbGVjdGVkS2V5czogdGhpcy5ub3JtYWxpemVUb0FycmF5KHNlbGVjdGVkS2V5cyB8fCBkZWZhdWx0U2VsZWN0ZWRLZXlzKSxcbiAgICAgICAgICAgIGZvY3VzZWRLZXk6ICdmb2N1c2VkS2V5JyBpbiB0aGlzLnByb3BzID8gZm9jdXNlZEtleSA6IChmb2N1c2FibGUgJiYgYXV0b0ZvY3VzID8gdGhpcy50YWJiYWJsZUtleSA6IG51bGwpXG4gICAgICAgIH07XG5cbiAgICAgICAgYmluZEN0eCh0aGlzLCBbJ2hhbmRsZU9wZW4nLCAnaGFuZGxlU2VsZWN0JywgJ2hhbmRsZUl0ZW1DbGljaycsICdoYW5kbGVJdGVtS2V5RG93bicsICdvbkJsdXInXSk7XG5cbiAgICAgICAgdGhpcy5wb3B1cE5vZGVzID0gW107XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMubWVudU5vZGUgPSBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHt9O1xuXG4gICAgICAgIGlmICgnb3BlbktleXMnIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgc3RhdGUub3BlbktleXMgPSB0aGlzLm5vcm1hbGl6ZVRvQXJyYXkobmV4dFByb3BzLm9wZW5LZXlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ3NlbGVjdGVkS2V5cycgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgICAgICBzdGF0ZS5zZWxlY3RlZEtleXMgPSB0aGlzLm5vcm1hbGl6ZVRvQXJyYXkobmV4dFByb3BzLnNlbGVjdGVkS2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdmb2N1c2VkS2V5JyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIHN0YXRlLmZvY3VzZWRLZXkgPSBuZXh0UHJvcHMuZm9jdXNlZEtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhzdGF0ZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgICAgIHRoaXMubmV3Q2hpbGRyZW4gPSB0aGlzLmdldE5ld0NoaWxkcmVuKG5leHRQcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmZvY3VzYWJsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGFiYmFibGVLZXkgaW4gdGhpcy5rMm4pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5mb2N1c2VkS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFiYmFibGVLZXkgPSB0aGlzLnN0YXRlLmZvY3VzZWRLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhYmJhYmxlS2V5ID0gdGhpcy5nZXRGaXJzdEF2YWxpYWJsZWxDaGlsZEtleSgnMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25CbHVyKGUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBmb2N1c2VkS2V5OiAnJ1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnByb3BzLm9uQmx1ciAmJiB0aGlzLnByb3BzLm9uQmx1cihlKTtcbiAgICB9XG5cbiAgICBnZXRJbml0T3BlbktleXMocHJvcHMpIHtcbiAgICAgICAgbGV0IGluaXRPcGVuS2V5cztcblxuICAgICAgICBjb25zdCB7IG9wZW5LZXlzLCBkZWZhdWx0T3BlbktleXMsIGRlZmF1bHRPcGVuQWxsLCBtb2RlLCBvcGVuTW9kZSB9ID0gcHJvcHM7XG4gICAgICAgIGlmIChvcGVuS2V5cykge1xuICAgICAgICAgICAgaW5pdE9wZW5LZXlzID0gb3BlbktleXM7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVmYXVsdE9wZW5BbGwgJiYgbW9kZSA9PT0gJ2lubGluZScgJiYgb3Blbk1vZGUgPT09ICdtdWx0aXBsZScpIHtcbiAgICAgICAgICAgIGluaXRPcGVuS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuazJuKS5maWx0ZXIoa2V5ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5rMm5ba2V5XS50eXBlID09PSAnc3VibWVudSc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluaXRPcGVuS2V5cyA9IGRlZmF1bHRPcGVuS2V5cztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZVRvQXJyYXkoaW5pdE9wZW5LZXlzKTtcbiAgICB9XG5cbiAgICBnZXROZXdDaGlsZHJlbihjaGlsZHJlbikge1xuICAgICAgICB0aGlzLmsybiA9IHt9O1xuICAgICAgICB0aGlzLnAybiA9IHt9O1xuICAgICAgICBjb25zdCBsb29wID0gKGNoaWxkcmVuLCBwb3NQcmVmaXgsIGluZGV4V3JhcHBlciA9IHsgaW5kZXg6IDAgfSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIENoaWxkcmVuLm1hcChjaGlsZHJlbiwgY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCAmJiB0eXBlb2YgY2hpbGQudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiAoJ21lbnVDaGlsZFR5cGUnIGluIGNoaWxkLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdDaGlsZDtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9zO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IHsgcm9vdDogdGhpcyB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChbJ2l0ZW0nLCAnc3VibWVudScsICdncm91cCddLmluZGV4T2YoY2hpbGQudHlwZS5tZW51Q2hpbGRUeXBlKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBgJHtwb3NQcmVmaXh9LSR7aW5kZXhXcmFwcGVyLmluZGV4Kyt9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHR5cGVvZiBjaGlsZC5rZXkgPT09ICdzdHJpbmcnID8gY2hpbGQua2V5IDogcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGV2ZWwgPSBwb3Muc3BsaXQoJy0nKS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rMm5ba2V5XSA9IHRoaXMucDJuW3Bvc10gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBjaGlsZC50eXBlLm1lbnVDaGlsZFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGNoaWxkLnByb3BzLmRpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBjaGlsZC5wcm9wcy5sYWJlbCB8fCBjaGlsZC5wcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuX2tleSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmxldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5ncm91cEluZGVudCA9IGNoaWxkLnR5cGUubWVudUNoaWxkVHlwZSA9PT0gJ2dyb3VwJyA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGlsZC50eXBlLm1lbnVDaGlsZFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N1Ym1lbnUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gY2xvbmVFbGVtZW50KGNoaWxkLCBwcm9wcywgbG9vcChjaGlsZC5wcm9wcy5jaGlsZHJlbiwgcG9zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdncm91cCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBjbG9uZUVsZW1lbnQoY2hpbGQsIHByb3BzLCBsb29wKGNoaWxkLnByb3BzLmNoaWxkcmVuLCBwb3NQcmVmaXgsIGluZGV4V3JhcHBlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaXRlbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkaXZpZGVyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNsb25lRWxlbWVudChjaGlsZCwgcHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBsb29wKGNoaWxkcmVuLCAnMCcpO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZVRvQXJyYXkoaXRlbXMpIHtcbiAgICAgICAgaWYgKGl0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2l0ZW1zXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpc1NpYmxpbmcoY3VycmVudFBvcywgdGFyZ2V0UG9zKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnROdW1zID0gY3VycmVudFBvcy5zcGxpdCgnLScpLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0TnVtcyA9IHRhcmdldFBvcy5zcGxpdCgnLScpLnNsaWNlKDAsIC0xKTtcblxuICAgICAgICByZXR1cm4gY3VycmVudE51bXMubGVuZ3RoID09PSB0YXJnZXROdW1zLmxlbmd0aCAmJiBjdXJyZW50TnVtcy5ldmVyeSgobnVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG51bSA9PT0gdGFyZ2V0TnVtc1tpbmRleF07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlzQW5jZXN0b3IoY3VycmVudFBvcywgdGFyZ2V0UG9zKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnROdW1zID0gY3VycmVudFBvcy5zcGxpdCgnLScpO1xuICAgICAgICBjb25zdCB0YXJnZXROdW1zID0gdGFyZ2V0UG9zLnNwbGl0KCctJyk7XG5cbiAgICAgICAgcmV0dXJuIGN1cnJlbnROdW1zLmxlbmd0aCA+IHRhcmdldE51bXMubGVuZ3RoICYmIHRhcmdldE51bXMuZXZlcnkoKG51bSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBudW0gPT09IGN1cnJlbnROdW1zW2luZGV4XTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaGFuZGxlT3BlbihrZXksIG9wZW4sIHRyaWdnZXJUeXBlLCBlKSB7XG4gICAgICAgIGxldCBuZXdPcGVuS2V5cztcblxuICAgICAgICBjb25zdCB7IG1vZGUsIG9wZW5Nb2RlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IG9wZW5LZXlzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCBpbmRleCA9IG9wZW5LZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgICAgaWYgKG9wZW4gJiYgaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICAgICBpZiAob3Blbk1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld09wZW5LZXlzID0gb3BlbktleXMuZmlsdGVyKGsgPT4gIXRoaXMuaXNTaWJsaW5nKHRoaXMuazJuW2tleV0ucG9zLCB0aGlzLmsybltrXS5wb3MpKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3T3BlbktleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld09wZW5LZXlzID0gb3BlbktleXMuY29uY2F0KGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdPcGVuS2V5cyA9IG9wZW5LZXlzLmZpbHRlcihrID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNBbmNlc3Rvcih0aGlzLmsybltrZXldLnBvcywgdGhpcy5rMm5ba10ucG9zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBuZXdPcGVuS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIW9wZW4gJiYgaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgbmV3T3BlbktleXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIC4uLm9wZW5LZXlzLnNsaWNlKDAsIGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgLi4ub3BlbktleXMuc2xpY2UoaW5kZXggKyAxKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRyaWdnZXJUeXBlID09PSAnZG9jQ2xpY2snKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBvcHVwTm9kZXMuY29uY2F0KHRoaXMubWVudU5vZGUpLnNvbWUobm9kZSA9PiBub2RlLmNvbnRhaW5zKGUudGFyZ2V0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3T3BlbktleXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld09wZW5LZXlzID0gb3BlbktleXMuZmlsdGVyKGsgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gayAhPT0ga2V5ICYmICF0aGlzLmlzQW5jZXN0b3IodGhpcy5rMm5ba10ucG9zLCB0aGlzLmsybltrZXldLnBvcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3T3BlbktleXMpIHtcbiAgICAgICAgICAgIGlmICghKCdvcGVuS2V5cycgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbktleXM6IG5ld09wZW5LZXlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucHJvcHMub25PcGVuKG5ld09wZW5LZXlzLCB7XG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIG9wZW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0UGF0aChrZXkpIHtcbiAgICAgICAgY29uc3Qga2V5UGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBsYWJlbFBhdGggPSBbXTtcblxuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLmsybltrZXldLnBvcztcbiAgICAgICAgY29uc3QgbnVtcyA9IHBvcy5zcGxpdCgnLScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG51bXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnROdW1zID0gbnVtcy5zbGljZSgwLCBpICsgMSk7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRQb3MgPSBwYXJlbnROdW1zLmpvaW4oJy0nKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucDJuW3BhcmVudFBvc107XG4gICAgICAgICAgICBrZXlQYXRoLnB1c2gocGFyZW50LmtleSk7XG4gICAgICAgICAgICBsYWJlbFBhdGgucHVzaChwYXJlbnQubGFiZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICBsYWJlbFBhdGhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBoYW5kbGVTZWxlY3Qoa2V5LCBzZWxlY3QsIG1lbnVJdGVtKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuazJuW2tleV0ucG9zO1xuICAgICAgICBjb25zdCBsZXZlbCA9IHBvcy5zcGxpdCgnLScpLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnNoYWxsb3dTZWxlY3QgJiYgbGV2ZWwgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbmV3U2VsZWN0ZWRLZXlzO1xuXG4gICAgICAgIGNvbnN0IHsgc2VsZWN0TW9kZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBzZWxlY3RlZEtleXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc2VsZWN0ZWRLZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgICAgaWYgKHNlbGVjdCAmJiBpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RNb2RlID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgICAgIG5ld1NlbGVjdGVkS2V5cyA9IFtrZXldO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RNb2RlID09PSAnbXVsdGlwbGUnKSB7XG4gICAgICAgICAgICAgICAgbmV3U2VsZWN0ZWRLZXlzID0gc2VsZWN0ZWRLZXlzLmNvbmNhdChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFzZWxlY3QgJiYgaW5kZXggPiAtMSAmJiBzZWxlY3RNb2RlID09PSAnbXVsdGlwbGUnKSB7XG4gICAgICAgICAgICBuZXdTZWxlY3RlZEtleXMgPSBbXG4gICAgICAgICAgICAgICAgLi4uc2VsZWN0ZWRLZXlzLnNsaWNlKDAsIGluZGV4KSxcbiAgICAgICAgICAgICAgICAuLi5zZWxlY3RlZEtleXMuc2xpY2UoaW5kZXggKyAxKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdTZWxlY3RlZEtleXMpIHtcbiAgICAgICAgICAgIGlmICghKCdzZWxlY3RlZEtleXMnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkS2V5czogbmV3U2VsZWN0ZWRLZXlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucHJvcHMub25TZWxlY3QobmV3U2VsZWN0ZWRLZXlzLCBtZW51SXRlbSwge1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBzZWxlY3QsXG4gICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuazJuW2tleV0ubGFiZWwsXG4gICAgICAgICAgICAgICAgLi4udGhpcy5nZXRQYXRoKGtleSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlSXRlbUNsaWNrKGtleSwgaXRlbSwgZSkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5mb2N1c2FibGUpIHtcbiAgICAgICAgICAgIGlmICghKCdmb2N1c2VkS2V5JyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBmb2N1c2VkS2V5OiBrZXlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkl0ZW1Gb2N1cyhrZXksIGl0ZW0sIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW0ucHJvcHMudHlwZSA9PT0gJ2l0ZW0nKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5wcm9wcy5wYXJlbnRNb2RlID09PSAncG9wdXAnICYmIHRoaXMuc3RhdGUub3BlbktleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoJ29wZW5LZXlzJyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5LZXlzOiBbXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uT3BlbihbXSwge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IHRoaXMuc3RhdGUub3BlbktleXMuc29ydCgocHJldktleSwgbmV4dEtleSkgPT4gdGhpcy5rMm5bbmV4dEtleV0ucG9zLnNwbGl0KCctJykubGVuZ3RoIC0gdGhpcy5rMm5bcHJldktleV0ucG9zLnNwbGl0KCctJykubGVuZ3RoKVswXSxcbiAgICAgICAgICAgICAgICAgICAgb3BlbjogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkl0ZW1DbGljayhrZXksIGl0ZW0sIGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNBdmFpbGFibGVQb3MocmVmUG9zLCB0YXJnZXRQb3MpIHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBkaXNhYmxlZCB9ID0gdGhpcy5wMm5bdGFyZ2V0UG9zXTtcblxuICAgICAgICByZXR1cm4gdGhpcy5pc1NpYmxpbmcocmVmUG9zLCB0YXJnZXRQb3MpICYmXG4gICAgICAgICAgICAodHlwZSA9PT0gJ2l0ZW0nICYmICFkaXNhYmxlZCB8fCB0eXBlID09PSAnc3VibWVudScpO1xuICAgIH1cblxuICAgIGdldEF2YWlsYWJsZUtleShwb3MsIHByZXYpIHtcbiAgICAgICAgY29uc3QgcHMgPSBPYmplY3Qua2V5cyh0aGlzLnAybikuZmlsdGVyKHAgPT4gdGhpcy5pc0F2YWlsYWJsZVBvcyhwb3MsIHApKTtcbiAgICAgICAgaWYgKHBzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcHMuaW5kZXhPZihwb3MpO1xuICAgICAgICAgICAgbGV0IHRhcmdldEluZGV4O1xuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRJbmRleCA9IGluZGV4ID09PSAwID8gcHMubGVuZ3RoIC0gMSA6IGluZGV4IC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SW5kZXggPSBpbmRleCA9PT0gcHMubGVuZ3RoIC0gMSA/IDAgOiBpbmRleCArIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnAybltwc1t0YXJnZXRJbmRleF1dLmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGdldEZpcnN0QXZhbGlhYmxlbENoaWxkS2V5KHBhcmVudFBvcykge1xuICAgICAgICBjb25zdCBwb3MgPSBPYmplY3Qua2V5cyh0aGlzLnAybikuZmluZChwID0+IHRoaXMuaXNBdmFpbGFibGVQb3MoYCR7cGFyZW50UG9zfS0wYCwgcCkpO1xuICAgICAgICByZXR1cm4gcG9zID8gdGhpcy5wMm5bcG9zXS5rZXkgOiBudWxsO1xuICAgIH1cblxuICAgIGdldFBhcmVudEtleShwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucDJuW3Bvcy5zbGljZSgwLCBwb3MubGVuZ3RoIC0gMildLmtleTtcbiAgICB9XG5cbiAgICBoYW5kbGVJdGVtS2V5RG93bihrZXksIHR5cGUsIGl0ZW0sIGUpIHtcbiAgICAgICAgaWYgKFtcbiAgICAgICAgICAgIEtFWUNPREUuVVAsIEtFWUNPREUuRE9XTiwgS0VZQ09ERS5SSUdIVCwgS0VZQ09ERS5MRUZULFxuICAgICAgICAgICAgS0VZQ09ERS5FTlRFUiwgS0VZQ09ERS5FU0MsIEtFWUNPREUuU1BBQ0VcbiAgICAgICAgXS5pbmRleE9mKGUua2V5Q29kZSkgPiAtMSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmb2N1c2VkS2V5ID0gdGhpcy5zdGF0ZS5mb2N1c2VkS2V5O1xuXG4gICAgICAgIGNvbnN0IHsgZGlyZWN0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLmsybltrZXldLnBvcztcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBwb3Muc3BsaXQoJy0nKS5sZW5ndGggLSAxO1xuICAgICAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgICAgICAgY2FzZSBLRVlDT0RFLlVQOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXZhbGlhYmxlS2V5ID0gdGhpcy5nZXRBdmFpbGFibGVLZXkocG9zLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoYXZhbGlhYmxlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzZWRLZXkgPSBhdmFsaWFibGVLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBLRVlDT0RFLkRPV046IHtcbiAgICAgICAgICAgICAgICBsZXQgYXZhbGlhYmxlS2V5O1xuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdob3onICYmIGxldmVsID09PSAxICYmIHR5cGUgPT09ICdzdWJtZW51Jykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU9wZW4oa2V5LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYXZhbGlhYmxlS2V5ID0gdGhpcy5nZXRGaXJzdEF2YWxpYWJsZWxDaGlsZEtleShwb3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF2YWxpYWJsZUtleSA9IHRoaXMuZ2V0QXZhaWxhYmxlS2V5KHBvcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXZhbGlhYmxlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzZWRLZXkgPSBhdmFsaWFibGVLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBLRVlDT0RFLlJJR0hUOiB7XG4gICAgICAgICAgICAgICAgbGV0IGF2YWxpYWJsZUtleTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnaG96JyAmJiBsZXZlbCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhdmFsaWFibGVLZXkgPSB0aGlzLmdldEF2YWlsYWJsZUtleShwb3MsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdWJtZW51Jykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU9wZW4oa2V5LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYXZhbGlhYmxlS2V5ID0gdGhpcy5nZXRGaXJzdEF2YWxpYWJsZWxDaGlsZEtleShwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXZhbGlhYmxlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzZWRLZXkgPSBhdmFsaWFibGVLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBLRVlDT0RFLkVOVEVSOiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzdWJtZW51Jykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU9wZW4oa2V5LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXZhbGlhYmxlS2V5ID0gdGhpcy5nZXRGaXJzdEF2YWxpYWJsZWxDaGlsZEtleShwb3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXZhbGlhYmxlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c2VkS2V5ID0gYXZhbGlhYmxlS2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBLRVlDT0RFLkxFRlQ6IHtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnaG96JyAmJiBsZXZlbCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdmFsaWFibGVLZXkgPSB0aGlzLmdldEF2YWlsYWJsZUtleShwb3MsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXZhbGlhYmxlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c2VkS2V5ID0gYXZhbGlhYmxlS2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZXZlbCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gdGhpcy5nZXRQYXJlbnRLZXkocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVPcGVuKHBhcmVudEtleSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBmb2N1c2VkS2V5ID0gcGFyZW50S2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgS0VZQ09ERS5FU0M6XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRLZXkgPSB0aGlzLmdldFBhcmVudEtleShwb3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU9wZW4ocGFyZW50S2V5LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzZWRLZXkgPSBwYXJlbnRLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEtFWUNPREUuVEFCOlxuICAgICAgICAgICAgICAgIGZvY3VzZWRLZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb2N1c2VkS2V5ICE9PSB0aGlzLnN0YXRlLmZvY3VzZWRLZXkpIHtcbiAgICAgICAgICAgIGlmICghKCdmb2N1c2VkS2V5JyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBmb2N1c2VkS2V5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucHJvcHMub25JdGVtS2V5RG93bihmb2N1c2VkS2V5LCBpdGVtLCBlKTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25JdGVtRm9jdXMoZm9jdXNlZEtleSwgZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBjbGFzc05hbWUsIGRpcmVjdGlvbiwgaG96QWxpZ24sIGhlYWRlciwgZm9vdGVyLCBzZWxlY3RNb2RlLCBydGwgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IG90aGVycyA9IHBpY2tPdGhlcnMoT2JqZWN0LmtleXMoTWVudS5wcm9wVHlwZXMpLCB0aGlzLnByb3BzKTtcblxuICAgICAgICBjb25zdCBuZXdDbGFzc05hbWUgPSBjeCh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fW1lbnVgXTogdHJ1ZSxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9dmVyYF06IGRpcmVjdGlvbiA9PT0gJ3ZlcicsXG4gICAgICAgICAgICBbYCR7cHJlZml4fWhvemBdOiBkaXJlY3Rpb24gPT09ICdob3onLFxuICAgICAgICAgICAgW2NsYXNzTmFtZV06ICEhY2xhc3NOYW1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJvbGUgPSBkaXJlY3Rpb24gPT09ICdob3onID8gJ21lbnViYXInIDogJ21lbnUnO1xuICAgICAgICBjb25zdCBoZWFkZXJFbGVtZW50ID0gaGVhZGVyID8gPGxpIGNsYXNzTmFtZT17YCR7cHJlZml4fW1lbnUtaGVhZGVyYH0+e2hlYWRlcn08L2xpPiA6IG51bGw7XG4gICAgICAgIGNvbnN0IGl0ZW1zRWxlbWVudCA9IGhlYWRlciB8fCBmb290ZXIgPyAgPHVsIGNsYXNzTmFtZT17YCR7cHJlZml4fW1lbnUtY29udGVudGB9Pnt0aGlzLm5ld0NoaWxkcmVufTwvdWw+IDogdGhpcy5uZXdDaGlsZHJlbjtcbiAgICAgICAgY29uc3QgZm9vdGVyRWxlbWVudCA9IGZvb3RlciA/IDxsaSBjbGFzc05hbWU9e2Ake3ByZWZpeH1tZW51LWZvb3RlcmB9Pntmb290ZXJ9PC9saT4gOiBudWxsO1xuICAgICAgICBjb25zdCBzaG91bGRXcmFwSXRlbXNBbmRGb290ZXIgPSBob3pBbGlnbiA9PT0gJ3JpZ2h0JyAmJiAhIWhlYWRlcjtcblxuICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgICBvdGhlcnMuZGlyID0gJ3J0bCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPHVsIHJvbGU9e3JvbGV9IG9uQmx1cj17dGhpcy5vbkJsdXJ9IGNsYXNzTmFtZT17bmV3Q2xhc3NOYW1lfSBvbktleURvd249e3RoaXMuaGFuZGxlRW50ZXJ9IGFyaWEtbXVsdGlzZWxlY3RhYmxlPXtzZWxlY3RNb2RlID09PSAnbXVsdGlwbGUnfSB7Li4ub3RoZXJzfT5cbiAgICAgICAgICAgICAgICB7aGVhZGVyRWxlbWVudH1cbiAgICAgICAgICAgICAgICB7c2hvdWxkV3JhcEl0ZW1zQW5kRm9vdGVyID9cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH1tZW51LWhvei1yaWdodGB9PlxuICAgICAgICAgICAgICAgICAgICAgICAge2l0ZW1zRWxlbWVudH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHtmb290ZXJFbGVtZW50fVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gOiBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHshc2hvdWxkV3JhcEl0ZW1zQW5kRm9vdGVyID8gaXRlbXNFbGVtZW50IDogbnVsbH1cbiAgICAgICAgICAgICAgICB7IXNob3VsZFdyYXBJdGVtc0FuZEZvb3RlciA/IGZvb3RlckVsZW1lbnQgOiBudWxsfVxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWVudS92aWV3L21lbnUuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgVHJhbnNpdGlvbkdyb3VwIH0gZnJvbSAncmVhY3QtdHJhbnNpdGlvbi1ncm91cCc7XG5pbXBvcnQgQW5pbWF0ZUNoaWxkIGZyb20gJy4vY2hpbGQnO1xuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5jb25zdCBGaXJzdENoaWxkID0gcHJvcHMgPT4ge1xuICAgIGNvbnN0IGNoaWxkcmVuQXJyYXkgPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KHByb3BzLmNoaWxkcmVuKTtcbiAgICByZXR1cm4gY2hpbGRyZW5BcnJheVswXSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBBbmltYXRlXG4gKi9cbmNsYXNzIEFuaW1hdGUgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliqjnlLsgY2xhc3NOYW1lXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRpb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWtkOWFg+e0oOesrOS4gOasoeaMgui9veaXtuaYr+WQpuaJp+ihjOWKqOeUu1xuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0aW9uQXBwZWFyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWMheijueWtkOWFg+e0oOeahOagh+etvlxuICAgICAgICAgKi9cbiAgICAgICAgY29tcG9uZW50OiBQcm9wVHlwZXMuYW55LFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5Y+q5pyJ5Y2V5Liq5a2Q5YWD57Sg77yM5aaC5p6c5pyJ5aSa5Liq5a2Q5YWD57Sg77yM6K+36K6+572u5Li6IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGVNb2RlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWtkOWFg+e0oFxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5lbGVtZW50LCBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuZWxlbWVudCldKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaJp+ihjOesrOS4gOasoeaMgui9veWKqOeUu+WJjeinpuWPkeeahOWbnuiwg+WHveaVsFxuICAgICAgICAgKi9cbiAgICAgICAgYmVmb3JlQXBwZWFyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaJp+ihjOesrOS4gOasoeaMgui9veWKqOeUu++8jOa3u+WKoCB4eHgtYXBwZWFyLWFjdGl2ZSDnsbvlkI3lkI7op6blj5HnmoTlm57osIPlh73mlbBcbiAgICAgICAgICogIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgXGLmiafooYzliqjnlLvnmoQgZG9tIOWFg+e0oFxuICAgICAgICAgKi9cbiAgICAgICAgb25BcHBlYXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5omn6KGM5a6M56ys5LiA5qyh5oyC6L295Yqo55S75ZCO6Kem5Y+R55qE5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgXGLmiafooYzliqjnlLvnmoQgZG9tIOWFg+e0oFxuICAgICAgICAgKi9cbiAgICAgICAgYWZ0ZXJBcHBlYXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5omn6KGM6L+b5Zy65Yqo55S75YmN6Kem5Y+R55qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgXGLmiafooYzliqjnlLvnmoQgZG9tIOWFg+e0oFxuICAgICAgICAgKi9cbiAgICAgICAgYmVmb3JlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5omn6KGM6L+b5Zy65Yqo55S777yM5re75YqgIHh4eC1lbnRlci1hY3RpdmUg57G75ZCN5ZCO6Kem5Y+R55qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgXGLmiafooYzliqjnlLvnmoQgZG9tIOWFg+e0oFxuICAgICAgICAgKi9cbiAgICAgICAgb25FbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmiafooYzlrozov5vlnLrliqjnlLvlkI7op6blj5HnmoTlm57osIPlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBcYuaJp+ihjOWKqOeUu+eahCBkb20g5YWD57SgXG4gICAgICAgICAqL1xuICAgICAgICBhZnRlckVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaJp+ihjOemu+WcuuWKqOeUu+WJjeinpuWPkeeahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIFxi5omn6KGM5Yqo55S755qEIGRvbSDlhYPntKBcbiAgICAgICAgICovXG4gICAgICAgIGJlZm9yZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaJp+ihjOemu+WcuuWKqOeUu++8jOa3u+WKoCB4eHgtbGVhdmUtYWN0aXZlIOexu+WQjeWQjuinpuWPkeeahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIFxi5omn6KGM5Yqo55S755qEIGRvbSDlhYPntKBcbiAgICAgICAgICovXG4gICAgICAgIG9uTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog5omn6KGM5a6M56a75Zy65Yqo55S75ZCO6Kem5Y+R55qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgXGLmiafooYzliqjnlLvnmoQgZG9tIOWFg+e0oFxuICAgICAgICAgKi9cbiAgICAgICAgYWZ0ZXJMZWF2ZTogUHJvcFR5cGVzLmZ1bmNcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgYW5pbWF0aW9uQXBwZWFyOiB0cnVlLFxuICAgICAgICBjb21wb25lbnQ6ICdkaXYnLFxuICAgICAgICBzaW5nbGVNb2RlOiB0cnVlLFxuICAgICAgICBiZWZvcmVBcHBlYXI6IG5vb3AsXG4gICAgICAgIG9uQXBwZWFyOiBub29wLFxuICAgICAgICBhZnRlckFwcGVhcjogbm9vcCxcbiAgICAgICAgYmVmb3JlRW50ZXI6IG5vb3AsXG4gICAgICAgIG9uRW50ZXI6IG5vb3AsXG4gICAgICAgIGFmdGVyRW50ZXI6IG5vb3AsXG4gICAgICAgIGJlZm9yZUxlYXZlOiBub29wLFxuICAgICAgICBvbkxlYXZlOiBub29wLFxuICAgICAgICBhZnRlckxlYXZlOiBub29wXG4gICAgfTtcblxuICAgIG5vcm1hbGl6ZU5hbWVzKG5hbWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFwcGVhcjogYCR7bmFtZXN9LWFwcGVhcmAsXG4gICAgICAgICAgICAgICAgYXBwZWFyQWN0aXZlOiBgJHtuYW1lc30tYXBwZWFyLWFjdGl2ZWAsXG4gICAgICAgICAgICAgICAgZW50ZXI6IGAke25hbWVzfS1lbnRlcmAsXG4gICAgICAgICAgICAgICAgZW50ZXJBY3RpdmU6IGAke25hbWVzfS1lbnRlci1hY3RpdmVgLFxuICAgICAgICAgICAgICAgIGxlYXZlOiBgJHtuYW1lc30tbGVhdmVgLFxuICAgICAgICAgICAgICAgIGxlYXZlQWN0aXZlOiBgJHtuYW1lc30tbGVhdmUtYWN0aXZlYFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5hbWVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhcHBlYXI6IG5hbWVzLmFwcGVhcixcbiAgICAgICAgICAgICAgICBhcHBlYXJBY3RpdmU6IGAke25hbWVzLmFwcGVhcn0tYWN0aXZlYCxcbiAgICAgICAgICAgICAgICBlbnRlcjogYCR7bmFtZXMuZW50ZXJ9YCxcbiAgICAgICAgICAgICAgICBlbnRlckFjdGl2ZTogYCR7bmFtZXMuZW50ZXJ9LWFjdGl2ZWAsXG4gICAgICAgICAgICAgICAgbGVhdmU6IGAke25hbWVzLmxlYXZlfWAsXG4gICAgICAgICAgICAgICAgbGVhdmVBY3RpdmU6IGAke25hbWVzLmxlYXZlfS1hY3RpdmVgLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbiwgY2hpbGRyZW4sIGFuaW1hdGlvbkFwcGVhciwgc2luZ2xlTW9kZSwgY29tcG9uZW50LFxuICAgICAgICAgICAgYmVmb3JlQXBwZWFyLCBvbkFwcGVhciwgYWZ0ZXJBcHBlYXIsXG4gICAgICAgICAgICBiZWZvcmVFbnRlciwgb25FbnRlciwgYWZ0ZXJFbnRlcixcbiAgICAgICAgICAgIGJlZm9yZUxlYXZlLCBvbkxlYXZlLCBhZnRlckxlYXZlLFxuICAgICAgICAgICAgLi4ub3RoZXJzXG4gICAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgICAgICAgY29uc3QgYW5pbWF0ZUNoaWxkcmVuID0gQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBjaGlsZCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxBbmltYXRlQ2hpbGQga2V5PXtjaGlsZC5rZXl9XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzPXt0aGlzLm5vcm1hbGl6ZU5hbWVzKGFuaW1hdGlvbil9XG4gICAgICAgICAgICAgICAgICAgIG9uQXBwZWFyPXtiZWZvcmVBcHBlYXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uQXBwZWFyaW5nPXtvbkFwcGVhcn1cbiAgICAgICAgICAgICAgICAgICAgb25BcHBlYXJlZD17YWZ0ZXJBcHBlYXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uRW50ZXI9e2JlZm9yZUVudGVyfVxuICAgICAgICAgICAgICAgICAgICBvbkVudGVyaW5nPXtvbkVudGVyfVxuICAgICAgICAgICAgICAgICAgICBvbkVudGVyZWQ9e2FmdGVyRW50ZXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uRXhpdD17YmVmb3JlTGVhdmV9XG4gICAgICAgICAgICAgICAgICAgIG9uRXhpdGluZz17b25MZWF2ZX1cbiAgICAgICAgICAgICAgICAgICAgb25FeGl0ZWQ9e2FmdGVyTGVhdmV9PlxuICAgICAgICAgICAgICAgICAgICB7Y2hpbGR9XG4gICAgICAgICAgICAgICAgPC9BbmltYXRlQ2hpbGQ+XG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPFRyYW5zaXRpb25Hcm91cCBhcHBlYXI9e2FuaW1hdGlvbkFwcGVhcn0gY29tcG9uZW50PXtzaW5nbGVNb2RlID8gRmlyc3RDaGlsZCA6IGNvbXBvbmVudH0gey4uLm90aGVyc30+XG4gICAgICAgICAgICAgICAge2FuaW1hdGVDaGlsZHJlbn1cbiAgICAgICAgICAgIDwvVHJhbnNpdGlvbkdyb3VwPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hbmltYXRlL2FuaW1hdGUuanN4IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfQ1NTVHJhbnNpdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vQ1NTVHJhbnNpdGlvblwiKSk7XG5cbnZhciBfUmVwbGFjZVRyYW5zaXRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1JlcGxhY2VUcmFuc2l0aW9uXCIpKTtcblxudmFyIF9UcmFuc2l0aW9uR3JvdXAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1RyYW5zaXRpb25Hcm91cFwiKSk7XG5cbnZhciBfVHJhbnNpdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vVHJhbnNpdGlvblwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBUcmFuc2l0aW9uOiBfVHJhbnNpdGlvbi5kZWZhdWx0LFxuICBUcmFuc2l0aW9uR3JvdXA6IF9UcmFuc2l0aW9uR3JvdXAuZGVmYXVsdCxcbiAgUmVwbGFjZVRyYW5zaXRpb246IF9SZXBsYWNlVHJhbnNpdGlvbi5kZWZhdWx0LFxuICBDU1NUcmFuc2l0aW9uOiBfQ1NTVHJhbnNpdGlvbi5kZWZhdWx0XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fcmVhY3QtdHJhbnNpdGlvbi1ncm91cEAyLjUuMkByZWFjdC10cmFuc2l0aW9uLWdyb3VwL2luZGV4LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLkVYSVRJTkcgPSBleHBvcnRzLkVOVEVSRUQgPSBleHBvcnRzLkVOVEVSSU5HID0gZXhwb3J0cy5FWElURUQgPSBleHBvcnRzLlVOTU9VTlRFRCA9IHZvaWQgMDtcblxudmFyIFByb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcblxudmFyIF9yZWFjdERvbSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0LWRvbVwiKSk7XG5cbnZhciBfcmVhY3RMaWZlY3ljbGVzQ29tcGF0ID0gcmVxdWlyZShcInJlYWN0LWxpZmVjeWNsZXMtY29tcGF0XCIpO1xuXG52YXIgX1Byb3BUeXBlcyA9IHJlcXVpcmUoXCIuL3V0aWxzL1Byb3BUeXBlc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVU5NT1VOVEVEID0gJ3VubW91bnRlZCc7XG5leHBvcnRzLlVOTU9VTlRFRCA9IFVOTU9VTlRFRDtcbnZhciBFWElURUQgPSAnZXhpdGVkJztcbmV4cG9ydHMuRVhJVEVEID0gRVhJVEVEO1xudmFyIEVOVEVSSU5HID0gJ2VudGVyaW5nJztcbmV4cG9ydHMuRU5URVJJTkcgPSBFTlRFUklORztcbnZhciBFTlRFUkVEID0gJ2VudGVyZWQnO1xuZXhwb3J0cy5FTlRFUkVEID0gRU5URVJFRDtcbnZhciBFWElUSU5HID0gJ2V4aXRpbmcnO1xuLyoqXG4gKiBUaGUgVHJhbnNpdGlvbiBjb21wb25lbnQgbGV0cyB5b3UgZGVzY3JpYmUgYSB0cmFuc2l0aW9uIGZyb20gb25lIGNvbXBvbmVudFxuICogc3RhdGUgdG8gYW5vdGhlciBfb3ZlciB0aW1lXyB3aXRoIGEgc2ltcGxlIGRlY2xhcmF0aXZlIEFQSS4gTW9zdCBjb21tb25seVxuICogaXQncyB1c2VkIHRvIGFuaW1hdGUgdGhlIG1vdW50aW5nIGFuZCB1bm1vdW50aW5nIG9mIGEgY29tcG9uZW50LCBidXQgY2FuIGFsc29cbiAqIGJlIHVzZWQgdG8gZGVzY3JpYmUgaW4tcGxhY2UgdHJhbnNpdGlvbiBzdGF0ZXMgYXMgd2VsbC5cbiAqXG4gKiBCeSBkZWZhdWx0IHRoZSBgVHJhbnNpdGlvbmAgY29tcG9uZW50IGRvZXMgbm90IGFsdGVyIHRoZSBiZWhhdmlvciBvZiB0aGVcbiAqIGNvbXBvbmVudCBpdCByZW5kZXJzLCBpdCBvbmx5IHRyYWNrcyBcImVudGVyXCIgYW5kIFwiZXhpdFwiIHN0YXRlcyBmb3IgdGhlIGNvbXBvbmVudHMuXG4gKiBJdCdzIHVwIHRvIHlvdSB0byBnaXZlIG1lYW5pbmcgYW5kIGVmZmVjdCB0byB0aG9zZSBzdGF0ZXMuIEZvciBleGFtcGxlIHdlIGNhblxuICogYWRkIHN0eWxlcyB0byBhIGNvbXBvbmVudCB3aGVuIGl0IGVudGVycyBvciBleGl0czpcbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCBUcmFuc2l0aW9uIGZyb20gJ3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvVHJhbnNpdGlvbic7XG4gKlxuICogY29uc3QgZHVyYXRpb24gPSAzMDA7XG4gKlxuICogY29uc3QgZGVmYXVsdFN0eWxlID0ge1xuICogICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke2R1cmF0aW9ufW1zIGVhc2UtaW4tb3V0YCxcbiAqICAgb3BhY2l0eTogMCxcbiAqIH1cbiAqXG4gKiBjb25zdCB0cmFuc2l0aW9uU3R5bGVzID0ge1xuICogICBlbnRlcmluZzogeyBvcGFjaXR5OiAwIH0sXG4gKiAgIGVudGVyZWQ6ICB7IG9wYWNpdHk6IDEgfSxcbiAqIH07XG4gKlxuICogY29uc3QgRmFkZSA9ICh7IGluOiBpblByb3AgfSkgPT4gKFxuICogICA8VHJhbnNpdGlvbiBpbj17aW5Qcm9wfSB0aW1lb3V0PXtkdXJhdGlvbn0+XG4gKiAgICAgeyhzdGF0ZSkgPT4gKFxuICogICAgICAgPGRpdiBzdHlsZT17e1xuICogICAgICAgICAuLi5kZWZhdWx0U3R5bGUsXG4gKiAgICAgICAgIC4uLnRyYW5zaXRpb25TdHlsZXNbc3RhdGVdXG4gKiAgICAgICB9fT5cbiAqICAgICAgICAgSSdtIGEgZmFkZSBUcmFuc2l0aW9uIVxuICogICAgICAgPC9kaXY+XG4gKiAgICAgKX1cbiAqICAgPC9UcmFuc2l0aW9uPlxuICogKTtcbiAqIGBgYFxuICpcbiAqIEFzIG5vdGVkIHRoZSBgVHJhbnNpdGlvbmAgY29tcG9uZW50IGRvZXNuJ3QgX2RvXyBhbnl0aGluZyBieSBpdHNlbGYgdG8gaXRzIGNoaWxkIGNvbXBvbmVudC5cbiAqIFdoYXQgaXQgZG9lcyBkbyBpcyB0cmFjayB0cmFuc2l0aW9uIHN0YXRlcyBvdmVyIHRpbWUgc28geW91IGNhbiB1cGRhdGUgdGhlXG4gKiBjb21wb25lbnQgKHN1Y2ggYXMgYnkgYWRkaW5nIHN0eWxlcyBvciBjbGFzc2VzKSB3aGVuIGl0IGNoYW5nZXMgc3RhdGVzLlxuICpcbiAqIFRoZXJlIGFyZSA0IG1haW4gc3RhdGVzIGEgVHJhbnNpdGlvbiBjYW4gYmUgaW46XG4gKiAgLSBgJ2VudGVyaW5nJ2BcbiAqICAtIGAnZW50ZXJlZCdgXG4gKiAgLSBgJ2V4aXRpbmcnYFxuICogIC0gYCdleGl0ZWQnYFxuICpcbiAqIFRyYW5zaXRpb24gc3RhdGUgaXMgdG9nZ2xlZCB2aWEgdGhlIGBpbmAgcHJvcC4gV2hlbiBgdHJ1ZWAgdGhlIGNvbXBvbmVudCBiZWdpbnMgdGhlXG4gKiBcIkVudGVyXCIgc3RhZ2UuIER1cmluZyB0aGlzIHN0YWdlLCB0aGUgY29tcG9uZW50IHdpbGwgc2hpZnQgZnJvbSBpdHMgY3VycmVudCB0cmFuc2l0aW9uIHN0YXRlLFxuICogdG8gYCdlbnRlcmluZydgIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIHRyYW5zaXRpb24gYW5kIHRoZW4gdG8gdGhlIGAnZW50ZXJlZCdgIHN0YWdlIG9uY2VcbiAqIGl0J3MgY29tcGxldGUuIExldCdzIHRha2UgdGhlIGZvbGxvd2luZyBleGFtcGxlOlxuICpcbiAqIGBgYGpzeFxuICogc3RhdGUgPSB7IGluOiBmYWxzZSB9O1xuICpcbiAqIHRvZ2dsZUVudGVyU3RhdGUgPSAoKSA9PiB7XG4gKiAgIHRoaXMuc2V0U3RhdGUoeyBpbjogdHJ1ZSB9KTtcbiAqIH1cbiAqXG4gKiByZW5kZXIoKSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGRpdj5cbiAqICAgICAgIDxUcmFuc2l0aW9uIGluPXt0aGlzLnN0YXRlLmlufSB0aW1lb3V0PXs1MDB9IC8+XG4gKiAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e3RoaXMudG9nZ2xlRW50ZXJTdGF0ZX0+Q2xpY2sgdG8gRW50ZXI8L2J1dHRvbj5cbiAqICAgICA8L2Rpdj5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkIHRoZSBjb21wb25lbnQgd2lsbCBzaGlmdCB0byB0aGUgYCdlbnRlcmluZydgIHN0YXRlIGFuZFxuICogc3RheSB0aGVyZSBmb3IgNTAwbXMgKHRoZSB2YWx1ZSBvZiBgdGltZW91dGApIGJlZm9yZSBpdCBmaW5hbGx5IHN3aXRjaGVzIHRvIGAnZW50ZXJlZCdgLlxuICpcbiAqIFdoZW4gYGluYCBpcyBgZmFsc2VgIHRoZSBzYW1lIHRoaW5nIGhhcHBlbnMgZXhjZXB0IHRoZSBzdGF0ZSBtb3ZlcyBmcm9tIGAnZXhpdGluZydgIHRvIGAnZXhpdGVkJ2AuXG4gKlxuICogIyMgVGltaW5nXG4gKlxuICogVGltaW5nIGlzIG9mdGVuIHRoZSB0cmlja2llc3QgcGFydCBvZiBhbmltYXRpb24sIG1pc3Rha2VzIGNhbiByZXN1bHQgaW4gc2xpZ2h0IGRlbGF5c1xuICogdGhhdCBhcmUgaGFyZCB0byBwaW4gZG93bi4gQSBjb21tb24gZXhhbXBsZSBpcyB3aGVuIHlvdSB3YW50IHRvIGFkZCBhbiBleGl0IHRyYW5zaXRpb24sXG4gKiB5b3Ugc2hvdWxkIHNldCB0aGUgZGVzaXJlZCBmaW5hbCBzdHlsZXMgd2hlbiB0aGUgc3RhdGUgaXMgYCdleGl0aW5nJ2AuIFRoYXQncyB3aGVuIHRoZVxuICogdHJhbnNpdGlvbiB0byB0aG9zZSBzdHlsZXMgd2lsbCBzdGFydCBhbmQsIGlmIHlvdSBtYXRjaGVkIHRoZSBgdGltZW91dGAgcHJvcCB3aXRoIHRoZVxuICogQ1NTIFRyYW5zaXRpb24gZHVyYXRpb24sIGl0IHdpbGwgZW5kIGV4YWN0bHkgd2hlbiB0aGUgc3RhdGUgY2hhbmdlcyB0byBgJ2V4aXRlZCdgLlxuICpcbiAqID4gKipOb3RlKio6IEZvciBzaW1wbGVyIHRyYW5zaXRpb25zIHRoZSBgVHJhbnNpdGlvbmAgY29tcG9uZW50IG1pZ2h0IGJlIGVub3VnaCwgYnV0XG4gKiA+IHRha2UgaW50byBhY2NvdW50IHRoYXQgaXQncyBwbGF0Zm9ybS1hZ25vc3RpYywgd2hpbGUgdGhlIGBDU1NUcmFuc2l0aW9uYCBjb21wb25lbnRcbiAqID4gW2ZvcmNlcyByZWZsb3dzXShodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2Jsb2IvNTAwNzMwM2U3MjlhNzRiZTY2YTIxYzNlMjIwNWU0OTE2ODIxNTI0Yi9zcmMvQ1NTVHJhbnNpdGlvbi5qcyNMMjA4LUwyMTUpXG4gKiA+IGluIG9yZGVyIHRvIG1ha2UgbW9yZSBjb21wbGV4IHRyYW5zaXRpb25zIG1vcmUgcHJlZGljdGFibGUuIEZvciBleGFtcGxlLCBldmVuIHRob3VnaFxuICogPiBjbGFzc2VzIGBleGFtcGxlLWVudGVyYCBhbmQgYGV4YW1wbGUtZW50ZXItYWN0aXZlYCBhcmUgYXBwbGllZCBpbW1lZGlhdGVseSBvbmUgYWZ0ZXJcbiAqID4gYW5vdGhlciwgeW91IGNhbiBzdGlsbCB0cmFuc2l0aW9uIGZyb20gb25lIHRvIHRoZSBvdGhlciBiZWNhdXNlIG9mIHRoZSBmb3JjZWQgcmVmbG93XG4gKiA+IChyZWFkIFt0aGlzIGlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2lzc3Vlcy8xNTkjaXNzdWVjb21tZW50LTMyMjc2MTE3MSlcbiAqID4gZm9yIG1vcmUgaW5mbykuIFRha2UgdGhpcyBpbnRvIGFjY291bnQgd2hlbiBjaG9vc2luZyBiZXR3ZWVuIGBUcmFuc2l0aW9uYCBhbmRcbiAqID4gYENTU1RyYW5zaXRpb25gLlxuICovXG5cbmV4cG9ydHMuRVhJVElORyA9IEVYSVRJTkc7XG5cbnZhciBUcmFuc2l0aW9uID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRyYW5zaXRpb24sIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRyYW5zaXRpb24ocHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkgfHwgdGhpcztcbiAgICB2YXIgcGFyZW50R3JvdXAgPSBjb250ZXh0LnRyYW5zaXRpb25Hcm91cDsgLy8gSW4gdGhlIGNvbnRleHQgb2YgYSBUcmFuc2l0aW9uR3JvdXAgYWxsIGVudGVycyBhcmUgcmVhbGx5IGFwcGVhcnNcblxuICAgIHZhciBhcHBlYXIgPSBwYXJlbnRHcm91cCAmJiAhcGFyZW50R3JvdXAuaXNNb3VudGluZyA/IHByb3BzLmVudGVyIDogcHJvcHMuYXBwZWFyO1xuICAgIHZhciBpbml0aWFsU3RhdHVzO1xuICAgIF90aGlzLmFwcGVhclN0YXR1cyA9IG51bGw7XG5cbiAgICBpZiAocHJvcHMuaW4pIHtcbiAgICAgIGlmIChhcHBlYXIpIHtcbiAgICAgICAgaW5pdGlhbFN0YXR1cyA9IEVYSVRFRDtcbiAgICAgICAgX3RoaXMuYXBwZWFyU3RhdHVzID0gRU5URVJJTkc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0aWFsU3RhdHVzID0gRU5URVJFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BzLnVubW91bnRPbkV4aXQgfHwgcHJvcHMubW91bnRPbkVudGVyKSB7XG4gICAgICAgIGluaXRpYWxTdGF0dXMgPSBVTk1PVU5URUQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0aWFsU3RhdHVzID0gRVhJVEVEO1xuICAgICAgfVxuICAgIH1cblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgc3RhdHVzOiBpbml0aWFsU3RhdHVzXG4gICAgfTtcbiAgICBfdGhpcy5uZXh0Q2FsbGJhY2sgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUcmFuc2l0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2l0aW9uR3JvdXA6IG51bGwgLy8gYWxsb3dzIGZvciBuZXN0ZWQgVHJhbnNpdGlvbnNcblxuICAgIH07XG4gIH07XG5cbiAgVHJhbnNpdGlvbi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoX3JlZiwgcHJldlN0YXRlKSB7XG4gICAgdmFyIG5leHRJbiA9IF9yZWYuaW47XG5cbiAgICBpZiAobmV4dEluICYmIHByZXZTdGF0ZS5zdGF0dXMgPT09IFVOTU9VTlRFRCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBFWElURURcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07IC8vIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHByZXZQcm9wcykge1xuICAvLyAgIGxldCBuZXh0U3RhdHVzID0gbnVsbFxuICAvLyAgIGlmIChwcmV2UHJvcHMgIT09IHRoaXMucHJvcHMpIHtcbiAgLy8gICAgIGNvbnN0IHsgc3RhdHVzIH0gPSB0aGlzLnN0YXRlXG4gIC8vICAgICBpZiAodGhpcy5wcm9wcy5pbikge1xuICAvLyAgICAgICBpZiAoc3RhdHVzICE9PSBFTlRFUklORyAmJiBzdGF0dXMgIT09IEVOVEVSRUQpIHtcbiAgLy8gICAgICAgICBuZXh0U3RhdHVzID0gRU5URVJJTkdcbiAgLy8gICAgICAgfVxuICAvLyAgICAgfSBlbHNlIHtcbiAgLy8gICAgICAgaWYgKHN0YXR1cyA9PT0gRU5URVJJTkcgfHwgc3RhdHVzID09PSBFTlRFUkVEKSB7XG4gIC8vICAgICAgICAgbmV4dFN0YXR1cyA9IEVYSVRJTkdcbiAgLy8gICAgICAgfVxuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy8gICByZXR1cm4geyBuZXh0U3RhdHVzIH1cbiAgLy8gfVxuXG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51cGRhdGVTdGF0dXModHJ1ZSwgdGhpcy5hcHBlYXJTdGF0dXMpO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgdmFyIG5leHRTdGF0dXMgPSBudWxsO1xuXG4gICAgaWYgKHByZXZQcm9wcyAhPT0gdGhpcy5wcm9wcykge1xuICAgICAgdmFyIHN0YXR1cyA9IHRoaXMuc3RhdGUuc3RhdHVzO1xuXG4gICAgICBpZiAodGhpcy5wcm9wcy5pbikge1xuICAgICAgICBpZiAoc3RhdHVzICE9PSBFTlRFUklORyAmJiBzdGF0dXMgIT09IEVOVEVSRUQpIHtcbiAgICAgICAgICBuZXh0U3RhdHVzID0gRU5URVJJTkc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IEVOVEVSSU5HIHx8IHN0YXR1cyA9PT0gRU5URVJFRCkge1xuICAgICAgICAgIG5leHRTdGF0dXMgPSBFWElUSU5HO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTdGF0dXMoZmFsc2UsIG5leHRTdGF0dXMpO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuY2FuY2VsTmV4dENhbGxiYWNrKCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldFRpbWVvdXRzID0gZnVuY3Rpb24gZ2V0VGltZW91dHMoKSB7XG4gICAgdmFyIHRpbWVvdXQgPSB0aGlzLnByb3BzLnRpbWVvdXQ7XG4gICAgdmFyIGV4aXQsIGVudGVyLCBhcHBlYXI7XG4gICAgZXhpdCA9IGVudGVyID0gYXBwZWFyID0gdGltZW91dDtcblxuICAgIGlmICh0aW1lb3V0ICE9IG51bGwgJiYgdHlwZW9mIHRpbWVvdXQgIT09ICdudW1iZXInKSB7XG4gICAgICBleGl0ID0gdGltZW91dC5leGl0O1xuICAgICAgZW50ZXIgPSB0aW1lb3V0LmVudGVyO1xuICAgICAgYXBwZWFyID0gdGltZW91dC5hcHBlYXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGV4aXQ6IGV4aXQsXG4gICAgICBlbnRlcjogZW50ZXIsXG4gICAgICBhcHBlYXI6IGFwcGVhclxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLnVwZGF0ZVN0YXR1cyA9IGZ1bmN0aW9uIHVwZGF0ZVN0YXR1cyhtb3VudGluZywgbmV4dFN0YXR1cykge1xuICAgIGlmIChtb3VudGluZyA9PT0gdm9pZCAwKSB7XG4gICAgICBtb3VudGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChuZXh0U3RhdHVzICE9PSBudWxsKSB7XG4gICAgICAvLyBuZXh0U3RhdHVzIHdpbGwgYWx3YXlzIGJlIEVOVEVSSU5HIG9yIEVYSVRJTkcuXG4gICAgICB0aGlzLmNhbmNlbE5leHRDYWxsYmFjaygpO1xuXG4gICAgICB2YXIgbm9kZSA9IF9yZWFjdERvbS5kZWZhdWx0LmZpbmRET01Ob2RlKHRoaXMpO1xuXG4gICAgICBpZiAobmV4dFN0YXR1cyA9PT0gRU5URVJJTkcpIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtRW50ZXIobm9kZSwgbW91bnRpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtRXhpdChub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMucHJvcHMudW5tb3VudE9uRXhpdCAmJiB0aGlzLnN0YXRlLnN0YXR1cyA9PT0gRVhJVEVEKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgc3RhdHVzOiBVTk1PVU5URURcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucGVyZm9ybUVudGVyID0gZnVuY3Rpb24gcGVyZm9ybUVudGVyKG5vZGUsIG1vdW50aW5nKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgZW50ZXIgPSB0aGlzLnByb3BzLmVudGVyO1xuICAgIHZhciBhcHBlYXJpbmcgPSB0aGlzLmNvbnRleHQudHJhbnNpdGlvbkdyb3VwID8gdGhpcy5jb250ZXh0LnRyYW5zaXRpb25Hcm91cC5pc01vdW50aW5nIDogbW91bnRpbmc7XG4gICAgdmFyIHRpbWVvdXRzID0gdGhpcy5nZXRUaW1lb3V0cygpOyAvLyBubyBlbnRlciBhbmltYXRpb24gc2tpcCByaWdodCB0byBFTlRFUkVEXG4gICAgLy8gaWYgd2UgYXJlIG1vdW50aW5nIGFuZCBydW5uaW5nIHRoaXMgaXQgbWVhbnMgYXBwZWFyIF9tdXN0XyBiZSBzZXRcblxuICAgIGlmICghbW91bnRpbmcgJiYgIWVudGVyKSB7XG4gICAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgIHN0YXR1czogRU5URVJFRFxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIucHJvcHMub25FbnRlcmVkKG5vZGUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wcm9wcy5vbkVudGVyKG5vZGUsIGFwcGVhcmluZyk7XG4gICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgc3RhdHVzOiBFTlRFUklOR1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMi5wcm9wcy5vbkVudGVyaW5nKG5vZGUsIGFwcGVhcmluZyk7IC8vIEZJWE1FOiBhcHBlYXIgdGltZW91dD9cblxuXG4gICAgICBfdGhpczIub25UcmFuc2l0aW9uRW5kKG5vZGUsIHRpbWVvdXRzLmVudGVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5zYWZlU2V0U3RhdGUoe1xuICAgICAgICAgIHN0YXR1czogRU5URVJFRFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLnByb3BzLm9uRW50ZXJlZChub2RlLCBhcHBlYXJpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5wZXJmb3JtRXhpdCA9IGZ1bmN0aW9uIHBlcmZvcm1FeGl0KG5vZGUpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBleGl0ID0gdGhpcy5wcm9wcy5leGl0O1xuICAgIHZhciB0aW1lb3V0cyA9IHRoaXMuZ2V0VGltZW91dHMoKTsgLy8gbm8gZXhpdCBhbmltYXRpb24gc2tpcCByaWdodCB0byBFWElURURcblxuICAgIGlmICghZXhpdCkge1xuICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICBzdGF0dXM6IEVYSVRFRFxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMucHJvcHMub25FeGl0ZWQobm9kZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzLm9uRXhpdChub2RlKTtcbiAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICBzdGF0dXM6IEVYSVRJTkdcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczMucHJvcHMub25FeGl0aW5nKG5vZGUpO1xuXG4gICAgICBfdGhpczMub25UcmFuc2l0aW9uRW5kKG5vZGUsIHRpbWVvdXRzLmV4aXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgICAgc3RhdHVzOiBFWElURURcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMy5wcm9wcy5vbkV4aXRlZChub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uY2FuY2VsTmV4dENhbGxiYWNrID0gZnVuY3Rpb24gY2FuY2VsTmV4dENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLm5leHRDYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5uZXh0Q2FsbGJhY2suY2FuY2VsKCk7XG4gICAgICB0aGlzLm5leHRDYWxsYmFjayA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5zYWZlU2V0U3RhdGUgPSBmdW5jdGlvbiBzYWZlU2V0U3RhdGUobmV4dFN0YXRlLCBjYWxsYmFjaykge1xuICAgIC8vIFRoaXMgc2hvdWxkbid0IGJlIG5lY2Vzc2FyeSwgYnV0IHRoZXJlIGFyZSB3ZWlyZCByYWNlIGNvbmRpdGlvbnMgd2l0aFxuICAgIC8vIHNldFN0YXRlIGNhbGxiYWNrcyBhbmQgdW5tb3VudGluZyBpbiB0ZXN0aW5nLCBzbyBhbHdheXMgbWFrZSBzdXJlIHRoYXRcbiAgICAvLyB3ZSBjYW4gY2FuY2VsIGFueSBwZW5kaW5nIHNldFN0YXRlIGNhbGxiYWNrcyBhZnRlciB3ZSB1bm1vdW50LlxuICAgIGNhbGxiYWNrID0gdGhpcy5zZXROZXh0Q2FsbGJhY2soY2FsbGJhY2spO1xuICAgIHRoaXMuc2V0U3RhdGUobmV4dFN0YXRlLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgX3Byb3RvLnNldE5leHRDYWxsYmFjayA9IGZ1bmN0aW9uIHNldE5leHRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgdmFyIGFjdGl2ZSA9IHRydWU7XG5cbiAgICB0aGlzLm5leHRDYWxsYmFjayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICBhY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgX3RoaXM0Lm5leHRDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5uZXh0Q2FsbGJhY2suY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLm5leHRDYWxsYmFjaztcbiAgfTtcblxuICBfcHJvdG8ub25UcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gb25UcmFuc2l0aW9uRW5kKG5vZGUsIHRpbWVvdXQsIGhhbmRsZXIpIHtcbiAgICB0aGlzLnNldE5leHRDYWxsYmFjayhoYW5kbGVyKTtcblxuICAgIGlmIChub2RlKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5hZGRFbmRMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnByb3BzLmFkZEVuZExpc3RlbmVyKG5vZGUsIHRoaXMubmV4dENhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMubmV4dENhbGxiYWNrLCB0aW1lb3V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dCh0aGlzLm5leHRDYWxsYmFjaywgMCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHN0YXR1cyA9IHRoaXMuc3RhdGUuc3RhdHVzO1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gVU5NT1VOVEVEKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBjaGlsZFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIFtcImNoaWxkcmVuXCJdKTsgLy8gZmlsdGVyIHByb3BzIGZvciBUcmFuc3RpdGlvblxuXG5cbiAgICBkZWxldGUgY2hpbGRQcm9wcy5pbjtcbiAgICBkZWxldGUgY2hpbGRQcm9wcy5tb3VudE9uRW50ZXI7XG4gICAgZGVsZXRlIGNoaWxkUHJvcHMudW5tb3VudE9uRXhpdDtcbiAgICBkZWxldGUgY2hpbGRQcm9wcy5hcHBlYXI7XG4gICAgZGVsZXRlIGNoaWxkUHJvcHMuZW50ZXI7XG4gICAgZGVsZXRlIGNoaWxkUHJvcHMuZXhpdDtcbiAgICBkZWxldGUgY2hpbGRQcm9wcy50aW1lb3V0O1xuICAgIGRlbGV0ZSBjaGlsZFByb3BzLmFkZEVuZExpc3RlbmVyO1xuICAgIGRlbGV0ZSBjaGlsZFByb3BzLm9uRW50ZXI7XG4gICAgZGVsZXRlIGNoaWxkUHJvcHMub25FbnRlcmluZztcbiAgICBkZWxldGUgY2hpbGRQcm9wcy5vbkVudGVyZWQ7XG4gICAgZGVsZXRlIGNoaWxkUHJvcHMub25FeGl0O1xuICAgIGRlbGV0ZSBjaGlsZFByb3BzLm9uRXhpdGluZztcbiAgICBkZWxldGUgY2hpbGRQcm9wcy5vbkV4aXRlZDtcblxuICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbihzdGF0dXMsIGNoaWxkUHJvcHMpO1xuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuXG4gICAgcmV0dXJuIF9yZWFjdC5kZWZhdWx0LmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcyk7XG4gIH07XG5cbiAgcmV0dXJuIFRyYW5zaXRpb247XG59KF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCk7XG5cblRyYW5zaXRpb24uY29udGV4dFR5cGVzID0ge1xuICB0cmFuc2l0aW9uR3JvdXA6IFByb3BUeXBlcy5vYmplY3Rcbn07XG5UcmFuc2l0aW9uLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICB0cmFuc2l0aW9uR3JvdXA6IGZ1bmN0aW9uIHRyYW5zaXRpb25Hcm91cCgpIHt9XG59O1xuVHJhbnNpdGlvbi5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIC8qKlxuICAgKiBBIGBmdW5jdGlvbmAgY2hpbGQgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiBhIFJlYWN0IGVsZW1lbnQuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhlIGN1cnJlbnQgdHJhbnNpdGlvbiBzdGF0dXNcbiAgICogKCdlbnRlcmluZycsICdlbnRlcmVkJywgJ2V4aXRpbmcnLCAnZXhpdGVkJywgJ3VubW91bnRlZCcpLCB3aGljaCBjYW4gYmUgdXNlZFxuICAgKiB0byBhcHBseSBjb250ZXh0IHNwZWNpZmljIHByb3BzIHRvIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogPFRyYW5zaXRpb24gdGltZW91dD17MTUwfT5cbiAgICogICB7KHN0YXR1cykgPT4gKFxuICAgKiAgICAgPE15Q29tcG9uZW50IGNsYXNzTmFtZT17YGZhZGUgZmFkZS0ke3N0YXR1c31gfSAvPlxuICAgKiAgICl9XG4gICAqIDwvVHJhbnNpdGlvbj5cbiAgICogYGBgXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCwgUHJvcFR5cGVzLmVsZW1lbnQuaXNSZXF1aXJlZF0pLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIGNvbXBvbmVudDsgdHJpZ2dlcnMgdGhlIGVudGVyIG9yIGV4aXQgc3RhdGVzXG4gICAqL1xuICBpbjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQgdGhlIGNoaWxkIGNvbXBvbmVudCBpcyBtb3VudGVkIGltbWVkaWF0ZWx5IGFsb25nIHdpdGhcbiAgICogdGhlIHBhcmVudCBgVHJhbnNpdGlvbmAgY29tcG9uZW50LiBJZiB5b3Ugd2FudCB0byBcImxhenkgbW91bnRcIiB0aGUgY29tcG9uZW50IG9uIHRoZVxuICAgKiBmaXJzdCBgaW49e3RydWV9YCB5b3UgY2FuIHNldCBgbW91bnRPbkVudGVyYC4gQWZ0ZXIgdGhlIGZpcnN0IGVudGVyIHRyYW5zaXRpb24gdGhlIGNvbXBvbmVudCB3aWxsIHN0YXlcbiAgICogbW91bnRlZCwgZXZlbiBvbiBcImV4aXRlZFwiLCB1bmxlc3MgeW91IGFsc28gc3BlY2lmeSBgdW5tb3VudE9uRXhpdGAuXG4gICAqL1xuICBtb3VudE9uRW50ZXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0IHRoZSBjaGlsZCBjb21wb25lbnQgc3RheXMgbW91bnRlZCBhZnRlciBpdCByZWFjaGVzIHRoZSBgJ2V4aXRlZCdgIHN0YXRlLlxuICAgKiBTZXQgYHVubW91bnRPbkV4aXRgIGlmIHlvdSdkIHByZWZlciB0byB1bm1vdW50IHRoZSBjb21wb25lbnQgYWZ0ZXIgaXQgZmluaXNoZXMgZXhpdGluZy5cbiAgICovXG4gIHVubW91bnRPbkV4aXQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBOb3JtYWxseSBhIGNvbXBvbmVudCBpcyBub3QgdHJhbnNpdGlvbmVkIGlmIGl0IGlzIHNob3duIHdoZW4gdGhlIGA8VHJhbnNpdGlvbj5gIGNvbXBvbmVudCBtb3VudHMuXG4gICAqIElmIHlvdSB3YW50IHRvIHRyYW5zaXRpb24gb24gdGhlIGZpcnN0IG1vdW50IHNldCBgYXBwZWFyYCB0byBgdHJ1ZWAsIGFuZCB0aGVcbiAgICogY29tcG9uZW50IHdpbGwgdHJhbnNpdGlvbiBpbiBhcyBzb29uIGFzIHRoZSBgPFRyYW5zaXRpb24+YCBtb3VudHMuXG4gICAqXG4gICAqID4gTm90ZTogdGhlcmUgYXJlIG5vIHNwZWNpZmljIFwiYXBwZWFyXCIgc3RhdGVzLiBgYXBwZWFyYCBvbmx5IGFkZHMgYW4gYWRkaXRpb25hbCBgZW50ZXJgIHRyYW5zaXRpb24uXG4gICAqL1xuICBhcHBlYXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBlbnRlciB0cmFuc2l0aW9ucy5cbiAgICovXG4gIGVudGVyOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgZXhpdCB0cmFuc2l0aW9ucy5cbiAgICovXG4gIGV4aXQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgZHVyYXRpb24gb2YgdGhlIHRyYW5zaXRpb24sIGluIG1pbGxpc2Vjb25kcy5cbiAgICogUmVxdWlyZWQgdW5sZXNzIGBhZGRFbmRMaXN0ZW5lcmAgaXMgcHJvdmlkZWRcbiAgICpcbiAgICogWW91IG1heSBzcGVjaWZ5IGEgc2luZ2xlIHRpbWVvdXQgZm9yIGFsbCB0cmFuc2l0aW9ucyBsaWtlOiBgdGltZW91dD17NTAwfWAsXG4gICAqIG9yIGluZGl2aWR1YWxseSBsaWtlOlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogdGltZW91dD17e1xuICAgKiAgZW50ZXI6IDMwMCxcbiAgICogIGV4aXQ6IDUwMCxcbiAgICogfX1cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXIgfCB7IGVudGVyPzogbnVtYmVyLCBleGl0PzogbnVtYmVyIH19XG4gICAqL1xuICB0aW1lb3V0OiBmdW5jdGlvbiB0aW1lb3V0KHByb3BzKSB7XG4gICAgdmFyIHB0ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gX1Byb3BUeXBlcy50aW1lb3V0c1NoYXBlIDoge307O1xuICAgIGlmICghcHJvcHMuYWRkRW5kTGlzdGVuZXIpIHB0ID0gcHQuaXNSZXF1aXJlZDtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBwdC5hcHBseSh2b2lkIDAsIFtwcm9wc10uY29uY2F0KGFyZ3MpKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkIGEgY3VzdG9tIHRyYW5zaXRpb24gZW5kIHRyaWdnZXIuIENhbGxlZCB3aXRoIHRoZSB0cmFuc2l0aW9uaW5nXG4gICAqIERPTSBub2RlIGFuZCBhIGBkb25lYCBjYWxsYmFjay4gQWxsb3dzIGZvciBtb3JlIGZpbmUgZ3JhaW5lZCB0cmFuc2l0aW9uIGVuZFxuICAgKiBsb2dpYy4gKipOb3RlOioqIFRpbWVvdXRzIGFyZSBzdGlsbCB1c2VkIGFzIGEgZmFsbGJhY2sgaWYgcHJvdmlkZWQuXG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiBhZGRFbmRMaXN0ZW5lcj17KG5vZGUsIGRvbmUpID0+IHtcbiAgICogICAvLyB1c2UgdGhlIGNzcyB0cmFuc2l0aW9uZW5kIGV2ZW50IHRvIG1hcmsgdGhlIGZpbmlzaCBvZiBhIHRyYW5zaXRpb25cbiAgICogICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBkb25lLCBmYWxzZSk7XG4gICAqIH19XG4gICAqIGBgYFxuICAgKi9cbiAgYWRkRW5kTGlzdGVuZXI6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBiZWZvcmUgdGhlIFwiZW50ZXJpbmdcIiBzdGF0dXMgaXMgYXBwbGllZC4gQW4gZXh0cmEgcGFyYW1ldGVyXG4gICAqIGBpc0FwcGVhcmluZ2AgaXMgc3VwcGxpZWQgdG8gaW5kaWNhdGUgaWYgdGhlIGVudGVyIHN0YWdlIGlzIG9jY3VycmluZyBvbiB0aGUgaW5pdGlhbCBtb3VudFxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpIC0+IHZvaWRcbiAgICovXG4gIG9uRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciB0aGUgXCJlbnRlcmluZ1wiIHN0YXR1cyBpcyBhcHBsaWVkLiBBbiBleHRyYSBwYXJhbWV0ZXJcbiAgICogYGlzQXBwZWFyaW5nYCBpcyBzdXBwbGllZCB0byBpbmRpY2F0ZSBpZiB0aGUgZW50ZXIgc3RhZ2UgaXMgb2NjdXJyaW5nIG9uIHRoZSBpbml0aWFsIG1vdW50XG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbClcbiAgICovXG4gIG9uRW50ZXJpbmc6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciB0aGUgXCJlbnRlcmVkXCIgc3RhdHVzIGlzIGFwcGxpZWQuIEFuIGV4dHJhIHBhcmFtZXRlclxuICAgKiBgaXNBcHBlYXJpbmdgIGlzIHN1cHBsaWVkIHRvIGluZGljYXRlIGlmIHRoZSBlbnRlciBzdGFnZSBpcyBvY2N1cnJpbmcgb24gdGhlIGluaXRpYWwgbW91bnRcbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKSAtPiB2b2lkXG4gICAqL1xuICBvbkVudGVyZWQ6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBiZWZvcmUgdGhlIFwiZXhpdGluZ1wiIHN0YXR1cyBpcyBhcHBsaWVkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCkgLT4gdm9pZFxuICAgKi9cbiAgb25FeGl0OiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgdGhlIFwiZXhpdGluZ1wiIHN0YXR1cyBpcyBhcHBsaWVkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCkgLT4gdm9pZFxuICAgKi9cbiAgb25FeGl0aW5nOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgdGhlIFwiZXhpdGVkXCIgc3RhdHVzIGlzIGFwcGxpZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KSAtPiB2b2lkXG4gICAqL1xuICBvbkV4aXRlZDogUHJvcFR5cGVzLmZ1bmMgLy8gTmFtZSB0aGUgZnVuY3Rpb24gc28gaXQgaXMgY2xlYXJlciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuXG59IDoge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5UcmFuc2l0aW9uLmRlZmF1bHRQcm9wcyA9IHtcbiAgaW46IGZhbHNlLFxuICBtb3VudE9uRW50ZXI6IGZhbHNlLFxuICB1bm1vdW50T25FeGl0OiBmYWxzZSxcbiAgYXBwZWFyOiBmYWxzZSxcbiAgZW50ZXI6IHRydWUsXG4gIGV4aXQ6IHRydWUsXG4gIG9uRW50ZXI6IG5vb3AsXG4gIG9uRW50ZXJpbmc6IG5vb3AsXG4gIG9uRW50ZXJlZDogbm9vcCxcbiAgb25FeGl0OiBub29wLFxuICBvbkV4aXRpbmc6IG5vb3AsXG4gIG9uRXhpdGVkOiBub29wXG59O1xuVHJhbnNpdGlvbi5VTk1PVU5URUQgPSAwO1xuVHJhbnNpdGlvbi5FWElURUQgPSAxO1xuVHJhbnNpdGlvbi5FTlRFUklORyA9IDI7XG5UcmFuc2l0aW9uLkVOVEVSRUQgPSAzO1xuVHJhbnNpdGlvbi5FWElUSU5HID0gNDtcblxudmFyIF9kZWZhdWx0ID0gKDAsIF9yZWFjdExpZmVjeWNsZXNDb21wYXQucG9seWZpbGwpKFRyYW5zaXRpb24pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX3JlYWN0LXRyYW5zaXRpb24tZ3JvdXBAMi41LjJAcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9UcmFuc2l0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5mdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gIC8vIENhbGwgdGhpcy5jb25zdHJ1Y3Rvci5nRFNGUCB0byBzdXBwb3J0IHN1Yi1jbGFzc2VzLlxuICB2YXIgc3RhdGUgPSB0aGlzLmNvbnN0cnVjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyh0aGlzLnByb3BzLCB0aGlzLnN0YXRlKTtcbiAgaWYgKHN0YXRlICE9PSBudWxsICYmIHN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAvLyBDYWxsIHRoaXMuY29uc3RydWN0b3IuZ0RTRlAgdG8gc3VwcG9ydCBzdWItY2xhc3Nlcy5cbiAgLy8gVXNlIHRoZSBzZXRTdGF0ZSgpIHVwZGF0ZXIgdG8gZW5zdXJlIHN0YXRlIGlzbid0IHN0YWxlIGluIGNlcnRhaW4gZWRnZSBjYXNlcy5cbiAgZnVuY3Rpb24gdXBkYXRlcihwcmV2U3RhdGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLmNvbnN0cnVjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlICE9PSBudWxsICYmIHN0YXRlICE9PSB1bmRlZmluZWQgPyBzdGF0ZSA6IG51bGw7XG4gIH1cbiAgLy8gQmluZGluZyBcInRoaXNcIiBpcyBpbXBvcnRhbnQgZm9yIHNoYWxsb3cgcmVuZGVyZXIgc3VwcG9ydC5cbiAgdGhpcy5zZXRTdGF0ZSh1cGRhdGVyLmJpbmQodGhpcykpO1xufVxuXG5mdW5jdGlvbiBjb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gIHRyeSB7XG4gICAgdmFyIHByZXZQcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByZXZTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5wcm9wcyA9IG5leHRQcm9wcztcbiAgICB0aGlzLnN0YXRlID0gbmV4dFN0YXRlO1xuICAgIHRoaXMuX19yZWFjdEludGVybmFsU25hcHNob3RGbGFnID0gdHJ1ZTtcbiAgICB0aGlzLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90ID0gdGhpcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShcbiAgICAgIHByZXZQcm9wcyxcbiAgICAgIHByZXZTdGF0ZVxuICAgICk7XG4gIH0gZmluYWxseSB7XG4gICAgdGhpcy5wcm9wcyA9IHByZXZQcm9wcztcbiAgICB0aGlzLnN0YXRlID0gcHJldlN0YXRlO1xuICB9XG59XG5cbi8vIFJlYWN0IG1heSB3YXJuIGFib3V0IGNXTS9jV1JQL2NXVSBtZXRob2RzIGJlaW5nIGRlcHJlY2F0ZWQuXG4vLyBBZGQgYSBmbGFnIHRvIHN1cHByZXNzIHRoZXNlIHdhcm5pbmdzIGZvciB0aGlzIHNwZWNpYWwgY2FzZS5cbmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nID0gdHJ1ZTtcbmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyA9IHRydWU7XG5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgPSB0cnVlO1xuXG5mdW5jdGlvbiBwb2x5ZmlsbChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG5cbiAgaWYgKCFwcm90b3R5cGUgfHwgIXByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gb25seSBwb2x5ZmlsbCBjbGFzcyBjb21wb25lbnRzJyk7XG4gIH1cblxuICBpZiAoXG4gICAgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgcHJvdG90eXBlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybiBDb21wb25lbnQ7XG4gIH1cblxuICAvLyBJZiBuZXcgY29tcG9uZW50IEFQSXMgYXJlIGRlZmluZWQsIFwidW5zYWZlXCIgbGlmZWN5Y2xlcyB3b24ndCBiZSBjYWxsZWQuXG4gIC8vIEVycm9yIGlmIGFueSBvZiB0aGVzZSBsaWZlY3ljbGVzIGFyZSBwcmVzZW50LFxuICAvLyBCZWNhdXNlIHRoZXkgd291bGQgd29yayBkaWZmZXJlbnRseSBiZXR3ZWVuIG9sZGVyIGFuZCBuZXdlciAoMTYuMyspIHZlcnNpb25zIG9mIFJlYWN0LlxuICB2YXIgZm91bmRXaWxsTW91bnROYW1lID0gbnVsbDtcbiAgdmFyIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsO1xuICB2YXIgZm91bmRXaWxsVXBkYXRlTmFtZSA9IG51bGw7XG4gIGlmICh0eXBlb2YgcHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdjb21wb25lbnRXaWxsTW91bnQnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm90b3R5cGUuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JztcbiAgfVxuICBpZiAodHlwZW9mIHByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvdG90eXBlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm90b3R5cGUuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb3RvdHlwZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICB9XG4gIGlmIChcbiAgICBmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHxcbiAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsIHx8XG4gICAgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbFxuICApIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZTtcbiAgICB2YXIgbmV3QXBpTmFtZSA9XG4gICAgICB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/ICdnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSdcbiAgICAgICAgOiAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSc7XG5cbiAgICB0aHJvdyBFcnJvcihcbiAgICAgICdVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4nICtcbiAgICAgICAgY29tcG9uZW50TmFtZSArXG4gICAgICAgICcgdXNlcyAnICtcbiAgICAgICAgbmV3QXBpTmFtZSArXG4gICAgICAgICcgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczonICtcbiAgICAgICAgKGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCA/ICdcXG4gICcgKyBmb3VuZFdpbGxNb3VudE5hbWUgOiAnJykgK1xuICAgICAgICAoZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbFxuICAgICAgICAgID8gJ1xcbiAgJyArIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWVcbiAgICAgICAgICA6ICcnKSArXG4gICAgICAgIChmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsID8gJ1xcbiAgJyArIGZvdW5kV2lsbFVwZGF0ZU5hbWUgOiAnJykgK1xuICAgICAgICAnXFxuXFxuVGhlIGFib3ZlIGxpZmVjeWNsZXMgc2hvdWxkIGJlIHJlbW92ZWQuIExlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6XFxuJyArXG4gICAgICAgICdodHRwczovL2ZiLm1lL3JlYWN0LWFzeW5jLWNvbXBvbmVudC1saWZlY3ljbGUtaG9va3MnXG4gICAgKTtcbiAgfVxuXG4gIC8vIFJlYWN0IDw9IDE2LjIgZG9lcyBub3Qgc3VwcG9ydCBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLlxuICAvLyBBcyBhIHdvcmthcm91bmQsIHVzZSBjV00gYW5kIGNXUlAgdG8gaW52b2tlIHRoZSBuZXcgc3RhdGljIGxpZmVjeWNsZS5cbiAgLy8gTmV3ZXIgdmVyc2lvbnMgb2YgUmVhY3Qgd2lsbCBpZ25vcmUgdGhlc2UgbGlmZWN5Y2xlcyBpZiBnRFNGUCBleGlzdHMuXG4gIGlmICh0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBjb21wb25lbnRXaWxsTW91bnQ7XG4gICAgcHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzO1xuICB9XG5cbiAgLy8gUmVhY3QgPD0gMTYuMiBkb2VzIG5vdCBzdXBwb3J0IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlLlxuICAvLyBBcyBhIHdvcmthcm91bmQsIHVzZSBjV1UgdG8gaW52b2tlIHRoZSBuZXcgbGlmZWN5Y2xlLlxuICAvLyBOZXdlciB2ZXJzaW9ucyBvZiBSZWFjdCB3aWxsIGlnbm9yZSB0aGF0IGxpZmVjeWNsZSBpZiBnU0JVIGV4aXN0cy5cbiAgaWYgKHR5cGVvZiBwcm90b3R5cGUuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIHByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBwb2x5ZmlsbCBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGZvciBjb21wb25lbnRzIHRoYXQgZG8gbm90IGRlZmluZSBjb21wb25lbnREaWRVcGRhdGUoKSBvbiB0aGUgcHJvdG90eXBlJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBwcm90b3R5cGUuY29tcG9uZW50V2lsbFVwZGF0ZSA9IGNvbXBvbmVudFdpbGxVcGRhdGU7XG5cbiAgICB2YXIgY29tcG9uZW50RGlkVXBkYXRlID0gcHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZTtcblxuICAgIHByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGVQb2x5ZmlsbChcbiAgICAgIHByZXZQcm9wcyxcbiAgICAgIHByZXZTdGF0ZSxcbiAgICAgIG1heWJlU25hcHNob3RcbiAgICApIHtcbiAgICAgIC8vIDE2LjMrIHdpbGwgbm90IGV4ZWN1dGUgb3VyIHdpbGwtdXBkYXRlIG1ldGhvZDtcbiAgICAgIC8vIEl0IHdpbGwgcGFzcyBhIHNuYXBzaG90IHZhbHVlIHRvIGRpZC11cGRhdGUgdGhvdWdoLlxuICAgICAgLy8gT2xkZXIgdmVyc2lvbnMgd2lsbCByZXF1aXJlIG91ciBwb2x5ZmlsbGVkIHdpbGwtdXBkYXRlIHZhbHVlLlxuICAgICAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYm90aCBjYXNlcywgYnV0IGNhbid0IGp1c3QgY2hlY2sgZm9yIHRoZSBwcmVzZW5jZSBvZiBcIm1heWJlU25hcHNob3RcIixcbiAgICAgIC8vIEJlY2F1c2UgZm9yIDw9IDE1LnggdmVyc2lvbnMgdGhpcyBtaWdodCBiZSBhIFwicHJldkNvbnRleHRcIiBvYmplY3QuXG4gICAgICAvLyBXZSBhbHNvIGNhbid0IGp1c3QgY2hlY2sgXCJfX3JlYWN0SW50ZXJuYWxTbmFwc2hvdFwiLFxuICAgICAgLy8gQmVjYXVzZSBnZXQtc25hcHNob3QgbWlnaHQgcmV0dXJuIGEgZmFsc3kgdmFsdWUuXG4gICAgICAvLyBTbyBjaGVjayBmb3IgdGhlIGV4cGxpY2l0IF9fcmVhY3RJbnRlcm5hbFNuYXBzaG90RmxhZyBmbGFnIHRvIGRldGVybWluZSBiZWhhdmlvci5cbiAgICAgIHZhciBzbmFwc2hvdCA9IHRoaXMuX19yZWFjdEludGVybmFsU25hcHNob3RGbGFnXG4gICAgICAgID8gdGhpcy5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdFxuICAgICAgICA6IG1heWJlU25hcHNob3Q7XG5cbiAgICAgIGNvbXBvbmVudERpZFVwZGF0ZS5jYWxsKHRoaXMsIHByZXZQcm9wcywgcHJldlN0YXRlLCBzbmFwc2hvdCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBDb21wb25lbnQ7XG59XG5cbmV4cG9ydCB7IHBvbHlmaWxsIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX3JlYWN0LWxpZmVjeWNsZXMtY29tcGF0QDMuMC40QHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0L3JlYWN0LWxpZmVjeWNsZXMtY29tcGF0LmVzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnRyYW5zaXRpb25UaW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG5leHBvcnRzLmNsYXNzTmFtZXNTaGFwZSA9IGV4cG9ydHMudGltZW91dHNTaGFwZSA9IHZvaWQgMDtcblxudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdHJhbnNpdGlvblRpbWVvdXQodHJhbnNpdGlvblR5cGUpIHtcbiAgdmFyIHRpbWVvdXRQcm9wTmFtZSA9ICd0cmFuc2l0aW9uJyArIHRyYW5zaXRpb25UeXBlICsgJ1RpbWVvdXQnO1xuICB2YXIgZW5hYmxlZFByb3BOYW1lID0gJ3RyYW5zaXRpb24nICsgdHJhbnNpdGlvblR5cGU7XG4gIHJldHVybiBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAvLyBJZiB0aGUgdHJhbnNpdGlvbiBpcyBlbmFibGVkXG4gICAgaWYgKHByb3BzW2VuYWJsZWRQcm9wTmFtZV0pIHtcbiAgICAgIC8vIElmIG5vIHRpbWVvdXQgZHVyYXRpb24gaXMgcHJvdmlkZWRcbiAgICAgIGlmIChwcm9wc1t0aW1lb3V0UHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcih0aW1lb3V0UHJvcE5hbWUgKyAnIHdhc25cXCd0IHN1cHBsaWVkIHRvIENTU1RyYW5zaXRpb25Hcm91cDogJyArICd0aGlzIGNhbiBjYXVzZSB1bnJlbGlhYmxlIGFuaW1hdGlvbnMgYW5kIHdvblxcJ3QgYmUgc3VwcG9ydGVkIGluICcgKyAnYSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdC4gU2VlICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1hbmltYXRpb24tdHJhbnNpdGlvbi1ncm91cC10aW1lb3V0IGZvciBtb3JlICcgKyAnaW5mb3JtYXRpb24uJyk7IC8vIElmIHRoZSBkdXJhdGlvbiBpc24ndCBhIG51bWJlclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHNbdGltZW91dFByb3BOYW1lXSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcih0aW1lb3V0UHJvcE5hbWUgKyAnIG11c3QgYmUgYSBudW1iZXIgKGluIG1pbGxpc2Vjb25kcyknKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cblxudmFyIHRpbWVvdXRzU2hhcGUgPSBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLCBfcHJvcFR5cGVzLmRlZmF1bHQuc2hhcGUoe1xuICBlbnRlcjogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgZXhpdDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlclxufSkuaXNSZXF1aXJlZF0pO1xuXG5leHBvcnRzLnRpbWVvdXRzU2hhcGUgPSB0aW1lb3V0c1NoYXBlO1xuXG52YXIgY2xhc3NOYW1lc1NoYXBlID0gX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZywgX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgZW50ZXI6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIGV4aXQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIGFjdGl2ZTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZ1xufSksIF9wcm9wVHlwZXMuZGVmYXVsdC5zaGFwZSh7XG4gIGVudGVyOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICBlbnRlckRvbmU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIGVudGVyQWN0aXZlOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICBleGl0OiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICBleGl0RG9uZTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgZXhpdEFjdGl2ZTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZ1xufSldKTtcblxuZXhwb3J0cy5jbGFzc05hbWVzU2hhcGUgPSBjbGFzc05hbWVzU2hhcGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19yZWFjdC10cmFuc2l0aW9uLWdyb3VwQDIuNS4yQHJlYWN0LXRyYW5zaXRpb24tZ3JvdXAvdXRpbHMvUHJvcFR5cGVzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfcmVhY3RMaWZlY3ljbGVzQ29tcGF0ID0gcmVxdWlyZShcInJlYWN0LWxpZmVjeWNsZXMtY29tcGF0XCIpO1xuXG52YXIgX0NoaWxkTWFwcGluZyA9IHJlcXVpcmUoXCIuL3V0aWxzL0NoaWxkTWFwcGluZ1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbnZhciB2YWx1ZXMgPSBPYmplY3QudmFsdWVzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIG9ialtrXTtcbiAgfSk7XG59O1xuXG52YXIgcHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICAvKipcbiAgICogYDxUcmFuc2l0aW9uR3JvdXA+YCByZW5kZXJzIGEgYDxkaXY+YCBieSBkZWZhdWx0LiBZb3UgY2FuIGNoYW5nZSB0aGlzXG4gICAqIGJlaGF2aW9yIGJ5IHByb3ZpZGluZyBhIGBjb21wb25lbnRgIHByb3AuXG4gICAqIElmIHlvdSB1c2UgUmVhY3QgdjE2KyBhbmQgd291bGQgbGlrZSB0byBhdm9pZCBhIHdyYXBwaW5nIGA8ZGl2PmAgZWxlbWVudFxuICAgKiB5b3UgY2FuIHBhc3MgaW4gYGNvbXBvbmVudD17bnVsbH1gLiBUaGlzIGlzIHVzZWZ1bCBpZiB0aGUgd3JhcHBpbmcgZGl2XG4gICAqIGJvcmtzIHlvdXIgY3NzIHN0eWxlcy5cbiAgICovXG4gIGNvbXBvbmVudDogX3Byb3BUeXBlcy5kZWZhdWx0LmFueSxcblxuICAvKipcbiAgICogQSBzZXQgb2YgYDxUcmFuc2l0aW9uPmAgY29tcG9uZW50cywgdGhhdCBhcmUgdG9nZ2xlZCBgaW5gIGFuZCBvdXQgYXMgdGhleVxuICAgKiBsZWF2ZS4gdGhlIGA8VHJhbnNpdGlvbkdyb3VwPmAgd2lsbCBpbmplY3Qgc3BlY2lmaWMgdHJhbnNpdGlvbiBwcm9wcywgc29cbiAgICogcmVtZW1iZXIgdG8gc3ByZWFkIHRoZW0gdGhyb3VnaCBpZiB5b3UgYXJlIHdyYXBwaW5nIHRoZSBgPFRyYW5zaXRpb24+YCBhc1xuICAgKiB3aXRoIG91ciBgPEZhZGU+YCBleGFtcGxlLlxuICAgKi9cbiAgY2hpbGRyZW46IF9wcm9wVHlwZXMuZGVmYXVsdC5ub2RlLFxuXG4gIC8qKlxuICAgKiBBIGNvbnZlbmllbmNlIHByb3AgdGhhdCBlbmFibGVzIG9yIGRpc2FibGVzIGFwcGVhciBhbmltYXRpb25zXG4gICAqIGZvciBhbGwgY2hpbGRyZW4uIE5vdGUgdGhhdCBzcGVjaWZ5aW5nIHRoaXMgd2lsbCBvdmVycmlkZSBhbnkgZGVmYXVsdHMgc2V0XG4gICAqIG9uIGluZGl2aWR1YWwgY2hpbGRyZW4gVHJhbnNpdGlvbnMuXG4gICAqL1xuICBhcHBlYXI6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBBIGNvbnZlbmllbmNlIHByb3AgdGhhdCBlbmFibGVzIG9yIGRpc2FibGVzIGVudGVyIGFuaW1hdGlvbnNcbiAgICogZm9yIGFsbCBjaGlsZHJlbi4gTm90ZSB0aGF0IHNwZWNpZnlpbmcgdGhpcyB3aWxsIG92ZXJyaWRlIGFueSBkZWZhdWx0cyBzZXRcbiAgICogb24gaW5kaXZpZHVhbCBjaGlsZHJlbiBUcmFuc2l0aW9ucy5cbiAgICovXG4gIGVudGVyOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcblxuICAvKipcbiAgICogQSBjb252ZW5pZW5jZSBwcm9wIHRoYXQgZW5hYmxlcyBvciBkaXNhYmxlcyBleGl0IGFuaW1hdGlvbnNcbiAgICogZm9yIGFsbCBjaGlsZHJlbi4gTm90ZSB0aGF0IHNwZWNpZnlpbmcgdGhpcyB3aWxsIG92ZXJyaWRlIGFueSBkZWZhdWx0cyBzZXRcbiAgICogb24gaW5kaXZpZHVhbCBjaGlsZHJlbiBUcmFuc2l0aW9ucy5cbiAgICovXG4gIGV4aXQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBZb3UgbWF5IG5lZWQgdG8gYXBwbHkgcmVhY3RpdmUgdXBkYXRlcyB0byBhIGNoaWxkIGFzIGl0IGlzIGV4aXRpbmcuXG4gICAqIFRoaXMgaXMgZ2VuZXJhbGx5IGRvbmUgYnkgdXNpbmcgYGNsb25lRWxlbWVudGAgaG93ZXZlciBpbiB0aGUgY2FzZSBvZiBhbiBleGl0aW5nXG4gICAqIGNoaWxkIHRoZSBlbGVtZW50IGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBhbmQgbm90IGFjY2Vzc2libGUgdG8gdGhlIGNvbnN1bWVyLlxuICAgKlxuICAgKiBJZiB5b3UgZG8gbmVlZCB0byB1cGRhdGUgYSBjaGlsZCBhcyBpdCBsZWF2ZXMgeW91IGNhbiBwcm92aWRlIGEgYGNoaWxkRmFjdG9yeWBcbiAgICogdG8gd3JhcCBldmVyeSBjaGlsZCwgZXZlbiB0aGUgb25lcyB0aGF0IGFyZSBsZWF2aW5nLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihjaGlsZDogUmVhY3RFbGVtZW50KSAtPiBSZWFjdEVsZW1lbnRcbiAgICovXG4gIGNoaWxkRmFjdG9yeTogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmNcbn0gOiB7fTs7XG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBjb21wb25lbnQ6ICdkaXYnLFxuICBjaGlsZEZhY3Rvcnk6IGZ1bmN0aW9uIGNoaWxkRmFjdG9yeShjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZDtcbiAgfVxuICAvKipcbiAgICogVGhlIGA8VHJhbnNpdGlvbkdyb3VwPmAgY29tcG9uZW50IG1hbmFnZXMgYSBzZXQgb2YgdHJhbnNpdGlvbiBjb21wb25lbnRzXG4gICAqIChgPFRyYW5zaXRpb24+YCBhbmQgYDxDU1NUcmFuc2l0aW9uPmApIGluIGEgbGlzdC4gTGlrZSB3aXRoIHRoZSB0cmFuc2l0aW9uXG4gICAqIGNvbXBvbmVudHMsIGA8VHJhbnNpdGlvbkdyb3VwPmAgaXMgYSBzdGF0ZSBtYWNoaW5lIGZvciBtYW5hZ2luZyB0aGUgbW91bnRpbmdcbiAgICogYW5kIHVubW91bnRpbmcgb2YgY29tcG9uZW50cyBvdmVyIHRpbWUuXG4gICAqXG4gICAqIENvbnNpZGVyIHRoZSBleGFtcGxlIGJlbG93LiBBcyBpdGVtcyBhcmUgcmVtb3ZlZCBvciBhZGRlZCB0byB0aGUgVG9kb0xpc3QgdGhlXG4gICAqIGBpbmAgcHJvcCBpcyB0b2dnbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIGA8VHJhbnNpdGlvbkdyb3VwPmAuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBgPFRyYW5zaXRpb25Hcm91cD5gICBkb2VzIG5vdCBkZWZpbmUgYW55IGFuaW1hdGlvbiBiZWhhdmlvciFcbiAgICogRXhhY3RseSBfaG93XyBhIGxpc3QgaXRlbSBhbmltYXRlcyBpcyB1cCB0byB0aGUgaW5kaXZpZHVhbCB0cmFuc2l0aW9uXG4gICAqIGNvbXBvbmVudC4gVGhpcyBtZWFucyB5b3UgY2FuIG1peCBhbmQgbWF0Y2ggYW5pbWF0aW9ucyBhY3Jvc3MgZGlmZmVyZW50IGxpc3RcbiAgICogaXRlbXMuXG4gICAqL1xuXG59O1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRyYW5zaXRpb25Hcm91cCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVHJhbnNpdGlvbkdyb3VwKHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpIHx8IHRoaXM7XG5cbiAgICB2YXIgaGFuZGxlRXhpdGVkID0gX3RoaXMuaGFuZGxlRXhpdGVkLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpOyAvLyBJbml0aWFsIGNoaWxkcmVuIHNob3VsZCBhbGwgYmUgZW50ZXJpbmcsIGRlcGVuZGVudCBvbiBhcHBlYXJcblxuXG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBoYW5kbGVFeGl0ZWQ6IGhhbmRsZUV4aXRlZCxcbiAgICAgIGZpcnN0UmVuZGVyOiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVHJhbnNpdGlvbkdyb3VwLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2l0aW9uR3JvdXA6IHtcbiAgICAgICAgaXNNb3VudGluZzogIXRoaXMuYXBwZWFyZWRcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuYXBwZWFyZWQgPSB0cnVlO1xuICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gIH07XG5cbiAgVHJhbnNpdGlvbkdyb3VwLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIF9yZWYpIHtcbiAgICB2YXIgcHJldkNoaWxkTWFwcGluZyA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICAgIGhhbmRsZUV4aXRlZCA9IF9yZWYuaGFuZGxlRXhpdGVkLFxuICAgICAgICBmaXJzdFJlbmRlciA9IF9yZWYuZmlyc3RSZW5kZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoaWxkcmVuOiBmaXJzdFJlbmRlciA/ICgwLCBfQ2hpbGRNYXBwaW5nLmdldEluaXRpYWxDaGlsZE1hcHBpbmcpKG5leHRQcm9wcywgaGFuZGxlRXhpdGVkKSA6ICgwLCBfQ2hpbGRNYXBwaW5nLmdldE5leHRDaGlsZE1hcHBpbmcpKG5leHRQcm9wcywgcHJldkNoaWxkTWFwcGluZywgaGFuZGxlRXhpdGVkKSxcbiAgICAgIGZpcnN0UmVuZGVyOiBmYWxzZVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZUV4aXRlZCA9IGZ1bmN0aW9uIGhhbmRsZUV4aXRlZChjaGlsZCwgbm9kZSkge1xuICAgIHZhciBjdXJyZW50Q2hpbGRNYXBwaW5nID0gKDAsIF9DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKSh0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICBpZiAoY2hpbGQua2V5IGluIGN1cnJlbnRDaGlsZE1hcHBpbmcpIHJldHVybjtcblxuICAgIGlmIChjaGlsZC5wcm9wcy5vbkV4aXRlZCkge1xuICAgICAgY2hpbGQucHJvcHMub25FeGl0ZWQobm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubW91bnRlZCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gX2V4dGVuZHMoe30sIHN0YXRlLmNoaWxkcmVuKTtcblxuICAgICAgICBkZWxldGUgY2hpbGRyZW5bY2hpbGQua2V5XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIENvbXBvbmVudCA9IF90aGlzJHByb3BzLmNvbXBvbmVudCxcbiAgICAgICAgY2hpbGRGYWN0b3J5ID0gX3RoaXMkcHJvcHMuY2hpbGRGYWN0b3J5LFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBbXCJjb21wb25lbnRcIiwgXCJjaGlsZEZhY3RvcnlcIl0pO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdmFsdWVzKHRoaXMuc3RhdGUuY2hpbGRyZW4pLm1hcChjaGlsZEZhY3RvcnkpO1xuICAgIGRlbGV0ZSBwcm9wcy5hcHBlYXI7XG4gICAgZGVsZXRlIHByb3BzLmVudGVyO1xuICAgIGRlbGV0ZSBwcm9wcy5leGl0O1xuXG4gICAgaWYgKENvbXBvbmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cblxuICAgIHJldHVybiBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgcHJvcHMsIGNoaWxkcmVuKTtcbiAgfTtcblxuICByZXR1cm4gVHJhbnNpdGlvbkdyb3VwO1xufShfcmVhY3QuZGVmYXVsdC5Db21wb25lbnQpO1xuXG5UcmFuc2l0aW9uR3JvdXAuY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHRyYW5zaXRpb25Hcm91cDogX3Byb3BUeXBlcy5kZWZhdWx0Lm9iamVjdC5pc1JlcXVpcmVkXG59O1xuVHJhbnNpdGlvbkdyb3VwLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHByb3BUeXBlcyA6IHt9O1xuVHJhbnNpdGlvbkdyb3VwLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxudmFyIF9kZWZhdWx0ID0gKDAsIF9yZWFjdExpZmVjeWNsZXNDb21wYXQucG9seWZpbGwpKFRyYW5zaXRpb25Hcm91cCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX3JlYWN0LXRyYW5zaXRpb24tZ3JvdXBAMi41LjJAcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9UcmFuc2l0aW9uR3JvdXAuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBJY29uIGZyb20gJy4uLy4uL2ljb24nO1xuaW1wb3J0IE92ZXJsYXkgZnJvbSAnLi4vLi4vb3ZlcmxheSc7XG5pbXBvcnQgeyBmdW5jLCBvYmosIGRvbSB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IEl0ZW0gZnJvbSAnLi9pdGVtJztcbmltcG9ydCBTZWxlY3RhYmxlSXRlbSBmcm9tICcuL3NlbGVjdGFibGUtaXRlbSc7XG5cbmNvbnN0IHsgYmluZEN0eCB9ID0gZnVuYztcbmNvbnN0IHsgc2V0U3R5bGUgfSA9IGRvbTtcbmNvbnN0IFBvcHVwID0gT3ZlcmxheS5Qb3B1cDtcblxuLyoqXG4gKiBNZW51LlBvcHVwSXRlbVxuICogQG9yZGVyIDJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9wdXBJdGVtIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgbWVudUNoaWxkVHlwZSA9ICdzdWJtZW51JztcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIF9rZXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHJvb3Q6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIGxldmVsOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBoYXNTdWJNZW51OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgcnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgc2VsZWN0YWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmoIfnrb7lhoXlrrlcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieW8ueWxguWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHRyaWdnZXJUeXBlOiBQcm9wVHlwZXMub25lT2YoWydjbGljaycsICdob3ZlciddKSxcbiAgICAgICAgYWxpZ246IFByb3BUeXBlcy5vbmVPZihbJ291dHNpZGUnLCAnZm9sbG93J10pLFxuICAgICAgICBhdXRvV2lkdGg6IFByb3BUeXBlcy5ib29sXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHNlbGVjdGFibGU6IGZhbHNlXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICBiaW5kQ3R4KHRoaXMsIFsgJ2hhbmRsZU9wZW4nLCAnaGFuZGxlUG9wdXBPcGVuJywgJ2hhbmRsZVBvcHVwQ2xvc2UnLCAnZ2V0UG9wdXAnXSk7XG4gICAgfVxuXG4gICAgZ2V0UG9wdXAocmVmKSB7XG4gICAgICAgIHRoaXMucG9wdXAgPSByZWY7XG4gICAgfVxuXG4gICAgZ2V0T3BlbigpIHtcbiAgICAgICAgY29uc3QgeyBfa2V5LCByb290IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IG9wZW5LZXlzIH0gPSByb290LnN0YXRlO1xuXG4gICAgICAgIHJldHVybiBvcGVuS2V5cy5pbmRleE9mKF9rZXkpID4gLTE7XG4gICAgfVxuXG4gICAgZ2V0UG9wdXBQcm9wcygpIHtcbiAgICAgICAgbGV0IHsgcG9wdXBQcm9wcyB9ID0gdGhpcy5wcm9wcy5yb290LnByb3BzO1xuICAgICAgICBpZiAodHlwZW9mIHBvcHVwUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHBvcHVwUHJvcHMgPSBwb3B1cFByb3BzKHRoaXMucHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3B1cFByb3BzO1xuICAgIH1cblxuICAgIGhhbmRsZU9wZW4ob3BlbiwgdHJpZ2dlclR5cGUsIGUpIHtcbiAgICAgICAgY29uc3QgeyBfa2V5LCByb290IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByb290LmhhbmRsZU9wZW4oX2tleSwgb3BlbiwgdHJpZ2dlclR5cGUsIGUpO1xuXG4gICAgICAgIGNvbnN0IHBvcHVwUHJvcHMgPSB0aGlzLnBvcHVwUHJvcHM7XG4gICAgICAgIHBvcHVwUHJvcHMub25WaXNpYmxlQ2hhbmdlICYmIHBvcHVwUHJvcHMub25WaXNpYmxlQ2hhbmdlKG9wZW4sIHRyaWdnZXJUeXBlLCBlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVQb3B1cE9wZW4oKSB7XG4gICAgICAgIGNvbnN0IHsgcm9vdCwgbGV2ZWwsIGFsaWduLCBhdXRvV2lkdGggfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgcG9wdXBBdXRvV2lkdGg6IHJvb3RQb3B1cEF1dG9XaWR0aCwgcG9wdXBBbGlnbjogcm9vdFBvcHVwQWxpZ24sIGRpcmVjdGlvbiB9ID0gcm9vdC5wcm9wcztcbiAgICAgICAgY29uc3QgcG9wdXBBbGlnbiA9IGFsaWduIHx8IHJvb3RQb3B1cEFsaWduO1xuICAgICAgICBjb25zdCBwb3B1cEF1dG9XaWR0aCA9ICdhdXRvV2lkdGgnIGluIHRoaXMucHJvcHMgPyBhdXRvV2lkdGggOiByb290UG9wdXBBdXRvV2lkdGg7XG4gICAgICAgIGNvbnN0IGl0ZW1Ob2RlID0gZmluZERPTU5vZGUodGhpcyk7XG4gICAgICAgIGNvbnN0IG1lbnVOb2RlID0gaXRlbU5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgdGhpcy5wb3B1cE5vZGUgPSB0aGlzLnBvcHVwLmdldEluc3RhbmNlKCkub3ZlcmxheS5nZXRJbnN0YW5jZSgpLmdldENvbnRlbnROb2RlKCk7XG4gICAgICAgIHJvb3QucG9wdXBOb2Rlcy5wdXNoKHRoaXMucG9wdXBOb2RlKTtcblxuICAgICAgICBpZiAocG9wdXBBdXRvV2lkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBkaXJlY3Rpb24gPT09ICdob3onICYmIGxldmVsID09PSAxID8gaXRlbU5vZGUgOiBtZW51Tm9kZTtcblxuICAgICAgICAgICAgaWYgKHRhcmdldE5vZGUub2Zmc2V0V2lkdGggPiB0aGlzLnBvcHVwTm9kZS5vZmZzZXRXaWR0aCkge1xuICAgICAgICAgICAgICAgIHNldFN0eWxlKHRoaXMucG9wdXBOb2RlLCAnd2lkdGgnLCBgJHt0YXJnZXROb2RlLm9mZnNldFdpZHRofXB4YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcHVwQWxpZ24gPT09ICdvdXRzaWRlJyAmJiAhKGRpcmVjdGlvbiA9PT0gJ2hveicgJiYgbGV2ZWwgPT09IDEpKSB7XG4gICAgICAgICAgICBzZXRTdHlsZSh0aGlzLnBvcHVwTm9kZSwgJ2hlaWdodCcsIGAke21lbnVOb2RlLm9mZnNldEhlaWdodH1weGApO1xuICAgICAgICAgICAgc2V0U3R5bGUodGhpcy5wb3B1cE5vZGUsICdvdmVyZmxvdy15JywgJ3Njcm9sbCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZUNsYXNzKHRoaXMucG9wdXBOb2RlLCBgJHtwcmVmaXh9aGlkZWApO1xuXG4gICAgICAgIGNvbnN0IHBvcHVwUHJvcHMgPSB0aGlzLnBvcHVwUHJvcHM7XG4gICAgICAgIHBvcHVwUHJvcHMub25PcGVuICYmIHBvcHVwUHJvcHMub25PcGVuKCk7XG4gICAgfVxuXG4gICAgaGFuZGxlUG9wdXBDbG9zZSgpIHtcbiAgICAgICAgY29uc3QgeyByb290IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBwb3B1cE5vZGVzID0gcm9vdC5wb3B1cE5vZGVzO1xuICAgICAgICBjb25zdCBpbmRleCA9IHBvcHVwTm9kZXMuaW5kZXhPZih0aGlzLnBvcHVwTm9kZSk7XG4gICAgICAgIGluZGV4ID4gLTEgJiYgcG9wdXBOb2Rlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgIGNvbnN0IHBvcHVwUHJvcHMgPSB0aGlzLnBvcHVwUHJvcHM7XG4gICAgICAgIHBvcHVwUHJvcHMub25DbG9zZSAmJiBwb3B1cFByb3BzLm9uQ2xvc2UoKTtcbiAgICB9XG5cbiAgICByZW5kZXJJdGVtKHNlbGVjdGFibGUsIGNoaWxkcmVuLCBvdGhlcnMpIHtcbiAgICAgICAgY29uc3QgeyBfa2V5LCByb290LCBsZXZlbCwgbGFiZWwsIGNsYXNzTmFtZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBwcmVmaXggfSA9IHJvb3QucHJvcHM7XG4gICAgICAgIGNvbnN0IE5ld0l0ZW0gPSBzZWxlY3RhYmxlID8gU2VsZWN0YWJsZUl0ZW0gOiBJdGVtO1xuICAgICAgICBjb25zdCBvcGVuID0gdGhpcy5nZXRPcGVuKCk7XG5cbiAgICAgICAgY29uc3QgaXRlbVByb3BzID0ge1xuICAgICAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiB0cnVlLFxuICAgICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBvcGVuLFxuICAgICAgICAgICAgX2tleSxcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgIHR5cGU6ICdzdWJtZW51J1xuICAgICAgICB9O1xuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgaXRlbVByb3BzLmNsYXNzTmFtZSA9IGN4KHtcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4fW9wZW5lZGBdOiB0cnVlLFxuICAgICAgICAgICAgICAgIFtjbGFzc05hbWVdOiAhIWNsYXNzTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtUHJvcHMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxOZXdJdGVtIHsuLi5pdGVtUHJvcHN9IHsuLi5vdGhlcnN9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YCR7cHJlZml4fW1lbnUtaXRlbS10ZXh0YH0+e2xhYmVsfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICA8L05ld0l0ZW0+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyUG9wdXAodHJpZ2dlciwgdHJpZ2dlclR5cGUsIHBvc2l0aW9uUHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IHsgcm9vdCwgbGV2ZWwsIHNlbGVjdGFibGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgZGlyZWN0aW9uIH0gPSByb290LnByb3BzO1xuICAgICAgICB0aGlzLnBvcHVwUHJvcHMgPSB0aGlzLmdldFBvcHVwUHJvcHMoKTtcbiAgICAgICAgY29uc3Qgb3BlbiA9IHRoaXMuZ2V0T3BlbigpO1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdob3onICYmIGxldmVsID09PSAxICYmIHNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uUHJvcHMudGFyZ2V0ID0gKCkgPT4gZmluZERPTU5vZGUodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPFBvcHVwIHJlZj17dGhpcy5nZXRQb3B1cH1cbiAgICAgICAgICAgICAgICB7Li4ucG9zaXRpb25Qcm9wc31cbiAgICAgICAgICAgICAgICB7Li4udGhpcy5wb3B1cFByb3BzfVxuICAgICAgICAgICAgICAgIGNhbkNsb3NlQnlFc2M9e2ZhbHNlfVxuICAgICAgICAgICAgICAgIHRyaWdnZXI9e3RyaWdnZXJ9XG4gICAgICAgICAgICAgICAgdHJpZ2dlclR5cGU9e3RyaWdnZXJUeXBlfVxuICAgICAgICAgICAgICAgIHZpc2libGU9e29wZW59XG4gICAgICAgICAgICAgICAgb25WaXNpYmxlQ2hhbmdlPXt0aGlzLmhhbmRsZU9wZW59XG4gICAgICAgICAgICAgICAgb25PcGVuPXt0aGlzLmhhbmRsZVBvcHVwT3Blbn1cbiAgICAgICAgICAgICAgICBvbkNsb3NlPXt0aGlzLmhhbmRsZVBvcHVwQ2xvc2V9PlxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgIDwvUG9wdXA+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHJvb3QsIGxldmVsLCBoYXNTdWJNZW51LCBzZWxlY3RhYmxlOiBzZWxlY3RhYmxlRnJvbVByb3BzLCBjaGlsZHJlbiwgdHJpZ2dlclR5cGUsIGFsaWduLCBydGwgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IG90aGVycyA9IG9iai5waWNrT3RoZXJzKE9iamVjdC5rZXlzKFBvcHVwSXRlbS5wcm9wVHlwZXMpLCB0aGlzLnByb3BzKTtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHNlbGVjdE1vZGUsIGRpcmVjdGlvbiwgcG9wdXBBbGlnbjogcm9vdFBvcHVwQWxpZ24sIHRyaWdnZXJUeXBlOiByb290VHJpZ2dlclR5cGUgfSA9IHJvb3QucHJvcHM7XG4gICAgICAgIGNvbnN0IHBvcHVwQWxpZ24gPSBhbGlnbiB8fCByb290UG9wdXBBbGlnbjtcbiAgICAgICAgY29uc3QgbmV3VHJpZ2dlclR5cGUgPSB0cmlnZ2VyVHlwZSB8fCAoaGFzU3ViTWVudSA/IHJvb3RUcmlnZ2VyVHlwZSA6ICdob3ZlcicpO1xuICAgICAgICBjb25zdCBuZXdDaGlsZHJlbiA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW5bMF0gOiBjaGlsZHJlbjtcbiAgICAgICAgLy8gbGV0IG5ld0NoaWxkcmVuID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlblswXSA6IGNoaWxkcmVuO1xuICAgICAgICAvLyBuZXdDaGlsZHJlbiA9IGNsb25lRWxlbWVudChuZXdDaGlsZHJlbiwge1xuICAgICAgICAvLyAgICAgY2xhc3NOYW1lOiBjeCh7XG4gICAgICAgIC8vICAgICAgICAgW2Ake3ByZWZpeH1tZW51LXBvcHVwLWNvbnRlbnRgXTogdHJ1ZSxcbiAgICAgICAgLy8gICAgICAgICBbbmV3Q2hpbGRyZW4ucHJvcHMuY2xhc3NOYW1lXTogISFuZXdDaGlsZHJlbi5wcm9wcy5jbGFzc05hbWUsXG4gICAgICAgIC8vICAgICAgICAgW2Ake3ByZWZpeH1oaWRlYF06IHBvcHVwQXV0b1dpZHRoIHx8IHBvcHVwQWxpZ24gPT09ICdvdXRzaWRlJ1xuICAgICAgICAvLyAgICAgfSlcbiAgICAgICAgLy8gfSk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGFibGUgPSBzZWxlY3RNb2RlICYmIHNlbGVjdGFibGVGcm9tUHJvcHM7XG4gICAgICAgIGNvbnN0IHRyaWdnZXJJc0ljb24gPSBzZWxlY3RhYmxlICYmIG5ld1RyaWdnZXJUeXBlID09PSAnY2xpY2snO1xuICAgICAgICBjb25zdCBvcGVuID0gdGhpcy5nZXRPcGVuKCk7XG5cbiAgICAgICAgY29uc3QgcG9zaXRpb25Qcm9wcyA9IHt9O1xuICAgICAgICBsZXQgYXJyb3dQcm9wcztcblxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnaG96JyAmJiBsZXZlbCA9PT0gMSkge1xuICAgICAgICAgICAgcG9zaXRpb25Qcm9wcy5hbGlnbiA9ICd0bCBibCc7XG4gICAgICAgICAgICBwb3NpdGlvblByb3BzLm9mZnNldCA9IFswLCAwXTtcblxuICAgICAgICAgICAgYXJyb3dQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXJyb3ctZG93bicsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjeCh7XG4gICAgICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9bWVudS1ob3otaWNvbi1hcnJvd2BdOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4fW9wZW5gXTogb3BlblxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwb3B1cEFsaWduID09PSAnb3V0c2lkZScpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvblByb3BzLnRhcmdldCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRET01Ob2RlKHJvb3QpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9zaXRpb25Qcm9wcy5hbGlnbiA9ICd0bCB0cic7XG5cbiAgICAgICAgICAgICAgICBydGwgP1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblByb3BzLm9mZnNldCA9IFstMiwgMF0gOlxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblByb3BzLm9mZnNldCA9IFsyLCAwXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJJc0ljb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25Qcm9wcy50YXJnZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluZERPTU5vZGUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uUHJvcHMuYWxpZ24gPSAndGwgdHInO1xuXG4gICAgICAgICAgICAgICAgcnRsID9cbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25Qcm9wcy5vZmZzZXQgPSBbMiwgLThdIDpcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25Qcm9wcy5vZmZzZXQgPSBbLTIsIC04XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXJyb3dQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXJyb3ctcmlnaHQnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogYCR7cHJlZml4fW1lbnUtaWNvbi1hcnJvd2BcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhcnJvdyA9IDxJY29uIHsuLi5hcnJvd1Byb3BzfSAvPjtcbiAgICAgICAgY29uc3QgdHJpZ2dlciA9IHRyaWdnZXJJc0ljb24gPyBhcnJvdyA6IHRoaXMucmVuZGVySXRlbShzZWxlY3RhYmxlLCBhcnJvdywgb3RoZXJzKTtcbiAgICAgICAgY29uc3QgcG9wdXAgPSB0aGlzLnJlbmRlclBvcHVwKHRyaWdnZXIsIG5ld1RyaWdnZXJUeXBlLCBwb3NpdGlvblByb3BzLCBuZXdDaGlsZHJlbik7XG4gICAgICAgIHJldHVybiB0cmlnZ2VySXNJY29uID8gdGhpcy5yZW5kZXJJdGVtKHNlbGVjdGFibGUsIHBvcHVwLCBvdGhlcnMpIDogcG9wdXA7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21lbnUvdmlldy9wb3B1cC1pdGVtLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENoZWNrYm94IGZyb20gJy4uLy4uL2NoZWNrYm94JztcbmltcG9ydCBSYWRpbyBmcm9tICcuLi8uLi9yYWRpbyc7XG5pbXBvcnQgeyBmdW5jLCBvYmosIEtFWUNPREUgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCBJdGVtIGZyb20gJy4vaXRlbSc7XG5cbmNvbnN0IG5vb3AgPSB7fTtcbmNvbnN0IHsgYmluZEN0eCB9ID0gZnVuYztcbmNvbnN0IHsgcGlja090aGVycyB9ID0gb2JqO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGVja2FibGVJdGVtIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBfa2V5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICByb290OiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGlubGluZUluZGVudDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgY2hlY2tlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGluZGV0ZXJtaW5hdGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGNoZWNrVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnY2hlY2tib3gnLCAncmFkaW8nXSksXG4gICAgICAgIGNoZWNrRGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBoZWxwZXI6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIG9uS2V5RG93bjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgY2hlY2tlZDogZmFsc2UsXG4gICAgICAgIGluZGV0ZXJtaW5hdGU6IGZhbHNlLFxuICAgICAgICBjaGVja1R5cGU6ICdjaGVja2JveCcsXG4gICAgICAgIGNoZWNrRGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBvbkNoYW5nZTogbm9vcFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgYmluZEN0eCh0aGlzLCBbJ3N0b3BQcm9wYWdhdGlvbicsICdoYW5kbGVLZXlEb3duJywgJ2hhbmRsZUNsaWNrJ10pO1xuICAgIH1cblxuICAgIHN0b3BQcm9wYWdhdGlvbihlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgaGFuZGxlQ2hlY2soZSkge1xuICAgICAgICBjb25zdCB7IGNoZWNrVHlwZSwgY2hlY2tlZCwgb25DaGFuZ2UgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmICghKGNoZWNrVHlwZSA9PT0gJ3JhZGlvJyAmJiBjaGVja2VkKSkge1xuICAgICAgICAgICAgb25DaGFuZ2UoIWNoZWNrZWQsIGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlS2V5RG93bihlKSB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IEtFWUNPREUuU1BBQ0UgJiYgIXRoaXMucHJvcHMuY2hlY2tEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGVjayhlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJvcHMub25LZXlEb3duICYmIHRoaXMucHJvcHMub25LZXlEb3duKGUpO1xuICAgIH1cblxuICAgIGhhbmRsZUNsaWNrKGUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVDaGVjayhlKTtcblxuICAgICAgICB0aGlzLnByb3BzLm9uQ2xpY2sgJiYgdGhpcy5wcm9wcy5vbkNsaWNrKGUpO1xuICAgIH1cblxuICAgIHJlbmRlckNoZWNrKCkge1xuICAgICAgICBjb25zdCB7IHJvb3QsIGNoZWNrZWQsIGluZGV0ZXJtaW5hdGUsIGRpc2FibGVkLCBjaGVja1R5cGUsIGNoZWNrRGlzYWJsZWQsIG9uQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IGxhYmVsVG9nZ2xlQ2hlY2tlZCB9ID0gcm9vdC5wcm9wcztcbiAgICAgICAgY29uc3QgQ2hlY2sgPSBjaGVja1R5cGUgPT09ICdyYWRpbycgPyBSYWRpbyA6IENoZWNrYm94O1xuXG4gICAgICAgIGNvbnN0IGNoZWNrUHJvcHMgPSB7XG4gICAgICAgICAgICB0YWJJbmRleDogJy0xJyxcbiAgICAgICAgICAgIGNoZWNrZWQsXG4gICAgICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWQgfHwgY2hlY2tEaXNhYmxlZFxuICAgICAgICB9O1xuICAgICAgICBpZiAoY2hlY2tUeXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgICAgICBjaGVja1Byb3BzLmluZGV0ZXJtaW5hdGUgPSBpbmRldGVybWluYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGFiZWxUb2dnbGVDaGVja2VkKSB7XG4gICAgICAgICAgICBjaGVja1Byb3BzLm9uQ2hhbmdlID0gb25DaGFuZ2U7XG4gICAgICAgICAgICBjaGVja1Byb3BzLm9uQ2xpY2sgPSB0aGlzLnN0b3BQcm9wYWdhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8Q2hlY2sgey4uLmNoZWNrUHJvcHN9IC8+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IF9rZXksIHJvb3QsIGNoZWNrZWQsIGRpc2FibGVkLCBvbkNsaWNrLCBoZWxwZXIsIGNoaWxkcmVuIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgbGFiZWxUb2dnbGVDaGVja2VkIH0gPSByb290LnByb3BzO1xuICAgICAgICBjb25zdCBvdGhlcnMgPSBwaWNrT3RoZXJzKE9iamVjdC5rZXlzKENoZWNrYWJsZUl0ZW0ucHJvcFR5cGVzKSwgdGhpcy5wcm9wcyk7XG5cbiAgICAgICAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgICAgICAgICBfa2V5LFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgdHlwZTogJ2l0ZW0nLFxuICAgICAgICAgICAgb25DbGljayxcbiAgICAgICAgICAgIG9uS2V5RG93bjogdGhpcy5oYW5kbGVLZXlEb3duLFxuICAgICAgICAgICAgLi4ub3RoZXJzXG4gICAgICAgIH07XG4gICAgICAgIGlmIChsYWJlbFRvZ2dsZUNoZWNrZWQgJiYgIWRpc2FibGVkKSB7XG4gICAgICAgICAgICBuZXdQcm9wcy5vbkNsaWNrID0gdGhpcy5oYW5kbGVDbGljaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8SXRlbSBhcmlhLWNoZWNrZWQ9e2NoZWNrZWR9IHsuLi5uZXdQcm9wc30+XG4gICAgICAgICAgICAgICAge3RoaXMucmVuZGVyQ2hlY2soKX1cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Ake3ByZWZpeH1tZW51LWl0ZW0tdGV4dGB9PntjaGlsZHJlbn08L3NwYW4+XG4gICAgICAgICAgICAgICAge2hlbHBlciA/IDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9bWVudS1pdGVtLWhlbHBlcmB9PntoZWxwZXJ9PC9kaXY+IDogbnVsbH1cbiAgICAgICAgICAgIDwvSXRlbT5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWVudS92aWV3L2NoZWNrYWJsZS1pdGVtLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgVUlTdGF0ZSBmcm9tICcuLi9taXhpbi11aS1zdGF0ZSc7XG5pbXBvcnQgQ29uZmlnUHJvdmlkZXIgZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCBJY29uIGZyb20gJy4uL2ljb24nO1xuaW1wb3J0IHsgb2JqLCBmdW5jIH0gZnJvbSAnLi4vdXRpbCc7XG5cbmNvbnN0IG5vb3AgPSBmdW5jLm5vb3A7XG5mdW5jdGlvbiBpc0NoZWNrZWQoc2VsZWN0ZWRWYWx1ZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gc2VsZWN0ZWRWYWx1ZS5pbmRleE9mKHZhbHVlKSA+IC0xO1xufVxuLyoqXG4gKiBDaGVja2JveFxuICogQG9yZGVyIDFcbiAqL1xuY2xhc3MgQ2hlY2tib3ggZXh0ZW5kcyBVSVN0YXRlIHtcbiAgICBzdGF0aWMgZGlzcGxheU5hbWUgPSAnQ2hlY2tib3gnO1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieexu+WQjVxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICogY2hlY2tib3ggaWQsIOaMgui9veWcqGlucHV05LiKXG4gICAgICAgICAqL1xuICAgICAgICBpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieWGheaVm+agt+W8j1xuICAgICAgICAgKi9cbiAgICAgICAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpgInkuK3nirbmgIFcbiAgICAgICAgICovXG4gICAgICAgIGNoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6buY6K6k6YCJ5Lit54q25oCBXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0Q2hlY2tlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnpoHnlKhcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmAmui/h+WxnuaAp+mFjee9rmxhYmVs77yMXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja2JveCDnmoTkuK3pl7TnirbmgIHvvIzlj6rkvJrlvbHlk43liLAgQ2hlY2tib3gg55qE5qC35byP77yM5bm25LiN5b2x5ZON5YW2IGNoZWNrZWQg5bGe5oCnXG4gICAgICAgICAqL1xuICAgICAgICBpbmRldGVybWluYXRlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBDaGVja2JveCDnmoTpu5jorqTkuK3pl7TmgIHvvIzlj6rkvJrlvbHlk43liLAgQ2hlY2tib3gg55qE5qC35byP77yM5bm25LiN5b2x5ZON5YW2IGNoZWNrZWQg5bGe5oCnXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0SW5kZXRlcm1pbmF0ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnirbmgIHlj5jljJbml7bop6blj5HnmoTkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBjaGVja2VkIOaYr+WQpumAieS4rVxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIERvbSDkuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOm8oOagh+i/m+WFpWVudGVy5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRG9tIOS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgb25Nb3VzZUVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOm8oOagh+emu+W8gExlYXZl5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRG9tIOS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgb25Nb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBkZWZhdWx0Q2hlY2tlZDogZmFsc2UsXG4gICAgICAgIGRlZmF1bHRJbmRldGVybWluYXRlOiBmYWxzZSxcbiAgICAgICAgb25DaGFuZ2U6IG5vb3AsXG4gICAgICAgIG9uTW91c2VFbnRlcjogbm9vcCxcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBub29wLFxuICAgICAgICBwcmVmaXg6ICduZXh0LScsXG4gICAgfVxuXG4gICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBfX2dyb3VwX186IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBzZWxlY3RlZFZhbHVlOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICBsZXQgY2hlY2tlZCwgaW5kZXRlcm1pbmF0ZTtcbiAgICAgICAgaWYgKGNvbnRleHQuX19ncm91cF9fKSB7XG4gICAgICAgICAgICBpbmRldGVybWluYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBjaGVja2VkID0gaXNDaGVja2VkKGNvbnRleHQuc2VsZWN0ZWRWYWx1ZSwgcHJvcHMudmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCdjaGVja2VkJyBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGVja2VkID0gcHJvcHMuZGVmYXVsdENoZWNrZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgnaW5kZXRlcm1pbmF0ZScgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpbmRldGVybWluYXRlID0gcHJvcHMuaW5kZXRlcm1pbmF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZSA9IHByb3BzLmRlZmF1bHRJbmRldGVybWluYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGNoZWNrZWQsXG4gICAgICAgICAgICBpbmRldGVybWluYXRlLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSAgcHJvcHMuZGlzYWJsZWQgfHwgKGNvbnRleHQuX19ncm91cF9fICYmICgnZGlzYWJsZWQnIGluIGNvbnRleHQpICYmIGNvbnRleHQuZGlzYWJsZWQpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gdGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzLCBuZXh0Q29udGV4dCkge1xuICAgICAgICBpZiAobmV4dENvbnRleHQuX19ncm91cF9fKSB7XG4gICAgICAgICAgICBpZiAoJ3NlbGVjdGVkVmFsdWUnIGluIG5leHRDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IGlzQ2hlY2tlZChuZXh0Q29udGV4dC5zZWxlY3RlZFZhbHVlLCBuZXh0UHJvcHMudmFsdWUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVkID0gbmV4dFByb3BzLmRpc2FibGVkIHx8IChcbiAgICAgICAgICAgICAgICAnZGlzYWJsZWQnIGluIG5leHRDb250ZXh0ICYmXG4gICAgICAgICAgICAgICAgbmV4dENvbnRleHQuZGlzYWJsZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoJ2NoZWNrZWQnIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBuZXh0UHJvcHMuY2hlY2tlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdpbmRldGVybWluYXRlJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZTogbmV4dFByb3BzLmluZGV0ZXJtaW5hdGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZWQgPSBuZXh0UHJvcHMuZGlzYWJsZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCkge1xuICAgICAgICBjb25zdCB7IHNoYWxsb3dFcXVhbCB9ID0gb2JqO1xuICAgICAgICByZXR1cm4gIXNoYWxsb3dFcXVhbCh0aGlzLnByb3BzLCBuZXh0UHJvcHMpIHx8XG4gICAgICAgICAgICAhc2hhbGxvd0VxdWFsKHRoaXMuc3RhdGUsIG5leHRTdGF0ZSkgfHxcbiAgICAgICAgICAgICFzaGFsbG93RXF1YWwodGhpcy5jb250ZXh0LCBuZXh0Q29udGV4dCk7XG4gICAgfVxuXG4gICAgb25DaGFuZ2UoZSkge1xuICAgICAgICBjb25zdCBjaGVja2VkID0gZS50YXJnZXQuY2hlY2tlZDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnByb3BzLnZhbHVlO1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuX19ncm91cF9fKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQub25DaGFuZ2UodmFsdWUsIGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEoJ2NoZWNrZWQnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IGNoZWNrZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEoJ2luZGV0ZXJtaW5hdGUnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGluZGV0ZXJtaW5hdGU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKGNoZWNrZWQsIGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgICAgICBjb25zdCB7IGlkLCBjbGFzc05hbWUsIGNoaWxkcmVuLCBzdHlsZSwgbGFiZWwsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlLCBydGwsXG4gICAgICAgICAgICAuLi5vdGhlclByb3BzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBjaGVja2VkID0gISF0aGlzLnN0YXRlLmNoZWNrZWQ7XG4gICAgICAgIGNvbnN0IGRpc2FibGVkID0gdGhpcy5kaXNhYmxlZDtcbiAgICAgICAgY29uc3QgaW5kZXRlcm1pbmF0ZSA9ICEhdGhpcy5zdGF0ZS5pbmRldGVybWluYXRlO1xuICAgICAgICBjb25zdCBwcmVmaXggPSB0aGlzLmNvbnRleHQucHJlZml4IHx8IHRoaXMucHJvcHMucHJlZml4O1xuXG4gICAgICAgIGNvbnN0IG90aGVycyA9IG9iai5waWNrT3RoZXJzKENoZWNrYm94LnByb3BUeXBlcywgb3RoZXJQcm9wcyk7XG4gICAgICAgIGNvbnN0IG90aGVyc0RhdGEgPSBvYmoucGlja0F0dHJzV2l0aChvdGhlcnMsICdkYXRhLScpO1xuXG5cblxuICAgICAgICBsZXQgY2hpbGRJbnB1dCA9ICg8aW5wdXRcbiAgICAgICAgICAgIHsuLi5vYmoucGlja090aGVycyhDaGVja2JveC5wcm9wVHlwZXMsIG90aGVyUHJvcHMpfVxuICAgICAgICAgICAgaWQ9e2lkfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cbiAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZX1cbiAgICAgICAgICAgIGFyaWEtY2hlY2tlZD17aW5kZXRlcm1pbmF0ZSA/ICdtaXhlZCcgOiBjaGVja2VkfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtwcmVmaXh9Y2hlY2tib3gtaW5wdXRgfVxuICAgICAgICAvPik7XG5cbiAgICAgICAgLy8gZGlzYWJsZSDml6DnirbmgIHmk43kvZxcbiAgICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICAgICAgY2hpbGRJbnB1dCA9IHRoaXMuZ2V0U3RhdGVFbGVtZW50KGNoaWxkSW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNscyA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1jaGVja2JveC13cmFwcGVyYF06IHRydWUsXG4gICAgICAgICAgICBbY2xhc3NOYW1lXTogISFjbGFzc05hbWUsXG4gICAgICAgICAgICBjaGVja2VkLFxuICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICBpbmRldGVybWluYXRlLFxuICAgICAgICAgICAgW3RoaXMuZ2V0U3RhdGVDbGFzc05hbWUoKV06IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGxhYmVsQ2xzID0gYCR7cHJlZml4fWNoZWNrYm94LWxhYmVsYDtcbiAgICAgICAgY29uc3QgdHlwZSA9IGluZGV0ZXJtaW5hdGUgPyAnc2VtaS1zZWxlY3QnIDogJ3NlbGVjdCc7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxsYWJlbFxuICAgICAgICAgICAgICAgIHsuLi5vdGhlcnNEYXRhfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xzfVxuICAgICAgICAgICAgICAgIHN0eWxlPXtzdHlsZX1cbiAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXI9e29uTW91c2VFbnRlcn1cbiAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU9e29uTW91c2VMZWF2ZX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Ake3ByZWZpeH1jaGVja2JveGB9PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Ake3ByZWZpeH1jaGVja2JveC1pbm5lcmB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPEljb24gdHlwZT17dHlwZX0gc2l6ZT1cInhzXCIgY2xhc3NOYW1lPXtpbmRldGVybWluYXRlID8gJ3pvb21JbicgOiAnJ30gLz5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICB7Y2hpbGRJbnB1dH1cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAge1tsYWJlbCwgY2hpbGRyZW5dLm1hcCgoaXRlbSwgaSkgPT4gKGl0ZW0gPyA8c3BhbiBrZXk9e2l9IGNsYXNzTmFtZT17bGFiZWxDbHN9PntpdGVtfTwvc3Bhbj4gOiBudWxsKSl9XG4gICAgICAgICAgICA8L2xhYmVsPik7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb25maWdQcm92aWRlci5jb25maWcoQ2hlY2tib3gpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NoZWNrYm94L2NoZWNrYm94LmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IGZ1bmMgfSBmcm9tICcuLi91dGlsJztcblxuY29uc3QgeyBtYWtlQ2hhaW4gfSA9IGZ1bmM7XG4vLyBVSVN0YXRlIOS4uuS4gOS6m+eJueauiuWFg+e0oOeahOeKtuaAgeWTjeW6lOaPkOS+m+S6huagh+WHhueahOaWueW8j++8jFxuLy8g5bCk5YW26YCC5ZCIQ1NT5peg5rOV5a6M5YWo5a6a5Yi255qE5o6n5Lu277yM5q+U5aaCY2hlY2tib3jvvIxyYWRpb+etieOAglxuLy8g6Iul57uE5Lu2IGRpc2FibGUg5YiZ6Ieq6KGM5Yik5pat5piv5ZCm6ZyA6KaB57uR5a6a54q25oCB566h55CG44CCXG4vLyDms6jmhI/vvJpkaXNhYmxlIOS4jeS8muinpuWPkeS6i+S7tu+8jOivt+S9v+eUqHJlc2V0VUlTdGF0Zei/mOWOn+eKtuaAgVxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcHJvcC10eXBlcyAqL1xuY2xhc3MgVUlTdGF0ZSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge307XG4gICAgICAgIFsnX29uVUlGb2N1cycsICdfb25VSUJsdXInXS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgdGhpc1tpdGVtXSA9IHRoaXNbaXRlbV0uYmluZCh0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGJhc2Ug5LqL5Lu257uR5a6a55qE5YWD57SgXG4gICAgZ2V0U3RhdGVFbGVtZW50KGJhc2UpIHtcbiAgICAgICAgY29uc3QgeyBvbkZvY3VzLCBvbkJsdXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoYmFzZSwge1xuICAgICAgICAgICAgb25Gb2N1czogbWFrZUNoYWluKHRoaXMuX29uVUlGb2N1cywgb25Gb2N1cyksXG4gICAgICAgICAgICBvbkJsdXI6IG1ha2VDaGFpbih0aGlzLl9vblVJQmx1ciwgb25CbHVyKVxuICAgICAgICB9KTtcblxuICAgIH1cbiAgICAvLyDojrflj5bnirbmgIFjbGFzc25hbWVcbiAgICBnZXRTdGF0ZUNsYXNzTmFtZSgpIHtcbiAgICAgICAgY29uc3QgeyBmb2N1c2VkIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICByZXR1cm4gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICBmb2N1c2VkXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyDlpI3ljp/nirbmgIFcbiAgICByZXNldFVJU3RhdGUoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZm9jdXNlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfb25VSUZvY3VzKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZvY3VzZWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9vblVJQmx1cigpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBmb2N1c2VkOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFVJU3RhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWl4aW4tdWktc3RhdGUvaW5kZXguanN4IiwiaW1wb3J0IFJhZGlvIGZyb20gJy4vcmFkaW8nO1xuaW1wb3J0IFJhZGlvR3JvdXAgZnJvbSAnLi9yYWRpby1ncm91cCc7XG5cblJhZGlvLkdyb3VwID0gUmFkaW9Hcm91cDtcblxuZXhwb3J0IGRlZmF1bHQgUmFkaW87XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmFkaW8vaW5kZXguanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBVSVN0YXRlIGZyb20gJy4uL21peGluLXVpLXN0YXRlJztcbmltcG9ydCBDb25maWdQcm92aWRlciBmcm9tICcuLi9jb25maWctcHJvdmlkZXInO1xuaW1wb3J0IHsgb2JqLCBmdW5jIH0gZnJvbSAnLi4vdXRpbCc7XG5cbmNvbnN0IHsgbWFrZUNoYWluLCBub29wIH0gPSBmdW5jO1xuLyoqXG4gKiBSYWRpb1xuICogQG9yZGVyIDFcbiAqL1xuY2xhc3MgUmFkaW8gZXh0ZW5kcyBVSVN0YXRlIHtcbiAgICBzdGF0aWMgZGlzcGxheU5hbWUgPSAnUmFkaW8nO1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieexu+WQjVxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog57uE5Lu2aW5wdXTnmoRpZFxuICAgICAgICAgKi9cbiAgICAgICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnlhoXmlZvmoLflvI9cbiAgICAgICAgICovXG4gICAgICAgIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572ucmFkaW/mmK/lkKbpgInkuK1cbiAgICAgICAgICovXG4gICAgICAgIGNoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572ucmFkaW/mmK/lkKbpu5jorqTpgInkuK1cbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRDaGVja2VkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmAmui/h+WxnuaAp+mFjee9rmxhYmVsXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnirbmgIHlj5jljJbml7bop6blj5HnmoTkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBjaGVja2VkIOaYr+WQpumAieS4rVxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIERvbSDkuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOm8oOagh+i/m+WFpWVudGVy5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRG9tIOS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgb25Nb3VzZUVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOm8oOagh+emu+W8gOS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIERvbSDkuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIG9uTW91c2VMZWF2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByYWRpb+aYr+WQpuiiq+emgeeUqFxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICogcmFkaW8g55qEdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuYm9vbF0pLFxuICAgICAgICAvKipcbiAgICAgICAgICogbmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBvbkNoYW5nZTogbm9vcCxcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBub29wLFxuICAgICAgICBvbk1vdXNlRW50ZXI6IG5vb3AsXG4gICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICBwcmVmaXg6ICduZXh0LSdcbiAgICB9XG5cbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIF9fZ3JvdXBfXzogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGlzQnV0dG9uOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLmJvb2xdKSxcbiAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICBsZXQgY2hlY2tlZDtcbiAgICAgICAgaWYgKGNvbnRleHQuX19ncm91cF9fKSB7XG4gICAgICAgICAgICBjaGVja2VkID0gY29udGV4dC5zZWxlY3RlZFZhbHVlID09PSBwcm9wcy52YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICgnY2hlY2tlZCcgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tlZCA9IHByb3BzLmRlZmF1bHRDaGVja2VkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHsgY2hlY2tlZCB9O1xuXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSB0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCB8fCAgKGNvbnRleHQuX19ncm91cF9fICYmICgnZGlzYWJsZWQnIGluIGNvbnRleHQpICYmIGNvbnRleHQuZGlzYWJsZWQpO1xuXG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAgICAgIGlmIChuZXh0Q29udGV4dC5fX2dyb3VwX18pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0ZWRWYWx1ZSB9ID0gbmV4dENvbnRleHQ7XG4gICAgICAgICAgICBpZiAoJ3NlbGVjdGVkVmFsdWUnIGluIG5leHRDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IHNlbGVjdGVkVmFsdWUgPT09IG5leHRQcm9wcy52YWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgnY2hlY2tlZCcgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBjaGVja2VkOiBuZXh0UHJvcHMuY2hlY2tlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpc2FibGVkID0gbmV4dFByb3BzLmRpc2FibGVkIHx8ICAobmV4dENvbnRleHQuX19ncm91cF9fICYmICgnZGlzYWJsZWQnIGluIG5leHRDb250ZXh0KSAmJiBuZXh0Q29udGV4dC5kaXNhYmxlZCk7XG5cbiAgICAgICAgLy8gd2hlbiBkaXNhYmxlZCwgcmVzZXQgVUlTdGF0ZVxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgLy8gb25seSBjbGFzcyBoYXMgYW4gaW1wYWN0LCBubyBlZmZlY3Qgb24gdmlzdWFsXG4gICAgICAgICAgICB0aGlzLnJlc2V0VUlTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCkge1xuICAgICAgICBjb25zdCB7IHNoYWxsb3dFcXVhbCB9ID0gb2JqO1xuICAgICAgICByZXR1cm4gIXNoYWxsb3dFcXVhbCh0aGlzLnByb3BzLCBuZXh0UHJvcHMpIHx8XG4gICAgICAgICAgICAhc2hhbGxvd0VxdWFsKHRoaXMuc3RhdGUsIG5leHRTdGF0ZSkgfHxcbiAgICAgICAgICAgICFzaGFsbG93RXF1YWwodGhpcy5uZXh0Q29udGV4dCwgbmV4dENvbnRleHQpO1xuICAgIH1cblxuICAgIG9uQ2hhbmdlKGUpIHtcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9IGUudGFyZ2V0LmNoZWNrZWQ7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wcm9wcy52YWx1ZTtcblxuICAgICAgICBpZiAodGhpcy5jb250ZXh0Ll9fZ3JvdXBfXykge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0Lm9uQ2hhbmdlKHZhbHVlLCBlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmNoZWNrZWQgIT09IGNoZWNrZWQpIHtcbiAgICAgICAgICAgIGlmICghKCdjaGVja2VkJyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBjaGVja2VkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKGNoZWNrZWQsIGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgICAgICBjb25zdCB7IGlkLCBjbGFzc05hbWUsIGNoaWxkcmVuLCBzdHlsZSwgbGFiZWwsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlLCB0YWJJbmRleCwgcnRsLFxuICAgICAgICAgICAgLi4ub3RoZXJQcm9wcyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9ICEhdGhpcy5zdGF0ZS5jaGVja2VkO1xuICAgICAgICBjb25zdCBkaXNhYmxlZCA9IHRoaXMuZGlzYWJsZWQ7XG4gICAgICAgIGNvbnN0IGlzQnV0dG9uID0gdGhpcy5jb250ZXh0LmlzQnV0dG9uO1xuICAgICAgICBjb25zdCBwcmVmaXggPSB0aGlzLmNvbnRleHQucHJlZml4IHx8IHRoaXMucHJvcHMucHJlZml4O1xuXG4gICAgICAgIGNvbnN0IG90aGVycyA9IG9iai5waWNrT3RoZXJzKFJhZGlvLnByb3BUeXBlcywgb3RoZXJQcm9wcyk7XG4gICAgICAgIGNvbnN0IG90aGVyc0RhdGEgPSBvYmoucGlja0F0dHJzV2l0aChvdGhlcnMsICdkYXRhLScpO1xuXG5cbiAgICAgICAgbGV0IGlucHV0ID0gKDxpbnB1dFxuICAgICAgICAgICAgey4uLm9iai5waWNrT3RoZXJzKG90aGVyc0RhdGEsIG90aGVycyl9XG4gICAgICAgICAgICBpZD17aWR9XG4gICAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgICBjaGVja2VkPXtjaGVja2VkfVxuICAgICAgICAgICAgdHlwZT1cInJhZGlvXCJcbiAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uQ2hhbmdlfVxuICAgICAgICAgICAgYXJpYS1jaGVja2VkPXtjaGVja2VkfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtwcmVmaXh9cmFkaW8taW5wdXRgfVxuICAgICAgICAvPik7XG5cbiAgICAgICAgLy8gZGlzYWJsZWQgZG8gbm90IGhvdmUgZm9jdXMgc3RhdGVcbiAgICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICAgICAgaW5wdXQgPSB0aGlzLmdldFN0YXRlRWxlbWVudChpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbHMgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9cmFkaW9gXTogdHJ1ZSxcbiAgICAgICAgICAgIGNoZWNrZWQsXG4gICAgICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgICAgIFt0aGlzLmdldFN0YXRlQ2xhc3NOYW1lKCldOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbHNJbm5lciA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1yYWRpby1pbm5lcmBdOiB0cnVlLFxuICAgICAgICAgICAgcHJlc3M6IGNoZWNrZWQsXG4gICAgICAgICAgICB1bnByZXNzOiAhY2hlY2tlZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xzV3JhcHBlciA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1yYWRpby13cmFwcGVyYF06IHRydWUsXG4gICAgICAgICAgICBbY2xhc3NOYW1lXTogISFjbGFzc05hbWUsXG4gICAgICAgICAgICBjaGVja2VkLFxuICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICBbdGhpcy5nZXRTdGF0ZUNsYXNzTmFtZSgpXTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW5DbHMgPSBgJHtwcmVmaXh9cmFkaW8tbGFiZWxgO1xuXG4gICAgICAgIGNvbnN0IHJhZGlvQ29tcCA9ICFpc0J1dHRvbiA/XG4gICAgICAgICAgICAoPHNwYW4gY2xhc3NOYW1lPXtjbHN9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y2xzSW5uZXJ9Pjwvc3Bhbj5cbiAgICAgICAgICAgICAgICB7aW5wdXR9XG4gICAgICAgICAgICA8L3NwYW4+KSA6XG4gICAgICAgICAgICAoPHNwYW4gY2xhc3NOYW1lPXtgJHtwcmVmaXh9cmFkaW8tc2luZ2xlLWlucHV0YH0+XG4gICAgICAgICAgICAgICAge2lucHV0fVxuICAgICAgICAgICAgPC9zcGFuPik7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxsYWJlbFxuICAgICAgICAgICAgICAgIHsuLi5vdGhlcnNEYXRhfVxuICAgICAgICAgICAgICAgIHJvbGU9XCJyYWRpb1wiXG4gICAgICAgICAgICAgICAgZGlyPXtydGwgPyAncnRsJyA6ICdsdHInfVxuICAgICAgICAgICAgICAgIHN0eWxlPXtzdHlsZX1cbiAgICAgICAgICAgICAgICB0YWJJbmRleD17dGFiSW5kZXh9XG4gICAgICAgICAgICAgICAgYXJpYS1jaGVja2VkPXtjaGVja2VkfVxuICAgICAgICAgICAgICAgIGFyaWEtZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xzV3JhcHBlcn1cbiAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXI9e2Rpc2FibGVkID8gb25Nb3VzZUVudGVyIDogbWFrZUNoYWluKHRoaXMuX29uVUlNb3VzZUVudGVyLCBvbk1vdXNlRW50ZXIpfVxuICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17ZGlzYWJsZWQgPyBvbk1vdXNlTGVhdmUgOiBtYWtlQ2hhaW4odGhpcy5fb25VSU1vdXNlTGVhdmUsIG9uTW91c2VMZWF2ZSl9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge3JhZGlvQ29tcH1cbiAgICAgICAgICAgICAgICB7W2NoaWxkcmVuLCBsYWJlbF0ubWFwKChkLCBpKSA9PiBkICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICA8c3BhbiBrZXk9e2l9IGNsYXNzTmFtZT17Y2hpbGRyZW5DbHN9PntkfTwvc3Bhbj4gOiBudWxsKX1cbiAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb25maWdQcm92aWRlci5jb25maWcoUmFkaW8pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JhZGlvL3JhZGlvLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi4vLi4vaWNvbic7XG5pbXBvcnQgeyBLRVlDT0RFIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3ByZWZlci1zdGF0ZWxlc3MtZnVuY3Rpb24gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNvcnQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBzb3J0OiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBvblNvcnQ6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBkYXRhSW5kZXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGxvY2FsZTogUHJvcFR5cGVzLm9iamVjdFxuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBzb3J0OiB7fVxuICAgIH1cbiAgICAvLyDmuLLmn5PmjpLluo9cbiAgICByZW5kZXJTb3J0KCkge1xuICAgICAgICBjb25zdCB7cHJlZml4LCBzb3J0LCBkYXRhSW5kZXgsIGxvY2FsZX0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgc29ydFN0YXR1cyA9IHNvcnRbZGF0YUluZGV4XSxcbiAgICAgICAgICAgIG1hcCA9IHtcbiAgICAgICAgICAgICAgICBkZXNjOiAnZGVzY2VuZGluZycsXG4gICAgICAgICAgICAgICAgYXNjOiAnYXNjZW5kaW5nJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBpY29ucyA9IFsnYXNjJywgJ2Rlc2MnXS5tYXAoc29ydE9yZGVyID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cImphdmFzY3JpcHQ6O1wiXG4gICAgICAgICAgICAgICAgICAgIGtleT17c29ydE9yZGVyfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3NvcnRTdGF0dXMgPT09IHNvcnRPcmRlciA/ICdjdXJyZW50JyA6ICcnfT5cbiAgICAgICAgICAgICAgICAgICAgPEljb24gdHlwZT17bWFwW3NvcnRPcmRlcl19IHNpemU9XCJzbWFsbFwiLz5cbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPHNwYW4gcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgdGFiSW5kZXg9XCIwXCJcbiAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPXtsb2NhbGVbc29ydFN0YXR1c119XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtc29ydGB9XG4gICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVDbGljay5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgICAgIG9uS2V5RG93bj17dGhpcy5rZXlkb3duSGFuZGxlcn0+XG4gICAgICAgICAgICAgICAge2ljb25zfVxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGhhbmRsZUNsaWNrID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB7c29ydCwgZGF0YUluZGV4fSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHRoaXMub25Tb3J0KGRhdGFJbmRleCwgc29ydFtkYXRhSW5kZXhdID09PSAnZGVzYycgPyAnYXNjJyA6ICdkZXNjJyk7XG4gICAgfVxuXG4gICAga2V5ZG93bkhhbmRsZXIgPSBlID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IEtFWUNPREUuRU5URVIpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xpY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uU29ydCA9IChkYXRhSW5kZXgsIG9yZGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHNvcnQgPSB7fTtcbiAgICAgICAgc29ydFtkYXRhSW5kZXhdID0gb3JkZXI7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vblNvcnQoZGF0YUluZGV4LCBvcmRlciwgc29ydCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJTb3J0KCk7XG4gICAgfVxuXG59XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9iYXNlL3NvcnQuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBSb3cgZnJvbSAnLi4vZXhwYW5kZWQvcm93JztcblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcHJlZmVyLXN0YXRlbGVzcy1mdW5jdGlvbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VsZWN0aW9uUm93IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAuLi5Sb3cucHJvcFR5cGVzXG4gICAgfVxuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgLi4uUm93LmRlZmF1bHRQcm9wc1xuICAgIH1cblxuICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIHNlbGVjdGVkUm93S2V5czogUHJvcFR5cGVzLmFycmF5LFxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMqL1xuICAgICAgICBjb25zdCB7IGNsYXNzTmFtZSwgcmVjb3JkLCBwcmltYXJ5S2V5IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHNlbGVjdGVkUm93S2V5cyB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBjb25zdCBjbHMgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZFJvd0tleXMuaW5kZXhPZihyZWNvcmRbcHJpbWFyeUtleV0pID4gLTEsXG4gICAgICAgICAgICBbY2xhc3NOYW1lXTogY2xhc3NOYW1lXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKDxSb3cgey4uLnRoaXMucHJvcHN9IGNsYXNzTmFtZT17Y2xzfSAvPik7XG4gICAgfVxufVxuXG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9zZWxlY3Rpb24vcm93LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgbG9nIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgUm93IGZyb20gJy4uL2xvY2svcm93JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXhwYW5kZWRSb3cgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC4uLlJvdy5wcm9wVHlwZXNcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAuLi5Sb3cuZGVmYXVsdFByb3BzLFxuICAgIH1cblxuICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIG9wZW5Sb3dLZXlzOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIGV4cGFuZGVkUm93UmVuZGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgZXhwYW5kZWRSb3dJbmRlbnQ6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgbG9ja1R5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2xlZnQnLCAncmlnaHQnXSlcbiAgICB9XG5cbiAgICByZW5kZXJFeHBhbmRlZFJvdyhyZWNvcmQsIGluZGV4LCBjb2xTcGFuKSB7XG4gICAgICAgIGNvbnN0IHsgZXhwYW5kZWRSb3dSZW5kZXIsIGV4cGFuZGVkUm93SW5kZW50LCBvcGVuUm93S2V5cywgbG9ja1R5cGUgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgY29uc3QgeyBjb2x1bW5zLCBjZWxsUmVmIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAoZXhwYW5kZWRSb3dSZW5kZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJpbWFyeUtleSwgcHJlZml4IH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGxlZnRJbmRlbnQgPSBleHBhbmRlZFJvd0luZGVudFswXSxcbiAgICAgICAgICAgICAgICByaWdodEluZGVudCA9IGV4cGFuZGVkUm93SW5kZW50WzFdLFxuICAgICAgICAgICAgICAgIHRvdGFsSW5kZW50ID0gbGVmdEluZGVudCArIHJpZ2h0SW5kZW50LFxuICAgICAgICAgICAgICAgIHJlbmRlckNvbHMgPSAobnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlcjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaCg8dGQga2V5PXtpfSByZWY9eyhjZWxsKSA9PiBjZWxsUmVmKGluZGV4LCBpLCBjZWxsKX0+Jm5ic3A7PC90ZD4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodG90YWxJbmRlbnQgPiBjb2xTcGFuICYmICFsb2NrVHlwZSkge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuaW5nKCdJdFxcJ3Mgbm90IGFsbG93ZWQgZXhwYW5kZWRSb3dJbmRlbnQgaXMgbW9yZSB0aGFuIHRoZSBudW1iZXIgb2YgY29sdW1ucy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWZ0SW5kZW50IDwgY29sdW1ucy5sZW5ndGggJiYgbG9ja1R5cGUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuaW5nKCdleHBhbmRlZFJvd0luZGVudCBsZWZ0IGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGxlZnQgbG9jayBjb2x1bW5zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJpZ2h0SW5kZW50IDwgY29sdW1ucy5sZW5ndGggJiYgbG9ja1R5cGUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICBsb2cud2FybmluZygnZXhwYW5kZWRSb3dJbmRlbnQgcmlnaHQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgcmlnaHQgbG9jayBjb2x1bW5zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvY2tUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgb3BlblJvd0tleXMuaW5kZXhPZihyZWNvcmRbcHJpbWFyeUtleV0pID4gLTEgPyA8dHIgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtZXhwYW5kZWQtcm93YH0gIGtleT17YGV4cGFuZGVkLSR7aW5kZXh9YH0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQgY29sU3Bhbj17Y29sU3Bhbn0gcmVmPXsoY2VsbCkgPT4gY2VsbFJlZihpbmRleCwgMCwgY2VsbCl9PiZuYnNwOzwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+IDogbnVsbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZW50ID0gZXhwYW5kZWRSb3dSZW5kZXIocmVjb3JkLCBpbmRleCk7XG4gICAgICAgICAgICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IChcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1jZWxsLXdyYXBwZXJgfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtjb250ZW50fVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBvcGVuUm93S2V5cy5pbmRleE9mKHJlY29yZFtwcmltYXJ5S2V5XSkgPiAtMSA/IDx0ciBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1leHBhbmRlZC1yb3dgfSBrZXk9e2BleHBhbmRlZC0ke3JlY29yZFtwcmltYXJ5S2V5XSB8fCBpbmRleH1gfT5cbiAgICAgICAgICAgICAgICAgICAge3JlbmRlckNvbHMobGVmdEluZGVudCl9XG4gICAgICAgICAgICAgICAgICAgIDx0ZCBjb2xTcGFuPXtjb2xTcGFuIC0gdG90YWxJbmRlbnR9PlxuICAgICAgICAgICAgICAgICAgICAgICAge2NvbnRlbnR9XG4gICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIHtyZW5kZXJDb2xzKHJpZ2h0SW5kZW50KX1cbiAgICAgICAgICAgICAgICA8L3RyPiA6IG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMqL1xuICAgICAgICBjb25zdCB7IHJlY29yZCwgcm93SW5kZXgsIGNvbHVtbnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChyZWNvcmQuX19leHBhbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyRXhwYW5kZWRSb3cocmVjb3JkLCByb3dJbmRleCwgY29sdW1ucy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoPFJvdyB7Li4udGhpcy5wcm9wc30gLz4pO1xuICAgIH1cbn1cblxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvZXhwYW5kZWQvcm93LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJvdyBmcm9tICcuLi9iYXNlL3Jvdyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvY2tSb3cgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC4uLlJvdy5wcm9wVHlwZXNcbiAgICB9XG5cbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICBvblJvd01vdXNlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvblJvd01vdXNlTGVhdmU6IFByb3BUeXBlcy5mdW5jXG4gICAgfVxuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgLi4uUm93LmRlZmF1bHRQcm9wc1xuICAgIH1cblxuICAgIG9uTW91c2VFbnRlciA9IChyZWNvcmQsIGluZGV4LCBlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25Sb3dNb3VzZUVudGVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGNvbnN0IHsgb25Nb3VzZUVudGVyIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBvblJvd01vdXNlRW50ZXIgJiYgb25Sb3dNb3VzZUVudGVyKHJlY29yZCwgaW5kZXgsIGUpO1xuICAgICAgICBvbk1vdXNlRW50ZXIocmVjb3JkLCBpbmRleCwgZSk7XG4gICAgfVxuXG4gICAgb25Nb3VzZUxlYXZlID0gKHJlY29yZCwgaW5kZXgsIGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBvblJvd01vdXNlTGVhdmUgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgY29uc3QgeyBvbk1vdXNlTGVhdmUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIG9uUm93TW91c2VMZWF2ZSAmJiBvblJvd01vdXNlTGVhdmUocmVjb3JkLCBpbmRleCwgZSk7XG4gICAgICAgIG9uTW91c2VMZWF2ZShyZWNvcmQsIGluZGV4LCBlKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzKi9cbiAgICAgICAgcmV0dXJuICg8Um93IHsuLi50aGlzLnByb3BzfSBvbk1vdXNlRW50ZXI9e3RoaXMub25Nb3VzZUVudGVyfSBvbk1vdXNlTGVhdmU9e3RoaXMub25Nb3VzZUxlYXZlfSAvPik7XG4gICAgfVxufVxuXG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9sb2NrL3Jvdy5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBCb2R5Q29tcG9uZW50IGZyb20gJy4uL2Jhc2UvYm9keSc7XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3ByZWZlci1zdGF0ZWxlc3MtZnVuY3Rpb24gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpeGVkQm9keSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjb2xHcm91cDogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgb25TY3JvbGw6IFByb3BUeXBlcy5mdW5jXG4gICAgfVxuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgb25TY3JvbGw6ICgpID0+IHt9XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgZml4ZWRIZWFkZXI6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBtYXhCb2R5SGVpZ2h0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gICAgICAgIG9uQm9keVNjcm9sbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGdldE5vZGU6IFByb3BUeXBlcy5mdW5jLFxuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCB7IGdldE5vZGUgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgZ2V0Tm9kZSAmJiBnZXROb2RlKCdib2R5JywgZmluZERPTU5vZGUodGhpcykpO1xuICAgIH1cblxuICAgIG9uQm9keVNjcm9sbCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBvbkJvZHlTY3JvbGwgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgb25Cb2R5U2Nyb2xsICYmIG9uQm9keVNjcm9sbCgpO1xuICAgICAgICB0aGlzLnByb3BzLm9uU2Nyb2xsKCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGNsYXNzTmFtZSwgY29sR3JvdXAsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBtYXhCb2R5SGVpZ2h0LCBmaXhlZEhlYWRlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBjb25zdCBzdHlsZSA9IHt9O1xuICAgICAgICBpZiAoZml4ZWRIZWFkZXIpIHtcbiAgICAgICAgICAgIHN0eWxlLm1heEhlaWdodCA9IG1heEJvZHlIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICg8ZGl2IHN0eWxlPXtzdHlsZX0gY2xhc3NOYW1lPXtjbGFzc05hbWV9IG9uU2Nyb2xsPXt0aGlzLm9uQm9keVNjcm9sbH0+XG4gICAgICAgICAgICA8dGFibGU+XG4gICAgICAgICAgICAgICAge2NvbEdyb3VwfVxuICAgICAgICAgICAgICAgIDxCb2R5Q29tcG9uZW50IHsuLi5vdGhlcnN9IGNvbEdyb3VwPXtjb2xHcm91cH0vPlxuICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgPC9kaXY+KTtcbiAgICB9XG59XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9maXhlZC9ib2R5LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG4vKipcbiAqIFRhYmxlLkdyb3VwSGVhZGVyXG4gKiBAb3JkZXIgMlxuICoqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlzdEhlYWRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog6KGM5riy5p+T55qE6YC76L6RXG4gICAgICAgICAqL1xuICAgICAgICBjZWxsOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZWxlbWVudCwgUHJvcFR5cGVzLm5vZGUsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblnKhDaGlsZHJlbuS4iumdoua4suafk3NlbGVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgaGFzQ2hpbGRyZW5TZWxlY3Rpb246IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5ZyoR3JvdXBIZWFkZXLkuIrpnaLmuLLmn5NzZWxlY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIGhhc1NlbGVjdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgfVxuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgY2VsbDogKCkgPT4gJycsXG4gICAgICAgIGhhc1NlbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgaGFzQ2hpbGRyZW5TZWxlY3Rpb246IGZhbHNlXG4gICAgfTtcblxuICAgIHN0YXRpYyBfdHlwZU1hcmsgPSAnbGlzdEhlYWRlcic7XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9saXN0LWhlYWRlci5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuLyoqXG4gKiBUYWJsZS5Hcm91cEZvb3RlclxuICogQG9yZGVyIDNcbiAqKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RGb290ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOihjOa4suafk+eahOmAu+i+kVxuICAgICAgICAgKi9cbiAgICAgICAgY2VsbDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmVsZW1lbnQsIFByb3BUeXBlcy5ub2RlLCBQcm9wVHlwZXMuZnVuY10pXG4gICAgfVxuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgY2VsbDogKCkgPT4gJydcbiAgICB9O1xuXG4gICAgc3RhdGljIF90eXBlTWFyayA9ICdsaXN0Rm9vdGVyJztcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2xpc3QtZm9vdGVyLmpzeCIsImltcG9ydCAnLi4vYW5pbWF0ZS9zdHlsZS5qcyc7XG5pbXBvcnQgJy4vbWFpbi5zY3NzJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yYWRpby9zdHlsZS5qcyIsImltcG9ydCBDb25maWdQcm92aWRlciBmcm9tICcuLi9jb25maWctcHJvdmlkZXInO1xuaW1wb3J0IEJ1dHRvbiBmcm9tICcuL3ZpZXcvYnV0dG9uJztcbmltcG9ydCBCdXR0b25Hcm91cCBmcm9tICcuL3ZpZXcvZ3JvdXAnO1xuXG5CdXR0b24uR3JvdXAgPSBCdXR0b25Hcm91cDtcblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlnUHJvdmlkZXIuY29uZmlnKEJ1dHRvbiwge1xuICAgIHRyYW5zZm9ybTogKHByb3BzLCBkZXByZWNhdGVkKSA9PiB7XG4gICAgICAgIGlmICgnc2hhcGUnIGluIHByb3BzKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVkKCdzaGFwZScsICd0ZXh0IHwgd2FybmluZyB8IGdob3N0JywgJ0J1dHRvbicpO1xuXG4gICAgICAgICAgICBjb25zdCB7IHNoYXBlLCB0eXBlLCAuLi5vdGhlcnMgfSA9IHByb3BzO1xuXG4gICAgICAgICAgICBsZXQgbmV3VHlwZSA9IHR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2xpZ2h0JyB8fCB0eXBlID09PSAnZGFyaycgfHwgKHR5cGUgPT09ICdzZWNvbmRhcnknICYmIHNoYXBlID09PSAnd2FybmluZycpKSB7XG4gICAgICAgICAgICAgICAgbmV3VHlwZSA9ICdub3JtYWwnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZ2hvc3Q7XG4gICAgICAgICAgICBpZiAoc2hhcGUgPT09ICdnaG9zdCcpIHtcbiAgICAgICAgICAgICAgICBnaG9zdCA9ICh7XG4gICAgICAgICAgICAgICAgICAgIHByaW1hcnk6ICdkYXJrJyxcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kYXJ5OiAnZGFyaycsXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbDogJ2xpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgZGFyazogJ2RhcmsnLFxuICAgICAgICAgICAgICAgICAgICBsaWdodDogJ2xpZ2h0J1xuICAgICAgICAgICAgICAgIH0pW3R5cGUgfHwgQnV0dG9uLmRlZmF1bHRQcm9wcy50eXBlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHNoYXBlID09PSAndGV4dCc7XG4gICAgICAgICAgICBjb25zdCB3YXJuaW5nID0gc2hhcGUgPT09ICd3YXJuaW5nJztcblxuICAgICAgICAgICAgcHJvcHMgPSB7IHR5cGU6IG5ld1R5cGUsIGdob3N0LCB0ZXh0LCB3YXJuaW5nLCAuLi5vdGhlcnMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9idXR0b24vaW5kZXguanN4IiwiaW1wb3J0ICcuLi9pY29uL3N0eWxlLmpzJztcbmltcG9ydCAnLi9tYWluLnNjc3MnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2J1dHRvbi9zdHlsZS5qcyIsImltcG9ydCBBbmltYXRlIGZyb20gJy4vYW5pbWF0ZSc7XG5pbXBvcnQgRXhwYW5kIGZyb20gJy4vZXhwYW5kJztcblxuQW5pbWF0ZS5FeHBhbmQgPSBFeHBhbmQ7XG5cbmV4cG9ydCBkZWZhdWx0IEFuaW1hdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYW5pbWF0ZS9pbmRleC5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IE92ZXJsYXkgZnJvbSAnLi4vb3ZlcmxheSc7XG5pbXBvcnQgQ29uZmlnUHJvdmlkZXIgZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCB7b2JqLCBmdW5jfSBmcm9tICcuLi91dGlsJztcblxuLyoqIExvYWRpbmcgKi9cbmNsYXNzIExvYWRpbmcgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmoLflvI/liY3nvIBcbiAgICAgICAgICovXG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgdGlwOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ5YaF5a655L2N572uXG4gICAgICAgICAqIEBlbnVtZGVzYyDlh7rnjrDlnKjliqjnlLvlj7PovrksIOWHuueOsOWcqOWKqOeUu+S4i+mdolxuICAgICAgICAgKi9cbiAgICAgICAgdGlwQWxpZ246IFByb3BUeXBlcy5vbmVPZihbJ3JpZ2h0JywgJ2JvdHRvbSddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGxvYWRpbmcg54q25oCBLCDpu5jorqQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmlzaWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIG9uVmlzaWJsZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYljbGFzc1xuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ5YaF6IGU5qC35byPXG4gICAgICAgICAqL1xuICAgICAgICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruWKqOeUu+WwuuWvuFxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g5LuF5LuF5a+56buY6K6k5Yqo55S75pWI5p6c6LW35L2c55SoXG4gICAgICAgICAqIEBlbnVtZGVzYyDlpKflj7csIOS4reWPt1xuICAgICAgICAgKi9cbiAgICAgICAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsnbGFyZ2UnLCAnbWVkaXVtJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ5Yqo55S7XG4gICAgICAgICAqL1xuICAgICAgICBpbmRpY2F0b3I6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliqjnlLvpopzoibJcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog5YWo5bGP5bGV56S6XG4gICAgICAgICAqL1xuICAgICAgICBmdWxsU2NyZWVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWtkOWFg+e0oFxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHByZWZpeDogJ25leHQtJyxcbiAgICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgb25WaXNpYmxlQ2hhbmdlOiBmdW5jLm5vb3AsXG4gICAgICAgIGFuaW1hdGU6IG51bGwsXG4gICAgICAgIHRpcEFsaWduOiAnYm90dG9tJyxcbiAgICAgICAgc2l6ZTogJ2xhcmdlJyxcbiAgICB9O1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB0aXAsXG4gICAgICAgICAgICB2aXNpYmxlLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICAgIGluZGljYXRvcixcbiAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgZnVsbFNjcmVlbixcbiAgICAgICAgICAgIG9uVmlzaWJsZUNoYW5nZSxcbiAgICAgICAgICAgIHRpcEFsaWduLFxuICAgICAgICAgICAgc2l6ZVxuICAgICAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBsZXQgaW5kaWNhdG9yRG9tID0gbnVsbDtcbiAgICAgICAgY29uc3QgZG90Q2xzID0gYCR7cHJlZml4fWxvYWRpbmctZG90YDtcblxuICAgICAgICBpZiAoaW5kaWNhdG9yKSB7XG4gICAgICAgICAgICBpbmRpY2F0b3JEb20gPSBpbmRpY2F0b3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgIGNvbnN0IGZ1c2lvblJlYWN0b3JDbHMgPSBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4fWxvYWRpbmctZnVzaW9uLXJlYWN0b3JgXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4fWxvYWRpbmctbWVkaXVtLWZ1c2lvbi1yZWFjdG9yYF06IHNpemUgPT09ICdtZWRpdW0nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbmRpY2F0b3JEb20gPSAoPGRpdiBjbGFzc05hbWU9e2Z1c2lvblJlYWN0b3JDbHN9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17ZG90Q2xzfSBzdHlsZT17e2JhY2tncm91bmRDb2xvcn19Pjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2RvdENsc30gc3R5bGU9e3tiYWNrZ3JvdW5kQ29sb3J9fT48L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtkb3RDbHN9IHN0eWxlPXt7YmFja2dyb3VuZENvbG9yfX0+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17ZG90Q2xzfSBzdHlsZT17e2JhY2tncm91bmRDb2xvcn19Pjwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2Pik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb2FkaW5nQ2xzID0gY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fWxvYWRpbmdgXTogdHJ1ZSxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9b3BlbmBdOiB2aXNpYmxlLFxuICAgICAgICAgICAgW2NsYXNzTmFtZV06IGNsYXNzTmFtZVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB0aXBDbHMgPSBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9bG9hZGluZy10aXBgXTogdHJ1ZSxcbiAgICAgICAgICAgIC8vIOm7mOiupOmdniByaWdodOWwseaYryBib3R0b21cbiAgICAgICAgICAgIFtgJHtwcmVmaXh9bG9hZGluZy1yaWdodC10aXBgXTogdGlwQWxpZ24gPT09ICdyaWdodCcsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG90aGVycyA9IG9iai5waWNrT3RoZXJzKExvYWRpbmcucHJvcFR5cGVzLCB0aGlzLnByb3BzKTtcblxuICAgICAgICBjb25zdCBjb250ZW50Q2xzID0gY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fWxvYWRpbmctY29tcG9uZW50YF06IHZpc2libGUsXG4gICAgICAgICAgICBbYCR7cHJlZml4fWxvYWRpbmctd3JhcGBdOiB0cnVlLFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZnVsbFNjcmVlbiA/XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgPE92ZXJsYXkga2V5PVwib3ZlcmxheVwiIGhhc01hc2sgYWxpZ249XCJjYyBjY1wiIHsuLi5vdGhlcnN9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17c3R5bGV9XG4gICAgICAgICAgICAgICAgICAgIHZpc2libGU9e3Zpc2libGV9XG4gICAgICAgICAgICAgICAgICAgIG9uUmVxdWVzdENsb3NlPXtvblZpc2libGVDaGFuZ2V9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17dGlwQ2xzfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9bG9hZGluZy1pbmRpY2F0b3JgfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aW5kaWNhdG9yRG9tfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fWxvYWRpbmctdGlwLWNvbnRlbnRgfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGlwfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICB7Lyog55Sx5LqO5pKR5byA6Zeu6aKYIOS9v+eUqOWQjOagt+eahOS4pOS4qkRPTSAqL31cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9bG9hZGluZy10aXAtcGxhY2Vob2xkZXJgfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGlwfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvT3ZlcmxheT5cbiAgICAgICAgICAgIF0gOiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2xvYWRpbmdDbHN9IHN0eWxlPXtzdHlsZX0gey4uLm90aGVyc30+XG4gICAgICAgICAgICAgICAgICAgIHt2aXNpYmxlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICg8ZGl2IGNsYXNzTmFtZT17dGlwQ2xzfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7cHJlZml4fWxvYWRpbmctaW5kaWNhdG9yYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpbmRpY2F0b3JEb219XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH1sb2FkaW5nLXRpcC1jb250ZW50YH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aXB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3ByZWZpeH1sb2FkaW5nLXRpcC1wbGFjZWhvbGRlcmB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGlwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+KSA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y29udGVudENsc30+XG4gICAgICAgICAgICAgICAgICAgICAgICB7dmlzaWJsZSA/IDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9bG9hZGluZy1tYXNrZXJgfT48L2Rpdj4gOiBudWxsfVxuICAgICAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb25maWdQcm92aWRlci5jb25maWcoTG9hZGluZyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbG9hZGluZy9pbmRleC5qc3giLCJpbXBvcnQgQ29uZmlnUHJvdmlkZXIgZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCBNZW51IGZyb20gJy4vdmlldy9tZW51JztcbmltcG9ydCBTdWJNZW51IGZyb20gJy4vdmlldy9zdWItbWVudSc7XG5pbXBvcnQgU2VsZWN0YWJsZUl0ZW0gZnJvbSAnLi92aWV3L3NlbGVjdGFibGUtaXRlbSc7XG5pbXBvcnQgQ2hlY2tib3hJdGVtIGZyb20gJy4vdmlldy9jaGVja2JveC1pdGVtJztcbmltcG9ydCBSYWRpb0l0ZW0gZnJvbSAnLi92aWV3L3JhZGlvLWl0ZW0nO1xuaW1wb3J0IFBvcHVwSXRlbSBmcm9tICcuL3ZpZXcvcG9wdXAtaXRlbSc7XG5pbXBvcnQgR3JvdXAgZnJvbSAnLi92aWV3L2dyb3VwJztcbmltcG9ydCBEaXZpZGVyIGZyb20gJy4vdmlldy9kaXZpZGVyJztcbmltcG9ydCBjcmVhdGUgZnJvbSAnLi92aWV3L2NyZWF0ZSc7XG5cbk1lbnUuU3ViTWVudSA9IFN1Yk1lbnU7XG5NZW51Lkl0ZW0gPSBTZWxlY3RhYmxlSXRlbTtcbk1lbnUuQ2hlY2tib3hJdGVtID0gQ2hlY2tib3hJdGVtO1xuTWVudS5SYWRpb0l0ZW0gPSBSYWRpb0l0ZW07XG5NZW51LlBvcHVwSXRlbSA9IFBvcHVwSXRlbTtcbk1lbnUuR3JvdXAgPSBHcm91cDtcbk1lbnUuRGl2aWRlciA9IERpdmlkZXI7XG5NZW51LmNyZWF0ZSA9IGNyZWF0ZTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IHRyYW5zZm9ybSA9IChwcm9wcywgZGVwcmVjYXRlZCkgPT4ge1xuICAgIGlmICgnaW5kZW50U2l6ZScgaW4gcHJvcHMpIHtcbiAgICAgICAgZGVwcmVjYXRlZCgnaW5kZW50U2l6ZScsICdpbmxpbmVJbmRlbnQnLCAnTWVudScpO1xuXG4gICAgICAgIGNvbnN0IHsgaW5kZW50U2l6ZSwgLi4ub3RoZXJzIH0gPSBwcm9wcztcbiAgICAgICAgcHJvcHMgPSB7IGlubGluZUluZGVudDogaW5kZW50U2l6ZSwgLi4ub3RoZXJzIH07XG4gICAgfVxuXG4gICAgaWYgKCdvbkRlc2VsZWN0JyBpbiBwcm9wcykge1xuICAgICAgICBkZXByZWNhdGVkKCdvbkRlc2VsZWN0JywgJ29uU2VsZWN0JywgJ01lbnUnKTtcbiAgICAgICAgaWYgKHByb3BzLm9uRGVzZWxlY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25EZXNlbGVjdCwgb25TZWxlY3QsIC4uLm90aGVycyB9ID0gcHJvcHM7XG4gICAgICAgICAgICBjb25zdCBuZXdPblNlbGVjdCA9IChzZWxlY3RlZEtleXMsIGl0ZW0sIGV4dHJhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFleHRyYS5zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgb25EZXNlbGVjdChleHRyYS5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob25TZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Qoc2VsZWN0ZWRLZXlzLCBpdGVtLCBleHRyYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcHJvcHMgPSB7IG9uU2VsZWN0OiBuZXdPblNlbGVjdCwgLi4ub3RoZXJzIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHM7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDb25maWdQcm92aWRlci5jb25maWcoTWVudSwge1xuICAgIHRyYW5zZm9ybVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWVudS9pbmRleC5qc3giLCJpbXBvcnQgJy4uL2ljb24vc3R5bGUuanMnO1xuaW1wb3J0ICcuLi9hbmltYXRlL3N0eWxlLmpzJztcbmltcG9ydCAnLi4vcmFkaW8vc3R5bGUuanMnO1xuaW1wb3J0ICcuLi9jaGVja2JveC9zdHlsZS5qcyc7XG5pbXBvcnQgJy4vbWFpbi5zY3NzJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tZW51L3N0eWxlLmpzIiwiaW1wb3J0ICcuLi9pY29uL3N0eWxlLmpzJztcbmltcG9ydCAnLi4vYW5pbWF0ZS9zdHlsZS5qcyc7XG5pbXBvcnQgJy4uL292ZXJsYXkvc3R5bGUuanMnO1xuaW1wb3J0ICcuL21haW4uc2Nzcyc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbG9hZGluZy9zdHlsZS5qcyIsImltcG9ydCBDb25maWdQcm92aWRlciBmcm9tICcuLi9jb25maWctcHJvdmlkZXInO1xuaW1wb3J0IEJhc2UgZnJvbSAnLi9iYXNlJztcbmltcG9ydCB0cmVlIGZyb20gJy4vdHJlZSc7XG5pbXBvcnQgZml4ZWQgZnJvbSAnLi9maXhlZCc7XG5pbXBvcnQgc2VsZWN0aW9uIGZyb20gJy4vc2VsZWN0aW9uJztcbmltcG9ydCBleHBhbmRlZCBmcm9tICcuL2V4cGFuZGVkJztcbmltcG9ydCB2aXJ0dWFsIGZyb20gJy4vdmlydHVhbCc7XG5pbXBvcnQgbG9jayBmcm9tICcuL2xvY2snO1xuaW1wb3J0IGxpc3QgZnJvbSAnLi9saXN0JztcbmltcG9ydCBzdGlja3kgZnJvbSAnLi9zdGlja3knO1xuaW1wb3J0IExpc3RIZWFkZXIgZnJvbSAnLi9saXN0LWhlYWRlcic7XG5pbXBvcnQgTGlzdEZvb3RlciBmcm9tICcuL2xpc3QtZm9vdGVyJztcblxuY29uc3QgT1JERVJfTElTVCA9IFtmaXhlZCwgbG9jaywgc2VsZWN0aW9uLCBleHBhbmRlZCwgdHJlZSwgdmlydHVhbCwgbGlzdCwgc3RpY2t5XTtcbmNvbnN0IFRhYmxlID0gT1JERVJfTElTVC5yZWR1Y2UoKHJldCwgY3VycmVudCkgPT4ge1xuICAgIHJldCA9IGN1cnJlbnQocmV0KTtcbiAgICByZXR1cm4gcmV0O1xufSwgQmFzZSk7XG5UYWJsZS5CYXNlID0gQmFzZTtcblRhYmxlLmZpeGVkID0gZml4ZWQ7XG5UYWJsZS5sb2NrID0gbG9jaztcblRhYmxlLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcblRhYmxlLmV4cGFuZGVkID0gZXhwYW5kZWQ7XG5UYWJsZS50cmVlID0gdHJlZTtcblRhYmxlLnZpcnR1YWwgPSB2aXJ0dWFsO1xuVGFibGUubGlzdCA9IGxpc3Q7XG5UYWJsZS5zdGlja3kgPSBzdGlja3k7XG5cblRhYmxlLkdyb3VwSGVhZGVyID0gTGlzdEhlYWRlcjtcblRhYmxlLkdyb3VwRm9vdGVyID0gTGlzdEZvb3RlcjtcblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlnUHJvdmlkZXIuY29uZmlnKFRhYmxlLCB7XG4gICAgY29tcG9uZW50TmFtZTogJ1RhYmxlJyxcbiAgICB0cmFuc2Zvcm06IChwcm9wcywgZGVwcmVjYXRlZCkgPT4ge1xuICAgICAgICBpZiAoJ2V4cGFuZGVkUm93S2V5cycgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZWQoJ2V4cGFuZGVkUm93S2V5cycsICdvcGVuUm93S2V5cycsICdUYWJsZScpO1xuXG4gICAgICAgICAgICBjb25zdCB7IGV4cGFuZGVkUm93S2V5cywgLi4ub3RoZXJzIH0gPSBwcm9wcztcbiAgICAgICAgICAgIHByb3BzID0geyBvcGVuUm93S2V5czogZXhwYW5kZWRSb3dLZXlzLCAuLi5vdGhlcnMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ29uRXhwYW5kZWRDaGFuZ2UnIGluIHByb3BzKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVkKCdvbkV4cGFuZGVkQ2hhbmdlJywgJ29uUm93T3BlbicsICdUYWJsZScpO1xuXG4gICAgICAgICAgICBjb25zdCB7IG9uRXhwYW5kZWRDaGFuZ2UsIC4uLm90aGVycyB9ID0gcHJvcHM7XG4gICAgICAgICAgICBwcm9wcyA9IHsgb25Sb3dPcGVuOiBvbkV4cGFuZGVkQ2hhbmdlLCAuLi5vdGhlcnMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2lzTG9hZGluZycgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZWQoJ2lzTG9hZGluZycsICdsb2FkaW5nJywgJ1RhYmxlJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgaXNMb2FkaW5nLCAuLi5vdGhlcnMgfSA9IHByb3BzO1xuICAgICAgICAgICAgcHJvcHMgPSB7IGxvYWRpbmc6IGlzTG9hZGluZywgLi4ub3RoZXJzIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdpbmRlbnRTaXplJyBpbiBwcm9wcykge1xuICAgICAgICAgICAgZGVwcmVjYXRlZCgnaW5kZW50U2l6ZScsICdpbmRlbnQnLCAnVGFibGUnKTtcblxuICAgICAgICAgICAgY29uc3QgeyBpbmRlbnRTaXplLCAuLi5vdGhlcnMgfSA9IHByb3BzO1xuICAgICAgICAgICAgcHJvcHMgPSB7IGluZGVudDogaW5kZW50U2l6ZSwgLi4ub3RoZXJzIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdvcHRpbWl6YXRpb24nIGluIHByb3BzKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVkKCdvcHRpbWl6YXRpb24nLCAncHVyZScsICdUYWJsZScpO1xuXG4gICAgICAgICAgICBjb25zdCB7IG9wdGltaXphdGlvbiwgLi4ub3RoZXJzIH0gPSBwcm9wcztcbiAgICAgICAgICAgIHByb3BzID0geyBwdXJlOiBvcHRpbWl6YXRpb24sIC4uLm90aGVycyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZ2V0Um93Q2xhc3NOYW1lJyBpbiBwcm9wcykge1xuICAgICAgICAgICAgZGVwcmVjYXRlZCgnZ2V0Um93Q2xhc3NOYW1lJywgJ2dldFJvd1Byb3BzJywgJ1RhYmxlJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgZ2V0Um93Q2xhc3NOYW1lLCBnZXRSb3dQcm9wcywgLi4ub3RoZXJzIH0gPSBwcm9wcztcbiAgICAgICAgICAgIGlmIChnZXRSb3dDbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdHZXRSb3dQcm9wcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGdldFJvd0NsYXNzTmFtZSguLi5hcmdzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLihnZXRSb3dQcm9wcyA/IGdldFJvd1Byb3BzKC4uLmFyZ3MpIDoge30pXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHByb3BzID0geyBnZXRSb3dQcm9wczogbmV3R2V0Um93UHJvcHMsIC4uLm90aGVycyB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9wcyA9IHsgZ2V0Um93UHJvcHMsIC4uLm90aGVycyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2luZGV4LmpzeCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSAgKyAnYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJyArIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSArICcgYXQgaW5kZXggJyArIGkgKyAnLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb21cbiAgICAgIC8vIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX3Byb3AtdHlwZXNAMTUuNi4yQHByb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19vYmplY3QtYXNzaWduQDQuMS4xQG9iamVjdC1hc3NpZ24vaW5kZXguanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgIClcblxuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnRmFpbGVkICcgKyBsb2NhdGlvbiArICcgdHlwZTogJyArIGVycm9yLm1lc3NhZ2UgKyAoc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19wcm9wLXR5cGVzQDE1LjYuMkBwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgdGhyb3cgZXJyO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYm9vbDogc2hpbSxcbiAgICBmdW5jOiBzaGltLFxuICAgIG51bWJlcjogc2hpbSxcbiAgICBvYmplY3Q6IHNoaW0sXG4gICAgc3RyaW5nOiBzaGltLFxuICAgIHN5bWJvbDogc2hpbSxcblxuICAgIGFueTogc2hpbSxcbiAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgIGVsZW1lbnQ6IHNoaW0sXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICBub2RlOiBzaGltLFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICAgIG9uZU9mOiBnZXRTaGltLFxuICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcbiAgICBzaGFwZTogZ2V0U2hpbSxcbiAgICBleGFjdDogZ2V0U2hpbVxuICB9O1xuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZW1wdHlGdW5jdGlvbjtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fcHJvcC10eXBlc0AxNS42LjJAcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBob2lzdE5vblJlYWN0U3RhdGljIGZyb20gJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJztcbmltcG9ydCB7IG9iaiwgbG9nIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgZ2V0Q29udGV4dFByb3BzIGZyb20gJy4vZ2V0LWNvbnRleHQtcHJvcHMnO1xuXG5jb25zdCB7IHNoYWxsb3dFcXVhbCB9ID0gb2JqO1xuXG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShDb21wb25lbnQpIHtcbiAgICByZXR1cm4gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xufVxuXG5sZXQgZ2xvYmFsTG9jYWxlcztcbmxldCBjdXJyZW50R2xvYmFsTGFuZ3VhZ2UgPSAnemgtY24nO1xubGV0IGN1cnJlbnRHbG9iYWxMb2NhbGUgPSB7fTtcbmxldCBjdXJyZW50R2xvYmFsUnRsID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0TG9jYWxlcyhsb2NhbGVzKSB7XG4gICAgZ2xvYmFsTG9jYWxlcyA9IGxvY2FsZXM7XG4gICAgY3VycmVudEdsb2JhbExvY2FsZSA9IGxvY2FsZXNbY3VycmVudEdsb2JhbExhbmd1YWdlXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldExhbmd1YWdlKGxhbmd1YWdlKSB7XG4gICAgaWYgKGdsb2JhbExvY2FsZXMpIHtcbiAgICAgICAgY3VycmVudEdsb2JhbExhbmd1YWdlID0gbGFuZ3VhZ2U7XG4gICAgICAgIGN1cnJlbnRHbG9iYWxMb2NhbGUgPSBnbG9iYWxMb2NhbGVzW2xhbmd1YWdlXTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRMb2NhbGUobG9jYWxlKSB7XG4gICAgY3VycmVudEdsb2JhbExvY2FsZSA9IHtcbiAgICAgICAgLi4uKGdsb2JhbExvY2FsZXMgPyBnbG9iYWxMb2NhbGVzW2N1cnJlbnRHbG9iYWxMYW5ndWFnZV0gOiB7fSksXG4gICAgICAgIC4uLmxvY2FsZVxuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXREaXJlY3Rpb24oZGlyKSB7XG4gICAgY3VycmVudEdsb2JhbFJ0bCA9IGRpciA9PT0gJ3J0bCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhbGUoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRHbG9iYWxMb2NhbGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYW5ndWFnZSgpIHtcbiAgICByZXR1cm4gY3VycmVudEdsb2JhbExhbmd1YWdlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKCkge1xuICAgIHJldHVybiBjdXJyZW50R2xvYmFsUnRsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29uZmlnKENvbXBvbmVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKENvbXBvbmVudC5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUoXG4gICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICBuZXh0U3RhdGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5wdXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgIXNoYWxsb3dFcXVhbCh0aGlzLnByb3BzLCBuZXh0UHJvcHMpIHx8XG4gICAgICAgICAgICAgICAgICAgICFzaGFsbG93RXF1YWwodGhpcy5zdGF0ZSwgbmV4dFN0YXRlKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNsYXNzIENvbmZpZ2VkQ29tcG9uZW50IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAgICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgICAgIC4uLihDb21wb25lbnQucHJvcFR5cGVzIHx8IHt9KSxcbiAgICAgICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgICAgIGxvY2FsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgICAgIHB1cmU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAgICAgcnRsOiBQcm9wVHlwZXMuYm9vbFxuICAgICAgICB9O1xuICAgICAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICAgICAgLi4uKENvbXBvbmVudC5jb250ZXh0VHlwZXMgfHwge30pLFxuICAgICAgICAgICAgbmV4dFByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgICAgIG5leHRMb2NhbGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgICAgICBuZXh0UHVyZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgICAgICBuZXh0UnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgICAgIG5leHRXYXJuaW5nOiBQcm9wVHlwZXMuYm9vbFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2dldEluc3RhbmNlID0gdGhpcy5fZ2V0SW5zdGFuY2UuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2RlcHJlY2F0ZWQgPSB0aGlzLl9kZXByZWNhdGVkLmJpbmQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBfZ2V0SW5zdGFuY2UocmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IHJlZjtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlICYmIG9wdGlvbnMuZXhwb3J0TmFtZXMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmV4cG9ydE5hbWVzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5faW5zdGFuY2VbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmllbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBmaWVsZC5iaW5kKHRoaXMuX2luc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBmaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX2RlcHJlY2F0ZWQoLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5uZXh0V2FybmluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBsb2cuZGVwcmVjYXRlZCguLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdldEluc3RhbmNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyKCkge1xuICAgICAgICAgICAgY29uc3QgeyBwcmVmaXgsIGxvY2FsZSwgcHVyZSwgcnRsLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgbmV4dFByZWZpeCxcbiAgICAgICAgICAgICAgICBuZXh0TG9jYWxlID0ge30sXG4gICAgICAgICAgICAgICAgbmV4dFB1cmUsXG4gICAgICAgICAgICAgICAgbmV4dFJ0bFxuICAgICAgICAgICAgfSA9IHRoaXMuY29udGV4dDtcblxuICAgICAgICAgICAgY29uc3QgZGlzcGxheU5hbWUgPVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29tcG9uZW50TmFtZSB8fCBnZXREaXNwbGF5TmFtZShDb21wb25lbnQpO1xuICAgICAgICAgICAgY29uc3QgY29udGV4dFByb3BzID0gZ2V0Q29udGV4dFByb3BzKFxuICAgICAgICAgICAgICAgIHsgcHJlZml4LCBsb2NhbGUsIHB1cmUsIHJ0bCB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgbmV4dExvY2FsZTogeyAuLi5jdXJyZW50R2xvYmFsTG9jYWxlLCAuLi5uZXh0TG9jYWxlIH0sXG4gICAgICAgICAgICAgICAgICAgIG5leHRQdXJlLFxuICAgICAgICAgICAgICAgICAgICBuZXh0UnRsOiB0eXBlb2YgbmV4dFJ0bCA9PT0gJ2Jvb2xlYW4nID8gbmV4dFJ0bCA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50R2xvYmFsUnRsID09PSB0cnVlID8gdHJ1ZSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRleHRQcm9wcyA9IFsncHJlZml4JywgJ2xvY2FsZScsICdwdXJlJywgJ3J0bCddLnJlZHVjZShcbiAgICAgICAgICAgICAgICAocmV0LCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dFByb3BzW25hbWVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0W25hbWVdID0gY29udGV4dFByb3BzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7fVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgbmV3T3RoZXJzID0gb3B0aW9ucy50cmFuc2Zvcm0gP1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudHJhbnNmb3JtKG90aGVycywgdGhpcy5fZGVwcmVjYXRlZCkgOlxuICAgICAgICAgICAgICAgIG90aGVycztcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8Q29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIHsuLi5uZXdPdGhlcnN9XG4gICAgICAgICAgICAgICAgICAgIHsuLi5uZXdDb250ZXh0UHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIHJlZj17dGhpcy5fZ2V0SW5zdGFuY2V9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBDb25maWdlZENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGBDb25maWcoJHtnZXREaXNwbGF5TmFtZShDb21wb25lbnQpfSlgO1xuXG4gICAgaG9pc3ROb25SZWFjdFN0YXRpYyhDb25maWdlZENvbXBvbmVudCwgQ29tcG9uZW50KTtcblxuICAgIHJldHVybiBDb25maWdlZENvbXBvbmVudDtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb25maWctcHJvdmlkZXIvY29uZmlnLmpzeCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gICAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gICAgY29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB0cnVlLFxuICAgIG1peGluczogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgdHlwZTogdHJ1ZVxufTtcblxudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gICAgbmFtZTogdHJ1ZSxcbiAgICBsZW5ndGg6IHRydWUsXG4gICAgcHJvdG90eXBlOiB0cnVlLFxuICAgIGNhbGxlcjogdHJ1ZSxcbiAgICBjYWxsZWU6IHRydWUsXG4gICAgYXJndW1lbnRzOiB0cnVlLFxuICAgIGFyaXR5OiB0cnVlXG59O1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiAmJiBnZXRQcm90b3R5cGVPZihPYmplY3QpO1xuXG5mdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgYmxhY2tsaXN0KSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7IC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG5cbiAgICAgICAgaWYgKG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICAgICAgdmFyIGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgICAgICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQsIGJsYWNrbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICghUkVBQ1RfU1RBVElDU1trZXldICYmICFLTk9XTl9TVEFUSUNTW2tleV0gJiYgKCFibGFja2xpc3QgfHwgIWJsYWNrbGlzdFtrZXldKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcbiAgICAgICAgICAgICAgICB0cnkgeyAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldENvbXBvbmVudCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhvaXN0Tm9uUmVhY3RTdGF0aWNzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19ob2lzdC1ub24tcmVhY3Qtc3RhdGljc0AyLjUuNUBob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9kaXN0L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzLmNqcy5qcyIsIi8qKlxuICog5Y+W5raI5LqL5Lu257uR5a6aXG4gKiBAcGFyYW0gIHsqfSAgIG5vZGUgICAgICAgRE9N6IqC54K55oiW5Lu75L2V5Y+v5Lul57uR5a6a5LqL5Lu255qE5a+56LGhXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgZXZlbnROYW1lICDkuovku7blkI1cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAgIOWbnuiwg+aWueazlVxuICogQHBhcmFtICB7Qm9vbGVhbn0gICBbdXNlQ2FwdHVyZT1mYWxzZV0g5piv5ZCm5byA5ZCv5LqL5Lu25o2V6I635LyY5YWIXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZmYgKG5vZGUsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2ssIHVzZUNhcHR1cmUgfHwgZmFsc2UpO1xuICAgIH1cbn1cblxuLyoqXG4gKiDnu5Hlrprkuovku7ZcbiAqIEBwYXJhbSAgeyp9ICAgbm9kZSAgICAgICBET03oioLngrnmiJbku7vkvZXlj6/ku6Xnu5Hlrprkuovku7bnmoTlr7nosaFcbiAqIEBwYXJhbSAge1N0cmluZ30gICBldmVudE5hbWUgIOS6i+S7tuWQjVxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrICAg5Zue6LCD5pa55rOVXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgIHVzZUNhcHR1cmUg5piv5ZCm5byA5ZCv5LqL5Lu25o2V6I635LyY5YWIXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAg6L+U5Zue55qEb2JqZWN05Lit5YyF5ZCr5LiA5Liqb2Zm5pa55rOV77yM55So5LqO5Y+W5raI5LqL5Lu255uR5ZCsXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGhhbmRsZXIgPSBldmVudHMub24oZG9jdW1lbnQuYm9keSwgJ2NsaWNrJywgZSA9PiB7XG4gKiAgICAgLy8gaGFuZGxlIGNsaWNrIC4uLlxuICogfSk7XG4gKiAvLyDlj5bmtojkuovku7bnu5HlrppcbiAqIGhhbmRsZXIub2ZmKCk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbiAobm9kZSwgZXZlbnROYW1lLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKG5vZGUuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSB8fCBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgb2ZmOiAoKSA9PiBvZmYobm9kZSwgZXZlbnROYW1lLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSlcbiAgICB9O1xufVxuXG4vKipcbiAqIOe7keWumuS6i+S7tu+8jOWPquaJp+ihjOS4gOasoeWQjumUgOavgVxuICogQHBhcmFtICB7Kn0gICBub2RlICAgICAgIERPTeiKgueCueaIluS7u+S9leWPr+S7pee7keWumuS6i+S7tueahOWvueixoVxuICogQHBhcmFtICB7U3RyaW5nfSAgIGV2ZW50TmFtZSAg5LqL5Lu25ZCNXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgICDlm57osIPmlrnms5VcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgdXNlQ2FwdHVyZSDmmK/lkKblvIDlkK/kuovku7bmjZXojrfkvJjlhYhcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAgICAgICAgICAgICDov5Tlm57nmoRvYmplY3TkuK3ljIXlkKvkuIDkuKpvZmbmlrnms5XvvIznlKjkuo7lj5bmtojkuovku7bnm5HlkKxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uY2UgKG5vZGUsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpIHtcbiAgICByZXR1cm4gb24obm9kZSwgZXZlbnROYW1lLCBmdW5jdGlvbiBfX2ZuICguLi5hcmdzKSB7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICAgIC8vIOeUseS6jmFkZEV2ZW50TGlzdGVuZXLkuK3nmoTlj4LmlbBvcHRpb25z5Y+q5ZyoQ2hyb21lIDU144CBRmlyZWZveChHZWNrbynku6XkuIrniYjmnKzmlK/mjIHvvIzmlYXov5jmmK/nlKjkvKDnu5/nmoTmlrnms5Xlrp7njrBvbmNlXG4gICAgICAgIG9mZihub2RlLCBldmVudE5hbWUsIF9fZm4sIHVzZUNhcHR1cmUpO1xuICAgIH0sIHVzZUNhcHR1cmUpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWwvZXZlbnRzLmpzIiwiaW1wb3J0IHtpc1Byb21pc2V9IGZyb20gJy4vb2JqZWN0JztcblxuLyoqXG4gKiDkuIDkuKrnqbrmlrnms5XvvIzov5Tlm57lhaXlj4LmnKzouqvmiJbnqbrlr7nosaFcbiAqL1xuZXhwb3J0IGNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcblxuLyoqXG4gKiDlsIZO5Liq5pa55rOV5ZCI5bm25Li65LiA5Liq6ZO+5byP6LCD55So55qE5pa55rOVXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gICAgIOWQiOW5tuWQjueahOaWueazlVxuICog5Y+C6ICDIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1jb21wb25lbnQvdXRpbC9cbiAqXG4gKiBAZXhhbXBsZVxuICogZnVuYy5tYWtlQ2hhaW4odGhpcy5oYW5kbGVDaGFuZ2UsIHRoaXMucHJvcHMub25DaGFuZ2UpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUNoYWluICguLi5mbnMpIHtcbiAgICBpZiAoZm5zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZm5zWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBjaGFpbmVkRnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSBmbnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm5zW2ldICYmIGZuc1tpXS5hcHBseSkge1xuICAgICAgICAgICAgICAgIGZuc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qKlxuICog5om56YeP5pS55Y+Y5pa55rOV55qE5LiK5LiL5paHXG4gKiDmraTmlrnms5XlnKhyZWFjdOe7hOS7tuS4reW+iOacieeUqO+8jOWcqGNvbnN0cnVjdG9y5Lit5om56YeP5bCG57uE5Lu25LiK55qE5pa55rOV5omn6KGM5LiK5LiL5paH57uR5a6a5Yiw57uE5Lu25pys6LqrXG4gKiDms6jmhI/vvJrnlKhiaW5k5pS55Y+Y5Ye95pWw6L+Q6KGM55qE5LiK5LiL5paH5Y+q5Lya55Sf5pWI5LiA5qyhXG4gKiBAcGFyYW0gIHtPYmplY3R9IGN0eCDmlrnms5XmjILovb3nmoTlr7nosaHku6Xlj4rmiafooYznmoTkuIrkuIvmlodcbiAqIEBwYXJhbSAge0FycmF5PFN0cmluZz59IGZucyDmlrnms5XlkI3liJfooahcbiAqXG4gKiBAZXhhbXBsZVxuICogZnVuYy5iaW5kQ3R4KHRoaXMsIFsnaGFuZGxlQ2xpY2snLCAnaGFuZGxlQ2hhbmdlJ10pO1xuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZEN0eCAoY3R4LCBmbnMsIG5zKSB7XG4gICAgaWYgKHR5cGVvZiBmbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZucyA9IFtmbnNdO1xuICAgIH1cblxuICAgIC8vIOaWueazleeahOaMgui9veepuumXtO+8jOWmguaenOS4jeS8oO+8jOm7mOiupOS4jmN0eOebuOWQjFxuICAgIG5zID0gbnMgfHwgY3R4O1xuXG4gICAgZm5zLmZvckVhY2goZm5OYW1lID0+IHtcbiAgICAgICAgLy8g6L+Z6YeM5LiN6KaB5re75Yqg56m65pa55rOV5Yik5pat77yM55Sx6LCD55So6ICF5L+d6K+B5q2j56Gu5oCn77yM5ZCm5YiZ5Ye65LqG6Zeu6aKY5peg5rOV5o6S5p+lXG4gICAgICAgIG5zW2ZuTmFtZV0gPSBuc1tmbk5hbWVdLmJpbmQoY3R4KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiDnlKjkuo7miafooYzlm57osIPmlrnms5XlkI7nmoTpgLvovpFcbiAqIEBwYXJhbSAgeyp9IHJldCAgICAgICAgICAgIOWbnuiwg+aWueazleaJp+ihjOe7k+aenFxuICogQHBhcmFtICB7RnVuY3Rpb259IHN1Y2Nlc3Mg5omn6KGM57uT5p6c6L+U5Zue6Z2eZmFsc2XnmoTlm57osINcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbZmFpbHVyZT1ub29wXSDmiafooYznu5Pmnpzov5Tlm55mYWxzZeeahOWbnuiwg1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvbWlzZUNhbGwgKHJldCwgc3VjY2VzcywgZmFpbHVyZSA9IG5vb3ApIHtcbiAgICBpZiAoaXNQcm9taXNlKHJldCkpIHtcbiAgICAgICAgcmV0dXJuIHJldC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBzdWNjZXNzKHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIGZhaWx1cmUoZSk7XG4gICAgICAgICAgICAvLyB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0ICE9PSBmYWxzZSA/IHN1Y2Nlc3MocmV0KSA6IGZhaWx1cmUocmV0KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlsL2Z1bmMuanMiLCJpbXBvcnQgeyBpc1Byb2R1Y3Rpb24gfSBmcm9tICcuL2Vudic7XG5cbi8qIGVzbGludCBuby1jb25zb2xlOiAwICovXG5cbi8qKlxuICog5Y+N5a+55L2/55So5p+Q5LiA5pa55rOV5oiW5bGe5oCn55qE6K2m5ZGKXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHByb3BzICAgICDov4fml7bnmoTlsZ7mgKfmiJbmlrnms5XlkI1cbiAqIEBwYXJhbSAge1N0cmluZ30gaW5zdGVhZCAgIOabv+S7o+eahOWxnuaAp+aIluaWueazleWQjVxuICogQHBhcmFtICB7U3RyaW5nfSBjb21wb25lbnQg57uE5Lu25ZCNXG4gKlxuICogQGV4YW1wbGVcbiAqIGxvZy5kZXByZWNhdGVkKCdvbkJlZm9yZUNsb3NlJywgJ2JlZm9yZUNsb3NlJywgJ0RpYWxvZycpO1xuICogLy8gV2FybmluZzogb25CZWZvcmVDbG9zZSBpcyBkZXByZWNhdGVkIGF0IFsgRGlhbG9nIF0sIHVzZSBbIGJlZm9yZUNsb3NlIF0gaW5zdGVhZCBvZiBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcHJlY2F0ZWQgKHByb3BzLCBpbnN0ZWFkLCBjb21wb25lbnQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICghaXNQcm9kdWN0aW9uKCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBgV2FybmluZzogWyAke3Byb3BzfSBdIGlzIGRlcHJlY2F0ZWQgYXQgWyAke2NvbXBvbmVudH0gXSwgYCArXG4gICAgICAgICAgICBgdXNlIFsgJHtpbnN0ZWFkfSBdIGluc3RlYWQgb2YgaXQuYFxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiDmjqfliLblj7DorablkYrml6Xlv5dcbiAqIEBwYXJhbSAge1N0cmluZ30gbXNnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3YXJuaW5nIChtc2cpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICByZXR1cm4gY29uc29sZS5lcnJvcihgV2FybmluZzogJHttc2d9YCk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWwvbG9nLmpzIiwiaW1wb3J0IHtoYXNET019IGZyb20gJy4vZG9tJztcbmltcG9ydCB7ZWFjaH0gZnJvbSAnLi9vYmplY3QnO1xuXG5jb25zdCBhbmltYXRpb25FbmRFdmVudE5hbWVzID0ge1xuICAgIFdlYmtpdEFuaW1hdGlvbjogJ3dlYmtpdEFuaW1hdGlvbkVuZCcsXG4gICAgT0FuaW1hdGlvbjogJ29BbmltYXRpb25FbmQnLFxuICAgIGFuaW1hdGlvbjogJ2FuaW1hdGlvbmVuZCdcbn07XG5cbmNvbnN0IHRyYW5zaXRpb25FdmVudE5hbWVzID0ge1xuICAgIFdlYmtpdFRyYW5zaXRpb246ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICBPVHJhbnNpdGlvbjogJ29UcmFuc2l0aW9uRW5kJyxcbiAgICB0cmFuc2l0aW9uOiAndHJhbnNpdGlvbmVuZCdcbn07XG5cbi8qKlxuICog5piv5ZCm5pSv5oyB5p+Q5Lqb5Yqo5pWI5LqL5Lu277yM5aaC5p6c5pSv5oyB77yM6L+U5Zue55u45bqU55qEZW5k5LqL5Lu25ZCNXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7T2JqZWN0PFN0cmluZz59IG5hbWVzXG4gKiBAcmV0dXJuIHtPYmplY3R8ZmFsc2V9XG4gKi9cbmZ1bmN0aW9uIF9zdXBwb3J0RW5kIChuYW1lcykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaGFzRE9NKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxldCByZXQgPSBmYWxzZTtcblxuICAgIGVhY2gobmFtZXMsICh2YWwsIGtleSkgPT4ge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoZWwuc3R5bGVba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXQgPSB7ZW5kOiB2YWx9O1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIOaYr+WQpuaUr+aMgeafkOS6m0NTU+WxnuaAp1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge09iamVjdDxBcnJheTxTdHJpbmc+Pn0gbmFtZXNcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgIGlzIHN1cHBvcnRcbiAqL1xuZnVuY3Rpb24gX3N1cHBvcnRDU1MgKG5hbWVzKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFoYXNET00pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbGV0IHJldCA9IGZhbHNlO1xuXG4gICAgZWFjaChuYW1lcywgKHZhbCwga2V5KSA9PiB7XG4gICAgICAgIGVhY2godmFsLCBpdGVtID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGVba2V5XSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgcmV0ID0gcmV0IHx8IGVsLnN0eWxlW2tleV0gPT09IGl0ZW07XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgd2lsbCBiZSB0aHJvdyBlcnJvciB3aGVuIHNldCB1bmtub3duIHByb3BlcnR5IHVuZGVyIElFOFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICFyZXQ7IC8vIOWmguaenOacieS4gOS4quaUr+aMgeWwsei/lOWbnmZhbHNl77yM5ZCO6Z2i5LiN6ZyA6KaB5YaN5Yik5patXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAhcmV0O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiDmmK/lkKbmlK/mjIFhbmltYXRpb27ku6Xlj4rliqjnlLvnu5PmnZ/kuovku7blkI1cbiAqIEB0eXBlIHtPYmplY3R8ZmFsc2V9XG4gKiBAcHJvcGVydHkge1N0cmluZ30gZW5kIOWKqOeUu+e7k+adn+S6i+S7tuWQjVxuICovXG5leHBvcnQgY29uc3QgYW5pbWF0aW9uID0gX3N1cHBvcnRFbmQoYW5pbWF0aW9uRW5kRXZlbnROYW1lcyk7XG5cbi8qKlxuICog5piv5ZCm5pSv5oyBdHJhbnNpdGlvbuS7peWPiui/h+a7pOaViOaenOe7k+adn+S6i+S7tuWQjVxuICogQHR5cGUge09iamVjdHxmYWxzZX1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBlbmQg6L+H5rih5pWI5p6c57uT5p2f5LqL5Lu25ZCNXG4gKi9cbmV4cG9ydCBjb25zdCB0cmFuc2l0aW9uID0gX3N1cHBvcnRFbmQodHJhbnNpdGlvbkV2ZW50TmFtZXMpO1xuXG4vKipcbiAqIOaYr+WQpuaUr+aMgWZsZXjlsZ7mgKdcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZmxleCA9IF9zdXBwb3J0Q1NTKHtcbiAgICBkaXNwbGF5OiBbJ2ZsZXgnLCAnLXdlYmtpdC1mbGV4JywgJy1tb3otZmxleCcsICctbXMtZmxleGJveCddXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlsL3N1cHBvcnQuanMiLCJpbXBvcnQgS0VZQ09ERSBmcm9tICcuL2tleWNvZGUnO1xuaW1wb3J0IHtlYWNofSBmcm9tICcuL29iamVjdCc7XG5cbi8qKlxuICog55So5LqO5YiH5o2i6aG16Z2i5YWD57Sg55qE54Sm54K5XG4gKi9cblxuXG4vKipcbiAqIOWFg+e0oOaYr+WQpuWPr+ingVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAgIHtFbGVtZW50fSAgbm9kZVxuICogQHJldHVybiAge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIF9pc1Zpc2libGUobm9kZSkge1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09PSBkb2N1bWVudC5ib2R5IHx8IG5vZGUgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnIHx8IG5vZGUuc3R5bGUudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiDlhYPntKDmmK/lkKblj6/ku6Xojrflj5bnhKbngrlcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gICB7RWxlbWVudH0gIG5vZGVcbiAqIEByZXR1cm4gIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBfaXNGb2N1c2FibGUobm9kZSkge1xuICAgIGNvbnN0IG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHRhYkluZGV4ID0gcGFyc2VJbnQobm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKTtcbiAgICBjb25zdCBoYXNUYWJJbmRleCA9ICFpc05hTih0YWJJbmRleCkgJiYgdGFiSW5kZXggPiAtMTtcblxuICAgIGlmIChfaXNWaXNpYmxlKG5vZGUpKSB7XG4gICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgcmV0dXJuICFub2RlLmRpc2FibGVkICYmIG5vZGUudHlwZSAhPT0gJ2hpZGRlbic7XG4gICAgICAgIH0gZWxzZSBpZiAoWydzZWxlY3QnLCAndGV4dGFyZWEnLCAnYnV0dG9uJ10uaW5kZXhPZihub2RlTmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuICFub2RlLmRpc2FibGVkO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSAnYScpIHtcbiAgICAgICAgICAgIHJldHVybiAobm9kZS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSB8fCBoYXNUYWJJbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzVGFiSW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIOWIl+WHuuiDveiOt+WPlueEpueCueeahOWtkOiKgueCuVxuICogQHBhcmFtICB7RWxlbWVudH0gbm9kZSDlrrnlmajoioLngrlcbiAqIEByZXR1cm4ge0FycmF5PEVsZW1lbnQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9jdXNOb2RlTGlzdChub2RlKSB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgY29uc3Qgbm9kZUxpc3QgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJyonKTtcblxuICAgIGVhY2gobm9kZUxpc3QsIGl0ZW0gPT4ge1xuICAgICAgICBpZiAoX2lzRm9jdXNhYmxlKGl0ZW0pKSB7XG4gICAgICAgICAgICBjb25zdCBtZXRob2QgPSBpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1hdXRvLWZvY3VzJykgPyAndW5zaGlmdCcgOiAncHVzaCc7XG4gICAgICAgICAgICByZXNbbWV0aG9kXShpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKF9pc0ZvY3VzYWJsZShub2RlKSkge1xuICAgICAgICByZXMudW5zaGlmdChub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyDnlKjkuo7orrDlvZXkuIrkuIDmrKHojrflvpfnhKbngrnnmoTml6DntKBcbmxldCBsYXN0Rm9jdXNFbGVtZW50ID0gbnVsbDtcblxuLyoqXG4gKiDkv53lrZjmnIDov5HkuIDmrKHojrflvpfnhKbngrnnmoTml6DntKBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhdmVMYXN0Rm9jdXNOb2RlKCkge1xuICAgIGxhc3RGb2N1c0VsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xufVxuXG4vKipcbiAqIOa4hemZpOeEpueCueiusOW9lVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJMYXN0Rm9jdXNOb2RlKCkge1xuICAgIGxhc3RGb2N1c0VsZW1lbnQgPSBudWxsO1xufVxuXG4vKipcbiAqIOWwneivleWwhueEpueCueWIh+aNouWIsOS4iuS4gOS4quWFg+e0oFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmFja0xhc3RGb2N1c05vZGUoKSB7XG4gICAgaWYgKGxhc3RGb2N1c0VsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIOWFg+e0oOWPr+iDveW3sue7j+iiq+enu+WKqOS6hlxuICAgICAgICAgICAgbGFzdEZvY3VzRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgLi4uXG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICog5Zyo6ZmQ5Yi255qE6IyD5Zu05YaF5YiH5o2i54Sm54K5XG4gKiBAcGFyYW0gIHtFbGVtZW50fSBub2RlIOWuueWZqOiKgueCuVxuICogQHBhcmFtICB7RXZlbnR9IGUgICAgICDplK7nm5jkuovku7ZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbWl0VGFiUmFuZ2Uobm9kZSwgZSkge1xuICAgIGlmIChlLmtleUNvZGUgPT09IEtFWUNPREUuVEFCKSB7XG4gICAgICAgIGNvbnN0IHRhYk5vZGVMaXN0ID0gZ2V0Rm9jdXNOb2RlTGlzdChub2RlKTtcbiAgICAgICAgY29uc3QgbWF4SW5kZXggPSB0YWJOb2RlTGlzdC5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRhYk5vZGVMaXN0LmluZGV4T2YoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG5cbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXRJbmRleCA9IGluZGV4ICsgKGUuc2hpZnRLZXkgPyAtMSA6IDEpO1xuICAgICAgICAgICAgdGFyZ2V0SW5kZXggPCAwICYmICh0YXJnZXRJbmRleCA9IG1heEluZGV4KTtcbiAgICAgICAgICAgIHRhcmdldEluZGV4ID4gbWF4SW5kZXggJiYgKHRhcmdldEluZGV4ID0gMCk7XG4gICAgICAgICAgICB0YWJOb2RlTGlzdFt0YXJnZXRJbmRleF0uZm9jdXMoKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlsL2ZvY3VzLmpzIiwibGV0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cbi8qKlxuICog55Sf5oiQ5YWo5bGA5ZSv5LiA55qEaWRcbiAqIEBwYXJhbSAge1N0cmluZ30gW3ByZWZpeD0nJ10g5YmN57yA5a2X56ym5LiyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKlxuICogQGV4YW1wbGVcbiAqIGd1aWQoKTsgLy8gajdqdjUwOWNcbiAqIGd1aWQoJ3ByZWZpeC0nKTsgLy8gcHJlZml4LWo3anY1MDlkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG5cbiAgICByZXR1cm4gcHJlZml4ICsgKHRpbWVzdGFtcCsrKS50b1N0cmluZygzNik7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbC9ndWlkLmpzIiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyBvYmplY3QgYW5kIGtleXNcbiAqIGdlbmVyYXRlZCBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5XG4gKiBvZiBvYmplY3QgdGhydSBpdGVyYXRlZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmNvbnN0IG1hcEtleXMgPSAob2JqLCBmbikgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0tleSA9IGZuKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgcmVzdWx0W25ld0tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJlcGxhY2Ugc3BlY2lmaWMga2V5IHdpdGggcHJlZml4IGBuZXh0YFxuICogYW5kIGxvd2VyY2FzZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHJlc3VsdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuY29uc3QgcmVwbGFjZUtleSA9IGtleSA9PlxuICAgIGtleS5yZXBsYWNlKC9eKG5leHQpKFtBLVpdKS8sIChtYXRjaCwgcDEsIHAyKSA9PiBwMi50b0xvd2VyQ2FzZSgpKTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmNvbnN0IHRyYW5zZm9ybUNvbnRleHQgPSBzb3VyY2UgPT4gbWFwS2V5cyhzb3VyY2UsIHJlcGxhY2VLZXkpO1xuXG4vKipcbiAqIENvbnN1bWVyXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcFxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuY29uc3QgQ29uc3VtZXIgPSAoeyBjaGlsZHJlbiB9LCBjb250ZXh0KSA9PlxuICAgIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkcmVuKHRyYW5zZm9ybUNvbnRleHQoY29udGV4dCkpIDogbnVsbDtcblxuLyoqXG4gKiBQcm9wVHlwZXNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc3RhdGljXG4gKi9cbkNvbnN1bWVyLnByb3BUeXBlcyA9IHtcbiAgICAvLyBSZW5kZXIgY29udGV4dCBhcyBmdW5jdGlvblxuICAgIC8vIEZ1bmN0aW9uKGNvbnRleHQ6IG9iamVjdCk6IFJlYWN0RWxlbWVudFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuLyoqXG4gKiBDb250ZXh0VHlwZXMgKGxlZ2FjeSBjb250ZXh0KVxuICogQHR5cGUge09iamVjdH1cbiAqIEBzdGF0aWNcbiAqL1xuQ29uc3VtZXIuY29udGV4dFR5cGVzID0ge1xuICAgIG5leHRQcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgbmV4dExvY2FsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBuZXh0UHVyZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgbmV3UnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBuZXh0V2FybmluZzogUHJvcFR5cGVzLmJvb2xcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENvbnN1bWVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbmZpZy1wcm92aWRlci9jb25zdW1lci5qc3giLCJjbGFzcyBDYWNoZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdG9yZSA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBlbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlLnNpemUgPT09IDA7XG4gICAgfVxuXG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcmUuaGFzKGtleSk7XG4gICAgfVxuXG4gICAgZ2V0KGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuaGFzKGtleSkgPyB0aGlzLl9zdG9yZS5nZXQoa2V5KSA6IHRoaXMucm9vdCgpO1xuICAgICAgICByZXR1cm4gKHR5cGVvZiByZXMgPT09ICd1bmRlZmluZWQnIHx8IHJlcyA9PT0gbnVsbCkgP1xuICAgICAgICAgICAgZGVmYXVsdFZhbHVlIDogcmVzO1xuICAgIH1cblxuICAgIGFkZChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RvcmUuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHVwZGF0ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9yZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmUoa2V5KSB7XG4gICAgICAgIHRoaXMuX3N0b3JlLmRlbGV0ZShrZXkpO1xuICAgIH1cblxuICAgIHJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9yZS5nZXQodGhpcy5fcm9vdCk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYWNoZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb25maWctcHJvdmlkZXIvY2FjaGUuanMiLCJpZih0eXBlb2Ygd2luZG93Lm1vbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHt2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSBcXFwid2luZG93Lm1vbWVudFxcXCJcIik7IGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJzsgdGhyb3cgZTt9XG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5tb21lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ3aW5kb3cubW9tZW50XCJcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUgNiA3IDggOSAxMCAxMSAxMiAxMyAxNCAxNSAxNiAxNyAxOCAxOSAyMCAyMSAyMiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgc2hhbGxvd0VsZW1lbnRFcXVhbHMgZnJvbSAnc2hhbGxvdy1lbGVtZW50LWVxdWFscyc7XG5pbXBvcnQgTG9hZGluZyBmcm9tICcuLi9sb2FkaW5nJztcbmltcG9ydCB6aENOIGZyb20gJy4uL2xvY2FsZS96aC1jbic7XG5pbXBvcnQgeyBsb2csIG9iaiB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IEJvZHlDb21wb25lbnQgZnJvbSAnLi9iYXNlL2JvZHknO1xuaW1wb3J0IEhlYWRlckNvbXBvbmVudCBmcm9tICcuL2Jhc2UvaGVhZGVyJztcbmltcG9ydCBXcmFwcGVyQ29tcG9uZW50IGZyb20gJy4vYmFzZS93cmFwcGVyJztcbmltcG9ydCBSb3dDb21wb25lbnQgZnJvbSAnLi9iYXNlL3Jvdyc7XG5pbXBvcnQgQ2VsbENvbXBvbmVudCBmcm9tICcuL2Jhc2UvY2VsbCc7XG5pbXBvcnQgRmlsdGVyQ29tcG9uZW50IGZyb20gJy4vYmFzZS9maWx0ZXInO1xuaW1wb3J0IFNvcnRDb21wb25lbnQgZnJvbSAnLi9iYXNlL3NvcnQnO1xuaW1wb3J0IENvbHVtbiBmcm9tICcuL2NvbHVtbic7XG5pbXBvcnQgQ29sdW1uR3JvdXAgZnJvbSAnLi9jb2x1bW4tZ3JvdXAnO1xuXG5jb25zdCBDaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLFxuICAgIG5vb3AgPSAoKSA9PiB7fTtcblxuLy88VGFibGU+XG4vLyAgICA8VGFibGUuQ29sdW1uLz5cbi8vICAgIDxUYWJsZS5Db2x1bW5Hcm91cD5cbi8vICAgICAgPFRhYmxlLkNvbHVtbi8+XG4vLyAgICAgIDxUYWJsZS5Db2x1bW4vPlxuLy8gICAgPC9UYWJsZS5Db2x1bW5Hcm91cD5cbi8vPC9UYWJsZT5cblxuLyoqIFRhYmxlICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWJsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIENvbHVtbiA9IENvbHVtbjtcbiAgICBzdGF0aWMgQ29sdW1uR3JvdXAgPSBDb2x1bW5Hcm91cDtcbiAgICBzdGF0aWMgSGVhZGVyID0gSGVhZGVyQ29tcG9uZW50O1xuICAgIHN0YXRpYyBCb2R5ID0gQm9keUNvbXBvbmVudDtcbiAgICBzdGF0aWMgV3JhcHBlciA9IFdyYXBwZXJDb21wb25lbnQ7XG4gICAgc3RhdGljIFJvdyA9IFJvd0NvbXBvbmVudDtcbiAgICBzdGF0aWMgQ2VsbCA9IENlbGxDb21wb25lbnQ7XG4gICAgc3RhdGljIEZpbHRlciA9IEZpbHRlckNvbXBvbmVudDtcbiAgICBzdGF0aWMgU29ydCA9IFNvcnRDb21wb25lbnQ7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5qC35byP57G75ZCN55qE5ZOB54mM5YmN57yAXG4gICAgICAgICAqL1xuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHB1cmU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBydGw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ57G75ZCNXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnlhoXogZTmoLflvI9cbiAgICAgICAgICovXG4gICAgICAgIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAvKipcbiAgICAgICAgICog6KGo5qC85bGV56S655qE5pWw5o2u5rqQXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhU291cmNlOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIGVudGlyZURhdGFTb3VyY2U6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeCueWHu+ihqOagvOavj+S4gOihjOinpuWPkeeahOS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkIOivpeihjOaJgOWvueW6lOeahOaVsOaNrlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXgg6K+l6KGM5omA5a+55bqU55qE5bqP5YiXXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRE9N5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBvblJvd0NsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaCrOa1ruWcqOihqOagvOavj+S4gOihjOeahOaXtuWAmeinpuWPkeeahOS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkIOivpeihjOaJgOWvueW6lOeahOaVsOaNrlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXgg6K+l6KGM5omA5a+55bqU55qE5bqP5YiXXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRE9N5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBvblJvd01vdXNlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAvKipcbiAgICAgICAgICog56a75byA6KGo5qC85q+P5LiA6KGM55qE5pe25YCZ6Kem5Y+R55qE5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmQg6K+l6KGM5omA5a+55bqU55qE5pWw5o2uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCDor6XooYzmiYDlr7nlupTnmoTluo/liJdcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSBET03kuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIG9uUm93TW91c2VMZWF2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDngrnlh7vliJfmjpLluo/op6blj5HnmoTkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFJbmRleCDmjIflrprnmoTmjpLluo/nmoTlrZfmrrVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9yZGVyIOaOkuW6j+WvueW6lOeahOmhuuW6jywg5pyJYGRlc2Ng5ZKMYGFzY2DkuKTnp41cbiAgICAgICAgICovXG4gICAgICAgIG9uU29ydDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDngrnlh7vov4fmu6Tnoa7orqTmjInpkq7op6blj5HnmoTkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGZpbHRlclBhcmFtcyDov4fmu6TnmoTlrZfmrrXkv6Hmga9cbiAgICAgICAgICovXG4gICAgICAgIG9uRmlsdGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmHjeiuvuWIl+WwuuWvuOeahOaXtuWAmeinpuWPkeeahOS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YUluZGV4IOaMh+WumumHjeiuvueahOWtl+autVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUg5YiX5a695Y+Y5Yqo55qE5pWw5YC8XG4gICAgICAgICAqL1xuICAgICAgICBvblJlc2l6ZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7mr4/kuIDooYznmoTlsZ7mgKfvvIzlpoLmnpzov5Tlm57lgLzlkozlhbbku5bpkojlr7nooYzmk43kvZznmoTlsZ7mgKflhrLnqoHliJnml6DmlYjjgIJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZCDor6XooYzmiYDlr7nlupTnmoTmlbDmja5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IOivpeihjOaJgOWvueW6lOeahOW6j+WIl1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSDpnIDopoHorr7nva7nmoTooYzlsZ7mgKdcbiAgICAgICAgICovXG4gICAgICAgIGdldFJvd1Byb3BzOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruWNleWFg+agvOeahOWxnuaAp++8jOmAmui/h+ivpeWxnuaAp+WPr+S7pei/m+ihjOWQiOW5tuWNleWFg+agvFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcm93SW5kZXgg6K+l6KGM5omA5a+55bqU55qE5bqP5YiXXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb2xJbmRleCDor6XliJfmiYDlr7nlupTnmoTluo/liJdcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFJbmRleCDor6XliJfmiYDlr7nlupTnmoTlrZfmrrXlkI3np7BcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZCDor6XooYzlr7nlupTnmoTorrDlvZVcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0g6L+U5ZuedGTlhYPntKDnmoTmiYDmlK/mjIHnmoTlsZ7mgKflr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIGdldENlbGxQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDooajmoLzmmK/lkKblhbfmnInovrnmoYZcbiAgICAgICAgICovXG4gICAgICAgIGhhc0JvcmRlcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDooajmoLzmmK/lkKblhbfmnInlpLTpg6hcbiAgICAgICAgICovXG4gICAgICAgIGhhc0hlYWRlcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDooajmoLzmmK/lkKbmmK/mlpHpqaznur9cbiAgICAgICAgICovXG4gICAgICAgIGlzWmVicmE6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6KGo5qC85piv5ZCm5Zyo5Yqg6L295LitXG4gICAgICAgICAqL1xuICAgICAgICBsb2FkaW5nOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5iSBMb2FkaW5nIOe7hOS7tlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBsb2FkaW5nQ29tcG9uZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW9k+WJjei/h+a7pOeahOeahGtleXMs5L2/55So5q2k5bGe5oCn5Y+v5Lul5o6n5Yi26KGo5qC855qE5aS06YOo55qE6L+H5ruk6YCJ6aG55Lit5ZOq5Liq6I+c5Y2V6KKr6YCJ5LitLOagvOW8j+S4uiB7ZGF0YUluZGV4OiB7c2VsZWN0ZWRLZXlzOltdfX1cbiAgICAgICAgICog56S65L6LOlxuICAgICAgICAgKiDlgYforr7opoHmjqfliLZkYXRhSW5kZXjkuLppZOeahOWIl+eahOi/h+a7pOiPnOWNleS4rWtleeS4um9uZeeahOiPnOWNlemhuemAieS4rVxuICAgICAgICAgKiBgPFRhYmxlIGZpbHRlclBhcmFtcz17e2lkOiB7c2VsZWN0ZWRLZXlzOiBbJ29uZSddfX19Lz5gXG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXJQYXJhbXM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvZPliY3mjpLluo/nmoTlrZfmrrUs5L2/55So5q2k5bGe5oCn5Y+v5Lul5o6n5Yi26KGo5qC855qE5a2X5q6155qE5o6S5bqPLOagvOW8j+S4untkYXRhSW5kZXg6ICdhc2MnfVxuICAgICAgICAgKi9cbiAgICAgICAgc29ydDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWumuS5ieWbvemZheWMluaWh+ahiOWvueixoVxuICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gb2sg6L+H5ruk5Zmo5Lit56Gu6K6k5oyJ6ZKu5paH5qGIXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZXNldCDov4fmu6TlmajkuK3ph43nva7mjInpkq7mlofmoYhcbiAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGVtcHR5IOayoeacieaVsOaNruaDheWGteS4iyB0YWJsZeWGheeahOaWh+ahiFxuICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gYXNjIOaOkuW6j+WNh+W6j+eKtuaAgeS4i+eahOaWh+ahiFxuICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gZGVzYyDmjpLluo/lsIbluo/nirbmgIHkuIvnmoTmlofmoYhcbiAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGV4cGFuZGVkIOWPr+aKmOWPoOihjO+8jOWxleW8gOeKtuaAgeS4i+eahOaWh+ahiFxuICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gZm9sZGVkIOWPr+aKmOWPoOihjO+8jOaKmOWPoOeKtuaAgeS4i+eahOaWh+ahiFxuICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gZmlsdGVyIOi/h+a7pOWZqOaWh+ahiFxuICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gc2VsZWN0QWxsIGhlYWRlcumHjOWFqOmAieeahOaMiemSruaWh+ahiFxuICAgICAgICAgKi9cbiAgICAgICAgbG9jYWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBjb21wb25lbnRzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBjb2x1bW5zOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7mlbDmja7kuLrnqbrnmoTml7blgJnnmoTooajmoLzlhoXlrrnlsZXnjrBcbiAgICAgICAgICovXG4gICAgICAgIGVtcHR5Q29udGVudDogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkYXRhU291cmNl5b2T5Lit5pWw5o2u55qE5Li76ZSu77yM5aaC5p6c57uZ5a6a55qE5pWw5o2u5rqQ5Lit55qE5bGe5oCn5LiN5YyF5ZCr6K+l5Li76ZSu77yM5Lya6YCg5oiQ6YCJ5oup54q25oCB5YWo6YOo6YCJ5LitXG4gICAgICAgICAqL1xuICAgICAgICBwcmltYXJ5S2V5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBsb2NrVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsICdyaWdodCddKSxcbiAgICAgICAgd3JhcHBlckNvbnRlbnQ6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIHJlZnM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpop3lpJbmuLLmn5PooYznmoTmuLLmn5Plh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZCDor6XooYzmiYDlr7nlupTnmoTmlbDmja5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IOivpeihjOaJgOWvueW6lOeahOW6j+WIl1xuICAgICAgICAgKiBAcmV0dXJucyB7RWxlbWVudH0g5riy5p+T5YaF5a65XG4gICAgICAgICAqL1xuICAgICAgICBleHBhbmRlZFJvd1JlbmRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpop3lpJbmuLLmn5PooYznmoTnvKnov5tcbiAgICAgICAgICovXG4gICAgICAgIGV4cGFuZGVkUm93SW5kZW50OiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpu5jorqTmg4XlhrXkuIvlsZXlvIDnmoTmuLLmn5PooYzmiJbogIVUcmVlLCDkvKDlhaXmraTlsZ7mgKfkuLrlj5fmjqfnirbmgIFcbiAgICAgICAgICovXG4gICAgICAgIG9wZW5Sb3dLZXlzOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbmmL7npLrngrnlh7vlsZXlvIDpop3lpJbmuLLmn5PooYznmoQr5Y+35oyJ6ZKuXG4gICAgICAgICAqL1xuICAgICAgICBoYXNFeHBhbmRlZFJvd0N0cmw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u6aKd5aSW5riy5p+T6KGM55qE5bGe5oCnXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFeHBhbmRlZENvbFByb3BzOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWcqOmineWklua4suafk+ihjOaIluiAhVRyZWXlsZXlvIDmiJbogIXmlLbotbfnmoTml7blgJnop6blj5HnmoTkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gb3BlblJvd0tleXMg5bGV5byA55qE5riy5p+T6KGM55qEa2V5XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjdXJyZW50Um93S2V5IOW9k+WJjeeCueWHu+eahOa4suafk+ihjOeahGtleVxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV4cGFuZGVkIOW9k+WJjeeCueWHu+aYr+WxleW8gOi/mOaYr+aUtui1t1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY3VycmVudFJlY29yZCDlvZPliY3ngrnlh7vpop3lpJbmuLLmn5PooYznmoTorrDlvZVcbiAgICAgICAgICovXG4gICAgICAgIG9uUm93T3BlbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDngrnlh7vpop3lpJbmuLLmn5PooYzop6blj5HnmoTkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZCDor6XooYzmiYDlr7nlupTnmoTmlbDmja5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IOivpeihjOaJgOWvueW6lOeahOW6j+WIl1xuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIERPTeS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgb25FeHBhbmRlZFJvd0NsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOihqOWktOaYr+WQpuWbuuWumu+8jOivpeWxnuaAp+mFjeWQiG1heEJvZHlIZWlnaHTkvb/nlKjvvIzlvZPlhoXlrrnljLrln5/nmoTpq5jluqbotoXov4dtYXhCb2R5SGVpZ2h055qE5pe25YCZ77yM5Zyo5YaF5a655Yy65Z+f5Lya5Ye6546w5rua5Yqo5p2hXG4gICAgICAgICAqL1xuICAgICAgICBmaXhlZEhlYWRlcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmnIDlpKflhoXlrrnljLrln5/nmoTpq5jluqYs5ZyoYGZpeGVkSGVhZGVyYOS4umB0cnVlYOeahOaXtuWAmSzotoXov4fov5nkuKrpq5jluqbkvJrlh7rnjrDmu5rliqjmnaFcbiAgICAgICAgICovXG4gICAgICAgIG1heEJvZHlIZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuWQr+eUqOmAieaLqeaooeW8j1xuICAgICAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBnZXRQcm9wcyBgRnVuY3Rpb24ocmVjb3JkLCBpbmRleCk9Pk9iamVjdGAg6I635Y+Wc2VsZWN0aW9u55qE6buY6K6k5bGe5oCnXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG9uQ2hhbmdlIGBGdW5jdGlvbihzZWxlY3RlZFJvd0tleXM6QXJyYXksIHJlY29yZHM6QXJyYXkpYCDpgInmi6nmlLnlj5jnmoTml7blgJnop6blj5HnmoTkuovku7bvvIwqKuazqOaEjzoqKiDlhbbkuK1yZWNvcmRz5Y+q5Lya5YyF5ZCr5b2T5YmNZGF0YVNvdXJjZeeahOaVsOaNru+8jOW+iOWPr+iDveS8muWwj+S6jnNlbGVjdGVkUm93S2V5c+eahOmVv+W6puOAglxuICAgICAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvblNlbGVjdCBgRnVuY3Rpb24oc2VsZWN0ZWQ6Qm9vbGVhbiwgcmVjb3JkOk9iamVjdCwgcmVjb3JkczpBcnJheSlgIOeUqOaIt+aJi+WKqOmAieaLqS/lj5bmtojpgInmi6nmn5DooYznmoTlm57osINcbiAgICAgICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb25TZWxlY3RBbGwgYEZ1bmN0aW9uKHNlbGVjdGVkOkJvb2xlYW4sIHJlY29yZHM6QXJyYXkpYCDnlKjmiLfmiYvliqjpgInmi6kv5Y+W5raI6YCJ5oup5omA5pyJ6KGM55qE5Zue6LCDXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHNlbGVjdGVkUm93S2V5cyDorr7nva7kuobmraTlsZ7mgKcs5bCGcm93U2VsZWN0aW9u5Y+Y5Li65Y+X5o6n54q25oCBLOaOpeaUtuWAvOS4uuivpeihjOaVsOaNrueahHByaW1hcnlLZXnnmoTlgLxcbiAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IG1vZGUg6YCJ5oupc2VsZWN0aW9u55qE5qih5byPLCDlj6/pgInlgLzkuLpgc2luZ2xlYCwgYG11bHRpcGxlYO+8jOm7mOiupOS4umBtdWx0aXBsZWBcbiAgICAgICAgICovXG4gICAgICAgIHJvd1NlbGVjdGlvbjogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOihqOWktOaYr+WQpuaYr3N0aWNreVxuICAgICAgICAgKi9cbiAgICAgICAgc3RpY2t5SGVhZGVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOi3neemu+eql+WPo+mhtumDqOi+vuWIsOaMh+WumuWBj+enu+mHj+WQjuinpuWPkVxuICAgICAgICAgKi9cbiAgICAgICAgb2Zmc2V0VG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICogYWZmaXjnu4Tku7bnmoTnmoTlsZ7mgKdcbiAgICAgICAgICovXG4gICAgICAgIGFmZml4UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlnKh0cmVl5qih5byP5LiL55qE57yp6L+b5bC65a+477yMIOS7heWcqGlzVHJlZeS4unRydWXml7blgJnmnInmlYhcbiAgICAgICAgICovXG4gICAgICAgIGluZGVudDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8gOWQr1RhYmxl55qEdHJlZeaooeW8jywg5o6l5pS255qE5pWw5o2u5qC85byP5Lit5YyF5ZCrY2hpbGRyZW7liJnmuLLmn5PmiJB0cmVlIHRhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBpc1RyZWU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5byA5ZCv6Jma5ouf5rua5YqoXG4gICAgICAgICAqL1xuICAgICAgICB1c2VWaXJ0dWFsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruihjOmrmFxuICAgICAgICAgKi9cbiAgICAgICAgcm93SGVpZ2h0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5Zyo5YaF5a655Yy65Z+f5rua5Yqo55qE5pe25YCZ6Kem5Y+R55qE5Ye95pWwXG4gICAgICAgICAqL1xuICAgICAgICBvbkJvZHlTY3JvbGw6IFByb3BUeXBlcy5mdW5jXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGRhdGFTb3VyY2U6IFtdLFxuICAgICAgICBvblJvd0NsaWNrOiBub29wLFxuICAgICAgICBvblJvd01vdXNlRW50ZXI6IG5vb3AsXG4gICAgICAgIG9uUm93TW91c2VMZWF2ZTogbm9vcCxcbiAgICAgICAgb25Tb3J0OiBub29wLFxuICAgICAgICBvbkZpbHRlcjogbm9vcCxcbiAgICAgICAgb25SZXNpemVDaGFuZ2U6IG5vb3AsXG4gICAgICAgIGdldFJvd1Byb3BzOiBub29wLFxuICAgICAgICBnZXRDZWxsUHJvcHM6IG5vb3AsXG4gICAgICAgIHByZWZpeDogJ25leHQtJyxcbiAgICAgICAgaGFzQm9yZGVyOiB0cnVlLFxuICAgICAgICBoYXNIZWFkZXI6IHRydWUsXG4gICAgICAgIGlzWmVicmE6IGZhbHNlLFxuICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgcHJpbWFyeUtleTogJ2lkJyxcbiAgICAgICAgY29tcG9uZW50czoge30sXG4gICAgICAgIGxvY2FsZTogemhDTi5UYWJsZVxuICAgIH07XG5cbiAgICBzdGF0aWMgY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIG5vdFJlbmRlckNlbGxJbmRleDogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBsb2NrVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsICdyaWdodCddKVxuICAgIH07XG5cbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICBnZXRUYWJsZUluc3RhbmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgZ2V0VGFibGVJbnN0YW5jZUZvclZpcnR1YWw6IFByb3BUeXBlcy5mdW5jXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgeyBnZXRUYWJsZUluc3RhbmNlLCBnZXRUYWJsZUluc3RhbmNlRm9yVmlydHVhbCB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBnZXRUYWJsZUluc3RhbmNlICYmIGdldFRhYmxlSW5zdGFuY2UocHJvcHMubG9ja1R5cGUsIHRoaXMpO1xuICAgICAgICBnZXRUYWJsZUluc3RhbmNlRm9yVmlydHVhbCAmJlxuICAgICAgICAgICAgZ2V0VGFibGVJbnN0YW5jZUZvclZpcnR1YWwocHJvcHMubG9ja1R5cGUsIHRoaXMpO1xuICAgICAgICB0aGlzLm5vdFJlbmRlckNlbGxJbmRleCA9IFtdO1xuICAgIH1cblxuICAgIHN0YXRlID0ge1xuICAgICAgICBzb3J0OiB0aGlzLnByb3BzLnNvcnQgfHwge31cbiAgICB9O1xuXG4gICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm90UmVuZGVyQ2VsbEluZGV4OiB0aGlzLm5vdFJlbmRlckNlbGxJbmRleCxcbiAgICAgICAgICAgIGxvY2tUeXBlOiB0aGlzLnByb3BzLmxvY2tUeXBlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLnNvcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBzb3J0OiBuZXh0UHJvcHMuc29ydFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gICAgICAgIGlmIChuZXh0UHJvcHMucHVyZSkge1xuICAgICAgICAgICAgY29uc3QgaXNFcXVhbCA9XG4gICAgICAgICAgICAgICAgc2hhbGxvd0VsZW1lbnRFcXVhbHMobmV4dFByb3BzLCB0aGlzLnByb3BzKSAmJlxuICAgICAgICAgICAgICAgIG9iai5zaGFsbG93RXF1YWwobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSAmJlxuICAgICAgICAgICAgICAgIG9iai5zaGFsbG93RXF1YWwobmV4dENvbnRleHQsIHRoaXMuY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gIWlzRXF1YWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVXBkYXRlKCkge1xuICAgICAgICB0aGlzLm5vdFJlbmRlckNlbGxJbmRleCA9IFtdO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZUNoaWxkcmVuU3RhdGUocHJvcHMpIHtcbiAgICAgICAgbGV0IGNvbHVtbnMgPSBwcm9wcy5jb2x1bW5zO1xuICAgICAgICBpZiAocHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbHVtbnMgPSB0aGlzLm5vcm1hbGl6ZUNoaWxkcmVuKHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEluZm9Gcm9tQmluYXJ5Q2hpbGRyZW4oY29sdW1ucyk7XG4gICAgfVxuXG4gICAgLy8g5bCGUmVhY3Tnu5PmnoTljJbmlbDmja7mj5Dlj5Zwcm9wc+i9rOaNouaIkOaVsOe7hFxuICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHByb3BzKSB7XG4gICAgICAgIGxldCB7IGNvbHVtbnMgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBnZXRDaGlsZHJlbiA9IGNoaWxkcmVuID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgICAgICAgQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IHsgLi4uY2hpbGQucHJvcHMgfTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGNoaWxkLnR5cGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2hpbGQudHlwZS5fdHlwZU1hcmsgPT09ICdjb2x1bW4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnR5cGUuX3R5cGVNYXJrID09PSAnY29sdW1uR3JvdXAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy53YXJuaW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdVc2UgPFRhYmxlLkNvbHVtbi8+LCA8VGFibGUuQ29sdW1uR3JvdXAvPiBhcyBjaGlsZC4nXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IGdldENoaWxkcmVuKGNoaWxkLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb2x1bW5zID0gZ2V0Q2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2x1bW5zO1xuICAgIH1cblxuICAgIGZldGNoSW5mb0Zyb21CaW5hcnlDaGlsZHJlbihjaGlsZHJlbikge1xuICAgICAgICBsZXQgaGFzR3JvdXBIZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgZmxhdENoaWxkcmVuID0gW10sXG4gICAgICAgICAgICBncm91cENoaWxkcmVuID0gW10sXG4gICAgICAgICAgICBnZXRDaGlsZHJlbiA9IChwcm9wc0NoaWxkcmVuLCBsZXZlbCkgPT4ge1xuICAgICAgICAgICAgICAgIGdyb3VwQ2hpbGRyZW5bbGV2ZWxdID0gZ3JvdXBDaGlsZHJlbltsZXZlbF0gfHwgW107XG4gICAgICAgICAgICAgICAgcHJvcHNDaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNHcm91cEhlYWRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDaGlsZHJlbihjaGlsZC5jaGlsZHJlbiwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYXRDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBncm91cENoaWxkcmVuW2xldmVsXS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRDb2xTcGFuID0gKGNoaWxkcmVuLCBjb2xTcGFuKSA9PiB7XG4gICAgICAgICAgICAgICAgY29sU3BhbiA9IGNvbFNwYW4gfHwgMDtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xTcGFuID0gZ2V0Q29sU3BhbihjaGlsZC5jaGlsZHJlbiwgY29sU3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xTcGFuICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sU3BhbjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgZ2V0Q2hpbGRyZW4oY2hpbGRyZW4sIDApO1xuXG4gICAgICAgIGdyb3VwQ2hpbGRyZW4uZm9yRWFjaCgoZ3JvdXBDaGlsZCwgaSkgPT4ge1xuICAgICAgICAgICAgZ3JvdXBDaGlsZC5mb3JFYWNoKChjaGlsZCwgaikgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBjb2xTcGFuO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gY2hpbGQuY2hpbGRyZW47XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29sU3BhbiA9IGdldENvbFNwYW4oY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5jb2xTcGFuID0gY29sU3BhbjtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBDaGlsZHJlbltpXVtqXSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmxhdENoaWxkcmVuLFxuICAgICAgICAgICAgZ3JvdXBDaGlsZHJlbixcbiAgICAgICAgICAgIGhhc0dyb3VwSGVhZGVyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmVuZGVyQ29sR3JvdXAoZmxhdENoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IGNvbHMgPSBmbGF0Q2hpbGRyZW4ubWFwKChjb2wsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IGNvbC53aWR0aDtcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IHt9O1xuICAgICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiA8Y29sIHN0eWxlPXtzdHlsZX0ga2V5PXtpbmRleH0gLz47XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gPGNvbGdyb3VwIGtleT1cInRhYmxlLWNvbGdyb3VwXCI+e2NvbHN9PC9jb2xncm91cD47XG4gICAgfVxuXG4gICAgb25Tb3J0ID0gKGRhdGFJbmRleCwgb3JkZXIsIHNvcnQpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLnNvcnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc29ydDogc29ydFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uU29ydChkYXRhSW5kZXgsIG9yZGVyLCBzb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblNvcnQoZGF0YUluZGV4LCBvcmRlciwgc29ydCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgb25GaWx0ZXIgPSBmaWx0ZXJQYXJhbXMgPT4ge1xuICAgICAgICB0aGlzLnByb3BzLm9uRmlsdGVyKGZpbHRlclBhcmFtcyk7XG4gICAgfTtcblxuICAgIG9uUmVzaXplQ2hhbmdlID0gKGRhdGFJbmRleCwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy5wcm9wcy5vblJlc2l6ZUNoYW5nZShkYXRhSW5kZXgsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLy8g6YCa6L+H5aS06YOo5ZKM5omB5bmz55qE57uT5p6E5riy5p+T6KGo5qC8XG4gICAgcmVuZGVyVGFibGUoZ3JvdXBDaGlsZHJlbiwgZmxhdENoaWxkcmVuKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGZsYXRDaGlsZHJlbi5sZW5ndGggfHxcbiAgICAgICAgICAgICghZmxhdENoaWxkcmVuLmxlbmd0aCAmJiAhdGhpcy5wcm9wcy5sb2NrVHlwZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgaGFzSGVhZGVyLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICAgIHdyYXBwZXJDb250ZW50LFxuICAgICAgICAgICAgICAgIGZpbHRlclBhcmFtcyxcbiAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgZGF0YVNvdXJjZSxcbiAgICAgICAgICAgICAgICBlbXB0eUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgbG9hZGluZyxcbiAgICAgICAgICAgICAgICBnZXRDZWxsUHJvcHMsXG4gICAgICAgICAgICAgICAgcHJpbWFyeUtleSxcbiAgICAgICAgICAgICAgICBnZXRSb3dQcm9wcyxcbiAgICAgICAgICAgICAgICBvblJvd0NsaWNrLFxuICAgICAgICAgICAgICAgIG9uUm93TW91c2VFbnRlcixcbiAgICAgICAgICAgICAgICBvblJvd01vdXNlTGVhdmUsXG4gICAgICAgICAgICAgICAgcHVyZVxuICAgICAgICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBjb25zdCB7IHNvcnQgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgSGVhZGVyID0gSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIFdyYXBwZXIgPSBXcmFwcGVyQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIEJvZHkgPSBCb2R5Q29tcG9uZW50XG4gICAgICAgICAgICB9ID0gY29tcG9uZW50cztcbiAgICAgICAgICAgIGNvbnN0IGNvbEdyb3VwID0gdGhpcy5yZW5kZXJDb2xHcm91cChmbGF0Q2hpbGRyZW4pO1xuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxXcmFwcGVyXG4gICAgICAgICAgICAgICAgICAgIGNvbEdyb3VwPXtjb2xHcm91cH1cbiAgICAgICAgICAgICAgICAgICAgcmVmPXt0aGlzLmdldFdyYXBwZXJSZWZ9XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeD17cHJlZml4fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAge2hhc0hlYWRlciA/IChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxIZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXg9e3ByZWZpeH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXJlPXtwdXJlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmZml4UmVmPXt0aGlzLmdldEFmZml4UmVmfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbEdyb3VwPXtjb2xHcm91cH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1oZWFkZXJgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlclBhcmFtcz17ZmlsdGVyUGFyYW1zfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnM9e2dyb3VwQ2hpbGRyZW59XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlPXtsb2NhbGV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyQ2VsbFJlZj17dGhpcy5nZXRIZWFkZXJDZWxsUmVmfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM9e2NvbXBvbmVudHN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25GaWx0ZXI9e3RoaXMub25GaWx0ZXJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydD17c29ydH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblJlc2l6ZUNoYW5nZT17dGhpcy5vblJlc2l6ZUNoYW5nZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblNvcnQ9e3RoaXMub25Tb3J0fVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgKSA6IG51bGx9XG4gICAgICAgICAgICAgICAgICAgIDxCb2R5XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXg9e3ByZWZpeH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHB1cmU9e3B1cmV9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xHcm91cD17Y29sR3JvdXB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1ib2R5YH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM9e2NvbXBvbmVudHN9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nPXtsb2FkaW5nfVxuICAgICAgICAgICAgICAgICAgICAgICAgZW1wdHlDb250ZW50PXtlbXB0eUNvbnRlbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDZWxsUHJvcHM9e2dldENlbGxQcm9wc31cbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXk9e3ByaW1hcnlLZXl9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRSb3dQcm9wcz17Z2V0Um93UHJvcHN9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zPXtmbGF0Q2hpbGRyZW59XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dSZWY9e3RoaXMuZ2V0Um93UmVmfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFJlZj17dGhpcy5nZXRDZWxsUmVmfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25Sb3dDbGljaz17b25Sb3dDbGlja31cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUm93TW91c2VFbnRlcj17b25Sb3dNb3VzZUVudGVyfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25Sb3dNb3VzZUxlYXZlPXtvblJvd01vdXNlTGVhdmV9XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhU291cmNlPXtkYXRhU291cmNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlPXtsb2NhbGV9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIHt3cmFwcGVyQ29udGVudH1cbiAgICAgICAgICAgICAgICA8L1dyYXBwZXI+XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRXcmFwcGVyUmVmID0gd3JhcHBlciA9PiB7XG4gICAgICAgIGlmICghd3JhcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyYXBwZXIgPSB3cmFwcGVyO1xuICAgIH07XG5cbiAgICBnZXRBZmZpeFJlZiA9IChhZmZpeFJlZikgPT4ge1xuICAgICAgICBpZiAoIWFmZml4UmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZmZpeFJlZjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFmZml4UmVmID0gYWZmaXhSZWY7XG4gICAgfTtcblxuICAgIGdldEhlYWRlckNlbGxSZWYgPSAoaSwgaiwgY2VsbCkgPT4ge1xuICAgICAgICBjb25zdCBjZWxsUmVmID0gYGhlYWRlcl9jZWxsXyR7aX1fJHtqfWA7XG4gICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2VsbFJlZl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tjZWxsUmVmXSA9IGNlbGw7XG4gICAgfTtcblxuICAgIGdldFJvd1JlZiA9IChpLCByb3cpID0+IHtcbiAgICAgICAgY29uc3Qgcm93UmVmID0gYHJvd18ke2l9YDtcbiAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3Jvd1JlZl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tyb3dSZWZdID0gcm93O1xuICAgIH07XG5cbiAgICBnZXRDZWxsUmVmID0gKGksIGosIGNlbGwpID0+IHtcbiAgICAgICAgY29uc3QgY2VsbFJlZiA9IGBjZWxsXyR7aX1fJHtqfWA7XG4gICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2VsbFJlZl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tjZWxsUmVmXSA9IGNlbGw7XG4gICAgfTtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5ub3JtYWxpemVDaGlsZHJlblN0YXRlKHRoaXMucHJvcHMpO1xuICAgICAgICB0aGlzLmdyb3VwQ2hpbGRyZW4gPSByZXQuZ3JvdXBDaGlsZHJlbjtcbiAgICAgICAgdGhpcy5mbGF0Q2hpbGRyZW4gPSByZXQuZmxhdENoaWxkcmVuO1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycywgcHJlZmVyLWNvbnN0ICovXG4gICAgICAgIGxldCB0YWJsZSA9IHRoaXMucmVuZGVyVGFibGUocmV0Lmdyb3VwQ2hpbGRyZW4sIHJldC5mbGF0Q2hpbGRyZW4pLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBoYXNCb3JkZXIsXG4gICAgICAgICAgICAgICAgaXNaZWJyYSxcbiAgICAgICAgICAgICAgICBsb2FkaW5nLFxuICAgICAgICAgICAgICAgIGhhc0hlYWRlcixcbiAgICAgICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICAgICAgZGF0YVNvdXJjZSxcbiAgICAgICAgICAgICAgICBlbnRpcmVEYXRhU291cmNlLFxuICAgICAgICAgICAgICAgIG9uU29ydCxcbiAgICAgICAgICAgICAgICBvblJlc2l6ZUNoYW5nZSxcbiAgICAgICAgICAgICAgICBvblJvd0NsaWNrLFxuICAgICAgICAgICAgICAgIG9uUm93TW91c2VFbnRlcixcbiAgICAgICAgICAgICAgICBvblJvd01vdXNlTGVhdmUsXG4gICAgICAgICAgICAgICAgb25GaWx0ZXIsXG4gICAgICAgICAgICAgICAgZ2V0Um93UHJvcHMsXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbFByb3BzLFxuICAgICAgICAgICAgICAgIHByaW1hcnlLZXksXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICB3cmFwcGVyQ29udGVudCxcbiAgICAgICAgICAgICAgICBsb2NrVHlwZSxcbiAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcmVmcyxcbiAgICAgICAgICAgICAgICBwdXJlLFxuICAgICAgICAgICAgICAgIHJ0bCxcbiAgICAgICAgICAgICAgICBlbXB0eUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgZmlsdGVyUGFyYW1zLFxuICAgICAgICAgICAgICAgIGxvYWRpbmdDb21wb25lbnQ6IExvYWRpbmdDb21wb25lbnQgPSBMb2FkaW5nLFxuICAgICAgICAgICAgICAgIC4uLm90aGVyc1xuICAgICAgICAgICAgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBjbHMgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4fXRhYmxlYF06IHRydWUsXG4gICAgICAgICAgICAgICAgJ29ubHktYm90dG9tLWJvcmRlcic6ICFoYXNCb3JkZXIsXG4gICAgICAgICAgICAgICAgJ25vLWhlYWRlcic6ICFoYXNIZWFkZXIsXG4gICAgICAgICAgICAgICAgemVicmE6IGlzWmVicmEsXG4gICAgICAgICAgICAgICAgW2NsYXNzTmFtZV06IGNsYXNzTmFtZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgb3RoZXJzLmRpciA9ICdydGwnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xzfSB7Li4ub3RoZXJzfT5cbiAgICAgICAgICAgICAgICB7dGFibGV9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGxvYWRpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvYWRpbmdDbGFzc05hbWUgPSBgJHtwcmVmaXh9dGFibGUtbG9hZGluZ2A7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxMb2FkaW5nQ29tcG9uZW50IGNsYXNzTmFtZT17bG9hZGluZ0NsYXNzTmFtZX0+XG4gICAgICAgICAgICAgICAgICAgIHtjb250ZW50fVxuICAgICAgICAgICAgICAgIDwvTG9hZGluZ0NvbXBvbmVudD5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2Jhc2UuanN4IiwidmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtRW50cnlFcXVhbChhLCBiKSB7XG4gIGZvciAodmFyIGsgaW4gYSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGspKSB7XG4gICAgICByZXR1cm4gYVtrXSA9PT0gYltrXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1FcXVhbChhLCBiKSB7XG4gIGlmICgoIWEgJiYgIWIpIHx8IChhID09PSBiKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghYSAhPT0gIWIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXRyYW5zZm9ybUVudHJ5RXF1YWwoYVtpXSwgYltpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dPYmplY3RFcXVhbHMoYSwgYikge1xuICB2YXIgaztcbiAgdmFyIGkgPSAwO1xuICB2YXIgaiA9IDA7XG4gIGZvciAoayBpbiBhKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYSwgaykpIHtcbiAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICBjYXNlICd0cmFuc2Zvcm0nOlxuICAgICAgICAgIGlmICghdHJhbnNmb3JtRXF1YWwoYVtrXSwgYltrXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NoYWRvd09mZnNldCc6XG4gICAgICAgICAgaWYgKCFzaGFsbG93T2JqZWN0RXF1YWxzKGFba10sIGJba10pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChhW2tdICE9PSBiW2tdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuICBmb3IgKGsgaW4gYikge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGspKSB7XG4gICAgICBqKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBpID09PSBqO1xufVxuXG5mdW5jdGlvbiBzdHlsZUVxdWFsKGEsIGIpIHtcbiAgaWYgKCghYSAmJiAhYikgfHwgKGEgPT09IGIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFhICE9PSAhYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzd2l0Y2ggKHR5cGVvZiBhKSB7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFzdHlsZUVxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2hhbGxvd09iamVjdEVxdWFscyhhLCBiKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBhID09PSBiO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVFcXVhbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fc3R5bGUtZXF1YWxAMS4wLjBAc3R5bGUtZXF1YWwvaW5kZXguanMiLCJjb25zdCBvdmVybGF5TWFuYWdlciA9IHtcbiAgICBhbGxPdmVybGF5czogW10sXG5cbiAgICBhZGRPdmVybGF5KG92ZXJsYXkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVPdmVybGF5KG92ZXJsYXkpO1xuICAgICAgICB0aGlzLmFsbE92ZXJsYXlzLnVuc2hpZnQob3ZlcmxheSk7XG4gICAgfSxcblxuICAgIGlzQ3VycmVudE92ZXJsYXkob3ZlcmxheSkge1xuICAgICAgICByZXR1cm4gb3ZlcmxheSAmJiB0aGlzLmFsbE92ZXJsYXlzWzBdID09PSBvdmVybGF5O1xuICAgIH0sXG5cbiAgICByZW1vdmVPdmVybGF5KG92ZXJsYXkpIHtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMuYWxsT3ZlcmxheXMuaW5kZXhPZihvdmVybGF5KTtcbiAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5hbGxPdmVybGF5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBvdmVybGF5TWFuYWdlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9vdmVybGF5L21hbmFnZXIuanMiLCJpbXBvcnQge2RvbX0gZnJvbSAnLi4vLi4vdXRpbCc7XG5cbmNvbnN0IFZJRVdQT1JUID0gJ3ZpZXdwb3J0JztcblxuLy8gSUU4IG5vdCBzdXBwb3J0IHBhZ2VYT2Zmc2V0XG5jb25zdCBnZXRQYWdlWCA9ICgpID0+IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcbmNvbnN0IGdldFBhZ2VZID0gKCkgPT4gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG5cbi8qKlxuICogQHByaXZhdGUgZ2V0IGVsZW1lbnQgcmVjdFxuICogQHBhcmFtICAgICAgIHtFbGVtZW50fSBlbGVtXG4gKiBAcmV0dXJuICAgICAge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gX2dldEVsZW1lbnRSZWN0IChlbGVtKSB7XG4gICAgbGV0IG9mZnNldFRvcCA9IDAsXG4gICAgICAgIG9mZnNldExlZnQgPSAwO1xuXG4gICAgY29uc3Qgb2Zmc2V0SGVpZ2h0ID0gZWxlbS5vZmZzZXRIZWlnaHQ7XG4gICAgY29uc3Qgb2Zmc2V0V2lkdGggPSBlbGVtLm9mZnNldFdpZHRoO1xuXG4gICAgZG8ge1xuICAgICAgICBpZiAoIWlzTmFOKGVsZW0ub2Zmc2V0VG9wKSkge1xuICAgICAgICAgICAgb2Zmc2V0VG9wICs9IGVsZW0ub2Zmc2V0VG9wO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNOYU4oZWxlbS5vZmZzZXRMZWZ0KSkge1xuICAgICAgICAgICAgb2Zmc2V0TGVmdCArPSBlbGVtLm9mZnNldExlZnQ7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlICgoZWxlbSA9IGVsZW0ub2Zmc2V0UGFyZW50KSAhPT0gbnVsbCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IG9mZnNldFRvcCAtIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKSxcbiAgICAgICAgbGVmdDogb2Zmc2V0TGVmdCAtIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQpLFxuICAgICAgICBoZWlnaHQ6IG9mZnNldEhlaWdodCxcbiAgICAgICAgd2lkdGg6IG9mZnNldFdpZHRoXG4gICAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZSBnZXQgdmlld3BvcnQgc2l6ZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBfZ2V0Vmlld3BvcnRTaXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgIGhlaWdodDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuICAgIH07XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3NpdGlvbiB7XG5cbiAgICBzdGF0aWMgVklFV1BPUlQgPSBWSUVXUE9SVDtcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWMgc3RhdGljIHBsYWNlIG1ldGhvZFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gICAgICAgcHJvcHNcbiAgICAgKiAgICAgQHBhcmFtICB7RE9NfSAgICAgIHByb3BzLnBpbkVsZW1lbnRcbiAgICAgKiAgICAgQHBhcmFtICB7RE9NfSAgICAgIHByb3BzLmJhc2VFbGVtZW50XG4gICAgICogICAgIEBwYXJhbSAge1N0cmluZ30gICBwcm9wcy5hbGlnblxuICAgICAqICAgICBAcGFyYW0gIHtOdW1iZXJ9ICAgcHJvcHMub2Zmc2V0XG4gICAgICogICAgIEBwYXJhbSAge0Jvb2xlYW59ICBwcm9wcy5uZWVkQWRqdXN0XG4gICAgICogICAgIEBwYXJhbSAge0Jvb2xlYW59ICBwcm9wcy5pc1J0bFxuICAgICAqIEByZXR1cm4ge1Bvc2l0aW9ufVxuICAgICAqL1xuICAgIHN0YXRpYyBwbGFjZSA9IHByb3BzID0+IG5ldyBQb3NpdGlvbihwcm9wcykuc2V0UG9zaXRpb24oKTtcblxuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgdGhpcy5waW5FbGVtZW50ID0gcHJvcHMucGluRWxlbWVudDtcbiAgICAgICAgdGhpcy5iYXNlRWxlbWVudCA9IHByb3BzLmJhc2VFbGVtZW50O1xuICAgICAgICB0aGlzLmFsaWduID0gcHJvcHMuYWxpZ24gfHwgJ3RsIHRsJztcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBwcm9wcy5vZmZzZXQgfHwgWzAsIDBdO1xuICAgICAgICB0aGlzLm5lZWRBZGp1c3QgPSBwcm9wcy5uZWVkQWRqdXN0IHx8IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUnRsID0gcHJvcHMuaXNSdGwgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgc2V0UG9zaXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHBpbkVsZW1lbnQgPSB0aGlzLnBpbkVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGJhc2VFbGVtZW50ID0gdGhpcy5iYXNlRWxlbWVudDtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRBbGlnbiA9IHRoaXMuX2dldEV4cGVjdGVkQWxpZ24oKTtcbiAgICAgICAgbGV0IGlzUGluRml4ZWQsIGlzQmFzZUZpeGVkLCBmaXJzdFBvc2l0aW9uUmVzdWx0O1xuICAgICAgICBpZiAocGluRWxlbWVudCA9PT0gVklFV1BPUlQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9tLmdldFN0eWxlKHBpbkVsZW1lbnQsICdwb3NpdGlvbicpICE9PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICBkb20uc2V0U3R5bGUocGluRWxlbWVudCwgJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJyk7XG4gICAgICAgICAgICBpc1BpbkZpeGVkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc1BpbkZpeGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZUVsZW1lbnQgPT09IFZJRVdQT1JUIHx8IGRvbS5nZXRTdHlsZShiYXNlRWxlbWVudCwgJ3Bvc2l0aW9uJykgIT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIGlzQmFzZUZpeGVkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc0Jhc2VGaXhlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8g5qC55o2u5pyf5pyb55qE5a6a5L2NXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwZWN0ZWRBbGlnbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYWxpZ24gPSBleHBlY3RlZEFsaWduW2ldO1xuICAgICAgICAgICAgY29uc3QgcGluRWxlbWVudFBvaW50cyA9IHRoaXMuX25vcm1hbGl6ZVBvc2l0aW9uKHBpbkVsZW1lbnQsIGFsaWduLnNwbGl0KCcgJylbMF0sIGlzUGluRml4ZWQpO1xuICAgICAgICAgICAgY29uc3QgYmFzZUVsZW1lbnRQb2ludHMgPSB0aGlzLl9ub3JtYWxpemVQb3NpdGlvbihiYXNlRWxlbWVudCwgYWxpZ24uc3BsaXQoJyAnKVsxXSwgaXNQaW5GaXhlZCk7XG4gICAgICAgICAgICBjb25zdCBwaW5FbGVtZW50UGFyZW50T2Zmc2V0ID0gdGhpcy5fZ2V0UGFyZW50T2Zmc2V0KHBpbkVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgYmFzZUVsZW1lbnRPZmZzZXQgPSAoaXNQaW5GaXhlZCAmJiBpc0Jhc2VGaXhlZCkgPyB0aGlzLl9nZXRMZWZ0VG9wKGJhc2VFbGVtZW50KSA6IGJhc2VFbGVtZW50UG9pbnRzLm9mZnNldCgpO1xuICAgICAgICAgICAgY29uc3QgdG9wID0gYmFzZUVsZW1lbnRPZmZzZXQudG9wICsgYmFzZUVsZW1lbnRQb2ludHMueSAtIHBpbkVsZW1lbnRQYXJlbnRPZmZzZXQudG9wIC0gcGluRWxlbWVudFBvaW50cy55O1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGJhc2VFbGVtZW50T2Zmc2V0LmxlZnQgKyBiYXNlRWxlbWVudFBvaW50cy54IC0gcGluRWxlbWVudFBhcmVudE9mZnNldC5sZWZ0ICAtIHBpbkVsZW1lbnRQb2ludHMueDtcbiAgICAgICAgICAgIHRoaXMuX3NldFBpbkVsZW1lbnRQb3N0aW9uKHBpbkVsZW1lbnQsIHtsZWZ0LCB0b3B9LCB0aGlzLm9mZnNldCk7XG5cbiAgICAgICAgICAgIGlmICghZmlyc3RQb3NpdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGZpcnN0UG9zaXRpb25SZXN1bHQgPSB7bGVmdCwgdG9wfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0luVmlld3BvcnQocGluRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxpZ247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpblZpZXdwb3J0TGVmdCA9IHRoaXMuX21ha2VFbGVtZW50SW5WaWV3cG9ydChwaW5FbGVtZW50LCBmaXJzdFBvc2l0aW9uUmVzdWx0LmxlZnQsICdMZWZ0JywgaXNQaW5GaXhlZCk7XG4gICAgICAgIGNvbnN0IGluVmlld3BvcnRUb3AgPSB0aGlzLl9tYWtlRWxlbWVudEluVmlld3BvcnQocGluRWxlbWVudCwgZmlyc3RQb3NpdGlvblJlc3VsdC50b3AsICdUb3AnLCBpc1BpbkZpeGVkKTtcblxuICAgICAgICB0aGlzLl9zZXRQaW5FbGVtZW50UG9zdGlvbihwaW5FbGVtZW50LCB7bGVmdDogaW5WaWV3cG9ydExlZnQsIHRvcDogaW5WaWV3cG9ydFRvcH0pO1xuICAgICAgICByZXR1cm4gZXhwZWN0ZWRBbGlnblswXTtcbiAgICB9XG5cbiAgICBfZ2V0UGFyZW50T2Zmc2V0KGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBsZXQgb2Zmc2V0O1xuICAgICAgICBpZiAocGFyZW50ID09PSBkb2N1bWVudC5ib2R5ICYmIGRvbS5nZXRTdHlsZShwYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgICAgICAgICAgb2Zmc2V0ID0ge1xuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0RWxlbWVudE9mZnNldChwYXJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2Zmc2V0LnRvcCArPSBwYXJzZUZsb2F0KGRvbS5nZXRTdHlsZShwYXJlbnQsICdib3JkZXItdG9wLXdpZHRoJyksIDEwKTtcbiAgICAgICAgb2Zmc2V0LmxlZnQgKz0gcGFyc2VGbG9hdChkb20uZ2V0U3R5bGUocGFyZW50LCAnYm9yZGVyLWxlZnQtd2lkdGgnKSwgMTApO1xuICAgICAgICBvZmZzZXQub2Zmc2V0UGFyZW50ID0gcGFyZW50O1xuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIF9tYWtlRWxlbWVudEluVmlld3BvcnQocGluRWxlbWVudCwgbnVtYmVyLCB0eXBlLCBpc1BpbkZpeGVkKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBudW1iZXI7XG4gICAgICAgIGNvbnN0IGRvY0VsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IG9mZnNldFBhcmVudCA9IHBpbkVsZW1lbnQub2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICBpZiAocmVzdWx0IDwgMCkge1xuICAgICAgICAgICAgaWYgKGlzUGluRml4ZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50LmJvZHkgJiYgZG9tLmdldFN0eWxlKG9mZnNldFBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSB3aGVuIGRpdidzIG9mZnNldFBhcmVudCBpcyBkb2N1bWVudC5ib2R5LCB3ZSBzZXQgbmV3IHBvc2l0aW9uIHJlc3VsdC5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBNYXRoLm1heChkb2NFbGVtZW50W2BzY3JvbGwke3R5cGV9YF0sIGRvY3VtZW50LmJvZHlbYHNjcm9sbCR7dHlwZX1gXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIF9ub3JtYWxpemVQb3NpdGlvbihlbGVtZW50LCBhbGlnbiwgaXNQaW5GaXhlZCkge1xuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9ub3JtYWxpemVFbGVtZW50KGVsZW1lbnQsIGlzUGluRml4ZWQpO1xuICAgICAgICB0aGlzLl9ub3JtYWxpemVYWShwb2ludHMsIGFsaWduKTtcblxuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cblxuICAgIF9ub3JtYWxpemVYWShwb2ludHMsIGFsaWduKSB7XG4gICAgICAgIGNvbnN0IHggPSBhbGlnbi5zcGxpdCgnJylbMV07XG4gICAgICAgIGNvbnN0IHkgPSBhbGlnbi5zcGxpdCgnJylbMF07XG5cbiAgICAgICAgcG9pbnRzLnggPSB0aGlzLl94eUNvbnZlcnRlcih4LCBwb2ludHMsICd3aWR0aCcpO1xuICAgICAgICBwb2ludHMueSA9IHRoaXMuX3h5Q29udmVydGVyKHksIHBvaW50cywgJ2hlaWdodCcpO1xuXG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuXG4gICAgX3h5Q29udmVydGVyKGFsaWduLCBwb2ludHMsIHR5cGUpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYWxpZ24ucmVwbGFjZSgvdHxsL2dpLCAnMCUnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL2MvZ2ksICc1MCUnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL2J8ci9naSwgJzEwMCUnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyhcXGQrKSUvZ2ksIGZ1bmN0aW9uKG0sIGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRzLnNpemUoKVt0eXBlXSAqIChkIC8gMTAwKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHJlcywgMTApIHx8IDA7XG4gICAgfVxuXG4gICAgX2dldExlZnRUb3AoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogcGFyc2VGbG9hdChkb20uZ2V0U3R5bGUoZWxlbWVudCwgJ2xlZnQnKSkgfHwgMCxcbiAgICAgICAgICAgIHRvcDogcGFyc2VGbG9hdChkb20uZ2V0U3R5bGUoZWxlbWVudCwgJ3RvcCcpKSB8fCAwXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgX25vcm1hbGl6ZUVsZW1lbnQoZWxlbWVudCwgaXNQaW5GaXhlZCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgIH0sIGlzVmlld3BvcnQgPSAoZWxlbWVudCA9PT0gVklFV1BPUlQpLCBkb2NFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICAgIHJlc3VsdC5vZmZzZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNQaW5GaXhlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzVmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBnZXRQYWdlWCgpLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IGdldFBhZ2VZKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RWxlbWVudE9mZnNldChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXN1bHQuc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1ZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGRvY0VsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogZG9jRWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBfZ2V0RWxlbWVudE9mZnNldChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBkb2NFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgY29uc3QgZG9jQ2xpZW50TGVmdCA9IChkb2NFbGVtZW50LmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDApO1xuICAgICAgICBjb25zdCBkb2NDbGllbnRUb3AgPSAoZG9jRWxlbWVudC5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIChnZXRQYWdlWCgpIC0gZG9jQ2xpZW50TGVmdCksXG4gICAgICAgICAgICB0b3A6IHJlY3QudG9wICsgKGdldFBhZ2VZKCkgLSBkb2NDbGllbnRUb3ApXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBsb2NhdGlvbiBvZiB0aGUgb3ZlcmZsb3cgdG8gY2FsY3VsYXRlIHRoZSBkZXNpcmVkIHBvc2l0aW9uaW5nXG4gICAgX2dldEV4cGVjdGVkQWxpZ24oKSB7XG4gICAgICAgIGNvbnN0IGFsaWduID0gdGhpcy5pc1J0bCA/IHRoaXMuX3JlcGxhY2VBbGlnbkRpcih0aGlzLmFsaWduLCAvbHxyL2csIHtsOiAncicsIHI6ICdsJ30pIDogdGhpcy5hbGlnbjtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRBbGlnbiA9IFthbGlnbl07XG5cbiAgICAgICAgaWYgKHRoaXMubmVlZEFkanVzdCkge1xuICAgICAgICAgICAgaWYgKC90fGIvZy50ZXN0KGFsaWduKSkge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkQWxpZ24ucHVzaCh0aGlzLl9yZXBsYWNlQWxpZ25EaXIoYWxpZ24sIC90fGIvZywge3Q6ICdiJywgYjogJ3QnfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC9sfHIvZy50ZXN0KGFsaWduKSkge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkQWxpZ24ucHVzaCh0aGlzLl9yZXBsYWNlQWxpZ25EaXIoYWxpZ24sIC9sfHIvZywge2w6ICdyJywgcjogJ2wnfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC9jL2cudGVzdChhbGlnbikpIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZEFsaWduLnB1c2godGhpcy5fcmVwbGFjZUFsaWduRGlyKGFsaWduLCAvYyg/PSB8JCkvZywge2M6ICdsJ30pKTtcbiAgICAgICAgICAgICAgICBleHBlY3RlZEFsaWduLnB1c2godGhpcy5fcmVwbGFjZUFsaWduRGlyKGFsaWduLCAvYyg/PSB8JCkvZywge2M6ICdyJ30pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cGVjdGVkQWxpZ24ucHVzaCh0aGlzLl9yZXBsYWNlQWxpZ25EaXIoYWxpZ24sIC9sfHJ8dHxiL2csIHtsOiAncicsIHI6ICdsJywgdDogJ2InLCBiOiAndCd9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkQWxpZ247XG4gICAgfVxuXG4gICAgLy8gVHJhbnNmb3JtIGFsaWduIG9yZGVyLlxuICAgIF9yZXBsYWNlQWxpZ25EaXIoYWxpZ24sIHJlZ0V4cCwgbWFwKSB7XG4gICAgICAgIHJldHVybiBhbGlnbi5yZXBsYWNlKHJlZ0V4cCwgcmVzID0+IHtcbiAgICAgICAgICAgIHJldHVybiBtYXBbcmVzXTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRGV0ZWN0aW5nIGVsZW1lbnQgaXMgaW4gdGhlIHdpbmRvd++8jCB3ZSB3YW50IHRvIGFkanVzdCBwb3NpdGlvbiBsYXRlci5cbiAgICBfaXNJblZpZXdwb3J0KGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3Qgdmlld3BvcnRTaXplID0gX2dldFZpZXdwb3J0U2l6ZSgpO1xuICAgICAgICAvLyBBdm9pZCBhbmltYXRlIHByb2JsZW0gdGhhdCB1c2Ugb2Zmc2V0V2lkdGggaW5zdGVhZCBvZiBnZXRCb3VuZGluZ0NsaWVudFJlY3QuXG4gICAgICAgIGNvbnN0IGVsZW1lbnRSZWN0ID0gX2dldEVsZW1lbnRSZWN0KGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gKGVsZW1lbnRSZWN0LmxlZnQgPj0gMCAmJiBlbGVtZW50UmVjdC5sZWZ0ICsgZWxlbWVudC5vZmZzZXRXaWR0aCA8PSB2aWV3cG9ydFNpemUud2lkdGggJiZcbiAgICAgICAgICAgIGVsZW1lbnRSZWN0LnRvcCA+PSAwICYmIGVsZW1lbnRSZWN0LnRvcCArIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IDw9IHZpZXdwb3J0U2l6ZS5oZWlnaHQpO1xuICAgIH1cbiAgICAvLyDlnKjov5nph4zlgZpSVEzliKTmlq0gdG9wLWxlZnQg5a6a5L2N6L2s5YyW5Li6562J5pWI55qEIHRvcC1yaWdodOWumuS9jVxuICAgIF9zZXRQaW5FbGVtZW50UG9zdGlvbihwaW5FbGVtZW50LCBwb3N0aW9uLCBvZmZzZXQgPSBbMCwgMF0pIHtcbiAgICAgICAgY29uc3Qge3RvcCwgbGVmdH0gPSBwb3N0aW9uO1xuICAgICAgICBpZiAoIXRoaXMuaXNSdGwpIHtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZShwaW5FbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgbGVmdDogYCR7bGVmdCArIG9mZnNldFswXX1weGAsXG4gICAgICAgICAgICAgICAgdG9wOiBgJHt0b3AgKyBvZmZzZXRbMV19cHhgLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmFuc2ZlciB7bGVmdCx0b3B9IGVxdWFseSB0byB7cmlnaHQsdG9wfVxuICAgICAgICBjb25zdCBwaW5FbGVtZW50UGFyZW50T2Zmc2V0ID0gdGhpcy5fZ2V0UGFyZW50T2Zmc2V0KHBpbkVsZW1lbnQpO1xuICAgICAgICBjb25zdCB7d2lkdGg6IG9mZnNldFBhcmVudFdpZHRofSA9ICBfZ2V0RWxlbWVudFJlY3QocGluRWxlbWVudFBhcmVudE9mZnNldC5vZmZzZXRQYXJlbnQpO1xuICAgICAgICBjb25zdCB7d2lkdGh9ID0gX2dldEVsZW1lbnRSZWN0KHBpbkVsZW1lbnQpO1xuICAgICAgICBjb25zdCByaWdodCA9IG9mZnNldFBhcmVudFdpZHRoIC0gKGxlZnQgKyB3aWR0aCk7XG4gICAgICAgIGRvbS5zZXRTdHlsZShwaW5FbGVtZW50LCB7XG4gICAgICAgICAgICBsZWZ0OiAnYXV0bycsXG4gICAgICAgICAgICByaWdodDogYCR7cmlnaHQgKyBvZmZzZXRbMF19cHhgLFxuICAgICAgICAgICAgdG9wOiBgJHt0b3AgKyBvZmZzZXRbMV19cHhgLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvb3ZlcmxheS91dGlscy9wb3NpdGlvbi5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGZ1bmMsIEtFWUNPREUgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBPdmVybGF5IGZyb20gJy4vb3ZlcmxheSc7XG5cbmNvbnN0IHsgbm9vcCwgbWFrZUNoYWluLCBiaW5kQ3R4IH0gPSBmdW5jO1xuXG4vKipcbiAqIE92ZXJsYXkuUG9wdXBcbiAqIEBkZXNjcmlwdGlvbiDnu6fmib8gT3ZlcmxheSDnmoQgQVBJ77yM6Zmk6Z2e54m55Yir6K+05piOXG4gKiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9wdXAgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLlhoXlrrlcbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOinpuWPkeW8ueWxguaYvuekuuaIlumakOiXj+eahOWFg+e0oFxuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcjogUHJvcFR5cGVzLmVsZW1lbnQsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDop6blj5HlvLnlsYLmmL7npLrmiJbpmpDol4/nmoTmk43kvZznsbvlnovvvIzlj6/ku6XmmK8gJ2NsaWNrJ++8jCdob3ZlcifvvIwnZm9jdXMn77yM5oiW6ICF5a6D5Lus57uE5oiQ55qE5pWw57uE77yM5aaCIFsnaG92ZXInLCAnZm9jdXMnXVxuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlclR5cGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5hcnJheV0pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5b2T5YmN5piv5ZCm5pi+56S6XG4gICAgICAgICAqL1xuICAgICAgICB2aXNpYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxgum7mOiupOaYr+WQpuaYvuekulxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdFZpc2libGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5pi+56S65oiW6ZqQ6JeP5pe26Kem5Y+R55qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSDlvLnlsYLmmK/lkKbmmL7npLpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg6Kem5Y+R5by55bGC5pi+56S65oiW6ZqQ6JeP55qE5p2l5rqQXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIERPTeS6i+S7tlxuICAgICAgICAgKi9cbiAgICAgICAgb25WaXNpYmxlQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruatpOWxnuaAp++8jOW8ueWxguaXoOazleaYvuekuuaIlumakOiXj1xuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5pi+56S65oiW6ZqQ6JeP55qE5bu25pe25pe26Ze077yI5Lul5q+r56eS5Li65Y2V5L2N77yJ77yM5ZyoIHRyaWdnZXJUeXBlIOiiq+iuvue9ruS4uiBob3ZlciDml7bnlJ/mlYhcbiAgICAgICAgICovXG4gICAgICAgIGRlbGF5OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Kem5Y+R5YWD57Sg5piv5ZCm5Y+v5Lul5YWz6Zet5by55bGCXG4gICAgICAgICAqL1xuICAgICAgICBjYW5DbG9zZUJ5VHJpZ2dlcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvLnlsYLlrprkvY3nmoTlj4LnhaflhYPntKBcbiAgICAgICAgICogQGRlZmF1bHQgdGFyZ2V0IOWxnuaAp++8jOWNs+inpuWPkeWFg+e0oFxuICAgICAgICAgKi9cbiAgICAgICAgdGFyZ2V0OiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBzYWZlTm9kZTogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpui3n+maj3RyaWdnZXLmu5rliqhcbiAgICAgICAgICovXG4gICAgICAgIGZvbGxvd1RyaWdnZXI6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBjb250YWluZXI6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIGhhc01hc2s6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICB3cmFwcGVyU3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHRyaWdnZXJUeXBlOiAnaG92ZXInLFxuICAgICAgICBkZWZhdWx0VmlzaWJsZTogZmFsc2UsXG4gICAgICAgIG9uVmlzaWJsZUNoYW5nZTogbm9vcCxcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBkZWxheTogMjAwLFxuICAgICAgICBjYW5DbG9zZUJ5VHJpZ2dlcjogdHJ1ZSxcbiAgICAgICAgZm9sbG93VHJpZ2dlcjogZmFsc2UsXG4gICAgICAgIGNvbnRhaW5lcjogKCkgPT4gZG9jdW1lbnQuYm9keSxcbiAgICAgICAgcnRsOiBmYWxzZSxcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB2aXNpYmxlOiB0eXBlb2YgcHJvcHMudmlzaWJsZSA9PT0gJ3VuZGVmaW5lZCcgPyBwcm9wcy5kZWZhdWx0VmlzaWJsZSA6IHByb3BzLnZpc2libGVcbiAgICAgICAgfTtcblxuICAgICAgICBiaW5kQ3R4KHRoaXMsIFtcbiAgICAgICAgICAgICdoYW5kbGVUcmlnZ2VyQ2xpY2snLCAnaGFuZGxlVHJpZ2dlcktleURvd24nLFxuICAgICAgICAgICAgJ2hhbmRsZVRyaWdnZXJNb3VzZUVudGVyJywgJ2hhbmRsZVRyaWdnZXJNb3VzZUxlYXZlJyxcbiAgICAgICAgICAgICdoYW5kbGVUcmlnZ2VyRm9jdXMnLCAnaGFuZGxlVHJpZ2dlckJsdXInLFxuICAgICAgICAgICAgJ2hhbmRsZUNvbnRlbnRNb3VzZUVudGVyJywgJ2hhbmRsZUNvbnRlbnRNb3VzZUxlYXZlJyxcbiAgICAgICAgICAgICdoYW5kbGVDb250ZW50TW91c2VEb3duJywgJ2hhbmRsZVJlcXVlc3RDbG9zZScsXG4gICAgICAgICAgICAnaGFuZGxlTWFza01vdXNlRW50ZXInLCAnaGFuZGxlTWFza01vdXNlTGVhdmUnXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIGlmICgndmlzaWJsZScgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiBuZXh0UHJvcHMudmlzaWJsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgWydfdGltZXInLCAnX2hpZGVUaW1lcicsICdfc2hvd1RpbWVyJ10uZm9yRWFjaCh0aW1lID0+IHtcbiAgICAgICAgICAgIHRoaXNbdGltZV0gJiYgY2xlYXJUaW1lb3V0KHRoaXNbdGltZV0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoYW5kbGVWaXNpYmxlQ2hhbmdlKHZpc2libGUsIHR5cGUsIGUpIHtcbiAgICAgICAgaWYgKCEoJ3Zpc2libGUnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJvcHMub25WaXNpYmxlQ2hhbmdlKHZpc2libGUsIHR5cGUsIGUpO1xuICAgIH1cblxuICAgIGhhbmRsZVRyaWdnZXJDbGljayhlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnZpc2libGUgJiYgIXRoaXMucHJvcHMuY2FuQ2xvc2VCeVRyaWdnZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGFuZGxlVmlzaWJsZUNoYW5nZSghdGhpcy5zdGF0ZS52aXNpYmxlLCAnZnJvbVRyaWdnZXInLCBlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVUcmlnZ2VyS2V5RG93bihlKSB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IEtFWUNPREUuU1BBQ0UgfHwgZS5rZXlDb2RlID09PSBLRVlDT0RFLkVOVEVSKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVRyaWdnZXJDbGljayhlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVRyaWdnZXJNb3VzZUVudGVyKGUpIHtcbiAgICAgICAgdGhpcy5fbW91c2VOb3RGaXJzdE9uTWFzayA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLl9oaWRlVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9oaWRlVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5faGlkZVRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc2hvd1RpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc2hvd1RpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3dUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nob3dUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVmlzaWJsZUNoYW5nZSh0cnVlLCAnZnJvbVRyaWdnZXInLCBlKTtcbiAgICAgICAgICAgIH0sIHRoaXMucHJvcHMuZGVsYXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlVHJpZ2dlck1vdXNlTGVhdmUoZSwgdHlwZSkge1xuICAgICAgICBpZiAodGhpcy5fc2hvd1RpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc2hvd1RpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3dUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5faGlkZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVWaXNpYmxlQ2hhbmdlKGZhbHNlLCB0eXBlIHx8ICdmcm9tVHJpZ2dlcicsIGUpO1xuICAgICAgICAgICAgfSwgdGhpcy5wcm9wcy5kZWxheSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVUcmlnZ2VyRm9jdXMoZSkge1xuICAgICAgICB0aGlzLmhhbmRsZVZpc2libGVDaGFuZ2UodHJ1ZSwgJ2Zyb21UcmlnZ2VyJywgZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlVHJpZ2dlckJsdXIoZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzRm9yd2FyZENvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVmlzaWJsZUNoYW5nZShmYWxzZSwgJ2Zyb21UcmlnZ2VyJywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNGb3J3YXJkQ29udGVudCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGhhbmRsZUNvbnRlbnRNb3VzZURvd24oKSB7XG4gICAgICAgIHRoaXMuX2lzRm9yd2FyZENvbnRlbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIGhhbmRsZUNvbnRlbnRNb3VzZUVudGVyKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5faGlkZVRpbWVyKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDb250ZW50TW91c2VMZWF2ZShlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlVHJpZ2dlck1vdXNlTGVhdmUoZSwgJ2Zyb21Db250ZW50Jyk7XG4gICAgfVxuXG4gICAgaGFuZGxlTWFza01vdXNlRW50ZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbW91c2VOb3RGaXJzdE9uTWFzaykge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2hpZGVUaW1lcik7XG4gICAgICAgICAgICB0aGlzLl9oaWRlVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbW91c2VOb3RGaXJzdE9uTWFzayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlTWFza01vdXNlTGVhdmUoKSB7XG4gICAgICAgIHRoaXMuX21vdXNlTm90Rmlyc3RPbk1hc2sgPSB0cnVlO1xuICAgIH1cblxuICAgIGhhbmRsZVJlcXVlc3RDbG9zZSh0eXBlLCBlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlVmlzaWJsZUNoYW5nZShmYWxzZSwgdHlwZSwgZSk7XG4gICAgfVxuXG4gICAgcmVuZGVyVHJpZ2dlcigpIHtcbiAgICAgICAgY29uc3QgeyB0cmlnZ2VyLCBkaXNhYmxlZCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgICAgICBrZXk6ICd0cmlnZ2VyJyxcbiAgICAgICAgICAgICdhcmlhLWhhc3BvcHVwJzogdHJ1ZSxcbiAgICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogdGhpcy5zdGF0ZS52aXNpYmxlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmlnZ2VyVHlwZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGNvbnN0IHRyaWdnZXJUeXBlcyA9IEFycmF5LmlzQXJyYXkodHJpZ2dlclR5cGUpID8gdHJpZ2dlclR5cGUgOiBbdHJpZ2dlclR5cGVdO1xuICAgICAgICAgICAgY29uc3QgeyBvbkNsaWNrLCBvbktleURvd24sIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlLCBvbkZvY3VzLCBvbkJsdXIgfSA9IHRyaWdnZXIucHJvcHM7XG4gICAgICAgICAgICB0cmlnZ2VyVHlwZXMuZm9yRWFjaCh0cmlnZ2VyVHlwZSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0cmlnZ2VyVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjbGljayc6XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5vbkNsaWNrID0gbWFrZUNoYWluKHRoaXMuaGFuZGxlVHJpZ2dlckNsaWNrLCBvbkNsaWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLm9uS2V5RG93biA9IG1ha2VDaGFpbih0aGlzLmhhbmRsZVRyaWdnZXJLZXlEb3duLCBvbktleURvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hvdmVyJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5vbk1vdXNlRW50ZXIgPSBtYWtlQ2hhaW4odGhpcy5oYW5kbGVUcmlnZ2VyTW91c2VFbnRlciwgb25Nb3VzZUVudGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLm9uTW91c2VMZWF2ZSA9IG1ha2VDaGFpbih0aGlzLmhhbmRsZVRyaWdnZXJNb3VzZUxlYXZlLCBvbk1vdXNlTGVhdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZvY3VzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLm9uRm9jdXMgPSBtYWtlQ2hhaW4odGhpcy5oYW5kbGVUcmlnZ2VyRm9jdXMsIG9uRm9jdXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMub25CbHVyID0gbWFrZUNoYWluKHRoaXMuaGFuZGxlVHJpZ2dlckJsdXIsIG9uQmx1cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudCh0cmlnZ2VyLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgcmVuZGVyQ29udGVudCgpIHtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgdHJpZ2dlclR5cGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHRyaWdnZXJUeXBlcyA9IEFycmF5LmlzQXJyYXkodHJpZ2dlclR5cGUpID8gdHJpZ2dlclR5cGUgOiBbdHJpZ2dlclR5cGVdO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgICAgIGNvbnN0IHsgb25Nb3VzZURvd24sIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlIH0gPSBjb250ZW50LnByb3BzO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgICAgIGtleTogJ3BvcnRhbCdcbiAgICAgICAgfTtcblxuICAgICAgICB0cmlnZ2VyVHlwZXMuZm9yRWFjaCh0cmlnZ2VyVHlwZSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRyaWdnZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZm9jdXMnOlxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5vbk1vdXNlRG93biA9IG1ha2VDaGFpbih0aGlzLmhhbmRsZUNvbnRlbnRNb3VzZURvd24sIG9uTW91c2VEb3duKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG92ZXInOlxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5vbk1vdXNlRW50ZXIgPSBtYWtlQ2hhaW4odGhpcy5oYW5kbGVDb250ZW50TW91c2VFbnRlciwgb25Nb3VzZUVudGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMub25Nb3VzZUxlYXZlID0gbWFrZUNoYWluKHRoaXMuaGFuZGxlQ29udGVudE1vdXNlTGVhdmUsIG9uTW91c2VMZWF2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNvbnRlbnQsIHByb3BzKTtcbiAgICB9XG5cbiAgICByZW5kZXJQb3J0YWwoKSB7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0LCBzYWZlTm9kZSwgZm9sbG93VHJpZ2dlciwgdHJpZ2dlclR5cGUsIGhhc01hc2ssIHdyYXBwZXJTdHlsZSwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQge2NvbnRhaW5lcn0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBmaW5kVHJpZ2dlck5vZGUgPSAoKSA9PiAoZmluZERPTU5vZGUodGhpcykgfHwge30pO1xuICAgICAgICBjb25zdCBzYWZlTm9kZXMgPSBBcnJheS5pc0FycmF5KHNhZmVOb2RlKSA/IFsuLi5zYWZlTm9kZV0gOiBbc2FmZU5vZGVdO1xuICAgICAgICBzYWZlTm9kZXMudW5zaGlmdChmaW5kVHJpZ2dlck5vZGUpO1xuXG4gICAgICAgIGNvbnN0IG5ld1dyYXBwZXJTdHlsZSA9IHdyYXBwZXJTdHlsZSB8fCB7fTtcblxuICAgICAgICBpZiAoZm9sbG93VHJpZ2dlcikge1xuICAgICAgICAgICAgY29udGFpbmVyID0gdHJpZ2dlciA9PiB0cmlnZ2VyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBuZXdXcmFwcGVyU3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyaWdnZXJUeXBlID09PSAnaG92ZXInICYmIGhhc01hc2spIHtcbiAgICAgICAgICAgIG90aGVycy5vbk1hc2tNb3VzZUVudGVyID0gdGhpcy5oYW5kbGVNYXNrTW91c2VFbnRlcjtcbiAgICAgICAgICAgIG90aGVycy5vbk1hc2tNb3VzZUxlYXZlID0gdGhpcy5oYW5kbGVNYXNrTW91c2VMZWF2ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8T3ZlcmxheSB7Li4ub3RoZXJzfVxuICAgICAgICAgICAgICAgIGtleT1cIm92ZXJsYXlcIlxuICAgICAgICAgICAgICAgIHJlZj17b3ZlcmxheSA9PiAodGhpcy5vdmVybGF5ID0gb3ZlcmxheSl9XG4gICAgICAgICAgICAgICAgdmlzaWJsZT17dGhpcy5zdGF0ZS52aXNpYmxlfVxuICAgICAgICAgICAgICAgIHRhcmdldD17dGFyZ2V0IHx8IGZpbmRUcmlnZ2VyTm9kZX1cbiAgICAgICAgICAgICAgICBjb250YWluZXI9e2NvbnRhaW5lcn1cbiAgICAgICAgICAgICAgICBzYWZlTm9kZT17c2FmZU5vZGVzfVxuICAgICAgICAgICAgICAgIHdyYXBwZXJTdHlsZT17bmV3V3JhcHBlclN0eWxlfVxuICAgICAgICAgICAgICAgIHRyaWdnZXJUeXBlPXt0cmlnZ2VyVHlwZX1cbiAgICAgICAgICAgICAgICBoYXNNYXNrPXtoYXNNYXNrfVxuICAgICAgICAgICAgICAgIG9uUmVxdWVzdENsb3NlPXt0aGlzLmhhbmRsZVJlcXVlc3RDbG9zZX0+XG4gICAgICAgICAgICAgICAge3RoaXMucmVuZGVyQ29udGVudCgpfVxuICAgICAgICAgICAgPC9PdmVybGF5PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVHJpZ2dlcigpLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJQb3J0YWwoKVxuICAgICAgICBdO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9vdmVybGF5L3BvcHVwLmpzeCIsImltcG9ydCBSZWFjdCwge0NvbXBvbmVudCwgQ2hpbGRyZW59IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgT3ZlcmxheSBmcm9tICcuLi9vdmVybGF5JztcbmltcG9ydCBDb25maWdQcm92aWRlciBmcm9tICcuLi9jb25maWctcHJvdmlkZXInO1xuaW1wb3J0IHtmdW5jfSBmcm9tICcuLi91dGlsJztcblxuY29uc3Qge25vb3AsIG1ha2VDaGFpbiwgYmluZEN0eH0gPSBmdW5jO1xuY29uc3QgUG9wdXAgPSBPdmVybGF5LlBvcHVwO1xuXG4vKipcbiAqIERyb3Bkb3duXG4gKiBAZGVzY3JpcHRpb24g57un5om/IFBvcHVwIOeahCBBUEnvvIzpmaTpnZ7nibnliKvor7TmmI5cbiAqL1xuY2xhc3MgRHJvcGRvd24gZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcHVyZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5b2T5YmN5piv5ZCm5pi+56S6XG4gICAgICAgICAqL1xuICAgICAgICB2aXNpYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxgum7mOiupOaYr+WQpuaYvuekulxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdFZpc2libGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC5pi+56S65oiW6ZqQ6JeP5pe26Kem5Y+R55qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSDlvLnlsYLmmK/lkKbmmL7npLpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg6Kem5Y+R5by55bGC5pi+56S65oiW6ZqQ6JeP55qE5p2l5rqQXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIERPTeS6i+S7tlxuICAgICAgICAgKi9cbiAgICAgICAgb25WaXNpYmxlQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOinpuWPkeW8ueWxguaYvuekuuaIluiAhemakOiXj+eahOWFg+e0oFxuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDop6blj5HlvLnlsYLmmL7npLrmiJbpmpDol4/nmoTmk43kvZznsbvlnotcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXJUeXBlOiBQcm9wVHlwZXMub25lT2YoWydob3ZlcicsICdjbGljaycsICdmb2N1cyddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruatpOWxnuaAp++8jOW8ueWxguaXoOazleaYvuekuuaIlumakOiXj1xuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC55u45a+55LqO6Kem5Y+R5YWD57Sg55qE5a6a5L2NLCDor6bop4EgT3ZlcmxheSDnmoTlrprkvY3pg6jliIZcbiAgICAgICAgICovXG4gICAgICAgIGFsaWduOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bGC55u45a+55LqO6Kem5Y+R5YWD57Sg5a6a5L2N55qE5b6u6LCDXG4gICAgICAgICAqL1xuICAgICAgICBvZmZzZXQ6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguaYvuekuuaIlumakOiXj+eahOW7tuaXtuaXtumXtO+8iOS7peavq+enkuS4uuWNleS9je+8ie+8jOWcqCB0cmlnZ2VyVHlwZSDooqvorr7nva7kuLogaG92ZXIg5pe255Sf5pWIXG4gICAgICAgICAqL1xuICAgICAgICBkZWxheTogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueWxguaJk+W8gOaXtuaYr+WQpuiuqeWFtuS4reeahOWFg+e0oOiHquWKqOiOt+WPlueEpueCuVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b0ZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuaYvuekuumBrue9qVxuICAgICAgICAgKi9cbiAgICAgICAgaGFzTWFzazogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpmpDol4/ml7bmmK/lkKbkv53nlZnlrZDoioLngrlcbiAgICAgICAgICovXG4gICAgICAgIGNhY2hlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmFjee9ruWKqOeUu+eahOaSreaUvuaWueW8j++8jOaUr+aMgSB7IGluOiAnZW50ZXItY2xhc3MnLCBvdXQ6ICdsZWF2ZS1jbGFzcycgfSDnmoTlr7nosaHlj4LmlbDvvIzlpoLmnpzorr7nva7kuLogZmFsc2XvvIzliJnkuI3mkq3mlL7liqjnlLtcbiAgICAgICAgICogQGRlZmF1bHQgeyBpbjogJ2V4cGFuZEluRG93bicsIG91dDogJ2V4cGFuZE91dFVwJyB9XG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRpb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5ib29sXSksXG4gICAgfTtcbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBwcmVmaXg6ICduZXh0LScsXG4gICAgICAgIHB1cmU6IGZhbHNlLFxuICAgICAgICBkZWZhdWx0VmlzaWJsZTogZmFsc2UsXG4gICAgICAgIG9uVmlzaWJsZUNoYW5nZTogbm9vcCxcbiAgICAgICAgdHJpZ2dlclR5cGU6ICdob3ZlcicsXG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgYWxpZ246ICd0bCBibCcsXG4gICAgICAgIG9mZnNldDogWzAsIDBdLFxuICAgICAgICBkZWxheTogMjAwLFxuICAgICAgICBhdXRvRm9jdXM6IHRydWUsXG4gICAgICAgIGhhc01hc2s6IGZhbHNlLFxuICAgICAgICBjYWNoZTogZmFsc2UsXG4gICAgICAgIG9uUG9zaXRpb246IG5vb3BcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB2aXNpYmxlOiAndmlzaWJsZScgaW4gcHJvcHMgPyBwcm9wcy52aXNpYmxlIDogKHByb3BzLmRlZmF1bHRWaXNpYmxlIHx8IGZhbHNlKVxuICAgICAgICB9O1xuXG4gICAgICAgIGJpbmRDdHgodGhpcywgW1xuICAgICAgICAgICAgJ29uTWVudUNsaWNrJyxcbiAgICAgICAgICAgICdvblZpc2libGVDaGFuZ2UnXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIGdldFZpc2libGUocHJvcHMgPSB0aGlzLnByb3BzKSB7XG4gICAgICAgIHJldHVybiAndmlzaWJsZScgaW4gcHJvcHMgPyBwcm9wcy52aXNpYmxlIDogdGhpcy5zdGF0ZS52aXNpYmxlO1xuICAgIH1cblxuICAgIG9uTWVudUNsaWNrKCkge1xuICAgICAgICB0aGlzLm9uVmlzaWJsZUNoYW5nZShmYWxzZSwgJ2Zyb21Db250ZW50Jyk7XG4gICAgfVxuXG4gICAgb25WaXNpYmxlQ2hhbmdlKHZpc2libGUsIGZyb20pIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7dmlzaWJsZX0pO1xuXG4gICAgICAgIHRoaXMucHJvcHMub25WaXNpYmxlQ2hhbmdlKHZpc2libGUsIGZyb20pO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC50eXBlID09PSAnZnVuY3Rpb24nICYmIGNoaWxkLnR5cGUuaXNOZXh0TWVudSkge1xuICAgICAgICAgICAgY2hpbGQgPSBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgICAgICAgICBvbkl0ZW1DbGljazogbWFrZUNoYWluKHRoaXMub25NZW51Q2xpY2ssIGNoaWxkLnByb3BzLm9uSXRlbUNsaWNrKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPFBvcHVwIHsuLi50aGlzLnByb3BzfVxuICAgICAgICAgICAgICAgIHZpc2libGU9e3RoaXMuZ2V0VmlzaWJsZSgpfVxuICAgICAgICAgICAgICAgIG9uVmlzaWJsZUNoYW5nZT17dGhpcy5vblZpc2libGVDaGFuZ2V9XG4gICAgICAgICAgICAgICAgY2FuQ2xvc2VCeU91dFNpZGVDbGljaz57Y2hpbGR9PC9Qb3B1cD5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZ1Byb3ZpZGVyLmNvbmZpZyhEcm9wZG93bik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZHJvcGRvd24vaW5kZXguanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgQ2hpbGRyZW4sIGNsb25lRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgQW5pbWF0ZSBmcm9tICcuLi8uLi9hbmltYXRlJztcbmltcG9ydCBJY29uIGZyb20gJy4uLy4uL2ljb24nO1xuaW1wb3J0IHsgZnVuYywgb2JqIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgSXRlbSBmcm9tICcuL2l0ZW0nO1xuaW1wb3J0IFNlbGVjdGFiZWxJdGVtIGZyb20gJy4vc2VsZWN0YWJsZS1pdGVtJztcbmltcG9ydCBQb3B1cEl0ZW0gZnJvbSAnLi9wb3B1cC1pdGVtJztcblxuY29uc3QgeyBFeHBhbmQgfSA9IEFuaW1hdGU7XG5jb25zdCB7IGJpbmRDdHggfSA9IGZ1bmM7XG5cbi8qKlxuICogTWVudS5TdWJNZW51XG4gKiBAb3JkZXIgMVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdWJNZW51IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgbWVudUNoaWxkVHlwZSA9ICdzdWJtZW51JztcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIF9rZXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHJvb3Q6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIGxldmVsOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBncm91cEluZGVudDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOagh+etvuWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5Y+v6YCJ77yM6K+l5bGe5oCn5LuF5Zyo6K6+572uIE1lbnUg57uE5Lu2IHNlbGVjdE1vZGUg5bGe5oCn5ZCO55Sf5pWIXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3RhYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWtkOiPnOWNleaJk+W8gOaWueW8j++8jOWmguaenOiuvue9ruS8muimhuebliBNZW51IOS4iueahOWQjOWQjeWxnuaAp1xuICAgICAgICAgKiBAZGVmYXVsdCBNZW51IOeahCBtb2RlIOWxnuaAp+WAvFxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZTogUHJvcFR5cGVzLm9uZU9mKFsnaW5saW5lJywgJ3BvcHVwJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog6I+c5Y2V6aG55oiW5LiL5LiA57qn5a2Q6I+c5Y2VXG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIG9uTW91c2VFbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uTW91c2VMZWF2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIHN1Yk1lbnVDb250ZW50Q2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICB0cmlnZ2VyVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnY2xpY2snLCAnaG92ZXInXSksXG4gICAgICAgIGFsaWduOiBQcm9wVHlwZXMub25lT2YoWydvdXRzaWRlJywgJ2ZvbGxvdyddKSxcbiAgICAgICAgcGFyZW50TW9kZTogUHJvcFR5cGVzLm9uZU9mKFsnaW5saW5lJywgJ3BvcHVwJ10pXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGdyb3VwSW5kZW50OiAwLFxuICAgICAgICBzZWxlY3RhYmxlOiBmYWxzZVxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgYmluZEN0eCh0aGlzLCBbXG4gICAgICAgICAgICAnaGFuZGxlTW91c2VFbnRlcicsICdoYW5kbGVNb3VzZUxlYXZlJywgJ2hhbmRsZUNsaWNrJyxcbiAgICAgICAgICAgICdoYW5kbGVPcGVuJywgJ2FmdGVyTGVhdmUnXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLml0ZW1Ob2RlID0gZmluZERPTU5vZGUodGhpcyk7XG4gICAgfVxuXG4gICAgYWZ0ZXJMZWF2ZSgpIHtcbiAgICAgICAgY29uc3QgeyBmb2N1c2VkLCByb290IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IGZvY3VzYWJsZSB9ID0gcm9vdC5wcm9wcztcbiAgICAgICAgaWYgKGZvY3VzYWJsZSAmJiBmb2N1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1Ob2RlLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRPcGVuKCkge1xuICAgICAgICBjb25zdCB7IF9rZXksIHJvb3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgb3BlbktleXMgfSA9IHJvb3Quc3RhdGU7XG5cbiAgICAgICAgcmV0dXJuIG9wZW5LZXlzLmluZGV4T2YoX2tleSkgPiAtMTtcbiAgICB9XG5cbiAgICBoYW5kbGVNb3VzZUVudGVyKGUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVPcGVuKHRydWUpO1xuXG4gICAgICAgIHRoaXMucHJvcHMub25Nb3VzZUVudGVyICYmIHRoaXMucHJvcHMub25Nb3VzZUVudGVyKGUpO1xuICAgIH1cblxuICAgIGhhbmRsZU1vdXNlTGVhdmUoZSkge1xuICAgICAgICB0aGlzLmhhbmRsZU9wZW4oZmFsc2UpO1xuXG4gICAgICAgIHRoaXMucHJvcHMub25Nb3VzZUxlYXZlICYmIHRoaXMucHJvcHMub25Nb3VzZUxlYXZlKGUpO1xuICAgIH1cblxuICAgIGhhbmRsZUNsaWNrKGUpIHtcbiAgICAgICAgY29uc3QgeyByb290LCBzZWxlY3RhYmxlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHNlbGVjdE1vZGUgfSA9IHJvb3QucHJvcHM7XG4gICAgICAgIGlmIChzZWxlY3RNb2RlICYmIHNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvcGVuID0gdGhpcy5nZXRPcGVuKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlT3Blbighb3Blbik7XG4gICAgfVxuXG4gICAgaGFuZGxlT3BlbihvcGVuLCB0cmlnZ2VyVHlwZSwgZSkge1xuICAgICAgICBjb25zdCB7IF9rZXksIHJvb3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJvb3QuaGFuZGxlT3Blbihfa2V5LCBvcGVuLCB0cmlnZ2VyVHlwZSwgZSk7XG4gICAgfVxuXG4gICAgcGFzc1BhcmVudFRvQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgeyBtb2RlLCByb290IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIHJldHVybiBDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGNoaWxkID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgcGFyZW50TW9kZTogbW9kZSB8fCByb290LnByb3BzLm1vZGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXJJbmxpbmUoKSB7XG4gICAgICAgIGNvbnN0IHsgX2tleSwgbGV2ZWwsIHJvb3QsIGNsYXNzTmFtZSwgc2VsZWN0YWJsZTogc2VsZWN0YWJsZUZyb21Qcm9wcywgbGFiZWwsIGNoaWxkcmVuLCBzdWJNZW51Q29udGVudENsYXNzTmFtZSwgdHJpZ2dlclR5cGU6IHByb3BzVHJpZ2dlclR5cGUsIHBhcmVudE1vZGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBzZWxlY3RNb2RlLCB0cmlnZ2VyVHlwZTogcm9vdFRyaWdnZXJUeXBlLCBpbmxpbmVBcnJvd0RpcmVjdGlvbiwgZXhwYW5kQW5pbWF0aW9uLCBydGwgfSA9IHJvb3QucHJvcHM7XG4gICAgICAgIGNvbnN0IHRyaWdnZXJUeXBlID0gcHJvcHNUcmlnZ2VyVHlwZSB8fCByb290VHJpZ2dlclR5cGU7XG4gICAgICAgIGNvbnN0IG9wZW4gPSB0aGlzLmdldE9wZW4oKTtcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gb2JqLnBpY2tPdGhlcnMoT2JqZWN0LmtleXMoU3ViTWVudS5wcm9wVHlwZXMpLCB0aGlzLnByb3BzKTtcblxuICAgICAgICBjb25zdCBsaVByb3BzID0ge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBjeCh7XG4gICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1tZW51LXN1Yi1tZW51LXdyYXBwZXJgXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBbY2xhc3NOYW1lXTogISFjbGFzc05hbWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGl0ZW1Qcm9wcyA9IHtcbiAgICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogb3BlbixcbiAgICAgICAgICAgIF9rZXksXG4gICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICB0eXBlOiAnc3VibWVudScsXG4gICAgICAgICAgICBjb21wb25lbnQ6ICdkaXYnLFxuICAgICAgICAgICAgcGFyZW50TW9kZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhcnJvclByb3BzID0ge1xuICAgICAgICAgICAgdHlwZTogaW5saW5lQXJyb3dEaXJlY3Rpb24gPT09ICdyaWdodCcgPyAnYXJyb3ctcmlnaHQnIDogJ2Fycm93LWRvd24nLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjeCh7XG4gICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1tZW51LWljb24tYXJyb3dgXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4fW1lbnUtaWNvbi1hcnJvdy1kb3duYF06IGlubGluZUFycm93RGlyZWN0aW9uID09PSAnZG93bicsXG4gICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1tZW51LWljb24tYXJyb3ctcmlnaHRgXTogaW5saW5lQXJyb3dEaXJlY3Rpb24gPT09ICdyaWdodCcsXG4gICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1vcGVuYF06IG9wZW5cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgc2VsZWN0YWJsZSA9ICEhc2VsZWN0TW9kZSAmJiBzZWxlY3RhYmxlRnJvbVByb3BzO1xuICAgICAgICBjb25zdCBOZXdJdGVtID0gc2VsZWN0YWJsZSA/IFNlbGVjdGFiZWxJdGVtIDogSXRlbTtcblxuICAgICAgICBpZiAodHJpZ2dlclR5cGUgPT09ICdob3ZlcicpIHtcbiAgICAgICAgICAgIGxpUHJvcHMub25Nb3VzZUVudGVyID0gdGhpcy5oYW5kbGVNb3VzZUVudGVyO1xuICAgICAgICAgICAgbGlQcm9wcy5vbk1vdXNlTGVhdmUgPSB0aGlzLmhhbmRsZU1vdXNlTGVhdmU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgYXJyb3JQcm9wcy5vbkNsaWNrID0gdGhpcy5oYW5kbGVDbGljaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW1Qcm9wcy5vbkNsaWNrID0gdGhpcy5oYW5kbGVDbGljaztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgaXRlbVByb3BzLmNsYXNzTmFtZSA9IGAke3ByZWZpeH1vcGVuZWRgO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmV3U3ViTWVudUNvbnRlbnRDbGFzc05hbWUgPSBjeCh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fW1lbnUtc3ViLW1lbnVgXTogdHJ1ZSxcbiAgICAgICAgICAgIFtzdWJNZW51Q29udGVudENsYXNzTmFtZV06ICEhc3ViTWVudUNvbnRlbnRDbGFzc05hbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgc3ViTWVudSA9IG9wZW4gPyAoXG4gICAgICAgICAgICA8dWwgcm9sZT1cIm1lbnVcIiBkaXI9e3J0bCA/ICdydGwnIDogdW5kZWZpbmVkfSByZWY9XCJzdWJNZW51XCIgY2xhc3NOYW1lPXtuZXdTdWJNZW51Q29udGVudENsYXNzTmFtZX0+XG4gICAgICAgICAgICAgICAge3RoaXMucGFzc1BhcmVudFRvQ2hpbGRyZW4oY2hpbGRyZW4pfVxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgKSA6IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxsaSB7Li4ub3RoZXJzfSB7Li4ubGlQcm9wc30+XG4gICAgICAgICAgICAgICAgPE5ld0l0ZW0gey4uLml0ZW1Qcm9wc30+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YCR7cHJlZml4fW1lbnUtaXRlbS10ZXh0YH0+e2xhYmVsfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPEljb24gey4uLmFycm9yUHJvcHN9IC8+XG4gICAgICAgICAgICAgICAgPC9OZXdJdGVtPlxuICAgICAgICAgICAgICAgIHtleHBhbmRBbmltYXRpb24gPyAoXG4gICAgICAgICAgICAgICAgICAgIDxFeHBhbmQgYW5pbWF0aW9uQXBwZWFyPXtmYWxzZX0gYWZ0ZXJMZWF2ZT17dGhpcy5hZnRlckxlYXZlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtzdWJNZW51fVxuICAgICAgICAgICAgICAgICAgICA8L0V4cGFuZD5cbiAgICAgICAgICAgICAgICApIDogc3ViTWVudX1cblxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXJQb3B1cCgpIHtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgc3ViTWVudUNvbnRlbnRDbGFzc05hbWUsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMucHJvcHMucm9vdDtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHBvcHVwQ2xhc3NOYW1lLCBwb3B1cFN0eWxlLCBydGwgfSA9IHJvb3QucHJvcHM7XG5cbiAgICAgICAgY29uc3QgbmV3Q2xhc3NOYW1lID0gY3goe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1tZW51YF06IHRydWUsXG4gICAgICAgICAgICBbYCR7cHJlZml4fXZlcmBdOiB0cnVlLFxuICAgICAgICAgICAgW3BvcHVwQ2xhc3NOYW1lXTogISFwb3B1cENsYXNzTmFtZSxcbiAgICAgICAgICAgIFtzdWJNZW51Q29udGVudENsYXNzTmFtZV06ICEhc3ViTWVudUNvbnRlbnRDbGFzc05hbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb3RoZXJzLnJ0bCA9IHJ0bDtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPFBvcHVwSXRlbSB7Li4ub3RoZXJzfSBoYXNTdWJNZW51PlxuICAgICAgICAgICAgICAgIDx1bCByb2xlPVwibWVudVwiIGRpcj17cnRsID8gJ3J0bCcgOiB1bmRlZmluZWR9IGNsYXNzTmFtZT17bmV3Q2xhc3NOYW1lfSBzdHlsZT17cG9wdXBTdHlsZX0+XG4gICAgICAgICAgICAgICAgICAgIHt0aGlzLnBhc3NQYXJlbnRUb0NoaWxkcmVuKGNoaWxkcmVuKX1cbiAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPC9Qb3B1cEl0ZW0+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IG1vZGUsIHJvb3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IG5ld01vZGUgPSBtb2RlIHx8IHJvb3QucHJvcHMubW9kZTtcblxuICAgICAgICByZXR1cm4gbmV3TW9kZSA9PT0gJ3BvcHVwJyA/XG4gICAgICAgICAgICB0aGlzLnJlbmRlclBvcHVwKCkgOlxuICAgICAgICAgICAgdGhpcy5yZW5kZXJJbmxpbmUoKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWVudS92aWV3L3N1Yi1tZW51LmpzeCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgUHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuXG52YXIgX2FkZENsYXNzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiZG9tLWhlbHBlcnMvY2xhc3MvYWRkQ2xhc3NcIikpO1xuXG52YXIgX3JlbW92ZUNsYXNzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiZG9tLWhlbHBlcnMvY2xhc3MvcmVtb3ZlQ2xhc3NcIikpO1xuXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX1RyYW5zaXRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1RyYW5zaXRpb25cIikpO1xuXG52YXIgX1Byb3BUeXBlcyA9IHJlcXVpcmUoXCIuL3V0aWxzL1Byb3BUeXBlc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxudmFyIGFkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3Mobm9kZSwgY2xhc3Nlcykge1xuICByZXR1cm4gbm9kZSAmJiBjbGFzc2VzICYmIGNsYXNzZXMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICgwLCBfYWRkQ2xhc3MuZGVmYXVsdCkobm9kZSwgYyk7XG4gIH0pO1xufTtcblxudmFyIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24gcmVtb3ZlQ2xhc3Mobm9kZSwgY2xhc3Nlcykge1xuICByZXR1cm4gbm9kZSAmJiBjbGFzc2VzICYmIGNsYXNzZXMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICgwLCBfcmVtb3ZlQ2xhc3MuZGVmYXVsdCkobm9kZSwgYyk7XG4gIH0pO1xufTtcblxudmFyIHByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IF9leHRlbmRzKHt9LCBfVHJhbnNpdGlvbi5kZWZhdWx0LnByb3BUeXBlcywge1xuICAvKipcbiAgICogVGhlIGFuaW1hdGlvbiBjbGFzc05hbWVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudCBhcyBpdCBlbnRlcnMsIGV4aXRzIG9yIGhhcyBmaW5pc2hlZCB0aGUgdHJhbnNpdGlvbi5cbiAgICogQSBzaW5nbGUgbmFtZSBjYW4gYmUgcHJvdmlkZWQgYW5kIGl0IHdpbGwgYmUgc3VmZml4ZWQgZm9yIGVhY2ggc3RhZ2U6IGUuZy5cbiAgICpcbiAgICogYGNsYXNzTmFtZXM9XCJmYWRlXCJgIGFwcGxpZXMgYGZhZGUtZW50ZXJgLCBgZmFkZS1lbnRlci1hY3RpdmVgLCBgZmFkZS1lbnRlci1kb25lYCxcbiAgICogYGZhZGUtZXhpdGAsIGBmYWRlLWV4aXQtYWN0aXZlYCwgYGZhZGUtZXhpdC1kb25lYCwgYGZhZGUtYXBwZWFyYCwgYW5kIGBmYWRlLWFwcGVhci1hY3RpdmVgLlxuICAgKiBFYWNoIGluZGl2aWR1YWwgY2xhc3NOYW1lcyBjYW4gYWxzbyBiZSBzcGVjaWZpZWQgaW5kZXBlbmRlbnRseSBsaWtlOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjbGFzc05hbWVzPXt7XG4gICAqICBhcHBlYXI6ICdteS1hcHBlYXInLFxuICAgKiAgYXBwZWFyQWN0aXZlOiAnbXktYWN0aXZlLWFwcGVhcicsXG4gICAqICBlbnRlcjogJ215LWVudGVyJyxcbiAgICogIGVudGVyQWN0aXZlOiAnbXktYWN0aXZlLWVudGVyJyxcbiAgICogIGVudGVyRG9uZTogJ215LWRvbmUtZW50ZXInLFxuICAgKiAgZXhpdDogJ215LWV4aXQnLFxuICAgKiAgZXhpdEFjdGl2ZTogJ215LWFjdGl2ZS1leGl0JyxcbiAgICogIGV4aXREb25lOiAnbXktZG9uZS1leGl0JyxcbiAgICogfX1cbiAgICogYGBgXG4gICAqXG4gICAqIElmIHlvdSB3YW50IHRvIHNldCB0aGVzZSBjbGFzc2VzIHVzaW5nIENTUyBNb2R1bGVzOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLmNzcyc7XG4gICAqIGBgYFxuICAgKlxuICAgKiB5b3UgbWlnaHQgd2FudCB0byB1c2UgY2FtZWxDYXNlIGluIHlvdXIgQ1NTIGZpbGUsIHRoYXQgd2F5IGNvdWxkIHNpbXBseSBzcHJlYWRcbiAgICogdGhlbSBpbnN0ZWFkIG9mIGxpc3RpbmcgdGhlbSBvbmUgYnkgb25lOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjbGFzc05hbWVzPXt7IC4uLnN0eWxlcyB9fVxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge3N0cmluZyB8IHtcbiAgICogIGFwcGVhcj86IHN0cmluZyxcbiAgICogIGFwcGVhckFjdGl2ZT86IHN0cmluZyxcbiAgICogIGVudGVyPzogc3RyaW5nLFxuICAgKiAgZW50ZXJBY3RpdmU/OiBzdHJpbmcsXG4gICAqICBlbnRlckRvbmU/OiBzdHJpbmcsXG4gICAqICBleGl0Pzogc3RyaW5nLFxuICAgKiAgZXhpdEFjdGl2ZT86IHN0cmluZyxcbiAgICogIGV4aXREb25lPzogc3RyaW5nLFxuICAgKiB9fVxuICAgKi9cbiAgY2xhc3NOYW1lczogX1Byb3BUeXBlcy5jbGFzc05hbWVzU2hhcGUsXG5cbiAgLyoqXG4gICAqIEEgYDxUcmFuc2l0aW9uPmAgY2FsbGJhY2sgZmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlICdlbnRlcicgb3IgJ2FwcGVhcicgY2xhc3MgaXNcbiAgICogYXBwbGllZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKVxuICAgKi9cbiAgb25FbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEEgYDxUcmFuc2l0aW9uPmAgY2FsbGJhY2sgZmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlICdlbnRlci1hY3RpdmUnIG9yXG4gICAqICdhcHBlYXItYWN0aXZlJyBjbGFzcyBpcyBhcHBsaWVkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpXG4gICAqL1xuICBvbkVudGVyaW5nOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQSBgPFRyYW5zaXRpb24+YCBjYWxsYmFjayBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgJ2VudGVyJyBvclxuICAgKiAnYXBwZWFyJyBjbGFzc2VzIGFyZSAqKnJlbW92ZWQqKiBhbmQgdGhlIGBkb25lYCBjbGFzcyBpcyBhZGRlZCB0byB0aGUgRE9NIG5vZGUuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbClcbiAgICovXG4gIG9uRW50ZXJlZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEEgYDxUcmFuc2l0aW9uPmAgY2FsbGJhY2sgZmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlICdleGl0JyBjbGFzcyBpc1xuICAgKiBhcHBsaWVkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudClcbiAgICovXG4gIG9uRXhpdDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEEgYDxUcmFuc2l0aW9uPmAgY2FsbGJhY2sgZmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlICdleGl0LWFjdGl2ZScgaXMgYXBwbGllZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpXG4gICAqL1xuICBvbkV4aXRpbmc6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBBIGA8VHJhbnNpdGlvbj5gIGNhbGxiYWNrIGZpcmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSAnZXhpdCcgY2xhc3Nlc1xuICAgKiBhcmUgKipyZW1vdmVkKiogYW5kIHRoZSBgZXhpdC1kb25lYCBjbGFzcyBpcyBhZGRlZCB0byB0aGUgRE9NIG5vZGUuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KVxuICAgKi9cbiAgb25FeGl0ZWQ6IFByb3BUeXBlcy5mdW5jXG59KSA6IHt9Oztcbi8qKlxuICogQSBgVHJhbnNpdGlvbmAgY29tcG9uZW50IHVzaW5nIENTUyB0cmFuc2l0aW9ucyBhbmQgYW5pbWF0aW9ucy5cbiAqIEl0J3MgaW5zcGlyZWQgYnkgdGhlIGV4Y2VsbGVudCBbbmctYW5pbWF0ZV0oaHR0cDovL3d3dy5uZ2FuaW1hdGUub3JnLykgbGlicmFyeS5cbiAqXG4gKiBgQ1NTVHJhbnNpdGlvbmAgYXBwbGllcyBhIHBhaXIgb2YgY2xhc3MgbmFtZXMgZHVyaW5nIHRoZSBgYXBwZWFyYCwgYGVudGVyYCxcbiAqIGFuZCBgZXhpdGAgc3RhZ2VzIG9mIHRoZSB0cmFuc2l0aW9uLiBUaGUgZmlyc3QgY2xhc3MgaXMgYXBwbGllZCBhbmQgdGhlbiBhXG4gKiBzZWNvbmQgXCJhY3RpdmVcIiBjbGFzcyBpbiBvcmRlciB0byBhY3RpdmF0ZSB0aGUgY3NzIGFuaW1hdGlvbi4gQWZ0ZXIgdGhlIGFuaW1hdGlvbixcbiAqIG1hdGNoaW5nIGBkb25lYCBjbGFzcyBuYW1lcyBhcmUgYXBwbGllZCB0byBwZXJzaXN0IHRoZSBhbmltYXRpb24gc3RhdGUuXG4gKlxuICogV2hlbiB0aGUgYGluYCBwcm9wIGlzIHRvZ2dsZWQgdG8gYHRydWVgIHRoZSBDb21wb25lbnQgd2lsbCBnZXRcbiAqIHRoZSBgZXhhbXBsZS1lbnRlcmAgQ1NTIGNsYXNzIGFuZCB0aGUgYGV4YW1wbGUtZW50ZXItYWN0aXZlYCBDU1MgY2xhc3NcbiAqIGFkZGVkIGluIHRoZSBuZXh0IHRpY2suIFRoaXMgaXMgYSBjb252ZW50aW9uIGJhc2VkIG9uIHRoZSBgY2xhc3NOYW1lc2AgcHJvcC5cbiAqL1xuXG52YXIgQ1NTVHJhbnNpdGlvbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShDU1NUcmFuc2l0aW9uLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBDU1NUcmFuc2l0aW9uKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMub25FbnRlciA9IGZ1bmN0aW9uIChub2RlLCBhcHBlYXJpbmcpIHtcbiAgICAgIHZhciBfdGhpcyRnZXRDbGFzc05hbWVzID0gX3RoaXMuZ2V0Q2xhc3NOYW1lcyhhcHBlYXJpbmcgPyAnYXBwZWFyJyA6ICdlbnRlcicpLFxuICAgICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJGdldENsYXNzTmFtZXMuY2xhc3NOYW1lO1xuXG4gICAgICBfdGhpcy5yZW1vdmVDbGFzc2VzKG5vZGUsICdleGl0Jyk7XG5cbiAgICAgIGFkZENsYXNzKG5vZGUsIGNsYXNzTmFtZSk7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkVudGVyKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uRW50ZXIobm9kZSwgYXBwZWFyaW5nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25FbnRlcmluZyA9IGZ1bmN0aW9uIChub2RlLCBhcHBlYXJpbmcpIHtcbiAgICAgIHZhciBfdGhpcyRnZXRDbGFzc05hbWVzMiA9IF90aGlzLmdldENsYXNzTmFtZXMoYXBwZWFyaW5nID8gJ2FwcGVhcicgOiAnZW50ZXInKSxcbiAgICAgICAgICBhY3RpdmVDbGFzc05hbWUgPSBfdGhpcyRnZXRDbGFzc05hbWVzMi5hY3RpdmVDbGFzc05hbWU7XG5cbiAgICAgIF90aGlzLnJlZmxvd0FuZEFkZENsYXNzKG5vZGUsIGFjdGl2ZUNsYXNzTmFtZSk7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkVudGVyaW5nKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uRW50ZXJpbmcobm9kZSwgYXBwZWFyaW5nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25FbnRlcmVkID0gZnVuY3Rpb24gKG5vZGUsIGFwcGVhcmluZykge1xuICAgICAgdmFyIF90aGlzJGdldENsYXNzTmFtZXMzID0gX3RoaXMuZ2V0Q2xhc3NOYW1lcygnZW50ZXInKSxcbiAgICAgICAgICBkb25lQ2xhc3NOYW1lID0gX3RoaXMkZ2V0Q2xhc3NOYW1lczMuZG9uZUNsYXNzTmFtZTtcblxuICAgICAgX3RoaXMucmVtb3ZlQ2xhc3Nlcyhub2RlLCBhcHBlYXJpbmcgPyAnYXBwZWFyJyA6ICdlbnRlcicpO1xuXG4gICAgICBhZGRDbGFzcyhub2RlLCBkb25lQ2xhc3NOYW1lKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRW50ZXJlZCkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkVudGVyZWQobm9kZSwgYXBwZWFyaW5nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25FeGl0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBfdGhpcyRnZXRDbGFzc05hbWVzNCA9IF90aGlzLmdldENsYXNzTmFtZXMoJ2V4aXQnKSxcbiAgICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRnZXRDbGFzc05hbWVzNC5jbGFzc05hbWU7XG5cbiAgICAgIF90aGlzLnJlbW92ZUNsYXNzZXMobm9kZSwgJ2FwcGVhcicpO1xuXG4gICAgICBfdGhpcy5yZW1vdmVDbGFzc2VzKG5vZGUsICdlbnRlcicpO1xuXG4gICAgICBhZGRDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25FeGl0KSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uRXhpdChub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25FeGl0aW5nID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBfdGhpcyRnZXRDbGFzc05hbWVzNSA9IF90aGlzLmdldENsYXNzTmFtZXMoJ2V4aXQnKSxcbiAgICAgICAgICBhY3RpdmVDbGFzc05hbWUgPSBfdGhpcyRnZXRDbGFzc05hbWVzNS5hY3RpdmVDbGFzc05hbWU7XG5cbiAgICAgIF90aGlzLnJlZmxvd0FuZEFkZENsYXNzKG5vZGUsIGFjdGl2ZUNsYXNzTmFtZSk7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkV4aXRpbmcpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25FeGl0aW5nKG5vZGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkV4aXRlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0Q2xhc3NOYW1lczYgPSBfdGhpcy5nZXRDbGFzc05hbWVzKCdleGl0JyksXG4gICAgICAgICAgZG9uZUNsYXNzTmFtZSA9IF90aGlzJGdldENsYXNzTmFtZXM2LmRvbmVDbGFzc05hbWU7XG5cbiAgICAgIF90aGlzLnJlbW92ZUNsYXNzZXMobm9kZSwgJ2V4aXQnKTtcblxuICAgICAgYWRkQ2xhc3Mobm9kZSwgZG9uZUNsYXNzTmFtZSk7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkV4aXRlZCkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkV4aXRlZChub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0Q2xhc3NOYW1lcyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgY2xhc3NOYW1lcyA9IF90aGlzLnByb3BzLmNsYXNzTmFtZXM7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gdHlwZW9mIGNsYXNzTmFtZXMgIT09ICdzdHJpbmcnID8gY2xhc3NOYW1lc1t0eXBlXSA6IGNsYXNzTmFtZXMgKyAnLScgKyB0eXBlO1xuICAgICAgdmFyIGFjdGl2ZUNsYXNzTmFtZSA9IHR5cGVvZiBjbGFzc05hbWVzICE9PSAnc3RyaW5nJyA/IGNsYXNzTmFtZXNbdHlwZSArICdBY3RpdmUnXSA6IGNsYXNzTmFtZSArICctYWN0aXZlJztcbiAgICAgIHZhciBkb25lQ2xhc3NOYW1lID0gdHlwZW9mIGNsYXNzTmFtZXMgIT09ICdzdHJpbmcnID8gY2xhc3NOYW1lc1t0eXBlICsgJ0RvbmUnXSA6IGNsYXNzTmFtZSArICctZG9uZSc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgYWN0aXZlQ2xhc3NOYW1lOiBhY3RpdmVDbGFzc05hbWUsXG4gICAgICAgIGRvbmVDbGFzc05hbWU6IGRvbmVDbGFzc05hbWVcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDU1NUcmFuc2l0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVtb3ZlQ2xhc3NlcyA9IGZ1bmN0aW9uIHJlbW92ZUNsYXNzZXMobm9kZSwgdHlwZSkge1xuICAgIHZhciBfdGhpcyRnZXRDbGFzc05hbWVzNyA9IHRoaXMuZ2V0Q2xhc3NOYW1lcyh0eXBlKSxcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkZ2V0Q2xhc3NOYW1lczcuY2xhc3NOYW1lLFxuICAgICAgICBhY3RpdmVDbGFzc05hbWUgPSBfdGhpcyRnZXRDbGFzc05hbWVzNy5hY3RpdmVDbGFzc05hbWUsXG4gICAgICAgIGRvbmVDbGFzc05hbWUgPSBfdGhpcyRnZXRDbGFzc05hbWVzNy5kb25lQ2xhc3NOYW1lO1xuXG4gICAgY2xhc3NOYW1lICYmIHJlbW92ZUNsYXNzKG5vZGUsIGNsYXNzTmFtZSk7XG4gICAgYWN0aXZlQ2xhc3NOYW1lICYmIHJlbW92ZUNsYXNzKG5vZGUsIGFjdGl2ZUNsYXNzTmFtZSk7XG4gICAgZG9uZUNsYXNzTmFtZSAmJiByZW1vdmVDbGFzcyhub2RlLCBkb25lQ2xhc3NOYW1lKTtcbiAgfTtcblxuICBfcHJvdG8ucmVmbG93QW5kQWRkQ2xhc3MgPSBmdW5jdGlvbiByZWZsb3dBbmRBZGRDbGFzcyhub2RlLCBjbGFzc05hbWUpIHtcbiAgICAvLyBUaGlzIGlzIGZvciB0byBmb3JjZSBhIHJlcGFpbnQsXG4gICAgLy8gd2hpY2ggaXMgbmVjZXNzYXJ5IGluIG9yZGVyIHRvIHRyYW5zaXRpb24gc3R5bGVzIHdoZW4gYWRkaW5nIGEgY2xhc3MgbmFtZS5cbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICAgIG5vZGUgJiYgbm9kZS5zY3JvbGxUb3A7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuXG4gICAgICBhZGRDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IF9leHRlbmRzKHt9LCB0aGlzLnByb3BzKTtcblxuICAgIGRlbGV0ZSBwcm9wcy5jbGFzc05hbWVzO1xuICAgIHJldHVybiBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9UcmFuc2l0aW9uLmRlZmF1bHQsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgb25FbnRlcjogdGhpcy5vbkVudGVyLFxuICAgICAgb25FbnRlcmVkOiB0aGlzLm9uRW50ZXJlZCxcbiAgICAgIG9uRW50ZXJpbmc6IHRoaXMub25FbnRlcmluZyxcbiAgICAgIG9uRXhpdDogdGhpcy5vbkV4aXQsXG4gICAgICBvbkV4aXRpbmc6IHRoaXMub25FeGl0aW5nLFxuICAgICAgb25FeGl0ZWQ6IHRoaXMub25FeGl0ZWRcbiAgICB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIENTU1RyYW5zaXRpb247XG59KF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCk7XG5cbkNTU1RyYW5zaXRpb24ucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gcHJvcFR5cGVzIDoge307XG52YXIgX2RlZmF1bHQgPSBDU1NUcmFuc2l0aW9uO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fcmVhY3QtdHJhbnNpdGlvbi1ncm91cEAyLjUuMkByZWFjdC10cmFuc2l0aW9uLWdyb3VwL0NTU1RyYW5zaXRpb24uanMiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBhZGRDbGFzcztcblxudmFyIF9oYXNDbGFzcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaGFzQ2xhc3NcIikpO1xuXG5mdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtlbHNlIGlmICghKDAsIF9oYXNDbGFzcy5kZWZhdWx0KShlbGVtZW50LCBjbGFzc05hbWUpKSBpZiAodHlwZW9mIGVsZW1lbnQuY2xhc3NOYW1lID09PSAnc3RyaW5nJykgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZSArICcgJyArIGNsYXNzTmFtZTtlbHNlIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIChlbGVtZW50LmNsYXNzTmFtZSAmJiBlbGVtZW50LmNsYXNzTmFtZS5iYXNlVmFsIHx8ICcnKSArICcgJyArIGNsYXNzTmFtZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19kb20taGVscGVyc0AzLjQuMEBkb20taGVscGVycy9jbGFzcy9hZGRDbGFzcy5qcyIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgZGVmYXVsdDogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX0BiYWJlbF9ydW50aW1lQDcuMi4wQEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBoYXNDbGFzcztcblxuZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkgcmV0dXJuICEhY2xhc3NOYW1lICYmIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7ZWxzZSByZXR1cm4gKFwiIFwiICsgKGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWwgfHwgZWxlbWVudC5jbGFzc05hbWUpICsgXCIgXCIpLmluZGV4T2YoXCIgXCIgKyBjbGFzc05hbWUgKyBcIiBcIikgIT09IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fZG9tLWhlbHBlcnNAMy40LjBAZG9tLWhlbHBlcnMvY2xhc3MvaGFzQ2xhc3MuanMiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHJlcGxhY2VDbGFzc05hbWUob3JpZ0NsYXNzLCBjbGFzc1RvUmVtb3ZlKSB7XG4gIHJldHVybiBvcmlnQ2xhc3MucmVwbGFjZShuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgY2xhc3NUb1JlbW92ZSArICcoPzpcXFxcc3wkKScsICdnJyksICckMScpLnJlcGxhY2UoL1xccysvZywgJyAnKS5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7ZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQuY2xhc3NOYW1lID09PSAnc3RyaW5nJykgZWxlbWVudC5jbGFzc05hbWUgPSByZXBsYWNlQ2xhc3NOYW1lKGVsZW1lbnQuY2xhc3NOYW1lLCBjbGFzc05hbWUpO2Vsc2UgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgcmVwbGFjZUNsYXNzTmFtZShlbGVtZW50LmNsYXNzTmFtZSAmJiBlbGVtZW50LmNsYXNzTmFtZS5iYXNlVmFsIHx8ICcnLCBjbGFzc05hbWUpKTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL19kb20taGVscGVyc0AzLjQuMEBkb20taGVscGVycy9jbGFzcy9yZW1vdmVDbGFzcy5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZShcInJlYWN0LWRvbVwiKTtcblxudmFyIF9UcmFuc2l0aW9uR3JvdXAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1RyYW5zaXRpb25Hcm91cFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBwcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIGluOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbC5pc1JlcXVpcmVkLFxuICBjaGlsZHJlbjogZnVuY3Rpb24gY2hpbGRyZW4ocHJvcHMsIHByb3BOYW1lKSB7XG4gICAgaWYgKF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLmNvdW50KHByb3BzW3Byb3BOYW1lXSkgIT09IDIpIHJldHVybiBuZXcgRXJyb3IoXCJcXFwiXCIgKyBwcm9wTmFtZSArIFwiXFxcIiBtdXN0IGJlIGV4YWN0bHkgdHdvIHRyYW5zaXRpb24gY29tcG9uZW50cy5cIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn0gOiB7fTs7XG4vKipcbiAqIFRoZSBgPFJlcGxhY2VUcmFuc2l0aW9uPmAgY29tcG9uZW50IGlzIGEgc3BlY2lhbGl6ZWQgYFRyYW5zaXRpb25gIGNvbXBvbmVudFxuICogdGhhdCBhbmltYXRlcyBiZXR3ZWVuIHR3byBjaGlsZHJlbi5cbiAqXG4gKiBgYGBqc3hcbiAqIDxSZXBsYWNlVHJhbnNpdGlvbiBpbj5cbiAqICAgPEZhZGU+PGRpdj5JIGFwcGVhciBmaXJzdDwvZGl2PjwvRmFkZT5cbiAqICAgPEZhZGU+PGRpdj5JIHJlcGxhY2UgdGhlIGFib3ZlPC9kaXY+PC9GYWRlPlxuICogPC9SZXBsYWNlVHJhbnNpdGlvbj5cbiAqIGBgYFxuICovXG5cbnZhciBSZXBsYWNlVHJhbnNpdGlvbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShSZXBsYWNlVHJhbnNpdGlvbiwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUmVwbGFjZVRyYW5zaXRpb24oKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgX2FyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChfYXJncykpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5oYW5kbGVFbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVMaWZlY3ljbGUoJ29uRW50ZXInLCAwLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlRW50ZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMuaGFuZGxlTGlmZWN5Y2xlKCdvbkVudGVyaW5nJywgMCwgYXJncyk7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZUVudGVyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMuaGFuZGxlTGlmZWN5Y2xlKCdvbkVudGVyZWQnLCAwLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlRXhpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSksIF9rZXk1ID0gMDsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgICAgICBhcmdzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVMaWZlY3ljbGUoJ29uRXhpdCcsIDEsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVFeGl0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42KSwgX2tleTYgPSAwOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTZdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZUxpZmVjeWNsZSgnb25FeGl0aW5nJywgMSwgYXJncyk7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZUV4aXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNyksIF9rZXk3ID0gMDsgX2tleTcgPCBfbGVuNzsgX2tleTcrKykge1xuICAgICAgICBhcmdzW19rZXk3XSA9IGFyZ3VtZW50c1tfa2V5N107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVMaWZlY3ljbGUoJ29uRXhpdGVkJywgMSwgYXJncyk7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBSZXBsYWNlVHJhbnNpdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmhhbmRsZUxpZmVjeWNsZSA9IGZ1bmN0aW9uIGhhbmRsZUxpZmVjeWNsZShoYW5kbGVyLCBpZHgsIG9yaWdpbmFsQXJncykge1xuICAgIHZhciBfY2hpbGQkcHJvcHM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuXG4gICAgdmFyIGNoaWxkID0gX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbilbaWR4XTtcblxuICAgIGlmIChjaGlsZC5wcm9wc1toYW5kbGVyXSkgKF9jaGlsZCRwcm9wcyA9IGNoaWxkLnByb3BzKVtoYW5kbGVyXS5hcHBseShfY2hpbGQkcHJvcHMsIG9yaWdpbmFsQXJncyk7XG4gICAgaWYgKHRoaXMucHJvcHNbaGFuZGxlcl0pIHRoaXMucHJvcHNbaGFuZGxlcl0oKDAsIF9yZWFjdERvbS5maW5kRE9NTm9kZSkodGhpcykpO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgaW5Qcm9wID0gX3RoaXMkcHJvcHMuaW4sXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIFtcImNoaWxkcmVuXCIsIFwiaW5cIl0pO1xuXG4gICAgdmFyIF9SZWFjdCRDaGlsZHJlbiR0b0FyciA9IF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pLFxuICAgICAgICBmaXJzdCA9IF9SZWFjdCRDaGlsZHJlbiR0b0FyclswXSxcbiAgICAgICAgc2Vjb25kID0gX1JlYWN0JENoaWxkcmVuJHRvQXJyWzFdO1xuXG4gICAgZGVsZXRlIHByb3BzLm9uRW50ZXI7XG4gICAgZGVsZXRlIHByb3BzLm9uRW50ZXJpbmc7XG4gICAgZGVsZXRlIHByb3BzLm9uRW50ZXJlZDtcbiAgICBkZWxldGUgcHJvcHMub25FeGl0O1xuICAgIGRlbGV0ZSBwcm9wcy5vbkV4aXRpbmc7XG4gICAgZGVsZXRlIHByb3BzLm9uRXhpdGVkO1xuICAgIHJldHVybiBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9UcmFuc2l0aW9uR3JvdXAuZGVmYXVsdCwgcHJvcHMsIGluUHJvcCA/IF9yZWFjdC5kZWZhdWx0LmNsb25lRWxlbWVudChmaXJzdCwge1xuICAgICAga2V5OiAnZmlyc3QnLFxuICAgICAgb25FbnRlcjogdGhpcy5oYW5kbGVFbnRlcixcbiAgICAgIG9uRW50ZXJpbmc6IHRoaXMuaGFuZGxlRW50ZXJpbmcsXG4gICAgICBvbkVudGVyZWQ6IHRoaXMuaGFuZGxlRW50ZXJlZFxuICAgIH0pIDogX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KHNlY29uZCwge1xuICAgICAga2V5OiAnc2Vjb25kJyxcbiAgICAgIG9uRW50ZXI6IHRoaXMuaGFuZGxlRXhpdCxcbiAgICAgIG9uRW50ZXJpbmc6IHRoaXMuaGFuZGxlRXhpdGluZyxcbiAgICAgIG9uRW50ZXJlZDogdGhpcy5oYW5kbGVFeGl0ZWRcbiAgICB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIFJlcGxhY2VUcmFuc2l0aW9uO1xufShfcmVhY3QuZGVmYXVsdC5Db21wb25lbnQpO1xuXG5SZXBsYWNlVHJhbnNpdGlvbi5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBwcm9wVHlwZXMgOiB7fTtcbnZhciBfZGVmYXVsdCA9IFJlcGxhY2VUcmFuc2l0aW9uO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fcmVhY3QtdHJhbnNpdGlvbi1ncm91cEAyLjUuMkByZWFjdC10cmFuc2l0aW9uLWdyb3VwL1JlcGxhY2VUcmFuc2l0aW9uLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmdldENoaWxkTWFwcGluZyA9IGdldENoaWxkTWFwcGluZztcbmV4cG9ydHMubWVyZ2VDaGlsZE1hcHBpbmdzID0gbWVyZ2VDaGlsZE1hcHBpbmdzO1xuZXhwb3J0cy5nZXRJbml0aWFsQ2hpbGRNYXBwaW5nID0gZ2V0SW5pdGlhbENoaWxkTWFwcGluZztcbmV4cG9ydHMuZ2V0TmV4dENoaWxkTWFwcGluZyA9IGdldE5leHRDaGlsZE1hcHBpbmc7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG5cbi8qKlxuICogR2l2ZW4gYHRoaXMucHJvcHMuY2hpbGRyZW5gLCByZXR1cm4gYW4gb2JqZWN0IG1hcHBpbmcga2V5IHRvIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Kn0gY2hpbGRyZW4gYHRoaXMucHJvcHMuY2hpbGRyZW5gXG4gKiBAcmV0dXJuIHtvYmplY3R9IE1hcHBpbmcgb2Yga2V5IHRvIGNoaWxkXG4gKi9cbmZ1bmN0aW9uIGdldENoaWxkTWFwcGluZyhjaGlsZHJlbiwgbWFwRm4pIHtcbiAgdmFyIG1hcHBlciA9IGZ1bmN0aW9uIG1hcHBlcihjaGlsZCkge1xuICAgIHJldHVybiBtYXBGbiAmJiAoMCwgX3JlYWN0LmlzVmFsaWRFbGVtZW50KShjaGlsZCkgPyBtYXBGbihjaGlsZCkgOiBjaGlsZDtcbiAgfTtcblxuICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGNoaWxkcmVuKSBfcmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiBjO1xuICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIC8vIHJ1biB0aGUgbWFwIGZ1bmN0aW9uIGhlcmUgaW5zdGVhZCBzbyB0aGF0IHRoZSBrZXkgaXMgdGhlIGNvbXB1dGVkIG9uZVxuICAgIHJlc3VsdFtjaGlsZC5rZXldID0gbWFwcGVyKGNoaWxkKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFdoZW4geW91J3JlIGFkZGluZyBvciByZW1vdmluZyBjaGlsZHJlbiBzb21lIG1heSBiZSBhZGRlZCBvciByZW1vdmVkIGluIHRoZVxuICogc2FtZSByZW5kZXIgcGFzcy4gV2Ugd2FudCB0byBzaG93ICpib3RoKiBzaW5jZSB3ZSB3YW50IHRvIHNpbXVsdGFuZW91c2x5XG4gKiBhbmltYXRlIGVsZW1lbnRzIGluIGFuZCBvdXQuIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBwcmV2aW91cyBzZXQgb2Yga2V5c1xuICogYW5kIGEgbmV3IHNldCBvZiBrZXlzIGFuZCBtZXJnZXMgdGhlbSB3aXRoIGl0cyBiZXN0IGd1ZXNzIG9mIHRoZSBjb3JyZWN0XG4gKiBvcmRlcmluZy4gSW4gdGhlIGZ1dHVyZSB3ZSBtYXkgZXhwb3NlIHNvbWUgb2YgdGhlIHV0aWxpdGllcyBpblxuICogUmVhY3RNdWx0aUNoaWxkIHRvIG1ha2UgdGhpcyBlYXN5LCBidXQgZm9yIG5vdyBSZWFjdCBpdHNlbGYgZG9lcyBub3RcbiAqIGRpcmVjdGx5IGhhdmUgdGhpcyBjb25jZXB0IG9mIHRoZSB1bmlvbiBvZiBwcmV2Q2hpbGRyZW4gYW5kIG5leHRDaGlsZHJlblxuICogc28gd2UgaW1wbGVtZW50IGl0IGhlcmUuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHByZXYgcHJldiBjaGlsZHJlbiBhcyByZXR1cm5lZCBmcm9tXG4gKiBgUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmdldENoaWxkTWFwcGluZygpYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0IG5leHQgY2hpbGRyZW4gYXMgcmV0dXJuZWQgZnJvbVxuICogYFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcoKWAuXG4gKiBAcmV0dXJuIHtvYmplY3R9IGEga2V5IHNldCB0aGF0IGNvbnRhaW5zIGFsbCBrZXlzIGluIGBwcmV2YCBhbmQgYWxsIGtleXNcbiAqIGluIGBuZXh0YCBpbiBhIHJlYXNvbmFibGUgb3JkZXIuXG4gKi9cblxuXG5mdW5jdGlvbiBtZXJnZUNoaWxkTWFwcGluZ3MocHJldiwgbmV4dCkge1xuICBwcmV2ID0gcHJldiB8fCB7fTtcbiAgbmV4dCA9IG5leHQgfHwge307XG5cbiAgZnVuY3Rpb24gZ2V0VmFsdWVGb3JLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleSBpbiBuZXh0ID8gbmV4dFtrZXldIDogcHJldltrZXldO1xuICB9IC8vIEZvciBlYWNoIGtleSBvZiBgbmV4dGAsIHRoZSBsaXN0IG9mIGtleXMgdG8gaW5zZXJ0IGJlZm9yZSB0aGF0IGtleSBpblxuICAvLyB0aGUgY29tYmluZWQgbGlzdFxuXG5cbiAgdmFyIG5leHRLZXlzUGVuZGluZyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBwZW5kaW5nS2V5cyA9IFtdO1xuXG4gIGZvciAodmFyIHByZXZLZXkgaW4gcHJldikge1xuICAgIGlmIChwcmV2S2V5IGluIG5leHQpIHtcbiAgICAgIGlmIChwZW5kaW5nS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgbmV4dEtleXNQZW5kaW5nW3ByZXZLZXldID0gcGVuZGluZ0tleXM7XG4gICAgICAgIHBlbmRpbmdLZXlzID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdLZXlzLnB1c2gocHJldktleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGk7XG4gIHZhciBjaGlsZE1hcHBpbmcgPSB7fTtcblxuICBmb3IgKHZhciBuZXh0S2V5IGluIG5leHQpIHtcbiAgICBpZiAobmV4dEtleXNQZW5kaW5nW25leHRLZXldKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbmV4dEtleXNQZW5kaW5nW25leHRLZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwZW5kaW5nTmV4dEtleSA9IG5leHRLZXlzUGVuZGluZ1tuZXh0S2V5XVtpXTtcbiAgICAgICAgY2hpbGRNYXBwaW5nW25leHRLZXlzUGVuZGluZ1tuZXh0S2V5XVtpXV0gPSBnZXRWYWx1ZUZvcktleShwZW5kaW5nTmV4dEtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGRNYXBwaW5nW25leHRLZXldID0gZ2V0VmFsdWVGb3JLZXkobmV4dEtleSk7XG4gIH0gLy8gRmluYWxseSwgYWRkIHRoZSBrZXlzIHdoaWNoIGRpZG4ndCBhcHBlYXIgYmVmb3JlIGFueSBrZXkgaW4gYG5leHRgXG5cblxuICBmb3IgKGkgPSAwOyBpIDwgcGVuZGluZ0tleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjaGlsZE1hcHBpbmdbcGVuZGluZ0tleXNbaV1dID0gZ2V0VmFsdWVGb3JLZXkocGVuZGluZ0tleXNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkTWFwcGluZztcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcChjaGlsZCwgcHJvcCwgcHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzW3Byb3BdICE9IG51bGwgPyBwcm9wc1twcm9wXSA6IGNoaWxkLnByb3BzW3Byb3BdO1xufVxuXG5mdW5jdGlvbiBnZXRJbml0aWFsQ2hpbGRNYXBwaW5nKHByb3BzLCBvbkV4aXRlZCkge1xuICByZXR1cm4gZ2V0Q2hpbGRNYXBwaW5nKHByb3BzLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKGNoaWxkLCB7XG4gICAgICBvbkV4aXRlZDogb25FeGl0ZWQuYmluZChudWxsLCBjaGlsZCksXG4gICAgICBpbjogdHJ1ZSxcbiAgICAgIGFwcGVhcjogZ2V0UHJvcChjaGlsZCwgJ2FwcGVhcicsIHByb3BzKSxcbiAgICAgIGVudGVyOiBnZXRQcm9wKGNoaWxkLCAnZW50ZXInLCBwcm9wcyksXG4gICAgICBleGl0OiBnZXRQcm9wKGNoaWxkLCAnZXhpdCcsIHByb3BzKVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TmV4dENoaWxkTWFwcGluZyhuZXh0UHJvcHMsIHByZXZDaGlsZE1hcHBpbmcsIG9uRXhpdGVkKSB7XG4gIHZhciBuZXh0Q2hpbGRNYXBwaW5nID0gZ2V0Q2hpbGRNYXBwaW5nKG5leHRQcm9wcy5jaGlsZHJlbik7XG4gIHZhciBjaGlsZHJlbiA9IG1lcmdlQ2hpbGRNYXBwaW5ncyhwcmV2Q2hpbGRNYXBwaW5nLCBuZXh0Q2hpbGRNYXBwaW5nKTtcbiAgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2tleV07XG4gICAgaWYgKCEoMCwgX3JlYWN0LmlzVmFsaWRFbGVtZW50KShjaGlsZCkpIHJldHVybjtcbiAgICB2YXIgaGFzUHJldiA9IGtleSBpbiBwcmV2Q2hpbGRNYXBwaW5nO1xuICAgIHZhciBoYXNOZXh0ID0ga2V5IGluIG5leHRDaGlsZE1hcHBpbmc7XG4gICAgdmFyIHByZXZDaGlsZCA9IHByZXZDaGlsZE1hcHBpbmdba2V5XTtcbiAgICB2YXIgaXNMZWF2aW5nID0gKDAsIF9yZWFjdC5pc1ZhbGlkRWxlbWVudCkocHJldkNoaWxkKSAmJiAhcHJldkNoaWxkLnByb3BzLmluOyAvLyBpdGVtIGlzIG5ldyAoZW50ZXJpbmcpXG5cbiAgICBpZiAoaGFzTmV4dCAmJiAoIWhhc1ByZXYgfHwgaXNMZWF2aW5nKSkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ2VudGVyaW5nJywga2V5KVxuICAgICAgY2hpbGRyZW5ba2V5XSA9ICgwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShjaGlsZCwge1xuICAgICAgICBvbkV4aXRlZDogb25FeGl0ZWQuYmluZChudWxsLCBjaGlsZCksXG4gICAgICAgIGluOiB0cnVlLFxuICAgICAgICBleGl0OiBnZXRQcm9wKGNoaWxkLCAnZXhpdCcsIG5leHRQcm9wcyksXG4gICAgICAgIGVudGVyOiBnZXRQcm9wKGNoaWxkLCAnZW50ZXInLCBuZXh0UHJvcHMpXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFoYXNOZXh0ICYmIGhhc1ByZXYgJiYgIWlzTGVhdmluZykge1xuICAgICAgLy8gaXRlbSBpcyBvbGQgKGV4aXRpbmcpXG4gICAgICAvLyBjb25zb2xlLmxvZygnbGVhdmluZycsIGtleSlcbiAgICAgIGNoaWxkcmVuW2tleV0gPSAoMCwgX3JlYWN0LmNsb25lRWxlbWVudCkoY2hpbGQsIHtcbiAgICAgICAgaW46IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGhhc05leHQgJiYgaGFzUHJldiAmJiAoMCwgX3JlYWN0LmlzVmFsaWRFbGVtZW50KShwcmV2Q2hpbGQpKSB7XG4gICAgICAvLyBpdGVtIGhhc24ndCBjaGFuZ2VkIHRyYW5zaXRpb24gc3RhdGVzXG4gICAgICAvLyBjb3B5IG92ZXIgdGhlIGxhc3QgdHJhbnNpdGlvbiBwcm9wcztcbiAgICAgIC8vIGNvbnNvbGUubG9nKCd1bmNoYW5nZWQnLCBrZXkpXG4gICAgICBjaGlsZHJlbltrZXldID0gKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKGNoaWxkLCB7XG4gICAgICAgIG9uRXhpdGVkOiBvbkV4aXRlZC5iaW5kKG51bGwsIGNoaWxkKSxcbiAgICAgICAgaW46IHByZXZDaGlsZC5wcm9wcy5pbixcbiAgICAgICAgZXhpdDogZ2V0UHJvcChjaGlsZCwgJ2V4aXQnLCBuZXh0UHJvcHMpLFxuICAgICAgICBlbnRlcjogZ2V0UHJvcChjaGlsZCwgJ2VudGVyJywgbmV4dFByb3BzKVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fcmVhY3QtdHJhbnNpdGlvbi1ncm91cEAyLjUuMkByZWFjdC10cmFuc2l0aW9uLWdyb3VwL3V0aWxzL0NoaWxkTWFwcGluZy5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gJ3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAnO1xuaW1wb3J0IHsgZnVuYywgc3VwcG9ydCwgZXZlbnRzLCBkb20sIGd1aWQgfSBmcm9tICcuLi91dGlsJztcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuY29uc3QgeyBvbiwgb2ZmIH0gPSBldmVudHM7XG5jb25zdCB7IGFkZENsYXNzLCByZW1vdmVDbGFzcyB9ID0gZG9tO1xuY29uc3QgcHJlZml4ZXMgPSBbJy13ZWJraXQtJywgJy1tb3otJywgJy1vLScsICdtcy0nLCAnJ107XG5cbmZ1bmN0aW9uIGdldFN0eWxlUHJvcGVydHkobm9kZSwgbmFtZSkge1xuICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgbGV0IHJldCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmV0ID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcmVmaXhlc1tpXSArIG5hbWUpO1xuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRlQ2hpbGQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIG5hbWVzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSksXG4gICAgICAgIG9uQXBwZWFyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25BcHBlYXJpbmc6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkFwcGVhcmVkOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgb25FbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uRW50ZXJpbmc6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkVudGVyZWQ6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkV4aXQ6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkV4aXRpbmc6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkV4aXRlZDogUHJvcFR5cGVzLmZ1bmNcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgb25BcHBlYXI6IG5vb3AsXG4gICAgICAgIG9uQXBwZWFyaW5nOiBub29wLFxuICAgICAgICBvbkFwcGVhcmVkOiBub29wLFxuICAgICAgICBvbkVudGVyOiBub29wLFxuICAgICAgICBvbkVudGVyaW5nOiBub29wLFxuICAgICAgICBvbkVudGVyZWQ6IG5vb3AsXG4gICAgICAgIG9uRXhpdDogbm9vcCxcbiAgICAgICAgb25FeGl0aW5nOiBub29wLFxuICAgICAgICBvbkV4aXRlZDogbm9vcFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIGZ1bmMuYmluZEN0eCh0aGlzLCBbXG4gICAgICAgICAgICAnaGFuZGxlRW50ZXInLCAnaGFuZGxlRW50ZXJpbmcnLCAnaGFuZGxlRW50ZXJlZCcsXG4gICAgICAgICAgICAnaGFuZGxlRXhpdCcsICdoYW5kbGVFeGl0aW5nJywgJ2hhbmRsZUV4aXRlZCcsXG4gICAgICAgICAgICAnYWRkRW5kTGlzdGVuZXInXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLmVuZExpc3RlbmVycyA9IHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25lbmQ6IFtdLFxuICAgICAgICAgICAgYW5pbWF0aW9uZW5kOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRpbWVvdXRNYXAgPSB7fTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5lbmRMaXN0ZW5lcnMpLmZvckVhY2goZXZlbnROYW1lID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW5kTGlzdGVuZXJzW2V2ZW50TmFtZV0uZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICAgICAgICAgICAgb2ZmKHRoaXMubm9kZSwgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW5kTGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgdHJhbnNpdGlvbmVuZDogW10sXG4gICAgICAgICAgICBhbmltYXRpb25lbmQ6IFtdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZ2VuZXJhdGVFbmRMaXN0ZW5lcihub2RlLCBkb25lLCBldmVudE5hbWUsIGlkKSB7XG4gICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGVuZExpc3RlbmVyKGUpIHtcblxuICAgICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudGltZW91dE1hcFtpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXRNYXBbaWRdKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnRpbWVvdXRNYXBbaWRdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICBvZmYobm9kZSwgZXZlbnROYW1lLCBlbmRMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gX3RoaXMuZW5kTGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihlbmRMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgaW5kZXggPiAtMSAmJiBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhZGRFbmRMaXN0ZW5lcihub2RlLCBkb25lKSB7XG4gICAgICAgIGlmIChzdXBwb3J0LnRyYW5zaXRpb24gfHwgc3VwcG9ydC5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gZ3VpZCgpO1xuXG4gICAgICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICAgICAgaWYgKHN1cHBvcnQudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb25FbmRMaXN0ZW5lciA9IHRoaXMuZ2VuZXJhdGVFbmRMaXN0ZW5lcihub2RlLCBkb25lLCAndHJhbnNpdGlvbmVuZCcsIGlkKTtcbiAgICAgICAgICAgICAgICBvbihub2RlLCAndHJhbnNpdGlvbmVuZCcsIHRyYW5zaXRpb25FbmRMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRMaXN0ZW5lcnMudHJhbnNpdGlvbmVuZC5wdXNoKHRyYW5zaXRpb25FbmRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3VwcG9ydC5hbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmltYXRpb25FbmRMaXN0ZW5lciA9IHRoaXMuZ2VuZXJhdGVFbmRMaXN0ZW5lcihub2RlLCBkb25lLCAnYW5pbWF0aW9uZW5kJywgaWQpO1xuICAgICAgICAgICAgICAgIG9uKG5vZGUsICdhbmltYXRpb25lbmQnLCBhbmltYXRpb25FbmRMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRMaXN0ZW5lcnMuYW5pbWF0aW9uZW5kLnB1c2goYW5pbWF0aW9uRW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uRGVsYXkgPSBwYXJzZUZsb2F0KGdldFN0eWxlUHJvcGVydHkobm9kZSwgJ3RyYW5zaXRpb24tZGVsYXknKSkgfHwgMDtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBwYXJzZUZsb2F0KGdldFN0eWxlUHJvcGVydHkobm9kZSwgJ3RyYW5zaXRpb24tZHVyYXRpb24nKSkgfHwgMDtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmltYXRpb25EZWxheSA9IHBhcnNlRmxvYXQoZ2V0U3R5bGVQcm9wZXJ0eShub2RlLCAnYW5pbWF0aW9uLWRlbGF5JykpIHx8IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb24gPSBwYXJzZUZsb2F0KGdldFN0eWxlUHJvcGVydHkobm9kZSwgJ2FuaW1hdGlvbi1kdXJhdGlvbicpKSB8fCAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBNYXRoLm1heCh0cmFuc2l0aW9uRHVyYXRpb24gKyB0cmFuc2l0aW9uRGVsYXksIGFuaW1hdGlvbkR1cmF0aW9uICsgYW5pbWF0aW9uRGVsYXkpO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZW91dE1hcFtpZF0gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGltZSAqIDEwMDAgKyAyMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDE1KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlRW5kdExpc3RlbmVyKCkge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25PZmYgJiYgdGhpcy50cmFuc2l0aW9uT2ZmKCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uT2ZmICYmIHRoaXMuYW5pbWF0aW9uT2ZmKCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlQ2xhc3NOYW1lcyhub2RlLCBuYW1lcykge1xuICAgICAgICBPYmplY3Qua2V5cyhuYW1lcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3Mobm9kZSwgbmFtZXNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGhhbmRsZUVudGVyKG5vZGUsIGlzQXBwZWFyaW5nKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZXMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChuYW1lcykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDbGFzc05hbWVzKG5vZGUsIG5hbWVzKTtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGlzQXBwZWFyaW5nID8gJ2FwcGVhcicgOiAnZW50ZXInO1xuICAgICAgICAgICAgYWRkQ2xhc3Mobm9kZSwgbmFtZXNbY2xhc3NOYW1lXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBob29rID0gaXNBcHBlYXJpbmcgPyB0aGlzLnByb3BzLm9uQXBwZWFyIDogdGhpcy5wcm9wcy5vbkVudGVyO1xuICAgICAgICBob29rKG5vZGUpO1xuICAgIH1cblxuICAgIGhhbmRsZUVudGVyaW5nKG5vZGUsIGlzQXBwZWFyaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lcyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChuYW1lcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGlzQXBwZWFyaW5nID8gJ2FwcGVhckFjdGl2ZScgOiAnZW50ZXJBY3RpdmUnO1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKG5vZGUsIG5hbWVzW2NsYXNzTmFtZV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBob29rID0gaXNBcHBlYXJpbmcgPyB0aGlzLnByb3BzLm9uQXBwZWFyaW5nIDogdGhpcy5wcm9wcy5vbkVudGVyaW5nO1xuICAgICAgICAgICAgaG9vayhub2RlKTtcbiAgICAgICAgfSwgMTApO1xuICAgIH1cblxuICAgIGhhbmRsZUVudGVyZWQobm9kZSwgaXNBcHBlYXJpbmcpIHtcbiAgICAgICAgY29uc3QgeyBuYW1lcyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKG5hbWVzKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc05hbWVzID0gaXNBcHBlYXJpbmcgP1xuICAgICAgICAgICAgICAgIFtuYW1lcy5hcHBlYXIsIG5hbWVzLmFwcGVhckFjdGl2ZV0gOlxuICAgICAgICAgICAgICAgIFtuYW1lcy5lbnRlciwgbmFtZXMuZW50ZXJBY3RpdmVdO1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5mb3JFYWNoKGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaG9vayA9IGlzQXBwZWFyaW5nID8gdGhpcy5wcm9wcy5vbkFwcGVhcmVkIDogdGhpcy5wcm9wcy5vbkVudGVyZWQ7XG4gICAgICAgIGhvb2sobm9kZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlRXhpdChub2RlKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZXMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChuYW1lcykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDbGFzc05hbWVzKG5vZGUsIG5hbWVzKTtcbiAgICAgICAgICAgIGFkZENsYXNzKG5vZGUsIG5hbWVzLmxlYXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJvcHMub25FeGl0KG5vZGUpO1xuICAgIH1cblxuICAgIGhhbmRsZUV4aXRpbmcobm9kZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZXMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAobmFtZXMpIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhub2RlLCBuYW1lcy5sZWF2ZUFjdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uRXhpdGluZyhub2RlKTtcbiAgICAgICAgfSwgMTApO1xuICAgIH1cblxuICAgIGhhbmRsZUV4aXRlZChub2RlKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZXMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChuYW1lcykge1xuICAgICAgICAgICAgW25hbWVzLmxlYXZlLCBuYW1lcy5sZWF2ZUFjdGl2ZV0uZm9yRWFjaChjbGFzc05hbWUgPT4ge1xuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKG5vZGUsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJvcHMub25FeGl0ZWQobm9kZSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgICAgICBjb25zdCB7IG5hbWVzLFxuICAgICAgICAgICAgb25BcHBlYXIsIG9uQXBwZWFyZWQsIG9uQXBwZWFyaW5nLFxuICAgICAgICAgICAgb25FbnRlciwgb25FbnRlcmluZywgb25FbnRlcmVkLFxuICAgICAgICAgICAgb25FeGl0LCBvbkV4aXRpbmcsIG9uRXhpdGVkLFxuICAgICAgICAgICAgLi4ub3RoZXJzXG4gICAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxUcmFuc2l0aW9uIHsuLi5vdGhlcnN9XG4gICAgICAgICAgICAgICAgb25FbnRlcj17dGhpcy5oYW5kbGVFbnRlcn1cbiAgICAgICAgICAgICAgICBvbkVudGVyaW5nPXt0aGlzLmhhbmRsZUVudGVyaW5nfVxuICAgICAgICAgICAgICAgIG9uRW50ZXJlZD17dGhpcy5oYW5kbGVFbnRlcmVkfVxuICAgICAgICAgICAgICAgIG9uRXhpdD17dGhpcy5oYW5kbGVFeGl0fVxuICAgICAgICAgICAgICAgIG9uRXhpdGluZz17dGhpcy5oYW5kbGVFeGl0aW5nfVxuICAgICAgICAgICAgICAgIG9uRXhpdGVkPXt0aGlzLmhhbmRsZUV4aXRlZH1cbiAgICAgICAgICAgICAgICBhZGRFbmRMaXN0ZW5lcj17dGhpcy5hZGRFbmRMaXN0ZW5lcn0gLz5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYW5pbWF0ZS9jaGlsZC5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGZ1bmMsIGRvbSB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IEFuaW1hdGUgZnJvbSAnLi9hbmltYXRlJztcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuY29uc3QgeyBnZXRTdHlsZSB9ID0gZG9tO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeHBhbmQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIGFuaW1hdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgICAgICBiZWZvcmVFbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBhZnRlckVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgYmVmb3JlTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgYWZ0ZXJMZWF2ZTogUHJvcFR5cGVzLmZ1bmNcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgYmVmb3JlRW50ZXI6IG5vb3AsXG4gICAgICAgIG9uRW50ZXI6IG5vb3AsXG4gICAgICAgIGFmdGVyRW50ZXI6IG5vb3AsXG4gICAgICAgIGJlZm9yZUxlYXZlOiBub29wLFxuICAgICAgICBvbkxlYXZlOiBub29wLFxuICAgICAgICBhZnRlckxlYXZlOiBub29wXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgZnVuYy5iaW5kQ3R4KHRoaXMsIFtcbiAgICAgICAgICAgICdiZWZvcmVFbnRlcicsICdvbkVudGVyJywgJ2FmdGVyRW50ZXInLFxuICAgICAgICAgICAgJ2JlZm9yZUxlYXZlJywgJ29uTGVhdmUnLCAnYWZ0ZXJMZWF2ZSdcbiAgICAgICAgXSk7XG4gICAgfVxuXG4gICAgYmVmb3JlRW50ZXIobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5sZWF2aW5nKSB7XG4gICAgICAgICAgICB0aGlzLmFmdGVyTGVhdmUobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhY2hlQ3VycmVudFN0eWxlKG5vZGUpO1xuICAgICAgICB0aGlzLmNhY2hlQ29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50U3R5bGVUb1plcm8obm9kZSk7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5iZWZvcmVFbnRlcihub2RlKTtcbiAgICB9XG5cbiAgICBvbkVudGVyKG5vZGUpIHtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50U3R5bGVUb0NvbXB1dGVkU3R5bGUobm9kZSk7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vbkVudGVyKG5vZGUpO1xuICAgIH1cblxuICAgIGFmdGVyRW50ZXIobm9kZSkge1xuICAgICAgICB0aGlzLnJlc3RvcmVDdXJyZW50U3R5bGUobm9kZSk7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5hZnRlckVudGVyKG5vZGUpO1xuICAgIH1cblxuICAgIGJlZm9yZUxlYXZlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5sZWF2aW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmNhY2hlQ3VycmVudFN0eWxlKG5vZGUpO1xuICAgICAgICB0aGlzLmNhY2hlQ29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50U3R5bGVUb0NvbXB1dGVkU3R5bGUobm9kZSk7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5iZWZvcmVMZWF2ZShub2RlKTtcbiAgICB9XG5cbiAgICBvbkxlYXZlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50U3R5bGVUb1plcm8obm9kZSk7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vbkxlYXZlKG5vZGUpO1xuICAgIH1cblxuICAgIGFmdGVyTGVhdmUobm9kZSkge1xuICAgICAgICB0aGlzLmxlYXZpbmcgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLnJlc3RvcmVDdXJyZW50U3R5bGUobm9kZSk7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5hZnRlckxlYXZlKG5vZGUpO1xuICAgIH1cblxuICAgIGNhY2hlQ3VycmVudFN0eWxlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5zdHlsZUJvcmRlclRvcFdpZHRoID0gbm9kZS5zdHlsZS5ib3JkZXJUb3BXaWR0aDtcbiAgICAgICAgdGhpcy5zdHlsZVBhZGRpbmdUb3AgPSBub2RlLnN0eWxlLnBhZGRpbmdUb3A7XG4gICAgICAgIHRoaXMuc3R5bGVIZWlnaHQgPSBub2RlLnN0eWxlLmhlaWdodDtcbiAgICAgICAgdGhpcy5zdHlsZVBhZGRpbmdCb3R0b20gPSBub2RlLnN0eWxlLnBhZGRpbmdCb3R0b207XG4gICAgICAgIHRoaXMuc3R5bGVCb3JkZXJCb3R0b21XaWR0aCA9IG5vZGUuc3R5bGUuYm9yZGVyQm90dG9tV2lkdGg7XG4gICAgfVxuXG4gICAgY2FjaGVDb21wdXRlZFN0eWxlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5ib3JkZXJUb3BXaWR0aCA9IGdldFN0eWxlKG5vZGUsICdib3JkZXJUb3BXaWR0aCcpO1xuICAgICAgICB0aGlzLnBhZGRpbmdUb3AgPSBnZXRTdHlsZShub2RlLCAncGFkZGluZ1RvcCcpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IG5vZGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSBnZXRTdHlsZShub2RlLCAncGFkZGluZ0JvdHRvbScpO1xuICAgICAgICB0aGlzLmJvcmRlckJvdHRvbVdpZHRoID0gZ2V0U3R5bGUobm9kZSwgJ2JvcmRlckJvdHRvbVdpZHRoJyk7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudFN0eWxlVG9aZXJvKG5vZGUpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5ib3JkZXJUb3BXaWR0aCA9ICcwcHgnO1xuICAgICAgICBub2RlLnN0eWxlLnBhZGRpbmdUb3AgPSAnMHB4JztcbiAgICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSAnMHB4JztcbiAgICAgICAgbm9kZS5zdHlsZS5wYWRkaW5nQm90dG9tID0gJzBweCc7XG4gICAgICAgIG5vZGUuc3R5bGUuYm9yZGVyQm90dG9tV2lkdGggPSAnMHB4JztcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50U3R5bGVUb0NvbXB1dGVkU3R5bGUobm9kZSkge1xuICAgICAgICBub2RlLnN0eWxlLmJvcmRlclRvcFdpZHRoID0gYCR7dGhpcy5ib3JkZXJUb3BXaWR0aH1weGA7XG4gICAgICAgIG5vZGUuc3R5bGUucGFkZGluZ1RvcCA9IGAke3RoaXMucGFkZGluZ1RvcH1weGA7XG4gICAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gYCR7dGhpcy5oZWlnaHR9cHhgO1xuICAgICAgICBub2RlLnN0eWxlLnBhZGRpbmdCb3R0b20gPSBgJHt0aGlzLnBhZGRpbmdCb3R0b219cHhgO1xuICAgICAgICBub2RlLnN0eWxlLmJvcmRlckJvdHRvbVdpZHRoID0gYCR7dGhpcy5ib3JkZXJCb3R0b21XaWR0aH1weGA7XG4gICAgfVxuXG4gICAgcmVzdG9yZUN1cnJlbnRTdHlsZShub2RlKSB7XG4gICAgICAgIG5vZGUuc3R5bGUuYm9yZGVyVG9wV2lkdGggPSB0aGlzLnN0eWxlQm9yZGVyVG9wV2lkdGg7XG4gICAgICAgIG5vZGUuc3R5bGUucGFkZGluZ1RvcCA9IHRoaXMuc3R5bGVQYWRkaW5nVG9wO1xuICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9IHRoaXMuc3R5bGVIZWlnaHQ7XG4gICAgICAgIG5vZGUuc3R5bGUucGFkZGluZ0JvdHRvbSA9IHRoaXMuc3R5bGVQYWRkaW5nQm90dG9tO1xuICAgICAgICBub2RlLnN0eWxlLmJvcmRlckJvdHRvbVdpZHRoID0gdGhpcy5zdHlsZUJvcmRlckJvdHRvbVdpZHRoO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb24sIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgbmV3QW5pbWF0aW9uID0gYW5pbWF0aW9uIHx8ICdleHBhbmQnO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8QW5pbWF0ZSB7Li4ub3RoZXJzfVxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbj17bmV3QW5pbWF0aW9ufVxuICAgICAgICAgICAgICAgIGJlZm9yZUVudGVyPXt0aGlzLmJlZm9yZUVudGVyfVxuICAgICAgICAgICAgICAgIG9uRW50ZXI9e3RoaXMub25FbnRlcn1cbiAgICAgICAgICAgICAgICBhZnRlckVudGVyPXt0aGlzLmFmdGVyRW50ZXJ9XG4gICAgICAgICAgICAgICAgYmVmb3JlTGVhdmU9e3RoaXMuYmVmb3JlTGVhdmV9XG4gICAgICAgICAgICAgICAgb25MZWF2ZT17dGhpcy5vbkxlYXZlfVxuICAgICAgICAgICAgICAgIGFmdGVyTGVhdmU9e3RoaXMuYWZ0ZXJMZWF2ZX0gLz5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYW5pbWF0ZS9leHBhbmQuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQ2hlY2thYmxlSXRlbSBmcm9tICcuL2NoZWNrYWJsZS1pdGVtJztcblxuLyoqXG4gKiBNZW51LkNoZWNrYm94SXRlbVxuICogQG9yZGVyIDNcbiAqIEBkZXNjcmlwdGlvbiDor6XlrZDnu4Tku7bpgInkuK3mg4XlhrXkuI3lj5cgZGVmYXVsdFNlbGVjdGVkS2V5cy9zZWxlY3RlZEtleXMg5o6n5Yi277yM6K+36Ieq6KGM5o6n5Yi26YCJ5Lit6YC76L6RXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoZWNrYm94SXRlbSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIG1lbnVDaGlsZFR5cGUgPSAnaXRlbSc7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm6YCJ5LitXG4gICAgICAgICAqL1xuICAgICAgICBjaGVja2VkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuWNiumAieS4rVxuICAgICAgICAgKi9cbiAgICAgICAgaW5kZXRlcm1pbmF0ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbnpoHnlKhcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmAieS4reaIluWPlua2iOmAieS4reinpuWPkeeahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNoZWNrZWQg5piv5ZCm6YCJ5LitXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDpgInkuK3kuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW4ruWKqeaWh+acrFxuICAgICAgICAgKi9cbiAgICAgICAgaGVscGVyOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOagh+etvuWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICBjaGVja2JveERpc2FibGVkOiBQcm9wVHlwZXMuYm9vbFxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBjaGVja2VkOiBmYWxzZSxcbiAgICAgICAgaW5kZXRlcm1pbmF0ZTogZmFsc2UsXG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgb25DaGFuZ2U6ICgpID0+IHt9LFxuICAgICAgICBjaGVja2JveERpc2FibGVkOiBmYWxzZVxuICAgIH07XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY2hlY2tib3hEaXNhYmxlZCwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gPENoZWNrYWJsZUl0ZW0gcm9sZT1cIm1lbnVpdGVtY2hlY2tib3hcIiBjaGVja1R5cGU9XCJjaGVja2JveFwiIGNoZWNrRGlzYWJsZWQ9e2NoZWNrYm94RGlzYWJsZWR9IHsuLi5vdGhlcnN9IC8+O1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tZW51L3ZpZXcvY2hlY2tib3gtaXRlbS5qc3giLCJpbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBDb25maWdQcm92aWRlciBmcm9tICcuLi9jb25maWctcHJvdmlkZXInO1xuaW1wb3J0IHsgb2JqIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgQ2hlY2tib3ggZnJvbSAnLi9jaGVja2JveCc7XG5cbmNvbnN0IHsgcGlja090aGVycyB9ID0gb2JqO1xuXG4vKiogQ2hlY2tib3guR3JvdXAgKi9cbmNsYXNzIENoZWNrYm94R3JvdXAgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBydGw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ57G75ZCNXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnlhoXmlZvmoLflvI9cbiAgICAgICAgICovXG4gICAgICAgIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAvKipcbiAgICAgICAgICog5pW05L2T56aB55SoXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlj6/pgInpobnliJfooagsIOaVsOaNrumhueWPr+S4uiBTdHJpbmcg5oiW6ICFIE9iamVjdCwg5aaCIGBbJ2FwcGxlJywgJ3BlYXInLCAnb3JhbmdlJ11gIOaIluiAhSBgW3t2YWx1ZTogJ2FwcGxlJywgbGFiZWw6ICfoi7nmnpwnLH0sIHt2YWx1ZTogJ3BlYXInLCBsYWJlbDogJ+aiqCd9LCB7dmFsdWU6ICdvcmFuZ2UnLCBsYWJlbDogJ+apmeWtkCd9XWBcbiAgICAgICAgICovXG4gICAgICAgIGRhdGFTb3VyY2U6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5hbnkpLFxuICAgICAgICAvKipcbiAgICAgICAgICog6KKr6YCJ5Lit55qE5YC85YiX6KGoXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmFycmF5LCBQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpu5jorqTooqvpgInkuK3nmoTlgLzliJfooahcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmFycmF5LCBQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpgJrov4flrZDlhYPntKDmlrnlvI/orr7nva7lhoXpg6ggY2hlY2tib3hcbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuZWxlbWVudCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpgInkuK3lgLzmlLnlj5jml7bnmoTkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWUg6YCJ5Lit6aG55YiX6KGoXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRG9tIOS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlrZDpobnnm67nmoTmjpLliJfmlrnlvI9cbiAgICAgICAgICogLSBob3o6IOawtOW5s+aOkuWIlyAoZGVmYXVsdClcbiAgICAgICAgICogLSB2ZXI6IOWeguebtOaOkuWIl1xuICAgICAgICAgKi9cbiAgICAgICAgaXRlbURpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAgICAgICAgICdob3onLFxuICAgICAgICAgICAgJ3ZlcicsXG4gICAgICAgIF0pLFxuICAgIH1cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGRhdGFTb3VyY2U6IFtdLFxuICAgICAgICBvbkNoYW5nZTogKCkgPT4ge1xuICAgICAgICB9LFxuICAgICAgICBwcmVmaXg6ICduZXh0LScsXG4gICAgICAgIGl0ZW1EaXJlY3Rpb246ICdob3onLFxuICAgIH1cblxuICAgIHN0YXRpYyBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBfX2dyb3VwX186IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBzZWxlY3RlZFZhbHVlOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbFxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICBsZXQgdmFsdWUgPSBbXTtcbiAgICAgICAgaWYgKCd2YWx1ZScgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2RlZmF1bHRWYWx1ZScgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB2YWx1ZTogWy4uLnZhbHVlXSxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gdGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9fZ3JvdXBfXzogdHJ1ZSxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLm9uQ2hhbmdlLFxuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZTogdGhpcy5zdGF0ZS52YWx1ZSxcbiAgICAgICAgICAgIGRpc2FibGVkOiB0aGlzLnByb3BzLmRpc2FibGVkXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKCd2YWx1ZScgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgICAgICBsZXQge3ZhbHVlfSA9IG5leHRQcm9wcztcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkNoYW5nZShjdXJyZW50VmFsdWUsIGUpIHtcbiAgICAgICAgY29uc3Qge3ZhbHVlfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdmFsdWUuaW5kZXhPZihjdXJyZW50VmFsdWUpO1xuICAgICAgICBjb25zdCB2YWxUZW1wID0gWy4uLnZhbHVlXTtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB2YWxUZW1wLnB1c2goY3VycmVudFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbFRlbXAuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKCd2YWx1ZScgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe3ZhbHVlOiB2YWxUZW1wfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh2YWxUZW1wLCBlKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY2xhc3NOYW1lLCBzdHlsZSwgcHJlZml4LCBkaXNhYmxlZCwgaXRlbURpcmVjdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gcGlja090aGVycyhDaGVja2JveEdyb3VwLnByb3BUeXBlcywgdGhpcy5wcm9wcyk7XG5cbiAgICAgICAgLy8g5aaC5p6c5YaF5bWM5qCH562+6LefZGF0YVNvdXJjZeWQjOaXtuWtmOWcqO+8jOS7peWGheW1jOagh+etvuS4uuS4u1xuICAgICAgICBsZXQgY2hpbGRyZW47XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMucHJvcHMuZGF0YVNvdXJjZS5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG9wdGlvbiA9IGl0ZW07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IHRoaXMuc3RhdGUudmFsdWUgJiYgdGhpcy5zdGF0ZS52YWx1ZS5pbmRleE9mKG9wdGlvbi52YWx1ZSkgPiAtMTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIDxDaGVja2JveCBrZXk9e2luZGV4fVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e29wdGlvbi52YWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2NoZWNrZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWQgfHwgb3B0aW9uLmRpc2FibGVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9e29wdGlvbi5sYWJlbH1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbHMgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9Y2hlY2tib3gtZ3JvdXBgXTogdHJ1ZSxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9Y2hlY2tib3gtZ3JvdXAtJHtpdGVtRGlyZWN0aW9ufWBdOiB0cnVlLFxuICAgICAgICAgICAgW2NsYXNzTmFtZV06ICEhY2xhc3NOYW1lLFxuICAgICAgICAgICAgZGlzYWJsZWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIDxzcGFuIHsuLi5vdGhlcnN9IGNsYXNzTmFtZT17Y2xzfSBzdHlsZT17c3R5bGV9PntjaGlsZHJlbn08L3NwYW4+O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlnUHJvdmlkZXIuY29uZmlnKENoZWNrYm94R3JvdXApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NoZWNrYm94L2NoZWNrYm94LWdyb3VwLmpzeCIsImltcG9ydCBSZWFjdCwge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IENvbmZpZ1Byb3ZpZGVyIGZyb20gJy4uL2NvbmZpZy1wcm92aWRlcic7XG5pbXBvcnQgeyBvYmogfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBSYWRpbyBmcm9tICcuL3JhZGlvJztcblxuY29uc3QgeyBwaWNrT3RoZXJzIH0gPSBvYmo7XG5cbi8qKlxuICogUmFkaW8uR3JvdXBcbiAqIEBvcmRlciAyXG4gKi9cbmNsYXNzIFJhZGlvR3JvdXAgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOagt+W8j+exu+WQjeeahOWTgeeJjOWJjee8gFxuICAgICAgICAgKi9cbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBydGw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog6Ieq5a6a5LmJ57G75ZCNXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDoh6rlrprkuYnlhoXmlZvmoLflvI9cbiAgICAgICAgICovXG4gICAgICAgIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAvKipcbiAgICAgICAgICogbmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJhZGlvIGdyb3Vw55qE6YCJ5Lit6aG555qE5YC8XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLmJvb2xdKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJhZGlvIGdyb3Vw55qE6buY6K6k5YC8XG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0VmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5ib29sXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpgInkuK3lgLzmlLnlj5jml7bnmoTkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmcvTnVtYmVyfSB2YWx1ZSDpgInkuK3pobnnmoTlgLxcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSBEb20g5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDooajnpLpyYWRpb+iiq+emgeeUqFxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5Y+v5Lul6K6+572u5oiQIGJ1dHRvbiDlsZXnpLrlvaLnirZcbiAgICAgICAgICogQGVudW1kZXNjIOaMiemSrueKtlxuICAgICAgICAgKi9cbiAgICAgICAgc2hhcGU6IFByb3BUeXBlcy5vbmVPZihbJ2J1dHRvbiddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS4jiBgc2hhcGVgIOWxnuaAp+mFjeWll+S9v+eUqO+8jHNoYXBl6K6+5Li6YnV0dG9u5pe25pyJ5pWIXG4gICAgICAgICAqIEBlbnVtZGVzYyDlpKcsIOS4rSwg5bCPXG4gICAgICAgICAqL1xuICAgICAgICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydsYXJnZScsICdtZWRpdW0nLCAnc21hbGwnXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlj6/pgInpobnliJfooagsIOaVsOaNrumhueWPr+S4uiBTdHJpbmcg5oiW6ICFIE9iamVjdCwg5aaCIGBbJ2FwcGxlJywgJ3BlYXInLCAnb3JhbmdlJ11gXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhU291cmNlOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuYW55KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmAmui/h+WtkOWFg+e0oOaWueW8j+iuvue9ruWGhemDqHJhZGlvXG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmVsZW1lbnQpLCBQcm9wVHlwZXMuZWxlbWVudF0pLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlrZDpobnnm67nmoTmjpLliJfmlrnlvI9cbiAgICAgICAgICogLSBob3o6IOawtOW5s+aOkuWIlyAoZGVmYXVsdClcbiAgICAgICAgICogLSB2ZXI6IOWeguebtOaOkuWIl1xuICAgICAgICAgKi9cbiAgICAgICAgaXRlbURpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAgICAgICAgICdob3onLFxuICAgICAgICAgICAgJ3ZlcicsXG4gICAgICAgIF0pLFxuICAgIH1cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGRhdGFTb3VyY2U6IFtdLFxuICAgICAgICBzaXplOiAnbWVkaXVtJyxcbiAgICAgICAgb25DaGFuZ2U6ICgpID0+IHtcbiAgICAgICAgfSxcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgICAgICBpdGVtRGlyZWN0aW9uOiAnaG96JyxcbiAgICB9XG5cbiAgICBzdGF0aWMgY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgX19ncm91cF9fOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgaXNCdXR0b246IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBzZWxlY3RlZFZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuYm9vbF0pLFxuICAgICAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2xcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBwcm9wcykge1xuICAgICAgICAgICAgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICgnZGVmYXVsdFZhbHVlJyBpbiBwcm9wcykge1xuICAgICAgICAgICAgdmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHt2YWx1ZX07XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSB0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX19ncm91cF9fOiB0cnVlLFxuICAgICAgICAgICAgaXNCdXR0b246IHRoaXMucHJvcHMuc2hhcGUgPT09ICdidXR0b24nLFxuICAgICAgICAgICAgb25DaGFuZ2U6IHRoaXMub25DaGFuZ2UsXG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlOiB0aGlzLnN0YXRlLnZhbHVlLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IHRoaXMucHJvcHMuZGlzYWJsZWRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBsZXQge3ZhbHVlfSA9IG5leHRQcm9wcztcbiAgICAgICAgaWYgKCd2YWx1ZScgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkNoYW5nZShjdXJyZW50VmFsdWUsIGUpIHtcbiAgICAgICAgaWYgKCEoJ3ZhbHVlJyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7dmFsdWU6IGN1cnJlbnRWYWx1ZX0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50VmFsdWUgIT09IHRoaXMuc3RhdGUudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoY3VycmVudFZhbHVlLCBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBydGwsIGNsYXNzTmFtZSwgc2hhcGUsIHNpemUsIHN0eWxlLCBwcmVmaXgsIGl0ZW1EaXJlY3Rpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IG90aGVycyA9IHBpY2tPdGhlcnMoT2JqZWN0LmtleXMoUmFkaW9Hcm91cC5wcm9wVHlwZXMpLCB0aGlzLnByb3BzKTtcbiAgICAgICAgY29uc3QgZGlzYWJsZWQgPSB0aGlzLnByb3BzLmRpc2FibGVkO1xuXG4gICAgICAgIGlmIChydGwpIHtcbiAgICAgICAgICAgIG90aGVycy5kaXIgPSAncnRsJztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjaGlsZHJlbjtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5kYXRhU291cmNlLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgb3B0aW9uID0gaXRlbTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja2VkID0gdGhpcy5zdGF0ZS52YWx1ZSA9PT0gb3B0aW9uLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAoPFJhZGlvXG4gICAgICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgICAgICAgICAgIHRhYkluZGV4PXsoKGluZGV4ID09PSAwICYmICF0aGlzLnN0YXRlLnZhbHVlKSB8fCBjaGVja2VkKSA/IDAgOiAtMX1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e29wdGlvbi52YWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cbiAgICAgICAgICAgICAgICAgICAgbGFiZWw9e29wdGlvbi5sYWJlbH1cbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkIHx8IG9wdGlvbi5kaXNhYmxlZH1cbiAgICAgICAgICAgICAgICAvPik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzQnV0dG9uU2hhcGUgPSBzaGFwZSA9PT0gJ2J1dHRvbic7XG5cbiAgICAgICAgY29uc3QgY2xzID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fXJhZGlvLWdyb3VwYF06IHRydWUsXG4gICAgICAgICAgICBbYCR7cHJlZml4fXJhZGlvLWdyb3VwLSR7aXRlbURpcmVjdGlvbn1gXTogIWlzQnV0dG9uU2hhcGUsXG4gICAgICAgICAgICBbYCR7cHJlZml4fXJhZGlvLWJ1dHRvbmBdOiBpc0J1dHRvblNoYXBlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1yYWRpby1idXR0b24tJHtzaXplfWBdOiBpc0J1dHRvblNoYXBlLFxuICAgICAgICAgICAgW2NsYXNzTmFtZV06ICEhY2xhc3NOYW1lLFxuICAgICAgICAgICAgZGlzYWJsZWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIDxkaXYgey4uLm90aGVyc30gYXJpYS1kaXNhYmxlZD17ZGlzYWJsZWR9IHJvbGU9XCJyYWRpb2dyb3VwXCIgY2xhc3NOYW1lPXtjbHN9IHN0eWxlPXtzdHlsZX0+e2NoaWxkcmVufTwvZGl2PjtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZ1Byb3ZpZGVyLmNvbmZpZyhSYWRpb0dyb3VwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yYWRpby9yYWRpby1ncm91cC5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBDaGVja2FibGVJdGVtIGZyb20gJy4vY2hlY2thYmxlLWl0ZW0nO1xuXG4vKipcbiAqIE1lbnUuUmFkaW9JdGVtXG4gKiBAb3JkZXIgNFxuICogQGRlc2NyaXB0aW9uIOivpeWtkOe7hOS7tumAieS4reaDheWGteS4jeWPlyBkZWZhdWx0U2VsZWN0ZWRLZXlzL3NlbGVjdGVkS2V5cyDmjqfliLbvvIzor7foh6rooYzmjqfliLbpgInkuK3pgLvovpFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkaW9JdGVtIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgbWVudUNoaWxkVHlwZSA9ICdpdGVtJztcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbpgInkuK1cbiAgICAgICAgICovXG4gICAgICAgIGNoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm56aB55SoXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpgInkuK3miJblj5bmtojpgInkuK3op6blj5HnmoTlm57osIPlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBjaGVja2VkIOaYr+WQpumAieS4rVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg6YCJ5Lit5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDluK7liqnmlofmnKxcbiAgICAgICAgICovXG4gICAgICAgIGhlbHBlcjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmoIfnrb7lhoXlrrlcbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBjaGVja2VkOiBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBvbkNoYW5nZTogKCkgPT4ge31cbiAgICB9O1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gPENoZWNrYWJsZUl0ZW0gcm9sZT1cIm1lbnVpdGVtcmFkaW9cIiBjaGVja1R5cGU9XCJyYWRpb1wiIHsuLi50aGlzLnByb3BzfSAvPjtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWVudS92aWV3L3JhZGlvLWl0ZW0uanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgY2xvbmVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBJdGVtIGZyb20gJy4vaXRlbSc7XG5cbi8qKlxuICogTWVudS5Hcm91cFxuICogQG9yZGVyIDVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JvdXAgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBtZW51Q2hpbGRUeXBlID0gJ2dyb3VwJztcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHJvb3Q6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOagh+etvuWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICAvKipcbiAgICAgICAgICog6I+c5Y2V6aG5XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIHBhcmVudE1vZGU6IFByb3BUeXBlcy5vbmVPZihbJ2lubGluZScsICdwb3B1cCddKSxcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcm9vdCwgY2xhc3NOYW1lLCBsYWJlbCwgY2hpbGRyZW4sIHBhcmVudE1vZGUsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBwcmVmaXggfSA9IHJvb3QucHJvcHM7XG5cbiAgICAgICAgY29uc3QgbmV3Q2xhc3NOYW1lID0gY3goe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1tZW51LWdyb3VwLWxhYmVsYF06IHRydWUsXG4gICAgICAgICAgICBbY2xhc3NOYW1lXTogISFjbGFzc05hbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbmV3Q2hpbGRyZW4gPSBjaGlsZHJlbi5tYXAoY2hpbGQgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjbGFzc05hbWUgfSA9IGNoaWxkLnByb3BzO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGRDbGFzc05hbWUgPSBjeCh7XG4gICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1tZW51LWdyb3VwLWl0ZW1gXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBbY2xhc3NOYW1lXTogISFjbGFzc05hbWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgICAgICAgICAgcGFyZW50TW9kZSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IG5ld0NoaWxkQ2xhc3NOYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIDxJdGVtXG4gICAgICAgICAgICAgICAga2V5PVwibWVudS1ncm91cC1sYWJlbFwiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtuZXdDbGFzc05hbWV9XG4gICAgICAgICAgICAgICAgcmVwbGFjZUNsYXNzTmFtZVxuICAgICAgICAgICAgICAgIHJvb3Q9e3Jvb3R9XG4gICAgICAgICAgICAgICAgcGFyZW50TW9kZT17cGFyZW50TW9kZX1cbiAgICAgICAgICAgICAgICB7Li4ub3RoZXJzfT57bGFiZWx9PC9JdGVtPixcbiAgICAgICAgICAgIC4uLm5ld0NoaWxkcmVuXG4gICAgICAgIF07XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21lbnUvdmlldy9ncm91cC5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcblxuLyoqXG4gKiBNZW51LkRpdmlkZXJcbiAqIEBvcmRlciA2XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpdmlkZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBtZW51Q2hpbGRUeXBlID0gJ2RpdmlkZXInO1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgcm9vdDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyByb290LCBjbGFzc05hbWUsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBwcmVmaXggfSA9IHJvb3QucHJvcHM7XG5cbiAgICAgICAgY29uc3QgbmV3Q2xhc3NOYW1lID0gY3goe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1tZW51LWRpdmlkZXJgXTogdHJ1ZSxcbiAgICAgICAgICAgIFtjbGFzc05hbWVdOiAhIWNsYXNzTmFtZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGxpIHJvbGU9XCJzZXBhcmF0b3JcIiBjbGFzc05hbWU9e25ld0NsYXNzTmFtZX0gey4uLm90aGVyc30+PC9saT5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWVudS92aWV3L2RpdmlkZXIuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHJlbmRlciwgdW5tb3VudENvbXBvbmVudEF0Tm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IE92ZXJsYXkgZnJvbSAnLi4vLi4vb3ZlcmxheSc7XG5pbXBvcnQgeyBmdW5jIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgQ29uZmlnUHJvdmlkZXIgZnJvbSAnLi4vLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCBtZW51IGZyb20gJy4vbWVudSc7XG5cbmNvbnN0IHsgYmluZEN0eCB9ID0gZnVuYztcbmNvbnN0IHsgZ2V0Q29udGV4dFByb3BzIH0gPSBDb25maWdQcm92aWRlcjtcbmNvbnN0IE1lbnUgPSBDb25maWdQcm92aWRlci5jb25maWcobWVudSk7XG5cbmxldCBtZW51SW5zdGFuY2U7XG5cbmNsYXNzIENvbnRleHRNZW51IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHBvcHVwQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICB0YXJnZXQ6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIGFsaWduOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBvZmZzZXQ6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgb3ZlcmxheVByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBhZnRlckNsb3NlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgbW9kZTogUHJvcFR5cGVzLm9uZU9mKFsnaW5saW5lJywgJ3BvcHVwJ10pLFxuICAgICAgICBvbk9wZW46IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkl0ZW1DbGljazogUHJvcFR5cGVzLmZ1bmNcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgICAgICBhbGlnbjogJ3RsIHRsJyxcbiAgICAgICAgbW9kZTogJ3BvcHVwJ1xuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICBiaW5kQ3R4KHRoaXMsIFsnaGFuZGxlT3ZlcmxheUNsb3NlJywgJ2hhbmRsZU92ZXJsYXlPcGVuJywgJ2hhbmRsZUl0ZW1DbGljaycsICdnZXRPdmVybGF5J10pO1xuICAgIH1cblxuICAgIGdldE92ZXJsYXkocmVmKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IHJlZjtcbiAgICB9XG5cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgbWVudUluc3RhbmNlID0gbnVsbDtcbiAgICB9XG5cbiAgICBoYW5kbGVPdmVybGF5Q2xvc2UodHJpZ2dlclR5cGUsIGUsIC4uLm90aGVycykge1xuICAgICAgICBjb25zdCBjbGlja2VkUG9wdXBNZW51ID0gdHJpZ2dlclR5cGUgPT09ICdkb2NDbGljaycgJiZcbiAgICAgICAgICAgIHRoaXMucG9wdXBOb2Rlcy5zb21lKG5vZGUgPT4gbm9kZS5jb250YWlucyhlLnRhcmdldCkpO1xuICAgICAgICBpZiAoIWNsaWNrZWRQb3B1cE1lbnUpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgb3ZlcmxheVByb3BzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKG92ZXJsYXlQcm9wcyAmJiBvdmVybGF5UHJvcHMub25SZXF1ZXN0Q2xvc2UpIHtcbiAgICAgICAgICAgICAgICBvdmVybGF5UHJvcHMub25SZXF1ZXN0Q2xvc2UodHJpZ2dlclR5cGUsIGUsIC4uLm90aGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVPdmVybGF5T3BlbigpIHtcbiAgICAgICAgdGhpcy5wb3B1cE5vZGVzID0gdGhpcy5vdmVybGF5LmdldEluc3RhbmNlKCkuZ2V0Q29udGVudCgpLmdldEluc3RhbmNlKCkucG9wdXBOb2RlcztcbiAgICAgICAgY29uc3QgeyBvdmVybGF5UHJvcHMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChvdmVybGF5UHJvcHMgJiYgb3ZlcmxheVByb3BzLm9uT3Blbikge1xuICAgICAgICAgICAgb3ZlcmxheVByb3BzLm9uT3BlbigpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBoYW5kbGVJdGVtQ2xpY2soLi4uYXJncykge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vbkl0ZW1DbGljayAmJiB0aGlzLnByb3BzLm9uSXRlbUNsaWNrKC4uLmFyZ3MpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBjbGFzc05hbWUsIHBvcHVwQ2xhc3NOYW1lLCB0YXJnZXQsIGFsaWduLCBvZmZzZXQsIGFmdGVyQ2xvc2UsIG92ZXJsYXlQcm9wcyA9IHt9LCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGNvbnRleHRQcm9wcyA9IGdldENvbnRleHRQcm9wcyh0aGlzLnByb3BzKTtcbiAgICAgICAgY29uc3QgeyBwcmVmaXggfSA9IGNvbnRleHRQcm9wcztcbiAgICAgICAgY29uc3QgeyB2aXNpYmxlIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIGNvbnN0IG5ld092ZXJsYXlQcm9wcyA9IHtcbiAgICAgICAgICAgIC4uLmNvbnRleHRQcm9wcyxcbiAgICAgICAgICAgIC4uLm92ZXJsYXlQcm9wcyxcbiAgICAgICAgICAgIHRhcmdldCwgYWxpZ24sIG9mZnNldCwgYWZ0ZXJDbG9zZSwgdmlzaWJsZSxcbiAgICAgICAgICAgIG9uUmVxdWVzdENsb3NlOiB0aGlzLmhhbmRsZU92ZXJsYXlDbG9zZSxcbiAgICAgICAgICAgIG9uT3BlbjogdGhpcy5oYW5kbGVPdmVybGF5T3BlbixcbiAgICAgICAgICAgIHJlZjogdGhpcy5nZXRPdmVybGF5XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1lbnVQcm9wcyA9IHtcbiAgICAgICAgICAgIC4uLmNvbnRleHRQcm9wcyxcbiAgICAgICAgICAgIHRyaWdnZXJUeXBlOiAnaG92ZXInLFxuICAgICAgICAgICAgLi4ub3RoZXJzLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjeCh7XG4gICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1jb250ZXh0YF06IHRydWUsXG4gICAgICAgICAgICAgICAgW2NsYXNzTmFtZV06ICEhY2xhc3NOYW1lXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHBvcHVwQ2xhc3NOYW1lOiBjeCh7XG4gICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1jb250ZXh0YF06IHRydWUsXG4gICAgICAgICAgICAgICAgW3BvcHVwQ2xhc3NOYW1lXTogISFwb3B1cENsYXNzTmFtZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvbkl0ZW1DbGljazogdGhpcy5oYW5kbGVJdGVtQ2xpY2tcbiAgICAgICAgfTtcblxuICAgICAgICBuZXdPdmVybGF5UHJvcHMucnRsID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxPdmVybGF5IHsuLi5uZXdPdmVybGF5UHJvcHN9PlxuICAgICAgICAgICAgICAgIDxNZW51IHsuLi5tZW51UHJvcHN9IC8+XG4gICAgICAgICAgICA8L092ZXJsYXk+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIOWIm+W7uuS4iuS4i+aWh+iPnOWNlVxuICogQGV4cG9ydE5hbWUgY3JlYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMg5bGe5oCn5a+56LGhXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZShwcm9wcykge1xuICAgIGlmIChtZW51SW5zdGFuY2UpIHtcbiAgICAgICAgbWVudUluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgIGNvbnN0IHsgYWZ0ZXJDbG9zZSwgLi4ub3RoZXJzIH0gPSBwcm9wcztcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG5cbiAgICBjb25zdCBjbG9zZUNoYWluID0gKCkgPT4ge1xuICAgICAgICB1bm1vdW50Q29tcG9uZW50QXROb2RlKGRpdik7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcblxuICAgICAgICBhZnRlckNsb3NlICYmIGFmdGVyQ2xvc2UoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgbmV3Q29udGV4dCA9IENvbmZpZ1Byb3ZpZGVyLmdldENvbnRleHQoKTtcblxuICAgIGxldCBtZW51O1xuICAgIHJlbmRlcihcbiAgICAgICAgPENvbmZpZ1Byb3ZpZGVyIHsuLi5uZXdDb250ZXh0fT5cbiAgICAgICAgICAgIDxDb250ZXh0TWVudSByZWY9e3JlZiA9PiB7XG4gICAgICAgICAgICAgICAgbWVudSA9IHJlZjtcbiAgICAgICAgICAgIH19IGFmdGVyQ2xvc2U9e2Nsb3NlQ2hhaW59IHsuLi5vdGhlcnN9IC8+XG4gICAgICAgIDwvQ29uZmlnUHJvdmlkZXI+XG4gICAgICAgICwgZGl2XG4gICAgKTtcblxuICAgIG1lbnVJbnN0YW5jZSA9IHtcbiAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG1lbnUpIHtcbiAgICAgICAgICAgICAgICBtZW51LmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIG1lbnVJbnN0YW5jZTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tZW51L3ZpZXcvY3JlYXRlLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuXG5mdW5jdGlvbiBtYXBJY29uU2l6ZShzaXplKSB7XG4gICAgcmV0dXJuICh7XG4gICAgICAgIGxhcmdlOiAnc21hbGwnLFxuICAgICAgICBtZWRpdW06ICd4cycsXG4gICAgICAgIHNtYWxsOiAneHMnLFxuICAgIH0pW3NpemVdO1xufVxuXG4vKiogQnV0dG9uICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXR0b24gZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaMiemSrueahOexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogUHJvcFR5cGVzLm9uZU9mKFsncHJpbWFyeScsICdzZWNvbmRhcnknLCAnbm9ybWFsJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5oyJ6ZKu55qE5bC65a+4XG4gICAgICAgICAqL1xuICAgICAgICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydzbWFsbCcsICdtZWRpdW0nLCAnbGFyZ2UnXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmjInpkq7kuK0gSWNvbiDnmoTlsLrlr7jvvIznlKjkuo7mm7/ku6MgSWNvbiDnmoTpu5jorqTlpKflsI9cbiAgICAgICAgICovXG4gICAgICAgIGljb25TaXplOiBQcm9wVHlwZXMub25lT2YoWyd4eHMnLCAneHMnLCAnc21hbGwnLCAnbWVkaXVtJywgJ2xhcmdlJywgJ3hsJywgJ3h4bCcsICd4eHhsJ10pLFxuICAgICAgICAvKipcbiAgICAgICAgICog5b2TIGNvbXBvbmVudCA9ICdidXR0b24nIOaXtu+8jOiuvue9riBidXR0b24g5qCH562+55qEIHR5cGUg5YC8XG4gICAgICAgICAqL1xuICAgICAgICBodG1sVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnc3VibWl0JywgJ3Jlc2V0JywgJ2J1dHRvbiddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruagh+etvuexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgY29tcG9uZW50OiBQcm9wVHlwZXMub25lT2YoWydidXR0b24nLCAnYSddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruaMiemSrueahOi9veWFpeeKtuaAgVxuICAgICAgICAgKi9cbiAgICAgICAgbG9hZGluZzogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbkuLrlub3ngbXmjInpkq5cbiAgICAgICAgICovXG4gICAgICAgIGdob3N0OiBQcm9wVHlwZXMub25lT2YoW3RydWUsIGZhbHNlLCAnbGlnaHQnLCAnZGFyayddKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuS4uuaWh+acrOaMiemSrlxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbkuLrorablkYrmjInpkq5cbiAgICAgICAgICovXG4gICAgICAgIHdhcm5pbmc6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm56aB55SoXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDngrnlh7vmjInpkq7nmoTlm57osINcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGUgRXZlbnQgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBvbk1vdXNlVXA6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgICAgICB0eXBlOiAnbm9ybWFsJyxcbiAgICAgICAgc2l6ZTogJ21lZGl1bScsXG4gICAgICAgIGh0bWxUeXBlOiAnYnV0dG9uJyxcbiAgICAgICAgY29tcG9uZW50OiAnYnV0dG9uJyxcbiAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgIGdob3N0OiBmYWxzZSxcbiAgICAgICAgdGV4dDogZmFsc2UsXG4gICAgICAgIHdhcm5pbmc6IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIG9uQ2xpY2s6ICgpID0+IHt9XG4gICAgfTtcblxuICAgIG9uTW91c2VVcCA9IChlKSA9PiB7XG4gICAgICAgIHRoaXMuYnV0dG9uLmJsdXIoKTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbk1vdXNlVXApIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Nb3VzZVVwKGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGJ1dHRvblJlZkhhbmRsZXIgPSAoYnV0dG9uKSA9PiB7XG4gICAgICAgIHRoaXMuYnV0dG9uID0gYnV0dG9uO1xuICAgIH07XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBjbGFzc05hbWUsIHR5cGUsIHNpemUsIGh0bWxUeXBlLCBsb2FkaW5nLCB0ZXh0LCB3YXJuaW5nLCBnaG9zdCwgY29tcG9uZW50LCBpY29uU2l6ZSwgY2hpbGRyZW4sIHJ0bCwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBnaG9zdFR5cGUgPSBbJ2xpZ2h0JywgJ2RhcmsnXS5pbmRleE9mKGdob3N0KSA+PSAwID8gZ2hvc3QgOiAnZGFyayc7XG5cbiAgICAgICAgY29uc3QgYnRuQ2xzID0gY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fWJ0bmBdOiB0cnVlLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH0ke3NpemV9YF06IHNpemUsXG4gICAgICAgICAgICBbYCR7cHJlZml4fWJ0bi0ke3R5cGV9YF06IHR5cGUgJiYgIWdob3N0LFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1idG4tdGV4dGBdOiB0ZXh0LFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1idG4td2FybmluZ2BdOiB3YXJuaW5nLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1idG4tbG9hZGluZ2BdOiBsb2FkaW5nLFxuICAgICAgICAgICAgW2Ake3ByZWZpeH1idG4tZ2hvc3RgXTogZ2hvc3QsXG4gICAgICAgICAgICBbYCR7cHJlZml4fWJ0bi0ke2dob3N0VHlwZX1gXTogZ2hvc3QsXG4gICAgICAgICAgICBbY2xhc3NOYW1lXTogY2xhc3NOYW1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGNvdW50ID0gQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pO1xuICAgICAgICBjb25zdCBjbG9uZWRDaGlsZHJlbiA9IENoaWxkcmVuLm1hcChjaGlsZHJlbiwgKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoaWxkICYmIHR5cGVvZiBjaGlsZC50eXBlID09PSAnZnVuY3Rpb24nICYmIGNoaWxkLnR5cGUuX3R5cGVNYXJrID09PSAnaWNvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uQ2xzID0gY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9YnRuLWljb25gXTogIWljb25TaXplLCAvLyDlpoLmnpznlKjmiLfmsqHmnInkvKAgaWNvblNpemXvvIzliJnkvb/nlKjor6XmoLflvI/moIforrAgaWNvbiDkuLogYnV0dG9uIOmihOiuvuWwuuWvuFxuICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4fWljb24tZmlyc3RgXTogY291bnQgPiAxICYmIGluZGV4ID09PSAwLFxuICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4fWljb24tbGFzdGBdOiBjb3VudCA+IDEgJiYgaW5kZXggPT09IGNvdW50IC0gMSxcbiAgICAgICAgICAgICAgICAgICAgW2Ake3ByZWZpeH1pY29uLWFsb25lYF06IGNvdW50ID09PSAxLFxuICAgICAgICAgICAgICAgICAgICBbY2hpbGQucHJvcHMuY2xhc3NOYW1lXTogISFjaGlsZC5wcm9wcy5jbGFzc05hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogaWNvbkNscyxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogaWNvblNpemUgfHwgbWFwSWNvblNpemUoc2l6ZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBUYWdOYW1lID0gY29tcG9uZW50O1xuICAgICAgICBjb25zdCB0YWdBdHRycyA9IHtcbiAgICAgICAgICAgIC4uLm90aGVycyxcbiAgICAgICAgICAgIHR5cGU6IGh0bWxUeXBlLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBidG5DbHNcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoVGFnTmFtZSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICBkZWxldGUgdGFnQXR0cnMudHlwZTtcblxuICAgICAgICAgICAgaWYgKHRhZ0F0dHJzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRhZ0F0dHJzLm9uQ2xpY2s7IC8vIGEg5qCH562+55qEIG9uQ2xpY2sg5rWP6KeI5Zmo6buY6K6k5LiN5Lya56aB55SoXG4gICAgICAgICAgICAgICAgdGFnQXR0cnMuaHJlZiAmJiBkZWxldGUgdGFnQXR0cnMuaHJlZjsgLy8gYSDmoIfnrb7lnKjnpoHnlKjnirbmgIHkuIvml6Dot7PovaxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8VGFnTmFtZSB7Li4udGFnQXR0cnN9IGRpcj17cnRsID8gJ3J0bCcgOiB1bmRlZmluZWR9IG9uTW91c2VVcD17dGhpcy5vbk1vdXNlVXB9IHJlZj17dGhpcy5idXR0b25SZWZIYW5kbGVyfSByb2xlPVwiYnV0dG9uXCI+XG4gICAgICAgICAgICAgICAge2Nsb25lZENoaWxkcmVufVxuICAgICAgICAgICAgPC9UYWdOYW1lPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9idXR0b24vdmlldy9idXR0b24uanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgQ29uZmlnUHJvdmlkZXIgZnJvbSAnLi4vLi4vY29uZmlnLXByb3ZpZGVyJztcblxuLyoqXG4gKiBCdXR0b24uR3JvdXBcbiAqL1xuY2xhc3MgQnV0dG9uR3JvdXAgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe7n+S4gOiuvue9riBCdXR0b24g57uE5Lu255qE5oyJ6ZKu5aSn5bCPXG4gICAgICAgICAqL1xuICAgICAgICBzaXplOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBwcmVmaXg6ICduZXh0LScsXG4gICAgICAgIHNpemU6ICdtZWRpdW0nLFxuICAgIH07XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBjbGFzc05hbWUsIHNpemUsIGNoaWxkcmVuLCBydGwsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBjb25zdCBncm91cENscyA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1idG4tZ3JvdXBgXTogdHJ1ZSxcbiAgICAgICAgICAgIFtjbGFzc05hbWVdOiBjbGFzc05hbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgY2xvbmVDaGlsZHJlbiA9IENoaWxkcmVuLm1hcChjaGlsZHJlbiwgKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgb3RoZXJzLmRpciA9ICdydGwnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgey4uLm90aGVyc30gY2xhc3NOYW1lPXtncm91cENsc30+XG4gICAgICAgICAgICAgICAge2Nsb25lQ2hpbGRyZW59XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZ1Byb3ZpZGVyLmNvbmZpZyhCdXR0b25Hcm91cCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYnV0dG9uL3ZpZXcvZ3JvdXAuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBUIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgZXZlbnRzLCBkb20gfSBmcm9tICcuLi8uLi91dGlsJztcblxuY2xhc3MgUmVzaXplIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBwcmVmaXg6IFQuc3RyaW5nLFxuICAgICAgICBvbkNoYW5nZTogVC5mdW5jLFxuICAgICAgICBkYXRhSW5kZXg6IFQuc3RyaW5nXG4gICAgfVxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIG9uQ2hhbmdlOiAoKSA9PiB7fVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5kZXN0b3J5KCk7XG4gICAgfVxuICAgIG9uTW91c2VEb3duID0gKGUpID0+IHtcbiAgICAgICAgdGhpcy5sYXN0UGFnZVggPSBlLnBhZ2VYO1xuICAgICAgICBldmVudHMub24oZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgZXZlbnRzLm9uKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKTtcbiAgICAgICAgdGhpcy51blNlbGVjdCgpO1xuICAgIH1cbiAgICBvbk1vdXNlTW92ZSA9IChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhZ2VYID0gZS5wYWdlWDtcbiAgICAgICAgY29uc3QgY2hhbmdlZFBhZ2VYID0gcGFnZVggLSB0aGlzLmxhc3RQYWdlWDtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh0aGlzLnByb3BzLmRhdGFJbmRleCwgY2hhbmdlZFBhZ2VYKTtcbiAgICAgICAgdGhpcy5sYXN0UGFnZVggPSBwYWdlWDtcbiAgICB9XG4gICAgb25Nb3VzZVVwID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmRlc3RvcnkoKTtcbiAgICB9XG4gICAgZGVzdG9yeSgpIHtcbiAgICAgICAgZXZlbnRzLm9mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgICAgICBldmVudHMub2ZmKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgICAgICB0aGlzLnNlbGVjdCgpO1xuICAgIH1cbiAgICB1blNlbGVjdCgpIHtcbiAgICAgICAgZG9tLnNldFN0eWxlKGRvY3VtZW50LmJvZHksIHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgICAgIGN1cnNvcjogJ2V3LXJlc2l6ZSdcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc2V0QXR0cmlidXRlKCd1bnNlbGVjdGFibGUnLCAnb24nKTtcbiAgICB9XG4gICAgc2VsZWN0KCkge1xuICAgICAgICBkb20uc2V0U3R5bGUoZG9jdW1lbnQuYm9keSwge1xuICAgICAgICAgICAgdXNlclNlbGVjdDogJycsXG4gICAgICAgICAgICBjdXJzb3I6ICcnXG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUF0dHJpYnV0ZSgndW5zZWxlY3RhYmxlJyk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXggfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiA8YSBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1yZXNpemUtaGFuZGxlcmB9IG9uTW91c2VEb3duPXt0aGlzLm9uTW91c2VEb3dufT48L2E+O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVzaXplO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2Jhc2UvcmVzaXplLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9wcmVmZXItc3RhdGVsZXNzLWZ1bmN0aW9uICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXcmFwcGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHtjb2xHcm91cCwgY2hpbGRyZW4sIGNvbXBvbmVudDogVGFnfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoPFRhZyByb2xlPVwidGFibGVcIj5cbiAgICAgICAgICAgIHtjb2xHcm91cH1cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9UYWc+KTtcbiAgICB9XG59XG5cbldyYXBwZXIuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbXBvbmVudDogJ3RhYmxlJ1xufTtcblxuV3JhcHBlci5wcm9wVHlwZXMgPSB7XG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGNvbEdyb3VwOiBQcm9wVHlwZXMuYW55LFxuICAgIGNvbXBvbmVudDogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2Jhc2Uvd3JhcHBlci5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuLyoqXG4gKiBUYWJsZS5Db2x1bW5Hcm91cFxuICogQG9yZGVyIDFcbiAqKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbHVtbkdyb3VwIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDooajlpLTmmL7npLrnmoTlhoXlrrlcbiAgICAgICAgICovXG4gICAgICAgIHRpdGxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZWxlbWVudCwgUHJvcFR5cGVzLm5vZGUsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgfVxuXG4gICAgc3RhdGljIGNoaWxkQ29udGV4dFR5cGVzID0ge1xuICAgICAgICBwYXJlbnQ6IFByb3BUeXBlcy5hbnlcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICB0aXRsZTogJ2NvbHVtbi1ncm91cCdcbiAgICB9XG5cbiAgICBzdGF0aWMgX3R5cGVNYXJrID0gJ2NvbHVtbkdyb3VwJztcblxuICAgIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2NvbHVtbi1ncm91cC5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSb3dDb21wb25lbnQgZnJvbSAnLi90cmVlL3Jvdyc7XG5pbXBvcnQgQ2VsbENvbXBvbmVudCBmcm9tICcuL3RyZWUvY2VsbCc7XG5pbXBvcnQge3N0YXRpY3N9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyZWUoQmFzZUNvbXBvbmVudCkge1xuICAgIGNsYXNzIFRyZWVUYWJsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgICAgIHN0YXRpYyBUcmVlUm93ID0gUm93Q29tcG9uZW50O1xuICAgICAgICBzdGF0aWMgVHJlZUNlbGwgPSBDZWxsQ29tcG9uZW50O1xuICAgICAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDpu5jorqTmg4XlhrXkuIvlsZXlvIDnmoTmoJHlvaLooajmoLzvvIzkvKDlhaXkuobmraTlsZ7mgKfku6Pooah0cmVl55qE5bGV5byA5Li65Y+X5o6n5pON5L2cXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9wZW5Sb3dLZXlzOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOeCueWHu3RyZWXlsZXlvIDmiJbogIXlhbPpl63nmoTml7blgJnop6blj5HnmoTkuovku7ZcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IG9wZW5Sb3dLZXlzIHRyZWXmqKHlvI/kuIvlsZXlvIDnmoRrZXlcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjdXJyZW50Um93S2V5IOW9k+WJjeeCueWHu+ihjOeahGtleVxuICAgICAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBvcGVuZWQg5b2T5YmN54K55Ye75piv5bGV5byA6L+Y5piv5pS26LW3XG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY3VycmVudFJlY29yZCDlvZPliY3ngrnlh7vooYznmoTorrDlvZVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb25Sb3dPcGVuOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogZGF0YVNvdXJjZeW9k+S4reaVsOaNrueahOS4u+mUru+8jOWmguaenOe7meWumueahOaVsOaNrua6kOS4reeahOWxnuaAp+S4jeWMheWQq+ivpeS4u+mUru+8jOS8mumAoOaIkOmAieaLqeeKtuaAgeWFqOmDqOmAieS4rVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBwcmltYXJ5S2V5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDlnKh0cmVl5qih5byP5LiL55qE57yp6L+b5bC65a+477yMIOS7heWcqGlzVHJlZeS4unRydWXml7blgJnmnInmlYhcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaW5kZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDlvIDlkK9UYWJsZeeahHRyZWXmqKHlvI8sIOaOpeaUtueahOaVsOaNruagvOW8j+S4reWMheWQq2NoaWxkcmVu5YiZ5riy5p+T5oiQdHJlZSB0YWJsZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpc1RyZWU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAgICAgbG9jYWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAgICAgLi4uQmFzZUNvbXBvbmVudC5wcm9wVHlwZXMsXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAgICAgLi4uQmFzZUNvbXBvbmVudC5kZWZhdWx0UHJvcHMsXG4gICAgICAgICAgICBwcmltYXJ5S2V5OiAnaWQnLFxuICAgICAgICAgICAgb25Sb3dPcGVuOiBub29wLFxuICAgICAgICAgICAgY29tcG9uZW50czoge30sXG4gICAgICAgICAgICBpbmRlbnQ6IDEyXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0aWMgY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gICAgICAgICAgICBvcGVuVHJlZVJvd0tleXM6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgICAgIGluZGVudDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgICAgIHRyZWVTdGF0dXM6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgICAgIG9uVHJlZU5vZGVDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgICAgICBpc1RyZWU6IFByb3BUeXBlcy5ib29sXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xuICAgICAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBvcGVuUm93S2V5czogcHJvcHMub3BlblJvd0tleXMgfHwgW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9wZW5UcmVlUm93S2V5czogdGhpcy5zdGF0ZS5vcGVuUm93S2V5cyxcbiAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMucHJvcHMuaW5kZW50LFxuICAgICAgICAgICAgICAgIHRyZWVTdGF0dXM6IHRoaXMuZ2V0VHJlZU5vZGVTdGF0dXModGhpcy5kcyksXG4gICAgICAgICAgICAgICAgb25UcmVlTm9kZUNsaWNrOiB0aGlzLm9uVHJlZU5vZGVDbGljayxcbiAgICAgICAgICAgICAgICBpc1RyZWU6IHRoaXMucHJvcHMuaXNUcmVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIGlmICgnb3BlblJvd0tleXMnIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgb3BlblJvd0tleXMgfSA9IG5leHRQcm9wcztcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlblJvd0tleXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vcm1hbGl6ZURhdGFTb3VyY2UoZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gW10sXG4gICAgICAgICAgICAgICAgbG9vcCA9IGZ1bmN0aW9uIChkYXRhU291cmNlLCBsZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhU291cmNlLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLl9fbGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb29wKGl0ZW0uY2hpbGRyZW4sIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsb29wKGRhdGFTb3VyY2UsIDApO1xuICAgICAgICAgICAgdGhpcy5kcyA9IHJldDtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRUcmVlTm9kZVN0YXR1cyhkYXRhU291cmNlID0gW10pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3BlblJvd0tleXMgfSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICAgICAgeyBwcmltYXJ5S2V5IH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIHJldCA9IFtdO1xuXG4gICAgICAgICAgICBvcGVuUm93S2V5cy5mb3JFYWNoKG9wZW5LZXkgPT4ge1xuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1bcHJpbWFyeUtleV0gPT09IG9wZW5LZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goY2hpbGRbcHJpbWFyeUtleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBvblRyZWVOb2RlQ2xpY2sgPSAocmVjb3JkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHByaW1hcnlLZXkgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaWQgPSByZWNvcmRbcHJpbWFyeUtleV0sXG4gICAgICAgICAgICAgICAgZGF0YVNvdXJjZSA9IHRoaXMuZHMsXG4gICAgICAgICAgICAgICAgb3BlblJvd0tleXMgPSBbLi4udGhpcy5zdGF0ZS5vcGVuUm93S2V5c10sXG4gICAgICAgICAgICAgICAgaW5kZXggPSBvcGVuUm93S2V5cy5pbmRleE9mKGlkKSxcbiAgICAgICAgICAgICAgICBnZXRDaGlsZHJlbktleUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9vcCA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goaXRlbVtwcmltYXJ5S2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcChpdGVtLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVNvdXJjZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1bcHJpbWFyeUtleV0gPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcChpdGVtLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8g5LiN5LuF6KaB5Yig6Zmk5b2T5YmN55qEb3BlblJvd0tlee+8jOi/mOmcgOimgeWIoOmZpOWFs+iBlOWtkOiKgueCueeahG9wZW5Sb3dLZXlcbiAgICAgICAgICAgICAgICBjb25zdCBpZHMgPSBnZXRDaGlsZHJlbktleUJ5SWQoaWQpO1xuICAgICAgICAgICAgICAgIGlkcy5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaSA9IG9wZW5Sb3dLZXlzLmluZGV4T2YoaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuUm93S2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3BlblJvd0tleXMucHVzaChpZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKCdvcGVuUm93S2V5cycgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlblJvd0tleXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Sb3dPcGVuKG9wZW5Sb3dLZXlzLCBpZCwgaW5kZXggPT09IC0xLCByZWNvcmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyKCkge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIHByZWZlci1jb25zdCAqL1xuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50cywgaXNUcmVlLCBkYXRhU291cmNlLCBpbmRlbnQsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICAgICAgaWYgKGlzVHJlZSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMgPSB7Li4uY29tcG9uZW50c307XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnRzLlJvdykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLlJvdyA9IFJvd0NvbXBvbmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnRzLkNlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5DZWxsID0gQ2VsbENvbXBvbmVudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXRhU291cmNlID0gdGhpcy5ub3JtYWxpemVEYXRhU291cmNlKGRhdGFTb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICg8QmFzZUNvbXBvbmVudCB7Li4ub3RoZXJzfSBkYXRhU291cmNlPXtkYXRhU291cmNlfSBjb21wb25lbnRzPXtjb21wb25lbnRzfSAvPik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljcyhUcmVlVGFibGUsIEJhc2VDb21wb25lbnQpO1xuICAgIHJldHVybiBUcmVlVGFibGU7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvdHJlZS5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFJvdyBmcm9tICcuLi9zZWxlY3Rpb24vcm93JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJlZVJvdyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLi4uUm93LnByb3BUeXBlc1xuICAgIH1cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIC4uLlJvdy5kZWZhdWx0UHJvcHNcbiAgICB9XG5cbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICB0cmVlU3RhdHVzOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIG9wZW5Sb3dLZXlzOiBQcm9wVHlwZXMuYXJyYXlcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzKi9cbiAgICAgICAgY29uc3QgeyBjbGFzc05hbWUsIHJlY29yZCwgcHJpbWFyeUtleSwgcHJlZml4LCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgdHJlZVN0YXR1cywgb3BlblJvd0tleXMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgY29uc3QgY2xzID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICBoaWRkZW46ICEodHJlZVN0YXR1cy5pbmRleE9mKHJlY29yZFtwcmltYXJ5S2V5XSkgPiAtMSkgJiYgcmVjb3JkLl9fbGV2ZWwgIT09IDAsXG4gICAgICAgICAgICBbYCR7cHJlZml4fXRhYmxlLXJvdy1sZXZlbC0ke3JlY29yZC5fX2xldmVsfWBdOiB0cnVlLFxuICAgICAgICAgICAgb3BlbmVkOiBvcGVuUm93S2V5cy5pbmRleE9mKHJlY29yZFtwcmltYXJ5S2V5XSkgPiAtMSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoPFJvdyB7Li4ub3RoZXJzfSByZWNvcmQ9e3JlY29yZH0gY2xhc3NOYW1lPXtjbHN9IHByaW1hcnlLZXk9e3ByaW1hcnlLZXl9IHByZWZpeD17cHJlZml4fS8+KTtcbiAgICB9XG59XG5cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL3RyZWUvcm93LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi4vLi4vaWNvbic7XG5pbXBvcnQgeyBLRVlDT0RFIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgQ2VsbENvbXBvbmVudCBmcm9tICcuLi9iYXNlL2NlbGwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmVlQ2VsbCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgaW5kZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBsb2NhbGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIC4uLkNlbGxDb21wb25lbnQucHJvcFR5cGVzXG4gICAgfVxuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgLi4uQ2VsbENvbXBvbmVudC5kZWZhdWx0UHJvcHMsXG4gICAgICAgIGNvbXBvbmVudDogJ3RkJyxcbiAgICAgICAgaW5kZW50OiAyMFxuICAgIH1cblxuICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIG9wZW5UcmVlUm93S2V5czogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBpbmRlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIG9uVHJlZU5vZGVDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGlzVHJlZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHJvd1NlbGVjdGlvbjogUHJvcFR5cGVzLm9iamVjdCxcbiAgICB9XG5cbiAgICBvblRyZWVOb2RlQ2xpY2sgPSAocmVjb3JkLCBlKSA9PiB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5vblRyZWVOb2RlQ2xpY2socmVjb3JkKTtcbiAgICB9XG5cbiAgICBleHBhbmRlZEtleWRvd24gPSAocmVjb3JkLCBlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBLRVlDT0RFLkVOVEVSKSB7XG4gICAgICAgICAgICB0aGlzLm9uVHJlZU5vZGVDbGljayhyZWNvcmQsIGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGNvbEluZGV4LCByZWNvcmQsIHByZWZpeCwgcHJpbWFyeUtleSwgbG9jYWxlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IG9wZW5UcmVlUm93S2V5czogb3BlblJvd0tleXMsIGluZGVudCwgaXNUcmVlLCByb3dTZWxlY3Rpb24gfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgY29uc3QgdHJlZUFycm93Tm9kZUluZGV4ID0gcm93U2VsZWN0aW9uID8gMSA6IDA7XG4gICAgICAgIGxldCBmaXJzdENlbGxTdHlsZSwgdHJlZUFycm93Tm9kZTtcbiAgICAgICAgaWYgKGNvbEluZGV4ID09PSB0cmVlQXJyb3dOb2RlSW5kZXgpIHtcbiAgICAgICAgICAgIGxldCB0cmVlQXJyb3dUeXBlO1xuICAgICAgICAgICAgaWYgKGlzVHJlZSkge1xuICAgICAgICAgICAgICAgIGZpcnN0Q2VsbFN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nTGVmdDogaW5kZW50ICogKHJlY29yZC5fX2xldmVsICsgMSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRyZWVBcnJvd05vZGUgPSA8SWNvbiBzaXplPVwieHNcIiBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS10cmVlLXBsYWNlaG9sZGVyYH0gLz47XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5jaGlsZHJlbiAmJiByZWNvcmQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc0V4cGFuZGVkID0gb3BlblJvd0tleXMuaW5kZXhPZihyZWNvcmRbcHJpbWFyeUtleV0pID4gLTE7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJlZUFycm93VHlwZSA9IGhhc0V4cGFuZGVkID8gJ2Fycm93LWRvd24nIDogJ2Fycm93LXJpZ2h0JztcblxuICAgICAgICAgICAgICAgICAgICB0cmVlQXJyb3dOb2RlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICg8SWNvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLXRyZWUtYXJyb3dgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9e3RyZWVBcnJvd1R5cGV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZT1cInhzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtlID0+IHRoaXMub25UcmVlTm9kZUNsaWNrKHJlY29yZCwgZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25LZXlEb3duPXtlID0+IHRoaXMuZXhwYW5kZWRLZXlkb3duKHJlY29yZCwgZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg9XCIwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWV4cGFuZGVkPXtoYXNFeHBhbmRlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPXtoYXNFeHBhbmRlZCA/IGxvY2FsZS5leHBhbmRlZCA6IGxvY2FsZS5mb2xkZWR9Lz4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDxDZWxsQ29tcG9uZW50IHsuLi50aGlzLnByb3BzfSBpbm5lclN0eWxlPXtmaXJzdENlbGxTdHlsZX0+XG4gICAgICAgICAgICB7dHJlZUFycm93Tm9kZX1cbiAgICAgICAgPC9DZWxsQ29tcG9uZW50Pik7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL3RyZWUvY2VsbC5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgSGVhZGVyQ29tcG9uZW50IGZyb20gJy4vZml4ZWQvaGVhZGVyJztcbmltcG9ydCBCb2R5Q29tcG9uZW50IGZyb20gJy4vZml4ZWQvYm9keSc7XG5pbXBvcnQgV3JhcHBlckNvbXBvbmVudCBmcm9tICcuL2ZpeGVkL3dyYXBwZXInO1xuaW1wb3J0IHtzdGF0aWNzfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaXhlZChCYXNlQ29tcG9uZW50KSB7XG4gICAgLyoqIFRhYmxlICovXG4gICAgY2xhc3MgRml4ZWRUYWJsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgICAgIHN0YXRpYyBGaXhlZEhlYWRlciA9IEhlYWRlckNvbXBvbmVudDtcbiAgICAgICAgc3RhdGljIEZpeGVkQm9keSA9IEJvZHlDb21wb25lbnQ7XG4gICAgICAgIHN0YXRpYyBGaXhlZFdyYXBwZXIgPSBXcmFwcGVyQ29tcG9uZW50O1xuICAgICAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICog5piv5ZCm5YW35pyJ6KGo5aS0XG4gICAgICAgICAgICAgICovXG4gICAgICAgICAgICBoYXNIZWFkZXI6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICog6KGo5aS05piv5ZCm5Zu65a6a77yM6K+l5bGe5oCn6YWN5ZCIbWF4Qm9keUhlaWdodOS9v+eUqO+8jOW9k+WGheWuueWMuuWfn+eahOmrmOW6pui2hei/h21heEJvZHlIZWlnaHTnmoTml7blgJnvvIzlnKjlhoXlrrnljLrln5/kvJrlh7rnjrDmu5rliqjmnaFcbiAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZpeGVkSGVhZGVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5pyA5aSn5YaF5a655Yy65Z+f55qE6auY5bqmLOWcqGBmaXhlZEhlYWRlcmDkuLpgdHJ1ZWDnmoTml7blgJks6LaF6L+H6L+Z5Liq6auY5bqm5Lya5Ye6546w5rua5Yqo5p2hXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG1heEJvZHlIZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgICAgICAgICAgIC4uLkJhc2VDb21wb25lbnQucHJvcFR5cGVzXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAgICAgLi4uQmFzZUNvbXBvbmVudC5kZWZhdWx0UHJvcHMsXG4gICAgICAgICAgICBoYXNIZWFkZXI6IHRydWUsXG4gICAgICAgICAgICBmaXhlZEhlYWRlcjogZmFsc2UsXG4gICAgICAgICAgICBtYXhCb2R5SGVpZ2h0OiAyMDAsXG4gICAgICAgICAgICBjb21wb25lbnRzOiB7fSxcbiAgICAgICAgICAgIHJlZnM6IHt9LFxuICAgICAgICAgICAgcHJlZml4OiAnbmV4dC0nXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0aWMgY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gICAgICAgICAgICBmaXhlZEhlYWRlcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgICAgICBtYXhCb2R5SGVpZ2h0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gICAgICAgICAgICBvbkJvZHlTY3JvbGw6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAgICAgZ2V0Tm9kZTogUHJvcFR5cGVzLmZ1bmNcbiAgICAgICAgfVxuXG4gICAgICAgIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZml4ZWRIZWFkZXI6IHRoaXMucHJvcHMuZml4ZWRIZWFkZXIsXG4gICAgICAgICAgICAgICAgbWF4Qm9keUhlaWdodDogdGhpcy5wcm9wcy5tYXhCb2R5SGVpZ2h0LFxuICAgICAgICAgICAgICAgIG9uQm9keVNjcm9sbDogdGhpcy5vbkJvZHlTY3JvbGwsXG4gICAgICAgICAgICAgICAgZ2V0Tm9kZTogdGhpcy5nZXROb2RlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgICAgICB0aGlzLmFkanVzdEZpeGVkSGVhZGVyU2l6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RGaXhlZEhlYWRlclNpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkanVzdEZpeGVkSGVhZGVyU2l6ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaGFzSGVhZGVyLCBmaXhlZEhlYWRlciwgbWF4Qm9keUhlaWdodCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChoYXNIZWFkZXIgJiYgZml4ZWRIZWFkZXIgJiYgIXRoaXMucHJvcHMubG9ja1R5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ib2R5Tm9kZS5zY3JvbGxIZWlnaHQgPD0gbWF4Qm9keUhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBkb20uc2V0U3R5bGUodGhpcy5oZWFkZXJOb2RlLCAncGFkZGluZ1JpZ2h0JywgMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tLnNldFN0eWxlKHRoaXMuaGVhZGVyTm9kZSwgJ3BhZGRpbmdSaWdodCcsIGRvbS5zY3JvbGxiYXIoKS53aWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2V0Tm9kZSA9ICh0eXBlLCBub2RlLCBsb2NrVHlwZSkgPT4ge1xuICAgICAgICAgICAgbG9ja1R5cGUgPSBsb2NrVHlwZSA/IGxvY2tUeXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbG9ja1R5cGUuc3Vic3RyKDEpIDogJyc7XG4gICAgICAgICAgICB0aGlzW2Ake3R5cGV9JHtsb2NrVHlwZX1Ob2RlYF0gPSBub2RlO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdoZWFkZXInICYmICFsb2NrVHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJIZWFkZXJOb2RlID0gdGhpcy5oZWFkZXJOb2RlLnF1ZXJ5U2VsZWN0b3IoJ2RpdicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb25Cb2R5U2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUbyh0aGlzLmJvZHlOb2RlLnNjcm9sbExlZnQsIHRoaXMuYm9keU5vZGUuc2Nyb2xsVG9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjcm9sbFRvKHgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlubmVySGVhZGVyTm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJIZWFkZXJOb2RlLnNjcm9sbExlZnQgPSB4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyKCkge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIHByZWZlci1jb25zdCAqL1xuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50cywgY2xhc3NOYW1lLCBwcmVmaXgsIGZpeGVkSGVhZGVyLCBtYXhCb2R5SGVpZ2h0LCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAoZml4ZWRIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzID0gey4uLmNvbXBvbmVudHN9O1xuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50cy5IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5IZWFkZXIgPSBIZWFkZXJDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50cy5Cb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuQm9keSA9IEJvZHlDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50cy5XcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuV3JhcHBlciA9IFdyYXBwZXJDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4fXRhYmxlLWZpeGVkYF06IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFtjbGFzc05hbWVdOiBjbGFzc05hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoPEJhc2VDb21wb25lbnQgIHsuLi5vdGhlcnN9IGNvbXBvbmVudHM9e2NvbXBvbmVudHN9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBwcmVmaXg9e3ByZWZpeH0gLz4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpY3MoRml4ZWRUYWJsZSwgQmFzZUNvbXBvbmVudCk7XG4gICAgcmV0dXJuIEZpeGVkVGFibGU7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvZml4ZWQuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBDaGVja2JveCBmcm9tICcuLi9jaGVja2JveCc7XG5pbXBvcnQgUmFkaW8gZnJvbSAnLi4vcmFkaW8nO1xuaW1wb3J0IHsgZnVuYywgbG9nIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgemhDTiBmcm9tICcuLi9sb2NhbGUvemgtY24nO1xuaW1wb3J0IFNlbGVjdGlvblJvdyBmcm9tICcuL3NlbGVjdGlvbi9yb3cnO1xuaW1wb3J0IENvbCBmcm9tICcuL2NvbHVtbic7XG5pbXBvcnQgeyBzdGF0aWNzIH0gZnJvbSAnLi91dGlsJztcblxuY29uc3QgeyBtYWtlQ2hhaW4gfSA9IGZ1bmM7XG5cbmNvbnN0IHVuaXF1ZSA9IChhcnIsIGtleSA9ICd0aGlzJykgPT4ge1xuICAgIGNvbnN0IHRlbXAgPSB7fSwgcmV0ID0gW107XG4gICAgYXJyLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgaWYgKGtleSA9PT0gJ3RoaXMnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGl0ZW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGl0ZW1ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRlbXBbdmFsdWVdKSB7XG4gICAgICAgICAgICByZXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIHRlbXBbdmFsdWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZWxlY3Rpb24oQmFzZUNvbXBvbmVudCkge1xuICAgIC8qKiBUYWJsZSAqL1xuICAgIGNsYXNzIFNlbGVjdGlvblRhYmxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAgICAgc3RhdGljIFNlbGVjdGlvblJvdyA9IFNlbGVjdGlvblJvdztcbiAgICAgICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgKiDmmK/lkKblkK/nlKjpgInmi6nmqKHlvI9cbiAgICAgICAgICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZ2V0UHJvcHMgYEZ1bmN0aW9uKHJlY29yZCwgaW5kZXgpPT5PYmplY3RgIOiOt+WPlnNlbGVjdGlvbueahOm7mOiupOWxnuaAp1xuICAgICAgICAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvbkNoYW5nZSBgRnVuY3Rpb24oc2VsZWN0ZWRSb3dLZXlzOkFycmF5LCByZWNvcmRzOkFycmF5KWAg6YCJ5oup5pS55Y+Y55qE5pe25YCZ6Kem5Y+R55qE5LqL5Lu277yMKirms6jmhI86Kiog5YW25LitcmVjb3Jkc+WPquS8muWMheWQq+W9k+WJjWRhdGFTb3VyY2XnmoTmlbDmja7vvIzlvojlj6/og73kvJrlsI/kuo5zZWxlY3RlZFJvd0tleXPnmoTplb/luqbjgIJcbiAgICAgICAgICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb25TZWxlY3QgYEZ1bmN0aW9uKHNlbGVjdGVkOkJvb2xlYW4sIHJlY29yZDpPYmplY3QsIHJlY29yZHM6QXJyYXkpYCDnlKjmiLfmiYvliqjpgInmi6kv5Y+W5raI6YCJ5oup5p+Q6KGM55qE5Zue6LCDXG4gICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG9uU2VsZWN0QWxsIGBGdW5jdGlvbihzZWxlY3RlZDpCb29sZWFuLCByZWNvcmRzOkFycmF5KWAg55So5oi35omL5Yqo6YCJ5oupL+WPlua2iOmAieaLqeaJgOacieihjOeahOWbnuiwg1xuICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5fSBzZWxlY3RlZFJvd0tleXMg6K6+572u5LqG5q2k5bGe5oCnLOWwhnJvd1NlbGVjdGlvbuWPmOS4uuWPl+aOp+eKtuaAgSzmjqXmlLblgLzkuLror6XooYzmlbDmja7nmoRwcmltYXJ5S2V555qE5YC8XG4gICAgICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBtb2RlIOmAieaLqXNlbGVjdGlvbueahOaooeW8jywg5Y+v6YCJ5YC85Li6YHNpbmdsZWAsIGBtdWx0aXBsZWDvvIzpu5jorqTkuLpgbXVsdGlwbGVgXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgcm93U2VsZWN0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAgICAgcHJpbWFyeUtleTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgICAgIGRhdGFTb3VyY2U6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgICAgIGVudGlyZURhdGFTb3VyY2U6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgICAgIC4uLkJhc2VDb21wb25lbnQucHJvcFR5cGVzLFxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgICAgIC4uLkJhc2VDb21wb25lbnQuZGVmYXVsdFByb3BzLFxuICAgICAgICAgICAgbG9jYWxlOiB6aENOLlRhYmxlLFxuICAgICAgICAgICAgcHJpbWFyeUtleTogJ2lkJyxcbiAgICAgICAgICAgIHByZWZpeDogJ25leHQtJ1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgICAgIGxpc3RIZWFkZXI6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0aWMgY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gICAgICAgICAgICByb3dTZWxlY3Rpb246IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgICAgICBzZWxlY3RlZFJvd0tleXM6IFByb3BUeXBlcy5hcnJheVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRSb3dLZXlzOiBwcm9wcy5yb3dTZWxlY3Rpb24gJiYgJ3NlbGVjdGVkUm93S2V5cycgaW4gcHJvcHMucm93U2VsZWN0aW9uID8gKHByb3BzLnJvd1NlbGVjdGlvbi5zZWxlY3RlZFJvd0tleXMgfHwgW10pIDogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJvd1NlbGVjdGlvbjogdGhpcy5wcm9wcy5yb3dTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRSb3dLZXlzOiB0aGlzLnN0YXRlLnNlbGVjdGVkUm93S2V5c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgICAgICBpZiAobmV4dFByb3BzLnJvd1NlbGVjdGlvbiAmJiAnc2VsZWN0ZWRSb3dLZXlzJyBpbiBuZXh0UHJvcHMucm93U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRSb3dLZXlzID0gbmV4dFByb3BzLnJvd1NlbGVjdGlvbi5zZWxlY3RlZFJvd0tleXMgfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkUm93S2V5c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJlZml4LCByb3dTZWxlY3Rpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAocm93U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIChjaGlsZCwgaW5kZXgpID0+IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGluZGV4XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnVuc2hpZnQoPENvbCBrZXk9XCJzZWxlY3Rpb25cIiB0aXRsZT17dGhpcy5yZW5kZXJTZWxlY3Rpb25IZWFkZXIuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICAgICAgY2VsbD17dGhpcy5yZW5kZXJTZWxlY3Rpb25Cb2R5LmJpbmQodGhpcyl9XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoPXs1MH1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtc2VsZWN0aW9uYH0gX19ub3JtYWxpemVkIC8+KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJTZWxlY3Rpb25IZWFkZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbkNoYW5nZSA9IHRoaXMuc2VsZWN0QWxsUm93LCBhdHRycyA9IHt9LFxuICAgICAgICAgICAgICAgIHsgcm93U2VsZWN0aW9uLCBwcmltYXJ5S2V5LCBkYXRhU291cmNlLCBsb2NhbGUgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgeyBzZWxlY3RlZFJvd0tleXMgfSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICAgICAgbW9kZSA9IHJvd1NlbGVjdGlvbi5tb2RlID8gcm93U2VsZWN0aW9uLm1vZGUgOiAnbXVsdGlwbGUnO1xuXG4gICAgICAgICAgICBsZXQgY2hlY2tlZCA9ICEhc2VsZWN0ZWRSb3dLZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBpbmRldGVybWluYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZsYXREYXRhU291cmNlKGRhdGFTb3VyY2UpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigocmVjb3JkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJvd1NlbGVjdGlvbi5nZXRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIShyb3dTZWxlY3Rpb24uZ2V0UHJvcHMocmVjb3JkLCBpbmRleCkgfHwge30pLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAubWFwKHJlY29yZCA9PiByZWNvcmRbcHJpbWFyeUtleV0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goaWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRSb3dLZXlzLmluZGV4T2YoaWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF0dHJzLm9uQ2xpY2sgPSBtYWtlQ2hhaW4oKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSwgYXR0cnMub25DbGljayk7XG5cbiAgICAgICAgICAgIGlmIChjaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vZGUgPT09ICdtdWx0aXBsZScgPyA8Q2hlY2tib3ggaW5kZXRlcm1pbmF0ZT17aW5kZXRlcm1pbmF0ZX0gYXJpYS1sYWJlbD17bG9jYWxlLnNlbGVjdEFsbH0gY2hlY2tlZD17Y2hlY2tlZH0gb25DaGFuZ2U9e29uQ2hhbmdlfSB7Li4uYXR0cnN9IC8+IDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlclNlbGVjdGlvbkJvZHkgPSAodmFsdWUsIGluZGV4LCByZWNvcmQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcm93U2VsZWN0aW9uLCBwcmltYXJ5S2V5IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgY29uc3QgeyBzZWxlY3RlZFJvd0tleXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBtb2RlID0gcm93U2VsZWN0aW9uLm1vZGUgPyByb3dTZWxlY3Rpb24ubW9kZSA6ICdtdWx0aXBsZSc7XG4gICAgICAgICAgICBjb25zdCBjaGVja2VkID0gc2VsZWN0ZWRSb3dLZXlzLmluZGV4T2YocmVjb3JkW3ByaW1hcnlLZXldKSA+IC0xO1xuICAgICAgICAgICAgY29uc3Qgb25DaGFuZ2UgPSB0aGlzLnNlbGVjdE9uZVJvdy5iaW5kKHRoaXMsIGluZGV4LCByZWNvcmQpO1xuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSByb3dTZWxlY3Rpb24uZ2V0UHJvcHMgPyAocm93U2VsZWN0aW9uLmdldFByb3BzKHJlY29yZCwgaW5kZXgpIHx8IHt9KSA6IHt9O1xuXG4gICAgICAgICAgICBhdHRycy5vbkNsaWNrID0gbWFrZUNoYWluKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0sIGF0dHJzLm9uQ2xpY2spO1xuICAgICAgICAgICAgcmV0dXJuIG1vZGUgPT09ICdtdWx0aXBsZScgPyA8Q2hlY2tib3ggY2hlY2tlZD17Y2hlY2tlZH0gb25DaGFuZ2U9e29uQ2hhbmdlfSB7Li4uYXR0cnN9IC8+IDpcbiAgICAgICAgICAgICAgICA8UmFkaW8gY2hlY2tlZD17Y2hlY2tlZH0gb25DaGFuZ2U9e29uQ2hhbmdlfSB7Li4uYXR0cnN9IC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZWN0QWxsUm93ID0gKGNoZWNrZWQsIGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IFsuLi50aGlzLnN0YXRlLnNlbGVjdGVkUm93S2V5c10sXG4gICAgICAgICAgICAgICAgeyByb3dTZWxlY3Rpb24sIHByaW1hcnlLZXksIGRhdGFTb3VyY2UsIGVudGlyZURhdGFTb3VyY2UgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgeyBzZWxlY3RlZFJvd0tleXMgfSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICAgICAgZ2V0UHJvcHMgPSByb3dTZWxlY3Rpb24uZ2V0UHJvcHM7XG4gICAgICAgICAgICBsZXQgYXR0cnMgPSB7fSwgcmVjb3JkcyA9IFtdO1xuXG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBlbnRpcmVEYXRhU291cmNlID8gZW50aXJlRGF0YVNvdXJjZSA6IGRhdGFTb3VyY2U7XG5cbiAgICAgICAgICAgIHRoaXMuZmxhdERhdGFTb3VyY2Uoc291cmNlKS5mb3JFYWNoKChyZWNvcmQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSByZWNvcmRbcHJpbWFyeUtleV07XG4gICAgICAgICAgICAgICAgaWYgKGdldFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzID0gZ2V0UHJvcHMocmVjb3JkLCBpbmRleCkgfHwge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIOWPjemAieWSjOWFqOmAieeahOaXtuWAmeS4jeimgeS4ouW8g+emgeeUqOmhueeahOmAieS4reeKtuaAgVxuICAgICAgICAgICAgICAgIGlmIChjaGVja2VkICYmICghYXR0cnMuZGlzYWJsZWQgfHwgc2VsZWN0ZWRSb3dLZXlzLmluZGV4T2YoaWQpID4gLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRycy5kaXNhYmxlZCAmJiBzZWxlY3RlZFJvd0tleXMuaW5kZXhPZihpZCkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZHMucHVzaChyZWNvcmQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSByZXQuaW5kZXhPZihpZCk7XG4gICAgICAgICAgICAgICAgICAgIGkgPiAtMSAmJiByZXQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZWNvcmRzID0gdW5pcXVlKHJlY29yZHMsIHByaW1hcnlLZXkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByb3dTZWxlY3Rpb24ub25TZWxlY3RBbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByb3dTZWxlY3Rpb24ub25TZWxlY3RBbGwoY2hlY2tlZCwgcmVjb3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJTZWxlY3Rpb24ocm93U2VsZWN0aW9uLCB1bmlxdWUocmV0KSwgcmVjb3Jkcyk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZWN0T25lUm93KGluZGV4LCByZWNvcmQsIGNoZWNrZWQsIGUpIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZFJvd0tleXMgPSBbLi4udGhpcy5zdGF0ZS5zZWxlY3RlZFJvd0tleXNdLCBpO1xuICAgICAgICAgICAgY29uc3QgeyBwcmltYXJ5S2V5LCByb3dTZWxlY3Rpb24sIGRhdGFTb3VyY2UgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgbW9kZSA9IHJvd1NlbGVjdGlvbi5tb2RlID8gcm93U2VsZWN0aW9uLm1vZGUgOiAnbXVsdGlwbGUnLFxuICAgICAgICAgICAgICAgIGlkID0gcmVjb3JkW3ByaW1hcnlLZXldO1xuICAgICAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuaW5nKGBDYW4ndCBnZXQgdmFsdWUgZnJvbSByZWNvcmQgdXNpbmcgZ2l2ZW4gJHtwcmltYXJ5S2V5fSBhcyBwcmltYXJ5S2V5LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdtdWx0aXBsZScpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd0tleXMucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IHNlbGVjdGVkUm93S2V5cy5pbmRleE9mKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRSb3dLZXlzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd0tleXMgPSBbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVjb3JkcyA9IHVuaXF1ZShkYXRhU291cmNlLmZpbHRlcihpdGVtID0+IHNlbGVjdGVkUm93S2V5cy5pbmRleE9mKGl0ZW1bcHJpbWFyeUtleV0pID4gLTEpLCBwcmltYXJ5S2V5KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygcm93U2VsZWN0aW9uLm9uU2VsZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcm93U2VsZWN0aW9uLm9uU2VsZWN0KGNoZWNrZWQsIHJlY29yZCwgcmVjb3Jkcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlclNlbGVjdGlvbihyb3dTZWxlY3Rpb24sIHNlbGVjdGVkUm93S2V5cywgcmVjb3Jkcyk7XG5cbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJpZ2dlclNlbGVjdGlvbihyb3dTZWxlY3Rpb24sIHNlbGVjdGVkUm93S2V5cywgcmVjb3Jkcykge1xuICAgICAgICAgICAgaWYgKCEoJ3NlbGVjdGVkUm93S2V5cycgaW4gcm93U2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd0tleXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygcm93U2VsZWN0aW9uLm9uQ2hhbmdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcm93U2VsZWN0aW9uLm9uQ2hhbmdlKHNlbGVjdGVkUm93S2V5cywgcmVjb3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmbGF0RGF0YVNvdXJjZShkYXRhU291cmNlKSB7XG4gICAgICAgICAgICBsZXQgcmV0ID0gZGF0YVNvdXJjZTtcbiAgICAgICAgICAgIGNvbnN0IHsgbGlzdEhlYWRlciB9ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICAgICAgICBpZiAobGlzdEhlYWRlcikge1xuICAgICAgICAgICAgICAgIHJldCA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaGFzQ2hpbGRyZW5TZWxlY3Rpb24sIGhhc1NlbGVjdGlvbiB9ID0gbGlzdEhlYWRlcjtcbiAgICAgICAgICAgICAgICBkYXRhU291cmNlLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gaXRlbS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c6ZyA6KaB5riy5p+Tc2VsZWN0aW9u5omN5bCG6L+Z5p2h6K6w5b2V5o+S5YWl5YiwZGF0YVNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAvLyDmiJbogIXmsqHmnInlranlrZDoioLngrlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1NlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuICYmIGhhc0NoaWxkcmVuU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCAqL1xuICAgICAgICAgICAgbGV0IHsgcm93U2VsZWN0aW9uLCBjb21wb25lbnRzLCBjaGlsZHJlbiwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgICAgICBpZiAocm93U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzID0geyAuLi5jb21wb25lbnRzIH07XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5Sb3cgPSBjb21wb25lbnRzLlJvdyB8fCBTZWxlY3Rpb25Sb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDxCYXNlQ29tcG9uZW50IHsuLi5vdGhlcnN9IGNvbXBvbmVudHM9e2NvbXBvbmVudHN9PlxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgIDwvQmFzZUNvbXBvbmVudD4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpY3MoU2VsZWN0aW9uVGFibGUsIEJhc2VDb21wb25lbnQpO1xuICAgIHJldHVybiBTZWxlY3Rpb25UYWJsZTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9zZWxlY3Rpb24uanN4IiwiaW1wb3J0IFJlYWN0LCB7IENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi4vaWNvbic7XG5pbXBvcnQgeyBLRVlDT0RFIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgUm93Q29tcG9uZW50IGZyb20gJy4vZXhwYW5kZWQvcm93JztcbmltcG9ydCBDb2wgZnJvbSAnLi9jb2x1bW4nO1xuaW1wb3J0IHsgc3RhdGljcyB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4cGFuZGVkKEJhc2VDb21wb25lbnQpIHtcbiAgICAvKiogVGFibGUgKi9cbiAgICBjbGFzcyBFeHBhbmRlZFRhYmxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAgICAgc3RhdGljIEV4cGFuZGVkUm93ID0gUm93Q29tcG9uZW50O1xuICAgICAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDpop3lpJbmuLLmn5PooYznmoTmuLLmn5Plh73mlbBcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmQg6K+l6KGM5omA5a+55bqU55qE5pWw5o2uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXgg6K+l6KGM5omA5a+55bqU55qE5bqP5YiXXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZXhwYW5kZWRSb3dSZW5kZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDpop3lpJbmuLLmn5PooYznmoTnvKnov5tcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZXhwYW5kZWRSb3dJbmRlbnQ6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog6buY6K6k5oOF5Ya15LiL5bGV5byA55qE5riy5p+T6KGM5oiW6ICFVHJlZSwg5Lyg5YWl5q2k5bGe5oCn5Li65Y+X5o6n54q25oCBXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9wZW5Sb3dLZXlzOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOaYr+WQpuaYvuekuueCueWHu+WxleW8gOmineWklua4suafk+ihjOeahCvlj7fmjInpkq5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaGFzRXhwYW5kZWRSb3dDdHJsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog6K6+572u6aKd5aSW5riy5p+T6KGM55qE5bGe5oCnXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldEV4cGFuZGVkQ29sUHJvcHM6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDlnKjpop3lpJbmuLLmn5PooYzmiJbogIVUcmVl5bGV5byA5oiW6ICF5pS26LW355qE5pe25YCZ6Kem5Y+R55qE5LqL5Lu2XG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBvcGVuUm93S2V5cyDlsZXlvIDnmoTmuLLmn5PooYznmoRrZXlcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjdXJyZW50Um93S2V5IOW9k+WJjeeCueWHu+eahOa4suafk+ihjOeahGtleVxuICAgICAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBleHBhbmRlZCDlvZPliY3ngrnlh7vmmK/lsZXlvIDov5jmmK/mlLbotbdcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdXJyZW50UmVjb3JkIOW9k+WJjeeCueWHu+mineWklua4suafk+ihjOeahOiusOW9lVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvblJvd09wZW46IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDngrnlh7vpop3lpJbmuLLmn5PooYzop6blj5HnmoTkuovku7ZcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmQg6K+l6KGM5omA5a+55bqU55qE5pWw5o2uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXgg6K+l6KGM5omA5a+55bqU55qE5bqP5YiXXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIERPTeS6i+S7tuWvueixoVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvbkV4cGFuZGVkUm93Q2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAgICAgbG9jYWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICAgICAgLi4uQmFzZUNvbXBvbmVudC5wcm9wVHlwZXNcbiAgICAgICAgfTtcblxuICAgICAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAgICAgLi4uQmFzZUNvbXBvbmVudC5kZWZhdWx0UHJvcHMsXG4gICAgICAgICAgICBnZXRFeHBhbmRlZENvbFByb3BzOiBub29wLFxuICAgICAgICAgICAgb25Sb3dPcGVuOiBub29wLFxuICAgICAgICAgICAgaGFzRXhwYW5kZWRSb3dDdHJsOiB0cnVlLFxuICAgICAgICAgICAgY29tcG9uZW50czoge30sXG4gICAgICAgICAgICBleHBhbmRlZFJvd0luZGVudDogWzEsIDBdLFxuICAgICAgICAgICAgcHJlZml4OiAnbmV4dC0nXG4gICAgICAgIH07XG5cbiAgICAgICAgc3RhdGljIGNoaWxkQ29udGV4dFR5cGVzID0ge1xuICAgICAgICAgICAgb3BlblJvd0tleXM6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgICAgIGV4cGFuZGVkUm93UmVuZGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgICAgIGV4cGFuZGVkUm93SW5kZW50OiBQcm9wVHlwZXMuYXJyYXlcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgb3BlblJvd0tleXM6IHRoaXMucHJvcHMub3BlblJvd0tleXMgfHwgW11cbiAgICAgICAgfTtcblxuICAgICAgICBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9wZW5Sb3dLZXlzOiB0aGlzLnN0YXRlLm9wZW5Sb3dLZXlzLFxuICAgICAgICAgICAgICAgIGV4cGFuZGVkUm93UmVuZGVyOiB0aGlzLnByb3BzLmV4cGFuZGVkUm93UmVuZGVyLFxuICAgICAgICAgICAgICAgIGV4cGFuZGVkUm93SW5kZW50OiB0aGlzLnByb3BzLmV4cGFuZGVkUm93SW5kZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIGlmICgnb3BlblJvd0tleXMnIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgb3BlblJvd0tleXMgfSA9IG5leHRQcm9wcztcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlblJvd0tleXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGFuZGVkS2V5ZG93biA9ICh2YWx1ZSwgcmVjb3JkLCBpbmRleCwgZSkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERS5FTlRFUikge1xuICAgICAgICAgICAgICAgIHRoaXMub25FeHBhbmRlZENsaWNrKHZhbHVlLCByZWNvcmQsIGluZGV4LCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlckV4cGFuZGVkQ2VsbCA9ICh2YWx1ZSwgaW5kZXgsIHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBnZXRFeHBhbmRlZENvbFByb3BzLCBwcmVmaXgsIGxvY2FsZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGNvbnN0IHsgb3BlblJvd0tleXMgfSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICAgICAgeyBwcmltYXJ5S2V5IH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGhhc0V4cGFuZGVkID0gb3BlblJvd0tleXMuaW5kZXhPZihyZWNvcmRbcHJpbWFyeUtleV0pID4gLTEsXG4gICAgICAgICAgICAgICAgc3dpdGNoTm9kZSA9IGhhc0V4cGFuZGVkID9cbiAgICAgICAgICAgICAgICAgICAgPEljb24gdHlwZT1cIm1pbnVzXCIgc2l6ZT1cInhzXCIgLz4gOiA8SWNvbiB0eXBlPVwiYWRkXCIgc2l6ZT1cInhzXCIgLz4sXG5cbiAgICAgICAgICAgICAgICBhdHRycyA9IGdldEV4cGFuZGVkQ29sUHJvcHMocmVjb3JkLCBpbmRleCkgfHwge307XG4gICAgICAgICAgICBjb25zdCBjbHMgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4fXRhYmxlLWV4cGFuZGVkLWN0cmxgXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogYXR0cnMuZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgW2F0dHJzLmNsYXNzTmFtZV06IGF0dHJzLmNsYXNzTmFtZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghYXR0cnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBhdHRycy5vbkNsaWNrID0gdGhpcy5vbkV4cGFuZGVkQ2xpY2suYmluZCh0aGlzLCB2YWx1ZSwgcmVjb3JkLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxzcGFuIHsuLi5hdHRyc31cbiAgICAgICAgICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgIHRhYkluZGV4PVwiMFwiXG4gICAgICAgICAgICAgICAgICAgIG9uS2V5RG93bj17dGhpcy5leHBhbmRlZEtleWRvd24uYmluZCh0aGlzLCB2YWx1ZSwgcmVjb3JkLCBpbmRleCl9XG4gICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e2hhc0V4cGFuZGVkID8gbG9jYWxlLmV4cGFuZGVkIDogbG9jYWxlLmZvbGRlZH1cbiAgICAgICAgICAgICAgICAgICAgYXJpYS1leHBhbmRlZD17aGFzRXhwYW5kZWR9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xzfT5cbiAgICAgICAgICAgICAgICAgICAge3N3aXRjaE5vZGV9XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9uRXhwYW5kZWRDbGljayh2YWx1ZSwgcmVjb3JkLCBpLCBlKSB7XG4gICAgICAgICAgICBjb25zdCBvcGVuUm93S2V5cyA9IFsuLi50aGlzLnN0YXRlLm9wZW5Sb3dLZXlzXSxcbiAgICAgICAgICAgICAgICB7IHByaW1hcnlLZXkgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaWQgPSByZWNvcmRbcHJpbWFyeUtleV0sXG4gICAgICAgICAgICAgICAgaW5kZXggPSBvcGVuUm93S2V5cy5pbmRleE9mKGlkKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgb3BlblJvd0tleXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3BlblJvd0tleXMucHVzaChpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISgnb3BlblJvd0tleXMnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5Sb3dLZXlzOiBvcGVuUm93S2V5c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblJvd09wZW4ob3BlblJvd0tleXMsIGlkLCBpbmRleCA9PT0gLTEsIHJlY29yZCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHRvQXJyYXlDaGlsZHJlbiA9IENoaWxkcmVuLm1hcChjaGlsZHJlbiwgKGNoaWxkLCBpbmRleCkgPT4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgICAgICAgICAga2V5OiBpbmRleFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY29uc3Qge3ByZWZpeH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgdG9BcnJheUNoaWxkcmVuLnVuc2hpZnQoPENvbCB0aXRsZT1cIlwiIGtleT1cImV4cGFuZGVkXCIgY2VsbD17dGhpcy5yZW5kZXJFeHBhbmRlZENlbGwuYmluZCh0aGlzKX0gd2lkdGg9ezUwfSBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1leHBhbmRlZGB9IF9fbm9ybWFsaXplZC8+KTtcbiAgICAgICAgICAgIHJldHVybiB0b0FycmF5Q2hpbGRyZW47XG4gICAgICAgIH1cblxuICAgICAgICBub3JtYWxpemVEYXRhU291cmNlKGRzKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgICAgICAgIGRzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUNvcHkgPSB7IC4uLml0ZW0gfTtcbiAgICAgICAgICAgICAgICBpdGVtQ29weS5fX2V4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXQucHVzaChpdGVtLCBpdGVtQ29weSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycywgcHJlZmVyLWNvbnN0ICovXG4gICAgICAgICAgICBsZXQgeyBjb21wb25lbnRzLCBvcGVuUm93S2V5cywgZXhwYW5kZWRSb3dSZW5kZXIsIGhhc0V4cGFuZGVkUm93Q3RybCwgY2hpbGRyZW4sIGRhdGFTb3VyY2UsIGdldEV4cGFuZGVkQ29sUHJvcHMsIGV4cGFuZGVkUm93SW5kZW50LCBvblJvd09wZW4sIG9uRXhwYW5kZWRSb3dDbGljaywgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKGV4cGFuZGVkUm93UmVuZGVyICYmICFjb21wb25lbnRzLlJvdykge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMgPSB7Li4uY29tcG9uZW50c307XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5Sb3cgPSBSb3dDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgZGF0YVNvdXJjZSA9IHRoaXMubm9ybWFsaXplRGF0YVNvdXJjZShkYXRhU291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHBhbmRlZFJvd1JlbmRlciAmJiBoYXNFeHBhbmRlZFJvd0N0cmwpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKDxCYXNlQ29tcG9uZW50IHsuLi5vdGhlcnN9IGRhdGFTb3VyY2U9e2RhdGFTb3VyY2V9ICBjb21wb25lbnRzPXtjb21wb25lbnRzfT5cbiAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICA8L0Jhc2VDb21wb25lbnQ+KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWNzKEV4cGFuZGVkVGFibGUsIEJhc2VDb21wb25lbnQpO1xuICAgIHJldHVybiBFeHBhbmRlZFRhYmxlO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2V4cGFuZGVkLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmaW5kRE9NTm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgVmlydHVhbEJvZHkgZnJvbSAnLi92aXJ0dWFsL2JvZHknO1xuaW1wb3J0IHsgc3RhdGljcyB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2aXJ0dWFsKEJhc2VDb21wb25lbnQpIHtcbiAgICBjbGFzcyBWaXJ0dWFsVGFibGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgICAgICBzdGF0aWMgVmlydHVhbEJvZHkgPSBWaXJ0dWFsQm9keTtcbiAgICAgICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5piv5ZCm5byA5ZCv6Jma5ouf5rua5YqoXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHVzZVZpcnR1YWw6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDorr7nva7ooYzpq5hcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcm93SGVpZ2h0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgICAgICAgICAgbWF4Qm9keUhlaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgICAgICAgICAgcHJpbWFyeUtleTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgICAgIGRhdGFTb3VyY2U6IFByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5Zyo5YaF5a655Yy65Z+f5rua5Yqo55qE5pe25YCZ6Kem5Y+R55qE5Ye95pWwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9uQm9keVNjcm9sbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgICAgICAuLi5CYXNlQ29tcG9uZW50LnByb3BUeXBlcyxcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgICAgICAuLi5CYXNlQ29tcG9uZW50LmRlZmF1bHRQcm9wcyxcbiAgICAgICAgICAgIHByaW1hcnlLZXk6ICdpZCcsXG4gICAgICAgICAgICByb3dIZWlnaHQ6IG5vb3AsXG4gICAgICAgICAgICBtYXhCb2R5SGVpZ2h0OiAyMDAsXG4gICAgICAgICAgICBjb21wb25lbnRzOiB7fSxcbiAgICAgICAgICAgIHByZWZpeDogJ25leHQtJyxcbiAgICAgICAgICAgIG9uQm9keVNjcm9sbDogbm9vcFxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGljIGNoaWxkQ29udGV4dFR5cGVzID0ge1xuICAgICAgICAgICAgb25WaXJ0dWFsU2Nyb2xsOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgICAgIGJvZHlIZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgICAgICBpbm5lclRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgICAgIGdldEJvZHlOb2RlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgICAgIGdldFRhYmxlSW5zdGFuY2VGb3JWaXJ0dWFsOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgICAgIHJvd1NlbGVjdGlvbjogUHJvcFR5cGVzLm9iamVjdFxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICByb3dIZWlnaHQ6IHRoaXMucHJvcHMucm93SGVpZ2h0LFxuICAgICAgICAgICAgc2Nyb2xsVG9Sb3c6IHRoaXMucHJvcHMuc2Nyb2xsVG9Sb3csXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMucHJvcHMubWF4Qm9keUhlaWdodFxuICAgICAgICB9XG5cbiAgICAgICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvblZpcnR1YWxTY3JvbGw6IHRoaXMub25TY3JvbGwsXG4gICAgICAgICAgICAgICAgYm9keUhlaWdodDogdGhpcy5jb21wdXRlQm9keUhlaWdodCgpLFxuICAgICAgICAgICAgICAgIGlubmVyVG9wOiB0aGlzLmNvbXB1dGVJbm5lclRvcCgpLFxuICAgICAgICAgICAgICAgIGdldEJvZHlOb2RlOiB0aGlzLmdldEJvZHlOb2RlLFxuICAgICAgICAgICAgICAgIGdldFRhYmxlSW5zdGFuY2VGb3JWaXJ0dWFsOiB0aGlzLmdldFRhYmxlSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgcm93U2VsZWN0aW9uOiB0aGlzLnJvd1NlbGVjdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlVmlydHVhbCwgZGF0YVNvdXJjZSB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICAgICAgdGhpcy5oYXNWaXJ0dWFsRGF0YSA9ICB1c2VWaXJ0dWFsICYmIGRhdGFTb3VyY2UgJiYgZGF0YVNvdXJjZS5sZW5ndGggPiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1ZpcnR1YWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0U2Nyb2xsVG9wID0gdGhpcy5ib2R5Tm9kZS5zY3JvbGxUb3A7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYWRqdXN0U2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFNpemUoKTtcbiAgICAgICAgICAgIHRoaXMucmVDb21wdXRlU2l6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlVmlydHVhbCwgZGF0YVNvdXJjZSB9ID0gbmV4dFByb3BzO1xuXG4gICAgICAgICAgICB0aGlzLmhhc1ZpcnR1YWxEYXRhID0gIHVzZVZpcnR1YWwgJiYgZGF0YVNvdXJjZSAmJiBkYXRhU291cmNlLmxlbmd0aCA+IDA7XG5cbiAgICAgICAgICAgIGlmICgnbWF4Qm9keUhlaWdodCcgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuaGVpZ2h0ICE9PSBuZXh0UHJvcHMubWF4Qm9keUhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogbmV4dFByb3BzLm1heEJvZHlIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoJ3Njcm9sbFRvUm93JyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9Sb3c6IG5leHRQcm9wcy5zY3JvbGxUb1Jvd1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5yb3dIZWlnaHQgJiYgJ3Jvd0hlaWdodCcgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5nZXRSb3dOb2RlKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93Q2xpZW50SGVpZ2h0ID0gcm93ICYmIHJvdy5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHJvd0NsaWVudEhlaWdodCAmJiByb3dDbGllbnRIZWlnaHQgIT09IHRoaXMuc3RhdGUucm93SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93SGVpZ2h0OiByb3dDbGllbnRIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFNjcm9sbFRvcCgpO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RTaXplKCk7XG4gICAgICAgICAgICB0aGlzLnJlQ29tcHV0ZVNpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlQ29tcHV0ZVNpemUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJvd0hlaWdodCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygcm93SGVpZ2h0ID09PSAnZnVuY3Rpb24nICYmIHRoaXMuaGFzVmlydHVhbERhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3cgPSB0aGlzLmdldFJvd05vZGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByb3dDbGllbnRIZWlnaHQgPSByb3cgJiYgcm93LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAocm93Q2xpZW50SGVpZ2h0ICE9PSB0aGlzLnN0YXRlLnJvd0hlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0hlaWdodDogcm93Q2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXB1dGVCb2R5SGVpZ2h0KCkge1xuICAgICAgICAgICAgY29uc3QgeyByb3dIZWlnaHQgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGFTb3VyY2UgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJvd0hlaWdodCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGFTb3VyY2UubGVuZ3RoICogcm93SGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcHV0ZUlubmVyVG9wKCkge1xuICAgICAgICAgICAgY29uc3QgeyByb3dIZWlnaHQgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJvd0hlaWdodCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnN0YXJ0ICogcm93SGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFZpc2libGVSYW5nZShFeHBlY3RTdGFydCkge1xuICAgICAgICAgICAgY29uc3QgeyBoZWlnaHQsIHJvd0hlaWdodCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IHRoaXMucHJvcHMuZGF0YVNvdXJjZS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGxldCBlbmQsIHZpc2libGVDb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByb3dIZWlnaHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyB0cnkgZ2V0IGNlbGwgaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGVuZCA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZpc2libGVDb3VudCA9IHBhcnNlSW50KGhlaWdodCAvIHJvd0hlaWdodCwgMTApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgRXhwZWN0U3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBFeHBlY3RTdGFydCA8IGxlbiA/IEV4cGVjdFN0YXJ0IDogMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbmQgPSBNYXRoLm1pbigrc3RhcnQgKyAxICsgdmlzaWJsZUNvdW50ICsgMTAsIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZUNvdW50ID0gdmlzaWJsZUNvdW50O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBhZGp1c3RTY3JvbGxUb3AoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNWaXJ0dWFsRGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keU5vZGUuc2Nyb2xsVG9wID0gdGhpcy5sYXN0U2Nyb2xsVG9wICUgdGhpcy5zdGF0ZS5yb3dIZWlnaHQgKyB0aGlzLnN0YXRlLnJvd0hlaWdodCAqIHRoaXMuc3RhdGUuc2Nyb2xsVG9Sb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhZGp1c3RTaXplKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzVmlydHVhbERhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gdGhpcy5ib2R5Tm9kZTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aXJ0dWFsU2Nyb2xsTm9kZSA9IGJvZHkucXVlcnlTZWxlY3RvcignZGl2Jyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjbGllbnRIZWlnaHQsIGNsaWVudFdpZHRoIH0gPSBib2R5O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGVJbmMgPSB0aGlzLnRhYmxlSW5jO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlTm9kZSA9IGZpbmRET01Ob2RlKHRhYmxlSW5jKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHByZWZpeCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJOb2RlID0gdGFibGVOb2RlLnF1ZXJ5U2VsZWN0b3IoYC4ke3ByZWZpeH10YWJsZS1oZWFkZXIgdGFibGVgKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJDbGllbnRXaWR0aCA9IGhlYWRlck5vZGUgJiYgaGVhZGVyTm9kZS5jbGllbnRXaWR0aDtcblxuICAgICAgICAgICAgICAgIGlmIChjbGllbnRXaWR0aCA8IGhlYWRlckNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5zZXRTdHlsZSh2aXJ0dWFsU2Nyb2xsTm9kZSwgJ21pbi13aWR0aCcsIGhlYWRlckNsaWVudFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVmdE5vZGUgPSB0aGlzLmJvZHlMZWZ0Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmlnaHROb2RlID0gdGhpcy5ib2R5UmlnaHROb2RlO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0Tm9kZSAmJiBkb20uc2V0U3R5bGUobGVmdE5vZGUsICdtYXgtaGVpZ2h0JywgY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHROb2RlICYmIGRvbS5zZXRTdHlsZShyaWdodE5vZGUsICdtYXgtaGVpZ2h0JywgY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNTY3JvbGxiYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzU2Nyb2xsYmFyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBvblNjcm9sbCA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIOmBv+WFjeaoquWQkea7muWKqOW4puadpeeahOaAp+iDvemXrumimFxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gdGhpcy5ib2R5Tm9kZS5zY3JvbGxUb3A7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsVG9wID09PSB0aGlzLmxhc3RTY3JvbGxUb3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuY29tcHV0ZVNjcm9sbFRvUm93KHNjcm9sbFRvcCk7XG4gICAgICAgICAgICBpZiAoISgnc2Nyb2xsVG9Sb3cnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvUm93OiBzdGFydFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkJvZHlTY3JvbGwoc3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5sYXN0U2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcHV0ZVNjcm9sbFRvUm93KG9mZnNldCkge1xuICAgICAgICAgICAgY29uc3QgeyByb3dIZWlnaHQgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHBhcnNlSW50KG9mZnNldCAvIHJvd0hlaWdodCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRCb2R5Tm9kZSA9IChub2RlLCBsb2NrVHlwZSkgPT4ge1xuICAgICAgICAgICAgbG9ja1R5cGUgPSBsb2NrVHlwZSA/IGxvY2tUeXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbG9ja1R5cGUuc3Vic3RyKDEpIDogJyc7XG4gICAgICAgICAgICB0aGlzW2Bib2R5JHtsb2NrVHlwZX1Ob2RlYF0gPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0VGFibGVJbnN0YW5jZSA9ICh0eXBlLCBpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUgPyB0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zdWJzdHIoMSkgOiAnJztcbiAgICAgICAgICAgIHRoaXNbYHRhYmxlJHt0eXBlfUluY2BdID0gaW5zdGFuY2U7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRSb3dOb2RlKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIG9mIGZpbmRpbmcgYW4gdW5tb3VudGVkIGNvbXBvbmVudCBkdWUgdG8gY2FjaGVkIGRhdGFcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGNsZWFyIHJlZnMgb2YgdGhpcy50YWJsZUluYyB3aGVuIGRhdGFTb3VyY2UgQ2hhbmdlZFxuICAgICAgICAgICAgICAgIC8vIHVzZSB0cnkgY2F0Y2ggZm9yIHRlbXBvcmFyeVxuICAgICAgICAgICAgICAgIHJldHVybiBmaW5kRE9NTm9kZSh0aGlzLnRhYmxlSW5jLmdldFJvd1JlZigwKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyKCkge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIHByZWZlci1jb25zdCAqL1xuICAgICAgICAgICAgbGV0IHsgdXNlVmlydHVhbCwgY29tcG9uZW50cywgZGF0YVNvdXJjZSwgZml4ZWRIZWFkZXIsIHJvd0hlaWdodCwgc2Nyb2xsVG9Sb3csIG9uQm9keVNjcm9sbCwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgICAgICBjb25zdCBlbnRpcmVEYXRhU291cmNlID0gZGF0YVNvdXJjZTtcblxuICAgICAgICAgICAgdGhpcy5yb3dTZWxlY3Rpb24gPSB0aGlzLnByb3BzLnJvd1NlbGVjdGlvbjtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1ZpcnR1YWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cyA9IHsgLi4uY29tcG9uZW50cyB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5nZXRWaXNpYmxlUmFuZ2UodGhpcy5zdGF0ZS5zY3JvbGxUb1Jvdyk7XG4gICAgICAgICAgICAgICAgZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2Uuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudHMuQm9keSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLkJvZHkgPSBWaXJ0dWFsQm9keTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZml4ZWRIZWFkZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKDxCYXNlQ29tcG9uZW50IHsuLi5vdGhlcnN9IGRhdGFTb3VyY2U9e2RhdGFTb3VyY2V9IGVudGlyZURhdGFTb3VyY2U9e2VudGlyZURhdGFTb3VyY2V9IGNvbXBvbmVudHM9e2NvbXBvbmVudHN9IGZpeGVkSGVhZGVyPXtmaXhlZEhlYWRlcn0gLz4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpY3MoVmlydHVhbFRhYmxlLCBCYXNlQ29tcG9uZW50KTtcbiAgICByZXR1cm4gVmlydHVhbFRhYmxlO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL3ZpcnR1YWwuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZpbmRET01Ob2RlIH0gIGZyb20gICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBCb2R5Q29tcG9uZW50IGZyb20gJy4uL2Jhc2UvYm9keSc7XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3ByZWZlci1zdGF0ZWxlc3MtZnVuY3Rpb24gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpcnR1YWxCb2R5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgcHJlZml4OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNvbEdyb3VwOiBQcm9wVHlwZXMuYW55XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgbWF4Qm9keUhlaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgICAgICBvbkJvZHlTY3JvbGw6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvblZpcnR1YWxTY3JvbGw6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkxvY2tCb2R5U2Nyb2xsOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgYm9keUhlaWdodDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgaW5uZXJUb3A6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGdldE5vZGU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBnZXRCb2R5Tm9kZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGdldExvY2tOb2RlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgbG9ja1R5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2xlZnQnLCAncmlnaHQnXSlcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgYm9keU5vZGUgPSBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgICAgLy8gLy8gZm9yIGZpeGVkXG4gICAgICAgIHRoaXMuY29udGV4dC5nZXROb2RlKCdib2R5JywgYm9keU5vZGUpO1xuICAgICAgICAvLyBmb3IgdmlydHVhbFxuICAgICAgICB0aGlzLmNvbnRleHQuZ2V0Qm9keU5vZGUoYm9keU5vZGUsIHRoaXMuY29udGV4dC5sb2NrVHlwZSk7XG4gICAgICAgIC8vIGZvciBsb2NrXG4gICAgICAgIHRoaXMuY29udGV4dC5nZXRMb2NrTm9kZSgnYm9keScsIGJvZHlOb2RlLCB0aGlzLmNvbnRleHQubG9ja1R5cGUpO1xuICAgIH1cblxuICAgIHRhYmxlUmVmID0gKHRhYmxlKSA9PiB7XG4gICAgICAgIHRoaXMudGFibGVOb2RlID0gdGFibGU7XG4gICAgfVxuXG4gICAgdmlydHVhbFNjcm9sbFJlZiA9ICh2aXJ0dWFsU2Nyb2xsKSA9PiB7XG4gICAgICAgIHRoaXMudmlydHVhbFNjcm9sbE5vZGUgPSB2aXJ0dWFsU2Nyb2xsO1xuICAgIH1cblxuICAgIG9uU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAvLyBmb3IgZml4ZWRcbiAgICAgICAgdGhpcy5jb250ZXh0Lm9uQm9keVNjcm9sbCgpO1xuICAgICAgICAvLyBmb3IgbG9ja1xuICAgICAgICB0aGlzLmNvbnRleHQub25Mb2NrQm9keVNjcm9sbCgpO1xuICAgICAgICAvLyBmb3IgdmlydHVhbFxuICAgICAgICB0aGlzLmNvbnRleHQub25WaXJ0dWFsU2Nyb2xsKCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgY2xhc3NOYW1lLCBjb2xHcm91cCwgLi4ub3RoZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7bWF4Qm9keUhlaWdodCwgYm9keUhlaWdodCwgaW5uZXJUb3B9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICByZXR1cm4gKDxkaXYgc3R5bGU9e3ttYXhIZWlnaHQ6IG1heEJvZHlIZWlnaHR9fSBjbGFzc05hbWU9e2NsYXNzTmFtZX0gb25TY3JvbGw9e3RoaXMub25TY3JvbGx9PlxuICAgICAgICAgICAgPGRpdiBzdHlsZT17e2hlaWdodDogYm9keUhlaWdodCwgb3ZlcmZsb3c6ICdoaWRkZW4nLCBwb3NpdGlvbjogJ3JlbGF0aXZlJ319IHJlZj17dGhpcy52aXJ0dWFsU2Nyb2xsUmVmfT5cbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7aGVpZ2h0OiAnMTAwJScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCB0cmFuc2Zvcm06IGB0cmFuc2xhdGVZKCR7aW5uZXJUb3B9cHgpYH19PlxuICAgICAgICAgICAgICAgICAgICA8dGFibGUgcmVmPXt0aGlzLnRhYmxlUmVmfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtjb2xHcm91cH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxCb2R5Q29tcG9uZW50IHsuLi5vdGhlcnN9IHByZWZpeD17cHJlZml4fS8+XG4gICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+KTtcbiAgICB9XG59XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS92aXJ0dWFsL2JvZHkuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHNoYWxsb3dFbGVtZW50RXF1YWxzIGZyb20gJ3NoYWxsb3ctZWxlbWVudC1lcXVhbHMnO1xuaW1wb3J0IHsgZG9tLCBsb2csIG9iaiwgZXZlbnRzIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgTG9ja1JvdyBmcm9tICcuL2xvY2svcm93JztcbmltcG9ydCBMb2NrQm9keSBmcm9tICcuL2xvY2svYm9keSc7XG5pbXBvcnQgTG9ja0hlYWRlciBmcm9tICcuL2xvY2svaGVhZGVyJztcbmltcG9ydCBMb2NrV3JhcHBlciBmcm9tICcuL2ZpeGVkL3dyYXBwZXInO1xuaW1wb3J0IHsgc3RhdGljcyB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxvY2soQmFzZUNvbXBvbmVudCkge1xuICAgIC8qKiBUYWJsZSAqL1xuICAgIGNsYXNzIExvY2tUYWJsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgICAgIHN0YXRpYyBMb2NrUm93ID0gTG9ja1JvdztcbiAgICAgICAgc3RhdGljIExvY2tCb2R5ID0gTG9ja0JvZHk7XG4gICAgICAgIHN0YXRpYyBMb2NrSGVhZGVyID0gTG9ja0hlYWRlcjtcbiAgICAgICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgICAgIHNjcm9sbFRvQ29sOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDmjIflrprmu5rliqjliLDmn5DkuIDooYzvvIzku4XlnKhgdXNlVmlydHVhbGDnmoTml7blgJnnlJ/mlYhcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2Nyb2xsVG9Sb3c6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgICAgICAuLi5CYXNlQ29tcG9uZW50LnByb3BUeXBlc1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgICAgIC4uLkJhc2VDb21wb25lbnQuZGVmYXVsdFByb3BzXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0aWMgY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gICAgICAgICAgICBnZXRUYWJsZUluc3RhbmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgICAgIGdldExvY2tOb2RlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgICAgIG9uTG9ja0JvZHlTY3JvbGw6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICAgICAgb25Mb2NrQm9keVdoZWVsOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgICAgIG9uUm93TW91c2VFbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgICAgICBvblJvd01vdXNlTGVhdmU6IFByb3BUeXBlcy5mdW5jXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xuICAgICAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy5sb2NrTGVmdENoaWxkcmVuID0gW107XG4gICAgICAgICAgICB0aGlzLmxvY2tSaWdodENoaWxkcmVuID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdldFRhYmxlSW5zdGFuY2U6IHRoaXMuZ2V0VGFibGVJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBnZXRMb2NrTm9kZTogdGhpcy5nZXROb2RlLFxuICAgICAgICAgICAgICAgIG9uTG9ja0JvZHlXaGVlbDogdGhpcy5vbkxvY2tCb2R5V2hlZWwsXG4gICAgICAgICAgICAgICAgb25Mb2NrQm9keVNjcm9sbDogdGhpcy5vbkxvY2tCb2R5U2Nyb2xsLFxuICAgICAgICAgICAgICAgIG9uUm93TW91c2VFbnRlcjogdGhpcy5vblJvd01vdXNlRW50ZXIsXG4gICAgICAgICAgICAgICAgb25Sb3dNb3VzZUxlYXZlOiB0aGlzLm9uUm93TW91c2VMZWF2ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RTaXplID0gdGhpcy5hZGp1c3RTaXplLmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgIHRoaXMuYWRqdXN0U2l6ZSgpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGwoKTtcblxuICAgICAgICAgICAgZXZlbnRzLm9uKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuYWRqdXN0U2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAobmV4dFByb3BzLnB1cmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0VxdWFsID0gc2hhbGxvd0VsZW1lbnRFcXVhbHMobmV4dFByb3BzLCB0aGlzLnByb3BzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIShpc0VxdWFsICYmIG9iai5zaGFsbG93RXF1YWwobmV4dENvbnRleHQsIHRoaXMuY29udGV4dCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudFdpbGxVcGRhdGUoKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0xvY2sgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0U2l6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgICAgICBldmVudHMub2ZmKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuYWRqdXN0U2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBub3JtYWxpemVDaGlsZHJlblN0YXRlKHByb3BzKSB7XG4gICAgICAgICAgICBsZXQgeyBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgICAgICAgICAgY29uc3Qgc3BsaXRDaGlsZHJlbiA9IHRoaXMuc3BsaXRGcm9tTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgICAgICAgICAgY29uc3QgeyBsb2NrTGVmdENoaWxkcmVuLCBsb2NrUmlnaHRDaGlsZHJlbiB9ID0gc3BsaXRDaGlsZHJlbjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbG9ja0xlZnRDaGlsZHJlbixcbiAgICAgICAgICAgICAgICBsb2NrUmlnaHRDaGlsZHJlbixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogdGhpcy5tZXJnZUZyb21TcGxpdExvY2tDaGlsZHJlbihzcGxpdENoaWxkcmVuKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOWwhlJlYWN057uT5p6E5YyW5pWw5o2u5o+Q5Y+WcHJvcHPovazmjaLmiJDmlbDnu4RcbiAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxldCBpc0xvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGdldENoaWxkcmVuID0gKGNoaWxkcmVuKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICAgICAgICAgICAgQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0geyAuLi5jaGlsZC5wcm9wcyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFt0cnVlLCAnbGVmdCcsICdyaWdodCddLmluZGV4T2YocHJvcHMubG9jaykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTG9jayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoJ3dpZHRoJyBpbiBwcm9wcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLndhcm5pbmcoYFNob3VsZCBjb25maWcgd2lkdGggZm9yIGxvY2sgY29sdW1uIG5hbWVkIFsgJHtwcm9wcy5kYXRhSW5kZXh9IF0uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2gocHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSBnZXRDaGlsZHJlbihjaGlsZC5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGdldENoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIHJldC5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICAvLyDkuLroh6rlrprkuYnnmoTliJfnibnmrorlpITnkIZcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuX19ub3JtYWxpemVkICYmIGlzTG9jaykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5sb2NrID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2hpbGQuX19ub3JtYWxpemVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5faXNMb2NrID0gaXNMb2NrO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8v5LuO5pWw57uE5Lit5YiG56a75Ye6bG9ja+eahOWIl+WSjOato+W4uOeahOWIl1xuICAgICAgICBzcGxpdEZyb21Ob3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luQ2hpbGRyZW4gPSBkZWVwQ29weShjaGlsZHJlbik7XG4gICAgICAgICAgICBjb25zdCBsb2NrTGVmdENoaWxkcmVuID0gZGVlcENvcHkoY2hpbGRyZW4pO1xuICAgICAgICAgICAgY29uc3QgbG9ja1JpZ2h0Q2hpbGRyZW4gPSBkZWVwQ29weShjaGlsZHJlbik7XG4gICAgICAgICAgICBjb25zdCBsb29wID0gKGxvY2tDaGlsZHJlbiwgY29uZGl0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICAgICAgICAgICAgbG9ja0NoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gbG9vcChjaGlsZC5jaGlsZHJlbiwgY29uZGl0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yZGVyID0gY29uZGl0aW9uKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXQuZm9yRWFjaChyZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGxvY2tDaGlsZHJlbi5pbmRleE9mKHJlcyk7XG4gICAgICAgICAgICAgICAgICAgIGxvY2tDaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NrQ2hpbGRyZW47XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbG9vcChsb2NrTGVmdENoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubG9jayA9PT0gdHJ1ZSB8fCBjaGlsZC5sb2NrID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdsZWZ0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxvb3AobG9ja1JpZ2h0Q2hpbGRyZW4sIChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5sb2NrID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAncmlnaHQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbG9vcChvcmlnaW5DaGlsZHJlbiwgKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmxvY2sgIT09IHRydWUgJiYgY2hpbGQubG9jayAhPT0gJ2xlZnQnICYmIGNoaWxkLmxvY2sgIT09ICdyaWdodCc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbG9ja0xlZnRDaGlsZHJlbixcbiAgICAgICAgICAgICAgICBsb2NrUmlnaHRDaGlsZHJlbixcbiAgICAgICAgICAgICAgICBvcmlnaW5DaGlsZHJlblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8v5bCG5bem5L6n55qE6ZSB5YiX5qCR5ZKM5Lit6Ze055qE5pmu6YCa5qCR5Y+K5Y+z5L6n55qE6ZSB5YiX5qCR6L+b6KGM5ZCI5bm2XG4gICAgICAgIG1lcmdlRnJvbVNwbGl0TG9ja0NoaWxkcmVuKHNwbGl0Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbG9ja0xlZnRDaGlsZHJlbiwgbG9ja1JpZ2h0Q2hpbGRyZW4gfSA9IHNwbGl0Q2hpbGRyZW47XG4gICAgICAgICAgICBsZXQgeyBvcmlnaW5DaGlsZHJlbiB9ID0gc3BsaXRDaGlsZHJlbjtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KG9yaWdpbkNoaWxkcmVuLCBsb2NrTGVmdENoaWxkcmVuKTtcbiAgICAgICAgICAgIG9yaWdpbkNoaWxkcmVuID0gb3JpZ2luQ2hpbGRyZW4uY29uY2F0KGxvY2tSaWdodENoaWxkcmVuKTtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5DaGlsZHJlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFRhYmxlSW5zdGFuY2UgPSAodHlwZSwgaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlID8gdHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR5cGUuc3Vic3RyKDEpIDogJyc7XG4gICAgICAgICAgICB0aGlzW2B0YWJsZSR7dHlwZX1JbmNgXSA9IGluc3RhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0Tm9kZSA9ICh0eXBlLCBub2RlLCBsb2NrVHlwZSkgPT4ge1xuICAgICAgICAgICAgbG9ja1R5cGUgPSBsb2NrVHlwZSA/IGxvY2tUeXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbG9ja1R5cGUuc3Vic3RyKDEpIDogJyc7XG4gICAgICAgICAgICB0aGlzW2Ake3R5cGV9JHtsb2NrVHlwZX1Ob2RlYF0gPSBub2RlO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdoZWFkZXInICYmICF0aGlzLmlubmVySGVhZGVyTm9kZSAmJiAhbG9ja1R5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVySGVhZGVyTm9kZSA9IHRoaXMuaGVhZGVyTm9kZS5xdWVyeVNlbGVjdG9yKCdkaXYnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9uUm93TW91c2VFbnRlciA9IChyZWNvcmQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0xvY2soKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuZ2V0Um93Tm9kZShpbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdFJvdyA9IHRoaXMuZ2V0Um93Tm9kZShpbmRleCwgJ2xlZnQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodFJvdyA9IHRoaXMuZ2V0Um93Tm9kZShpbmRleCwgJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgW3JvdywgbGVmdFJvdywgcmlnaHRSb3ddLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcm93ICYmIGRvbS5hZGRDbGFzcyhyb3csICdob3ZlcmVkJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvblJvd01vdXNlTGVhdmUgPSAocmVjb3JkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2NrKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3cgPSB0aGlzLmdldFJvd05vZGUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRSb3cgPSB0aGlzLmdldFJvd05vZGUoaW5kZXgsICdsZWZ0Jyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHRSb3cgPSB0aGlzLmdldFJvd05vZGUoaW5kZXgsICdyaWdodCcpO1xuICAgICAgICAgICAgICAgIFtyb3csIGxlZnRSb3csIHJpZ2h0Um93XS5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJvdyAmJiBkb20ucmVtb3ZlQ2xhc3Mocm93LCAnaG92ZXJlZCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2Nyb2xsKCkge1xuICAgICAgICAgICAgY29uc3QgeyBzY3JvbGxUb0NvbCA9IDAsIHNjcm9sbFRvUm93ID0gMCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmICghc2Nyb2xsVG9Db2wgJiYgIXNjcm9sbFRvUm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29sQ2VsbE5vZGUgPSB0aGlzLmdldENlbGxOb2RlKDAsIHNjcm9sbFRvQ29sKTtcbiAgICAgICAgICAgIGNvbnN0IHJvd0NlbGxOb2RlID0gdGhpcy5nZXRDZWxsTm9kZShzY3JvbGxUb1JvdywgMCk7XG4gICAgICAgICAgICBjb25zdCBib2R5Tm9kZU9mZnNldCA9IHRoaXMuYm9keU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBpZiAoY29sQ2VsbE5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsTm9kZW9mZnNldCA9IGNvbENlbGxOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcm9sbExlZnQgPSBjZWxsTm9kZW9mZnNldC5sZWZ0IC0gYm9keU5vZGVPZmZzZXQubGVmdDtcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHlOb2RlLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvd0NlbGxOb2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbE5vZGVvZmZzZXQgPSByb3dDZWxsTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSBjZWxsTm9kZW9mZnNldC50b3AgLSBib2R5Tm9kZU9mZnNldC50b3A7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Tm9kZS5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvbkxvY2tCb2R5V2hlZWwgPSAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeSA9IGUuZGVsdGFZO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2NrKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NrUmlnaHRCb2R5ID0gdGhpcy5ib2R5UmlnaHROb2RlLFxuICAgICAgICAgICAgICAgICAgICBsb2NrTGVmdEJvZHkgPSB0aGlzLmJvZHlMZWZ0Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTm9kZSA9IHRoaXMuYm9keU5vZGUsXG4gICAgICAgICAgICAgICAgICAgIHsgc2Nyb2xsVG9wLCBjbGllbnRIZWlnaHQsIHNjcm9sbEhlaWdodCB9ID0gc2Nyb2xsTm9kZTtcblxuICAgICAgICAgICAgICAgIGlmIChsb2NrTGVmdEJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9ja0xlZnRCb2R5LnNjcm9sbFRvcCA9IHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsb2NrUmlnaHRCb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2tSaWdodEJvZHkuc2Nyb2xsVG9wID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2Nyb2xsTm9kZS5zY3JvbGxUb3AgPSBzY3JvbGxUb3AgKyB5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsVG9wOiBuZXdTY3JvbGxUb3AgfSA9IHNjcm9sbE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1Njcm9sbFRvcCArIGNsaWVudEhlaWdodCA8IHNjcm9sbEhlaWdodCAmJiBuZXdTY3JvbGxUb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9uTG9ja0JvZHlTY3JvbGwgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0xvY2soKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2tSaWdodEJvZHkgPSB0aGlzLmJvZHlSaWdodE5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGxvY2tMZWZ0Qm9keSA9IHRoaXMuYm9keUxlZnROb2RlLFxuICAgICAgICAgICAgICAgICAgICBsb2NrUmlnaHRUYWJsZSA9IHRoaXMuZ2V0V3JhcHBlck5vZGUoJ3JpZ2h0JyksXG4gICAgICAgICAgICAgICAgICAgIGxvY2tMZWZ0VGFibGUgPSB0aGlzLmdldFdyYXBwZXJOb2RlKCdsZWZ0JyksXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd0NsYXNzTmFtZSA9ICdzaGFkb3cnO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMuYm9keU5vZGUuc2Nyb2xsTGVmdCwgeSA9IHRoaXMuYm9keU5vZGUuc2Nyb2xsVG9wO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxvY2tMZWZ0Qm9keSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NrTGVmdEJvZHkuc2Nyb2xsVG9wID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxvY2tSaWdodEJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9ja1JpZ2h0Qm9keS5zY3JvbGxUb3AgPSB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NrTGVmdFRhYmxlICYmIGRvbS5yZW1vdmVDbGFzcyhsb2NrTGVmdFRhYmxlLCBzaGFkb3dDbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICBsb2NrUmlnaHRUYWJsZSAmJiBkb20uYWRkQ2xhc3MobG9ja1JpZ2h0VGFibGUsIHNoYWRvd0NsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh4ID09PSAodGhpcy5ib2R5Tm9kZS5zY3JvbGxXaWR0aCAtIHRoaXMuYm9keU5vZGUuY2xpZW50V2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2tMZWZ0VGFibGUgJiYgZG9tLmFkZENsYXNzKGxvY2tMZWZ0VGFibGUsIHNoYWRvd0NsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvY2tSaWdodFRhYmxlICYmIGRvbS5yZW1vdmVDbGFzcyhsb2NrUmlnaHRUYWJsZSwgc2hhZG93Q2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NrTGVmdFRhYmxlICYmIGRvbS5hZGRDbGFzcyhsb2NrTGVmdFRhYmxlLCBzaGFkb3dDbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICBsb2NrUmlnaHRUYWJsZSAmJiBkb20uYWRkQ2xhc3MobG9ja1JpZ2h0VGFibGUsIHNoYWRvd0NsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGFibGXlpITnkIbov4flkI7nnJ/lrp7nmoRsb2Nr54q25oCBXG4gICAgICAgIGlzTG9jaygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2tMZWZ0Q2hpbGRyZW4ubGVuZ3RoIHx8IHRoaXMubG9ja1JpZ2h0Q2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g55So5oi36K6+572u55qEbG9ja+eKtuaAgVxuICAgICAgICBpc09yaWdpbkxvY2soKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNMb2NrO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRqdXN0U2l6ZSgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hZGp1c3RJZlRhYmxlTm90TmVlZExvY2soKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRqdXN0SGVhZGVyU2l6ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRqdXN0Qm9keVNpemUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkanVzdENlbGxTaXplKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkxvY2tCb2R5U2Nyb2xsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhZGp1c3RJZlRhYmxlTm90TmVlZExvY2soKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc09yaWdpbkxvY2soKSAmJiB0aGlzLnRhYmxlSW5jLnByb3BzLmRhdGFTb3VyY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZmlnV2lkdGhzID0gdGhpcy50YWJsZUluYy5mbGF0Q2hpbGRyZW4ubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3cgPSB0aGlzLmdldENlbGxOb2RlKDAsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChyb3cgJiYgcm93LmNsaWVudFdpZHRoKSB8fCAwO1xuICAgICAgICAgICAgICAgIH0pLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gbm9kZS5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NrTGVmdExlbiA9IHRoaXMubG9ja0xlZnRDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9ja1JpZ2h0TGVuID0gdGhpcy5sb2NrUmlnaHRDaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnV2lkdGhzIDw9IHdpZHRoICYmIGNvbmZpZ1dpZHRocyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2tMZWZ0TGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub3ROZWVkQWRqdXN0TG9ja0xlZnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NrUmlnaHRMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25vdE5lZWRBZGp1c3RMb2NrUmlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NrUmlnaHRMZW4gfHwgbG9ja0xlZnRMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ub3ROZWVkQWRqdXN0TG9ja0xlZnQgfHwgdGhpcy5fbm90TmVlZEFkanVzdExvY2tSaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub3ROZWVkQWRqdXN0TG9ja0xlZnQgPSB0aGlzLl9ub3ROZWVkQWRqdXN0TG9ja1JpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub3ROZWVkQWRqdXN0TG9ja0xlZnQgPSB0aGlzLl9ub3ROZWVkQWRqdXN0TG9ja1JpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkanVzdEJvZHlTaXplKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2NrKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gdGhpcy5ib2R5Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgbG9ja0xlZnRCb2R5ID0gdGhpcy5ib2R5TGVmdE5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGxvY2tSaWdodEJvZHkgPSB0aGlzLmJvZHlSaWdodE5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGxvY2tSaWdodEJvZHlXcmFwcGVyID0gdGhpcy5nZXRXcmFwcGVyTm9kZSgncmlnaHQnKSxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyID0gZG9tLnNjcm9sbGJhcigpLFxuICAgICAgICAgICAgICAgICAgICBib2R5SGVpZ2h0ID0gYm9keS5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGhhc0hvelNjcm9sbCA9IGJvZHkuc2Nyb2xsV2lkdGggPiBib2R5LmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoYXNWZXJTY3JvbGwgPSBib2R5LnNjcm9sbEhlaWdodCA+IGJvZHkuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGhhc1ZlclNjcm9sbCA/IHNjcm9sbGJhci53aWR0aCA6IDAsXG4gICAgICAgICAgICAgICAgICAgIGxvY2tCb2R5SGVpZ2h0ID0gYm9keUhlaWdodCAtIChoYXNIb3pTY3JvbGwgPyBzY3JvbGxiYXIuaGVpZ2h0IDogMCk7XG5cbiAgICAgICAgICAgICAgICBsb2NrTGVmdEJvZHkgJiYgZG9tLnNldFN0eWxlKGxvY2tMZWZ0Qm9keSwgJ21heC1oZWlnaHQnLCBsb2NrQm9keUhlaWdodCk7XG4gICAgICAgICAgICAgICAgbG9ja1JpZ2h0Qm9keSAmJiBkb20uc2V0U3R5bGUobG9ja1JpZ2h0Qm9keSwgJ21heC1oZWlnaHQnLCBsb2NrQm9keUhlaWdodCk7XG4gICAgICAgICAgICAgICAgbG9ja1JpZ2h0Qm9keVdyYXBwZXIgJiYgZG9tLnNldFN0eWxlKGxvY2tSaWdodEJvZHlXcmFwcGVyLCAncmlnaHQnLCB3aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhZGp1c3RIZWFkZXJTaXplKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2NrKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhYmxlSW5jLmdyb3VwQ2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHRoaXMudGFibGVJbmMuZ3JvdXBDaGlsZHJlbltpbmRleF0ubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlclJpZ2h0Um93ID0gdGhpcy5nZXRIZWFkZXJDZWxsTm9kZShpbmRleCwgbGFzdEluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlckxlZnRSb3cgPSB0aGlzLmdldEhlYWRlckNlbGxOb2RlKGluZGV4LCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlclJpZ2h0TG9ja1JvdyA9IHRoaXMuZ2V0SGVhZGVyQ2VsbE5vZGUoaW5kZXgsIDAsICdyaWdodCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyTGVmdExvY2tSb3cgPSB0aGlzLmdldEhlYWRlckNlbGxOb2RlKGluZGV4LCAwLCAnbGVmdCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWFkZXJSaWdodFJvdyAmJiBoZWFkZXJSaWdodExvY2tSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heFJpZ2h0Um93SGVpZ2h0ID0gaGVhZGVyUmlnaHRSb3cub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkb20uc2V0U3R5bGUoaGVhZGVyUmlnaHRMb2NrUm93LCAnaGVpZ2h0JywgbWF4UmlnaHRSb3dIZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhYmxlUmlnaHRJbmMuYWZmaXhSZWYgJiYgdGhpcy50YWJsZVJpZ2h0SW5jLmFmZml4UmVmLmdldEluc3RhbmNlKCkudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlckxlZnRSb3cgJiYgaGVhZGVyTGVmdExvY2tSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heExlZnRSb3dIZWlnaHQgPSBoZWFkZXJMZWZ0Um93Lm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnNldFN0eWxlKGhlYWRlckxlZnRMb2NrUm93LCAnaGVpZ2h0JywgbWF4TGVmdFJvd0hlaWdodCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFibGVMZWZ0SW5jLmFmZml4UmVmICYmIHRoaXMudGFibGVMZWZ0SW5jLmFmZml4UmVmLmdldEluc3RhbmNlKCkudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFkanVzdENlbGxTaXplKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2NrKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhYmxlSW5jLnByb3BzLmRhdGFTb3VyY2UuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9ja0xlZnRSb3cgPSB0aGlzLmdldENlbGxOb2RlKGluZGV4LCAwLCAnbGVmdCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9ja1JpZ2h0Um93ID0gdGhpcy5nZXRDZWxsTm9kZShpbmRleCwgMCwgJ3JpZ2h0JyksXG4gICAgICAgICAgICAgICAgICAgICAgICByb3cgPSB0aGlzLmdldEZpcnN0Tm9ybWFsQ2VsbE5vZGUoaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93SGVpZ2h0ID0gcm93ICYmIHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZShyb3cpLmhlaWdodCkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxvY2tMZWZ0SGVpZ2h0ID0gMCwgbG9ja1JpZ2h0SGVpZ2h0ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobG9ja0xlZnRSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2tMZWZ0SGVpZ2h0ID0gbG9ja0xlZnRSb3cub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NrUmlnaHRSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2tSaWdodEhlaWdodCA9IGxvY2tSaWdodFJvdy5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2tMZWZ0Um93ICYmIHJvd0hlaWdodCAhPT0gbG9ja0xlZnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5zZXRTdHlsZShsb2NrTGVmdFJvdywgJ2hlaWdodCcsIHJvd0hlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2tSaWdodFJvdyAmJiByb3dIZWlnaHQgIT09IGxvY2tSaWdodEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnNldFN0eWxlKGxvY2tSaWdodFJvdywgJ2hlaWdodCcsIHJvd0hlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdldFdyYXBwZXJOb2RlKHR5cGUpIHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlID8gdHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR5cGUuc3Vic3RyKDEpIDogJyc7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGluIGNhc2Ugb2YgZmluZGluZyBhbiB1bm1vdW50ZWQgY29tcG9uZW50IGR1ZSB0byBjYWNoZWQgZGF0YVxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gY2xlYXIgcmVmcyBvZiB0YWJsZSB3aGVuIGRhdGFTb3VyY2UgQ2hhbmdlZFxuICAgICAgICAgICAgICAgIC8vIHVzZSB0cnkgY2F0Y2ggZm9yIHRlbXBvcmFyeVxuICAgICAgICAgICAgICAgIHJldHVybiBmaW5kRE9NTm9kZSh0aGlzLnJlZnNbYGxvY2ske3R5cGV9YF0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdldEZpcnN0Tm9ybWFsQ2VsbE5vZGUoaW5kZXgpIHtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGxldCByb3c7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcm93ID0gdGhpcy5nZXRDZWxsTm9kZShpbmRleCwgaSk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSB3aGlsZSAoKCFyb3cgfHwgcm93ICYmIHJvdy5yb3dTcGFuICYmIHJvdy5yb3dTcGFuID4gMSkgJiYgdGhpcy50YWJsZUluYy5mbGF0Q2hpbGRyZW4ubGVuZ3RoID4gaSk7XG5cbiAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRSb3dOb2RlKGluZGV4LCB0eXBlKSB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZSA/IHR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eXBlLnN1YnN0cigxKSA6ICcnO1xuICAgICAgICAgICAgY29uc3QgdGFibGUgPSB0aGlzW2B0YWJsZSR7dHlwZX1JbmNgXTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIG9mIGZpbmRpbmcgYW4gdW5tb3VudGVkIGNvbXBvbmVudCBkdWUgdG8gY2FjaGVkIGRhdGFcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGNsZWFyIHJlZnMgb2YgdGFibGUgd2hlbiBkYXRhU291cmNlIENoYW5nZWRcbiAgICAgICAgICAgICAgICAvLyB1c2UgdHJ5IGNhdGNoIGZvciB0ZW1wb3JhcnlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluZERPTU5vZGUodGFibGUuZ2V0Um93UmVmKGluZGV4KSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2V0SGVhZGVyQ2VsbE5vZGUoaW5kZXgsIGksIHR5cGUpIHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlID8gdHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR5cGUuc3Vic3RyKDEpIDogJyc7XG4gICAgICAgICAgICBjb25zdCB0YWJsZSA9IHRoaXNbYHRhYmxlJHt0eXBlfUluY2BdO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGluIGNhc2Ugb2YgZmluZGluZyBhbiB1bm1vdW50ZWQgY29tcG9uZW50IGR1ZSB0byBjYWNoZWQgZGF0YVxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gY2xlYXIgcmVmcyBvZiB0YWJsZSB3aGVuIGRhdGFTb3VyY2UgQ2hhbmdlZFxuICAgICAgICAgICAgICAgIC8vIHVzZSB0cnkgY2F0Y2ggZm9yIHRlbXBvcmFyeVxuICAgICAgICAgICAgICAgIHJldHVybiBmaW5kRE9NTm9kZSh0YWJsZS5nZXRIZWFkZXJDZWxsUmVmKGluZGV4LCBpKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2V0Q2VsbE5vZGUoaW5kZXgsIGksIHR5cGUpIHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlID8gdHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR5cGUuc3Vic3RyKDEpIDogJyc7XG4gICAgICAgICAgICBjb25zdCB0YWJsZSA9IHRoaXNbYHRhYmxlJHt0eXBlfUluY2BdO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGluIGNhc2Ugb2YgZmluZGluZyBhbiB1bm1vdW50ZWQgY29tcG9uZW50IGR1ZSB0byBjYWNoZWQgZGF0YVxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gY2xlYXIgcmVmcyBvZiB0YWJsZSB3aGVuIGRhdGFTb3VyY2UgQ2hhbmdlZFxuICAgICAgICAgICAgICAgIC8vIHVzZSB0cnkgY2F0Y2ggZm9yIHRlbXBvcmFyeVxuICAgICAgICAgICAgICAgIHJldHVybiBmaW5kRE9NTm9kZSh0YWJsZS5nZXRDZWxsUmVmKGluZGV4LCBpKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyKCkge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIHByZWZlci1jb25zdCAqL1xuICAgICAgICAgICAgbGV0IHsgY2hpbGRyZW4sIHByZWZpeCwgY29tcG9uZW50cywgY2xhc3NOYW1lLCAuLi5vdGhlcnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBsZXQgeyBsb2NrTGVmdENoaWxkcmVuLCBsb2NrUmlnaHRDaGlsZHJlbiwgY2hpbGRyZW46IG5vcm1hbGl6ZWRDaGlsZHJlbiB9ID0gdGhpcy5ub3JtYWxpemVDaGlsZHJlblN0YXRlKHRoaXMucHJvcHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX25vdE5lZWRBZGp1c3RMb2NrTGVmdCkge1xuICAgICAgICAgICAgICAgIGxvY2tMZWZ0Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9ub3ROZWVkQWRqdXN0TG9ja1JpZ2h0KSB7XG4gICAgICAgICAgICAgICAgbG9ja1JpZ2h0Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9ja0xlZnRDaGlsZHJlbiA9IGxvY2tMZWZ0Q2hpbGRyZW47XG4gICAgICAgICAgICB0aGlzLmxvY2tSaWdodENoaWxkcmVuID0gbG9ja1JpZ2h0Q2hpbGRyZW47XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzT3JpZ2luTG9jaygpKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cyA9IHsgLi4uY29tcG9uZW50cyB9O1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuQm9keSA9IGNvbXBvbmVudHMuQm9keSB8fCBMb2NrQm9keTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLkhlYWRlciA9IGNvbXBvbmVudHMuSGVhZGVyIHx8IExvY2tIZWFkZXI7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5XcmFwcGVyID0gY29tcG9uZW50cy5XcmFwcGVyIHx8IExvY2tXcmFwcGVyO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuUm93ID0gY29tcG9uZW50cy5Sb3cgfHwgTG9ja1JvdztcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgW2Ake3ByZWZpeH10YWJsZS1sb2NrYF06IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFtjbGFzc05hbWVdOiBjbGFzc05hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gW1xuICAgICAgICAgICAgICAgICAgICA8QmFzZUNvbXBvbmVudCB7Li4ub3RoZXJzfSBrZXk9XCJsb2NrLWxlZnRcIiBjb2x1bW5zPXtsb2NrTGVmdENoaWxkcmVufSBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1sb2NrLWxlZnRgfSBwcmVmaXg9e3ByZWZpeH0gbG9ja1R5cGU9XCJsZWZ0XCIgY29tcG9uZW50cz17Y29tcG9uZW50c30gcmVmPVwibG9ja0xlZnRcIiBsb2FkaW5nPXtmYWxzZX0gLz4sXG4gICAgICAgICAgICAgICAgICAgIDxCYXNlQ29tcG9uZW50IHsuLi5vdGhlcnN9IGtleT1cImxvY2stcmlnaHRcIiBjb2x1bW5zPXtsb2NrUmlnaHRDaGlsZHJlbn0gY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtbG9jay1yaWdodGB9IHByZWZpeD17cHJlZml4fSBsb2NrVHlwZT1cInJpZ2h0XCIgY29tcG9uZW50cz17Y29tcG9uZW50c30gcmVmPVwibG9ja1JpZ2h0XCIgbG9hZGluZz17ZmFsc2V9IC8+XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gPEJhc2VDb21wb25lbnQgey4uLm90aGVyc30gY29sdW1ucz17bm9ybWFsaXplZENoaWxkcmVufSBwcmVmaXg9e3ByZWZpeH0gd3JhcHBlckNvbnRlbnQ9e2NvbnRlbnR9IGNvbXBvbmVudHM9e2NvbXBvbmVudHN9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSAvPjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoPEJhc2VDb21wb25lbnQgey4uLnRoaXMucHJvcHN9IC8+KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWNzKExvY2tUYWJsZSwgQmFzZUNvbXBvbmVudCk7XG4gICAgcmV0dXJuIExvY2tUYWJsZTtcbn1cblxuXG5mdW5jdGlvbiBkZWVwQ29weShhcnIpIHtcbiAgICBsZXQgY29weSA9IChhcnIpID0+IHtcbiAgICAgICAgcmV0dXJuIGFyci5tYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtID0geyAuLi5pdGVtIH07XG4gICAgICAgICAgICBpZiAoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2hpbGRyZW4gPSBjb3B5KGl0ZW0uY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld0l0ZW07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIGNvcHkoYXJyKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9sb2NrLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmaW5kRE9NTm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEZpeGVkQm9keSBmcm9tICcuLi9maXhlZC9ib2R5JztcblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcHJlZmVyLXN0YXRlbGVzcy1mdW5jdGlvbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9ja0JvZHkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIC4uLkZpeGVkQm9keS5wcm9wVHlwZXNcbiAgICB9XG5cbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICAuLi5GaXhlZEJvZHkuY29udGV4dFR5cGVzLFxuICAgICAgICBnZXRMb2NrTm9kZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uTG9ja0JvZHlTY3JvbGw6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkxvY2tCb2R5V2hlZWw6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBsb2NrVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsICdyaWdodCddKVxuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmNvbnRleHQuZ2V0TG9ja05vZGUoJ2JvZHknLCBmaW5kRE9NTm9kZSh0aGlzKSwgdGhpcy5jb250ZXh0LmxvY2tUeXBlKTtcbiAgICB9XG5cbiAgICBvbkJvZHlTY3JvbGwgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuY29udGV4dC5vbkxvY2tCb2R5U2Nyb2xsKCk7XG4gICAgfVxuXG4gICAgb25Cb2R5V2hlZWwgPSAoZSkgPT4ge1xuICAgICAgICB0aGlzLmNvbnRleHQub25Mb2NrQm9keVdoZWVsKGUpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIDxGaXhlZEJvZHkgey4uLnRoaXMucHJvcHN9IG9uU2Nyb2xsPXt0aGlzLm9uQm9keVNjcm9sbH0gb25XaGVlbD17dGhpcy5vbkJvZHlXaGVlbH0gLz47XG4gICAgfVxufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvbG9jay9ib2R5LmpzeCIsImltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgRml4ZWRIZWFkZXIgZnJvbSAnLi4vZml4ZWQvaGVhZGVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9ja0hlYWRlciBleHRlbmRzIEZpeGVkSGVhZGVyIHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAuLi5GaXhlZEhlYWRlci5wcm9wVHlwZXNcbiAgICB9XG5cbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICAuLi5GaXhlZEhlYWRlci5jb250ZXh0VHlwZXMsXG4gICAgICAgIGdldExvY2tOb2RlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgbG9ja1R5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2xlZnQnLCAncmlnaHQnXSlcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3Qge2dldE5vZGUsIGdldExvY2tOb2RlfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgZ2V0Tm9kZSAmJiBnZXROb2RlKCdoZWFkZXInLCBmaW5kRE9NTm9kZSh0aGlzKSwgdGhpcy5jb250ZXh0LmxvY2tUeXBlKTtcbiAgICAgICAgZ2V0TG9ja05vZGUgJiYgZ2V0TG9ja05vZGUoJ2hlYWRlcicsIGZpbmRET01Ob2RlKHRoaXMpLCB0aGlzLmNvbnRleHQubG9ja1R5cGUpO1xuICAgIH1cbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2xvY2svaGVhZGVyLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBMaXN0SGVhZGVyIGZyb20gJy4vbGlzdC1oZWFkZXInO1xuaW1wb3J0IExpc3RGb290ZXIgZnJvbSAnLi9saXN0LWZvb3Rlcic7XG5pbXBvcnQgUm93Q29tcG9uZW50IGZyb20gJy4vbGlzdC9yb3cnO1xuaW1wb3J0IEJvZHlDb21wb25lbnQgZnJvbSAnLi9saXN0L2JvZHknO1xuaW1wb3J0IEhlYWRlckNvbXBvbmVudCBmcm9tICcuL2ZpeGVkL2hlYWRlcic7XG5pbXBvcnQgV3JhcHBlckNvbXBvbmVudCBmcm9tICcuL2ZpeGVkL3dyYXBwZXInO1xuaW1wb3J0IHsgc3RhdGljcyB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxpc3QoQmFzZUNvbXBvbmVudCkge1xuICAgIGNsYXNzIExpc3RUYWJsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgICAgIHN0YXRpYyBMaXN0SGVhZGVyID0gTGlzdEhlYWRlcjtcbiAgICAgICAgc3RhdGljIExpc3RGb290ZXIgPSBMaXN0Rm9vdGVyO1xuICAgICAgICBzdGF0aWMgTGlzdFJvdyA9IFJvd0NvbXBvbmVudDtcbiAgICAgICAgc3RhdGljIExpc3RCb2R5ID0gQm9keUNvbXBvbmVudDtcbiAgICAgICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgICAgIC4uLkJhc2VDb21wb25lbnQucHJvcFR5cGVzXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgICAgIC4uLkJhc2VDb21wb25lbnQuZGVmYXVsdFByb3BzXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0aWMgY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gICAgICAgICAgICBsaXN0SGVhZGVyOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICAgICAgbGlzdEZvb3RlcjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgICAgIHJvd1NlbGVjdGlvbjogUHJvcFR5cGVzLm9iamVjdFxuICAgICAgICB9XG5cbiAgICAgICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsaXN0SGVhZGVyOiB0aGlzLmxpc3RIZWFkZXIsXG4gICAgICAgICAgICAgICAgbGlzdEZvb3RlcjogdGhpcy5saXN0Rm9vdGVyLFxuICAgICAgICAgICAgICAgIHJvd1NlbGVjdGlvbjogdGhpcy5yb3dTZWxlY3Rpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBub3JtYWxpemVEYXRhU291cmNlKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgICAgICAgY29uc3QgbG9vcCA9IGZ1bmN0aW9uIChkYXRhU291cmNlLCBsZXZlbCkge1xuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5fX2xldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9vcChpdGVtLmNoaWxkcmVuLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbG9vcChkYXRhU291cmNlLCAwKTtcbiAgICAgICAgICAgIHRoaXMuZHMgPSByZXQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyKCkge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWNvbnN0ICovXG4gICAgICAgICAgICBsZXQgeyBjb21wb25lbnRzLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCBwcmVmaXgsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGxldCBpc0xpc3QgPSBmYWxzZSwgcmV0ID0gW107XG4gICAgICAgICAgICBDaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUuX3R5cGVNYXJrID09PSAnbGlzdEhlYWRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RIZWFkZXIgPSBjaGlsZC5wcm9wcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xpc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZC50eXBlLl90eXBlTWFyayA9PT0gJ2xpc3RGb290ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0Rm9vdGVyID0gY2hpbGQucHJvcHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yb3dTZWxlY3Rpb24gPSB0aGlzLnByb3BzLnJvd1NlbGVjdGlvbjtcbiAgICAgICAgICAgIGlmIChpc0xpc3QpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzID0geyAuLi5jb21wb25lbnRzIH07XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5Sb3cgPSBjb21wb25lbnRzLlJvdyB8fCBSb3dDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5Cb2R5ID0gY29tcG9uZW50cy5Cb2R5IHx8IEJvZHlDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5IZWFkZXIgPSBjb21wb25lbnRzLkhlYWRlciB8fCBIZWFkZXJDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5XcmFwcGVyID0gY29tcG9uZW50cy5XcmFwcGVyIHx8IFdyYXBwZXJDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgIFtgJHtwcmVmaXh9dGFibGUtZ3JvdXBgXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgW2NsYXNzTmFtZV06IGNsYXNzTmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICg8QmFzZUNvbXBvbmVudCB7Li4ub3RoZXJzfSBjb21wb25lbnRzPXtjb21wb25lbnRzfSBjaGlsZHJlbj17cmV0fSBjbGFzc05hbWU9e2NsYXNzTmFtZX0gcHJlZml4PXtwcmVmaXh9Lz4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpY3MoTGlzdFRhYmxlLCBCYXNlQ29tcG9uZW50KTtcbiAgICByZXR1cm4gTGlzdFRhYmxlO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2xpc3QuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IGxvZyB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IFJvdyBmcm9tICcuLi9iYXNlL3Jvdyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyb3VwTGlzdFJvdyBleHRlbmRzIFJvdyB7XG5cbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICBsaXN0SGVhZGVyOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBsaXN0Rm9vdGVyOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICByb3dTZWxlY3Rpb246IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgIG5vdFJlbmRlckNlbGxJbmRleDogUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBsb2NrVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsICdyaWdodCddKVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMqL1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgY2xhc3NOYW1lLCBvbkNsaWNrLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSwgY29sdW1ucywgQ2VsbCwgcm93SW5kZXgsIHJlY29yZCwgY2hpbGRyZW4sIHByaW1hcnlLZXksIGNvbEdyb3VwLCBjZWxsUmVmLCBnZXRDZWxsUHJvcHMsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgY2xzID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fXRhYmxlLXJvd2BdOiB0cnVlLFxuICAgICAgICAgICAgW2NsYXNzTmFtZV06IGNsYXNzTmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICg8dGFibGUgY2xhc3NOYW1lPXtjbHN9IHJvbGU9XCJyb3dcIiB7Li4ub3RoZXJzfVxuICAgICAgICAgICAgb25DbGljaz17dGhpcy5vbkNsaWNrfSBvbk1vdXNlRW50ZXI9e3RoaXMub25Nb3VzZUVudGVyfSBvbk1vdXNlTGVhdmU9e3RoaXMub25Nb3VzZUxlYXZlfT5cbiAgICAgICAgICAgIHtjb2xHcm91cH1cbiAgICAgICAgICAgIDx0Ym9keT5cbiAgICAgICAgICAgICAgICB7dGhpcy5yZW5kZXJDb250ZW50KCdoZWFkZXInKX1cbiAgICAgICAgICAgICAgICB7dGhpcy5yZW5kZXJDaGlsZHJlbigpfVxuICAgICAgICAgICAgICAgIHt0aGlzLnJlbmRlckNvbnRlbnQoJ2Zvb3RlcicpfVxuICAgICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgPC90YWJsZT4pO1xuICAgIH1cblxuICAgIGlzQ2hpbGRyZW5TZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQubGlzdEhlYWRlciAmJiB0aGlzLmNvbnRleHQubGlzdEhlYWRlci5oYXNDaGlsZHJlblNlbGVjdGlvbjtcbiAgICB9XG5cbiAgICBpc1NlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5saXN0SGVhZGVyICYmIHRoaXMuY29udGV4dC5saXN0SGVhZGVyLmhhc1NlbGVjdGlvbjtcbiAgICB9XG5cbiAgICByZW5kZXJDaGlsZHJlbigpIHtcbiAgICAgICAgY29uc3QgeyByZWNvcmQsIHByaW1hcnlLZXkgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHJlY29yZDtcbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW4ubWFwKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxscyA9IHRoaXMucmVuZGVyQ2VsbHMoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ2hpbGRyZW5TZWxlY3Rpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkW3ByaW1hcnlLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cud2FybmluZygncmVjb3JkLmNoaWxkcmVuIHNob3VsZCBjb250YWlucyBwcmltYXJ5S2V5IHdoZW4gY2hpbGRyZW5TZWxlY3Rpb24gaXMgdHJ1ZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gPHRyIGtleT17Y2hpbGRbcHJpbWFyeUtleV19PntjZWxsc308L3RyPjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5yb3dTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY2VsbHNbMF0gPSBSZWFjdC5jbG9uZUVsZW1lbnQoY2VsbHNbMF0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbFNwYW46IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jZWxsc1swXS5wcm9wc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDx0ciBrZXk9e2luZGV4fT57Y2VsbHN9PC90cj47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmVuZGVyQ29udGVudCh0eXBlKSB7XG4gICAgICAgIGNvbnN0IHsgY29sdW1ucywgcHJlZml4LCByZWNvcmQsIHJvd0luZGV4IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBjYW1lVHlwZSA9IHR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eXBlLnN1YnN0cigxKTtcbiAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMuY29udGV4dFtgbGlzdCR7Y2FtZVR5cGV9YF07XG4gICAgICAgIGxldCBsaXN0Tm9kZTtcbiAgICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgICAgIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChsaXN0LmNlbGwpKSB7XG4gICAgICAgICAgICAgICAgbGlzdE5vZGUgPSBSZWFjdC5jbG9uZUVsZW1lbnQobGlzdC5jZWxsLCB7IHJlY29yZCwgaW5kZXg6IHJvd0luZGV4IH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdC5jZWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbGlzdE5vZGUgPSBsaXN0LmNlbGwocmVjb3JkLCByb3dJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGlzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2VsbHMgPSB0aGlzLnJlbmRlckNlbGxzKHJlY29yZCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdoZWFkZXInICYmIHRoaXMuY29udGV4dC5yb3dTZWxlY3Rpb24gJiYgdGhpcy5pc1NlbGVjdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxzID0gY2VsbHMuc2xpY2UoMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQgY29sU3Bhbj17Y29sdW1ucy5sZW5ndGggLSAxfSBrZXk9XCJsaXN0Tm9kZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtY2VsbC13cmFwcGVyYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtsaXN0Tm9kZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGxpc3ROb2RlID0gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGNsYXNzTmFtZT17YCR7cHJlZml4fXRhYmxlLWdyb3VwLSR7dHlwZX1gfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y2VsbHN9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3ROb2RlID0gKDx0ciBjbGFzc05hbWU9e2Ake3ByZWZpeH10YWJsZS1ncm91cC0ke3R5cGV9YH0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQgY29sU3Bhbj17Y29sdW1ucy5sZW5ndGh9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXh9dGFibGUtY2VsbC13cmFwcGVyYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtsaXN0Tm9kZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3ROb2RlO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9saXN0L3Jvdy5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IEJvZHlDb21wb25lbnQgZnJvbSAnLi4vYmFzZS9ib2R5JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGlzdEJvZHkocHJvcHMpIHtcbiAgICByZXR1cm4gPEJvZHlDb21wb25lbnQgY29tcG9uZW50PVwiZGl2XCIgey4uLnByb3BzfS8+O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL2xpc3QvYm9keS5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBIZWFkZXIgZnJvbSAnLi9maXhlZC9oZWFkZXInO1xuaW1wb3J0IFN0aWNreUhlYWRlciBmcm9tICcuL3N0aWNreS9oZWFkZXInO1xuaW1wb3J0IHsgc3RhdGljcyB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN0aWNreShCYXNlQ29tcG9uZW50KSB7XG4gICAgLyoqIFRhYmxlICovXG4gICAgY2xhc3MgU3RpY2t5VGFibGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgICAgICBzdGF0aWMgU3RpY2t5SGVhZGVyID0gU3RpY2t5SGVhZGVyO1xuICAgICAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDooajlpLTmmK/lkKbmmK9zdGlja3lcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3RpY2t5SGVhZGVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog6Led56a756qX5Y+j6aG26YOo6L6+5Yiw5oyH5a6a5YGP56e76YeP5ZCO6Kem5Y+RXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9mZnNldFRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogYWZmaXjnu4Tku7bnmoTnmoTlsZ7mgKdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYWZmaXhQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICAgICAgICAuLi5CYXNlQ29tcG9uZW50LnByb3BUeXBlc1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IHt9LFxuICAgICAgICAgICAgLi4uQmFzZUNvbXBvbmVudC5kZWZhdWx0UHJvcHNcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgICAgIEhlYWRlcjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgICAgIG9mZnNldFRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgICAgIGFmZml4UHJvcHM6IFByb3BUeXBlcy5vYmplY3RcbiAgICAgICAgfVxuXG4gICAgICAgIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgSGVhZGVyOiAodGhpcy5wcm9wcy5jb21wb25lbnRzLkhlYWRlciB8fCBIZWFkZXIpLFxuICAgICAgICAgICAgICAgIG9mZnNldFRvcDogdGhpcy5wcm9wcy5vZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgYWZmaXhQcm9wczogdGhpcy5wcm9wcy5hZmZpeFByb3BzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyKCkge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgICAgIGNvbnN0IHsgc3RpY2t5SGVhZGVyLCBvZmZzZXRUb3AsIGFmZml4UHJvcHMsIC4uLm90aGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudHMsIG1heEJvZHlIZWlnaHQsIGZpeGVkSGVhZGVyIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKHN0aWNreUhlYWRlcikge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMgPSB7Li4uY29tcG9uZW50c307XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5IZWFkZXIgPSBTdGlja3lIZWFkZXI7XG4gICAgICAgICAgICAgICAgZml4ZWRIZWFkZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1heEJvZHlIZWlnaHQgPSBNYXRoLm1heChtYXhCb2R5SGVpZ2h0LCAxMDAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gPEJhc2VDb21wb25lbnQgey4uLm90aGVyc30gY29tcG9uZW50cz17Y29tcG9uZW50c30gZml4ZWRIZWFkZXI9e2ZpeGVkSGVhZGVyfSBtYXhCb2R5SGVpZ2h0PXttYXhCb2R5SGVpZ2h0fS8+O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpY3MoU3RpY2t5VGFibGUsIEJhc2VDb21wb25lbnQpO1xuICAgIHJldHVybiBTdGlja3lUYWJsZTtcbn1cblxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdGFibGUvc3RpY2t5LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgQWZmaXggZnJvbSAnLi4vLi4vYWZmaXgnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9wcmVmZXItc3RhdGVsZXNzLWZ1bmN0aW9uKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0aWNrSGVhZGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBwcmVmaXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgfVxuICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgICAgIEhlYWRlcjogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgb2Zmc2V0VG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBhZmZpeFByb3BzOiBQcm9wVHlwZXMub2JqZWN0XG4gICAgfVxuXG4gICAgZ2V0QWZmaXhSZWYgPSAocmVmKSA9PiB7XG4gICAgICAgIHRoaXMucHJvcHMuYWZmaXhSZWYgJiYgdGhpcy5wcm9wcy5hZmZpeFJlZihyZWYpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXggfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgSGVhZGVyLCBvZmZzZXRUb3AsIGFmZml4UHJvcHMgfSA9IHRoaXMuY29udGV4dDtcblxuICAgICAgICBjb25zdCBuZXdBZmZpeFByb3BzID0gYWZmaXhQcm9wcyB8fCB7fTtcbiAgICAgICAgY29uc3QgeyBjbGFzc05hbWUsIC4uLm90aGVycyB9ID0gbmV3QWZmaXhQcm9wcztcbiAgICAgICAgY29uc3QgY2xzID0gY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICBbYCR7cHJlZml4fXRhYmxlLWFmZml4YF06IHRydWUsXG4gICAgICAgICAgICBjbGFzc05hbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuICg8QWZmaXggcmVmPXt0aGlzLmdldEFmZml4UmVmfSB7Li4ub3RoZXJzfSBjbGFzc05hbWU9e2Nsc30gb2Zmc2V0VG9wPXtvZmZzZXRUb3B9PlxuICAgICAgICAgICAgPEhlYWRlciB7Li4udGhpcy5wcm9wc30vPlxuICAgICAgICA8L0FmZml4Pik7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RhYmxlL3N0aWNreS9oZWFkZXIuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBmaW5kRE9NTm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IG9iaiwgZXZlbnRzLCBmdW5jIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgQ29uZmlnUHJvdmlkZXIgZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCB7IGdldFNjcm9sbCwgZ2V0UmVjdCwgZ2V0Tm9kZUhlaWdodCB9IGZyb20gJy4vdXRpbCc7XG5cbi8qKiBBZmZpeCAqL1xuY2xhc3MgQWZmaXggZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHByZWZpeDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9riBBZmZpeCDpnIDopoHnm5HlkKzmu5rliqjkuovku7bnmoTlrrnlmajlhYPntKBcbiAgICAgICAgICogQHJldHVybiB7UmVhY3RFbGVtZW50fSDnm67moIflrrnlmajlhYPntKDnmoTlrp7kvotcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5lcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDot53nprvnqpflj6Ppobbpg6jovr7liLDmjIflrprlgY/np7vph4/lkI7op6blj5FcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNldFRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOi3neemu+eql+WPo+W6lemDqOi+vuWIsOWItuWumuWBj+enu+mHj+WQjuinpuWPkVxuICAgICAgICAgKi9cbiAgICAgICAgb2Zmc2V0Qm90dG9tOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICog5b2T5YWD57Sg55qE5qC35byP5Y+R55Sf5Zu66ZKJ5qC35byP5Y+Y5YyW5pe26Kem5Y+R55qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0g5YWD57Sg5piv5ZCm6KKr5Zu66ZKJXG4gICAgICAgICAqL1xuICAgICAgICBvbkFmZml4OiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuWQr+eUqOe7neWvueW4g+WxgOWunueOsCBhZmZpeFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IOaYr+WQpuWQr+eUqOe7neWvueW4g+WxgFxuICAgICAgICAgKi9cbiAgICAgICAgdXNlQWJzb2x1dGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmFueSxcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgcHJlZml4OiAnbmV4dC0nLFxuICAgICAgICBjb250YWluZXI6ICgpID0+IHdpbmRvdyxcbiAgICAgICAgb25BZmZpeDogZnVuYy5ub29wLFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xuICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzdHlsZTogbnVsbCxcbiAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFmZml4TW9kZSA9IHRoaXMuX2dldEFmZml4TW9kZShwcm9wcyk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICB0aGlzLl91cGRhdGVOb2RlUG9zaXRpb24oKTtcbiAgICAgICAgLy8gd2FpdCBmb3IgcGFyZW50IHJlbmRlcmVkXG4gICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc2V0RXZlbnRIYW5kbGVyRm9yQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMudGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlckZvckNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIH1cblxuICAgIF9zZXRFdmVudEhhbmRsZXJGb3JDb250YWluZXIoZ2V0Q29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50cy5vbihjb250YWluZXIsICdzY3JvbGwnLCB0aGlzLl91cGRhdGVOb2RlUG9zaXRpb24sIGZhbHNlKTtcbiAgICAgICAgZXZlbnRzLm9uKGNvbnRhaW5lciwgJ3Jlc2l6ZScsIHRoaXMuX3VwZGF0ZU5vZGVQb3NpdGlvbiwgZmFsc2UpO1xuICAgIH1cblxuICAgIF9yZW1vdmVFdmVudEhhbmRsZXJGb3JDb250YWluZXIoZ2V0Q29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBldmVudHMub2ZmKGNvbnRhaW5lciwgJ3Njcm9sbCcsIHRoaXMuX3VwZGF0ZU5vZGVQb3NpdGlvbik7XG4gICAgICAgICAgICBldmVudHMub2ZmKGNvbnRhaW5lciwgJ3Jlc2l6ZScsIHRoaXMuX3VwZGF0ZU5vZGVQb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVQb3NpdGlvbiA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fdXBkYXRlTm9kZVBvc2l0aW9uKCk7XG4gICAgfVxuXG4gICAgX3VwZGF0ZU5vZGVQb3NpdGlvbiA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXIsIHVzZUFic29sdXRlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBhZmZpeENvbnRhaW5lciA9IGNvbnRhaW5lcigpO1xuXG4gICAgICAgIGlmICghYWZmaXhDb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250YWluZXJTY3JvbGxUb3AgPSBnZXRTY3JvbGwoYWZmaXhDb250YWluZXIsIHRydWUpOyAgICAvLyDlrrnlmajlnKjlnoLnm7TkvY3nva7kuIrnmoTmu5rliqggb2Zmc2V0XG4gICAgICAgIGNvbnN0IGFmZml4T2Zmc2V0ID0gdGhpcy5fZ2V0T2Zmc2V0KHRoaXMuYWZmaXhOb2RlLCBhZmZpeENvbnRhaW5lcik7IC8vIOebruagh+iKgueCueW9k+WJjeebuOWvueS6juWuueWZqOeahCBvZmZzZXRcbiAgICAgICAgY29uc3QgY29udGFpbmVySGVpZ2h0ID0gZ2V0Tm9kZUhlaWdodChhZmZpeENvbnRhaW5lcik7ICAgICAgICAgLy8g5a655Zmo55qE6auY5bqmXG4gICAgICAgIGNvbnN0IGFmZml4SGVpZ2h0ID0gdGhpcy5hZmZpeE5vZGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBjb25zdCBjb250YWluZXJSZWN0ID0gZ2V0UmVjdChhZmZpeENvbnRhaW5lcik7XG5cbiAgICAgICAgY29uc3QgYWZmaXhDaGlsZEhlaWdodCA9IHRoaXMuYWZmaXhDaGlsZE5vZGUub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIGNvbnN0IGFmZml4TW9kZSA9IHRoaXMuYWZmaXhNb2RlO1xuICAgICAgICBjb25zdCBhZmZpeFN0eWxlID0ge1xuICAgICAgICAgICAgd2lkdGg6IGFmZml4T2Zmc2V0LndpZHRoLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb250YWluZXJTdHlsZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBhZmZpeE9mZnNldC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogYWZmaXhDaGlsZEhlaWdodCxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoYWZmaXhNb2RlLnRvcCAmJiBjb250YWluZXJTY3JvbGxUb3AgPiBhZmZpeE9mZnNldC50b3AgLSBhZmZpeE1vZGUub2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyBhZmZpeCB0b3BcbiAgICAgICAgICAgIGlmICh1c2VBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIGFmZml4U3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgICAgIGFmZml4U3R5bGUudG9wID0gY29udGFpbmVyU2Nyb2xsVG9wIC0gKGFmZml4T2Zmc2V0LnRvcCAtIGFmZml4TW9kZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWZmaXhTdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgICAgICAgICAgYWZmaXhTdHlsZS50b3AgPSBhZmZpeE1vZGUub2Zmc2V0ICsgY29udGFpbmVyUmVjdC50b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXRBZmZpeFN0eWxlKGFmZml4U3R5bGUsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5fc2V0Q29udGFpbmVyU3R5bGUoY29udGFpbmVyU3R5bGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGFmZml4TW9kZS5ib3R0b20gJiYgY29udGFpbmVyU2Nyb2xsVG9wIDwgYWZmaXhPZmZzZXQudG9wICsgYWZmaXhIZWlnaHQgKyBhZmZpeE1vZGUub2Zmc2V0IC0gY29udGFpbmVySGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBhZmZpeCBib3R0b21cbiAgICAgICAgICAgIGFmZml4U3R5bGUuaGVpZ2h0ID0gYWZmaXhIZWlnaHQ7XG4gICAgICAgICAgICBpZiAodXNlQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICBhZmZpeFN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgICAgICBhZmZpeFN0eWxlLnRvcCA9IGNvbnRhaW5lclNjcm9sbFRvcCAtIChhZmZpeE9mZnNldC50b3AgKyBhZmZpeEhlaWdodCArIGFmZml4TW9kZS5vZmZzZXQgLSBjb250YWluZXJIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWZmaXhTdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgICAgICAgICAgYWZmaXhTdHlsZS5ib3R0b20gPSBhZmZpeE1vZGUub2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2V0QWZmaXhTdHlsZShhZmZpeFN0eWxlLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX3NldENvbnRhaW5lclN0eWxlKGNvbnRhaW5lclN0eWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEFmZml4U3R5bGUobnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9zZXRDb250YWluZXJTdHlsZShudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBfZ2V0QWZmaXhNb2RlKCkge1xuICAgICAgICBjb25zdCB7IG9mZnNldFRvcCwgb2Zmc2V0Qm90dG9tIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBhZmZpeE1vZGUgPSB7XG4gICAgICAgICAgICB0b3A6IGZhbHNlLFxuICAgICAgICAgICAgYm90dG9tOiBmYWxzZSxcbiAgICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldFRvcCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIG9mZnNldEJvdHRvbSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0XG4gICAgICAgICAgICBhZmZpeE1vZGUudG9wID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2Zmc2V0VG9wID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgYWZmaXhNb2RlLnRvcCA9IHRydWU7XG4gICAgICAgICAgICBhZmZpeE1vZGUub2Zmc2V0ID0gb2Zmc2V0VG9wO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvZmZzZXRCb3R0b20gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBhZmZpeE1vZGUuYm90dG9tID0gdHJ1ZTtcbiAgICAgICAgICAgIGFmZml4TW9kZS5vZmZzZXQgPSBvZmZzZXRCb3R0b207XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWZmaXhNb2RlO1xuICAgIH1cblxuICAgIF9zZXRBZmZpeFN0eWxlKGFmZml4U3R5bGUsIGFmZml4ZWQgPSBmYWxzZSkge1xuICAgICAgICBpZiAob2JqLnNoYWxsb3dFcXVhbChhZmZpeFN0eWxlLCB0aGlzLnN0YXRlLnN0eWxlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBzdHlsZTogYWZmaXhTdHlsZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgeyBvbkFmZml4IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGlmIChhZmZpeGVkKSB7XG4gICAgICAgICAgICBvbkFmZml4KHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKCFhZmZpeFN0eWxlKSB7XG4gICAgICAgICAgICBvbkFmZml4KGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRDb250YWluZXJTdHlsZShjb250YWluZXJTdHlsZSkge1xuICAgICAgICBpZiAob2JqLnNoYWxsb3dFcXVhbChjb250YWluZXJTdHlsZSwgdGhpcy5zdGF0ZS5jb250YWluZXJTdHlsZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFN0YXRlKHsgY29udGFpbmVyU3R5bGUgfSk7XG4gICAgfVxuXG4gICAgX2dldE9mZnNldChhZmZpeE5vZGUsIGFmZml4Q29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IGFmZml4UmVjdCA9IGFmZml4Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgIC8vIGFmZml4IOWFg+e0oCDnm7jlr7nmtY/op4jlmajnqpflj6PnmoTkvY3nva5cbiAgICAgICAgY29uc3QgY29udGFpbmVyUmVjdCA9IGdldFJlY3QoYWZmaXhDb250YWluZXIpOyAvLyBhZmZpeCDlrrnlmagg55u45a+55rWP6KeI5Zmo56qX5Y+j55qE5L2N572uXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNjcm9sbFRvcCA9IGdldFNjcm9sbChhZmZpeENvbnRhaW5lciwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNjcm9sbExlZnQgPSBnZXRTY3JvbGwoYWZmaXhDb250YWluZXIsIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBhZmZpeFJlY3QudG9wIC0gY29udGFpbmVyUmVjdC50b3AgKyBjb250YWluZXJTY3JvbGxUb3AsXG4gICAgICAgICAgICBsZWZ0OiBhZmZpeFJlY3QubGVmdCAtIGNvbnRhaW5lclJlY3QubGVmdCArIGNvbnRhaW5lclNjcm9sbExlZnQsXG4gICAgICAgICAgICB3aWR0aDogYWZmaXhSZWN0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBhZmZpeFJlY3QuaGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9hZmZpeE5vZGVSZWZIYW5kbGVyID0gKHJlZikgPT4ge1xuICAgICAgICB0aGlzLmFmZml4Tm9kZSA9IGZpbmRET01Ob2RlKHJlZik7XG4gICAgfVxuXG4gICAgX2FmZml4Q2hpbGROb2RlUmVmSGFuZGxlciA9IChyZWYpID0+IHtcbiAgICAgICAgdGhpcy5hZmZpeENoaWxkTm9kZSA9IGZpbmRET01Ob2RlKHJlZik7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgY2xhc3NOYW1lLCBzdHlsZSwgY2hpbGRyZW4gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgW2Ake3ByZWZpeH1hZmZpeGBdOiBzdGF0ZS5zdHlsZSxcbiAgICAgICAgICAgIFtgJHtwcmVmaXh9YWZmaXgtdG9wYF06ICFzdGF0ZS5zdHlsZSAmJiB0aGlzLmFmZml4TW9kZS50b3AsXG4gICAgICAgICAgICBbYCR7cHJlZml4fWFmZml4LWJvdHRvbWBdOiAhc3RhdGUuc3R5bGUgJiYgdGhpcy5hZmZpeE1vZGUuYm90dG9tLFxuICAgICAgICAgICAgW2NsYXNzTmFtZV06IGNsYXNzTmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkU3R5bGUgPSB7IC4uLnN0YXRlLmNvbnRhaW5lclN0eWxlLCAuLi5zdHlsZSB9O1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IHJlZj17dGhpcy5fYWZmaXhOb2RlUmVmSGFuZGxlcn0gc3R5bGU9e2NvbWJpbmVkU3R5bGV9PlxuICAgICAgICAgICAgICAgIDxkaXYgcmVmPXt0aGlzLl9hZmZpeENoaWxkTm9kZVJlZkhhbmRsZXJ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gc3R5bGU9e3N0YXRlLnN0eWxlfT5cbiAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb25maWdQcm92aWRlci5jb25maWcoQWZmaXgpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FmZml4L2luZGV4LmpzeCIsImV4cG9ydCBmdW5jdGlvbiBnZXRTY3JvbGwobm9kZSwgaXNWZXJ0aWNhbCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3Qgd2luZG93UHJvcCA9IGlzVmVydGljYWwgPyAncGFnZVlPZmZzZXQnIDogJ3BhZ2VYT2Zmc2V0JztcbiAgICBjb25zdCBlbGVtZW50UHJvcCA9IGlzVmVydGljYWwgPyAnc2Nyb2xsVG9wJyA6ICdzY3JvbGxMZWZ0JztcbiAgICByZXR1cm4gbm9kZSA9PT0gd2luZG93ID8gbm9kZVt3aW5kb3dQcm9wXSA6IG5vZGVbZWxlbWVudFByb3BdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVjdChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgIT09IHdpbmRvdyA/IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7IHRvcDogMCwgbGVmdDogMCwgYm90dG9tOiAwIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlSGVpZ2h0KG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChub2RlID09PSB3aW5kb3cpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUuY2xpZW50SGVpZ2h0O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FmZml4L3V0aWwuanMiLCJpbXBvcnQgJy4uL2ljb24vc3R5bGUuanMnO1xuaW1wb3J0ICcuLi9jaGVja2JveC9zdHlsZS5qcyc7XG5pbXBvcnQgJy4uL3JhZGlvL3N0eWxlLmpzJztcbmltcG9ydCAnLi4vbWVudS9zdHlsZS5qcyc7XG5pbXBvcnQgJy4uL2J1dHRvbi9zdHlsZS5qcyc7XG5pbXBvcnQgJy4uL2Ryb3Bkb3duL3N0eWxlLmpzJztcbmltcG9ydCAnLi4vbG9hZGluZy9zdHlsZS5qcyc7XG5pbXBvcnQgJy4vbWFpbi5zY3NzJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9zdHlsZS5qcyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaWNvbi9tYWluLnNjc3MiLCJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDAuMTguMkBzdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDAuMTguMkBzdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FuaW1hdGUvbWFpbi5zY3NzIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAwLjE4LjJAc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jaGVja2JveC9tYWluLnNjc3MiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDAuMTguMkBzdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JhZGlvL21haW4uc2NzcyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMC4xOC4yQHN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvX3Bvc3Rjc3MtbG9hZGVyQDIuMS42QHBvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0yLTIhLi4vLi4vbm9kZV9tb2R1bGVzL19mYXN0LXNhc3MtbG9hZGVyQDEuNC43QGZhc3Qtc2Fzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWVudS9tYWluLnNjc3MiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDAuMTguMkBzdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2J1dHRvbi9tYWluLnNjc3MiLCJpbXBvcnQgJy4uL292ZXJsYXkvc3R5bGUuanMnO1xuaW1wb3J0ICcuL21haW4uc2Nzcyc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZHJvcGRvd24vc3R5bGUuanMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDAuMTguMkBzdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL292ZXJsYXkvbWFpbi5zY3NzIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAwLjE4LjJAc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9kcm9wZG93bi9tYWluLnNjc3MiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDAuMTguMkBzdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL19wb3N0Y3NzLWxvYWRlckAyLjEuNkBwb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMi0yIS4uLy4uL25vZGVfbW9kdWxlcy9fZmFzdC1zYXNzLWxvYWRlckAxLjQuN0BmYXN0LXNhc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xvYWRpbmcvbWFpbi5zY3NzIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAwLjE4LjJAc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMi4xLjZAcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTItMiEuLi8uLi9ub2RlX21vZHVsZXMvX2Zhc3Qtc2Fzcy1sb2FkZXJAMS40LjdAZmFzdC1zYXNzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90YWJsZS9tYWluLnNjc3MiLCJcbmltcG9ydCBUYWJsZSBmcm9tICcuLi8uLi8uLi9zcmMvdGFibGUnO1xuaW1wb3J0ICcuLi8uLi8uLi9zcmMvdGFibGUvc3R5bGUuanMnO1xuXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuLyogZXNsaW50LWRpc2FibGUgcmVhY3Qvbm8tbXVsdGktY29tcCxyZWFjdC9wcm9wLXR5cGVzICovXG5jb25zdCB7SGVhZGVyLCBDZWxsfSA9IFRhYmxlO1xuY29uc3QgZGF0YVNvdXJjZSA9ICgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICB0aXRsZTogYFF1b3RhdGlvbiBmb3IgMVBDUyBOYW5vICR7MyArIGl9LjAgY29udHJvbGxlciBjb21wYXRpYmxlYCxcbiAgICAgICAgICAgIGlkOiAxMDAzMDY2NjA5NDAgKyBpLFxuICAgICAgICAgICAgdGltZTogMjAwMCArIGlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBBcHBIZWFkZXIgPSAocHJvcHMsIGNvbnRleHQpID0+IHtcbiAgICBjb25zdCB7Y29sdW1uc30gPSBwcm9wcztcbiAgICBjb25zdCB7b25DaGFuZ2V9ID0gY29udGV4dDtcbiAgICBjb25zdCBsZW5ndGggPSBjb2x1bW5zW2NvbHVtbnMubGVuZ3RoIC0gMV0ubGVuZ3RoO1xuICAgIHJldHVybiAoPEhlYWRlciB7Li4ucHJvcHN9PlxuICAgICAgICA8dHI+XG4gICAgICAgICAgICA8Q2VsbCBjb2xTcGFuPXtsZW5ndGh9PlxuICAgICAgICAgICAgICAgIDxhIG9uQ2xpY2s9eygpID0+IG9uQ2hhbmdlKHRydWUpfSBocmVmPVwiamF2YXNjcmlwdDo7XCI+U2VsZWN0IGFsbDwvYT4mbmJzcDtcbiAgICAgICAgICAgICAgICA8YSBvbkNsaWNrPXsoKSA9PiBvbkNoYW5nZShmYWxzZSl9IGhyZWY9XCJqYXZhc2NyaXB0OjtcIj5VbnNlbGVjdCBhbGw8L2E+XG4gICAgICAgICAgICA8L0NlbGw+XG4gICAgICAgIDwvdHI+XG4gICAgPC9IZWFkZXI+KTtcbn07XG5cbkFwcEhlYWRlci5jb250ZXh0VHlwZXMgPSB7XG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5jbGFzcyBBcHAgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jXG4gICAgfVxuICAgIHN0YXRlID0ge1xuICAgICAgICBzZWxlY3RlZEtleXM6IFtdXG4gICAgfVxuICAgIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLm9uQ2hhbmdlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRhdGFTb3VyY2UgPSBkYXRhU291cmNlKClcbiAgICBvbkNoYW5nZSA9IChjaGVja2VkKSA9PiB7XG4gICAgICAgIGxldCBzZWxlY3RlZEtleXMgPSBbXTtcbiAgICAgICAgaWYgKGNoZWNrZWQpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkS2V5cyA9IHRoaXMuZGF0YVNvdXJjZS5tYXAoaXRlbSA9PiBpdGVtLmlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uUm93Q2hhbmdlKHNlbGVjdGVkS2V5cyk7XG4gICAgfVxuICAgIG9uUm93Q2hhbmdlID0gKHNlbGVjdGVkS2V5cykgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHNlbGVjdGVkS2V5c1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKDxzcGFuPlxuICAgICAgICAgICAgPFRhYmxlIGRhdGFTb3VyY2U9e3RoaXMuZGF0YVNvdXJjZX1cbiAgICAgICAgICAgICAgICBjb21wb25lbnRzPXt7XG4gICAgICAgICAgICAgICAgICAgIEhlYWRlcjogQXBwSGVhZGVyXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICByb3dTZWxlY3Rpb249e3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRSb3dLZXlzOiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6IHRoaXMub25Sb3dDaGFuZ2VcbiAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICA8VGFibGUuQ29sdW1uIHRpdGxlPVwiSWRcIiBkYXRhSW5kZXg9XCJpZFwiIC8+XG4gICAgICAgICAgICAgICAgPFRhYmxlLkNvbHVtbiB0aXRsZT1cIlRpdGxlXCIgZGF0YUluZGV4PVwidGl0bGVcIi8+XG4gICAgICAgICAgICAgICAgPFRhYmxlLkNvbHVtbiB0aXRsZT1cIlRpbWVcIiBkYXRhSW5kZXg9XCJ0aW1lXCIvPlxuICAgICAgICAgICAgPC9UYWJsZT5cbiAgICAgICAgPC9zcGFuPik7XG4gICAgfVxufVxuXG5SZWFjdERPTS5yZW5kZXIoPEFwcC8+LCBtb3VudE5vZGUpO1xuXG5cbi8vIEhPVCBSRUxPQUQgQ09ERVxuY29uc3QgY29tcG9uZW50RGVzYyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjb21wb25lbnQtZGVzYycpO1xuY29tcG9uZW50RGVzYy5pbm5lckhUTUwgPSBg6YCa6L+HVGFibGXmmrTpnLLnmoTlrZDnu4Tku7bov5vooYzmianlsZVgO1xuY29uc3QgY29tcG9uZW50Qm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjb21wb25lbnQtYm9keScpO1xuY29tcG9uZW50Qm9keS5pbm5lckhUTUwgPSBgPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLWpzeFwiPjxkaXYgY2xhc3M9XCJobGpzXCI+PHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj5pbXBvcnQ8L3NwYW4+IHsgVGFibGUgfSA8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPmZyb208L3NwYW4+IDxzcGFuIGNsYXNzPVwiaGxqcy1zdHJpbmdcIj4nQGFsaWZkL25leHQnPC9zcGFuPjtcbjxzcGFuIGNsYXNzPVwiaGxqcy1rZXl3b3JkXCI+aW1wb3J0PC9zcGFuPiBQcm9wVHlwZXMgPHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj5mcm9tPC9zcGFuPiA8c3BhbiBjbGFzcz1cImhsanMtc3RyaW5nXCI+J3Byb3AtdHlwZXMnPC9zcGFuPjtcbjxzcGFuIGNsYXNzPVwiaGxqcy1jb21tZW50XCI+LyogZXNsaW50LWRpc2FibGUgcmVhY3Qvbm8tbXVsdGktY29tcCxyZWFjdC9wcm9wLXR5cGVzICovPC9zcGFuPlxuPHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj5jb25zdDwvc3Bhbj4ge0hlYWRlciwgQ2VsbH0gPSBUYWJsZTtcbjxzcGFuIGNsYXNzPVwiaGxqcy1rZXl3b3JkXCI+Y29uc3Q8L3NwYW4+IGRhdGFTb3VyY2UgPSA8c3BhbiBjbGFzcz1cImhsanMtZnVuY3Rpb25cIj48c3BhbiBjbGFzcz1cImhsanMtcGFyYW1zXCI+KCk8L3NwYW4+ID0mZ3Q7PC9zcGFuPiB7XG4gICAgPHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj5jb25zdDwvc3Bhbj4gcmVzdWx0ID0gW107XG4gICAgPHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj5mb3I8L3NwYW4+ICg8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPmxldDwvc3Bhbj4gaSA9IDxzcGFuIGNsYXNzPVwiaGxqcy1udW1iZXJcIj4wPC9zcGFuPjsgaSAmbHQ7IDxzcGFuIGNsYXNzPVwiaGxqcy1udW1iZXJcIj41PC9zcGFuPjsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaGxqcy1hdHRyXCI+dGl0bGU8L3NwYW4+OiA8c3BhbiBjbGFzcz1cImhsanMtc3RyaW5nXCI+e2JhY2txdW90ZX1RdW90YXRpb24gZm9yIDFQQ1MgTmFubyA8c3BhbiBjbGFzcz1cImhsanMtc3Vic3RcIj57ZG9sbGFyfXs8c3BhbiBjbGFzcz1cImhsanMtbnVtYmVyXCI+Mzwvc3Bhbj4gKyBpfTwvc3Bhbj4uMCBjb250cm9sbGVyIGNvbXBhdGlibGV7YmFja3F1b3RlfTwvc3Bhbj4sXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMtYXR0clwiPmlkPC9zcGFuPjogPHNwYW4gY2xhc3M9XCJobGpzLW51bWJlclwiPjEwMDMwNjY2MDk0MDwvc3Bhbj4gKyBpLFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJobGpzLWF0dHJcIj50aW1lPC9zcGFuPjogPHNwYW4gY2xhc3M9XCJobGpzLW51bWJlclwiPjIwMDA8L3NwYW4+ICsgaVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgPHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj5yZXR1cm48L3NwYW4+IHJlc3VsdDtcbn07XG5cbjxzcGFuIGNsYXNzPVwiaGxqcy1rZXl3b3JkXCI+Y29uc3Q8L3NwYW4+IEFwcEhlYWRlciA9IDxzcGFuIGNsYXNzPVwiaGxqcy1mdW5jdGlvblwiPig8c3BhbiBjbGFzcz1cImhsanMtcGFyYW1zXCI+cHJvcHMsIGNvbnRleHQ8L3NwYW4+KSA9Jmd0Ozwvc3Bhbj4ge1xuICAgIDxzcGFuIGNsYXNzPVwiaGxqcy1rZXl3b3JkXCI+Y29uc3Q8L3NwYW4+IHtjb2x1bW5zfSA9IHByb3BzO1xuICAgIDxzcGFuIGNsYXNzPVwiaGxqcy1rZXl3b3JkXCI+Y29uc3Q8L3NwYW4+IHtvbkNoYW5nZX0gPSBjb250ZXh0O1xuICAgIDxzcGFuIGNsYXNzPVwiaGxqcy1rZXl3b3JkXCI+Y29uc3Q8L3NwYW4+IGxlbmd0aCA9IGNvbHVtbnNbY29sdW1ucy5sZW5ndGggLSA8c3BhbiBjbGFzcz1cImhsanMtbnVtYmVyXCI+MTwvc3Bhbj5dLmxlbmd0aDtcbiAgICA8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPnJldHVybjwvc3Bhbj4gKDxzcGFuIGNsYXNzPVwieG1sXCI+PHNwYW4gY2xhc3M9XCJobGpzLXRhZ1wiPiZsdDs8c3BhbiBjbGFzcz1cImhsanMtbmFtZVwiPkhlYWRlcjwvc3Bhbj4gezxzcGFuIGNsYXNzPVwiaGxqcy1hdHRyXCI+Li4ucHJvcHM8L3NwYW4+fSZndDs8L3NwYW4+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaGxqcy10YWdcIj4mbHQ7PHNwYW4gY2xhc3M9XCJobGpzLW5hbWVcIj50cjwvc3Bhbj4mZ3Q7PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJobGpzLXRhZ1wiPiZsdDs8c3BhbiBjbGFzcz1cImhsanMtbmFtZVwiPkNlbGw8L3NwYW4+IDxzcGFuIGNsYXNzPVwiaGxqcy1hdHRyXCI+Y29sU3Bhbjwvc3Bhbj49PHNwYW4gY2xhc3M9XCJobGpzLXN0cmluZ1wiPntsZW5ndGh9PC9zcGFuPiZndDs8L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJobGpzLXRhZ1wiPiZsdDs8c3BhbiBjbGFzcz1cImhsanMtbmFtZVwiPmE8L3NwYW4+IDxzcGFuIGNsYXNzPVwiaGxqcy1hdHRyXCI+b25DbGljazwvc3Bhbj49PHNwYW4gY2xhc3M9XCJobGpzLXN0cmluZ1wiPnsoKTwvc3Bhbj4gPSZndDs8L3NwYW4+IG9uQ2hhbmdlKHRydWUpfSBocmVmPVwiamF2YXNjcmlwdDo7XCImZ3Q7U2VsZWN0IGFsbDxzcGFuIGNsYXNzPVwiaGxqcy10YWdcIj4mbHQ7LzxzcGFuIGNsYXNzPVwiaGxqcy1uYW1lXCI+YTwvc3Bhbj4mZ3Q7PC9zcGFuPiZhbXA7bmJzcDtcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMtdGFnXCI+Jmx0OzxzcGFuIGNsYXNzPVwiaGxqcy1uYW1lXCI+YTwvc3Bhbj4gPHNwYW4gY2xhc3M9XCJobGpzLWF0dHJcIj5vbkNsaWNrPC9zcGFuPj08c3BhbiBjbGFzcz1cImhsanMtc3RyaW5nXCI+eygpPC9zcGFuPiA9Jmd0Ozwvc3Bhbj4gb25DaGFuZ2UoZmFsc2UpfSBocmVmPVwiamF2YXNjcmlwdDo7XCImZ3Q7VW5zZWxlY3QgYWxsPHNwYW4gY2xhc3M9XCJobGpzLXRhZ1wiPiZsdDsvPHNwYW4gY2xhc3M9XCJobGpzLW5hbWVcIj5hPC9zcGFuPiZndDs8L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMtdGFnXCI+Jmx0Oy88c3BhbiBjbGFzcz1cImhsanMtbmFtZVwiPkNlbGw8L3NwYW4+Jmd0Ozwvc3Bhbj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJobGpzLXRhZ1wiPiZsdDsvPHNwYW4gY2xhc3M9XCJobGpzLW5hbWVcIj50cjwvc3Bhbj4mZ3Q7PC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwiaGxqcy10YWdcIj4mbHQ7LzxzcGFuIGNsYXNzPVwiaGxqcy1uYW1lXCI+SGVhZGVyPC9zcGFuPiZndDs8L3NwYW4+PC9zcGFuPik7XG59O1xuXG5BcHBIZWFkZXIuY29udGV4dFR5cGVzID0ge1xuICAgIDxzcGFuIGNsYXNzPVwiaGxqcy1hdHRyXCI+b25DaGFuZ2U8L3NwYW4+OiBQcm9wVHlwZXMuZnVuY1xufTtcblxuPHNwYW4gY2xhc3M9XCJobGpzLWNsYXNzXCI+PHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj5jbGFzczwvc3Bhbj4gPHNwYW4gY2xhc3M9XCJobGpzLXRpdGxlXCI+QXBwPC9zcGFuPiA8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPmV4dGVuZHM8L3NwYW4+IDxzcGFuIGNsYXNzPVwiaGxqcy10aXRsZVwiPlJlYWN0PC9zcGFuPi48c3BhbiBjbGFzcz1cImhsanMtdGl0bGVcIj5Db21wb25lbnQ8L3NwYW4+IDwvc3Bhbj57XG4gICAgPHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj5zdGF0aWM8L3NwYW4+IGNoaWxkQ29udGV4dFR5cGVzID0ge1xuICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMtYXR0clwiPm9uQ2hhbmdlPC9zcGFuPjogUHJvcFR5cGVzLmZ1bmNcbiAgICB9XG4gICAgc3RhdGUgPSB7XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaGxqcy1hdHRyXCI+c2VsZWN0ZWRLZXlzPC9zcGFuPjogW11cbiAgICB9XG4gICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPnJldHVybjwvc3Bhbj4ge1xuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJobGpzLWF0dHJcIj5vbkNoYW5nZTwvc3Bhbj46IDxzcGFuIGNsYXNzPVwiaGxqcy1rZXl3b3JkXCI+dGhpczwvc3Bhbj4ub25DaGFuZ2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2UoKVxuICAgIG9uQ2hhbmdlID0gPHNwYW4gY2xhc3M9XCJobGpzLWZ1bmN0aW9uXCI+KDxzcGFuIGNsYXNzPVwiaGxqcy1wYXJhbXNcIj5jaGVja2VkPC9zcGFuPikgPSZndDs8L3NwYW4+IHtcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj5sZXQ8L3NwYW4+IHNlbGVjdGVkS2V5cyA9IFtdO1xuICAgICAgICA8c3BhbiBjbGFzcz1cImhsanMta2V5d29yZFwiPmlmPC9zcGFuPiAoY2hlY2tlZCkge1xuICAgICAgICAgICAgc2VsZWN0ZWRLZXlzID0gPHNwYW4gY2xhc3M9XCJobGpzLWtleXdvcmRcIj50aGlzPC9zcGFuPi5kYXRhU291cmNlLm1hcCg8c3BhbiBjbGFzcz1cImhsanMtZnVuY3Rpb25cIj48c3BhbiBjbGFzcz1cImhsanMtcGFyYW1zXCI+aXRlbTwvc3Bhbj4gPSZndDs8L3NwYW4+IGl0ZW0uaWQpO1xuICAgICAgICB9XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaGxqcy1rZXl3b3JkXCI+dGhpczwvc3Bhbj4ub25Sb3dDaGFuZ2Uoc2VsZWN0ZWRLZXlzKTtcbiAgICB9XG4gICAgb25Sb3dDaGFuZ2UgPSA8c3BhbiBjbGFzcz1cImhsanMtZnVuY3Rpb25cIj4oPHNwYW4gY2xhc3M9XCJobGpzLXBhcmFtc1wiPnNlbGVjdGVkS2V5czwvc3Bhbj4pID0mZ3Q7PC9zcGFuPiB7XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaGxqcy1rZXl3b3JkXCI+dGhpczwvc3Bhbj4uc2V0U3RhdGUoe1xuICAgICAgICAgICAgc2VsZWN0ZWRLZXlzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaGxqcy1rZXl3b3JkXCI+cmV0dXJuPC9zcGFuPiAoJmx0O3NwYW4mZ3Q7XG4gICAgICAgICAgICAmbHQ7VGFibGUgZGF0YVNvdXJjZT17dGhpcy5kYXRhU291cmNlfVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM9e3tcbiAgICAgICAgICAgICAgICAgICAgSGVhZGVyOiBBcHBIZWFkZXJcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd1NlbGVjdGlvbj17e1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd0tleXM6IHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzLFxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTogdGhpcy5vblJvd0NoYW5nZVxuICAgICAgICAgICAgICAgIH19Jmd0O1xuICAgICAgICAgICAgICAgICZsdDtUYWJsZS5Db2x1bW4gdGl0bGU9XCJJZFwiIGRhdGFJbmRleD1cImlkXCIgLyZndDtcbiAgICAgICAgICAgICAgICAmbHQ7VGFibGUuQ29sdW1uIHRpdGxlPVwiVGl0bGVcIiBkYXRhSW5kZXg9XCJ0aXRsZVwiLyZndDtcbiAgICAgICAgICAgICAgICAmbHQ7VGFibGUuQ29sdW1uIHRpdGxlPVwiVGltZVwiIGRhdGFJbmRleD1cInRpbWVcIi8mZ3Q7XG4gICAgICAgICAgICAmbHQ7L1RhYmxlJmd0O1xuICAgICAgICAmbHQ7L3NwYW4mZ3Q7KTtcbiAgICB9XG59XG5cblJlYWN0RE9NLnJlbmRlcigmbHQ7QXBwLyZndDssIG1vdW50Tm9kZSk7XG48L2Rpdj48L2NvZGU+PC9wcmU+XG5gLnJlcGxhY2UoL3tiYWNrcXVvdGV9L2csICdgJykucmVwbGFjZSgve2RvbGxhcn0vZywgJyQnKTtcblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKTtcblxuICBjb25zdCByZWxvYWRpbmcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbmV4dC1kZW1vLXJlbG9hZGluZycpO1xuXG4gIGlmICghd2luZG93Lmhhc0FkZFN0YXR1c0hhbmRsZXIpIHtcbiAgICBtb2R1bGUuaG90LmFkZFN0YXR1c0hhbmRsZXIoc3RhdHVzID0+IHtcbiAgICAgIHdpbmRvdy5oYXNBZGRTdGF0dXNIYW5kbGVyID0gdHJ1ZTtcbiAgICAgIGlmIChzdGF0dXMgPT09ICdjaGVjaycpIHtcbiAgICAgICAgcmVsb2FkaW5nLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09ICdpZGxlJykge1xuICAgICAgICByZWxvYWRpbmcuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RvY3MvdGFibGUvZGVtby9hZHZhbmNlZC5tZCJdLCJzb3VyY2VSb290IjoiIn0=